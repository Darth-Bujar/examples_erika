#line 1 "D:/RTOS_PROJEKT/erica/aurix_workspace/can_erika/ee/../Libraries/iLLD/TC38A/Tricore/Scu/Std/IfxScuWdt.c"
/**
 * \file IfxScuWdt.c
 * \brief SCU  basic functionality
 *
 * \version iLLD_1_0_1_15_0_1
 * \copyright Copyright (c) 2022 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 *
 */

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/


#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\ee\\..\\Libraries\\iLLD\\TC38A\\Tricore\\Scu\\Std\\IfxScuWdt.h"
/**
 * \file IfxScuWdt.h
 * \brief SCU  basic functionality
 * \ingroup IfxLld_Scu
 *
 * \version iLLD_1_0_1_15_0_1
 * \copyright Copyright (c) 2019 Infineon Technologies AG. All rights reserved.
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 * This file contains the APIs for SCU Watchdog and Endinit related functions.
 *
 * \defgroup IfxLld_Scu_Std_Wdt Wdt Basic Functionality
 * \ingroup IfxLld_Scu_Std
 * \defgroup IfxLld_Scu_Std_Wdt_Wdt_Configuration Watchdog Configuration functions
 * \ingroup IfxLld_Scu_Std_Wdt
 * \defgroup IfxLld_Scu_Std_Wdt_Wdt_Endinit Watchdog Endinit functions
 * \ingroup IfxLld_Scu_Std_Wdt
 * \defgroup IfxLld_Scu_Std_Wdt_Wdt_Operative Watchdog Operative functions
 * \ingroup IfxLld_Scu_Std_Wdt
 * \defgroup IfxLld_Scu_Std_Wdt_Wdt_Endinit_Usage How to use Endinit APIs?
 * \ingroup IfxLld_Scu_Std_Wdt
 */




/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/


#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\_Impl\\IfxScu_cfg.h"
/**
 * \file IfxScu_cfg.h
 * \brief SCU on-chip implementation data
 * \ingroup IfxLld_Scu
 *
 * \version iLLD_1_0_1_15_0_1
 * \copyright Copyright (c) 2012 Infineon Technologies AG. All rights reserved.
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * \defgroup IfxLld_Scu SCU
 * \ingroup IfxLld
 * \defgroup IfxLld_Scu_Impl Implementation
 * \ingroup IfxLld_Scu
 * \defgroup IfxLld_Scu_Std Standard Driver
 * \ingroup IfxLld_Scu
 */



/******************************************************************************/

#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Configurations\\Ifx_Cfg.h"
/**********************************************************************************************************************
 * \file Ifx_Cfg.h
 * \brief Project configuration file.
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/




/*********************************************************************************************************************/
/*------------------------------------------Configuration for IfxScu_cfg.h-------------------------------------------*/
/*********************************************************************************************************************/
/* External oscillator frequency in Hz */

/* System PLL frequency in Hz */


/* Peripheral PLL1 frequency in Hz */

/* Peripheral PLL2 frequency in Hz */


/*********************************************************************************************************************/
/*-----------------------------------Configuration for Software managed interrupt------------------------------------*/
/*********************************************************************************************************************/
/* #define IFX_USE_SW_MANAGED_INT */ /* Decomment this line if the project needs to use Software managed interrupts */

/*********************************************************************************************************************/
/*---------------------------------Configuration for Trap Hook Functions' Extensions---------------------------------*/
/*********************************************************************************************************************/
/* #define IFX_CFG_EXTEND_TRAP_HOOKS */ /* Decomment this line if the project needs to extend trap hook functions */


#line 53 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\_Impl\\IfxScu_cfg.h"

#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\Infra\\Sfr\\TC38A\\_Reg\\IfxScu_bf.h"
/**
 * \file IfxScu_bf.h
 * \brief
 * \copyright Copyright (c) 2020 Infineon Technologies AG. All rights reserved.
 *
 *
 * Version: TC38XA_UM_V1.5.0
 * Specification: TC3xx User Manual V1.5.0
 * MAY BE CHANGED BY USER [yes/no]: No
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * \defgroup IfxSfr_Scu_Registers_BitfieldsMask Bitfields mask and offset
 * \ingroup IfxSfr_Scu_Registers
 * 
 */



/******************************************************************************/

/******************************************************************************/

/** \addtogroup IfxSfr_Scu_Registers_BitfieldsMask
 * \{  */
/** \brief Length for Ifx_SCU_ID_Bits.MODREV */


/** \brief Mask for Ifx_SCU_ID_Bits.MODREV */


/** \brief Offset for Ifx_SCU_ID_Bits.MODREV */


/** \brief Length for Ifx_SCU_ID_Bits.MODTYPE */


/** \brief Mask for Ifx_SCU_ID_Bits.MODTYPE */


/** \brief Offset for Ifx_SCU_ID_Bits.MODTYPE */


/** \brief Length for Ifx_SCU_ID_Bits.MODNUMBER */


/** \brief Mask for Ifx_SCU_ID_Bits.MODNUMBER */


/** \brief Offset for Ifx_SCU_ID_Bits.MODNUMBER */


/** \brief Length for Ifx_SCU_OSCCON_Bits.PLLLV */


/** \brief Mask for Ifx_SCU_OSCCON_Bits.PLLLV */


/** \brief Offset for Ifx_SCU_OSCCON_Bits.PLLLV */


/** \brief Length for Ifx_SCU_OSCCON_Bits.OSCRES */


/** \brief Mask for Ifx_SCU_OSCCON_Bits.OSCRES */


/** \brief Offset for Ifx_SCU_OSCCON_Bits.OSCRES */


/** \brief Length for Ifx_SCU_OSCCON_Bits.GAINSEL */


/** \brief Mask for Ifx_SCU_OSCCON_Bits.GAINSEL */


/** \brief Offset for Ifx_SCU_OSCCON_Bits.GAINSEL */


/** \brief Length for Ifx_SCU_OSCCON_Bits.MODE */


/** \brief Mask for Ifx_SCU_OSCCON_Bits.MODE */


/** \brief Offset for Ifx_SCU_OSCCON_Bits.MODE */


/** \brief Length for Ifx_SCU_OSCCON_Bits.SHBY */


/** \brief Mask for Ifx_SCU_OSCCON_Bits.SHBY */


/** \brief Offset for Ifx_SCU_OSCCON_Bits.SHBY */


/** \brief Length for Ifx_SCU_OSCCON_Bits.PLLHV */


/** \brief Mask for Ifx_SCU_OSCCON_Bits.PLLHV */


/** \brief Offset for Ifx_SCU_OSCCON_Bits.PLLHV */


/** \brief Length for Ifx_SCU_OSCCON_Bits.HYSEN */


/** \brief Mask for Ifx_SCU_OSCCON_Bits.HYSEN */


/** \brief Offset for Ifx_SCU_OSCCON_Bits.HYSEN */


/** \brief Length for Ifx_SCU_OSCCON_Bits.HYSCTL */


/** \brief Mask for Ifx_SCU_OSCCON_Bits.HYSCTL */


/** \brief Offset for Ifx_SCU_OSCCON_Bits.HYSCTL */


/** \brief Length for Ifx_SCU_OSCCON_Bits.AMPCTL */


/** \brief Mask for Ifx_SCU_OSCCON_Bits.AMPCTL */


/** \brief Offset for Ifx_SCU_OSCCON_Bits.AMPCTL */


/** \brief Length for Ifx_SCU_OSCCON_Bits.OSCVAL */


/** \brief Mask for Ifx_SCU_OSCCON_Bits.OSCVAL */


/** \brief Offset for Ifx_SCU_OSCCON_Bits.OSCVAL */


/** \brief Length for Ifx_SCU_OSCCON_Bits.APREN */


/** \brief Mask for Ifx_SCU_OSCCON_Bits.APREN */


/** \brief Offset for Ifx_SCU_OSCCON_Bits.APREN */


/** \brief Length for Ifx_SCU_OSCCON_Bits.CAP0EN */


/** \brief Mask for Ifx_SCU_OSCCON_Bits.CAP0EN */


/** \brief Offset for Ifx_SCU_OSCCON_Bits.CAP0EN */


/** \brief Length for Ifx_SCU_OSCCON_Bits.CAP1EN */


/** \brief Mask for Ifx_SCU_OSCCON_Bits.CAP1EN */


/** \brief Offset for Ifx_SCU_OSCCON_Bits.CAP1EN */


/** \brief Length for Ifx_SCU_OSCCON_Bits.CAP2EN */


/** \brief Mask for Ifx_SCU_OSCCON_Bits.CAP2EN */


/** \brief Offset for Ifx_SCU_OSCCON_Bits.CAP2EN */


/** \brief Length for Ifx_SCU_OSCCON_Bits.CAP3EN */


/** \brief Mask for Ifx_SCU_OSCCON_Bits.CAP3EN */


/** \brief Offset for Ifx_SCU_OSCCON_Bits.CAP3EN */


/** \brief Length for Ifx_SCU_SYSPLLSTAT_Bits.PWDSTAT */


/** \brief Mask for Ifx_SCU_SYSPLLSTAT_Bits.PWDSTAT */


/** \brief Offset for Ifx_SCU_SYSPLLSTAT_Bits.PWDSTAT */


/** \brief Length for Ifx_SCU_SYSPLLSTAT_Bits.LOCK */


/** \brief Mask for Ifx_SCU_SYSPLLSTAT_Bits.LOCK */


/** \brief Offset for Ifx_SCU_SYSPLLSTAT_Bits.LOCK */


/** \brief Length for Ifx_SCU_SYSPLLSTAT_Bits.K2RDY */


/** \brief Mask for Ifx_SCU_SYSPLLSTAT_Bits.K2RDY */


/** \brief Offset for Ifx_SCU_SYSPLLSTAT_Bits.K2RDY */


/** \brief Length for Ifx_SCU_SYSPLLSTAT_Bits.MODRUN */


/** \brief Mask for Ifx_SCU_SYSPLLSTAT_Bits.MODRUN */


/** \brief Offset for Ifx_SCU_SYSPLLSTAT_Bits.MODRUN */


/** \brief Length for Ifx_SCU_SYSPLLCON0_Bits.MODEN */


/** \brief Mask for Ifx_SCU_SYSPLLCON0_Bits.MODEN */


/** \brief Offset for Ifx_SCU_SYSPLLCON0_Bits.MODEN */


/** \brief Length for Ifx_SCU_SYSPLLCON0_Bits.NDIV */


/** \brief Mask for Ifx_SCU_SYSPLLCON0_Bits.NDIV */


/** \brief Offset for Ifx_SCU_SYSPLLCON0_Bits.NDIV */


/** \brief Length for Ifx_SCU_SYSPLLCON0_Bits.PLLPWD */


/** \brief Mask for Ifx_SCU_SYSPLLCON0_Bits.PLLPWD */


/** \brief Offset for Ifx_SCU_SYSPLLCON0_Bits.PLLPWD */


/** \brief Length for Ifx_SCU_SYSPLLCON0_Bits.RESLD */


/** \brief Mask for Ifx_SCU_SYSPLLCON0_Bits.RESLD */


/** \brief Offset for Ifx_SCU_SYSPLLCON0_Bits.RESLD */


/** \brief Length for Ifx_SCU_SYSPLLCON0_Bits.PDIV */


/** \brief Mask for Ifx_SCU_SYSPLLCON0_Bits.PDIV */


/** \brief Offset for Ifx_SCU_SYSPLLCON0_Bits.PDIV */


/** \brief Length for Ifx_SCU_SYSPLLCON0_Bits.INSEL */


/** \brief Mask for Ifx_SCU_SYSPLLCON0_Bits.INSEL */


/** \brief Offset for Ifx_SCU_SYSPLLCON0_Bits.INSEL */


/** \brief Length for Ifx_SCU_SYSPLLCON1_Bits.K2DIV */


/** \brief Mask for Ifx_SCU_SYSPLLCON1_Bits.K2DIV */


/** \brief Offset for Ifx_SCU_SYSPLLCON1_Bits.K2DIV */


/** \brief Length for Ifx_SCU_SYSPLLCON2_Bits.MODCFG */


/** \brief Mask for Ifx_SCU_SYSPLLCON2_Bits.MODCFG */


/** \brief Offset for Ifx_SCU_SYSPLLCON2_Bits.MODCFG */


/** \brief Length for Ifx_SCU_PERPLLSTAT_Bits.PWDSTAT */


/** \brief Mask for Ifx_SCU_PERPLLSTAT_Bits.PWDSTAT */


/** \brief Offset for Ifx_SCU_PERPLLSTAT_Bits.PWDSTAT */


/** \brief Length for Ifx_SCU_PERPLLSTAT_Bits.LOCK */


/** \brief Mask for Ifx_SCU_PERPLLSTAT_Bits.LOCK */


/** \brief Offset for Ifx_SCU_PERPLLSTAT_Bits.LOCK */


/** \brief Length for Ifx_SCU_PERPLLSTAT_Bits.K3RDY */


/** \brief Mask for Ifx_SCU_PERPLLSTAT_Bits.K3RDY */


/** \brief Offset for Ifx_SCU_PERPLLSTAT_Bits.K3RDY */


/** \brief Length for Ifx_SCU_PERPLLSTAT_Bits.K2RDY */


/** \brief Mask for Ifx_SCU_PERPLLSTAT_Bits.K2RDY */


/** \brief Offset for Ifx_SCU_PERPLLSTAT_Bits.K2RDY */


/** \brief Length for Ifx_SCU_PERPLLCON0_Bits.DIVBY */


/** \brief Mask for Ifx_SCU_PERPLLCON0_Bits.DIVBY */


/** \brief Offset for Ifx_SCU_PERPLLCON0_Bits.DIVBY */


/** \brief Length for Ifx_SCU_PERPLLCON0_Bits.NDIV */


/** \brief Mask for Ifx_SCU_PERPLLCON0_Bits.NDIV */


/** \brief Offset for Ifx_SCU_PERPLLCON0_Bits.NDIV */


/** \brief Length for Ifx_SCU_PERPLLCON0_Bits.PLLPWD */


/** \brief Mask for Ifx_SCU_PERPLLCON0_Bits.PLLPWD */


/** \brief Offset for Ifx_SCU_PERPLLCON0_Bits.PLLPWD */


/** \brief Length for Ifx_SCU_PERPLLCON0_Bits.RESLD */


/** \brief Mask for Ifx_SCU_PERPLLCON0_Bits.RESLD */


/** \brief Offset for Ifx_SCU_PERPLLCON0_Bits.RESLD */


/** \brief Length for Ifx_SCU_PERPLLCON0_Bits.PDIV */


/** \brief Mask for Ifx_SCU_PERPLLCON0_Bits.PDIV */


/** \brief Offset for Ifx_SCU_PERPLLCON0_Bits.PDIV */


/** \brief Length for Ifx_SCU_PERPLLCON1_Bits.K2DIV */


/** \brief Mask for Ifx_SCU_PERPLLCON1_Bits.K2DIV */


/** \brief Offset for Ifx_SCU_PERPLLCON1_Bits.K2DIV */


/** \brief Length for Ifx_SCU_PERPLLCON1_Bits.K3DIV */


/** \brief Mask for Ifx_SCU_PERPLLCON1_Bits.K3DIV */


/** \brief Offset for Ifx_SCU_PERPLLCON1_Bits.K3DIV */


/** \brief Length for Ifx_SCU_CCUCON0_Bits.STMDIV */


/** \brief Mask for Ifx_SCU_CCUCON0_Bits.STMDIV */


/** \brief Offset for Ifx_SCU_CCUCON0_Bits.STMDIV */


/** \brief Length for Ifx_SCU_CCUCON0_Bits.GTMDIV */


/** \brief Mask for Ifx_SCU_CCUCON0_Bits.GTMDIV */


/** \brief Offset for Ifx_SCU_CCUCON0_Bits.GTMDIV */


/** \brief Length for Ifx_SCU_CCUCON0_Bits.SRIDIV */


/** \brief Mask for Ifx_SCU_CCUCON0_Bits.SRIDIV */


/** \brief Offset for Ifx_SCU_CCUCON0_Bits.SRIDIV */


/** \brief Length for Ifx_SCU_CCUCON0_Bits.LPDIV */


/** \brief Mask for Ifx_SCU_CCUCON0_Bits.LPDIV */


/** \brief Offset for Ifx_SCU_CCUCON0_Bits.LPDIV */


/** \brief Length for Ifx_SCU_CCUCON0_Bits.SPBDIV */


/** \brief Mask for Ifx_SCU_CCUCON0_Bits.SPBDIV */


/** \brief Offset for Ifx_SCU_CCUCON0_Bits.SPBDIV */


/** \brief Length for Ifx_SCU_CCUCON0_Bits.BBBDIV */


/** \brief Mask for Ifx_SCU_CCUCON0_Bits.BBBDIV */


/** \brief Offset for Ifx_SCU_CCUCON0_Bits.BBBDIV */


/** \brief Length for Ifx_SCU_CCUCON0_Bits.FSIDIV */


/** \brief Mask for Ifx_SCU_CCUCON0_Bits.FSIDIV */


/** \brief Offset for Ifx_SCU_CCUCON0_Bits.FSIDIV */


/** \brief Length for Ifx_SCU_CCUCON0_Bits.FSI2DIV */


/** \brief Mask for Ifx_SCU_CCUCON0_Bits.FSI2DIV */


/** \brief Offset for Ifx_SCU_CCUCON0_Bits.FSI2DIV */


/** \brief Length for Ifx_SCU_CCUCON0_Bits.CLKSEL */


/** \brief Mask for Ifx_SCU_CCUCON0_Bits.CLKSEL */


/** \brief Offset for Ifx_SCU_CCUCON0_Bits.CLKSEL */


/** \brief Length for Ifx_SCU_CCUCON0_Bits.UP */


/** \brief Mask for Ifx_SCU_CCUCON0_Bits.UP */


/** \brief Offset for Ifx_SCU_CCUCON0_Bits.UP */


/** \brief Length for Ifx_SCU_CCUCON0_Bits.LCK */


/** \brief Mask for Ifx_SCU_CCUCON0_Bits.LCK */


/** \brief Offset for Ifx_SCU_CCUCON0_Bits.LCK */


/** \brief Length for Ifx_SCU_CCUCON1_Bits.MCANDIV */


/** \brief Mask for Ifx_SCU_CCUCON1_Bits.MCANDIV */


/** \brief Offset for Ifx_SCU_CCUCON1_Bits.MCANDIV */


/** \brief Length for Ifx_SCU_CCUCON1_Bits.CLKSELMCAN */


/** \brief Mask for Ifx_SCU_CCUCON1_Bits.CLKSELMCAN */


/** \brief Offset for Ifx_SCU_CCUCON1_Bits.CLKSELMCAN */


/** \brief Length for Ifx_SCU_CCUCON1_Bits.PLL1DIVDIS */


/** \brief Mask for Ifx_SCU_CCUCON1_Bits.PLL1DIVDIS */


/** \brief Offset for Ifx_SCU_CCUCON1_Bits.PLL1DIVDIS */


/** \brief Length for Ifx_SCU_CCUCON1_Bits.I2CDIV */


/** \brief Mask for Ifx_SCU_CCUCON1_Bits.I2CDIV */


/** \brief Offset for Ifx_SCU_CCUCON1_Bits.I2CDIV */


/** \brief Length for Ifx_SCU_CCUCON1_Bits.MSCDIV */


/** \brief Mask for Ifx_SCU_CCUCON1_Bits.MSCDIV */


/** \brief Offset for Ifx_SCU_CCUCON1_Bits.MSCDIV */


/** \brief Length for Ifx_SCU_CCUCON1_Bits.CLKSELMSC */


/** \brief Mask for Ifx_SCU_CCUCON1_Bits.CLKSELMSC */


/** \brief Offset for Ifx_SCU_CCUCON1_Bits.CLKSELMSC */


/** \brief Length for Ifx_SCU_CCUCON1_Bits.QSPIDIV */


/** \brief Mask for Ifx_SCU_CCUCON1_Bits.QSPIDIV */


/** \brief Offset for Ifx_SCU_CCUCON1_Bits.QSPIDIV */


/** \brief Length for Ifx_SCU_CCUCON1_Bits.CLKSELQSPI */


/** \brief Mask for Ifx_SCU_CCUCON1_Bits.CLKSELQSPI */


/** \brief Offset for Ifx_SCU_CCUCON1_Bits.CLKSELQSPI */


/** \brief Length for Ifx_SCU_CCUCON1_Bits.LCK */


/** \brief Mask for Ifx_SCU_CCUCON1_Bits.LCK */


/** \brief Offset for Ifx_SCU_CCUCON1_Bits.LCK */


/** \brief Length for Ifx_SCU_FDR_Bits.STEP */


/** \brief Mask for Ifx_SCU_FDR_Bits.STEP */


/** \brief Offset for Ifx_SCU_FDR_Bits.STEP */


/** \brief Length for Ifx_SCU_FDR_Bits.DM */


/** \brief Mask for Ifx_SCU_FDR_Bits.DM */


/** \brief Offset for Ifx_SCU_FDR_Bits.DM */


/** \brief Length for Ifx_SCU_FDR_Bits.RESULT */


/** \brief Mask for Ifx_SCU_FDR_Bits.RESULT */


/** \brief Offset for Ifx_SCU_FDR_Bits.RESULT */


/** \brief Length for Ifx_SCU_FDR_Bits.DISCLK */


/** \brief Mask for Ifx_SCU_FDR_Bits.DISCLK */


/** \brief Offset for Ifx_SCU_FDR_Bits.DISCLK */


/** \brief Length for Ifx_SCU_EXTCON_Bits.EN0 */


/** \brief Mask for Ifx_SCU_EXTCON_Bits.EN0 */


/** \brief Offset for Ifx_SCU_EXTCON_Bits.EN0 */


/** \brief Length for Ifx_SCU_EXTCON_Bits.SEL0 */


/** \brief Mask for Ifx_SCU_EXTCON_Bits.SEL0 */


/** \brief Offset for Ifx_SCU_EXTCON_Bits.SEL0 */


/** \brief Length for Ifx_SCU_EXTCON_Bits.EN1 */


/** \brief Mask for Ifx_SCU_EXTCON_Bits.EN1 */


/** \brief Offset for Ifx_SCU_EXTCON_Bits.EN1 */


/** \brief Length for Ifx_SCU_EXTCON_Bits.NSEL */


/** \brief Mask for Ifx_SCU_EXTCON_Bits.NSEL */


/** \brief Offset for Ifx_SCU_EXTCON_Bits.NSEL */


/** \brief Length for Ifx_SCU_EXTCON_Bits.SEL1 */


/** \brief Mask for Ifx_SCU_EXTCON_Bits.SEL1 */


/** \brief Offset for Ifx_SCU_EXTCON_Bits.SEL1 */


/** \brief Length for Ifx_SCU_EXTCON_Bits.DIV1 */


/** \brief Mask for Ifx_SCU_EXTCON_Bits.DIV1 */


/** \brief Offset for Ifx_SCU_EXTCON_Bits.DIV1 */


/** \brief Length for Ifx_SCU_CCUCON2_Bits.ASCLINFDIV */


/** \brief Mask for Ifx_SCU_CCUCON2_Bits.ASCLINFDIV */


/** \brief Offset for Ifx_SCU_CCUCON2_Bits.ASCLINFDIV */


/** \brief Length for Ifx_SCU_CCUCON2_Bits.ASCLINSDIV */


/** \brief Mask for Ifx_SCU_CCUCON2_Bits.ASCLINSDIV */


/** \brief Offset for Ifx_SCU_CCUCON2_Bits.ASCLINSDIV */


/** \brief Length for Ifx_SCU_CCUCON2_Bits.CLKSELASCLINS */


/** \brief Mask for Ifx_SCU_CCUCON2_Bits.CLKSELASCLINS */


/** \brief Offset for Ifx_SCU_CCUCON2_Bits.CLKSELASCLINS */


/** \brief Length for Ifx_SCU_CCUCON2_Bits.ERAYPERON */


/** \brief Mask for Ifx_SCU_CCUCON2_Bits.ERAYPERON */


/** \brief Offset for Ifx_SCU_CCUCON2_Bits.ERAYPERON */


/** \brief Length for Ifx_SCU_CCUCON2_Bits.LCK */


/** \brief Mask for Ifx_SCU_CCUCON2_Bits.LCK */


/** \brief Offset for Ifx_SCU_CCUCON2_Bits.LCK */


/** \brief Length for Ifx_SCU_CCUCON3_Bits.PLL0MONEN */


/** \brief Mask for Ifx_SCU_CCUCON3_Bits.PLL0MONEN */


/** \brief Offset for Ifx_SCU_CCUCON3_Bits.PLL0MONEN */


/** \brief Length for Ifx_SCU_CCUCON3_Bits.PLL1MONEN */


/** \brief Mask for Ifx_SCU_CCUCON3_Bits.PLL1MONEN */


/** \brief Offset for Ifx_SCU_CCUCON3_Bits.PLL1MONEN */


/** \brief Length for Ifx_SCU_CCUCON3_Bits.PLL2MONEN */


/** \brief Mask for Ifx_SCU_CCUCON3_Bits.PLL2MONEN */


/** \brief Offset for Ifx_SCU_CCUCON3_Bits.PLL2MONEN */


/** \brief Length for Ifx_SCU_CCUCON3_Bits.SPBMONEN */


/** \brief Mask for Ifx_SCU_CCUCON3_Bits.SPBMONEN */


/** \brief Offset for Ifx_SCU_CCUCON3_Bits.SPBMONEN */


/** \brief Length for Ifx_SCU_CCUCON3_Bits.BACKMONEN */


/** \brief Mask for Ifx_SCU_CCUCON3_Bits.BACKMONEN */


/** \brief Offset for Ifx_SCU_CCUCON3_Bits.BACKMONEN */


/** \brief Length for Ifx_SCU_CCUCON3_Bits.PLL0MONTST */


/** \brief Mask for Ifx_SCU_CCUCON3_Bits.PLL0MONTST */


/** \brief Offset for Ifx_SCU_CCUCON3_Bits.PLL0MONTST */


/** \brief Length for Ifx_SCU_CCUCON3_Bits.PLL1MONTST */


/** \brief Mask for Ifx_SCU_CCUCON3_Bits.PLL1MONTST */


/** \brief Offset for Ifx_SCU_CCUCON3_Bits.PLL1MONTST */


/** \brief Length for Ifx_SCU_CCUCON3_Bits.PLL2MONTST */


/** \brief Mask for Ifx_SCU_CCUCON3_Bits.PLL2MONTST */


/** \brief Offset for Ifx_SCU_CCUCON3_Bits.PLL2MONTST */


/** \brief Length for Ifx_SCU_CCUCON3_Bits.SPBMONTST */


/** \brief Mask for Ifx_SCU_CCUCON3_Bits.SPBMONTST */


/** \brief Offset for Ifx_SCU_CCUCON3_Bits.SPBMONTST */


/** \brief Length for Ifx_SCU_CCUCON3_Bits.BACKMONTST */


/** \brief Mask for Ifx_SCU_CCUCON3_Bits.BACKMONTST */


/** \brief Offset for Ifx_SCU_CCUCON3_Bits.BACKMONTST */


/** \brief Length for Ifx_SCU_CCUCON3_Bits.UP */


/** \brief Mask for Ifx_SCU_CCUCON3_Bits.UP */


/** \brief Offset for Ifx_SCU_CCUCON3_Bits.UP */


/** \brief Length for Ifx_SCU_CCUCON3_Bits.LCK */


/** \brief Mask for Ifx_SCU_CCUCON3_Bits.LCK */


/** \brief Offset for Ifx_SCU_CCUCON3_Bits.LCK */


/** \brief Length for Ifx_SCU_CCUCON4_Bits.LOTHR */


/** \brief Mask for Ifx_SCU_CCUCON4_Bits.LOTHR */


/** \brief Offset for Ifx_SCU_CCUCON4_Bits.LOTHR */


/** \brief Length for Ifx_SCU_CCUCON4_Bits.UPTHR */


/** \brief Mask for Ifx_SCU_CCUCON4_Bits.UPTHR */


/** \brief Offset for Ifx_SCU_CCUCON4_Bits.UPTHR */


/** \brief Length for Ifx_SCU_CCUCON4_Bits.MONEN */


/** \brief Mask for Ifx_SCU_CCUCON4_Bits.MONEN */


/** \brief Offset for Ifx_SCU_CCUCON4_Bits.MONEN */


/** \brief Length for Ifx_SCU_CCUCON4_Bits.MONTST */


/** \brief Mask for Ifx_SCU_CCUCON4_Bits.MONTST */


/** \brief Offset for Ifx_SCU_CCUCON4_Bits.MONTST */


/** \brief Length for Ifx_SCU_CCUCON4_Bits.UP */


/** \brief Mask for Ifx_SCU_CCUCON4_Bits.UP */


/** \brief Offset for Ifx_SCU_CCUCON4_Bits.UP */


/** \brief Length for Ifx_SCU_CCUCON4_Bits.LCK */


/** \brief Mask for Ifx_SCU_CCUCON4_Bits.LCK */


/** \brief Offset for Ifx_SCU_CCUCON4_Bits.LCK */


/** \brief Length for Ifx_SCU_CCUCON5_Bits.GETHDIV */


/** \brief Mask for Ifx_SCU_CCUCON5_Bits.GETHDIV */


/** \brief Offset for Ifx_SCU_CCUCON5_Bits.GETHDIV */


/** \brief Length for Ifx_SCU_CCUCON5_Bits.MCANHDIV */


/** \brief Mask for Ifx_SCU_CCUCON5_Bits.MCANHDIV */


/** \brief Offset for Ifx_SCU_CCUCON5_Bits.MCANHDIV */


/** \brief Length for Ifx_SCU_CCUCON5_Bits.UP */


/** \brief Mask for Ifx_SCU_CCUCON5_Bits.UP */


/** \brief Offset for Ifx_SCU_CCUCON5_Bits.UP */


/** \brief Length for Ifx_SCU_CCUCON5_Bits.LCK */


/** \brief Mask for Ifx_SCU_CCUCON5_Bits.LCK */


/** \brief Offset for Ifx_SCU_CCUCON5_Bits.LCK */


/** \brief Length for Ifx_SCU_RSTSTAT_Bits.ESR0 */


/** \brief Mask for Ifx_SCU_RSTSTAT_Bits.ESR0 */


/** \brief Offset for Ifx_SCU_RSTSTAT_Bits.ESR0 */


/** \brief Length for Ifx_SCU_RSTSTAT_Bits.ESR1 */


/** \brief Mask for Ifx_SCU_RSTSTAT_Bits.ESR1 */


/** \brief Offset for Ifx_SCU_RSTSTAT_Bits.ESR1 */


/** \brief Length for Ifx_SCU_RSTSTAT_Bits.SMU */


/** \brief Mask for Ifx_SCU_RSTSTAT_Bits.SMU */


/** \brief Offset for Ifx_SCU_RSTSTAT_Bits.SMU */


/** \brief Length for Ifx_SCU_RSTSTAT_Bits.SW */


/** \brief Mask for Ifx_SCU_RSTSTAT_Bits.SW */


/** \brief Offset for Ifx_SCU_RSTSTAT_Bits.SW */


/** \brief Length for Ifx_SCU_RSTSTAT_Bits.STM0 */


/** \brief Mask for Ifx_SCU_RSTSTAT_Bits.STM0 */


/** \brief Offset for Ifx_SCU_RSTSTAT_Bits.STM0 */


/** \brief Length for Ifx_SCU_RSTSTAT_Bits.STM1 */


/** \brief Mask for Ifx_SCU_RSTSTAT_Bits.STM1 */


/** \brief Offset for Ifx_SCU_RSTSTAT_Bits.STM1 */


/** \brief Length for Ifx_SCU_RSTSTAT_Bits.STM2 */


/** \brief Mask for Ifx_SCU_RSTSTAT_Bits.STM2 */


/** \brief Offset for Ifx_SCU_RSTSTAT_Bits.STM2 */


/** \brief Length for Ifx_SCU_RSTSTAT_Bits.STM3 */


/** \brief Mask for Ifx_SCU_RSTSTAT_Bits.STM3 */


/** \brief Offset for Ifx_SCU_RSTSTAT_Bits.STM3 */


/** \brief Length for Ifx_SCU_RSTSTAT_Bits.PORST */


/** \brief Mask for Ifx_SCU_RSTSTAT_Bits.PORST */


/** \brief Offset for Ifx_SCU_RSTSTAT_Bits.PORST */


/** \brief Length for Ifx_SCU_RSTSTAT_Bits.CB0 */


/** \brief Mask for Ifx_SCU_RSTSTAT_Bits.CB0 */


/** \brief Offset for Ifx_SCU_RSTSTAT_Bits.CB0 */


/** \brief Length for Ifx_SCU_RSTSTAT_Bits.CB1 */


/** \brief Mask for Ifx_SCU_RSTSTAT_Bits.CB1 */


/** \brief Offset for Ifx_SCU_RSTSTAT_Bits.CB1 */


/** \brief Length for Ifx_SCU_RSTSTAT_Bits.CB3 */


/** \brief Mask for Ifx_SCU_RSTSTAT_Bits.CB3 */


/** \brief Offset for Ifx_SCU_RSTSTAT_Bits.CB3 */


/** \brief Length for Ifx_SCU_RSTSTAT_Bits.EVRC */


/** \brief Mask for Ifx_SCU_RSTSTAT_Bits.EVRC */


/** \brief Offset for Ifx_SCU_RSTSTAT_Bits.EVRC */


/** \brief Length for Ifx_SCU_RSTSTAT_Bits.EVR33 */


/** \brief Mask for Ifx_SCU_RSTSTAT_Bits.EVR33 */


/** \brief Offset for Ifx_SCU_RSTSTAT_Bits.EVR33 */


/** \brief Length for Ifx_SCU_RSTSTAT_Bits.SWD */


/** \brief Mask for Ifx_SCU_RSTSTAT_Bits.SWD */


/** \brief Offset for Ifx_SCU_RSTSTAT_Bits.SWD */


/** \brief Length for Ifx_SCU_RSTSTAT_Bits.HSMS */


/** \brief Mask for Ifx_SCU_RSTSTAT_Bits.HSMS */


/** \brief Offset for Ifx_SCU_RSTSTAT_Bits.HSMS */


/** \brief Length for Ifx_SCU_RSTSTAT_Bits.HSMA */


/** \brief Mask for Ifx_SCU_RSTSTAT_Bits.HSMA */


/** \brief Offset for Ifx_SCU_RSTSTAT_Bits.HSMA */


/** \brief Length for Ifx_SCU_RSTSTAT_Bits.STBYR */


/** \brief Mask for Ifx_SCU_RSTSTAT_Bits.STBYR */


/** \brief Offset for Ifx_SCU_RSTSTAT_Bits.STBYR */


/** \brief Length for Ifx_SCU_RSTSTAT_Bits.LBPORST */


/** \brief Mask for Ifx_SCU_RSTSTAT_Bits.LBPORST */


/** \brief Offset for Ifx_SCU_RSTSTAT_Bits.LBPORST */


/** \brief Length for Ifx_SCU_RSTSTAT_Bits.LBTERM */


/** \brief Mask for Ifx_SCU_RSTSTAT_Bits.LBTERM */


/** \brief Offset for Ifx_SCU_RSTSTAT_Bits.LBTERM */


/** \brief Length for Ifx_SCU_RSTCON_Bits.ESR0 */


/** \brief Mask for Ifx_SCU_RSTCON_Bits.ESR0 */


/** \brief Offset for Ifx_SCU_RSTCON_Bits.ESR0 */


/** \brief Length for Ifx_SCU_RSTCON_Bits.ESR1 */


/** \brief Mask for Ifx_SCU_RSTCON_Bits.ESR1 */


/** \brief Offset for Ifx_SCU_RSTCON_Bits.ESR1 */


/** \brief Length for Ifx_SCU_RSTCON_Bits.SMU */


/** \brief Mask for Ifx_SCU_RSTCON_Bits.SMU */


/** \brief Offset for Ifx_SCU_RSTCON_Bits.SMU */


/** \brief Length for Ifx_SCU_RSTCON_Bits.SW */


/** \brief Mask for Ifx_SCU_RSTCON_Bits.SW */


/** \brief Offset for Ifx_SCU_RSTCON_Bits.SW */


/** \brief Length for Ifx_SCU_RSTCON_Bits.STM0 */


/** \brief Mask for Ifx_SCU_RSTCON_Bits.STM0 */


/** \brief Offset for Ifx_SCU_RSTCON_Bits.STM0 */


/** \brief Length for Ifx_SCU_RSTCON_Bits.STM1 */


/** \brief Mask for Ifx_SCU_RSTCON_Bits.STM1 */


/** \brief Offset for Ifx_SCU_RSTCON_Bits.STM1 */


/** \brief Length for Ifx_SCU_RSTCON_Bits.STM2 */


/** \brief Mask for Ifx_SCU_RSTCON_Bits.STM2 */


/** \brief Offset for Ifx_SCU_RSTCON_Bits.STM2 */


/** \brief Length for Ifx_SCU_RSTCON_Bits.STM3 */


/** \brief Mask for Ifx_SCU_RSTCON_Bits.STM3 */


/** \brief Offset for Ifx_SCU_RSTCON_Bits.STM3 */


/** \brief Length for Ifx_SCU_ARSTDIS_Bits.STM0DIS */


/** \brief Mask for Ifx_SCU_ARSTDIS_Bits.STM0DIS */


/** \brief Offset for Ifx_SCU_ARSTDIS_Bits.STM0DIS */


/** \brief Length for Ifx_SCU_ARSTDIS_Bits.STM1DIS */


/** \brief Mask for Ifx_SCU_ARSTDIS_Bits.STM1DIS */


/** \brief Offset for Ifx_SCU_ARSTDIS_Bits.STM1DIS */


/** \brief Length for Ifx_SCU_ARSTDIS_Bits.STM2DIS */


/** \brief Mask for Ifx_SCU_ARSTDIS_Bits.STM2DIS */


/** \brief Offset for Ifx_SCU_ARSTDIS_Bits.STM2DIS */


/** \brief Length for Ifx_SCU_ARSTDIS_Bits.STM3DIS */


/** \brief Mask for Ifx_SCU_ARSTDIS_Bits.STM3DIS */


/** \brief Offset for Ifx_SCU_ARSTDIS_Bits.STM3DIS */


/** \brief Length for Ifx_SCU_SWRSTCON_Bits.SWRSTREQ */


/** \brief Mask for Ifx_SCU_SWRSTCON_Bits.SWRSTREQ */


/** \brief Offset for Ifx_SCU_SWRSTCON_Bits.SWRSTREQ */


/** \brief Length for Ifx_SCU_RSTCON2_Bits.FRTO */


/** \brief Mask for Ifx_SCU_RSTCON2_Bits.FRTO */


/** \brief Offset for Ifx_SCU_RSTCON2_Bits.FRTO */


/** \brief Length for Ifx_SCU_RSTCON2_Bits.CLRC */


/** \brief Mask for Ifx_SCU_RSTCON2_Bits.CLRC */


/** \brief Offset for Ifx_SCU_RSTCON2_Bits.CLRC */


/** \brief Length for Ifx_SCU_RSTCON2_Bits.CSSx */


/** \brief Mask for Ifx_SCU_RSTCON2_Bits.CSSx */


/** \brief Offset for Ifx_SCU_RSTCON2_Bits.CSSx */


/** \brief Length for Ifx_SCU_RSTCON2_Bits.USRINFO */


/** \brief Mask for Ifx_SCU_RSTCON2_Bits.USRINFO */


/** \brief Offset for Ifx_SCU_RSTCON2_Bits.USRINFO */


/** \brief Length for Ifx_SCU_ESRCFGX_ESRCFGX_Bits.EDCON */


/** \brief Mask for Ifx_SCU_ESRCFGX_ESRCFGX_Bits.EDCON */


/** \brief Offset for Ifx_SCU_ESRCFGX_ESRCFGX_Bits.EDCON */


/** \brief Length for Ifx_SCU_ESROCFG_Bits.ARI */


/** \brief Mask for Ifx_SCU_ESROCFG_Bits.ARI */


/** \brief Offset for Ifx_SCU_ESROCFG_Bits.ARI */


/** \brief Length for Ifx_SCU_ESROCFG_Bits.ARC */


/** \brief Mask for Ifx_SCU_ESROCFG_Bits.ARC */


/** \brief Offset for Ifx_SCU_ESROCFG_Bits.ARC */


/** \brief Length for Ifx_SCU_SYSCON_Bits.CCTRIG0 */


/** \brief Mask for Ifx_SCU_SYSCON_Bits.CCTRIG0 */


/** \brief Offset for Ifx_SCU_SYSCON_Bits.CCTRIG0 */


/** \brief Length for Ifx_SCU_SYSCON_Bits.RAMINTM */


/** \brief Mask for Ifx_SCU_SYSCON_Bits.RAMINTM */


/** \brief Offset for Ifx_SCU_SYSCON_Bits.RAMINTM */


/** \brief Length for Ifx_SCU_SYSCON_Bits.SETLUDIS */


/** \brief Mask for Ifx_SCU_SYSCON_Bits.SETLUDIS */


/** \brief Offset for Ifx_SCU_SYSCON_Bits.SETLUDIS */


/** \brief Length for Ifx_SCU_SYSCON_Bits.DDC */


/** \brief Mask for Ifx_SCU_SYSCON_Bits.DDC */


/** \brief Offset for Ifx_SCU_SYSCON_Bits.DDC */


/** \brief Length for Ifx_SCU_CCUCON6_Bits.CPU0DIV */


/** \brief Mask for Ifx_SCU_CCUCON6_Bits.CPU0DIV */


/** \brief Offset for Ifx_SCU_CCUCON6_Bits.CPU0DIV */


/** \brief Length for Ifx_SCU_CCUCON7_Bits.CPU1DIV */


/** \brief Mask for Ifx_SCU_CCUCON7_Bits.CPU1DIV */


/** \brief Offset for Ifx_SCU_CCUCON7_Bits.CPU1DIV */


/** \brief Length for Ifx_SCU_CCUCON8_Bits.CPU2DIV */


/** \brief Mask for Ifx_SCU_CCUCON8_Bits.CPU2DIV */


/** \brief Offset for Ifx_SCU_CCUCON8_Bits.CPU2DIV */


/** \brief Length for Ifx_SCU_CCUCON9_Bits.CPU3DIV */


/** \brief Mask for Ifx_SCU_CCUCON9_Bits.CPU3DIV */


/** \brief Offset for Ifx_SCU_CCUCON9_Bits.CPU3DIV */


/** \brief Length for Ifx_SCU_PDR_Bits.PD0 */


/** \brief Mask for Ifx_SCU_PDR_Bits.PD0 */


/** \brief Offset for Ifx_SCU_PDR_Bits.PD0 */


/** \brief Length for Ifx_SCU_PDR_Bits.PL0 */


/** \brief Mask for Ifx_SCU_PDR_Bits.PL0 */


/** \brief Offset for Ifx_SCU_PDR_Bits.PL0 */


/** \brief Length for Ifx_SCU_PDR_Bits.PD1 */


/** \brief Mask for Ifx_SCU_PDR_Bits.PD1 */


/** \brief Offset for Ifx_SCU_PDR_Bits.PD1 */


/** \brief Length for Ifx_SCU_PDR_Bits.PL1 */


/** \brief Mask for Ifx_SCU_PDR_Bits.PL1 */


/** \brief Offset for Ifx_SCU_PDR_Bits.PL1 */


/** \brief Length for Ifx_SCU_IOCR_Bits.PC0 */


/** \brief Mask for Ifx_SCU_IOCR_Bits.PC0 */


/** \brief Offset for Ifx_SCU_IOCR_Bits.PC0 */


/** \brief Length for Ifx_SCU_IOCR_Bits.PC1 */


/** \brief Mask for Ifx_SCU_IOCR_Bits.PC1 */


/** \brief Offset for Ifx_SCU_IOCR_Bits.PC1 */


/** \brief Length for Ifx_SCU_OUT_Bits.P0 */


/** \brief Mask for Ifx_SCU_OUT_Bits.P0 */


/** \brief Offset for Ifx_SCU_OUT_Bits.P0 */


/** \brief Length for Ifx_SCU_OUT_Bits.P1 */


/** \brief Mask for Ifx_SCU_OUT_Bits.P1 */


/** \brief Offset for Ifx_SCU_OUT_Bits.P1 */


/** \brief Length for Ifx_SCU_OMR_Bits.PS0 */


/** \brief Mask for Ifx_SCU_OMR_Bits.PS0 */


/** \brief Offset for Ifx_SCU_OMR_Bits.PS0 */


/** \brief Length for Ifx_SCU_OMR_Bits.PS1 */


/** \brief Mask for Ifx_SCU_OMR_Bits.PS1 */


/** \brief Offset for Ifx_SCU_OMR_Bits.PS1 */


/** \brief Length for Ifx_SCU_OMR_Bits.PCL0 */


/** \brief Mask for Ifx_SCU_OMR_Bits.PCL0 */


/** \brief Offset for Ifx_SCU_OMR_Bits.PCL0 */


/** \brief Length for Ifx_SCU_OMR_Bits.PCL1 */


/** \brief Mask for Ifx_SCU_OMR_Bits.PCL1 */


/** \brief Offset for Ifx_SCU_OMR_Bits.PCL1 */


/** \brief Length for Ifx_SCU_IN_Bits.P0 */


/** \brief Mask for Ifx_SCU_IN_Bits.P0 */


/** \brief Offset for Ifx_SCU_IN_Bits.P0 */


/** \brief Length for Ifx_SCU_IN_Bits.P1 */


/** \brief Mask for Ifx_SCU_IN_Bits.P1 */


/** \brief Offset for Ifx_SCU_IN_Bits.P1 */


/** \brief Length for Ifx_SCU_STSTAT_Bits.HWCFG */


/** \brief Mask for Ifx_SCU_STSTAT_Bits.HWCFG */


/** \brief Offset for Ifx_SCU_STSTAT_Bits.HWCFG */


/** \brief Length for Ifx_SCU_STSTAT_Bits.FTM */


/** \brief Mask for Ifx_SCU_STSTAT_Bits.FTM */


/** \brief Offset for Ifx_SCU_STSTAT_Bits.FTM */


/** \brief Length for Ifx_SCU_STSTAT_Bits.MODE */


/** \brief Mask for Ifx_SCU_STSTAT_Bits.MODE */


/** \brief Offset for Ifx_SCU_STSTAT_Bits.MODE */


/** \brief Length for Ifx_SCU_STSTAT_Bits.FCBAE */


/** \brief Mask for Ifx_SCU_STSTAT_Bits.FCBAE */


/** \brief Offset for Ifx_SCU_STSTAT_Bits.FCBAE */


/** \brief Length for Ifx_SCU_STSTAT_Bits.LUDIS */


/** \brief Mask for Ifx_SCU_STSTAT_Bits.LUDIS */


/** \brief Offset for Ifx_SCU_STSTAT_Bits.LUDIS */


/** \brief Length for Ifx_SCU_STSTAT_Bits.TRSTL */


/** \brief Mask for Ifx_SCU_STSTAT_Bits.TRSTL */


/** \brief Offset for Ifx_SCU_STSTAT_Bits.TRSTL */


/** \brief Length for Ifx_SCU_STSTAT_Bits.SPDEN */


/** \brief Mask for Ifx_SCU_STSTAT_Bits.SPDEN */


/** \brief Offset for Ifx_SCU_STSTAT_Bits.SPDEN */


/** \brief Length for Ifx_SCU_STSTAT_Bits.RAMINT */


/** \brief Mask for Ifx_SCU_STSTAT_Bits.RAMINT */


/** \brief Offset for Ifx_SCU_STSTAT_Bits.RAMINT */


/** \brief Length for Ifx_SCU_STCON_Bits.SFCBAE */


/** \brief Mask for Ifx_SCU_STCON_Bits.SFCBAE */


/** \brief Offset for Ifx_SCU_STCON_Bits.SFCBAE */


/** \brief Length for Ifx_SCU_STCON_Bits.CFCBAE */


/** \brief Mask for Ifx_SCU_STCON_Bits.CFCBAE */


/** \brief Offset for Ifx_SCU_STCON_Bits.CFCBAE */


/** \brief Length for Ifx_SCU_STCON_Bits.STP */


/** \brief Mask for Ifx_SCU_STCON_Bits.STP */


/** \brief Offset for Ifx_SCU_STCON_Bits.STP */


/** \brief Length for Ifx_SCU_PMCSR0_Bits.REQSLP */


/** \brief Mask for Ifx_SCU_PMCSR0_Bits.REQSLP */


/** \brief Offset for Ifx_SCU_PMCSR0_Bits.REQSLP */


/** \brief Length for Ifx_SCU_PMCSR0_Bits.PMST */


/** \brief Mask for Ifx_SCU_PMCSR0_Bits.PMST */


/** \brief Offset for Ifx_SCU_PMCSR0_Bits.PMST */


/** \brief Length for Ifx_SCU_PMCSR1_Bits.REQSLP */


/** \brief Mask for Ifx_SCU_PMCSR1_Bits.REQSLP */


/** \brief Offset for Ifx_SCU_PMCSR1_Bits.REQSLP */


/** \brief Length for Ifx_SCU_PMCSR1_Bits.PMST */


/** \brief Mask for Ifx_SCU_PMCSR1_Bits.PMST */


/** \brief Offset for Ifx_SCU_PMCSR1_Bits.PMST */


/** \brief Length for Ifx_SCU_PMCSR2_Bits.REQSLP */


/** \brief Mask for Ifx_SCU_PMCSR2_Bits.REQSLP */


/** \brief Offset for Ifx_SCU_PMCSR2_Bits.REQSLP */


/** \brief Length for Ifx_SCU_PMCSR2_Bits.PMST */


/** \brief Mask for Ifx_SCU_PMCSR2_Bits.PMST */


/** \brief Offset for Ifx_SCU_PMCSR2_Bits.PMST */


/** \brief Length for Ifx_SCU_PMCSR3_Bits.REQSLP */


/** \brief Mask for Ifx_SCU_PMCSR3_Bits.REQSLP */


/** \brief Offset for Ifx_SCU_PMCSR3_Bits.REQSLP */


/** \brief Length for Ifx_SCU_PMCSR3_Bits.PMST */


/** \brief Mask for Ifx_SCU_PMCSR3_Bits.PMST */


/** \brief Offset for Ifx_SCU_PMCSR3_Bits.PMST */


/** \brief Length for Ifx_SCU_PMCSR4_Bits.REQSLP */


/** \brief Mask for Ifx_SCU_PMCSR4_Bits.REQSLP */


/** \brief Offset for Ifx_SCU_PMCSR4_Bits.REQSLP */


/** \brief Length for Ifx_SCU_PMCSR4_Bits.PMST */


/** \brief Mask for Ifx_SCU_PMCSR4_Bits.PMST */


/** \brief Offset for Ifx_SCU_PMCSR4_Bits.PMST */


/** \brief Length for Ifx_SCU_PMCSR5_Bits.REQSLP */


/** \brief Mask for Ifx_SCU_PMCSR5_Bits.REQSLP */


/** \brief Offset for Ifx_SCU_PMCSR5_Bits.REQSLP */


/** \brief Length for Ifx_SCU_PMCSR5_Bits.PMST */


/** \brief Mask for Ifx_SCU_PMCSR5_Bits.PMST */


/** \brief Offset for Ifx_SCU_PMCSR5_Bits.PMST */


/** \brief Length for Ifx_SCU_PMSTAT0_Bits.CPU0 */


/** \brief Mask for Ifx_SCU_PMSTAT0_Bits.CPU0 */


/** \brief Offset for Ifx_SCU_PMSTAT0_Bits.CPU0 */


/** \brief Length for Ifx_SCU_PMSTAT0_Bits.CPU1 */


/** \brief Mask for Ifx_SCU_PMSTAT0_Bits.CPU1 */


/** \brief Offset for Ifx_SCU_PMSTAT0_Bits.CPU1 */


/** \brief Length for Ifx_SCU_PMSTAT0_Bits.CPU2 */


/** \brief Mask for Ifx_SCU_PMSTAT0_Bits.CPU2 */


/** \brief Offset for Ifx_SCU_PMSTAT0_Bits.CPU2 */


/** \brief Length for Ifx_SCU_PMSTAT0_Bits.CPU3 */


/** \brief Mask for Ifx_SCU_PMSTAT0_Bits.CPU3 */


/** \brief Offset for Ifx_SCU_PMSTAT0_Bits.CPU3 */


/** \brief Length for Ifx_SCU_PMSTAT0_Bits.CPU4 */


/** \brief Mask for Ifx_SCU_PMSTAT0_Bits.CPU4 */


/** \brief Offset for Ifx_SCU_PMSTAT0_Bits.CPU4 */


/** \brief Length for Ifx_SCU_PMSTAT0_Bits.CPU5 */


/** \brief Mask for Ifx_SCU_PMSTAT0_Bits.CPU5 */


/** \brief Offset for Ifx_SCU_PMSTAT0_Bits.CPU5 */


/** \brief Length for Ifx_SCU_PMSTAT0_Bits.CPU0LS */


/** \brief Mask for Ifx_SCU_PMSTAT0_Bits.CPU0LS */


/** \brief Offset for Ifx_SCU_PMSTAT0_Bits.CPU0LS */


/** \brief Length for Ifx_SCU_PMSTAT0_Bits.CPU1LS */


/** \brief Mask for Ifx_SCU_PMSTAT0_Bits.CPU1LS */


/** \brief Offset for Ifx_SCU_PMSTAT0_Bits.CPU1LS */


/** \brief Length for Ifx_SCU_PMSTAT0_Bits.CPU2LS */


/** \brief Mask for Ifx_SCU_PMSTAT0_Bits.CPU2LS */


/** \brief Offset for Ifx_SCU_PMSTAT0_Bits.CPU2LS */


/** \brief Length for Ifx_SCU_PMSTAT0_Bits.CPU3LS */


/** \brief Mask for Ifx_SCU_PMSTAT0_Bits.CPU3LS */


/** \brief Offset for Ifx_SCU_PMSTAT0_Bits.CPU3LS */


/** \brief Length for Ifx_SCU_PMSWCR1_Bits.CPUIDLSEL */


/** \brief Mask for Ifx_SCU_PMSWCR1_Bits.CPUIDLSEL */


/** \brief Offset for Ifx_SCU_PMSWCR1_Bits.CPUIDLSEL */


/** \brief Length for Ifx_SCU_PMSWCR1_Bits.IRADIS */


/** \brief Mask for Ifx_SCU_PMSWCR1_Bits.IRADIS */


/** \brief Offset for Ifx_SCU_PMSWCR1_Bits.IRADIS */


/** \brief Length for Ifx_SCU_PMSWCR1_Bits.CPUSEL */


/** \brief Mask for Ifx_SCU_PMSWCR1_Bits.CPUSEL */


/** \brief Offset for Ifx_SCU_PMSWCR1_Bits.CPUSEL */


/** \brief Length for Ifx_SCU_PMSWCR1_Bits.STBYEVEN */


/** \brief Mask for Ifx_SCU_PMSWCR1_Bits.STBYEVEN */


/** \brief Offset for Ifx_SCU_PMSWCR1_Bits.STBYEVEN */


/** \brief Length for Ifx_SCU_PMSWCR1_Bits.STBYEV */


/** \brief Mask for Ifx_SCU_PMSWCR1_Bits.STBYEV */


/** \brief Offset for Ifx_SCU_PMSWCR1_Bits.STBYEV */


/** \brief Length for Ifx_SCU_EMSR_Bits.POL */


/** \brief Mask for Ifx_SCU_EMSR_Bits.POL */


/** \brief Offset for Ifx_SCU_EMSR_Bits.POL */


/** \brief Length for Ifx_SCU_EMSR_Bits.MODE */


/** \brief Mask for Ifx_SCU_EMSR_Bits.MODE */


/** \brief Offset for Ifx_SCU_EMSR_Bits.MODE */


/** \brief Length for Ifx_SCU_EMSR_Bits.ENON */


/** \brief Mask for Ifx_SCU_EMSR_Bits.ENON */


/** \brief Offset for Ifx_SCU_EMSR_Bits.ENON */


/** \brief Length for Ifx_SCU_EMSR_Bits.PSEL */


/** \brief Mask for Ifx_SCU_EMSR_Bits.PSEL */


/** \brief Offset for Ifx_SCU_EMSR_Bits.PSEL */


/** \brief Length for Ifx_SCU_EMSR_Bits.EMSF */


/** \brief Mask for Ifx_SCU_EMSR_Bits.EMSF */


/** \brief Offset for Ifx_SCU_EMSR_Bits.EMSF */


/** \brief Length for Ifx_SCU_EMSR_Bits.SEMSF */


/** \brief Mask for Ifx_SCU_EMSR_Bits.SEMSF */


/** \brief Offset for Ifx_SCU_EMSR_Bits.SEMSF */


/** \brief Length for Ifx_SCU_EMSSW_Bits.EMSFM */


/** \brief Mask for Ifx_SCU_EMSSW_Bits.EMSFM */


/** \brief Offset for Ifx_SCU_EMSSW_Bits.EMSFM */


/** \brief Length for Ifx_SCU_EMSSW_Bits.SEMSFM */


/** \brief Mask for Ifx_SCU_EMSSW_Bits.SEMSFM */


/** \brief Offset for Ifx_SCU_EMSSW_Bits.SEMSFM */


/** \brief Length for Ifx_SCU_DTSCSTAT_Bits.RESULT */


/** \brief Mask for Ifx_SCU_DTSCSTAT_Bits.RESULT */


/** \brief Offset for Ifx_SCU_DTSCSTAT_Bits.RESULT */


/** \brief Length for Ifx_SCU_DTSCLIM_Bits.LOWER */


/** \brief Mask for Ifx_SCU_DTSCLIM_Bits.LOWER */


/** \brief Offset for Ifx_SCU_DTSCLIM_Bits.LOWER */


/** \brief Length for Ifx_SCU_DTSCLIM_Bits.BGPOK */


/** \brief Mask for Ifx_SCU_DTSCLIM_Bits.BGPOK */


/** \brief Offset for Ifx_SCU_DTSCLIM_Bits.BGPOK */


/** \brief Length for Ifx_SCU_DTSCLIM_Bits.EN */


/** \brief Mask for Ifx_SCU_DTSCLIM_Bits.EN */


/** \brief Offset for Ifx_SCU_DTSCLIM_Bits.EN */


/** \brief Length for Ifx_SCU_DTSCLIM_Bits.LLU */


/** \brief Mask for Ifx_SCU_DTSCLIM_Bits.LLU */


/** \brief Offset for Ifx_SCU_DTSCLIM_Bits.LLU */


/** \brief Length for Ifx_SCU_DTSCLIM_Bits.UPPER */


/** \brief Mask for Ifx_SCU_DTSCLIM_Bits.UPPER */


/** \brief Offset for Ifx_SCU_DTSCLIM_Bits.UPPER */


/** \brief Length for Ifx_SCU_DTSCLIM_Bits.INTEN */


/** \brief Mask for Ifx_SCU_DTSCLIM_Bits.INTEN */


/** \brief Offset for Ifx_SCU_DTSCLIM_Bits.INTEN */


/** \brief Length for Ifx_SCU_DTSCLIM_Bits.INT */


/** \brief Mask for Ifx_SCU_DTSCLIM_Bits.INT */


/** \brief Offset for Ifx_SCU_DTSCLIM_Bits.INT */


/** \brief Length for Ifx_SCU_DTSCLIM_Bits.UOF */


/** \brief Mask for Ifx_SCU_DTSCLIM_Bits.UOF */


/** \brief Offset for Ifx_SCU_DTSCLIM_Bits.UOF */


/** \brief Length for Ifx_SCU_TRAPSTAT_Bits.ESR0T */


/** \brief Mask for Ifx_SCU_TRAPSTAT_Bits.ESR0T */


/** \brief Offset for Ifx_SCU_TRAPSTAT_Bits.ESR0T */


/** \brief Length for Ifx_SCU_TRAPSTAT_Bits.ESR1T */


/** \brief Mask for Ifx_SCU_TRAPSTAT_Bits.ESR1T */


/** \brief Offset for Ifx_SCU_TRAPSTAT_Bits.ESR1T */


/** \brief Length for Ifx_SCU_TRAPSTAT_Bits.TRAP2 */


/** \brief Mask for Ifx_SCU_TRAPSTAT_Bits.TRAP2 */


/** \brief Offset for Ifx_SCU_TRAPSTAT_Bits.TRAP2 */


/** \brief Length for Ifx_SCU_TRAPSTAT_Bits.SMUT */


/** \brief Mask for Ifx_SCU_TRAPSTAT_Bits.SMUT */


/** \brief Offset for Ifx_SCU_TRAPSTAT_Bits.SMUT */


/** \brief Length for Ifx_SCU_TRAPSET_Bits.ESR0T */


/** \brief Mask for Ifx_SCU_TRAPSET_Bits.ESR0T */


/** \brief Offset for Ifx_SCU_TRAPSET_Bits.ESR0T */


/** \brief Length for Ifx_SCU_TRAPSET_Bits.ESR1T */


/** \brief Mask for Ifx_SCU_TRAPSET_Bits.ESR1T */


/** \brief Offset for Ifx_SCU_TRAPSET_Bits.ESR1T */


/** \brief Length for Ifx_SCU_TRAPSET_Bits.TRAP2 */


/** \brief Mask for Ifx_SCU_TRAPSET_Bits.TRAP2 */


/** \brief Offset for Ifx_SCU_TRAPSET_Bits.TRAP2 */


/** \brief Length for Ifx_SCU_TRAPSET_Bits.SMUT */


/** \brief Mask for Ifx_SCU_TRAPSET_Bits.SMUT */


/** \brief Offset for Ifx_SCU_TRAPSET_Bits.SMUT */


/** \brief Length for Ifx_SCU_TRAPCLR_Bits.ESR0T */


/** \brief Mask for Ifx_SCU_TRAPCLR_Bits.ESR0T */


/** \brief Offset for Ifx_SCU_TRAPCLR_Bits.ESR0T */


/** \brief Length for Ifx_SCU_TRAPCLR_Bits.ESR1T */


/** \brief Mask for Ifx_SCU_TRAPCLR_Bits.ESR1T */


/** \brief Offset for Ifx_SCU_TRAPCLR_Bits.ESR1T */


/** \brief Length for Ifx_SCU_TRAPCLR_Bits.TRAP2 */


/** \brief Mask for Ifx_SCU_TRAPCLR_Bits.TRAP2 */


/** \brief Offset for Ifx_SCU_TRAPCLR_Bits.TRAP2 */


/** \brief Length for Ifx_SCU_TRAPCLR_Bits.SMUT */


/** \brief Mask for Ifx_SCU_TRAPCLR_Bits.SMUT */


/** \brief Offset for Ifx_SCU_TRAPCLR_Bits.SMUT */


/** \brief Length for Ifx_SCU_TRAPDIS0_Bits.CPU0ESR0T */


/** \brief Mask for Ifx_SCU_TRAPDIS0_Bits.CPU0ESR0T */


/** \brief Offset for Ifx_SCU_TRAPDIS0_Bits.CPU0ESR0T */


/** \brief Length for Ifx_SCU_TRAPDIS0_Bits.CPU0ESR1T */


/** \brief Mask for Ifx_SCU_TRAPDIS0_Bits.CPU0ESR1T */


/** \brief Offset for Ifx_SCU_TRAPDIS0_Bits.CPU0ESR1T */


/** \brief Length for Ifx_SCU_TRAPDIS0_Bits.CPU0TRAP2T */


/** \brief Mask for Ifx_SCU_TRAPDIS0_Bits.CPU0TRAP2T */


/** \brief Offset for Ifx_SCU_TRAPDIS0_Bits.CPU0TRAP2T */


/** \brief Length for Ifx_SCU_TRAPDIS0_Bits.CPU0SMUT */


/** \brief Mask for Ifx_SCU_TRAPDIS0_Bits.CPU0SMUT */


/** \brief Offset for Ifx_SCU_TRAPDIS0_Bits.CPU0SMUT */


/** \brief Length for Ifx_SCU_TRAPDIS0_Bits.CPU1ESR0T */


/** \brief Mask for Ifx_SCU_TRAPDIS0_Bits.CPU1ESR0T */


/** \brief Offset for Ifx_SCU_TRAPDIS0_Bits.CPU1ESR0T */


/** \brief Length for Ifx_SCU_TRAPDIS0_Bits.CPU1ESR1T */


/** \brief Mask for Ifx_SCU_TRAPDIS0_Bits.CPU1ESR1T */


/** \brief Offset for Ifx_SCU_TRAPDIS0_Bits.CPU1ESR1T */


/** \brief Length for Ifx_SCU_TRAPDIS0_Bits.CPU1TRAP2T */


/** \brief Mask for Ifx_SCU_TRAPDIS0_Bits.CPU1TRAP2T */


/** \brief Offset for Ifx_SCU_TRAPDIS0_Bits.CPU1TRAP2T */


/** \brief Length for Ifx_SCU_TRAPDIS0_Bits.CPU1SMUT */


/** \brief Mask for Ifx_SCU_TRAPDIS0_Bits.CPU1SMUT */


/** \brief Offset for Ifx_SCU_TRAPDIS0_Bits.CPU1SMUT */


/** \brief Length for Ifx_SCU_TRAPDIS0_Bits.CPU2ESR0T */


/** \brief Mask for Ifx_SCU_TRAPDIS0_Bits.CPU2ESR0T */


/** \brief Offset for Ifx_SCU_TRAPDIS0_Bits.CPU2ESR0T */


/** \brief Length for Ifx_SCU_TRAPDIS0_Bits.CPU2ESR1T */


/** \brief Mask for Ifx_SCU_TRAPDIS0_Bits.CPU2ESR1T */


/** \brief Offset for Ifx_SCU_TRAPDIS0_Bits.CPU2ESR1T */


/** \brief Length for Ifx_SCU_TRAPDIS0_Bits.CPU2TRAP2T */


/** \brief Mask for Ifx_SCU_TRAPDIS0_Bits.CPU2TRAP2T */


/** \brief Offset for Ifx_SCU_TRAPDIS0_Bits.CPU2TRAP2T */


/** \brief Length for Ifx_SCU_TRAPDIS0_Bits.CPU2SMUT */


/** \brief Mask for Ifx_SCU_TRAPDIS0_Bits.CPU2SMUT */


/** \brief Offset for Ifx_SCU_TRAPDIS0_Bits.CPU2SMUT */


/** \brief Length for Ifx_SCU_TRAPDIS0_Bits.CPU3ESR0T */


/** \brief Mask for Ifx_SCU_TRAPDIS0_Bits.CPU3ESR0T */


/** \brief Offset for Ifx_SCU_TRAPDIS0_Bits.CPU3ESR0T */


/** \brief Length for Ifx_SCU_TRAPDIS0_Bits.CPU3ESR1T */


/** \brief Mask for Ifx_SCU_TRAPDIS0_Bits.CPU3ESR1T */


/** \brief Offset for Ifx_SCU_TRAPDIS0_Bits.CPU3ESR1T */


/** \brief Length for Ifx_SCU_TRAPDIS0_Bits.CPU3TRAP2T */


/** \brief Mask for Ifx_SCU_TRAPDIS0_Bits.CPU3TRAP2T */


/** \brief Offset for Ifx_SCU_TRAPDIS0_Bits.CPU3TRAP2T */


/** \brief Length for Ifx_SCU_TRAPDIS0_Bits.CPU3SMUT */


/** \brief Mask for Ifx_SCU_TRAPDIS0_Bits.CPU3SMUT */


/** \brief Offset for Ifx_SCU_TRAPDIS0_Bits.CPU3SMUT */


/** \brief Length for Ifx_SCU_LCLCON0_Bits.LS0 */


/** \brief Mask for Ifx_SCU_LCLCON0_Bits.LS0 */


/** \brief Offset for Ifx_SCU_LCLCON0_Bits.LS0 */


/** \brief Length for Ifx_SCU_LCLCON0_Bits.LSEN0 */


/** \brief Mask for Ifx_SCU_LCLCON0_Bits.LSEN0 */


/** \brief Offset for Ifx_SCU_LCLCON0_Bits.LSEN0 */


/** \brief Length for Ifx_SCU_LCLCON1_Bits.LS1 */


/** \brief Mask for Ifx_SCU_LCLCON1_Bits.LS1 */


/** \brief Offset for Ifx_SCU_LCLCON1_Bits.LS1 */


/** \brief Length for Ifx_SCU_LCLCON1_Bits.LSEN1 */


/** \brief Mask for Ifx_SCU_LCLCON1_Bits.LSEN1 */


/** \brief Offset for Ifx_SCU_LCLCON1_Bits.LSEN1 */


/** \brief Length for Ifx_SCU_LCLTEST_Bits.LCLT0 */


/** \brief Mask for Ifx_SCU_LCLTEST_Bits.LCLT0 */


/** \brief Offset for Ifx_SCU_LCLTEST_Bits.LCLT0 */


/** \brief Length for Ifx_SCU_LCLTEST_Bits.LCLT1 */


/** \brief Mask for Ifx_SCU_LCLTEST_Bits.LCLT1 */


/** \brief Offset for Ifx_SCU_LCLTEST_Bits.LCLT1 */


/** \brief Length for Ifx_SCU_LCLTEST_Bits.LCLT2 */


/** \brief Mask for Ifx_SCU_LCLTEST_Bits.LCLT2 */


/** \brief Offset for Ifx_SCU_LCLTEST_Bits.LCLT2 */


/** \brief Length for Ifx_SCU_LCLTEST_Bits.LCLT3 */


/** \brief Mask for Ifx_SCU_LCLTEST_Bits.LCLT3 */


/** \brief Offset for Ifx_SCU_LCLTEST_Bits.LCLT3 */


/** \brief Length for Ifx_SCU_LCLTEST_Bits.PLCLT0 */


/** \brief Mask for Ifx_SCU_LCLTEST_Bits.PLCLT0 */


/** \brief Offset for Ifx_SCU_LCLTEST_Bits.PLCLT0 */


/** \brief Length for Ifx_SCU_LCLTEST_Bits.PLCLT1 */


/** \brief Mask for Ifx_SCU_LCLTEST_Bits.PLCLT1 */


/** \brief Offset for Ifx_SCU_LCLTEST_Bits.PLCLT1 */


/** \brief Length for Ifx_SCU_LCLTEST_Bits.PLCLT2 */


/** \brief Mask for Ifx_SCU_LCLTEST_Bits.PLCLT2 */


/** \brief Offset for Ifx_SCU_LCLTEST_Bits.PLCLT2 */


/** \brief Length for Ifx_SCU_LCLTEST_Bits.PLCLT3 */


/** \brief Mask for Ifx_SCU_LCLTEST_Bits.PLCLT3 */


/** \brief Offset for Ifx_SCU_LCLTEST_Bits.PLCLT3 */


/** \brief Length for Ifx_SCU_CHIPID_Bits.CHREV */


/** \brief Mask for Ifx_SCU_CHIPID_Bits.CHREV */


/** \brief Offset for Ifx_SCU_CHIPID_Bits.CHREV */


/** \brief Length for Ifx_SCU_CHIPID_Bits.CHTEC */


/** \brief Mask for Ifx_SCU_CHIPID_Bits.CHTEC */


/** \brief Offset for Ifx_SCU_CHIPID_Bits.CHTEC */


/** \brief Length for Ifx_SCU_CHIPID_Bits.CHPK */


/** \brief Mask for Ifx_SCU_CHIPID_Bits.CHPK */


/** \brief Offset for Ifx_SCU_CHIPID_Bits.CHPK */


/** \brief Length for Ifx_SCU_CHIPID_Bits.CHID */


/** \brief Mask for Ifx_SCU_CHIPID_Bits.CHID */


/** \brief Offset for Ifx_SCU_CHIPID_Bits.CHID */


/** \brief Length for Ifx_SCU_CHIPID_Bits.EEA */


/** \brief Mask for Ifx_SCU_CHIPID_Bits.EEA */


/** \brief Offset for Ifx_SCU_CHIPID_Bits.EEA */


/** \brief Length for Ifx_SCU_CHIPID_Bits.UCODE */


/** \brief Mask for Ifx_SCU_CHIPID_Bits.UCODE */


/** \brief Offset for Ifx_SCU_CHIPID_Bits.UCODE */


/** \brief Length for Ifx_SCU_CHIPID_Bits.FSIZE */


/** \brief Mask for Ifx_SCU_CHIPID_Bits.FSIZE */


/** \brief Offset for Ifx_SCU_CHIPID_Bits.FSIZE */


/** \brief Length for Ifx_SCU_CHIPID_Bits.VART */


/** \brief Mask for Ifx_SCU_CHIPID_Bits.VART */


/** \brief Offset for Ifx_SCU_CHIPID_Bits.VART */


/** \brief Length for Ifx_SCU_CHIPID_Bits.SEC */


/** \brief Mask for Ifx_SCU_CHIPID_Bits.SEC */


/** \brief Offset for Ifx_SCU_CHIPID_Bits.SEC */


/** \brief Length for Ifx_SCU_MANID_Bits.DEPT */


/** \brief Mask for Ifx_SCU_MANID_Bits.DEPT */


/** \brief Offset for Ifx_SCU_MANID_Bits.DEPT */


/** \brief Length for Ifx_SCU_MANID_Bits.MANUF */


/** \brief Mask for Ifx_SCU_MANID_Bits.MANUF */


/** \brief Offset for Ifx_SCU_MANID_Bits.MANUF */


/** \brief Length for Ifx_SCU_SWAPCTRL_Bits.ADDRCFG */


/** \brief Mask for Ifx_SCU_SWAPCTRL_Bits.ADDRCFG */


/** \brief Offset for Ifx_SCU_SWAPCTRL_Bits.ADDRCFG */


/** \brief Length for Ifx_SCU_SWAPCTRL_Bits.Spare */


/** \brief Mask for Ifx_SCU_SWAPCTRL_Bits.Spare */


/** \brief Offset for Ifx_SCU_SWAPCTRL_Bits.Spare */


/** \brief Length for Ifx_SCU_LBISTCTRL0_Bits.LBISTREQ */


/** \brief Mask for Ifx_SCU_LBISTCTRL0_Bits.LBISTREQ */


/** \brief Offset for Ifx_SCU_LBISTCTRL0_Bits.LBISTREQ */


/** \brief Length for Ifx_SCU_LBISTCTRL0_Bits.LBISTRES */


/** \brief Mask for Ifx_SCU_LBISTCTRL0_Bits.LBISTRES */


/** \brief Offset for Ifx_SCU_LBISTCTRL0_Bits.LBISTRES */


/** \brief Length for Ifx_SCU_LBISTCTRL0_Bits.PATTERNS */


/** \brief Mask for Ifx_SCU_LBISTCTRL0_Bits.PATTERNS */


/** \brief Offset for Ifx_SCU_LBISTCTRL0_Bits.PATTERNS */


/** \brief Length for Ifx_SCU_LBISTCTRL0_Bits.LBISTDONE */


/** \brief Mask for Ifx_SCU_LBISTCTRL0_Bits.LBISTDONE */


/** \brief Offset for Ifx_SCU_LBISTCTRL0_Bits.LBISTDONE */


/** \brief Length for Ifx_SCU_LBISTCTRL0_Bits.LBISTERRINJ */


/** \brief Mask for Ifx_SCU_LBISTCTRL0_Bits.LBISTERRINJ */


/** \brief Offset for Ifx_SCU_LBISTCTRL0_Bits.LBISTERRINJ */


/** \brief Length for Ifx_SCU_LBISTCTRL0_Bits.LBISTREQRED */


/** \brief Mask for Ifx_SCU_LBISTCTRL0_Bits.LBISTREQRED */


/** \brief Offset for Ifx_SCU_LBISTCTRL0_Bits.LBISTREQRED */


/** \brief Length for Ifx_SCU_LBISTCTRL1_Bits.SEED */


/** \brief Mask for Ifx_SCU_LBISTCTRL1_Bits.SEED */


/** \brief Offset for Ifx_SCU_LBISTCTRL1_Bits.SEED */


/** \brief Length for Ifx_SCU_LBISTCTRL1_Bits.SPLITSH */


/** \brief Mask for Ifx_SCU_LBISTCTRL1_Bits.SPLITSH */


/** \brief Offset for Ifx_SCU_LBISTCTRL1_Bits.SPLITSH */


/** \brief Length for Ifx_SCU_LBISTCTRL1_Bits.BODY */


/** \brief Mask for Ifx_SCU_LBISTCTRL1_Bits.BODY */


/** \brief Offset for Ifx_SCU_LBISTCTRL1_Bits.BODY */


/** \brief Length for Ifx_SCU_LBISTCTRL1_Bits.LBISTFREQU */


/** \brief Mask for Ifx_SCU_LBISTCTRL1_Bits.LBISTFREQU */


/** \brief Offset for Ifx_SCU_LBISTCTRL1_Bits.LBISTFREQU */


/** \brief Length for Ifx_SCU_LBISTCTRL2_Bits.LENGTH */


/** \brief Mask for Ifx_SCU_LBISTCTRL2_Bits.LENGTH */


/** \brief Offset for Ifx_SCU_LBISTCTRL2_Bits.LENGTH */


/** \brief Length for Ifx_SCU_LBISTCTRL3_Bits.SIGNATURE */


/** \brief Mask for Ifx_SCU_LBISTCTRL3_Bits.SIGNATURE */


/** \brief Offset for Ifx_SCU_LBISTCTRL3_Bits.SIGNATURE */


/** \brief Length for Ifx_SCU_STMEM1_Bits.MEM */


/** \brief Mask for Ifx_SCU_STMEM1_Bits.MEM */


/** \brief Offset for Ifx_SCU_STMEM1_Bits.MEM */


/** \brief Length for Ifx_SCU_STMEM2_Bits.MEM */


/** \brief Mask for Ifx_SCU_STMEM2_Bits.MEM */


/** \brief Offset for Ifx_SCU_STMEM2_Bits.MEM */


/** \brief Length for Ifx_SCU_PDISC_Bits.PDIS0 */


/** \brief Mask for Ifx_SCU_PDISC_Bits.PDIS0 */


/** \brief Offset for Ifx_SCU_PDISC_Bits.PDIS0 */


/** \brief Length for Ifx_SCU_PDISC_Bits.PDIS1 */


/** \brief Mask for Ifx_SCU_PDISC_Bits.PDIS1 */


/** \brief Offset for Ifx_SCU_PDISC_Bits.PDIS1 */


/** \brief Length for Ifx_SCU_PMTRCSR0_Bits.LJTEN */


/** \brief Mask for Ifx_SCU_PMTRCSR0_Bits.LJTEN */


/** \brief Offset for Ifx_SCU_PMTRCSR0_Bits.LJTEN */


/** \brief Length for Ifx_SCU_PMTRCSR0_Bits.LJTOVEN */


/** \brief Mask for Ifx_SCU_PMTRCSR0_Bits.LJTOVEN */


/** \brief Offset for Ifx_SCU_PMTRCSR0_Bits.LJTOVEN */


/** \brief Length for Ifx_SCU_PMTRCSR0_Bits.LJTOVIEN */


/** \brief Mask for Ifx_SCU_PMTRCSR0_Bits.LJTOVIEN */


/** \brief Offset for Ifx_SCU_PMTRCSR0_Bits.LJTOVIEN */


/** \brief Length for Ifx_SCU_PMTRCSR0_Bits.LJTSTRT */


/** \brief Mask for Ifx_SCU_PMTRCSR0_Bits.LJTSTRT */


/** \brief Offset for Ifx_SCU_PMTRCSR0_Bits.LJTSTRT */


/** \brief Length for Ifx_SCU_PMTRCSR0_Bits.LJTSTP */


/** \brief Mask for Ifx_SCU_PMTRCSR0_Bits.LJTSTP */


/** \brief Offset for Ifx_SCU_PMTRCSR0_Bits.LJTSTP */


/** \brief Length for Ifx_SCU_PMTRCSR0_Bits.LJTCLR */


/** \brief Mask for Ifx_SCU_PMTRCSR0_Bits.LJTCLR */


/** \brief Offset for Ifx_SCU_PMTRCSR0_Bits.LJTCLR */


/** \brief Length for Ifx_SCU_PMTRCSR0_Bits.SDSTEP */


/** \brief Mask for Ifx_SCU_PMTRCSR0_Bits.SDSTEP */


/** \brief Offset for Ifx_SCU_PMTRCSR0_Bits.SDSTEP */


/** \brief Length for Ifx_SCU_PMTRCSR0_Bits.VDTEN */


/** \brief Mask for Ifx_SCU_PMTRCSR0_Bits.VDTEN */


/** \brief Offset for Ifx_SCU_PMTRCSR0_Bits.VDTEN */


/** \brief Length for Ifx_SCU_PMTRCSR0_Bits.VDTOVEN */


/** \brief Mask for Ifx_SCU_PMTRCSR0_Bits.VDTOVEN */


/** \brief Offset for Ifx_SCU_PMTRCSR0_Bits.VDTOVEN */


/** \brief Length for Ifx_SCU_PMTRCSR0_Bits.VDTOVIEN */


/** \brief Mask for Ifx_SCU_PMTRCSR0_Bits.VDTOVIEN */


/** \brief Offset for Ifx_SCU_PMTRCSR0_Bits.VDTOVIEN */


/** \brief Length for Ifx_SCU_PMTRCSR0_Bits.VDTSTRT */


/** \brief Mask for Ifx_SCU_PMTRCSR0_Bits.VDTSTRT */


/** \brief Offset for Ifx_SCU_PMTRCSR0_Bits.VDTSTRT */


/** \brief Length for Ifx_SCU_PMTRCSR0_Bits.VDTSTP */


/** \brief Mask for Ifx_SCU_PMTRCSR0_Bits.VDTSTP */


/** \brief Offset for Ifx_SCU_PMTRCSR0_Bits.VDTSTP */


/** \brief Length for Ifx_SCU_PMTRCSR0_Bits.VDTCLR */


/** \brief Mask for Ifx_SCU_PMTRCSR0_Bits.VDTCLR */


/** \brief Offset for Ifx_SCU_PMTRCSR0_Bits.VDTCLR */


/** \brief Length for Ifx_SCU_PMTRCSR0_Bits.LPSLPEN */


/** \brief Mask for Ifx_SCU_PMTRCSR0_Bits.LPSLPEN */


/** \brief Offset for Ifx_SCU_PMTRCSR0_Bits.LPSLPEN */


/** \brief Length for Ifx_SCU_PMTRCSR1_Bits.LJTCV */


/** \brief Mask for Ifx_SCU_PMTRCSR1_Bits.LJTCV */


/** \brief Offset for Ifx_SCU_PMTRCSR1_Bits.LJTCV */


/** \brief Length for Ifx_SCU_PMTRCSR1_Bits.VDTCV */


/** \brief Mask for Ifx_SCU_PMTRCSR1_Bits.VDTCV */


/** \brief Offset for Ifx_SCU_PMTRCSR1_Bits.VDTCV */


/** \brief Length for Ifx_SCU_PMTRCSR2_Bits.LDJMPREQ */


/** \brief Mask for Ifx_SCU_PMTRCSR2_Bits.LDJMPREQ */


/** \brief Offset for Ifx_SCU_PMTRCSR2_Bits.LDJMPREQ */


/** \brief Length for Ifx_SCU_PMTRCSR2_Bits.LJTRUN */


/** \brief Mask for Ifx_SCU_PMTRCSR2_Bits.LJTRUN */


/** \brief Offset for Ifx_SCU_PMTRCSR2_Bits.LJTRUN */


/** \brief Length for Ifx_SCU_PMTRCSR2_Bits.LJTOV */


/** \brief Mask for Ifx_SCU_PMTRCSR2_Bits.LJTOV */


/** \brief Offset for Ifx_SCU_PMTRCSR2_Bits.LJTOV */


/** \brief Length for Ifx_SCU_PMTRCSR2_Bits.LJTOVCLR */


/** \brief Mask for Ifx_SCU_PMTRCSR2_Bits.LJTOVCLR */


/** \brief Offset for Ifx_SCU_PMTRCSR2_Bits.LJTOVCLR */


/** \brief Length for Ifx_SCU_PMTRCSR2_Bits.LJTCNT */


/** \brief Mask for Ifx_SCU_PMTRCSR2_Bits.LJTCNT */


/** \brief Offset for Ifx_SCU_PMTRCSR2_Bits.LJTCNT */


/** \brief Length for Ifx_SCU_PMTRCSR3_Bits.VDROOPREQ */


/** \brief Mask for Ifx_SCU_PMTRCSR3_Bits.VDROOPREQ */


/** \brief Offset for Ifx_SCU_PMTRCSR3_Bits.VDROOPREQ */


/** \brief Length for Ifx_SCU_PMTRCSR3_Bits.VDTRUN */


/** \brief Mask for Ifx_SCU_PMTRCSR3_Bits.VDTRUN */


/** \brief Offset for Ifx_SCU_PMTRCSR3_Bits.VDTRUN */


/** \brief Length for Ifx_SCU_PMTRCSR3_Bits.VDTOV */


/** \brief Mask for Ifx_SCU_PMTRCSR3_Bits.VDTOV */


/** \brief Offset for Ifx_SCU_PMTRCSR3_Bits.VDTOV */


/** \brief Length for Ifx_SCU_PMTRCSR3_Bits.VDTOVCLR */


/** \brief Mask for Ifx_SCU_PMTRCSR3_Bits.VDTOVCLR */


/** \brief Offset for Ifx_SCU_PMTRCSR3_Bits.VDTOVCLR */


/** \brief Length for Ifx_SCU_PMTRCSR3_Bits.VDTCNT */


/** \brief Mask for Ifx_SCU_PMTRCSR3_Bits.VDTCNT */


/** \brief Offset for Ifx_SCU_PMTRCSR3_Bits.VDTCNT */


/** \brief Length for Ifx_SCU_STMEM3_Bits.MEM */


/** \brief Mask for Ifx_SCU_STMEM3_Bits.MEM */


/** \brief Offset for Ifx_SCU_STMEM3_Bits.MEM */


/** \brief Length for Ifx_SCU_STMEM4_Bits.MEM */


/** \brief Mask for Ifx_SCU_STMEM4_Bits.MEM */


/** \brief Offset for Ifx_SCU_STMEM4_Bits.MEM */


/** \brief Length for Ifx_SCU_STMEM5_Bits.MEM */


/** \brief Mask for Ifx_SCU_STMEM5_Bits.MEM */


/** \brief Offset for Ifx_SCU_STMEM5_Bits.MEM */


/** \brief Length for Ifx_SCU_STMEM6_Bits.MEM */


/** \brief Mask for Ifx_SCU_STMEM6_Bits.MEM */


/** \brief Offset for Ifx_SCU_STMEM6_Bits.MEM */


/** \brief Length for Ifx_SCU_OVCENABLE_Bits.OVEN0 */


/** \brief Mask for Ifx_SCU_OVCENABLE_Bits.OVEN0 */


/** \brief Offset for Ifx_SCU_OVCENABLE_Bits.OVEN0 */


/** \brief Length for Ifx_SCU_OVCENABLE_Bits.OVEN1 */


/** \brief Mask for Ifx_SCU_OVCENABLE_Bits.OVEN1 */


/** \brief Offset for Ifx_SCU_OVCENABLE_Bits.OVEN1 */


/** \brief Length for Ifx_SCU_OVCENABLE_Bits.OVEN2 */


/** \brief Mask for Ifx_SCU_OVCENABLE_Bits.OVEN2 */


/** \brief Offset for Ifx_SCU_OVCENABLE_Bits.OVEN2 */


/** \brief Length for Ifx_SCU_OVCENABLE_Bits.OVEN3 */


/** \brief Mask for Ifx_SCU_OVCENABLE_Bits.OVEN3 */


/** \brief Offset for Ifx_SCU_OVCENABLE_Bits.OVEN3 */


/** \brief Length for Ifx_SCU_OVCCON_Bits.CSEL0 */


/** \brief Mask for Ifx_SCU_OVCCON_Bits.CSEL0 */


/** \brief Offset for Ifx_SCU_OVCCON_Bits.CSEL0 */


/** \brief Length for Ifx_SCU_OVCCON_Bits.CSEL1 */


/** \brief Mask for Ifx_SCU_OVCCON_Bits.CSEL1 */


/** \brief Offset for Ifx_SCU_OVCCON_Bits.CSEL1 */


/** \brief Length for Ifx_SCU_OVCCON_Bits.CSEL2 */


/** \brief Mask for Ifx_SCU_OVCCON_Bits.CSEL2 */


/** \brief Offset for Ifx_SCU_OVCCON_Bits.CSEL2 */


/** \brief Length for Ifx_SCU_OVCCON_Bits.CSEL3 */


/** \brief Mask for Ifx_SCU_OVCCON_Bits.CSEL3 */


/** \brief Offset for Ifx_SCU_OVCCON_Bits.CSEL3 */


/** \brief Length for Ifx_SCU_OVCCON_Bits.OVSTRT */


/** \brief Mask for Ifx_SCU_OVCCON_Bits.OVSTRT */


/** \brief Offset for Ifx_SCU_OVCCON_Bits.OVSTRT */


/** \brief Length for Ifx_SCU_OVCCON_Bits.OVSTP */


/** \brief Mask for Ifx_SCU_OVCCON_Bits.OVSTP */


/** \brief Offset for Ifx_SCU_OVCCON_Bits.OVSTP */


/** \brief Length for Ifx_SCU_OVCCON_Bits.DCINVAL */


/** \brief Mask for Ifx_SCU_OVCCON_Bits.DCINVAL */


/** \brief Offset for Ifx_SCU_OVCCON_Bits.DCINVAL */


/** \brief Length for Ifx_SCU_OVCCON_Bits.OVCONF */


/** \brief Mask for Ifx_SCU_OVCCON_Bits.OVCONF */


/** \brief Offset for Ifx_SCU_OVCCON_Bits.OVCONF */


/** \brief Length for Ifx_SCU_OVCCON_Bits.POVCONF */


/** \brief Mask for Ifx_SCU_OVCCON_Bits.POVCONF */


/** \brief Offset for Ifx_SCU_OVCCON_Bits.POVCONF */


/** \brief Length for Ifx_SCU_EIFILT_Bits.FILRQ0A */


/** \brief Mask for Ifx_SCU_EIFILT_Bits.FILRQ0A */


/** \brief Offset for Ifx_SCU_EIFILT_Bits.FILRQ0A */


/** \brief Length for Ifx_SCU_EIFILT_Bits.FILRQ5A */


/** \brief Mask for Ifx_SCU_EIFILT_Bits.FILRQ5A */


/** \brief Offset for Ifx_SCU_EIFILT_Bits.FILRQ5A */


/** \brief Length for Ifx_SCU_EIFILT_Bits.FILRQ2A */


/** \brief Mask for Ifx_SCU_EIFILT_Bits.FILRQ2A */


/** \brief Offset for Ifx_SCU_EIFILT_Bits.FILRQ2A */


/** \brief Length for Ifx_SCU_EIFILT_Bits.FILRQ3A */


/** \brief Mask for Ifx_SCU_EIFILT_Bits.FILRQ3A */


/** \brief Offset for Ifx_SCU_EIFILT_Bits.FILRQ3A */


/** \brief Length for Ifx_SCU_EIFILT_Bits.FILRQ0C */


/** \brief Mask for Ifx_SCU_EIFILT_Bits.FILRQ0C */


/** \brief Offset for Ifx_SCU_EIFILT_Bits.FILRQ0C */


/** \brief Length for Ifx_SCU_EIFILT_Bits.FILRQ1C */


/** \brief Mask for Ifx_SCU_EIFILT_Bits.FILRQ1C */


/** \brief Offset for Ifx_SCU_EIFILT_Bits.FILRQ1C */


/** \brief Length for Ifx_SCU_EIFILT_Bits.FILRQ3C */


/** \brief Mask for Ifx_SCU_EIFILT_Bits.FILRQ3C */


/** \brief Offset for Ifx_SCU_EIFILT_Bits.FILRQ3C */


/** \brief Length for Ifx_SCU_EIFILT_Bits.FILRQ2C */


/** \brief Mask for Ifx_SCU_EIFILT_Bits.FILRQ2C */


/** \brief Offset for Ifx_SCU_EIFILT_Bits.FILRQ2C */


/** \brief Length for Ifx_SCU_EIFILT_Bits.FILRQ4A */


/** \brief Mask for Ifx_SCU_EIFILT_Bits.FILRQ4A */


/** \brief Offset for Ifx_SCU_EIFILT_Bits.FILRQ4A */


/** \brief Length for Ifx_SCU_EIFILT_Bits.FILRQ6A */


/** \brief Mask for Ifx_SCU_EIFILT_Bits.FILRQ6A */


/** \brief Offset for Ifx_SCU_EIFILT_Bits.FILRQ6A */


/** \brief Length for Ifx_SCU_EIFILT_Bits.FILRQ1A */


/** \brief Mask for Ifx_SCU_EIFILT_Bits.FILRQ1A */


/** \brief Offset for Ifx_SCU_EIFILT_Bits.FILRQ1A */


/** \brief Length for Ifx_SCU_EIFILT_Bits.FILRQ7A */


/** \brief Mask for Ifx_SCU_EIFILT_Bits.FILRQ7A */


/** \brief Offset for Ifx_SCU_EIFILT_Bits.FILRQ7A */


/** \brief Length for Ifx_SCU_EIFILT_Bits.FILRQ6D */


/** \brief Mask for Ifx_SCU_EIFILT_Bits.FILRQ6D */


/** \brief Offset for Ifx_SCU_EIFILT_Bits.FILRQ6D */


/** \brief Length for Ifx_SCU_EIFILT_Bits.FILRQ4D */


/** \brief Mask for Ifx_SCU_EIFILT_Bits.FILRQ4D */


/** \brief Offset for Ifx_SCU_EIFILT_Bits.FILRQ4D */


/** \brief Length for Ifx_SCU_EIFILT_Bits.FILRQ2B */


/** \brief Mask for Ifx_SCU_EIFILT_Bits.FILRQ2B */


/** \brief Offset for Ifx_SCU_EIFILT_Bits.FILRQ2B */


/** \brief Length for Ifx_SCU_EIFILT_Bits.FILRQ3B */


/** \brief Mask for Ifx_SCU_EIFILT_Bits.FILRQ3B */


/** \brief Offset for Ifx_SCU_EIFILT_Bits.FILRQ3B */


/** \brief Length for Ifx_SCU_EIFILT_Bits.FILRQ7C */


/** \brief Mask for Ifx_SCU_EIFILT_Bits.FILRQ7C */


/** \brief Offset for Ifx_SCU_EIFILT_Bits.FILRQ7C */


/** \brief Length for Ifx_SCU_EIFILT_Bits.FILTDIV */


/** \brief Mask for Ifx_SCU_EIFILT_Bits.FILTDIV */


/** \brief Offset for Ifx_SCU_EIFILT_Bits.FILTDIV */


/** \brief Length for Ifx_SCU_EIFILT_Bits.DEPTH */


/** \brief Mask for Ifx_SCU_EIFILT_Bits.DEPTH */


/** \brief Offset for Ifx_SCU_EIFILT_Bits.DEPTH */


/** \brief Length for Ifx_SCU_EICR_Bits.EXIS0 */


/** \brief Mask for Ifx_SCU_EICR_Bits.EXIS0 */


/** \brief Offset for Ifx_SCU_EICR_Bits.EXIS0 */


/** \brief Length for Ifx_SCU_EICR_Bits.FEN0 */


/** \brief Mask for Ifx_SCU_EICR_Bits.FEN0 */


/** \brief Offset for Ifx_SCU_EICR_Bits.FEN0 */


/** \brief Length for Ifx_SCU_EICR_Bits.REN0 */


/** \brief Mask for Ifx_SCU_EICR_Bits.REN0 */


/** \brief Offset for Ifx_SCU_EICR_Bits.REN0 */


/** \brief Length for Ifx_SCU_EICR_Bits.LDEN0 */


/** \brief Mask for Ifx_SCU_EICR_Bits.LDEN0 */


/** \brief Offset for Ifx_SCU_EICR_Bits.LDEN0 */


/** \brief Length for Ifx_SCU_EICR_Bits.EIEN0 */


/** \brief Mask for Ifx_SCU_EICR_Bits.EIEN0 */


/** \brief Offset for Ifx_SCU_EICR_Bits.EIEN0 */


/** \brief Length for Ifx_SCU_EICR_Bits.INP0 */


/** \brief Mask for Ifx_SCU_EICR_Bits.INP0 */


/** \brief Offset for Ifx_SCU_EICR_Bits.INP0 */


/** \brief Length for Ifx_SCU_EICR_Bits.EXIS1 */


/** \brief Mask for Ifx_SCU_EICR_Bits.EXIS1 */


/** \brief Offset for Ifx_SCU_EICR_Bits.EXIS1 */


/** \brief Length for Ifx_SCU_EICR_Bits.FEN1 */


/** \brief Mask for Ifx_SCU_EICR_Bits.FEN1 */


/** \brief Offset for Ifx_SCU_EICR_Bits.FEN1 */


/** \brief Length for Ifx_SCU_EICR_Bits.REN1 */


/** \brief Mask for Ifx_SCU_EICR_Bits.REN1 */


/** \brief Offset for Ifx_SCU_EICR_Bits.REN1 */


/** \brief Length for Ifx_SCU_EICR_Bits.LDEN1 */


/** \brief Mask for Ifx_SCU_EICR_Bits.LDEN1 */


/** \brief Offset for Ifx_SCU_EICR_Bits.LDEN1 */


/** \brief Length for Ifx_SCU_EICR_Bits.EIEN1 */


/** \brief Mask for Ifx_SCU_EICR_Bits.EIEN1 */


/** \brief Offset for Ifx_SCU_EICR_Bits.EIEN1 */


/** \brief Length for Ifx_SCU_EICR_Bits.INP1 */


/** \brief Mask for Ifx_SCU_EICR_Bits.INP1 */


/** \brief Offset for Ifx_SCU_EICR_Bits.INP1 */


/** \brief Length for Ifx_SCU_EIFR_Bits.INTF0 */


/** \brief Mask for Ifx_SCU_EIFR_Bits.INTF0 */


/** \brief Offset for Ifx_SCU_EIFR_Bits.INTF0 */


/** \brief Length for Ifx_SCU_EIFR_Bits.INTF1 */


/** \brief Mask for Ifx_SCU_EIFR_Bits.INTF1 */


/** \brief Offset for Ifx_SCU_EIFR_Bits.INTF1 */


/** \brief Length for Ifx_SCU_EIFR_Bits.INTF2 */


/** \brief Mask for Ifx_SCU_EIFR_Bits.INTF2 */


/** \brief Offset for Ifx_SCU_EIFR_Bits.INTF2 */


/** \brief Length for Ifx_SCU_EIFR_Bits.INTF3 */


/** \brief Mask for Ifx_SCU_EIFR_Bits.INTF3 */


/** \brief Offset for Ifx_SCU_EIFR_Bits.INTF3 */


/** \brief Length for Ifx_SCU_EIFR_Bits.INTF4 */


/** \brief Mask for Ifx_SCU_EIFR_Bits.INTF4 */


/** \brief Offset for Ifx_SCU_EIFR_Bits.INTF4 */


/** \brief Length for Ifx_SCU_EIFR_Bits.INTF5 */


/** \brief Mask for Ifx_SCU_EIFR_Bits.INTF5 */


/** \brief Offset for Ifx_SCU_EIFR_Bits.INTF5 */


/** \brief Length for Ifx_SCU_EIFR_Bits.INTF6 */


/** \brief Mask for Ifx_SCU_EIFR_Bits.INTF6 */


/** \brief Offset for Ifx_SCU_EIFR_Bits.INTF6 */


/** \brief Length for Ifx_SCU_EIFR_Bits.INTF7 */


/** \brief Mask for Ifx_SCU_EIFR_Bits.INTF7 */


/** \brief Offset for Ifx_SCU_EIFR_Bits.INTF7 */


/** \brief Length for Ifx_SCU_FMR_Bits.FS0 */


/** \brief Mask for Ifx_SCU_FMR_Bits.FS0 */


/** \brief Offset for Ifx_SCU_FMR_Bits.FS0 */


/** \brief Length for Ifx_SCU_FMR_Bits.FS1 */


/** \brief Mask for Ifx_SCU_FMR_Bits.FS1 */


/** \brief Offset for Ifx_SCU_FMR_Bits.FS1 */


/** \brief Length for Ifx_SCU_FMR_Bits.FS2 */


/** \brief Mask for Ifx_SCU_FMR_Bits.FS2 */


/** \brief Offset for Ifx_SCU_FMR_Bits.FS2 */


/** \brief Length for Ifx_SCU_FMR_Bits.FS3 */


/** \brief Mask for Ifx_SCU_FMR_Bits.FS3 */


/** \brief Offset for Ifx_SCU_FMR_Bits.FS3 */


/** \brief Length for Ifx_SCU_FMR_Bits.FS4 */


/** \brief Mask for Ifx_SCU_FMR_Bits.FS4 */


/** \brief Offset for Ifx_SCU_FMR_Bits.FS4 */


/** \brief Length for Ifx_SCU_FMR_Bits.FS5 */


/** \brief Mask for Ifx_SCU_FMR_Bits.FS5 */


/** \brief Offset for Ifx_SCU_FMR_Bits.FS5 */


/** \brief Length for Ifx_SCU_FMR_Bits.FS6 */


/** \brief Mask for Ifx_SCU_FMR_Bits.FS6 */


/** \brief Offset for Ifx_SCU_FMR_Bits.FS6 */


/** \brief Length for Ifx_SCU_FMR_Bits.FS7 */


/** \brief Mask for Ifx_SCU_FMR_Bits.FS7 */


/** \brief Offset for Ifx_SCU_FMR_Bits.FS7 */


/** \brief Length for Ifx_SCU_FMR_Bits.FC0 */


/** \brief Mask for Ifx_SCU_FMR_Bits.FC0 */


/** \brief Offset for Ifx_SCU_FMR_Bits.FC0 */


/** \brief Length for Ifx_SCU_FMR_Bits.FC1 */


/** \brief Mask for Ifx_SCU_FMR_Bits.FC1 */


/** \brief Offset for Ifx_SCU_FMR_Bits.FC1 */


/** \brief Length for Ifx_SCU_FMR_Bits.FC2 */


/** \brief Mask for Ifx_SCU_FMR_Bits.FC2 */


/** \brief Offset for Ifx_SCU_FMR_Bits.FC2 */


/** \brief Length for Ifx_SCU_FMR_Bits.FC3 */


/** \brief Mask for Ifx_SCU_FMR_Bits.FC3 */


/** \brief Offset for Ifx_SCU_FMR_Bits.FC3 */


/** \brief Length for Ifx_SCU_FMR_Bits.FC4 */


/** \brief Mask for Ifx_SCU_FMR_Bits.FC4 */


/** \brief Offset for Ifx_SCU_FMR_Bits.FC4 */


/** \brief Length for Ifx_SCU_FMR_Bits.FC5 */


/** \brief Mask for Ifx_SCU_FMR_Bits.FC5 */


/** \brief Offset for Ifx_SCU_FMR_Bits.FC5 */


/** \brief Length for Ifx_SCU_FMR_Bits.FC6 */


/** \brief Mask for Ifx_SCU_FMR_Bits.FC6 */


/** \brief Offset for Ifx_SCU_FMR_Bits.FC6 */


/** \brief Length for Ifx_SCU_FMR_Bits.FC7 */


/** \brief Mask for Ifx_SCU_FMR_Bits.FC7 */


/** \brief Offset for Ifx_SCU_FMR_Bits.FC7 */


/** \brief Length for Ifx_SCU_PDRR_Bits.PDR0 */


/** \brief Mask for Ifx_SCU_PDRR_Bits.PDR0 */


/** \brief Offset for Ifx_SCU_PDRR_Bits.PDR0 */


/** \brief Length for Ifx_SCU_PDRR_Bits.PDR1 */


/** \brief Mask for Ifx_SCU_PDRR_Bits.PDR1 */


/** \brief Offset for Ifx_SCU_PDRR_Bits.PDR1 */


/** \brief Length for Ifx_SCU_PDRR_Bits.PDR2 */


/** \brief Mask for Ifx_SCU_PDRR_Bits.PDR2 */


/** \brief Offset for Ifx_SCU_PDRR_Bits.PDR2 */


/** \brief Length for Ifx_SCU_PDRR_Bits.PDR3 */


/** \brief Mask for Ifx_SCU_PDRR_Bits.PDR3 */


/** \brief Offset for Ifx_SCU_PDRR_Bits.PDR3 */


/** \brief Length for Ifx_SCU_PDRR_Bits.PDR4 */


/** \brief Mask for Ifx_SCU_PDRR_Bits.PDR4 */


/** \brief Offset for Ifx_SCU_PDRR_Bits.PDR4 */


/** \brief Length for Ifx_SCU_PDRR_Bits.PDR5 */


/** \brief Mask for Ifx_SCU_PDRR_Bits.PDR5 */


/** \brief Offset for Ifx_SCU_PDRR_Bits.PDR5 */


/** \brief Length for Ifx_SCU_PDRR_Bits.PDR6 */


/** \brief Mask for Ifx_SCU_PDRR_Bits.PDR6 */


/** \brief Offset for Ifx_SCU_PDRR_Bits.PDR6 */


/** \brief Length for Ifx_SCU_PDRR_Bits.PDR7 */


/** \brief Mask for Ifx_SCU_PDRR_Bits.PDR7 */


/** \brief Offset for Ifx_SCU_PDRR_Bits.PDR7 */


/** \brief Length for Ifx_SCU_IGCR_Bits.IPEN00 */


/** \brief Mask for Ifx_SCU_IGCR_Bits.IPEN00 */


/** \brief Offset for Ifx_SCU_IGCR_Bits.IPEN00 */


/** \brief Length for Ifx_SCU_IGCR_Bits.IPEN01 */


/** \brief Mask for Ifx_SCU_IGCR_Bits.IPEN01 */


/** \brief Offset for Ifx_SCU_IGCR_Bits.IPEN01 */


/** \brief Length for Ifx_SCU_IGCR_Bits.IPEN02 */


/** \brief Mask for Ifx_SCU_IGCR_Bits.IPEN02 */


/** \brief Offset for Ifx_SCU_IGCR_Bits.IPEN02 */


/** \brief Length for Ifx_SCU_IGCR_Bits.IPEN03 */


/** \brief Mask for Ifx_SCU_IGCR_Bits.IPEN03 */


/** \brief Offset for Ifx_SCU_IGCR_Bits.IPEN03 */


/** \brief Length for Ifx_SCU_IGCR_Bits.IPEN04 */


/** \brief Mask for Ifx_SCU_IGCR_Bits.IPEN04 */


/** \brief Offset for Ifx_SCU_IGCR_Bits.IPEN04 */


/** \brief Length for Ifx_SCU_IGCR_Bits.IPEN05 */


/** \brief Mask for Ifx_SCU_IGCR_Bits.IPEN05 */


/** \brief Offset for Ifx_SCU_IGCR_Bits.IPEN05 */


/** \brief Length for Ifx_SCU_IGCR_Bits.IPEN06 */


/** \brief Mask for Ifx_SCU_IGCR_Bits.IPEN06 */


/** \brief Offset for Ifx_SCU_IGCR_Bits.IPEN06 */


/** \brief Length for Ifx_SCU_IGCR_Bits.IPEN07 */


/** \brief Mask for Ifx_SCU_IGCR_Bits.IPEN07 */


/** \brief Offset for Ifx_SCU_IGCR_Bits.IPEN07 */


/** \brief Length for Ifx_SCU_IGCR_Bits.GEEN0 */


/** \brief Mask for Ifx_SCU_IGCR_Bits.GEEN0 */


/** \brief Offset for Ifx_SCU_IGCR_Bits.GEEN0 */


/** \brief Length for Ifx_SCU_IGCR_Bits.IGP0 */


/** \brief Mask for Ifx_SCU_IGCR_Bits.IGP0 */


/** \brief Offset for Ifx_SCU_IGCR_Bits.IGP0 */


/** \brief Length for Ifx_SCU_IGCR_Bits.IPEN10 */


/** \brief Mask for Ifx_SCU_IGCR_Bits.IPEN10 */


/** \brief Offset for Ifx_SCU_IGCR_Bits.IPEN10 */


/** \brief Length for Ifx_SCU_IGCR_Bits.IPEN11 */


/** \brief Mask for Ifx_SCU_IGCR_Bits.IPEN11 */


/** \brief Offset for Ifx_SCU_IGCR_Bits.IPEN11 */


/** \brief Length for Ifx_SCU_IGCR_Bits.IPEN12 */


/** \brief Mask for Ifx_SCU_IGCR_Bits.IPEN12 */


/** \brief Offset for Ifx_SCU_IGCR_Bits.IPEN12 */


/** \brief Length for Ifx_SCU_IGCR_Bits.IPEN13 */


/** \brief Mask for Ifx_SCU_IGCR_Bits.IPEN13 */


/** \brief Offset for Ifx_SCU_IGCR_Bits.IPEN13 */


/** \brief Length for Ifx_SCU_IGCR_Bits.IPEN14 */


/** \brief Mask for Ifx_SCU_IGCR_Bits.IPEN14 */


/** \brief Offset for Ifx_SCU_IGCR_Bits.IPEN14 */


/** \brief Length for Ifx_SCU_IGCR_Bits.IPEN15 */


/** \brief Mask for Ifx_SCU_IGCR_Bits.IPEN15 */


/** \brief Offset for Ifx_SCU_IGCR_Bits.IPEN15 */


/** \brief Length for Ifx_SCU_IGCR_Bits.IPEN16 */


/** \brief Mask for Ifx_SCU_IGCR_Bits.IPEN16 */


/** \brief Offset for Ifx_SCU_IGCR_Bits.IPEN16 */


/** \brief Length for Ifx_SCU_IGCR_Bits.IPEN17 */


/** \brief Mask for Ifx_SCU_IGCR_Bits.IPEN17 */


/** \brief Offset for Ifx_SCU_IGCR_Bits.IPEN17 */


/** \brief Length for Ifx_SCU_IGCR_Bits.GEEN1 */


/** \brief Mask for Ifx_SCU_IGCR_Bits.GEEN1 */


/** \brief Offset for Ifx_SCU_IGCR_Bits.GEEN1 */


/** \brief Length for Ifx_SCU_IGCR_Bits.IGP1 */


/** \brief Mask for Ifx_SCU_IGCR_Bits.IGP1 */


/** \brief Offset for Ifx_SCU_IGCR_Bits.IGP1 */


/** \brief Length for Ifx_SCU_WDTCPU_CON0_Bits.ENDINIT */


/** \brief Mask for Ifx_SCU_WDTCPU_CON0_Bits.ENDINIT */


/** \brief Offset for Ifx_SCU_WDTCPU_CON0_Bits.ENDINIT */


/** \brief Length for Ifx_SCU_WDTCPU_CON0_Bits.LCK */


/** \brief Mask for Ifx_SCU_WDTCPU_CON0_Bits.LCK */


/** \brief Offset for Ifx_SCU_WDTCPU_CON0_Bits.LCK */


/** \brief Length for Ifx_SCU_WDTCPU_CON0_Bits.PW */


/** \brief Mask for Ifx_SCU_WDTCPU_CON0_Bits.PW */


/** \brief Offset for Ifx_SCU_WDTCPU_CON0_Bits.PW */


/** \brief Length for Ifx_SCU_WDTCPU_CON0_Bits.REL */


/** \brief Mask for Ifx_SCU_WDTCPU_CON0_Bits.REL */


/** \brief Offset for Ifx_SCU_WDTCPU_CON0_Bits.REL */


/** \brief Length for Ifx_SCU_WDTCPU_CON1_Bits.IR0 */


/** \brief Mask for Ifx_SCU_WDTCPU_CON1_Bits.IR0 */


/** \brief Offset for Ifx_SCU_WDTCPU_CON1_Bits.IR0 */


/** \brief Length for Ifx_SCU_WDTCPU_CON1_Bits.DR */


/** \brief Mask for Ifx_SCU_WDTCPU_CON1_Bits.DR */


/** \brief Offset for Ifx_SCU_WDTCPU_CON1_Bits.DR */


/** \brief Length for Ifx_SCU_WDTCPU_CON1_Bits.IR1 */


/** \brief Mask for Ifx_SCU_WDTCPU_CON1_Bits.IR1 */


/** \brief Offset for Ifx_SCU_WDTCPU_CON1_Bits.IR1 */


/** \brief Length for Ifx_SCU_WDTCPU_CON1_Bits.UR */


/** \brief Mask for Ifx_SCU_WDTCPU_CON1_Bits.UR */


/** \brief Offset for Ifx_SCU_WDTCPU_CON1_Bits.UR */


/** \brief Length for Ifx_SCU_WDTCPU_CON1_Bits.PAR */


/** \brief Mask for Ifx_SCU_WDTCPU_CON1_Bits.PAR */


/** \brief Offset for Ifx_SCU_WDTCPU_CON1_Bits.PAR */


/** \brief Length for Ifx_SCU_WDTCPU_CON1_Bits.TCR */


/** \brief Mask for Ifx_SCU_WDTCPU_CON1_Bits.TCR */


/** \brief Offset for Ifx_SCU_WDTCPU_CON1_Bits.TCR */


/** \brief Length for Ifx_SCU_WDTCPU_CON1_Bits.TCTR */


/** \brief Mask for Ifx_SCU_WDTCPU_CON1_Bits.TCTR */


/** \brief Offset for Ifx_SCU_WDTCPU_CON1_Bits.TCTR */


/** \brief Length for Ifx_SCU_WDTCPU_SR_Bits.AE */


/** \brief Mask for Ifx_SCU_WDTCPU_SR_Bits.AE */


/** \brief Offset for Ifx_SCU_WDTCPU_SR_Bits.AE */


/** \brief Length for Ifx_SCU_WDTCPU_SR_Bits.OE */


/** \brief Mask for Ifx_SCU_WDTCPU_SR_Bits.OE */


/** \brief Offset for Ifx_SCU_WDTCPU_SR_Bits.OE */


/** \brief Length for Ifx_SCU_WDTCPU_SR_Bits.IS0 */


/** \brief Mask for Ifx_SCU_WDTCPU_SR_Bits.IS0 */


/** \brief Offset for Ifx_SCU_WDTCPU_SR_Bits.IS0 */


/** \brief Length for Ifx_SCU_WDTCPU_SR_Bits.DS */


/** \brief Mask for Ifx_SCU_WDTCPU_SR_Bits.DS */


/** \brief Offset for Ifx_SCU_WDTCPU_SR_Bits.DS */


/** \brief Length for Ifx_SCU_WDTCPU_SR_Bits.TO */


/** \brief Mask for Ifx_SCU_WDTCPU_SR_Bits.TO */


/** \brief Offset for Ifx_SCU_WDTCPU_SR_Bits.TO */


/** \brief Length for Ifx_SCU_WDTCPU_SR_Bits.IS1 */


/** \brief Mask for Ifx_SCU_WDTCPU_SR_Bits.IS1 */


/** \brief Offset for Ifx_SCU_WDTCPU_SR_Bits.IS1 */


/** \brief Length for Ifx_SCU_WDTCPU_SR_Bits.US */


/** \brief Mask for Ifx_SCU_WDTCPU_SR_Bits.US */


/** \brief Offset for Ifx_SCU_WDTCPU_SR_Bits.US */


/** \brief Length for Ifx_SCU_WDTCPU_SR_Bits.PAS */


/** \brief Mask for Ifx_SCU_WDTCPU_SR_Bits.PAS */


/** \brief Offset for Ifx_SCU_WDTCPU_SR_Bits.PAS */


/** \brief Length for Ifx_SCU_WDTCPU_SR_Bits.TCS */


/** \brief Mask for Ifx_SCU_WDTCPU_SR_Bits.TCS */


/** \brief Offset for Ifx_SCU_WDTCPU_SR_Bits.TCS */


/** \brief Length for Ifx_SCU_WDTCPU_SR_Bits.TCT */


/** \brief Mask for Ifx_SCU_WDTCPU_SR_Bits.TCT */


/** \brief Offset for Ifx_SCU_WDTCPU_SR_Bits.TCT */


/** \brief Length for Ifx_SCU_WDTCPU_SR_Bits.TIM */


/** \brief Mask for Ifx_SCU_WDTCPU_SR_Bits.TIM */


/** \brief Offset for Ifx_SCU_WDTCPU_SR_Bits.TIM */


/** \brief Length for Ifx_SCU_EICON0_Bits.ENDINIT */


/** \brief Mask for Ifx_SCU_EICON0_Bits.ENDINIT */


/** \brief Offset for Ifx_SCU_EICON0_Bits.ENDINIT */


/** \brief Length for Ifx_SCU_EICON0_Bits.EPW */


/** \brief Mask for Ifx_SCU_EICON0_Bits.EPW */


/** \brief Offset for Ifx_SCU_EICON0_Bits.EPW */


/** \brief Length for Ifx_SCU_EICON0_Bits.REL */


/** \brief Mask for Ifx_SCU_EICON0_Bits.REL */


/** \brief Offset for Ifx_SCU_EICON0_Bits.REL */


/** \brief Length for Ifx_SCU_EICON1_Bits.IR0 */


/** \brief Mask for Ifx_SCU_EICON1_Bits.IR0 */


/** \brief Offset for Ifx_SCU_EICON1_Bits.IR0 */


/** \brief Length for Ifx_SCU_EICON1_Bits.DR */


/** \brief Mask for Ifx_SCU_EICON1_Bits.DR */


/** \brief Offset for Ifx_SCU_EICON1_Bits.DR */


/** \brief Length for Ifx_SCU_EICON1_Bits.IR1 */


/** \brief Mask for Ifx_SCU_EICON1_Bits.IR1 */


/** \brief Offset for Ifx_SCU_EICON1_Bits.IR1 */


/** \brief Length for Ifx_SCU_EISR_Bits.AE */


/** \brief Mask for Ifx_SCU_EISR_Bits.AE */


/** \brief Offset for Ifx_SCU_EISR_Bits.AE */


/** \brief Length for Ifx_SCU_EISR_Bits.OE */


/** \brief Mask for Ifx_SCU_EISR_Bits.OE */


/** \brief Offset for Ifx_SCU_EISR_Bits.OE */


/** \brief Length for Ifx_SCU_EISR_Bits.IS0 */


/** \brief Mask for Ifx_SCU_EISR_Bits.IS0 */


/** \brief Offset for Ifx_SCU_EISR_Bits.IS0 */


/** \brief Length for Ifx_SCU_EISR_Bits.DS */


/** \brief Mask for Ifx_SCU_EISR_Bits.DS */


/** \brief Offset for Ifx_SCU_EISR_Bits.DS */


/** \brief Length for Ifx_SCU_EISR_Bits.TO */


/** \brief Mask for Ifx_SCU_EISR_Bits.TO */


/** \brief Offset for Ifx_SCU_EISR_Bits.TO */


/** \brief Length for Ifx_SCU_EISR_Bits.IS1 */


/** \brief Mask for Ifx_SCU_EISR_Bits.IS1 */


/** \brief Offset for Ifx_SCU_EISR_Bits.IS1 */


/** \brief Length for Ifx_SCU_EISR_Bits.TIM */


/** \brief Mask for Ifx_SCU_EISR_Bits.TIM */


/** \brief Offset for Ifx_SCU_EISR_Bits.TIM */


/** \brief Length for Ifx_SCU_WDTS_CON0_Bits.ENDINIT */


/** \brief Mask for Ifx_SCU_WDTS_CON0_Bits.ENDINIT */


/** \brief Offset for Ifx_SCU_WDTS_CON0_Bits.ENDINIT */


/** \brief Length for Ifx_SCU_WDTS_CON0_Bits.LCK */


/** \brief Mask for Ifx_SCU_WDTS_CON0_Bits.LCK */


/** \brief Offset for Ifx_SCU_WDTS_CON0_Bits.LCK */


/** \brief Length for Ifx_SCU_WDTS_CON0_Bits.PW */


/** \brief Mask for Ifx_SCU_WDTS_CON0_Bits.PW */


/** \brief Offset for Ifx_SCU_WDTS_CON0_Bits.PW */


/** \brief Length for Ifx_SCU_WDTS_CON0_Bits.REL */


/** \brief Mask for Ifx_SCU_WDTS_CON0_Bits.REL */


/** \brief Offset for Ifx_SCU_WDTS_CON0_Bits.REL */


/** \brief Length for Ifx_SCU_WDTS_CON1_Bits.CLRIRF */


/** \brief Mask for Ifx_SCU_WDTS_CON1_Bits.CLRIRF */


/** \brief Offset for Ifx_SCU_WDTS_CON1_Bits.CLRIRF */


/** \brief Length for Ifx_SCU_WDTS_CON1_Bits.IR0 */


/** \brief Mask for Ifx_SCU_WDTS_CON1_Bits.IR0 */


/** \brief Offset for Ifx_SCU_WDTS_CON1_Bits.IR0 */


/** \brief Length for Ifx_SCU_WDTS_CON1_Bits.DR */


/** \brief Mask for Ifx_SCU_WDTS_CON1_Bits.DR */


/** \brief Offset for Ifx_SCU_WDTS_CON1_Bits.DR */


/** \brief Length for Ifx_SCU_WDTS_CON1_Bits.IR1 */


/** \brief Mask for Ifx_SCU_WDTS_CON1_Bits.IR1 */


/** \brief Offset for Ifx_SCU_WDTS_CON1_Bits.IR1 */


/** \brief Length for Ifx_SCU_WDTS_CON1_Bits.UR */


/** \brief Mask for Ifx_SCU_WDTS_CON1_Bits.UR */


/** \brief Offset for Ifx_SCU_WDTS_CON1_Bits.UR */


/** \brief Length for Ifx_SCU_WDTS_CON1_Bits.PAR */


/** \brief Mask for Ifx_SCU_WDTS_CON1_Bits.PAR */


/** \brief Offset for Ifx_SCU_WDTS_CON1_Bits.PAR */


/** \brief Length for Ifx_SCU_WDTS_CON1_Bits.TCR */


/** \brief Mask for Ifx_SCU_WDTS_CON1_Bits.TCR */


/** \brief Offset for Ifx_SCU_WDTS_CON1_Bits.TCR */


/** \brief Length for Ifx_SCU_WDTS_CON1_Bits.TCTR */


/** \brief Mask for Ifx_SCU_WDTS_CON1_Bits.TCTR */


/** \brief Offset for Ifx_SCU_WDTS_CON1_Bits.TCTR */


/** \brief Length for Ifx_SCU_WDTS_SR_Bits.AE */


/** \brief Mask for Ifx_SCU_WDTS_SR_Bits.AE */


/** \brief Offset for Ifx_SCU_WDTS_SR_Bits.AE */


/** \brief Length for Ifx_SCU_WDTS_SR_Bits.OE */


/** \brief Mask for Ifx_SCU_WDTS_SR_Bits.OE */


/** \brief Offset for Ifx_SCU_WDTS_SR_Bits.OE */


/** \brief Length for Ifx_SCU_WDTS_SR_Bits.IS0 */


/** \brief Mask for Ifx_SCU_WDTS_SR_Bits.IS0 */


/** \brief Offset for Ifx_SCU_WDTS_SR_Bits.IS0 */


/** \brief Length for Ifx_SCU_WDTS_SR_Bits.DS */


/** \brief Mask for Ifx_SCU_WDTS_SR_Bits.DS */


/** \brief Offset for Ifx_SCU_WDTS_SR_Bits.DS */


/** \brief Length for Ifx_SCU_WDTS_SR_Bits.TO */


/** \brief Mask for Ifx_SCU_WDTS_SR_Bits.TO */


/** \brief Offset for Ifx_SCU_WDTS_SR_Bits.TO */


/** \brief Length for Ifx_SCU_WDTS_SR_Bits.IS1 */


/** \brief Mask for Ifx_SCU_WDTS_SR_Bits.IS1 */


/** \brief Offset for Ifx_SCU_WDTS_SR_Bits.IS1 */


/** \brief Length for Ifx_SCU_WDTS_SR_Bits.US */


/** \brief Mask for Ifx_SCU_WDTS_SR_Bits.US */


/** \brief Offset for Ifx_SCU_WDTS_SR_Bits.US */


/** \brief Length for Ifx_SCU_WDTS_SR_Bits.PAS */


/** \brief Mask for Ifx_SCU_WDTS_SR_Bits.PAS */


/** \brief Offset for Ifx_SCU_WDTS_SR_Bits.PAS */


/** \brief Length for Ifx_SCU_WDTS_SR_Bits.TCS */


/** \brief Mask for Ifx_SCU_WDTS_SR_Bits.TCS */


/** \brief Offset for Ifx_SCU_WDTS_SR_Bits.TCS */


/** \brief Length for Ifx_SCU_WDTS_SR_Bits.TCT */


/** \brief Mask for Ifx_SCU_WDTS_SR_Bits.TCT */


/** \brief Offset for Ifx_SCU_WDTS_SR_Bits.TCT */


/** \brief Length for Ifx_SCU_WDTS_SR_Bits.TIM */


/** \brief Mask for Ifx_SCU_WDTS_SR_Bits.TIM */


/** \brief Offset for Ifx_SCU_WDTS_SR_Bits.TIM */


/** \brief Length for Ifx_SCU_SEICON0_Bits.ENDINIT */


/** \brief Mask for Ifx_SCU_SEICON0_Bits.ENDINIT */


/** \brief Offset for Ifx_SCU_SEICON0_Bits.ENDINIT */


/** \brief Length for Ifx_SCU_SEICON0_Bits.EPW */


/** \brief Mask for Ifx_SCU_SEICON0_Bits.EPW */


/** \brief Offset for Ifx_SCU_SEICON0_Bits.EPW */


/** \brief Length for Ifx_SCU_SEICON0_Bits.REL */


/** \brief Mask for Ifx_SCU_SEICON0_Bits.REL */


/** \brief Offset for Ifx_SCU_SEICON0_Bits.REL */


/** \brief Length for Ifx_SCU_SEICON1_Bits.IR0 */


/** \brief Mask for Ifx_SCU_SEICON1_Bits.IR0 */


/** \brief Offset for Ifx_SCU_SEICON1_Bits.IR0 */


/** \brief Length for Ifx_SCU_SEICON1_Bits.DR */


/** \brief Mask for Ifx_SCU_SEICON1_Bits.DR */


/** \brief Offset for Ifx_SCU_SEICON1_Bits.DR */


/** \brief Length for Ifx_SCU_SEICON1_Bits.IR1 */


/** \brief Mask for Ifx_SCU_SEICON1_Bits.IR1 */


/** \brief Offset for Ifx_SCU_SEICON1_Bits.IR1 */


/** \brief Length for Ifx_SCU_SEISR_Bits.AE */


/** \brief Mask for Ifx_SCU_SEISR_Bits.AE */


/** \brief Offset for Ifx_SCU_SEISR_Bits.AE */


/** \brief Length for Ifx_SCU_SEISR_Bits.OE */


/** \brief Mask for Ifx_SCU_SEISR_Bits.OE */


/** \brief Offset for Ifx_SCU_SEISR_Bits.OE */


/** \brief Length for Ifx_SCU_SEISR_Bits.IS0 */


/** \brief Mask for Ifx_SCU_SEISR_Bits.IS0 */


/** \brief Offset for Ifx_SCU_SEISR_Bits.IS0 */


/** \brief Length for Ifx_SCU_SEISR_Bits.DS */


/** \brief Mask for Ifx_SCU_SEISR_Bits.DS */


/** \brief Offset for Ifx_SCU_SEISR_Bits.DS */


/** \brief Length for Ifx_SCU_SEISR_Bits.TO */


/** \brief Mask for Ifx_SCU_SEISR_Bits.TO */


/** \brief Offset for Ifx_SCU_SEISR_Bits.TO */


/** \brief Length for Ifx_SCU_SEISR_Bits.IS1 */


/** \brief Mask for Ifx_SCU_SEISR_Bits.IS1 */


/** \brief Offset for Ifx_SCU_SEISR_Bits.IS1 */


/** \brief Length for Ifx_SCU_SEISR_Bits.TIM */


/** \brief Mask for Ifx_SCU_SEISR_Bits.TIM */


/** \brief Offset for Ifx_SCU_SEISR_Bits.TIM */


/** \brief Length for Ifx_SCU_ACCEN10_Bits.EN0 */


/** \brief Mask for Ifx_SCU_ACCEN10_Bits.EN0 */


/** \brief Offset for Ifx_SCU_ACCEN10_Bits.EN0 */


/** \brief Length for Ifx_SCU_ACCEN10_Bits.EN1 */


/** \brief Mask for Ifx_SCU_ACCEN10_Bits.EN1 */


/** \brief Offset for Ifx_SCU_ACCEN10_Bits.EN1 */


/** \brief Length for Ifx_SCU_ACCEN10_Bits.EN2 */


/** \brief Mask for Ifx_SCU_ACCEN10_Bits.EN2 */


/** \brief Offset for Ifx_SCU_ACCEN10_Bits.EN2 */


/** \brief Length for Ifx_SCU_ACCEN10_Bits.EN3 */


/** \brief Mask for Ifx_SCU_ACCEN10_Bits.EN3 */


/** \brief Offset for Ifx_SCU_ACCEN10_Bits.EN3 */


/** \brief Length for Ifx_SCU_ACCEN10_Bits.EN4 */


/** \brief Mask for Ifx_SCU_ACCEN10_Bits.EN4 */


/** \brief Offset for Ifx_SCU_ACCEN10_Bits.EN4 */


/** \brief Length for Ifx_SCU_ACCEN10_Bits.EN5 */


/** \brief Mask for Ifx_SCU_ACCEN10_Bits.EN5 */


/** \brief Offset for Ifx_SCU_ACCEN10_Bits.EN5 */


/** \brief Length for Ifx_SCU_ACCEN10_Bits.EN6 */


/** \brief Mask for Ifx_SCU_ACCEN10_Bits.EN6 */


/** \brief Offset for Ifx_SCU_ACCEN10_Bits.EN6 */


/** \brief Length for Ifx_SCU_ACCEN10_Bits.EN7 */


/** \brief Mask for Ifx_SCU_ACCEN10_Bits.EN7 */


/** \brief Offset for Ifx_SCU_ACCEN10_Bits.EN7 */


/** \brief Length for Ifx_SCU_ACCEN10_Bits.EN8 */


/** \brief Mask for Ifx_SCU_ACCEN10_Bits.EN8 */


/** \brief Offset for Ifx_SCU_ACCEN10_Bits.EN8 */


/** \brief Length for Ifx_SCU_ACCEN10_Bits.EN9 */


/** \brief Mask for Ifx_SCU_ACCEN10_Bits.EN9 */


/** \brief Offset for Ifx_SCU_ACCEN10_Bits.EN9 */


/** \brief Length for Ifx_SCU_ACCEN10_Bits.EN10 */


/** \brief Mask for Ifx_SCU_ACCEN10_Bits.EN10 */


/** \brief Offset for Ifx_SCU_ACCEN10_Bits.EN10 */


/** \brief Length for Ifx_SCU_ACCEN10_Bits.EN11 */


/** \brief Mask for Ifx_SCU_ACCEN10_Bits.EN11 */


/** \brief Offset for Ifx_SCU_ACCEN10_Bits.EN11 */


/** \brief Length for Ifx_SCU_ACCEN10_Bits.EN12 */


/** \brief Mask for Ifx_SCU_ACCEN10_Bits.EN12 */


/** \brief Offset for Ifx_SCU_ACCEN10_Bits.EN12 */


/** \brief Length for Ifx_SCU_ACCEN10_Bits.EN13 */


/** \brief Mask for Ifx_SCU_ACCEN10_Bits.EN13 */


/** \brief Offset for Ifx_SCU_ACCEN10_Bits.EN13 */


/** \brief Length for Ifx_SCU_ACCEN10_Bits.EN14 */


/** \brief Mask for Ifx_SCU_ACCEN10_Bits.EN14 */


/** \brief Offset for Ifx_SCU_ACCEN10_Bits.EN14 */


/** \brief Length for Ifx_SCU_ACCEN10_Bits.EN15 */


/** \brief Mask for Ifx_SCU_ACCEN10_Bits.EN15 */


/** \brief Offset for Ifx_SCU_ACCEN10_Bits.EN15 */


/** \brief Length for Ifx_SCU_ACCEN10_Bits.EN16 */


/** \brief Mask for Ifx_SCU_ACCEN10_Bits.EN16 */


/** \brief Offset for Ifx_SCU_ACCEN10_Bits.EN16 */


/** \brief Length for Ifx_SCU_ACCEN10_Bits.EN17 */


/** \brief Mask for Ifx_SCU_ACCEN10_Bits.EN17 */


/** \brief Offset for Ifx_SCU_ACCEN10_Bits.EN17 */


/** \brief Length for Ifx_SCU_ACCEN10_Bits.EN18 */


/** \brief Mask for Ifx_SCU_ACCEN10_Bits.EN18 */


/** \brief Offset for Ifx_SCU_ACCEN10_Bits.EN18 */


/** \brief Length for Ifx_SCU_ACCEN10_Bits.EN19 */


/** \brief Mask for Ifx_SCU_ACCEN10_Bits.EN19 */


/** \brief Offset for Ifx_SCU_ACCEN10_Bits.EN19 */


/** \brief Length for Ifx_SCU_ACCEN10_Bits.EN20 */


/** \brief Mask for Ifx_SCU_ACCEN10_Bits.EN20 */


/** \brief Offset for Ifx_SCU_ACCEN10_Bits.EN20 */


/** \brief Length for Ifx_SCU_ACCEN10_Bits.EN21 */


/** \brief Mask for Ifx_SCU_ACCEN10_Bits.EN21 */


/** \brief Offset for Ifx_SCU_ACCEN10_Bits.EN21 */


/** \brief Length for Ifx_SCU_ACCEN10_Bits.EN22 */


/** \brief Mask for Ifx_SCU_ACCEN10_Bits.EN22 */


/** \brief Offset for Ifx_SCU_ACCEN10_Bits.EN22 */


/** \brief Length for Ifx_SCU_ACCEN10_Bits.EN23 */


/** \brief Mask for Ifx_SCU_ACCEN10_Bits.EN23 */


/** \brief Offset for Ifx_SCU_ACCEN10_Bits.EN23 */


/** \brief Length for Ifx_SCU_ACCEN10_Bits.EN24 */


/** \brief Mask for Ifx_SCU_ACCEN10_Bits.EN24 */


/** \brief Offset for Ifx_SCU_ACCEN10_Bits.EN24 */


/** \brief Length for Ifx_SCU_ACCEN10_Bits.EN25 */


/** \brief Mask for Ifx_SCU_ACCEN10_Bits.EN25 */


/** \brief Offset for Ifx_SCU_ACCEN10_Bits.EN25 */


/** \brief Length for Ifx_SCU_ACCEN10_Bits.EN26 */


/** \brief Mask for Ifx_SCU_ACCEN10_Bits.EN26 */


/** \brief Offset for Ifx_SCU_ACCEN10_Bits.EN26 */


/** \brief Length for Ifx_SCU_ACCEN10_Bits.EN27 */


/** \brief Mask for Ifx_SCU_ACCEN10_Bits.EN27 */


/** \brief Offset for Ifx_SCU_ACCEN10_Bits.EN27 */


/** \brief Length for Ifx_SCU_ACCEN10_Bits.EN28 */


/** \brief Mask for Ifx_SCU_ACCEN10_Bits.EN28 */


/** \brief Offset for Ifx_SCU_ACCEN10_Bits.EN28 */


/** \brief Length for Ifx_SCU_ACCEN10_Bits.EN29 */


/** \brief Mask for Ifx_SCU_ACCEN10_Bits.EN29 */


/** \brief Offset for Ifx_SCU_ACCEN10_Bits.EN29 */


/** \brief Length for Ifx_SCU_ACCEN10_Bits.EN30 */


/** \brief Mask for Ifx_SCU_ACCEN10_Bits.EN30 */


/** \brief Offset for Ifx_SCU_ACCEN10_Bits.EN30 */


/** \brief Length for Ifx_SCU_ACCEN10_Bits.EN31 */


/** \brief Mask for Ifx_SCU_ACCEN10_Bits.EN31 */


/** \brief Offset for Ifx_SCU_ACCEN10_Bits.EN31 */


/** \brief Length for Ifx_SCU_ACCEN00_Bits.EN0 */


/** \brief Mask for Ifx_SCU_ACCEN00_Bits.EN0 */


/** \brief Offset for Ifx_SCU_ACCEN00_Bits.EN0 */


/** \brief Length for Ifx_SCU_ACCEN00_Bits.EN1 */


/** \brief Mask for Ifx_SCU_ACCEN00_Bits.EN1 */


/** \brief Offset for Ifx_SCU_ACCEN00_Bits.EN1 */


/** \brief Length for Ifx_SCU_ACCEN00_Bits.EN2 */


/** \brief Mask for Ifx_SCU_ACCEN00_Bits.EN2 */


/** \brief Offset for Ifx_SCU_ACCEN00_Bits.EN2 */


/** \brief Length for Ifx_SCU_ACCEN00_Bits.EN3 */


/** \brief Mask for Ifx_SCU_ACCEN00_Bits.EN3 */


/** \brief Offset for Ifx_SCU_ACCEN00_Bits.EN3 */


/** \brief Length for Ifx_SCU_ACCEN00_Bits.EN4 */


/** \brief Mask for Ifx_SCU_ACCEN00_Bits.EN4 */


/** \brief Offset for Ifx_SCU_ACCEN00_Bits.EN4 */


/** \brief Length for Ifx_SCU_ACCEN00_Bits.EN5 */


/** \brief Mask for Ifx_SCU_ACCEN00_Bits.EN5 */


/** \brief Offset for Ifx_SCU_ACCEN00_Bits.EN5 */


/** \brief Length for Ifx_SCU_ACCEN00_Bits.EN6 */


/** \brief Mask for Ifx_SCU_ACCEN00_Bits.EN6 */


/** \brief Offset for Ifx_SCU_ACCEN00_Bits.EN6 */


/** \brief Length for Ifx_SCU_ACCEN00_Bits.EN7 */


/** \brief Mask for Ifx_SCU_ACCEN00_Bits.EN7 */


/** \brief Offset for Ifx_SCU_ACCEN00_Bits.EN7 */


/** \brief Length for Ifx_SCU_ACCEN00_Bits.EN8 */


/** \brief Mask for Ifx_SCU_ACCEN00_Bits.EN8 */


/** \brief Offset for Ifx_SCU_ACCEN00_Bits.EN8 */


/** \brief Length for Ifx_SCU_ACCEN00_Bits.EN9 */


/** \brief Mask for Ifx_SCU_ACCEN00_Bits.EN9 */


/** \brief Offset for Ifx_SCU_ACCEN00_Bits.EN9 */


/** \brief Length for Ifx_SCU_ACCEN00_Bits.EN10 */


/** \brief Mask for Ifx_SCU_ACCEN00_Bits.EN10 */


/** \brief Offset for Ifx_SCU_ACCEN00_Bits.EN10 */


/** \brief Length for Ifx_SCU_ACCEN00_Bits.EN11 */


/** \brief Mask for Ifx_SCU_ACCEN00_Bits.EN11 */


/** \brief Offset for Ifx_SCU_ACCEN00_Bits.EN11 */


/** \brief Length for Ifx_SCU_ACCEN00_Bits.EN12 */


/** \brief Mask for Ifx_SCU_ACCEN00_Bits.EN12 */


/** \brief Offset for Ifx_SCU_ACCEN00_Bits.EN12 */


/** \brief Length for Ifx_SCU_ACCEN00_Bits.EN13 */


/** \brief Mask for Ifx_SCU_ACCEN00_Bits.EN13 */


/** \brief Offset for Ifx_SCU_ACCEN00_Bits.EN13 */


/** \brief Length for Ifx_SCU_ACCEN00_Bits.EN14 */


/** \brief Mask for Ifx_SCU_ACCEN00_Bits.EN14 */


/** \brief Offset for Ifx_SCU_ACCEN00_Bits.EN14 */


/** \brief Length for Ifx_SCU_ACCEN00_Bits.EN15 */


/** \brief Mask for Ifx_SCU_ACCEN00_Bits.EN15 */


/** \brief Offset for Ifx_SCU_ACCEN00_Bits.EN15 */


/** \brief Length for Ifx_SCU_ACCEN00_Bits.EN16 */


/** \brief Mask for Ifx_SCU_ACCEN00_Bits.EN16 */


/** \brief Offset for Ifx_SCU_ACCEN00_Bits.EN16 */


/** \brief Length for Ifx_SCU_ACCEN00_Bits.EN17 */


/** \brief Mask for Ifx_SCU_ACCEN00_Bits.EN17 */


/** \brief Offset for Ifx_SCU_ACCEN00_Bits.EN17 */


/** \brief Length for Ifx_SCU_ACCEN00_Bits.EN18 */


/** \brief Mask for Ifx_SCU_ACCEN00_Bits.EN18 */


/** \brief Offset for Ifx_SCU_ACCEN00_Bits.EN18 */


/** \brief Length for Ifx_SCU_ACCEN00_Bits.EN19 */


/** \brief Mask for Ifx_SCU_ACCEN00_Bits.EN19 */


/** \brief Offset for Ifx_SCU_ACCEN00_Bits.EN19 */


/** \brief Length for Ifx_SCU_ACCEN00_Bits.EN20 */


/** \brief Mask for Ifx_SCU_ACCEN00_Bits.EN20 */


/** \brief Offset for Ifx_SCU_ACCEN00_Bits.EN20 */


/** \brief Length for Ifx_SCU_ACCEN00_Bits.EN21 */


/** \brief Mask for Ifx_SCU_ACCEN00_Bits.EN21 */


/** \brief Offset for Ifx_SCU_ACCEN00_Bits.EN21 */


/** \brief Length for Ifx_SCU_ACCEN00_Bits.EN22 */


/** \brief Mask for Ifx_SCU_ACCEN00_Bits.EN22 */


/** \brief Offset for Ifx_SCU_ACCEN00_Bits.EN22 */


/** \brief Length for Ifx_SCU_ACCEN00_Bits.EN23 */


/** \brief Mask for Ifx_SCU_ACCEN00_Bits.EN23 */


/** \brief Offset for Ifx_SCU_ACCEN00_Bits.EN23 */


/** \brief Length for Ifx_SCU_ACCEN00_Bits.EN24 */


/** \brief Mask for Ifx_SCU_ACCEN00_Bits.EN24 */


/** \brief Offset for Ifx_SCU_ACCEN00_Bits.EN24 */


/** \brief Length for Ifx_SCU_ACCEN00_Bits.EN25 */


/** \brief Mask for Ifx_SCU_ACCEN00_Bits.EN25 */


/** \brief Offset for Ifx_SCU_ACCEN00_Bits.EN25 */


/** \brief Length for Ifx_SCU_ACCEN00_Bits.EN26 */


/** \brief Mask for Ifx_SCU_ACCEN00_Bits.EN26 */


/** \brief Offset for Ifx_SCU_ACCEN00_Bits.EN26 */


/** \brief Length for Ifx_SCU_ACCEN00_Bits.EN27 */


/** \brief Mask for Ifx_SCU_ACCEN00_Bits.EN27 */


/** \brief Offset for Ifx_SCU_ACCEN00_Bits.EN27 */


/** \brief Length for Ifx_SCU_ACCEN00_Bits.EN28 */


/** \brief Mask for Ifx_SCU_ACCEN00_Bits.EN28 */


/** \brief Offset for Ifx_SCU_ACCEN00_Bits.EN28 */


/** \brief Length for Ifx_SCU_ACCEN00_Bits.EN29 */


/** \brief Mask for Ifx_SCU_ACCEN00_Bits.EN29 */


/** \brief Offset for Ifx_SCU_ACCEN00_Bits.EN29 */


/** \brief Length for Ifx_SCU_ACCEN00_Bits.EN30 */


/** \brief Mask for Ifx_SCU_ACCEN00_Bits.EN30 */


/** \brief Offset for Ifx_SCU_ACCEN00_Bits.EN30 */


/** \brief Length for Ifx_SCU_ACCEN00_Bits.EN31 */


/** \brief Mask for Ifx_SCU_ACCEN00_Bits.EN31 */


/** \brief Offset for Ifx_SCU_ACCEN00_Bits.EN31 */


/** \}  */

/******************************************************************************/

/******************************************************************************/


#line 54 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\_Impl\\IfxScu_cfg.h"

/******************************************************************************/
/*                           Macro                                            */
/******************************************************************************/

























/*The following frequency is the PLL free running frequency */




/* By Default - external crystal is chosen as input */
/* This can be set to external clock input by user */





/* iLLD Configs from Master CFG file */
/*Utility macros for the configuration structure */





























/******************************************************************************/
/*                           Per PLL Config                                   */
/******************************************************************************/



















/***************************************************************************************************/
/*************************MACROS To Configure SYSPLL Steps******************************************/
/* These Macros are used to Configure different profiles of frequency jump from FOsc to Target Freq*/
/* This is Important for the current jump Control during Clock Throttling                          */
/***************************************************************************************************/



































































/***************************************************************************************************/
/*********************** SYSPLL CONFIGURATIONS *****************************************************/
/***************************************************************************************************/

/*******************************16MHz Oscillator Frequency******************************************/


/************** Target = 80MHz *****************/

 
/**** Macro for Initial Pll step, for profile with 16MHz Crystal and 80MHz target (fDCO= 640)*/










/**** Macro for Pll step for profile with 16MHz Crystal and 80MHz target (fDCO= 640MHz)*/



/************** Target = 133MHz *****************/

 
/**** Macro for Initial Pll step, for profile with 16MHz Crystal and 133MHz target (fDCO= 800)*/










/**** Macro for Pll step for profile with 16MHz Crystal and 133MHz target (fDCO= 800MHz)*/



/************** Target = 240MHz *****************/

 
/**** Macro for Initial Pll step, for profile with 16MHz Crystal and 240MHz target (fDCO= 720)*/










/**** Macro for Pll step for profile with 16MHz Crystal and 240MHz target (fDCO= 720MHz)*/



/************** Target = 300MHz *****************/

 
/**** Macro for Initial Pll step, for profile with 16MHz Crystal and 300MHz target (fDCO= 600)*/










/**** Macro for Pll step for profile with 16MHz Crystal and 300MHz target (fDCO= 600MHz)*/



/*******************************20MHz Oscillator Frequency******************************************/


/************** Target = 200MHz *****************/

 
/**** Macro for Initial Pll step, for profile with 20MHz Crystal and 200MHz target (fDCO= 600)*/










/**** Macro for Pll step for profile with 20MHz Crystal and 200MHz target (fDCO= 600MHz)*/



/************** Target = 240MHz *****************/

 
/**** Macro for Initial Pll step, for profile with 20MHz Crystal and 240MHz target (fDCO= 720)*/










/**** Macro for Pll step for profile with 20MHz Crystal and 240MHz target (fDCO= 720MHz)*/



/************** Target = 300MHz *****************/

 
/**** Macro for Initial Pll step, for profile with 20MHz Crystal and 300MHz target (fDCO= 600)*/










/**** Macro for Pll step for profile with 20MHz Crystal and 300MHz target (fDCO= 600MHz)*/



/*******************************25MHz Oscillator Frequency******************************************/


/************** Target = 200MHz *****************/

 
/**** Macro for Initial Pll step, for profile with 25MHz Crystal and 200MHz target (fDCO= 600)*/










/**** Macro for Pll step for profile with 25MHz Crystal and 200MHz target (fDCO= 600MHz)*/



/************** Target = 300MHz *****************/

 
/**** Macro for Initial Pll step, for profile with 25MHz Crystal and 300MHz target (fDCO= 600)*/










/**** Macro for Pll step for profile with 25MHz Crystal and 300MHz target (fDCO= 600MHz)*/



/*******************************40MHz Oscillator Frequency******************************************/


/************** Target = 200MHz *****************/

 
/**** Macro for Initial Pll step, for profile with 40MHz Crystal and 200MHz target (fDCO= 600)*/










/**** Macro for Pll step for profile with 40MHz Crystal and 200MHz target (fDCO= 600MHz)*/



/************** Target = 240MHz *****************/

 
/**** Macro for Initial Pll step, for profile with 40MHz Crystal and 240MHz target (fDCO= 720)*/










/**** Macro for Pll step for profile with 40MHz Crystal and 240MHz target (fDCO= 720MHz)*/



/************** Target = 300MHz *****************/

 
/**** Macro for Initial Pll step, for profile with 40MHz Crystal and 300MHz target (fDCO= 600)*/










/**** Macro for Pll step for profile with 40MHz Crystal and 300MHz target (fDCO= 600MHz)*/



/***************************************************************************************************/
/*********************** PERPLL CONFIGURATIONS *****************************************************/
/***************************************************************************************************/

/*******************************16MHz Oscillator Frequency******************************************/


/************** Fpll1 = 320MHz, Fpll2 = 200MHz *****************/


/** \brief Macro for Initial Pll step, for profile with 16MHz Crystal and 320/200MHz target (fDCO= 640)*/





/************** Fpll1 = 160MHz, Fpll2 = 200MHz *****************/


/** \brief Macro for Initial Pll step, for profile with 16MHz Crystal and 160/200MHz target (fDCO= 640)*/





/*******************************20MHz Oscillator Frequency******************************************/


/************** Fpll1 = 320MHz, Fpll2 = 200MHz *****************/


/** \brief Macro for Initial Pll step, for profile with 20MHz Crystal and 320/200MHz target (fDCO= 640)*/





/************** Fpll1 = 160MHz, Fpll2 = 200MHz *****************/


/** \brief Macro for Initial Pll step, for profile with 20MHz Crystal and 160/200MHz target (fDCO= 640)*/





/*******************************25MHz Oscillator Frequency******************************************/


/************** Fpll1 = 160MHz, Fpll2 = 200MHz *****************/


/** \brief Macro for Initial Pll step, for profile with 25MHz Crystal and 160/200MHz target (fDCO= 800)*/





/*******************************40MHz Oscillator Frequency******************************************/


/************** Fpll1 = 320MHz, Fpll2 = 200MHz *****************/


/** \brief Macro for Initial Pll step, for profile with 40MHz Crystal and 320/200MHz target (fDCO= 640)*/





/************** Fpll1 = 160MHz, Fpll2 = 200MHz *****************/


/** \brief Macro for Initial Pll step, for profile with 40MHz Crystal and 160/200MHz target (fDCO= 640)*/





/***************************** Final Macro Setting for PLL ****************************************/




/****************** initial step configuration definitions ******************************/
/*macro for sys pll initial step configuration */




/*macro for per pll initial step configuration */




/*macro for wait at initial step configuration */




/*macro for sys pll initial step configuration */











/***************************************************************************************************/
/*********************** DIVIDER CONFIGURATIONS ****************************************************/
/***************************************************************************************************/

/**************** DIVIDERS DEPENDING ON FSource0 (Fpll0) *******************************************/

/**************** Fsource = Fpll0 = 80MHz **********************************************************/

/************** CCUCON0 : STMDIV  (Output : fSTM)**************/
/* Target = 80 MHz AND Source = Fsource0 */




/************** CCUCON0 : GTMDIV  (Output : fGTM)**************/
/* Target = 80 MHz AND Source = Fsource0 */




/************** CCUCON0 : SRIDIV  (Output : fSRI)**************/
/* Target = 80 MHz AND Source = Fsource0 */




/************** CCUCON0 : SPBDIV  (Output : fSPB)**************/
/* Target = 40 MHz AND Source = Fsource0 */




/************** CCUCON0 : BBBDIV  (Output : fBBB)**************/
/* Target = 40 MHz AND Source = Fsource0 */




/************** CCUCON0 : FSIDIV  (Output : fFSI)**************/
/* Target = 80 MHz AND Source = Fsri */




/************** CCUCON0 : FSI2DIV  (Output : fFSI2)**************/
/* Target = 80 MHz AND Source = Fsri */




/************** CCUCON5 : GETHDIV  (Output : fGETH)**************/
/* Target = 80 MHz AND Source = Fsource0 */




/************** CCUCON5 : MCANHDIV  (Output : fMCANH)**************/
/* Target = 40 MHz AND Source = Fsource0 */




/************** CCUCON6 : CPU0DIV  (Output : fCPU0)**************/
/* Target = 80 MHz AND Source = Fsri */




/************** CCUCON7 : CPU1DIV  (Output : fCPU1)**************/
/* Target = 80 MHz AND Source = Fsri */




/************** CCUCON8 : CPU2DIV  (Output : fCPU2)**************/
/* Target = 80 MHz AND Source = Fsri */




/************** CCUCON9 : CPU3DIV  (Output : fCPU3)**************/
/* Target = 80 MHz AND Source = Fsri */




/**************** Fsource = Fpll0 = 133MHz **********************************************************/

/************** CCUCON0 : STMDIV  (Output : fSTM)**************/
/* Target = 66.5 MHz AND Source = Fsource0 */




/************** CCUCON0 : GTMDIV  (Output : fGTM)**************/
/* Target = 133 MHz AND Source = Fsource0 */




/************** CCUCON0 : SRIDIV  (Output : fSRI)**************/
/* Target = 133 MHz AND Source = Fsource0 */




/************** CCUCON0 : SPBDIV  (Output : fSPB)**************/
/* Target = 66.5 MHz AND Source = Fsource0 */




/************** CCUCON0 : BBBDIV  (Output : fBBB)**************/
/* Target = 66.5 MHz AND Source = Fsource0 */




/************** CCUCON0 : FSIDIV  (Output : fFSI)**************/
/* Target = 66.5 MHz AND Source = Fsri */




/************** CCUCON0 : FSI2DIV  (Output : fFSI2)**************/
/* Target = 133 MHz AND Source = Fsri */




/************** CCUCON5 : GETHDIV  (Output : fGETH)**************/
/* Target = 133 MHz AND Source = Fsource0 */




/************** CCUCON5 : MCANHDIV  (Output : fMCANH)**************/
/* Target = 66.5 MHz AND Source = Fsource0 */




/************** CCUCON6 : CPU0DIV  (Output : fCPU0)**************/
/* Target = 133 MHz AND Source = Fsri */




/************** CCUCON7 : CPU1DIV  (Output : fCPU1)**************/
/* Target = 133 MHz AND Source = Fsri */




/************** CCUCON8 : CPU2DIV  (Output : fCPU2)**************/
/* Target = 133 MHz AND Source = Fsri */




/************** CCUCON9 : CPU3DIV  (Output : fCPU3)**************/
/* Target = 133 MHz AND Source = Fsri */




/**************** Fsource = Fpll0 = 200MHz **********************************************************/

/************** CCUCON0 : STMDIV  (Output : fSTM)**************/
/* Target = 100 MHz AND Source = Fsource0 */




/************** CCUCON0 : GTMDIV  (Output : fGTM)**************/
/* Target = 200 MHz AND Source = Fsource0 */




/************** CCUCON0 : SRIDIV  (Output : fSRI)**************/
/* Target = 200 MHz AND Source = Fsource0 */




/************** CCUCON0 : SPBDIV  (Output : fSPB)**************/
/* Target = 100 MHz AND Source = Fsource0 */




/************** CCUCON0 : BBBDIV  (Output : fBBB)**************/
/* Target = 100 MHz AND Source = Fsource0 */




/************** CCUCON0 : FSIDIV  (Output : fFSI)**************/
/* Target = 100 MHz AND Source = Fsri */




/************** CCUCON0 : FSI2DIV  (Output : fFSI2)**************/
/* Target = 200 MHz AND Source = Fsri */




/************** CCUCON5 : GETHDIV  (Output : fGETH)**************/
/* Target = 200 MHz AND Source = Fsource0 */




/************** CCUCON5 : MCANHDIV  (Output : fMCANH)**************/
/* Target = 100 MHz AND Source = Fsource0 */




/************** CCUCON6 : CPU0DIV  (Output : fCPU0)**************/
/* Target = 200 MHz AND Source = Fsri */




/************** CCUCON7 : CPU1DIV  (Output : fCPU1)**************/
/* Target = 200 MHz AND Source = Fsri */




/************** CCUCON8 : CPU2DIV  (Output : fCPU2)**************/
/* Target = 200 MHz AND Source = Fsri */




/************** CCUCON9 : CPU3DIV  (Output : fCPU3)**************/
/* Target = 200 MHz AND Source = Fsri */




/**************** Fsource = Fpll0 = 240MHz **********************************************************/

/************** CCUCON0 : STMDIV  (Output : fSTM)**************/
/* Target = 80 MHz AND Source = Fsource0 */




/************** CCUCON0 : GTMDIV  (Output : fGTM)**************/
/* Target = 200 MHz AND Source = Fsource0 */




/************** CCUCON0 : SRIDIV  (Output : fSRI)**************/
/* Target = 240 MHz AND Source = Fsource0 */




/************** CCUCON0 : SPBDIV  (Output : fSPB)**************/
/* Target = 80 MHz AND Source = Fsource0 */




/************** CCUCON0 : BBBDIV  (Output : fBBB)**************/
/* Target = 120 MHz AND Source = Fsource0 */




/************** CCUCON0 : FSIDIV  (Output : fFSI)**************/
/* Target = 80 MHz AND Source = Fsri */




/************** CCUCON0 : FSI2DIV  (Output : fFSI2)**************/
/* Target = 240 MHz AND Source = Fsri */




/************** CCUCON5 : GETHDIV  (Output : fGETH)**************/
/* Target = 120 MHz AND Source = Fsource0 */




/************** CCUCON5 : MCANHDIV  (Output : fMCANH)**************/
/* Target = 80 MHz AND Source = Fsource0 */




/************** CCUCON6 : CPU0DIV  (Output : fCPU0)**************/
/* Target = 240 MHz AND Source = Fsri */




/************** CCUCON7 : CPU1DIV  (Output : fCPU1)**************/
/* Target = 240 MHz AND Source = Fsri */




/************** CCUCON8 : CPU2DIV  (Output : fCPU2)**************/
/* Target = 240 MHz AND Source = Fsri */




/************** CCUCON9 : CPU3DIV  (Output : fCPU3)**************/
/* Target = 240 MHz AND Source = Fsri */




/**************** Fsource = Fpll0 = 300MHz **********************************************************/

/************** CCUCON0 : STMDIV  (Output : fSTM)**************/
/* Target = 100 MHz AND Source = Fsource0 */




/************** CCUCON0 : GTMDIV  (Output : fGTM)**************/
/* Target = 200 MHz AND Source = Fsource0 */




/************** CCUCON0 : SRIDIV  (Output : fSRI)**************/
/* Target = 300 MHz AND Source = Fsource0 */




/************** CCUCON0 : SPBDIV  (Output : fSPB)**************/
/* Target = 100 MHz AND Source = Fsource0 */




/************** CCUCON0 : BBBDIV  (Output : fBBB)**************/
/* Target = 150 MHz AND Source = Fsource0 */




/************** CCUCON0 : FSIDIV  (Output : fFSI)**************/
/* Target = 100 MHz AND Source = Fsri */




/************** CCUCON0 : FSI2DIV  (Output : fFSI2)**************/
/* Target = 300 MHz AND Source = Fsri */




/************** CCUCON5 : GETHDIV  (Output : fGETH)**************/
/* Target = 150 MHz AND Source = Fsource0 */




/************** CCUCON5 : MCANHDIV  (Output : fMCANH)**************/
/* Target = 100 MHz AND Source = Fsource0 */




/************** CCUCON6 : CPU0DIV  (Output : fCPU0)**************/
/* Target = 300 MHz AND Source = Fsri */




/************** CCUCON7 : CPU1DIV  (Output : fCPU1)**************/
/* Target = 300 MHz AND Source = Fsri */




/************** CCUCON8 : CPU2DIV  (Output : fCPU2)**************/
/* Target = 300 MHz AND Source = Fsri */




/************** CCUCON9 : CPU3DIV  (Output : fCPU3)**************/
/* Target = 300 MHz AND Source = Fsri */




/**************** DIVIDERS DEPENDING ON FSource1,2 (Fpll1_Fpll2) ***********************************/

/**************** Fpll1 = 320MHz, Fpll2 = 200MHz ***************************************************/

/************** CCUCON1 : MCANDIV  (Output : fMCAN)**************/
/* Target = 80 MHz AND Source = Fsource1 */




/************** CCUCON1 : CLKSELMCAN  (Output : fMCANI)**************/
/* Target = Fmcani MHz AND Source = Fmcani/Fosc0 */




/************** CCUCON1 : PLL1DIVDIS  (Output : fsource1)**************/
/* Target = Fpll1by2 MHz AND Source = Fpll1 */




/************** CCUCON1 : I2CDIV  (Output : fI2C)**************/
/* Target = 100 MHz AND Source = Fsource2 */




/************** CCUCON1 : MSCDIV  (Output : fMSC)**************/
/* Target = 160 MHz AND Source = Fsource2 */




/************** CCUCON1 : CLKSELMSC  (Output : fSOURCEMSC)**************/
/* Target = Fsource1 MHz AND Source = Fsource1/Fsource2 */




/************** CCUCON1 : QSPIDIV  (Output : fQSPI)**************/
/* Target = 200 MHz AND Source = Fsource2 */




/************** CCUCON1 : CLKSELQSPI  (Output : fSOURCESPI)**************/
/* Target = Fsource2 MHz AND Source = Fsource1/Fsource2 */




/************** CCUCON2 : ASCLINFDIV  (Output : fASCLINF)**************/
/* Target = 200 MHz AND Source = Fsource2 */




/************** CCUCON2 : ASCLINSDIV  (Output : fASCLINSI)**************/
/* Target = 80 MHz AND Source = Fsource1 */




/************** CCUCON2 : CLKSELASCLINS  (Output : fASCLINS)**************/
/* Target = Fasclinsi MHz AND Source = Fasclinsi/Fosc0 */




/**************** Fpll1 = 160MHz, Fpll2 = 200MHz ***************************************************/

/************** CCUCON1 : MCANDIV  (Output : fMCAN)**************/
/* Target = 80 MHz AND Source = Fsource1 */




/************** CCUCON1 : CLKSELMCAN  (Output : fMCANI)**************/
/* Target = Fmcani MHz AND Source = Fmcani/Fosc0 */




/************** CCUCON1 : PLL1DIVDIS  (Output : fsource1)**************/
/* Target = Fpll1by2 MHz AND Source = Fpll1 */




/************** CCUCON1 : I2CDIV  (Output : fI2C)**************/
/* Target = 100 MHz AND Source = Fsource2 */




/************** CCUCON1 : MSCDIV  (Output : fMSC)**************/
/* Target = 80 MHz AND Source = Fsource2 */




/************** CCUCON1 : CLKSELMSC  (Output : fSOURCEMSC)**************/
/* Target = Fsource1 MHz AND Source = Fsource1/Fsource2 */




/************** CCUCON1 : QSPIDIV  (Output : fQSPI)**************/
/* Target = 200 MHz AND Source = Fsource2 */




/************** CCUCON1 : CLKSELQSPI  (Output : fSOURCESPI)**************/
/* Target = Fsource2 MHz AND Source = Fsource1/Fsource2 */




/************** CCUCON2 : ASCLINFDIV  (Output : fASCLINF)**************/
/* Target = 200 MHz AND Source = Fsource2 */




/************** CCUCON2 : ASCLINSDIV  (Output : fASCLINSI)**************/
/* Target = 80 MHz AND Source = Fsource1 */




/************** CCUCON2 : CLKSELASCLINS  (Output : fASCLINS)**************/
/* Target = Fasclinsi MHz AND Source = Fasclinsi/Fosc0 */




/***************************************************************************************************/
/*********************** REGISTER DEFAULT VALUES ***************************************************/
/***************************************************************************************************/

/************************** CCUCON0 **************************/
























/************************** CCUCON1 **************************/


























/************************** CCUCON2 **************************/
















/************************** CCUCON5 **************************/














/************************** CCUCON6 **************************/












/************************** CCUCON7 **************************/












/************************** CCUCON8 **************************/












/************************** CCUCON9 **************************/












/**************** Final Clock Distribution ******************/














/** \brief Macros to configure FLASH.FCON registers */












/******************************************************************************/
/*---------------------------LBIST Config Macros------------------------------*/
/******************************************************************************/
































/******************************************************************************/
/*                           Enum                                             */
/******************************************************************************/
/** Clock selection  */
typedef enum
{
    IfxScu_CCUCON0_CLKSEL_fBack = 0,
    IfxScu_CCUCON0_CLKSEL_fPll  = 1
} IfxScu_CCUCON0_CLKSEL;

/** Input frequency request control */
typedef enum
{
    IfxScu_WDTCON1_IR_divBy16384 = 0,
    IfxScu_WDTCON1_IR_divBy256   = 1,
    IfxScu_WDTCON1_IR_divBy64    = 2
} IfxScu_WDTCON1_IR;

typedef enum
{
    IfxScu_PMCSR_REQSLP_Run   = 0U, /* 00 Request CPU Run Mode */
    IfxScu_PMCSR_REQSLP_Idle  = 1U, /* 01 Request CPU Idle Mode */
    IfxScu_PMCSR_REQSLP_Sleep = 2U, /* 10 Request CPU System Sleep Mode */
    IfxScu_PMCSR_REQSLP_Stby  = 3U  /* 11 Request System Standby Mode */
} IfxScu_PMCSR_REQSLP;

/******************************************************************************/


#line 64 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\ee\\..\\Libraries\\iLLD\\TC38A\\Tricore\\Scu\\Std\\IfxScuWdt.h"

#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Cpu\\Std\\Ifx_Types.h"
/**
 * \file Ifx_Types.h
 * \brief This files defines all types used by the IFX HAL and libraries
 *
 * \version iLLD_1_0_1_15_0_1
 * \copyright Copyright (c) 2018 Infineon Technologies AG. All rights reserved.
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */




/******************************************************************************/

#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\Infra\\Platform\\Tricore\\Compilers\\Compilers.h"
/**
 * \file Compilers.h
 *
 * \copyright Copyright (c) 2013 Infineon Technologies AG. All rights reserved.
 *
 * $Date: 2014-04-07 12:13:19 GMT$
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */




/******************************************************************************/



/*this file shall not be modified by the user, IFX_XXXX defines shall be defined in Ifx_Cfg.h */





































#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\Infra\\Platform\\Tricore\\Compilers\\CompilerTasking.h"
/**
 * \file CompilerTasking.h
 *
 * \version iLLD_New
 * \copyright Copyright (c) 2013 Infineon Technologies AG. All rights reserved.
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */




/******************************************************************************/


#line 1 "C:\\Infineon\\AURIX-Studio-1.9.4\\plugins\\com.infineon.aurix.tools_1.9.4\\build_system\\tools\\Compilers\\Tasking_1.1r8\\ctc\\include\\stddef.h"
/**************************************************************************
**                                                                        *
**  FILE        :  stddef.h                                               *
**                                                                        *
**  DESCRIPTION :  Include file with macros for common use                *
**                                                                        *
**  Copyright 1996-2022 Altium BV                                         *
**                                                                        *
**************************************************************************/






#pragma nomisrac 19.7,19.10,20.1







typedef __size_t        size_t;




typedef __wchar_t       wchar_t;



typedef __ptrdiff_t     ptrdiff_t;













#pragma nomisrac restore


#line 47 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\Infra\\Platform\\Tricore\\Compilers\\CompilerTasking.h"

/*Linker definitions which are specific to Tasking */
/* IFX_CFG_USE_COMPILER_DEFAULT_LINKER shall be defined in Ifx_Cfg.h
 * to use the default compiler linker varaibles and startup */



/*Start: Common definitions ********************************************** */



/*End: Common definitions ********************************************** */

/*Start: Core 0 definitions ********************************************** */

















/*Wrapper macros for the tool specific definitions */















/******************************************************************************/






/* FXIME check how to pack structure members */





/* Note that __REVISION__ is only available for tasking compiler! */


/******************************************************************************/








/* *INDENT-OFF* */









/* *INDENT-ON* */

/******************************************************************************/



/******************************************************************************/
/*Memory qualifiers*/























/******************************************************************************/


#line 86 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\Infra\\Platform\\Tricore\\Compilers\\Compilers.h"

















































/* Functions prototypes                                                       */
/******************************************************************************/
void Ifx_C_Init(void);
/******************************************************************************/



#line 47 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Cpu\\Std\\Ifx_Types.h"

#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Cpu\\Std\\Platform_Types.h"
/**
 * \file Platform_Types.h
 *
 * \version iLLD_1_0_1_15_0_1
 * \copyright Copyright (c) 2020 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */



/******************************************************************************
**                      Includes                                             **
******************************************************************************/

/******************************************************************************
**                      Global Macro Definitions                             **
******************************************************************************/








/* [cover parentID={5294D975-045A-4d91-9A1A-B1765FAB4653}] */
/* CPU register width type definition */



/* Register width of CPU*/

/* [/cover] */


/* [cover parentID={FBA2FA55-430B-4dfb-82B1-C791F0878F9B}] */
/* Bit order type definition*/


/* Bit order of Register level*/

/* [/cover] */


/* [cover parentID={0E2E6A28-264A-4d32-96EE-5F5C93286311}] */
/* Byte order type definition*/


/* Byte order on Memory level*/

/* [/cover] */


/* TRUE, FALSE symbol for Boolean types*/
/* [cover parentID={FF7F9840-8904-4b7d-83A7-988524B795DE}] */






/* [/cover] */
/******************************************************************************
**                      Global Type Definitions                              **
******************************************************************************/
/* AUTOSAR integer data types*/

/* unsigned char with a bit length that is the shortest one natively supported
  by the platform.*/
/* [cover parentID={F7B51F71-6687-4e05-8408-7F5AAC55C638}] boolean [/cover]*/
typedef unsigned char       boolean;        /* for use with TRUE/FALSE      */

/* 8bit unsigned :  0 .. 255 [0X00 .. 0XFF]*/
/* [cover parentID={4269E5AB-7F28-4803-8D60-7B4EC91CB087}] uint8 [/cover] */
typedef unsigned char       uint8;

/* 16bit unsigned:  0..65535 [0x0000..0xFFFF]*/
/* [cover parentID={66E964CA-35D5-4013-BB61-1E824636D713}] uint16 [/cover] */
typedef unsigned short      uint16;

/* 32bit unsigned:  0..4294967295 [0x00000000..0xFFFFFFFF]*/
/* [cover parentID={DA33B7A0-7CD3-45e7-9C9A-6D63FB8BA3DC}] uint32 [/cover] */
typedef unsigned long       uint32;

/* 64bit unsigned
*          0..18446744073709551615   [0x0000000000000000..0xFFFFFFFFFFFFFFFF]*/
/* [cover parentID={3409E2A3-BF2D-44a5-9B00-A72300848166}] uint64 */
typedef unsigned long long  uint64;

/* 8bit signed, 7 bit + 1 bit sign -128..+127 [0x80..0x7F]*/
/* [cover parentID={94E0756B-993D-4cae-9499-416CDFD6FEAF}] sint8[/cover]*/
typedef signed char         sint8;

/* 16bit signed, 15 bit + 1 bit sign -32768..+32767 [0x8000..0x7FFF]*/
/* [cover parentID={B3482DFF-8DFF-41bd-95E0-0406E2451CB0}] sint16 [/cover]*/
typedef short               sint16;

/* 32bit signed, 31 bit + 1 bit sign
 -2147483648..+2147483647 [0x80000000..0x7FFFFFFF]*/
/* [cover parentID={B027B471-A1A2-456c-A015-35F4A34A88EF}] sint32 [/cover]*/
typedef long                sint32;
/*
* 64bit signed, 63 bit + 1 bit sign
* -9223372036854775808..9223372036854775807
* [0x8000000000000000..0x7FFFFFFFFFFFFFFF]
*/
/* [cover parentID={3CF3471C-EB1A-450c-B78F-4B96D226A1F5}] sint64 [/cover]*/
typedef long long           sint64;

/* At least 8 bit*/
/* [cover parentID={F8719785-0A16-486e-AB85-0A2859402037}] uint8_least[/cover]*/
typedef unsigned long       uint8_least;

/* At least 16 bit*/
/* [cover parentID={BEAD868D-0EC1-44f0-AFEE-B57401CC9E65}]uint16_least[/cover]*/
typedef unsigned long       uint16_least;

/* least 32 bit*/
/* [cover parentID={9B9CC46A-0F61-4d25-8001-679CF210C135}]uint32_least[/cover]*/
typedef unsigned long       uint32_least;

/* At least 7 bit + 1 bit sign*/
/* [cover parentID={5C0DE046-8407-4708-8D26-41B96731D89D}]sint8_least[/cover]*/
typedef signed long         sint8_least;

/* At least 15 bit + 1 bit sign*/
/* [cover parentID={0A83DB6E-ECD8-42f0-B97C-057F9FBFEB6E}]sint16_least[/cover]*/
typedef signed long         sint16_least;

/* At least 31 bit + 1 bit sign*/
/* [cover parentID={A65F0248-A0A7-4ab7-BAFA-A5428F4E8A96}]sint32_least[/cover]*/
typedef signed long         sint32_least;

/* IEEE754-2008 single precision
* -3.4028235e+38..+3.4028235e+38*/
/* [cover parentID={BBC4F70E-DA81-4d37-BCA4-628A89B29517}] float32  [/cover]*/
typedef float               float32;        /* IEEE754-2008 single precision */

/* IEEE754-2008 double precision
* -1.7976931348623157e+308..+1.7976931348623157e+308*/
/* [cover parentID={0D62172C-9309-493a-8028-06A7299D7906}] float64 [/cover]*/
typedef double              float64;        /* IEEE754-2008 double precision */


/******************************************************************************
**                      Global Constant Declarations                         **
******************************************************************************/

/******************************************************************************
**                      Global Variable Declarations                         **
******************************************************************************/

/******************************************************************************
**                      Global Function Declarations                         **
******************************************************************************/


#line 48 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Cpu\\Std\\Ifx_Types.h"

/*******************************************************************************
**                      Global Data Types                                     **
**                      (Types not defined by AUTOSAR)                        **
*******************************************************************************/
typedef const char        *pchar;                           /**< \brief const char pointer                               */
typedef void              *pvoid;                           /**< \brief void pointer                                     */
typedef volatile void     *vvoid;                           /**< \brief volatile void pointer                            */
typedef void              (*voidfuncvoid) (void);           /**< \brief void pointer which takes void argument           */

typedef struct
{
    float32 real;               /**< \brief Real part */
    float32 imag;               /**< \brief Imaginary part */
} cfloat32;

typedef struct
{
    sint32 real;				/**< \brief Real part */
    sint32 imag;				/**< \brief Imaginary part */
} csint32;

typedef struct
{
    sint16 real;				/**< \brief Real part */
    sint16 imag;				/**< \brief Imaginary part */
} csint16;

typedef sint64             Ifx_TickTime;    /**< \brief Time in ticks */












typedef sint16 Ifx_SizeT;                       /**< \brief Type used for data stream size */


/** \brief Circular buffer definition. */
typedef struct
{
    void  *base;                   /**< \brief buffer base address */
    uint16 index;                  /**< \brief buffer current index */
    uint16 length;                 /**< \brief buffer length*/
} Ifx_CircularBuffer;

typedef uint16 Ifx_Priority;       /**< \brief Used in interrupt service priorities */
typedef uint32 Ifx_TimerValue;     /**< \brief Used in timer values */
typedef sint32 Ifx_SignedTimerVal; /**< \brief Used in signed timer values */

typedef pvoid  Ifx_AddressValue;   /**< \brief Used in address values */

typedef struct
{
    uint16 priority;
    uint16 provider;
} Ifx_IsrSetting;

/** \brief Signal active state definition. */
typedef enum
{
    Ifx_ActiveState_low  = 0,       /**< \brief The signal is low active */
    Ifx_ActiveState_high = 1        /**< \brief The signal is high active */
} Ifx_ActiveState;

typedef enum
{
    Ifx_ParityMode_even = 0,
    Ifx_ParityMode_odd  = 1
} Ifx_ParityMode;

/** \brief input multiplexer definition used in PinMaps
 */
typedef enum
{
    Ifx_RxSel_a,
    Ifx_RxSel_b,
    Ifx_RxSel_c,
    Ifx_RxSel_d,
    Ifx_RxSel_e,
    Ifx_RxSel_f,
    Ifx_RxSel_g,
    Ifx_RxSel_h
} Ifx_RxSel;

/** \brief Module address and index map */
typedef struct
{
    volatile void *module;      /**< \brief Module address */
    sint32         index;       /**< \brief Module index */
} IfxModule_IndexMap;

typedef struct
{
    Ifx_TickTime timestamp;
    uint8        data;
}Ifx_DataBufferMode_TimeStampSingle;

/*
 * typedef struct
 * {
 *  Ifx_TickTime timestamp;
 *  uint8 count[1];     // Number of valid data
 *  uint8 data[7];
 * }Ifx_DataBufferMode_TimeStampBurst;
 */

typedef enum
{
    Ifx_DataBufferMode_normal = 0,           /**< \brief normal mode, each received byte is moved to the rx fifo */
    Ifx_DataBufferMode_timeStampSingle,      /**< \brief Single byte type stamp mode. The rx fifo is filled in with Ifx_DataBufferMode_TimeStampSingle items. */
//    Ifx_DataBufferMode_timeStameBurst      /**< \brief Burst byte type stamp mode. The rx fifo is filled in with Ifx_DataBufferMode_TimeStampBurst items. */
}Ifx_DataBufferMode;

/**
 * Defines the PWM modes
 *
 * The 1st member shall start with value 0, and the next members value shall be the previous member +1
 * pwmMode_off shall be the member with the higher index
 * \note enum order and values should not be modified, except Ifx_Pwm_Mode_init and Ifx_Pwm_Mode_count
 */
typedef enum
{
    Ifx_Pwm_Mode_centerAligned         = 0, /**< \brief Center aligned mode */
    Ifx_Pwm_Mode_centerAlignedInverted = 1, /**< \brief Center aligned inverted aligned mode */
    Ifx_Pwm_Mode_leftAligned           = 2, /**< \brief Left aligned mode. The PWM period starts with a rising edge */
    Ifx_Pwm_Mode_rightAligned          = 3, /**< \brief Right aligned mode. The PWM period starts with a falling edge*/
    Ifx_Pwm_Mode_off                   = 4, /**< \brief All switch open */
    Ifx_Pwm_Mode_init                  = 5, /**< \brief Initialisation mode, do not use at run time */
    Ifx_Pwm_Mode_count                      /**< \brief Number of defined modes */
} Ifx_Pwm_Mode;






#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Cpu\\Std\\Ifx_TypesTasking.h"
/**
 * \file Ifx_TypesTasking.h
 * \version iLLD_1_0_1_15_0_1
 * \copyright Copyright (c) 2012 Infineon Technologies AG. All rights reserved.
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */


/******************************************************************************/




/******************************************************************************/

/******************************************************************************/


#line 191 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Cpu\\Std\\Ifx_Types.h"














typedef struct
{
    __fract real;				/**< \brief Real part */
    __fract imag;				/**< \brief Imaginary part */
} cfract;

typedef struct
{
    __sfract real;				/**< \brief Real part */
    __sfract imag;				/**< \brief Imaginary part */
} csfract;









#line 65 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\ee\\..\\Libraries\\iLLD\\TC38A\\Tricore\\Scu\\Std\\IfxScuWdt.h"

#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\Infra\\Sfr\\TC38A\\_Reg\\IfxScu_reg.h"
/**
 * \file IfxScu_reg.h
 * \brief
 * \copyright Copyright (c) 2020 Infineon Technologies AG. All rights reserved.
 *
 *
 * Version: TC38XA_UM_V1.5.0
 * Specification: TC3xx User Manual V1.5.0
 * MAY BE CHANGED BY USER [yes/no]: No
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * \defgroup IfxSfr_Scu_Registers_Cfg Scu address
 * \ingroup IfxSfr_Scu_Registers
 * 
 * \defgroup IfxSfr_Scu_Registers_Cfg_BaseAddress Base address
 * \ingroup IfxSfr_Scu_Registers_Cfg
 *
 * \defgroup IfxSfr_Scu_Registers_Cfg_Scu 2-SCU
 * \ingroup IfxSfr_Scu_Registers_Cfg
 *
 *
 */


/******************************************************************************/

#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\Infra\\Sfr\\TC38A\\_Reg\\IfxScu_regdef.h"
/**
 * \file IfxScu_regdef.h
 * \brief
 * \copyright Copyright (c) 2020 Infineon Technologies AG. All rights reserved.
 *
 *
 * Version: TC38XA_UM_V1.5.0
 * Specification: TC3xx User Manual V1.5.0
 * MAY BE CHANGED BY USER [yes/no]: No
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * \defgroup IfxSfr_Scu_Registers Scu Registers
 * \ingroup IfxSfr
 * 
 * \defgroup IfxSfr_Scu_Registers_Bitfields Bitfields
 * \ingroup IfxSfr_Scu_Registers
 * 
 * \defgroup IfxSfr_Scu_Registers_union Register unions
 * \ingroup IfxSfr_Scu_Registers
 * 
 * \defgroup IfxSfr_Scu_Registers_struct Memory map
 * \ingroup IfxSfr_Scu_Registers
 */


/******************************************************************************/

#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\Infra\\Sfr\\TC38A\\_Reg\\Ifx_TypesReg.h"
/**
 * \file Ifx_TypesReg.h
 * \brief
 * \copyright Copyright (c) 2018 Infineon Technologies AG. All rights reserved.
 *
 * Version: IFXREGTYPES_V1.0.R0
 *
 * MAY BE CHANGED BY USER [yes/no]: No
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 * Data type access rules for peripheral space
 * data type                               | Allowed access size   | Alignment of address in memory
 * ----------------------------------------|-----------------------|-----------------------------------
 * Ifx_UReg_8Bit, Ifx_SReg_8Bit            | Byte                  | Byte (1H)                         
 * Ifx_UReg_16Bit, Ifx_SReg_16Bit          | Byte, Half-Word       | 2 bytes (2H)                      
 * Ifx_UReg_32Bit, Ifx_SReg_32Bit          | Byte, Half-Word, Word | 4 bytes (4H)                      
 * Ifx_Strict_16Bit                        | Half-Word             | 2 bytes (2H)                      
 * Ifx_Strict_32Bit                        | Word                  | 4 bytes (4H)                      
 * 
 * 
 * Alignment rules for peripheral space (From TriCoreTM TC1.6.2 core architecture manual, 2.2.1 Alignment Requirements)
 * Access type                             | Access size           | Required alignment of address in memory    
 * ----------------------------------------|-----------------------|-----------------------------------
 * Load, Store Data Register               | Byte (8-bits)         | Byte (1H)                         
 * Load, Store Data Register               | Half-Word (16-bits)   | 2 bytes (2H)                      
 * Load, Store Data Register               | Word (32-bits)        | 4 bytes (4H)                      
 * Load, Store Data Register               | Double-Word (64-bits) | 8 bytes (8H)                      
 * Load, Store Address Register            | Word                  | 4 bytes (4H)                      
 * Load, Store Address Register            | Double-Word           | 8 bytes (8H)                      
 * SWAP.W, LDMST, ST.T                     | Word                  | 4 bytes (4H)                      
 * CMPSWAP.W, SWAPMSK.W                    | Word                  | 4 bytes (4H)                      
 * Context Load / Store / Restore / Save   | 16 x 32-bit registers | Not Permitted                     
 * 
 * 
 * 
 *  Peripheral space : segment F and E (From TriCoreTM TC1.6.2 core architecture manual, 8.3.4 Default Memory types for all segments)
 */



/******************************************************************************/


 
 
 
 

















typedef unsigned char  Ifx_UReg_8Bit;
typedef unsigned short Ifx_UReg_16Bit;
typedef unsigned int   Ifx_UReg_32Bit;
typedef signed char    Ifx_SReg_8Bit;
typedef signed short   Ifx_SReg_16Bit;
typedef signed int     Ifx_SReg_32Bit;


/******************************************************************************/

#line 58 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\Infra\\Sfr\\TC38A\\_Reg\\IfxScu_regdef.h"
/******************************************************************************/

/******************************************************************************/

/******************************************************************************/


/** \addtogroup IfxSfr_Scu_Registers_Bitfields
 * \{  */
/** \brief Access Enable Register 00 */
typedef struct _Ifx_SCU_ACCEN00_Bits
{
    Ifx_UReg_32Bit EN0:1;             /**< \brief [0:0] Access Enable for Master TAG ID 0 - EN0 (rw) */
    Ifx_UReg_32Bit EN1:1;             /**< \brief [1:1] Access Enable for Master TAG ID 1 - EN1 (rw) */
    Ifx_UReg_32Bit EN2:1;             /**< \brief [2:2] Access Enable for Master TAG ID 2 - EN2 (rw) */
    Ifx_UReg_32Bit EN3:1;             /**< \brief [3:3] Access Enable for Master TAG ID 3 - EN3 (rw) */
    Ifx_UReg_32Bit EN4:1;             /**< \brief [4:4] Access Enable for Master TAG ID 4 - EN4 (rw) */
    Ifx_UReg_32Bit EN5:1;             /**< \brief [5:5] Access Enable for Master TAG ID 5 - EN5 (rw) */
    Ifx_UReg_32Bit EN6:1;             /**< \brief [6:6] Access Enable for Master TAG ID 6 - EN6 (rw) */
    Ifx_UReg_32Bit EN7:1;             /**< \brief [7:7] Access Enable for Master TAG ID 7 - EN7 (rw) */
    Ifx_UReg_32Bit EN8:1;             /**< \brief [8:8] Access Enable for Master TAG ID 8 - EN8 (rw) */
    Ifx_UReg_32Bit EN9:1;             /**< \brief [9:9] Access Enable for Master TAG ID 9 - EN9 (rw) */
    Ifx_UReg_32Bit EN10:1;            /**< \brief [10:10] Access Enable for Master TAG ID 10 - EN10 (rw) */
    Ifx_UReg_32Bit EN11:1;            /**< \brief [11:11] Access Enable for Master TAG ID 11 - EN11 (rw) */
    Ifx_UReg_32Bit EN12:1;            /**< \brief [12:12] Access Enable for Master TAG ID 12 - EN12 (rw) */
    Ifx_UReg_32Bit EN13:1;            /**< \brief [13:13] Access Enable for Master TAG ID 13 - EN13 (rw) */
    Ifx_UReg_32Bit EN14:1;            /**< \brief [14:14] Access Enable for Master TAG ID 14 - EN14 (rw) */
    Ifx_UReg_32Bit EN15:1;            /**< \brief [15:15] Access Enable for Master TAG ID 15 - EN15 (rw) */
    Ifx_UReg_32Bit EN16:1;            /**< \brief [16:16] Access Enable for Master TAG ID 16 - EN16 (rw) */
    Ifx_UReg_32Bit EN17:1;            /**< \brief [17:17] Access Enable for Master TAG ID 17 - EN17 (rw) */
    Ifx_UReg_32Bit EN18:1;            /**< \brief [18:18] Access Enable for Master TAG ID 18 - EN18 (rw) */
    Ifx_UReg_32Bit EN19:1;            /**< \brief [19:19] Access Enable for Master TAG ID 19 - EN19 (rw) */
    Ifx_UReg_32Bit EN20:1;            /**< \brief [20:20] Access Enable for Master TAG ID 20 - EN20 (rw) */
    Ifx_UReg_32Bit EN21:1;            /**< \brief [21:21] Access Enable for Master TAG ID 21 - EN21 (rw) */
    Ifx_UReg_32Bit EN22:1;            /**< \brief [22:22] Access Enable for Master TAG ID 22 - EN22 (rw) */
    Ifx_UReg_32Bit EN23:1;            /**< \brief [23:23] Access Enable for Master TAG ID 23 - EN23 (rw) */
    Ifx_UReg_32Bit EN24:1;            /**< \brief [24:24] Access Enable for Master TAG ID 24 - EN24 (rw) */
    Ifx_UReg_32Bit EN25:1;            /**< \brief [25:25] Access Enable for Master TAG ID 25 - EN25 (rw) */
    Ifx_UReg_32Bit EN26:1;            /**< \brief [26:26] Access Enable for Master TAG ID 26 - EN26 (rw) */
    Ifx_UReg_32Bit EN27:1;            /**< \brief [27:27] Access Enable for Master TAG ID 27 - EN27 (rw) */
    Ifx_UReg_32Bit EN28:1;            /**< \brief [28:28] Access Enable for Master TAG ID 28 - EN28 (rw) */
    Ifx_UReg_32Bit EN29:1;            /**< \brief [29:29] Access Enable for Master TAG ID 29 - EN29 (rw) */
    Ifx_UReg_32Bit EN30:1;            /**< \brief [30:30] Access Enable for Master TAG ID 30 - EN30 (rw) */
    Ifx_UReg_32Bit EN31:1;            /**< \brief [31:31] Access Enable for Master TAG ID 31 - EN31 (rw) */
} Ifx_SCU_ACCEN00_Bits;

/** \brief Access Enable Register 01 */
typedef struct _Ifx_SCU_ACCEN01_Bits
{
    Ifx_UReg_32Bit reserved_0:32;     /**< \brief [31:0] \internal Reserved */
} Ifx_SCU_ACCEN01_Bits;

/** \brief Access Enable Register 10 */
typedef struct _Ifx_SCU_ACCEN10_Bits
{
    Ifx_UReg_32Bit EN0:1;             /**< \brief [0:0] Access Enable for Master TAG ID 0 - EN0 (rw) */
    Ifx_UReg_32Bit EN1:1;             /**< \brief [1:1] Access Enable for Master TAG ID 1 - EN1 (rw) */
    Ifx_UReg_32Bit EN2:1;             /**< \brief [2:2] Access Enable for Master TAG ID 2 - EN2 (rw) */
    Ifx_UReg_32Bit EN3:1;             /**< \brief [3:3] Access Enable for Master TAG ID 3 - EN3 (rw) */
    Ifx_UReg_32Bit EN4:1;             /**< \brief [4:4] Access Enable for Master TAG ID 4 - EN4 (rw) */
    Ifx_UReg_32Bit EN5:1;             /**< \brief [5:5] Access Enable for Master TAG ID 5 - EN5 (rw) */
    Ifx_UReg_32Bit EN6:1;             /**< \brief [6:6] Access Enable for Master TAG ID 6 - EN6 (rw) */
    Ifx_UReg_32Bit EN7:1;             /**< \brief [7:7] Access Enable for Master TAG ID 7 - EN7 (rw) */
    Ifx_UReg_32Bit EN8:1;             /**< \brief [8:8] Access Enable for Master TAG ID 8 - EN8 (rw) */
    Ifx_UReg_32Bit EN9:1;             /**< \brief [9:9] Access Enable for Master TAG ID 9 - EN9 (rw) */
    Ifx_UReg_32Bit EN10:1;            /**< \brief [10:10] Access Enable for Master TAG ID 10 - EN10 (rw) */
    Ifx_UReg_32Bit EN11:1;            /**< \brief [11:11] Access Enable for Master TAG ID 11 - EN11 (rw) */
    Ifx_UReg_32Bit EN12:1;            /**< \brief [12:12] Access Enable for Master TAG ID 12 - EN12 (rw) */
    Ifx_UReg_32Bit EN13:1;            /**< \brief [13:13] Access Enable for Master TAG ID 13 - EN13 (rw) */
    Ifx_UReg_32Bit EN14:1;            /**< \brief [14:14] Access Enable for Master TAG ID 14 - EN14 (rw) */
    Ifx_UReg_32Bit EN15:1;            /**< \brief [15:15] Access Enable for Master TAG ID 15 - EN15 (rw) */
    Ifx_UReg_32Bit EN16:1;            /**< \brief [16:16] Access Enable for Master TAG ID 16 - EN16 (rw) */
    Ifx_UReg_32Bit EN17:1;            /**< \brief [17:17] Access Enable for Master TAG ID 17 - EN17 (rw) */
    Ifx_UReg_32Bit EN18:1;            /**< \brief [18:18] Access Enable for Master TAG ID 18 - EN18 (rw) */
    Ifx_UReg_32Bit EN19:1;            /**< \brief [19:19] Access Enable for Master TAG ID 19 - EN19 (rw) */
    Ifx_UReg_32Bit EN20:1;            /**< \brief [20:20] Access Enable for Master TAG ID 20 - EN20 (rw) */
    Ifx_UReg_32Bit EN21:1;            /**< \brief [21:21] Access Enable for Master TAG ID 21 - EN21 (rw) */
    Ifx_UReg_32Bit EN22:1;            /**< \brief [22:22] Access Enable for Master TAG ID 22 - EN22 (rw) */
    Ifx_UReg_32Bit EN23:1;            /**< \brief [23:23] Access Enable for Master TAG ID 23 - EN23 (rw) */
    Ifx_UReg_32Bit EN24:1;            /**< \brief [24:24] Access Enable for Master TAG ID 24 - EN24 (rw) */
    Ifx_UReg_32Bit EN25:1;            /**< \brief [25:25] Access Enable for Master TAG ID 25 - EN25 (rw) */
    Ifx_UReg_32Bit EN26:1;            /**< \brief [26:26] Access Enable for Master TAG ID 26 - EN26 (rw) */
    Ifx_UReg_32Bit EN27:1;            /**< \brief [27:27] Access Enable for Master TAG ID 27 - EN27 (rw) */
    Ifx_UReg_32Bit EN28:1;            /**< \brief [28:28] Access Enable for Master TAG ID 28 - EN28 (rw) */
    Ifx_UReg_32Bit EN29:1;            /**< \brief [29:29] Access Enable for Master TAG ID 29 - EN29 (rw) */
    Ifx_UReg_32Bit EN30:1;            /**< \brief [30:30] Access Enable for Master TAG ID 30 - EN30 (rw) */
    Ifx_UReg_32Bit EN31:1;            /**< \brief [31:31] Access Enable for Master TAG ID 31 - EN31 (rw) */
} Ifx_SCU_ACCEN10_Bits;

/** \brief Access Enable Register 11 */
typedef struct _Ifx_SCU_ACCEN11_Bits
{
    Ifx_UReg_32Bit reserved_0:32;     /**< \brief [31:0] \internal Reserved */
} Ifx_SCU_ACCEN11_Bits;

/** \brief Application Reset Disable Register */
typedef struct _Ifx_SCU_ARSTDIS_Bits
{
    Ifx_UReg_32Bit STM0DIS:1;         /**< \brief [0:0] STM0 Disable Reset - STM0DIS (rw) */
    Ifx_UReg_32Bit STM1DIS:1;         /**< \brief [1:1] STM1 Disable Reset - STM1DIS (rw) */
    Ifx_UReg_32Bit STM2DIS:1;         /**< \brief [2:2] STM2 Disable Reset - STM2DIS (rw) */
    Ifx_UReg_32Bit STM3DIS:1;         /**< \brief [3:3] STM3 Disable Reset - STM3DIS (rw) */
    Ifx_UReg_32Bit reserved_4:1;      /**< \brief [4:4] \internal Reserved */
    Ifx_UReg_32Bit reserved_5:1;      /**< \brief [5:5] \internal Reserved */
    Ifx_UReg_32Bit reserved_6:2;      /**< \brief [7:6] \internal Reserved */
    Ifx_UReg_32Bit reserved_8:24;     /**< \brief [31:8] \internal Reserved */
} Ifx_SCU_ARSTDIS_Bits;

/** \brief CCU Clock Control Register 0 */
typedef struct _Ifx_SCU_CCUCON0_Bits
{
    Ifx_UReg_32Bit STMDIV:4;          /**< \brief [3:0] STM Divider Reload Value - STMDIV (rw) */
    Ifx_UReg_32Bit GTMDIV:4;          /**< \brief [7:4] GTM Divider Reload Value - GTMDIV (rw) */
    Ifx_UReg_32Bit SRIDIV:4;          /**< \brief [11:8] SRI Divider Reload Value - SRIDIV (rw) */
    Ifx_UReg_32Bit LPDIV:3;           /**< \brief [14:12] Low Power Divider Reload Value - LPDIV (rw) */
    Ifx_UReg_32Bit reserved_15:1;     /**< \brief [15:15] \internal Reserved */
    Ifx_UReg_32Bit SPBDIV:4;          /**< \brief [19:16] SPB Divider Reload Value - SPBDIV (rw) */
    Ifx_UReg_32Bit BBBDIV:4;          /**< \brief [23:20] BBB Divider Reload Value - BBBDIV (rw) */
    Ifx_UReg_32Bit FSIDIV:2;          /**< \brief [25:24] FSI Divider Reload Value - FSIDIV (rw) */
    Ifx_UReg_32Bit FSI2DIV:2;         /**< \brief [27:26] FSI2 Divider Reload Value - FSI2DIV (rw) */
    Ifx_UReg_32Bit CLKSEL:2;          /**< \brief [29:28] Clock Selection for Source - CLKSEL (rwh) */
    Ifx_UReg_32Bit UP:1;              /**< \brief [30:30] Update Request - UP (w) */
    Ifx_UReg_32Bit LCK:1;             /**< \brief [31:31] Lock Status - LCK (rh) */
} Ifx_SCU_CCUCON0_Bits;

/** \brief CCU Clock Control Register 1 */
typedef struct _Ifx_SCU_CCUCON1_Bits
{
    Ifx_UReg_32Bit MCANDIV:4;         /**< \brief [3:0] MCAN Divider Reload Value - MCANDIV (rw) */
    Ifx_UReg_32Bit CLKSELMCAN:2;      /**< \brief [5:4] Clock Selection for MCAN - CLKSELMCAN (rw) */
    Ifx_UReg_32Bit reserved_6:1;      /**< \brief [6:6] \internal Reserved */
    Ifx_UReg_32Bit PLL1DIVDIS:1;      /**< \brief [7:7] Divider Disable for fPLL1 - PLL1DIVDIS (rw) */
    Ifx_UReg_32Bit I2CDIV:4;          /**< \brief [11:8] I2C Divider Reload Value - I2CDIV (rw) */
    Ifx_UReg_32Bit reserved_12:4;     /**< \brief [15:12] \internal Reserved */
    Ifx_UReg_32Bit MSCDIV:4;          /**< \brief [19:16] MSC Divider Reload Value - MSCDIV (rw) */
    Ifx_UReg_32Bit CLKSELMSC:2;       /**< \brief [21:20] Clock Selection for MSC - CLKSELMSC (rw) */
    Ifx_UReg_32Bit reserved_22:2;     /**< \brief [23:22] \internal Reserved */
    Ifx_UReg_32Bit QSPIDIV:4;         /**< \brief [27:24] QSPI Divider Reload Value - QSPIDIV (rw) */
    Ifx_UReg_32Bit CLKSELQSPI:2;      /**< \brief [29:28] Clock Selection for QSPI - CLKSELQSPI (rw) */
    Ifx_UReg_32Bit reserved_30:1;     /**< \brief [30:30] \internal Reserved */
    Ifx_UReg_32Bit LCK:1;             /**< \brief [31:31] Lock Status - LCK (rh) */
} Ifx_SCU_CCUCON1_Bits;

/** \brief CCU Clock Control Register 2 */
typedef struct _Ifx_SCU_CCUCON2_Bits
{
    Ifx_UReg_32Bit ASCLINFDIV:4;      /**< \brief [3:0] ASCLIN Fast Divider Reload Value - ASCLINFDIV (rw) */
    Ifx_UReg_32Bit reserved_4:4;      /**< \brief [7:4] \internal Reserved */
    Ifx_UReg_32Bit ASCLINSDIV:4;      /**< \brief [11:8] ASCLIN Slow Divider Reload Value - ASCLINSDIV (rw) */
    Ifx_UReg_32Bit CLKSELASCLINS:2;    /**< \brief [13:12] Clock Selection for ASCLINS - CLKSELASCLINS (rw) */
    Ifx_UReg_32Bit reserved_14:10;    /**< \brief [23:14] \internal Reserved */
    Ifx_UReg_32Bit reserved_24:1;     /**< \brief [24:24] \internal Reserved */
    Ifx_UReg_32Bit ERAYPERON:1;       /**< \brief [25:25] Power Safe SwitchOff for ERAY Clock - ERAYPERON (rw) */
    Ifx_UReg_32Bit reserved_26:1;     /**< \brief [26:26] \internal Reserved */
    Ifx_UReg_32Bit reserved_27:4;     /**< \brief [30:27] \internal Reserved */
    Ifx_UReg_32Bit LCK:1;             /**< \brief [31:31] Lock Status - LCK (rh) */
} Ifx_SCU_CCUCON2_Bits;

/** \brief CCU Clock Control Register 3 */
typedef struct _Ifx_SCU_CCUCON3_Bits
{
    Ifx_UReg_32Bit PLL0MONEN:1;       /**< \brief [0:0] PLL0 Clock Monitor Enable - PLL0MONEN (rw) */
    Ifx_UReg_32Bit PLL1MONEN:1;       /**< \brief [1:1] PLL1 Clock Monitor Enable - PLL1MONEN (rw) */
    Ifx_UReg_32Bit PLL2MONEN:1;       /**< \brief [2:2] PLL2 Clock Monitor Enable - PLL2MONEN (rw) */
    Ifx_UReg_32Bit SPBMONEN:1;        /**< \brief [3:3] SPB Clock Monitor Enable - SPBMONEN (rw) */
    Ifx_UReg_32Bit BACKMONEN:1;       /**< \brief [4:4] Backup Clock Monitor Enable - BACKMONEN (rw) */
    Ifx_UReg_32Bit reserved_5:3;      /**< \brief [7:5] \internal Reserved */
    Ifx_UReg_32Bit PLL0MONTST:1;      /**< \brief [8:8] PLL0 Clock Monitor Test - PLL0MONTST (rw) */
    Ifx_UReg_32Bit PLL1MONTST:1;      /**< \brief [9:9] PLL1 Clock Monitor Test - PLL1MONTST (rw) */
    Ifx_UReg_32Bit PLL2MONTST:1;      /**< \brief [10:10] PLL2 Clock Monitor Test - PLL2MONTST (rw) */
    Ifx_UReg_32Bit SPBMONTST:1;       /**< \brief [11:11] SPB Clock Monitor Test - SPBMONTST (rw) */
    Ifx_UReg_32Bit BACKMONTST:1;      /**< \brief [12:12] Backup Clock Monitor Test - BACKMONTST (rw) */
    Ifx_UReg_32Bit reserved_13:11;    /**< \brief [23:13] \internal Reserved */
    Ifx_UReg_32Bit reserved_24:6;     /**< \brief [29:24] \internal Reserved */
    Ifx_UReg_32Bit UP:1;              /**< \brief [30:30] Update Request - UP (w) */
    Ifx_UReg_32Bit LCK:1;             /**< \brief [31:31] Lock Status - LCK (rh) */
} Ifx_SCU_CCUCON3_Bits;

/** \brief CCU Clock Control Register 4 */
typedef struct _Ifx_SCU_CCUCON4_Bits
{
    Ifx_UReg_32Bit LOTHR:12;          /**< \brief [11:0] Backup Clock Monitor Lower Threshold - LOTHR (rw) */
    Ifx_UReg_32Bit UPTHR:12;          /**< \brief [23:12] Backup Clock Monitor Upper Threshold - UPTHR (rw) */
    Ifx_UReg_32Bit MONEN:1;           /**< \brief [24:24] Backup Clock Monitor Enable - MONEN (rw) */
    Ifx_UReg_32Bit MONTST:1;          /**< \brief [25:25] Backup Clock Monitor Test - MONTST (rw) */
    Ifx_UReg_32Bit reserved_26:4;     /**< \brief [29:26] \internal Reserved */
    Ifx_UReg_32Bit UP:1;              /**< \brief [30:30] Update Request - UP (w) */
    Ifx_UReg_32Bit LCK:1;             /**< \brief [31:31] Lock Status - LCK (rh) */
} Ifx_SCU_CCUCON4_Bits;

/** \brief CCU Clock Control Register 5 */
typedef struct _Ifx_SCU_CCUCON5_Bits
{
    Ifx_UReg_32Bit GETHDIV:4;         /**< \brief [3:0] GETH Divider Reload Value - GETHDIV (rw) */
    Ifx_UReg_32Bit MCANHDIV:4;        /**< \brief [7:4] MCANH Divider Reload Value - MCANHDIV (rw) */
    Ifx_UReg_32Bit reserved_8:4;      /**< \brief [11:8] \internal Reserved */
    Ifx_UReg_32Bit reserved_12:18;    /**< \brief [29:12] \internal Reserved */
    Ifx_UReg_32Bit UP:1;              /**< \brief [30:30] Update Request - UP (w) */
    Ifx_UReg_32Bit LCK:1;             /**< \brief [31:31] Lock Status - LCK (rh) */
} Ifx_SCU_CCUCON5_Bits;

/** \brief CCU Clock Control Register 6 */
typedef struct _Ifx_SCU_CCUCON6_Bits
{
    Ifx_UReg_32Bit CPU0DIV:6;         /**< \brief [5:0] CPU0 Divider Reload Value - CPU0DIV (rw) */
    Ifx_UReg_32Bit reserved_6:26;     /**< \brief [31:6] \internal Reserved */
} Ifx_SCU_CCUCON6_Bits;

/** \brief CCU Clock Control Register 7 */
typedef struct _Ifx_SCU_CCUCON7_Bits
{
    Ifx_UReg_32Bit CPU1DIV:6;         /**< \brief [5:0] CPU1 Divider Reload Value - CPU1DIV (rw) */
    Ifx_UReg_32Bit reserved_6:26;     /**< \brief [31:6] \internal Reserved */
} Ifx_SCU_CCUCON7_Bits;

/** \brief CCU Clock Control Register 8 */
typedef struct _Ifx_SCU_CCUCON8_Bits
{
    Ifx_UReg_32Bit CPU2DIV:6;         /**< \brief [5:0] CPU2 Divider Reload Value - CPU2DIV (rw) */
    Ifx_UReg_32Bit reserved_6:26;     /**< \brief [31:6] \internal Reserved */
} Ifx_SCU_CCUCON8_Bits;

/** \brief CCU Clock Control Register 9 */
typedef struct _Ifx_SCU_CCUCON9_Bits
{
    Ifx_UReg_32Bit CPU3DIV:6;         /**< \brief [5:0] CPU3 Divider Reload Value - CPU3DIV (rw) */
    Ifx_UReg_32Bit reserved_6:26;     /**< \brief [31:6] \internal Reserved */
} Ifx_SCU_CCUCON9_Bits;

/** \brief Chip Identification Register */
typedef struct _Ifx_SCU_CHIPID_Bits
{
    Ifx_UReg_32Bit CHREV:6;           /**< \brief [5:0] Chip Revision Number - CHREV (r) */
    Ifx_UReg_32Bit CHTEC:2;           /**< \brief [7:6] Chip Family - CHTEC (r) */
    Ifx_UReg_32Bit CHPK:4;            /**< \brief [11:8] Chip Package - CHPK (rw) */
    Ifx_UReg_32Bit CHID:4;            /**< \brief [15:12] Chip Product - CHID (rw) */
    Ifx_UReg_32Bit EEA:1;             /**< \brief [16:16] Emulation or ADAS Extension Available - EEA (rh) */
    Ifx_UReg_32Bit UCODE:7;           /**< \brief [23:17] \xb5Code Version - UCODE (rw) */
    Ifx_UReg_32Bit FSIZE:4;           /**< \brief [27:24] Program Flash Size - FSIZE (rw) */
    Ifx_UReg_32Bit VART:3;            /**< \brief [30:28] Variant - VART (rw) */
    Ifx_UReg_32Bit SEC:1;             /**< \brief [31:31] Security Device Available - SEC (rw) */
} Ifx_SCU_CHIPID_Bits;

/** \brief Core Die Temperature Sensor Limit Register */
typedef struct _Ifx_SCU_DTSCLIM_Bits
{
    Ifx_UReg_32Bit LOWER:12;          /**< \brief [11:0] DTSC Lower Limit - LOWER (rw) */
    Ifx_UReg_32Bit reserved_12:1;     /**< \brief [12:12] \internal Reserved */
    Ifx_UReg_32Bit BGPOK:1;           /**< \brief [13:13] DTSC Bandgap OK (rh) */
    Ifx_UReg_32Bit EN:1;              /**< \brief [14:14] DTSC Enable (rw) */
    Ifx_UReg_32Bit LLU:1;             /**< \brief [15:15] DTSC Lower Limit Underflow - LLU (rwh) */
    Ifx_UReg_32Bit UPPER:12;          /**< \brief [27:16] DTSC Upper Limit - UPPER (rw) */
    Ifx_UReg_32Bit INTEN:1;           /**< \brief [28:28] DTSC Interrupt Enable (rw) */
    Ifx_UReg_32Bit reserved_29:1;     /**< \brief [29:29] \internal Reserved */
    Ifx_UReg_32Bit INT:1;             /**< \brief [30:30] DTSC Interrupt status flag (rwh) */
    Ifx_UReg_32Bit UOF:1;             /**< \brief [31:31] DTSC Upper Limit Overflow - UOF (rwh) */
} Ifx_SCU_DTSCLIM_Bits;

/** \brief Core Die Temperature Sensor Status Register */
typedef struct _Ifx_SCU_DTSCSTAT_Bits
{
    Ifx_UReg_32Bit RESULT:12;         /**< \brief [11:0] Result of the DTSC Measurement - RESULT (rh) */
    Ifx_UReg_32Bit reserved_12:20;    /**< \brief [31:12] \internal Reserved */
} Ifx_SCU_DTSCSTAT_Bits;

/** \brief ENDINIT Global Control Register 0 */
typedef struct _Ifx_SCU_EICON0_Bits
{
    unsigned __sfrbit32 reserved_0:1;    /**< \brief [0:0] \internal Reserved */
    unsigned __sfrbit32 ENDINIT:1;       /**< \brief [1:1] End-of-Initialization Control Bit - ENDINIT (rwh) */
    unsigned __sfrbit32 EPW:14;          /**< \brief [15:2] User-Definable ENDINIT Password Field - EPW (rwh) */
    unsigned __sfrbit32 REL:16;          /**< \brief [31:16] Reload Value for the ENDINIT Timeout Counter - REL (r) */
} Ifx_SCU_EICON0_Bits;

/** \brief ENDINIT Global Control Register 1 */
typedef struct _Ifx_SCU_EICON1_Bits
{
    Ifx_UReg_32Bit reserved_0:1;      /**< \brief [0:0] \internal Reserved */
    Ifx_UReg_32Bit reserved_1:1;      /**< \brief [1:1] \internal Reserved */
    Ifx_UReg_32Bit IR0:1;             /**< \brief [2:2] Input Frequency Request Control - IR1,IR0 (rw) */
    Ifx_UReg_32Bit DR:1;              /**< \brief [3:3] Disable Request Control Bit - DR (rw) */
    Ifx_UReg_32Bit reserved_4:1;      /**< \brief [4:4] \internal Reserved */
    Ifx_UReg_32Bit IR1:1;             /**< \brief [5:5] Input Frequency Request Control - IR1,IR0 (rw) */
    Ifx_UReg_32Bit reserved_6:26;     /**< \brief [31:6] \internal Reserved */
} Ifx_SCU_EICON1_Bits;

/** \brief External Input Channel Register ${i} */
typedef struct _Ifx_SCU_EICR_Bits
{
    Ifx_UReg_32Bit reserved_0:4;      /**< \brief [3:0] \internal Reserved */
    Ifx_UReg_32Bit EXIS0:3;           /**< \brief [6:4] External Input Selection 0 - EXIS0 (rw) */
    Ifx_UReg_32Bit reserved_7:1;      /**< \brief [7:7] \internal Reserved */
    Ifx_UReg_32Bit FEN0:1;            /**< \brief [8:8] Falling Edge Enable 0 - FEN0 (rw) */
    Ifx_UReg_32Bit REN0:1;            /**< \brief [9:9] Rising Edge Enable 0 - REN0 (rw) */
    Ifx_UReg_32Bit LDEN0:1;           /**< \brief [10:10] Level Detection Enable 0 - LDEN0 (rw) */
    Ifx_UReg_32Bit EIEN0:1;           /**< \brief [11:11] External Input Enable 0 - EIEN0 (rw) */
    Ifx_UReg_32Bit INP0:3;            /**< \brief [14:12] Input Node Pointer - INP0 (rw) */
    Ifx_UReg_32Bit reserved_15:5;     /**< \brief [19:15] \internal Reserved */
    Ifx_UReg_32Bit EXIS1:3;           /**< \brief [22:20] External Input Selection 1 - EXIS1 (rw) */
    Ifx_UReg_32Bit reserved_23:1;     /**< \brief [23:23] \internal Reserved */
    Ifx_UReg_32Bit FEN1:1;            /**< \brief [24:24] Falling Edge Enable 1 - FEN1 (rw) */
    Ifx_UReg_32Bit REN1:1;            /**< \brief [25:25] Rising Edge Enable 1 - REN1 (rw) */
    Ifx_UReg_32Bit LDEN1:1;           /**< \brief [26:26] Level Detection Enable 1 - LDEN1 (rw) */
    Ifx_UReg_32Bit EIEN1:1;           /**< \brief [27:27] External Input Enable 1 - EIEN1 (rw) */
    Ifx_UReg_32Bit INP1:3;            /**< \brief [30:28] Input Node Pointer - INP1 (rw) */
    Ifx_UReg_32Bit reserved_31:1;     /**< \brief [31:31] \internal Reserved */
} Ifx_SCU_EICR_Bits;

/** \brief External Input Filter Register */
typedef struct _Ifx_SCU_EIFILT_Bits
{
    Ifx_UReg_32Bit FILRQ0A:1;         /**< \brief [0:0] Filter Enable for REQ0A - FILRQ0A (rw) */
    Ifx_UReg_32Bit FILRQ5A:1;         /**< \brief [1:1] Filter Enable for REQ5A - FILRQ5A (rw) */
    Ifx_UReg_32Bit FILRQ2A:1;         /**< \brief [2:2] Filter Enable for REQ2A - FILRQ2A (rw) */
    Ifx_UReg_32Bit FILRQ3A:1;         /**< \brief [3:3] Filter Enable for REQ3A - FILRQ3A (rw) */
    Ifx_UReg_32Bit FILRQ0C:1;         /**< \brief [4:4] Filter Enable for REQ0C - FILRQ0C (rw) */
    Ifx_UReg_32Bit FILRQ1C:1;         /**< \brief [5:5] Filter Enable for REQ1C - FILRQ1C (rw) */
    Ifx_UReg_32Bit FILRQ3C:1;         /**< \brief [6:6] Filter Enable for REQ3C - FILRQ3C (rw) */
    Ifx_UReg_32Bit FILRQ2C:1;         /**< \brief [7:7] Filter Enable for REQ2C - FILRQ2C (rw) */
    Ifx_UReg_32Bit FILRQ4A:1;         /**< \brief [8:8] Filter Enable for REQ4A - FILRQ4A (rw) */
    Ifx_UReg_32Bit FILRQ6A:1;         /**< \brief [9:9] Filter Enable for REQ6A - FILRQ6A (rw) */
    Ifx_UReg_32Bit FILRQ1A:1;         /**< \brief [10:10] Filter Enable for REQ1A - FILRQ1A (rw) */
    Ifx_UReg_32Bit FILRQ7A:1;         /**< \brief [11:11] Filter Enable for REQ7A - FILRQ7A (rw) */
    Ifx_UReg_32Bit FILRQ6D:1;         /**< \brief [12:12] Filter Enable for REQ6D - FILRQ6D (rw) */
    Ifx_UReg_32Bit FILRQ4D:1;         /**< \brief [13:13] Filter Enable for REQ4D - FILRQ4D (rw) */
    Ifx_UReg_32Bit FILRQ2B:1;         /**< \brief [14:14] Filter Enable for REQ2B - FILRQ2B (rw) */
    Ifx_UReg_32Bit FILRQ3B:1;         /**< \brief [15:15] Filter Enable for REQ3B - FILRQ3B (rw) */
    Ifx_UReg_32Bit FILRQ7C:1;         /**< \brief [16:16] Filter Enable for REQ7C - FILRQ7C (rw) */
    Ifx_UReg_32Bit reserved_17:7;     /**< \brief [23:17] \internal Reserved */
    Ifx_UReg_32Bit FILTDIV:4;         /**< \brief [27:24] Digital Glitch Filter Clock Predivider - FILTDIV (rw) */
    Ifx_UReg_32Bit DEPTH:4;           /**< \brief [31:28] Digital Glitch Filter Depth - DEPTH (rw) */
} Ifx_SCU_EIFILT_Bits;

/** \brief External Input Flag Register */
typedef struct _Ifx_SCU_EIFR_Bits
{
    Ifx_UReg_32Bit INTF0:1;           /**< \brief [0:0] External Event Flag of Channel 0 - INTF0 (rh) */
    Ifx_UReg_32Bit INTF1:1;           /**< \brief [1:1] External Event Flag of Channel 1 - INTF1 (rh) */
    Ifx_UReg_32Bit INTF2:1;           /**< \brief [2:2] External Event Flag of Channel 2 - INTF2 (rh) */
    Ifx_UReg_32Bit INTF3:1;           /**< \brief [3:3] External Event Flag of Channel 3 - INTF3 (rh) */
    Ifx_UReg_32Bit INTF4:1;           /**< \brief [4:4] External Event Flag of Channel 4 - INTF4 (rh) */
    Ifx_UReg_32Bit INTF5:1;           /**< \brief [5:5] External Event Flag of Channel 5 - INTF5 (rh) */
    Ifx_UReg_32Bit INTF6:1;           /**< \brief [6:6] External Event Flag of Channel 6 - INTF6 (rh) */
    Ifx_UReg_32Bit INTF7:1;           /**< \brief [7:7] External Event Flag of Channel 7 - INTF7 (rh) */
    Ifx_UReg_32Bit reserved_8:24;     /**< \brief [31:8] \internal Reserved */
} Ifx_SCU_EIFR_Bits;

/** \brief ENDINIT Timeout Counter Status Register */
typedef struct _Ifx_SCU_EISR_Bits
{
    Ifx_UReg_32Bit AE:1;              /**< \brief [0:0] EICON0 Access Error Status Flag - AE (rh) */
    Ifx_UReg_32Bit OE:1;              /**< \brief [1:1] EI Timeout Overflow Error Status Flag - OE (rh) */
    Ifx_UReg_32Bit IS0:1;             /**< \brief [2:2] EI Timeout Input Clock Status - IS1,IS0 (rh) */
    Ifx_UReg_32Bit DS:1;              /**< \brief [3:3] EI Timeout Enable/Disable Status Flag - DS (rh) */
    Ifx_UReg_32Bit TO:1;              /**< \brief [4:4] EI Time-Out Mode Flag - TO (rh) */
    Ifx_UReg_32Bit IS1:1;             /**< \brief [5:5] EI Timeout Input Clock Status - IS1,IS0 (rh) */
    Ifx_UReg_32Bit reserved_6:10;     /**< \brief [15:6] \internal Reserved */
    Ifx_UReg_32Bit TIM:16;            /**< \brief [31:16] Timer Value - TIM (rh) */
} Ifx_SCU_EISR_Bits;

/** \brief Emergency Stop Register */
typedef struct _Ifx_SCU_EMSR_Bits
{
    Ifx_UReg_32Bit POL:1;             /**< \brief [0:0] Input Polarity - POL (rw) */
    Ifx_UReg_32Bit MODE:1;            /**< \brief [1:1] Mode Selection - MODE (rw) */
    Ifx_UReg_32Bit ENON:1;            /**< \brief [2:2] Enable ON - ENON (rw) */
    Ifx_UReg_32Bit PSEL:1;            /**< \brief [3:3] PORT Select - PSEL (rw) */
    Ifx_UReg_32Bit reserved_4:12;     /**< \brief [15:4] \internal Reserved */
    Ifx_UReg_32Bit EMSF:1;            /**< \brief [16:16] Emergency Stop Flag - EMSF (rh) */
    Ifx_UReg_32Bit SEMSF:1;           /**< \brief [17:17] SMU Emergency Stop Flag - SEMSF (rh) */
    Ifx_UReg_32Bit reserved_18:14;    /**< \brief [31:18] \internal Reserved */
} Ifx_SCU_EMSR_Bits;

/** \brief Emergency Stop Software set and clear register */
typedef struct _Ifx_SCU_EMSSW_Bits
{
    Ifx_UReg_32Bit reserved_0:24;     /**< \brief [23:0] \internal Reserved */
    Ifx_UReg_32Bit EMSFM:2;           /**< \brief [25:24] Emergency Stop Flag Modification - EMSFM (w) */
    Ifx_UReg_32Bit SEMSFM:2;          /**< \brief [27:26] SMU Emergency Stop Flag Modification - SEMSFM (w) */
    Ifx_UReg_32Bit reserved_28:4;     /**< \brief [31:28] \internal Reserved */
} Ifx_SCU_EMSSW_Bits;

/** \brief ESR${x} Input Configuration Register */
typedef struct _Ifx_SCU_ESRCFGX_ESRCFGX_Bits
{
    Ifx_UReg_32Bit reserved_0:7;      /**< \brief [6:0] \internal Reserved */
    Ifx_UReg_32Bit EDCON:2;           /**< \brief [8:7] Edge Detection Control - EDCON (rw) */
    Ifx_UReg_32Bit reserved_9:23;     /**< \brief [31:9] \internal Reserved */
} Ifx_SCU_ESRCFGX_ESRCFGX_Bits;

/** \brief ESR Output Configuration Register */
typedef struct _Ifx_SCU_ESROCFG_Bits
{
    Ifx_UReg_32Bit ARI:1;             /**< \brief [0:0] Application Reset Indicator - ARI (rh) */
    Ifx_UReg_32Bit ARC:1;             /**< \brief [1:1] Application Reset Indicator Clear - ARC (w) */
    Ifx_UReg_32Bit reserved_2:30;     /**< \brief [31:2] \internal Reserved */
} Ifx_SCU_ESROCFG_Bits;

/** \brief External Clock Control Register */
typedef struct _Ifx_SCU_EXTCON_Bits
{
    Ifx_UReg_32Bit EN0:1;             /**< \brief [0:0] External Clock Enable for EXTCLK0 - EN0 (rwh) */
    Ifx_UReg_32Bit reserved_1:1;      /**< \brief [1:1] \internal Reserved */
    Ifx_UReg_32Bit SEL0:4;            /**< \brief [5:2] External Clock Select for EXTCLK0 - SEL0 (rwh) */
    Ifx_UReg_32Bit reserved_6:10;     /**< \brief [15:6] \internal Reserved */
    Ifx_UReg_32Bit EN1:1;             /**< \brief [16:16] External Clock Enable for EXTCLK1 - EN1 (rwh) */
    Ifx_UReg_32Bit NSEL:1;            /**< \brief [17:17] Negation Selection - NSEL (rwh) */
    Ifx_UReg_32Bit SEL1:4;            /**< \brief [21:18] External Clock Select for EXTCLK1 - SEL1 (rwh) */
    Ifx_UReg_32Bit reserved_22:2;     /**< \brief [23:22] \internal Reserved */
    Ifx_UReg_32Bit DIV1:8;            /**< \brief [31:24] External Clock Divider for EXTCLK1 - DIV1 (rw) */
} Ifx_SCU_EXTCON_Bits;

/** \brief Fractional Divider Register */
typedef struct _Ifx_SCU_FDR_Bits
{
    Ifx_UReg_32Bit STEP:10;           /**< \brief [9:0] Step Value - STEP (rw) */
    Ifx_UReg_32Bit reserved_10:4;     /**< \brief [13:10] \internal Reserved */
    Ifx_UReg_32Bit DM:2;              /**< \brief [15:14] Divider Mode - DM (rw) */
    Ifx_UReg_32Bit RESULT:10;         /**< \brief [25:16] Result Value - RESULT (rh) */
    Ifx_UReg_32Bit reserved_26:5;     /**< \brief [30:26] \internal Reserved */
    Ifx_UReg_32Bit DISCLK:1;          /**< \brief [31:31] Disable Clock - DISCLK (rwh) */
} Ifx_SCU_FDR_Bits;

/** \brief Flag Modification Register */
typedef struct _Ifx_SCU_FMR_Bits
{
    Ifx_UReg_32Bit FS0:1;             /**< \brief [0:0] Set Flag INTFx for Channel 0 - FS0 (w) */
    Ifx_UReg_32Bit FS1:1;             /**< \brief [1:1] Set Flag INTFx for Channel 1 - FS1 (w) */
    Ifx_UReg_32Bit FS2:1;             /**< \brief [2:2] Set Flag INTFx for Channel 2 - FS2 (w) */
    Ifx_UReg_32Bit FS3:1;             /**< \brief [3:3] Set Flag INTFx for Channel 3 - FS3 (w) */
    Ifx_UReg_32Bit FS4:1;             /**< \brief [4:4] Set Flag INTFx for Channel 4 - FS4 (w) */
    Ifx_UReg_32Bit FS5:1;             /**< \brief [5:5] Set Flag INTFx for Channel 5 - FS5 (w) */
    Ifx_UReg_32Bit FS6:1;             /**< \brief [6:6] Set Flag INTFx for Channel 6 - FS6 (w) */
    Ifx_UReg_32Bit FS7:1;             /**< \brief [7:7] Set Flag INTFx for Channel 7 - FS7 (w) */
    Ifx_UReg_32Bit reserved_8:8;      /**< \brief [15:8] \internal Reserved */
    Ifx_UReg_32Bit FC0:1;             /**< \brief [16:16] Clear Flag INTFx for Channel 0 - FC0 (w) */
    Ifx_UReg_32Bit FC1:1;             /**< \brief [17:17] Clear Flag INTFx for Channel 1 - FC1 (w) */
    Ifx_UReg_32Bit FC2:1;             /**< \brief [18:18] Clear Flag INTFx for Channel 2 - FC2 (w) */
    Ifx_UReg_32Bit FC3:1;             /**< \brief [19:19] Clear Flag INTFx for Channel 3 - FC3 (w) */
    Ifx_UReg_32Bit FC4:1;             /**< \brief [20:20] Clear Flag INTFx for Channel 4 - FC4 (w) */
    Ifx_UReg_32Bit FC5:1;             /**< \brief [21:21] Clear Flag INTFx for Channel 5 - FC5 (w) */
    Ifx_UReg_32Bit FC6:1;             /**< \brief [22:22] Clear Flag INTFx for Channel 6 - FC6 (w) */
    Ifx_UReg_32Bit FC7:1;             /**< \brief [23:23] Clear Flag INTFx for Channel 7 - FC7 (w) */
    Ifx_UReg_32Bit reserved_24:8;     /**< \brief [31:24] \internal Reserved */
} Ifx_SCU_FMR_Bits;

/** \brief Identification Register */
typedef struct _Ifx_SCU_ID_Bits
{
    Ifx_UReg_32Bit MODREV:8;          /**< \brief [7:0] Module Revision Number - MODREV (r) */
    Ifx_UReg_32Bit MODTYPE:8;         /**< \brief [15:8] Module Type - MODTYPE (r) */
    Ifx_UReg_32Bit MODNUMBER:16;      /**< \brief [31:16] Module Number - MODNUMBER (r) */
} Ifx_SCU_ID_Bits;

/** \brief Flag Gating Register ${j} */
typedef struct _Ifx_SCU_IGCR_Bits
{
    Ifx_UReg_32Bit IPEN00:1;          /**< \brief [0:0] Flag Pattern Enable for Channel 0 - IPEN00 (rw) */
    Ifx_UReg_32Bit IPEN01:1;          /**< \brief [1:1] Flag Pattern Enable for Channel 0 - IPEN01 (rw) */
    Ifx_UReg_32Bit IPEN02:1;          /**< \brief [2:2] Flag Pattern Enable for Channel 0 - IPEN02 (rw) */
    Ifx_UReg_32Bit IPEN03:1;          /**< \brief [3:3] Flag Pattern Enable for Channel 0 - IPEN03 (rw) */
    Ifx_UReg_32Bit IPEN04:1;          /**< \brief [4:4] Flag Pattern Enable for Channel 0 - IPEN04 (rw) */
    Ifx_UReg_32Bit IPEN05:1;          /**< \brief [5:5] Flag Pattern Enable for Channel 0 - IPEN05 (rw) */
    Ifx_UReg_32Bit IPEN06:1;          /**< \brief [6:6] Flag Pattern Enable for Channel 0 - IPEN06 (rw) */
    Ifx_UReg_32Bit IPEN07:1;          /**< \brief [7:7] Flag Pattern Enable for Channel 0 - IPEN07 (rw) */
    Ifx_UReg_32Bit reserved_8:5;      /**< \brief [12:8] \internal Reserved */
    Ifx_UReg_32Bit GEEN0:1;           /**< \brief [13:13] Generate Event Enable 0 - GEEN0 (rw) */
    Ifx_UReg_32Bit IGP0:2;            /**< \brief [15:14] Interrupt Gating Pattern 0 - IGP0 (rw) */
    Ifx_UReg_32Bit IPEN10:1;          /**< \brief [16:16] Interrupt Pattern Enable for Channel 1 - IPEN10 (rw) */
    Ifx_UReg_32Bit IPEN11:1;          /**< \brief [17:17] Interrupt Pattern Enable for Channel 1 - IPEN11 (rw) */
    Ifx_UReg_32Bit IPEN12:1;          /**< \brief [18:18] Interrupt Pattern Enable for Channel 1 - IPEN12 (rw) */
    Ifx_UReg_32Bit IPEN13:1;          /**< \brief [19:19] Interrupt Pattern Enable for Channel 1 - IPEN13 (rw) */
    Ifx_UReg_32Bit IPEN14:1;          /**< \brief [20:20] Interrupt Pattern Enable for Channel 1 - IPEN14 (rw) */
    Ifx_UReg_32Bit IPEN15:1;          /**< \brief [21:21] Interrupt Pattern Enable for Channel 1 - IPEN15 (rw) */
    Ifx_UReg_32Bit IPEN16:1;          /**< \brief [22:22] Interrupt Pattern Enable for Channel 1 - IPEN16 (rw) */
    Ifx_UReg_32Bit IPEN17:1;          /**< \brief [23:23] Interrupt Pattern Enable for Channel 1 - IPEN17 (rw) */
    Ifx_UReg_32Bit reserved_24:5;     /**< \brief [28:24] \internal Reserved */
    Ifx_UReg_32Bit GEEN1:1;           /**< \brief [29:29] Generate Event Enable 1 - GEEN1 (rw) */
    Ifx_UReg_32Bit IGP1:2;            /**< \brief [31:30] Interrupt Gating Pattern 1 - IGP1 (rw) */
} Ifx_SCU_IGCR_Bits;

/** \brief ESR Input Register */
typedef struct _Ifx_SCU_IN_Bits
{
    Ifx_UReg_32Bit P0:1;              /**< \brief [0:0] Input Bit 0 - P0 (rh) */
    Ifx_UReg_32Bit P1:1;              /**< \brief [1:1] Input Bit 1 - P1 (rh) */
    Ifx_UReg_32Bit reserved_2:30;     /**< \brief [31:2] \internal Reserved */
} Ifx_SCU_IN_Bits;

/** \brief Input/Output Control Register */
typedef struct _Ifx_SCU_IOCR_Bits
{
    Ifx_UReg_32Bit reserved_0:4;      /**< \brief [3:0] \internal Reserved */
    Ifx_UReg_32Bit PC0:4;             /**< \brief [7:4] Control for ESR0 Pin - PC0 (rw) */
    Ifx_UReg_32Bit reserved_8:4;      /**< \brief [11:8] \internal Reserved */
    Ifx_UReg_32Bit PC1:4;             /**< \brief [15:12] Control for ESR1 Pin - PC1 (rw) */
    Ifx_UReg_32Bit reserved_16:16;    /**< \brief [31:16] \internal Reserved */
} Ifx_SCU_IOCR_Bits;

/** \brief Logic BIST Control 0 Register */
typedef struct _Ifx_SCU_LBISTCTRL0_Bits
{
    Ifx_UReg_32Bit LBISTREQ:1;        /**< \brief [0:0] LBIST Request - LBISTREQ (w) */
    Ifx_UReg_32Bit LBISTRES:1;        /**< \brief [1:1] LBIST-Reset- LBISTRES (w) */
    Ifx_UReg_32Bit PATTERNS:18;       /**< \brief [19:2] LBIST Pattern Number - PATTERNS (rw) */
    Ifx_UReg_32Bit reserved_20:8;     /**< \brief [27:20] \internal Reserved */
    Ifx_UReg_32Bit LBISTDONE:1;       /**< \brief [28:28] LBIST Execution Indicator - LBISTDONE (rh) */
    Ifx_UReg_32Bit reserved_29:1;     /**< \brief [29:29] \internal Reserved */
    Ifx_UReg_32Bit LBISTERRINJ:1;     /**< \brief [30:30] LBIST / Test-Mode Alarm Error Injection (rwh) */
    Ifx_UReg_32Bit LBISTREQRED:1;     /**< \brief [31:31] LBIST Request Redundancy (rw) */
} Ifx_SCU_LBISTCTRL0_Bits;

/** \brief Logic BIST Control 1 Register */
typedef struct _Ifx_SCU_LBISTCTRL1_Bits
{
    Ifx_UReg_32Bit SEED:19;           /**< \brief [18:0] LBIST Seed - SEED (rw) */
    Ifx_UReg_32Bit reserved_19:5;     /**< \brief [23:19] \internal Reserved */
    Ifx_UReg_32Bit SPLITSH:3;         /**< \brief [26:24] LBIST Split-Shift Selection - SPLITSH (rw) */
    Ifx_UReg_32Bit BODY:1;            /**< \brief [27:27] Body Application Indicator - BODY (rw) */
    Ifx_UReg_32Bit LBISTFREQU:4;      /**< \brief [31:28] LBIST Frequency Selection - LBISTFREQU (rw) */
} Ifx_SCU_LBISTCTRL1_Bits;

/** \brief Logic BIST Control 2 Register */
typedef struct _Ifx_SCU_LBISTCTRL2_Bits
{
    Ifx_UReg_32Bit LENGTH:12;         /**< \brief [11:0] LBIST Maximum Scan-Chain Length - LENGTH (rwh) */
    Ifx_UReg_32Bit reserved_12:20;    /**< \brief [31:12] \internal Reserved */
} Ifx_SCU_LBISTCTRL2_Bits;

/** \brief Logic BIST Control 3 Register */
typedef struct _Ifx_SCU_LBISTCTRL3_Bits
{
    Ifx_UReg_32Bit SIGNATURE:32;      /**< \brief [31:0] LBIST Signature - SIGNATURE (rh) */
} Ifx_SCU_LBISTCTRL3_Bits;

/** \brief LCL CPU0 and CPU2 Control Register */
typedef struct _Ifx_SCU_LCLCON0_Bits
{
    Ifx_UReg_32Bit reserved_0:1;      /**< \brief [0:0] \internal Reserved */
    Ifx_UReg_32Bit reserved_1:14;     /**< \brief [14:1] \internal Reserved */
    Ifx_UReg_32Bit reserved_15:1;     /**< \brief [15:15] \internal Reserved */
    Ifx_UReg_32Bit LS0:1;             /**< \brief [16:16] Lockstep Mode Status - LS0 (rh) */
    Ifx_UReg_32Bit reserved_17:14;    /**< \brief [30:17] \internal Reserved */
    Ifx_UReg_32Bit LSEN0:1;           /**< \brief [31:31] Lockstep Enable - LSEN0 (rw) */
} Ifx_SCU_LCLCON0_Bits;

/** \brief LCL CPU1 and CPU3 Control Register */
typedef struct _Ifx_SCU_LCLCON1_Bits
{
    Ifx_UReg_32Bit reserved_0:1;      /**< \brief [0:0] \internal Reserved */
    Ifx_UReg_32Bit reserved_1:14;     /**< \brief [14:1] \internal Reserved */
    Ifx_UReg_32Bit reserved_15:1;     /**< \brief [15:15] \internal Reserved */
    Ifx_UReg_32Bit LS1:1;             /**< \brief [16:16] Lockstep Mode Status - LS1 (rh) */
    Ifx_UReg_32Bit reserved_17:14;    /**< \brief [30:17] \internal Reserved */
    Ifx_UReg_32Bit LSEN1:1;           /**< \brief [31:31] Lockstep Enable - LSEN1 (rw) */
} Ifx_SCU_LCLCON1_Bits;

/** \brief LCL Test Register */
typedef struct _Ifx_SCU_LCLTEST_Bits
{
    Ifx_UReg_32Bit LCLT0:1;           /**< \brief [0:0] LCL0 Lockstep Test - LCLT0 (w) */
    Ifx_UReg_32Bit LCLT1:1;           /**< \brief [1:1] LCL1 Lockstep Test - LCLT1 (w) */
    Ifx_UReg_32Bit LCLT2:1;           /**< \brief [2:2] LCL2 Lockstep Test - LCLT2 (w) */
    Ifx_UReg_32Bit LCLT3:1;           /**< \brief [3:3] LCL3 Lockstep Test - LCLT3 (w) */
    Ifx_UReg_32Bit reserved_4:1;      /**< \brief [4:4] \internal Reserved */
    Ifx_UReg_32Bit reserved_5:1;      /**< \brief [5:5] \internal Reserved */
    Ifx_UReg_32Bit reserved_6:10;     /**< \brief [15:6] \internal Reserved */
    Ifx_UReg_32Bit PLCLT0:1;          /**< \brief [16:16] PFI0 Lockstep Test (w) */
    Ifx_UReg_32Bit PLCLT1:1;          /**< \brief [17:17] PFI1 Lockstep Test (w) */
    Ifx_UReg_32Bit PLCLT2:1;          /**< \brief [18:18] PFI2 Lockstep Test (w) */
    Ifx_UReg_32Bit PLCLT3:1;          /**< \brief [19:19] PFI3 Lockstep Test (w) */
    Ifx_UReg_32Bit reserved_20:1;     /**< \brief [20:20] \internal Reserved */
    Ifx_UReg_32Bit reserved_21:1;     /**< \brief [21:21] \internal Reserved */
    Ifx_UReg_32Bit reserved_22:10;    /**< \brief [31:22] \internal Reserved */
} Ifx_SCU_LCLTEST_Bits;

/** \brief Manufacturer Identification Register */
typedef struct _Ifx_SCU_MANID_Bits
{
    Ifx_UReg_32Bit DEPT:5;            /**< \brief [4:0] Department Identification Number - DEPT (r) */
    Ifx_UReg_32Bit MANUF:11;          /**< \brief [15:5] Manufacturer Identification Number - MANUF (r) */
    Ifx_UReg_32Bit reserved_16:16;    /**< \brief [31:16] \internal Reserved */
} Ifx_SCU_MANID_Bits;

/** \brief ESR Output Modification Register */
typedef struct _Ifx_SCU_OMR_Bits
{
    Ifx_UReg_32Bit PS0:1;             /**< \brief [0:0] ESRx Pin Set Bit 0 - PS0 (w) */
    Ifx_UReg_32Bit PS1:1;             /**< \brief [1:1] ESRx Pin Set Bit 1 - PS1 (w) */
    Ifx_UReg_32Bit reserved_2:14;     /**< \brief [15:2] \internal Reserved */
    Ifx_UReg_32Bit PCL0:1;            /**< \brief [16:16] ESRx Pin Clear Bit 0 - PCL0 (w) */
    Ifx_UReg_32Bit PCL1:1;            /**< \brief [17:17] ESRx Pin Clear Bit 1 - PCL1 (w) */
    Ifx_UReg_32Bit reserved_18:14;    /**< \brief [31:18] \internal Reserved */
} Ifx_SCU_OMR_Bits;

/** \brief OSC Control Register */
typedef struct _Ifx_SCU_OSCCON_Bits
{
    Ifx_UReg_32Bit reserved_0:1;      /**< \brief [0:0] \internal Reserved */
    Ifx_UReg_32Bit PLLLV:1;           /**< \brief [1:1] Oscillator for PLL Valid Low Status Bit - PLLLV (rh) */
    Ifx_UReg_32Bit OSCRES:1;          /**< \brief [2:2] Oscillator Watchdog Reset - OSCRES (w) */
    Ifx_UReg_32Bit GAINSEL:2;         /**< \brief [4:3] Oscillator Gain Selection - GAINSEL (rw) */
    Ifx_UReg_32Bit MODE:2;            /**< \brief [6:5] Oscillator Mode - MODE (rw) */
    Ifx_UReg_32Bit SHBY:1;            /**< \brief [7:7] Shaper Bypass - SHBY (rw) */
    Ifx_UReg_32Bit PLLHV:1;           /**< \brief [8:8] Oscillator for PLL Valid High Status Bit - PLLHV (rh) */
    Ifx_UReg_32Bit HYSEN:1;           /**< \brief [9:9] Hysteresis Enable (rw) */
    Ifx_UReg_32Bit HYSCTL:2;          /**< \brief [11:10] Hysteresis Control (rw) */
    Ifx_UReg_32Bit AMPCTL:2;          /**< \brief [13:12] Amplitude Control (rw) */
    Ifx_UReg_32Bit reserved_14:2;     /**< \brief [15:14] \internal Reserved */
    Ifx_UReg_32Bit OSCVAL:5;          /**< \brief [20:16] OSC Frequency Value - OSCVAL (rw) */
    Ifx_UReg_32Bit reserved_21:2;     /**< \brief [22:21] \internal Reserved */
    Ifx_UReg_32Bit APREN:1;           /**< \brief [23:23] Amplitude Regulation Enable - APREN (rw) */
    Ifx_UReg_32Bit CAP0EN:1;          /**< \brief [24:24] Capacitance 0 Enable - CAP0EN (rw) */
    Ifx_UReg_32Bit CAP1EN:1;          /**< \brief [25:25] Capacitance 1 Enable - CAP1EN (rw) */
    Ifx_UReg_32Bit CAP2EN:1;          /**< \brief [26:26] Capacitance 2 Enable - CAP2EN (rw) */
    Ifx_UReg_32Bit CAP3EN:1;          /**< \brief [27:27] Capacitance 3 Enable - CAP3EN (rw) */
    Ifx_UReg_32Bit reserved_28:4;     /**< \brief [31:28] \internal Reserved */
} Ifx_SCU_OSCCON_Bits;

/** \brief ESR Output Register */
typedef struct _Ifx_SCU_OUT_Bits
{
    Ifx_UReg_32Bit P0:1;              /**< \brief [0:0] Output Bit 0 - P0 (rwh) */
    Ifx_UReg_32Bit P1:1;              /**< \brief [1:1] Output Bit 1 - P1 (rwh) */
    Ifx_UReg_32Bit reserved_2:30;     /**< \brief [31:2] \internal Reserved */
} Ifx_SCU_OUT_Bits;

/** \brief Overlay Control Register */
typedef struct _Ifx_SCU_OVCCON_Bits
{
    Ifx_UReg_32Bit CSEL0:1;           /**< \brief [0:0] CPU Select 0 - CSEL0 (w) */
    Ifx_UReg_32Bit CSEL1:1;           /**< \brief [1:1] CPU Select 1 (If product has CPU1) - CSEL1 (w) */
    Ifx_UReg_32Bit CSEL2:1;           /**< \brief [2:2] CPU Select 2 (If product has CPU2) - CSEL2 (w) */
    Ifx_UReg_32Bit CSEL3:1;           /**< \brief [3:3] CPU Select 3 (If product has CPU3) - CSEL3 (w) */
    Ifx_UReg_32Bit reserved_4:1;      /**< \brief [4:4] \internal Reserved */
    Ifx_UReg_32Bit reserved_5:1;      /**< \brief [5:5] \internal Reserved */
    Ifx_UReg_32Bit reserved_6:10;     /**< \brief [15:6] \internal Reserved */
    Ifx_UReg_32Bit OVSTRT:1;          /**< \brief [16:16] Overlay Start - OVSTRT (w) */
    Ifx_UReg_32Bit OVSTP:1;           /**< \brief [17:17] Overlay Stop - OVSTP (w) */
    Ifx_UReg_32Bit DCINVAL:1;         /**< \brief [18:18] Data Cache Invalidate - DCINVAL (w) */
    Ifx_UReg_32Bit reserved_19:5;     /**< \brief [23:19] \internal Reserved */
    Ifx_UReg_32Bit OVCONF:1;          /**< \brief [24:24] Overlay Configured - OVCONF (rw) */
    Ifx_UReg_32Bit POVCONF:1;         /**< \brief [25:25] Write Protection for OVCONF - POVCONF (w) */
    Ifx_UReg_32Bit reserved_26:6;     /**< \brief [31:26] \internal Reserved */
} Ifx_SCU_OVCCON_Bits;

/** \brief Overlay Enable Register */
typedef struct _Ifx_SCU_OVCENABLE_Bits
{
    Ifx_UReg_32Bit OVEN0:1;           /**< \brief [0:0] Overlay Enable 0 - OVEN0 (rw) */
    Ifx_UReg_32Bit OVEN1:1;           /**< \brief [1:1] Overlay Enable 1 (If product has CPU1) - OVEN1 (rw) */
    Ifx_UReg_32Bit OVEN2:1;           /**< \brief [2:2] Overlay Enable 2 (If product has CPU2) - OVEN2 (rw) */
    Ifx_UReg_32Bit OVEN3:1;           /**< \brief [3:3] Overlay Enable 3 (If product has CPU3) - OVEN3 (rw) */
    Ifx_UReg_32Bit reserved_4:1;      /**< \brief [4:4] \internal Reserved */
    Ifx_UReg_32Bit reserved_5:1;      /**< \brief [5:5] \internal Reserved */
    Ifx_UReg_32Bit reserved_6:26;     /**< \brief [31:6] \internal Reserved */
} Ifx_SCU_OVCENABLE_Bits;

/** \brief Pad Disable Control Register */
typedef struct _Ifx_SCU_PDISC_Bits
{
    Ifx_UReg_32Bit PDIS0:1;           /**< \brief [0:0] Pad Disable for ESR Pin 0 - PDIS0 (rw) */
    Ifx_UReg_32Bit PDIS1:1;           /**< \brief [1:1] Pad Disable for ESR Pin 1 - PDIS1 (rw) */
    Ifx_UReg_32Bit reserved_2:30;     /**< \brief [31:2] \internal Reserved */
} Ifx_SCU_PDISC_Bits;

/** \brief ESR Pad Driver Mode Register */
typedef struct _Ifx_SCU_PDR_Bits
{
    Ifx_UReg_32Bit PD0:2;             /**< \brief [1:0] Pad Driver Mode for ESR Pins 0 - PD0 (rw) */
    Ifx_UReg_32Bit PL0:2;             /**< \brief [3:2] Pad Level Selection for ESR Pins 0 - PL0 (rw) */
    Ifx_UReg_32Bit PD1:2;             /**< \brief [5:4] Pad Driver Mode for ESR Pins 1 - PD1 (rw) */
    Ifx_UReg_32Bit PL1:2;             /**< \brief [7:6] Pad Level Selection for ESR Pins 1 - PL1 (rw) */
    Ifx_UReg_32Bit reserved_8:24;     /**< \brief [31:8] \internal Reserved */
} Ifx_SCU_PDR_Bits;

/** \brief Pattern Detection Result Register */
typedef struct _Ifx_SCU_PDRR_Bits
{
    Ifx_UReg_32Bit PDR0:1;            /**< \brief [0:0] Pattern Detection Result of Channel 0 - PDR0 (rh) */
    Ifx_UReg_32Bit PDR1:1;            /**< \brief [1:1] Pattern Detection Result of Channel 1 - PDR1 (rh) */
    Ifx_UReg_32Bit PDR2:1;            /**< \brief [2:2] Pattern Detection Result of Channel 2 - PDR2 (rh) */
    Ifx_UReg_32Bit PDR3:1;            /**< \brief [3:3] Pattern Detection Result of Channel 3 - PDR3 (rh) */
    Ifx_UReg_32Bit PDR4:1;            /**< \brief [4:4] Pattern Detection Result of Channel 4 - PDR4 (rh) */
    Ifx_UReg_32Bit PDR5:1;            /**< \brief [5:5] Pattern Detection Result of Channel 5 - PDR5 (rh) */
    Ifx_UReg_32Bit PDR6:1;            /**< \brief [6:6] Pattern Detection Result of Channel 6 - PDR6 (rh) */
    Ifx_UReg_32Bit PDR7:1;            /**< \brief [7:7] Pattern Detection Result of Channel 7 - PDR7 (rh) */
    Ifx_UReg_32Bit reserved_8:24;     /**< \brief [31:8] \internal Reserved */
} Ifx_SCU_PDRR_Bits;

/** \brief Peripheral PLL Configuration 0 Register */
typedef struct _Ifx_SCU_PERPLLCON0_Bits
{
    Ifx_UReg_32Bit DIVBY:1;           /**< \brief [0:0] Divider Bypass - DIVBY (rw) */
    Ifx_UReg_32Bit reserved_1:8;      /**< \brief [8:1] \internal Reserved */
    Ifx_UReg_32Bit NDIV:7;            /**< \brief [15:9] N-Divider Value - NDIV (rw) */
    Ifx_UReg_32Bit PLLPWD:1;          /**< \brief [16:16] Peripheral PLL Power Saving Mode - PLLPWD (rw) */
    Ifx_UReg_32Bit reserved_17:1;     /**< \brief [17:17] \internal Reserved */
    Ifx_UReg_32Bit RESLD:1;           /**< \brief [18:18] Restart DCO Lock Detection - RESLD (w) */
    Ifx_UReg_32Bit reserved_19:5;     /**< \brief [23:19] \internal Reserved */
    Ifx_UReg_32Bit PDIV:3;            /**< \brief [26:24] P-Divider Value - PDIV (rw) */
    Ifx_UReg_32Bit reserved_27:5;     /**< \brief [31:27] \internal Reserved */
} Ifx_SCU_PERPLLCON0_Bits;

/** \brief Peripheral PLL Configuration 1 Register */
typedef struct _Ifx_SCU_PERPLLCON1_Bits
{
    Ifx_UReg_32Bit K2DIV:3;           /**< \brief [2:0] K2-Divider Value - K2DIV (rw) */
    Ifx_UReg_32Bit reserved_3:5;      /**< \brief [7:3] \internal Reserved */
    Ifx_UReg_32Bit K3DIV:3;           /**< \brief [10:8] K3-Divider Value - K3DIV (rw) */
    Ifx_UReg_32Bit reserved_11:21;    /**< \brief [31:11] \internal Reserved */
} Ifx_SCU_PERPLLCON1_Bits;

/** \brief Peripheral PLL Status Register */
typedef struct _Ifx_SCU_PERPLLSTAT_Bits
{
    Ifx_UReg_32Bit reserved_0:1;      /**< \brief [0:0] \internal Reserved */
    Ifx_UReg_32Bit PWDSTAT:1;         /**< \brief [1:1] Peripheral PLL Power-saving Mode Status - PWDSTAT (rh) */
    Ifx_UReg_32Bit LOCK:1;            /**< \brief [2:2] Peripheral PLL Lock Status - LOCK (rh) */
    Ifx_UReg_32Bit reserved_3:1;      /**< \brief [3:3] \internal Reserved */
    Ifx_UReg_32Bit K3RDY:1;           /**< \brief [4:4] K3 Divider Ready Status - K3RDY (rh) */
    Ifx_UReg_32Bit K2RDY:1;           /**< \brief [5:5] K2 Divider Ready Status - K2RDY (rh) */
    Ifx_UReg_32Bit reserved_6:1;      /**< \brief [6:6] \internal Reserved */
    Ifx_UReg_32Bit reserved_7:25;     /**< \brief [31:7] \internal Reserved */
} Ifx_SCU_PERPLLSTAT_Bits;

/** \brief Power Management Control and Status Register */
typedef struct _Ifx_SCU_PMCSR0_Bits
{
    Ifx_UReg_32Bit REQSLP:2;          /**< \brief [1:0] Idle Mode and Sleep Mode Request - REQSLP (rwh) */
    Ifx_UReg_32Bit reserved_2:6;      /**< \brief [7:2] \internal Reserved */
    Ifx_UReg_32Bit PMST:3;            /**< \brief [10:8] Power management Status - PMST (rh) */
    Ifx_UReg_32Bit reserved_11:21;    /**< \brief [31:11] \internal Reserved */
} Ifx_SCU_PMCSR0_Bits;

/** \brief Power Management Control and Status Register */
typedef struct _Ifx_SCU_PMCSR1_Bits
{
    Ifx_UReg_32Bit REQSLP:2;          /**< \brief [1:0] Idle Mode and Sleep Mode Request - REQSLP (rwh) */
    Ifx_UReg_32Bit reserved_2:6;      /**< \brief [7:2] \internal Reserved */
    Ifx_UReg_32Bit PMST:3;            /**< \brief [10:8] Power management Status - PMST (rh) */
    Ifx_UReg_32Bit reserved_11:21;    /**< \brief [31:11] \internal Reserved */
} Ifx_SCU_PMCSR1_Bits;

/** \brief Power Management Control and Status Register */
typedef struct _Ifx_SCU_PMCSR2_Bits
{
    Ifx_UReg_32Bit REQSLP:2;          /**< \brief [1:0] Idle Mode and Sleep Mode Request - REQSLP (rwh) */
    Ifx_UReg_32Bit reserved_2:6;      /**< \brief [7:2] \internal Reserved */
    Ifx_UReg_32Bit PMST:3;            /**< \brief [10:8] Power management Status - PMST (rh) */
    Ifx_UReg_32Bit reserved_11:21;    /**< \brief [31:11] \internal Reserved */
} Ifx_SCU_PMCSR2_Bits;

/** \brief Power Management Control and Status Register */
typedef struct _Ifx_SCU_PMCSR3_Bits
{
    Ifx_UReg_32Bit REQSLP:2;          /**< \brief [1:0] Idle Mode and Sleep Mode Request - REQSLP (rwh) */
    Ifx_UReg_32Bit reserved_2:6;      /**< \brief [7:2] \internal Reserved */
    Ifx_UReg_32Bit PMST:3;            /**< \brief [10:8] Power management Status - PMST (rh) */
    Ifx_UReg_32Bit reserved_11:21;    /**< \brief [31:11] \internal Reserved */
} Ifx_SCU_PMCSR3_Bits;

/** \brief Power Management Control and Status Register */
typedef struct _Ifx_SCU_PMCSR4_Bits
{
    Ifx_UReg_32Bit REQSLP:2;          /**< \brief [1:0] Idle Mode and Sleep Mode Request - REQSLP (rwh) */
    Ifx_UReg_32Bit reserved_2:6;      /**< \brief [7:2] \internal Reserved */
    Ifx_UReg_32Bit PMST:3;            /**< \brief [10:8] Power management Status - PMST (rh) */
    Ifx_UReg_32Bit reserved_11:21;    /**< \brief [31:11] \internal Reserved */
} Ifx_SCU_PMCSR4_Bits;

/** \brief Power Management Control and Status Register */
typedef struct _Ifx_SCU_PMCSR5_Bits
{
    Ifx_UReg_32Bit REQSLP:2;          /**< \brief [1:0] Idle Mode and Sleep Mode Request - REQSLP (rwh) */
    Ifx_UReg_32Bit reserved_2:6;      /**< \brief [7:2] \internal Reserved */
    Ifx_UReg_32Bit PMST:3;            /**< \brief [10:8] Power management Status - PMST (rh) */
    Ifx_UReg_32Bit reserved_11:21;    /**< \brief [31:11] \internal Reserved */
} Ifx_SCU_PMCSR5_Bits;

/** \brief Power Management Status Register 0 */
typedef struct _Ifx_SCU_PMSTAT0_Bits
{
    Ifx_UReg_32Bit CPU0:1;            /**< \brief [0:0] CPU0 Status - CPU0 (rh) */
    Ifx_UReg_32Bit CPU1:1;            /**< \brief [1:1] CPU1 Status - CPU1 (rh) */
    Ifx_UReg_32Bit CPU2:1;            /**< \brief [2:2] CPU2 Status - CPU2 (rh) */
    Ifx_UReg_32Bit CPU3:1;            /**< \brief [3:3] CPU3 Status - CPU3 (rh) */
    Ifx_UReg_32Bit CPU4:1;            /**< \brief [4:4] CPU4 Status - CPU4 (rh) */
    Ifx_UReg_32Bit CPU5:1;            /**< \brief [5:5] CPU5 Status - CPU5 (rh) */
    Ifx_UReg_32Bit reserved_6:10;     /**< \brief [15:6] \internal Reserved */
    Ifx_UReg_32Bit CPU0LS:1;          /**< \brief [16:16] CPU0LS Status - CPU0LS (rh) */
    Ifx_UReg_32Bit CPU1LS:1;          /**< \brief [17:17] CPU1LS Status - CPU1LS (rh) */
    Ifx_UReg_32Bit CPU2LS:1;          /**< \brief [18:18] CPU2LS Status - CPU2LS (rh) */
    Ifx_UReg_32Bit CPU3LS:1;          /**< \brief [19:19] CPU3LS Status - CPU3LS (rh) */
    Ifx_UReg_32Bit reserved_20:12;    /**< \brief [31:20] \internal Reserved */
} Ifx_SCU_PMSTAT0_Bits;

/** \brief Standby and Wake-up Control Register 1 */
typedef struct _Ifx_SCU_PMSWCR1_Bits
{
    Ifx_UReg_32Bit reserved_0:8;      /**< \brief [7:0] \internal Reserved */
    Ifx_UReg_32Bit CPUIDLSEL:3;       /**< \brief [10:8] CPU selection for Idle mode - CPUIDLSEL (rw) */
    Ifx_UReg_32Bit reserved_11:1;     /**< \brief [11:11] \internal Reserved */
    Ifx_UReg_32Bit IRADIS:1;          /**< \brief [12:12] Idle-Request-Acknowledge Sequence Disable - IRADIS (rw) */
    Ifx_UReg_32Bit reserved_13:11;    /**< \brief [23:13] \internal Reserved */
    Ifx_UReg_32Bit CPUSEL:3;          /**< \brief [26:24] CPU selection for Sleep and Standby mode - CPUSEL (rw) */
    Ifx_UReg_32Bit STBYEVEN:1;        /**< \brief [27:27] Standby Entry Event configuration enable - STBYEVEN (w) */
    Ifx_UReg_32Bit STBYEV:3;          /**< \brief [30:28] Standby Entry Event Configuration - STBYEV (rw) */
    Ifx_UReg_32Bit reserved_31:1;     /**< \brief [31:31] \internal Reserved */
} Ifx_SCU_PMSWCR1_Bits;

/** \brief Power Management Transition Control and Status Register 0 */
typedef struct _Ifx_SCU_PMTRCSR0_Bits
{
    Ifx_UReg_32Bit LJTEN:1;           /**< \brief [0:0] Load Jump Timer Enable - LJTEN (rw) */
    Ifx_UReg_32Bit LJTOVEN:1;         /**< \brief [1:1] Load Jump Timer Overflow Enable - LJTOVEN (rw) */
    Ifx_UReg_32Bit LJTOVIEN:1;        /**< \brief [2:2] Load Jump Timer Overflow Interrupt Enable - LJTOVIEN (rw) */
    Ifx_UReg_32Bit LJTSTRT:1;         /**< \brief [3:3] Load Jump Timer Start - LJTSTRT (rwh) */
    Ifx_UReg_32Bit LJTSTP:1;          /**< \brief [4:4] Load Jump Timer Stop - LJTSTP (rw) */
    Ifx_UReg_32Bit LJTCLR:1;          /**< \brief [5:5] Load Jump Timer Clear - LJTCLR (w) */
    Ifx_UReg_32Bit reserved_6:6;      /**< \brief [11:6] \internal Reserved */
    Ifx_UReg_32Bit SDSTEP:4;          /**< \brief [15:12] Droop Voltage Step(vdroop_step_i) - SDSTEP (rw) */
    Ifx_UReg_32Bit VDTEN:1;           /**< \brief [16:16] Voltage Droop Timer Enable - VDTEN (rw) */
    Ifx_UReg_32Bit VDTOVEN:1;         /**< \brief [17:17] Voltage Droop Timer Overflow Enable - VDTOVEN (rw) */
    Ifx_UReg_32Bit VDTOVIEN:1;        /**< \brief [18:18] Voltage Droop Timer Overflow Interrupt Enable - VDTOVIEN (rw) */
    Ifx_UReg_32Bit VDTSTRT:1;         /**< \brief [19:19] Voltage Droop Timer Start - VDTSTRT (rwh) */
    Ifx_UReg_32Bit VDTSTP:1;          /**< \brief [20:20] Voltage Droop Timer Stop - VDTSTP (rw) */
    Ifx_UReg_32Bit VDTCLR:1;          /**< \brief [21:21] Voltage Droop Timer Clear - VDTCLR (w) */
    Ifx_UReg_32Bit reserved_22:7;     /**< \brief [28:22] \internal Reserved */
    Ifx_UReg_32Bit LPSLPEN:1;         /**< \brief [29:29] EVRC Low Power Mode activation on a Sleep Request - LPSLPEN (rw) */
    Ifx_UReg_32Bit reserved_30:2;     /**< \brief [31:30] \internal Reserved */
} Ifx_SCU_PMTRCSR0_Bits;

/** \brief Power Management Transition Control and Status Register 1 */
typedef struct _Ifx_SCU_PMTRCSR1_Bits
{
    Ifx_UReg_32Bit LJTCV:16;          /**< \brief [15:0] Load Jump Timer Compare Setpoint Value - LJTCV (rw) */
    Ifx_UReg_32Bit VDTCV:10;          /**< \brief [25:16] Voltage Droop Timer Compare Setpoint Value - VDTCV (rw) */
    Ifx_UReg_32Bit reserved_26:6;     /**< \brief [31:26] \internal Reserved */
} Ifx_SCU_PMTRCSR1_Bits;

/** \brief Power Management Transition Control and Status Register 2 */
typedef struct _Ifx_SCU_PMTRCSR2_Bits
{
    Ifx_UReg_32Bit LDJMPREQ:2;        /**< \brief [1:0] Load Jump Request - LDJMPREQ (rwh) */
    Ifx_UReg_32Bit reserved_2:2;      /**< \brief [3:2] \internal Reserved */
    Ifx_UReg_32Bit LJTRUN:2;          /**< \brief [5:4] Load Jump Timer Run Status - LJTRUN (rh) */
    Ifx_UReg_32Bit reserved_6:2;      /**< \brief [7:6] \internal Reserved */
    Ifx_UReg_32Bit LJTOV:1;           /**< \brief [8:8] Load Jump Timer Overflow Status - LJTOV (rh) */
    Ifx_UReg_32Bit reserved_9:3;      /**< \brief [11:9] \internal Reserved */
    Ifx_UReg_32Bit LJTOVCLR:1;        /**< \brief [12:12] Load Jump Timer Overflow Status Clear - LJTOVCLR (w) */
    Ifx_UReg_32Bit reserved_13:3;     /**< \brief [15:13] \internal Reserved */
    Ifx_UReg_32Bit LJTCNT:16;         /**< \brief [31:16] Load Jump Timer Value - LJTCNT (rh) */
} Ifx_SCU_PMTRCSR2_Bits;

/** \brief Power Management Transition Control and Status Register 3 */
typedef struct _Ifx_SCU_PMTRCSR3_Bits
{
    Ifx_UReg_32Bit VDROOPREQ:2;       /**< \brief [1:0] Voltage Droop Request - VDROOPREQ (rwh) */
    Ifx_UReg_32Bit reserved_2:2;      /**< \brief [3:2] \internal Reserved */
    Ifx_UReg_32Bit VDTRUN:2;          /**< \brief [5:4] Voltage Droop Timer Run Status - VDTRUN (rh) */
    Ifx_UReg_32Bit reserved_6:2;      /**< \brief [7:6] \internal Reserved */
    Ifx_UReg_32Bit VDTOV:1;           /**< \brief [8:8] Voltage Droop Timer Overflow Status - VDTOV (rh) */
    Ifx_UReg_32Bit reserved_9:3;      /**< \brief [11:9] \internal Reserved */
    Ifx_UReg_32Bit VDTOVCLR:1;        /**< \brief [12:12] Voltage Droop Timer Overflow Status Clear - VDTOVCLR (w) */
    Ifx_UReg_32Bit reserved_13:3;     /**< \brief [15:13] \internal Reserved */
    Ifx_UReg_32Bit VDTCNT:10;         /**< \brief [25:16] Voltage Droop Timer Value - VDTCNT (rh) */
    Ifx_UReg_32Bit reserved_26:6;     /**< \brief [31:26] \internal Reserved */
} Ifx_SCU_PMTRCSR3_Bits;

/** \brief Reset Configuration Register */
typedef struct _Ifx_SCU_RSTCON_Bits
{
    Ifx_UReg_32Bit ESR0:2;            /**< \brief [1:0] ESR0 Reset Request Trigger Reset Configuration - ESR0 (rw) */
    Ifx_UReg_32Bit ESR1:2;            /**< \brief [3:2] ESR1 Reset Request Trigger Reset Configuration - ESR1 (rw) */
    Ifx_UReg_32Bit reserved_4:2;      /**< \brief [5:4] \internal Reserved */
    Ifx_UReg_32Bit SMU:2;             /**< \brief [7:6] SMU Reset Request Trigger Reset Configuration - SMU (rw) */
    Ifx_UReg_32Bit SW:2;              /**< \brief [9:8] SW Reset Request Trigger Reset Configuration - SW (rw) */
    Ifx_UReg_32Bit STM0:2;            /**< \brief [11:10] STM0 Reset Request Trigger Reset Configuration - STM0 (rw) */
    Ifx_UReg_32Bit STM1:2;            /**< \brief [13:12] STM1 Reset Request Trigger Reset Configuration (If Product has STM1) - STM1 (rw) */
    Ifx_UReg_32Bit STM2:2;            /**< \brief [15:14] STM2 Reset Request Trigger Reset Configuration (If Product has STM2) - STM2 (rw) */
    Ifx_UReg_32Bit STM3:2;            /**< \brief [17:16] STM3 Reset Request Trigger Reset Configuration (If Product has STM3) - STM3 (rw) */
    Ifx_UReg_32Bit reserved_18:2;     /**< \brief [19:18] \internal Reserved */
    Ifx_UReg_32Bit reserved_20:2;     /**< \brief [21:20] \internal Reserved */
    Ifx_UReg_32Bit reserved_22:10;    /**< \brief [31:22] \internal Reserved */
} Ifx_SCU_RSTCON_Bits;

/** \brief Additional Reset Control Register */
typedef struct _Ifx_SCU_RSTCON2_Bits
{
    Ifx_UReg_32Bit FRTO:1;            /**< \brief [0:0] Force Reset Timeout - FRTO (rw) */
    Ifx_UReg_32Bit CLRC:1;            /**< \brief [1:1] Clear Cold Reset Status - CLRC (w) */
    Ifx_UReg_32Bit reserved_2:1;      /**< \brief [2:2] \internal Reserved */
    Ifx_UReg_32Bit reserved_3:1;      /**< \brief [3:3] \internal Reserved */
    Ifx_UReg_32Bit reserved_4:1;      /**< \brief [4:4] \internal Reserved */
    Ifx_UReg_32Bit reserved_5:1;      /**< \brief [5:5] \internal Reserved */
    Ifx_UReg_32Bit reserved_6:1;      /**< \brief [6:6] \internal Reserved */
    Ifx_UReg_32Bit CSSX:6;            /**< \brief [12:7] CPU x Shutdown State Reached - CSSx (rh) */
    Ifx_UReg_32Bit reserved_13:1;     /**< \brief [13:13] \internal Reserved */
    Ifx_UReg_32Bit reserved_14:1;     /**< \brief [14:14] \internal Reserved */
    Ifx_UReg_32Bit reserved_15:1;     /**< \brief [15:15] \internal Reserved */
    Ifx_UReg_32Bit USRINFO:16;        /**< \brief [31:16] User Information - USRINFO (rw) */
} Ifx_SCU_RSTCON2_Bits;

/** \brief Reset Configuration Register 3 */
typedef struct _Ifx_SCU_RSTCON3_Bits
{
    Ifx_UReg_32Bit reserved_0:32;     /**< \brief [31:0] \internal Reserved */
} Ifx_SCU_RSTCON3_Bits;

/** \brief Reset Status Register */
typedef struct _Ifx_SCU_RSTSTAT_Bits
{
    Ifx_UReg_32Bit ESR0:1;            /**< \brief [0:0] Reset Request Trigger Reset Status for ESR0 - ESR0 (rh) */
    Ifx_UReg_32Bit ESR1:1;            /**< \brief [1:1] Reset Request Trigger Reset Status for ESR1 - ESR1 (rh) */
    Ifx_UReg_32Bit reserved_2:1;      /**< \brief [2:2] \internal Reserved */
    Ifx_UReg_32Bit SMU:1;             /**< \brief [3:3] Reset Request Trigger Reset Status for SMU - SMU (rh) */
    Ifx_UReg_32Bit SW:1;              /**< \brief [4:4] Reset Request Trigger Reset Status for SW - SW (rh) */
    Ifx_UReg_32Bit STM0:1;            /**< \brief [5:5] Reset Request Trigger Reset Status for STM0 Compare Match - STM0 (rh) */
    Ifx_UReg_32Bit STM1:1;            /**< \brief [6:6] Reset Request Trigger Reset Status for STM1 Compare Match (If Product has STM1) - STM1 (rh) */
    Ifx_UReg_32Bit STM2:1;            /**< \brief [7:7] Reset Request Trigger Reset Status for STM2 Compare Match (If Product has STM2) - STM2 (rh) */
    Ifx_UReg_32Bit STM3:1;            /**< \brief [8:8] Reset Request Trigger Reset Status for STM3 Compare Match (If Product has STM3) - STM3 (rh) */
    Ifx_UReg_32Bit reserved_9:1;      /**< \brief [9:9] \internal Reserved */
    Ifx_UReg_32Bit reserved_10:1;     /**< \brief [10:10] \internal Reserved */
    Ifx_UReg_32Bit reserved_11:5;     /**< \brief [15:11] \internal Reserved */
    Ifx_UReg_32Bit PORST:1;           /**< \brief [16:16] Reset Request Trigger Reset Status for PORST - PORST (rh) */
    Ifx_UReg_32Bit reserved_17:1;     /**< \brief [17:17] \internal Reserved */
    Ifx_UReg_32Bit CB0:1;             /**< \brief [18:18] Reset Request Trigger Reset Status for Cerberus System Reset - CB0 (rh) */
    Ifx_UReg_32Bit CB1:1;             /**< \brief [19:19] Reset Request Trigger Reset Status for Cerberus Debug Reset - CB1 (rh) */
    Ifx_UReg_32Bit CB3:1;             /**< \brief [20:20] Reset Request Trigger Reset Status for Cerberus Application Reset - CB3 (rh) */
    Ifx_UReg_32Bit reserved_21:1;     /**< \brief [21:21] \internal Reserved */
    Ifx_UReg_32Bit reserved_22:1;     /**< \brief [22:22] \internal Reserved */
    Ifx_UReg_32Bit EVRC:1;            /**< \brief [23:23] Reset Request Trigger Reset Status for EVRC - EVRC (rh) */
    Ifx_UReg_32Bit EVR33:1;           /**< \brief [24:24] Reset Request Trigger Reset Status for EVR33 - EVR33 (rh) */
    Ifx_UReg_32Bit SWD:1;             /**< \brief [25:25] Reset Request Trigger Reset Status for Supply Watchdog (SWD) - SWD (rh) */
    Ifx_UReg_32Bit HSMS:1;            /**< \brief [26:26] Reset Request Trigger Reset Status for HSM System Reset (HSM S) - HSMS (rh) */
    Ifx_UReg_32Bit HSMA:1;            /**< \brief [27:27] Reset Request Trigger Reset Status for HSM Application Reset (HSM A) - HSMA (rh) */
    Ifx_UReg_32Bit STBYR:1;           /**< \brief [28:28] Reset Request Trigger Reset Status for Standby Regulator Watchdog (STBYR) - STBYR (rh) */
    Ifx_UReg_32Bit LBPORST:1;         /**< \brief [29:29] LBIST termination due to PORST (rh) */
    Ifx_UReg_32Bit LBTERM:1;          /**< \brief [30:30] LBIST was properly terminated (rh) */
    Ifx_UReg_32Bit reserved_31:1;     /**< \brief [31:31] \internal Reserved */
} Ifx_SCU_RSTSTAT_Bits;

/** \brief Safety ENDINIT Control Register 0 */
typedef struct _Ifx_SCU_SEICON0_Bits
{
    unsigned __sfrbit32 reserved_0:1;    /**< \brief [0:0] \internal Reserved */
    unsigned __sfrbit32 ENDINIT:1;       /**< \brief [1:1] End-of-Initialization Control Bit - ENDINIT (rwh) */
    unsigned __sfrbit32 EPW:14;          /**< \brief [15:2] User-Definable Safety ENDINIT Password Field - EPW (rwh) */
    unsigned __sfrbit32 REL:16;          /**< \brief [31:16] Reload Value for the Safety  ENDINIT Timeout Counter - REL (r) */
} Ifx_SCU_SEICON0_Bits;

/** \brief Safety ENDINIT Control Register 1 */
typedef struct _Ifx_SCU_SEICON1_Bits
{
    Ifx_UReg_32Bit reserved_0:1;      /**< \brief [0:0] \internal Reserved */
    Ifx_UReg_32Bit reserved_1:1;      /**< \brief [1:1] \internal Reserved */
    Ifx_UReg_32Bit IR0:1;             /**< \brief [2:2] Input Frequency Request Control - IR1,IR0 (rw) */
    Ifx_UReg_32Bit DR:1;              /**< \brief [3:3] Disable Request Control Bit - DR (rw) */
    Ifx_UReg_32Bit reserved_4:1;      /**< \brief [4:4] \internal Reserved */
    Ifx_UReg_32Bit IR1:1;             /**< \brief [5:5] Input Frequency Request Control - IR1,IR0 (rw) */
    Ifx_UReg_32Bit reserved_6:26;     /**< \brief [31:6] \internal Reserved */
} Ifx_SCU_SEICON1_Bits;

/** \brief Safety ENDINIT Timeout Status Register */
typedef struct _Ifx_SCU_SEISR_Bits
{
    Ifx_UReg_32Bit AE:1;              /**< \brief [0:0] SEICON0 Access Error Status Flag - AE (rh) */
    Ifx_UReg_32Bit OE:1;              /**< \brief [1:1] SEI Timeout Overflow Error Status Flag - OE (rh) */
    Ifx_UReg_32Bit IS0:1;             /**< \brief [2:2] SEI Timeout Input Clock Status - IS0, IS1 (rh) */
    Ifx_UReg_32Bit DS:1;              /**< \brief [3:3] SEI Enable/Disable Status Flag - DS (rh) */
    Ifx_UReg_32Bit TO:1;              /**< \brief [4:4] SEI Time-Out Mode Flag - TO (rh) */
    Ifx_UReg_32Bit IS1:1;             /**< \brief [5:5] SEI Timeout Input Clock Status - IS0, IS1 (rh) */
    Ifx_UReg_32Bit reserved_6:10;     /**< \brief [15:6] \internal Reserved */
    Ifx_UReg_32Bit TIM:16;            /**< \brief [31:16] Timer Value - TIM (rh) */
} Ifx_SCU_SEISR_Bits;

/** \brief Start-up Configuration Register */
typedef struct _Ifx_SCU_STCON_Bits
{
    Ifx_UReg_32Bit reserved_0:13;     /**< \brief [12:0] \internal Reserved */
    Ifx_UReg_32Bit SFCBAE:1;          /**< \brief [13:13] Set Flash Config. Sector Access Enable - SFCBAE (w) */
    Ifx_UReg_32Bit CFCBAE:1;          /**< \brief [14:14] Clear Flash Config. Sector Access Enable - CFCBAE (w) */
    Ifx_UReg_32Bit STP:1;             /**< \brief [15:15] Start-up Protection Setting - STP (rwh) */
    Ifx_UReg_32Bit reserved_16:16;    /**< \brief [31:16] \internal Reserved */
} Ifx_SCU_STCON_Bits;

/** \brief Start-up Memory Register 1 */
typedef struct _Ifx_SCU_STMEM1_Bits
{
    Ifx_UReg_32Bit MEM:32;            /**< \brief [31:0] Memory - MEM (rw) */
} Ifx_SCU_STMEM1_Bits;

/** \brief Start-up Memory Register 2 */
typedef struct _Ifx_SCU_STMEM2_Bits
{
    Ifx_UReg_32Bit MEM:32;            /**< \brief [31:0] Memory - MEM (rw) */
} Ifx_SCU_STMEM2_Bits;

/** \brief Start-up Memory Register 3 */
typedef struct _Ifx_SCU_STMEM3_Bits
{
    Ifx_UReg_32Bit MEM:32;            /**< \brief [31:0] Memory - MEM (rw) */
} Ifx_SCU_STMEM3_Bits;

/** \brief Start-up Memory Register 4 */
typedef struct _Ifx_SCU_STMEM4_Bits
{
    Ifx_UReg_32Bit MEM:32;            /**< \brief [31:0] Memory - MEM (rw) */
} Ifx_SCU_STMEM4_Bits;

/** \brief Start-up Memory Register 5 */
typedef struct _Ifx_SCU_STMEM5_Bits
{
    Ifx_UReg_32Bit MEM:32;            /**< \brief [31:0] Memory - MEM (rw) */
} Ifx_SCU_STMEM5_Bits;

/** \brief Start-up Memory Register 6 */
typedef struct _Ifx_SCU_STMEM6_Bits
{
    Ifx_UReg_32Bit MEM:32;            /**< \brief [31:0] Memory - MEM (rw) */
} Ifx_SCU_STMEM6_Bits;

/** \brief Start-up Status Register */
typedef struct _Ifx_SCU_STSTAT_Bits
{
    Ifx_UReg_32Bit HWCFG:8;           /**< \brief [7:0] Hardware Configuration Setting - HWCFG (rh) */
    Ifx_UReg_32Bit FTM:7;             /**< \brief [14:8] Firmware Test Setting - FTM (rh) */
    Ifx_UReg_32Bit MODE:1;            /**< \brief [15:15] MODE - MODE (rh) */
    Ifx_UReg_32Bit FCBAE:1;           /**< \brief [16:16] Flash Config. Sector Access Enable - FCBAE (rh) */
    Ifx_UReg_32Bit LUDIS:1;           /**< \brief [17:17] Latch Update Disable - LUDIS (rh) */
    Ifx_UReg_32Bit reserved_18:1;     /**< \brief [18:18] \internal Reserved */
    Ifx_UReg_32Bit TRSTL:1;           /**< \brief [19:19] TRSTL Status - TRSTL (rh) */
    Ifx_UReg_32Bit SPDEN:1;           /**< \brief [20:20] Single Pin DAP Mode Enable - SPDEN (rh) */
    Ifx_UReg_32Bit reserved_21:1;     /**< \brief [21:21] \internal Reserved */
    Ifx_UReg_32Bit reserved_22:1;     /**< \brief [22:22] \internal Reserved */
    Ifx_UReg_32Bit reserved_23:1;     /**< \brief [23:23] \internal Reserved */
    Ifx_UReg_32Bit RAMINT:1;          /**< \brief [24:24] RAM Content Security Integrity - RAMINT (rh) */
    Ifx_UReg_32Bit reserved_25:3;     /**< \brief [27:25] \internal Reserved */
    Ifx_UReg_32Bit reserved_28:4;     /**< \brief [31:28] \internal Reserved */
} Ifx_SCU_STSTAT_Bits;

/** \brief Address Map Control Register */
typedef struct _Ifx_SCU_SWAPCTRL_Bits
{
    Ifx_UReg_32Bit ADDRCFG:2;         /**< \brief [1:0] Address Configuration (rw) */
    Ifx_UReg_32Bit SPARE:14;          /**< \brief [15:2] Spare address configuration registers (rw) */
    Ifx_UReg_32Bit reserved_16:16;    /**< \brief [31:16] \internal Reserved */
} Ifx_SCU_SWAPCTRL_Bits;

/** \brief Software Reset Configuration Register */
typedef struct _Ifx_SCU_SWRSTCON_Bits
{
    Ifx_UReg_32Bit reserved_0:1;      /**< \brief [0:0] \internal Reserved */
    Ifx_UReg_32Bit SWRSTREQ:1;        /**< \brief [1:1] Software Reset Request - SWRSTREQ (w) */
    Ifx_UReg_32Bit reserved_2:6;      /**< \brief [7:2] \internal Reserved */
    Ifx_UReg_32Bit reserved_8:8;      /**< \brief [15:8] \internal Reserved */
    Ifx_UReg_32Bit reserved_16:16;    /**< \brief [31:16] \internal Reserved */
} Ifx_SCU_SWRSTCON_Bits;

/** \brief System Control Register */
typedef struct _Ifx_SCU_SYSCON_Bits
{
    Ifx_UReg_32Bit CCTRIG0:1;         /**< \brief [0:0] Capture Compare Trigger 0 - CCTRIG0 (rw) */
    Ifx_UReg_32Bit reserved_1:1;      /**< \brief [1:1] \internal Reserved */
    Ifx_UReg_32Bit RAMINTM:2;         /**< \brief [3:2] RAM Integrity Modify - RAMINTM (w) */
    Ifx_UReg_32Bit SETLUDIS:1;        /**< \brief [4:4] Set Latch Update Disable - SETLUDIS (w) */
    Ifx_UReg_32Bit reserved_5:1;      /**< \brief [5:5] \internal Reserved */
    Ifx_UReg_32Bit reserved_6:1;      /**< \brief [6:6] \internal Reserved */
    Ifx_UReg_32Bit reserved_7:1;      /**< \brief [7:7] \internal Reserved */
    Ifx_UReg_32Bit DDC:1;             /**< \brief [8:8] Disable DXCPL - DDC (rw) */
    Ifx_UReg_32Bit reserved_9:7;      /**< \brief [15:9] \internal Reserved */
    Ifx_UReg_32Bit reserved_16:16;    /**< \brief [31:16] \internal Reserved */
} Ifx_SCU_SYSCON_Bits;

/** \brief System PLL Configuration 0 Register */
typedef struct _Ifx_SCU_SYSPLLCON0_Bits
{
    Ifx_UReg_32Bit reserved_0:2;      /**< \brief [1:0] \internal Reserved */
    Ifx_UReg_32Bit MODEN:1;           /**< \brief [2:2] Modulation Enable - MODEN (rw) */
    Ifx_UReg_32Bit reserved_3:6;      /**< \brief [8:3] \internal Reserved */
    Ifx_UReg_32Bit NDIV:7;            /**< \brief [15:9] N-Divider Value - NDIV (rw) */
    Ifx_UReg_32Bit PLLPWD:1;          /**< \brief [16:16] System PLL Power Saving Mode - PLLPWD (rw) */
    Ifx_UReg_32Bit reserved_17:1;     /**< \brief [17:17] \internal Reserved */
    Ifx_UReg_32Bit RESLD:1;           /**< \brief [18:18] Restart DCO Lock Detection - RESLD (w) */
    Ifx_UReg_32Bit reserved_19:5;     /**< \brief [23:19] \internal Reserved */
    Ifx_UReg_32Bit PDIV:3;            /**< \brief [26:24] P-Divider Value - PDIV (rw) */
    Ifx_UReg_32Bit reserved_27:3;     /**< \brief [29:27] \internal Reserved */
    Ifx_UReg_32Bit INSEL:2;           /**< \brief [31:30] Input Selection - INSEL (rw) */
} Ifx_SCU_SYSPLLCON0_Bits;

/** \brief System PLL Configuration 1 Register */
typedef struct _Ifx_SCU_SYSPLLCON1_Bits
{
    Ifx_UReg_32Bit K2DIV:3;           /**< \brief [2:0] K2-Divider Value - K2DIV (rw) */
    Ifx_UReg_32Bit reserved_3:29;     /**< \brief [31:3] \internal Reserved */
} Ifx_SCU_SYSPLLCON1_Bits;

/** \brief System PLL Configuration 2 Register */
typedef struct _Ifx_SCU_SYSPLLCON2_Bits
{
    Ifx_UReg_32Bit MODCFG:16;         /**< \brief [15:0] Modulation Configuration - MODCFG (rw) */
    Ifx_UReg_32Bit reserved_16:16;    /**< \brief [31:16] \internal Reserved */
} Ifx_SCU_SYSPLLCON2_Bits;

/** \brief System PLL Status Register */
typedef struct _Ifx_SCU_SYSPLLSTAT_Bits
{
    Ifx_UReg_32Bit reserved_0:1;      /**< \brief [0:0] \internal Reserved */
    Ifx_UReg_32Bit PWDSTAT:1;         /**< \brief [1:1] System PLL Power-saving Mode Status - PWDSTAT (rh) */
    Ifx_UReg_32Bit LOCK:1;            /**< \brief [2:2] System PLL Lock Status - LOCK (rh) */
    Ifx_UReg_32Bit reserved_3:2;      /**< \brief [4:3] \internal Reserved */
    Ifx_UReg_32Bit K2RDY:1;           /**< \brief [5:5] K2 Divider Ready Status - K2RDY (rh) */
    Ifx_UReg_32Bit reserved_6:1;      /**< \brief [6:6] \internal Reserved */
    Ifx_UReg_32Bit MODRUN:1;          /**< \brief [7:7] Modulation Run - MODRUN (rh) */
    Ifx_UReg_32Bit reserved_8:24;     /**< \brief [31:8] \internal Reserved */
} Ifx_SCU_SYSPLLSTAT_Bits;

/** \brief Trap Clear Register */
typedef struct _Ifx_SCU_TRAPCLR_Bits
{
    Ifx_UReg_32Bit ESR0T:1;           /**< \brief [0:0] Clear Trap Request Flag ESR0T - ESR0T (w) */
    Ifx_UReg_32Bit ESR1T:1;           /**< \brief [1:1] Clear Trap Request Flag ESR1T - ESR1T (w) */
    Ifx_UReg_32Bit TRAP2:1;           /**< \brief [2:2] Clear Trap Request Flag TRAP2 - TRAP2 (w) */
    Ifx_UReg_32Bit SMUT:1;            /**< \brief [3:3] Clear Trap Request Flag SMUT - SMUT (w) */
    Ifx_UReg_32Bit reserved_4:28;     /**< \brief [31:4] \internal Reserved */
} Ifx_SCU_TRAPCLR_Bits;

/** \brief Trap Disable Register 0 */
typedef struct _Ifx_SCU_TRAPDIS0_Bits
{
    Ifx_UReg_32Bit CPU0ESR0T:1;       /**< \brief [0:0] Disable Trap Request ESR0T on CPU0 - CPU0ESR0T (rw) */
    Ifx_UReg_32Bit CPU0ESR1T:1;       /**< \brief [1:1] Disable Trap Request ESR1T on CPU0 - CPU0ESR1T (rw) */
    Ifx_UReg_32Bit CPU0TRAP2T:1;      /**< \brief [2:2] Disable Trap Request TRAP2T on CPU0 - CPU0TRAP2T (rw) */
    Ifx_UReg_32Bit CPU0SMUT:1;        /**< \brief [3:3] Disable Trap Request SMUT on CPU0 - CPU0SMUT (rw) */
    Ifx_UReg_32Bit reserved_4:4;      /**< \brief [7:4] \internal Reserved */
    Ifx_UReg_32Bit CPU1ESR0T:1;       /**< \brief [8:8] Disable Trap Request ESR0T on CPU1 (If product has CPU1) - CPU1ESR0T (rw) */
    Ifx_UReg_32Bit CPU1ESR1T:1;       /**< \brief [9:9] Disable Trap Request ESR1T on CPU1 (If product has CPU1) - CPU1ESR1T (rw) */
    Ifx_UReg_32Bit CPU1TRAP2T:1;      /**< \brief [10:10] Disable Trap Request TRAP2T on CPU1 (If product has CPU1) - CPU1TRAP2T (rw) */
    Ifx_UReg_32Bit CPU1SMUT:1;        /**< \brief [11:11] Disable Trap Request SMUT on CPU1 (If product has CPU1) - CPU1SMUT (rw) */
    Ifx_UReg_32Bit reserved_12:4;     /**< \brief [15:12] \internal Reserved */
    Ifx_UReg_32Bit CPU2ESR0T:1;       /**< \brief [16:16] Disable Trap Request ESR0T on CPU2 (If product has CPU2) - CPU2ESR0T (rw) */
    Ifx_UReg_32Bit CPU2ESR1T:1;       /**< \brief [17:17] Disable Trap Request ESR1T on CPU2 (If product has CPU2) - CPU2ESR1T (rw) */
    Ifx_UReg_32Bit CPU2TRAP2T:1;      /**< \brief [18:18] Disable Trap Request TRAP2T on CPU2 (If product has CPU2) - CPU2TRAP2T (rw) */
    Ifx_UReg_32Bit CPU2SMUT:1;        /**< \brief [19:19] Disable Trap Request SMUT on CPU2 (If product has CPU2) - CPU2SMUT (rw) */
    Ifx_UReg_32Bit reserved_20:4;     /**< \brief [23:20] \internal Reserved */
    Ifx_UReg_32Bit CPU3ESR0T:1;       /**< \brief [24:24] Disable Trap Request ESR0T on CPU3 (If product has CPU3) - CPU3ESR0T (rw) */
    Ifx_UReg_32Bit CPU3ESR1T:1;       /**< \brief [25:25] Disable Trap Request ESR1T on CPU3 (If product has CPU3) - CPU3ESR1T (rw) */
    Ifx_UReg_32Bit CPU3TRAP2T:1;      /**< \brief [26:26] Disable Trap Request TRAP2T on CPU3 (If product has CPU3) - CPU3TRAP2T (rw) */
    Ifx_UReg_32Bit CPU3SMUT:1;        /**< \brief [27:27] Disable Trap Request SMUT on CPU3 (If product has CPU3) - CPU3SMUT (rw) */
    Ifx_UReg_32Bit reserved_28:4;     /**< \brief [31:28] \internal Reserved */
} Ifx_SCU_TRAPDIS0_Bits;

/** \brief Trap Disable Register 1 */
typedef struct _Ifx_SCU_TRAPDIS1_Bits
{
    Ifx_UReg_32Bit reserved_0:4;      /**< \brief [3:0] \internal Reserved */
    Ifx_UReg_32Bit reserved_4:4;      /**< \brief [7:4] \internal Reserved */
    Ifx_UReg_32Bit reserved_8:4;      /**< \brief [11:8] \internal Reserved */
    Ifx_UReg_32Bit reserved_12:4;     /**< \brief [15:12] \internal Reserved */
    Ifx_UReg_32Bit reserved_16:16;    /**< \brief [31:16] \internal Reserved */
} Ifx_SCU_TRAPDIS1_Bits;

/** \brief Trap Set Register */
typedef struct _Ifx_SCU_TRAPSET_Bits
{
    Ifx_UReg_32Bit ESR0T:1;           /**< \brief [0:0] Set Trap Request Flag ESR0T - ESR0T (w) */
    Ifx_UReg_32Bit ESR1T:1;           /**< \brief [1:1] Set Trap Request Flag ESR1T - ESR1T (w) */
    Ifx_UReg_32Bit TRAP2:1;           /**< \brief [2:2] Set Trap Request Flag TRAP2 - TRAP2 (w) */
    Ifx_UReg_32Bit SMUT:1;            /**< \brief [3:3] Set Trap Request Flag SMUT - SMUT (w) */
    Ifx_UReg_32Bit reserved_4:28;     /**< \brief [31:4] \internal Reserved */
} Ifx_SCU_TRAPSET_Bits;

/** \brief Trap Status Register */
typedef struct _Ifx_SCU_TRAPSTAT_Bits
{
    Ifx_UReg_32Bit ESR0T:1;           /**< \brief [0:0] ESR0 Trap Request Flag - ESR0T (rh) */
    Ifx_UReg_32Bit ESR1T:1;           /**< \brief [1:1] ESR1 Trap Request Flag - ESR1T (rh) */
    Ifx_UReg_32Bit TRAP2:1;           /**< \brief [2:2] Trap Bit 2 Request Flag - TRAP2 (rh) */
    Ifx_UReg_32Bit SMUT:1;            /**< \brief [3:3] SMU Alarm Trap Request Flag - SMUT (rh) */
    Ifx_UReg_32Bit reserved_4:28;     /**< \brief [31:4] \internal Reserved */
} Ifx_SCU_TRAPSTAT_Bits;

/** \brief CPU${y} WDT Control Register 0 */
typedef struct _Ifx_SCU_WDTCPU_CON0_Bits
{
    unsigned __sfrbit32 ENDINIT:1;       /**< \brief [0:0] End-of-Initialization Control Bit - ENDINIT (rwh) */
    unsigned __sfrbit32 LCK:1;           /**< \brief [1:1] Lock Bit to Control Access to WDTxCON0 - LCK (rwh) */
    unsigned __sfrbit32 PW:14;           /**< \brief [15:2] User-Definable Password Field for Access to WDTxCON0 - PW (rwh) */
    unsigned __sfrbit32 REL:16;          /**< \brief [31:16] Reload Value for the WDT (also Time Check Value) - REL (rw) */
} Ifx_SCU_WDTCPU_CON0_Bits;

/** \brief CPU${y} WDT Control Register 1 */
typedef struct _Ifx_SCU_WDTCPU_CON1_Bits
{
    Ifx_UReg_32Bit reserved_0:1;      /**< \brief [0:0] \internal Reserved */
    Ifx_UReg_32Bit reserved_1:1;      /**< \brief [1:1] \internal Reserved */
    Ifx_UReg_32Bit IR0:1;             /**< \brief [2:2] Input Frequency Request Control - IR1,IR0 (rw) */
    Ifx_UReg_32Bit DR:1;              /**< \brief [3:3] Disable Request Control Bit - DR (rw) */
    Ifx_UReg_32Bit reserved_4:1;      /**< \brief [4:4] \internal Reserved */
    Ifx_UReg_32Bit IR1:1;             /**< \brief [5:5] Input Frequency Request Control - IR1,IR0 (rw) */
    Ifx_UReg_32Bit UR:1;              /**< \brief [6:6] Unlock Restriction Request Control Bit - UR (rw) */
    Ifx_UReg_32Bit PAR:1;             /**< \brief [7:7] Password Auto-sequence Request Bit - PAR (rw) */
    Ifx_UReg_32Bit TCR:1;             /**< \brief [8:8] Counter Check Request Bit - TCR (rw) */
    Ifx_UReg_32Bit TCTR:7;            /**< \brief [15:9] Timer Check Tolerance Request - TCTR (rw) */
    Ifx_UReg_32Bit reserved_16:16;    /**< \brief [31:16] \internal Reserved */
} Ifx_SCU_WDTCPU_CON1_Bits;

/** \brief CPU${y} WDT Status Register */
typedef struct _Ifx_SCU_WDTCPU_SR_Bits
{
    Ifx_UReg_32Bit AE:1;              /**< \brief [0:0] Watchdog Access Error Status Flag - AE (rh) */
    Ifx_UReg_32Bit OE:1;              /**< \brief [1:1] Watchdog Overflow Error Status Flag - OE (rh) */
    Ifx_UReg_32Bit IS0:1;             /**< \brief [2:2] Watchdog Input Clock Status - IS1,IS0 (rh) */
    Ifx_UReg_32Bit DS:1;              /**< \brief [3:3] Watchdog Enable/Disable Status Flag - DS (rh) */
    Ifx_UReg_32Bit TO:1;              /**< \brief [4:4] Watchdog Time-Out Mode Flag - TO (rh) */
    Ifx_UReg_32Bit IS1:1;             /**< \brief [5:5] Watchdog Input Clock Status - IS1,IS0 (rh) */
    Ifx_UReg_32Bit US:1;              /**< \brief [6:6] SMU Unlock Restriction Status Flag - US (rh) */
    Ifx_UReg_32Bit PAS:1;             /**< \brief [7:7] Password Auto-sequence Status Flag - PAS (rh) */
    Ifx_UReg_32Bit TCS:1;             /**< \brief [8:8] Timer Check Status Flag - TCS (rh) */
    Ifx_UReg_32Bit TCT:7;             /**< \brief [15:9] Timer Check Tolerance - TCT (rh) */
    Ifx_UReg_32Bit TIM:16;            /**< \brief [31:16] Timer Value - TIM (rh) */
} Ifx_SCU_WDTCPU_SR_Bits;

/** \brief Safety WDT Control Register 0 */
typedef struct _Ifx_SCU_WDTS_CON0_Bits
{
    unsigned __sfrbit32 ENDINIT:1;       /**< \brief [0:0] End-of-Initialization Control Bit - ENDINIT (rwh) */
    unsigned __sfrbit32 LCK:1;           /**< \brief [1:1] Lock Bit to Control Access to WDTxCON0 - LCK (rwh) */
    unsigned __sfrbit32 PW:14;           /**< \brief [15:2] User-Definable Password Field for Access to WDTxCON0 - PW (rwh) */
    unsigned __sfrbit32 REL:16;          /**< \brief [31:16] Reload Value for the WDT (also Time Check Value) - REL (rw) */
} Ifx_SCU_WDTS_CON0_Bits;

/** \brief Safety WDT Control Register 1 */
typedef struct _Ifx_SCU_WDTS_CON1_Bits
{
    Ifx_UReg_32Bit CLRIRF:1;          /**< \brief [0:0] Clear Internal Reset Flag - CLRIRF (rwh) */
    Ifx_UReg_32Bit reserved_1:1;      /**< \brief [1:1] \internal Reserved */
    Ifx_UReg_32Bit IR0:1;             /**< \brief [2:2] Input Frequency Request Control - IR1,IR0 (rw) */
    Ifx_UReg_32Bit DR:1;              /**< \brief [3:3] Disable Request Control Bit - DR (rw) */
    Ifx_UReg_32Bit reserved_4:1;      /**< \brief [4:4] \internal Reserved */
    Ifx_UReg_32Bit IR1:1;             /**< \brief [5:5] Input Frequency Request Control - IR1,IR0 (rw) */
    Ifx_UReg_32Bit UR:1;              /**< \brief [6:6] Unlock Restriction Request Control Bit - UR (rw) */
    Ifx_UReg_32Bit PAR:1;             /**< \brief [7:7] Password Auto-sequence Request Bit - PAR (rw) */
    Ifx_UReg_32Bit TCR:1;             /**< \brief [8:8] Counter Check Request Bit - TCR (rw) */
    Ifx_UReg_32Bit TCTR:7;            /**< \brief [15:9] Timer Check Tolerance Request - TCTR (rw) */
    Ifx_UReg_32Bit reserved_16:16;    /**< \brief [31:16] \internal Reserved */
} Ifx_SCU_WDTS_CON1_Bits;

/** \brief Safety WDT Status Register */
typedef struct _Ifx_SCU_WDTS_SR_Bits
{
    Ifx_UReg_32Bit AE:1;              /**< \brief [0:0] Watchdog Access Error Status Flag - AE (rh) */
    Ifx_UReg_32Bit OE:1;              /**< \brief [1:1] Watchdog Overflow Error Status Flag - OE (rh) */
    Ifx_UReg_32Bit IS0:1;             /**< \brief [2:2] Watchdog Input Clock Status - IS1,IS0 (rh) */
    Ifx_UReg_32Bit DS:1;              /**< \brief [3:3] Watchdog Enable/Disable Status Flag - DS (rh) */
    Ifx_UReg_32Bit TO:1;              /**< \brief [4:4] Watchdog Time-Out Mode Flag - TO (rh) */
    Ifx_UReg_32Bit IS1:1;             /**< \brief [5:5] Watchdog Input Clock Status - IS1,IS0 (rh) */
    Ifx_UReg_32Bit US:1;              /**< \brief [6:6] SMU Unlock Restriction Status Flag - US (rh) */
    Ifx_UReg_32Bit PAS:1;             /**< \brief [7:7] Password Auto-sequence Status Flag - PAS (rh) */
    Ifx_UReg_32Bit TCS:1;             /**< \brief [8:8] Timer Check Status Flag - TCS (rh) */
    Ifx_UReg_32Bit TCT:7;             /**< \brief [15:9] Timer Check Tolerance - TCT (rh) */
    Ifx_UReg_32Bit TIM:16;            /**< \brief [31:16] Timer Value - TIM (rh) */
} Ifx_SCU_WDTS_SR_Bits;

/** \}  */
/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_scu_Registers_union
 * \{   */
/** \brief Access Enable Register 00   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_ACCEN00_Bits B;           /**< \brief Bitfield access */
} Ifx_SCU_ACCEN00;

/** \brief Access Enable Register 01   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_ACCEN01_Bits B;           /**< \brief Bitfield access */
} Ifx_SCU_ACCEN01;

/** \brief Access Enable Register 10   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_ACCEN10_Bits B;           /**< \brief Bitfield access */
} Ifx_SCU_ACCEN10;

/** \brief Access Enable Register 11   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_ACCEN11_Bits B;           /**< \brief Bitfield access */
} Ifx_SCU_ACCEN11;

/** \brief Application Reset Disable Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_ARSTDIS_Bits B;           /**< \brief Bitfield access */
} Ifx_SCU_ARSTDIS;

/** \brief CCU Clock Control Register 0   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_CCUCON0_Bits B;           /**< \brief Bitfield access */
} Ifx_SCU_CCUCON0;

/** \brief CCU Clock Control Register 1   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_CCUCON1_Bits B;           /**< \brief Bitfield access */
} Ifx_SCU_CCUCON1;

/** \brief CCU Clock Control Register 2   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_CCUCON2_Bits B;           /**< \brief Bitfield access */
} Ifx_SCU_CCUCON2;

/** \brief CCU Clock Control Register 3   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_CCUCON3_Bits B;           /**< \brief Bitfield access */
} Ifx_SCU_CCUCON3;

/** \brief CCU Clock Control Register 4   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_CCUCON4_Bits B;           /**< \brief Bitfield access */
} Ifx_SCU_CCUCON4;

/** \brief CCU Clock Control Register 5   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_CCUCON5_Bits B;           /**< \brief Bitfield access */
} Ifx_SCU_CCUCON5;

/** \brief CCU Clock Control Register 6   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_CCUCON6_Bits B;           /**< \brief Bitfield access */
} Ifx_SCU_CCUCON6;

/** \brief CCU Clock Control Register 7   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_CCUCON7_Bits B;           /**< \brief Bitfield access */
} Ifx_SCU_CCUCON7;

/** \brief CCU Clock Control Register 8   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_CCUCON8_Bits B;           /**< \brief Bitfield access */
} Ifx_SCU_CCUCON8;

/** \brief CCU Clock Control Register 9   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_CCUCON9_Bits B;           /**< \brief Bitfield access */
} Ifx_SCU_CCUCON9;

/** \brief Chip Identification Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_CHIPID_Bits B;            /**< \brief Bitfield access */
} Ifx_SCU_CHIPID;

/** \brief Core Die Temperature Sensor Limit Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_DTSCLIM_Bits B;           /**< \brief Bitfield access */
} Ifx_SCU_DTSCLIM;

/** \brief Core Die Temperature Sensor Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_DTSCSTAT_Bits B;          /**< \brief Bitfield access */
} Ifx_SCU_DTSCSTAT;

/** \brief ENDINIT Global Control Register 0   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_EICON0_Bits B;            /**< \brief Bitfield access */
} Ifx_SCU_EICON0;

/** \brief ENDINIT Global Control Register 1   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_EICON1_Bits B;            /**< \brief Bitfield access */
} Ifx_SCU_EICON1;

/** \brief External Input Channel Register ${i}   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_EICR_Bits B;              /**< \brief Bitfield access */
} Ifx_SCU_EICR;

/** \brief External Input Filter Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_EIFILT_Bits B;            /**< \brief Bitfield access */
} Ifx_SCU_EIFILT;

/** \brief External Input Flag Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_EIFR_Bits B;              /**< \brief Bitfield access */
} Ifx_SCU_EIFR;

/** \brief ENDINIT Timeout Counter Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_EISR_Bits B;              /**< \brief Bitfield access */
} Ifx_SCU_EISR;

/** \brief Emergency Stop Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_EMSR_Bits B;              /**< \brief Bitfield access */
} Ifx_SCU_EMSR;

/** \brief Emergency Stop Software set and clear register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_EMSSW_Bits B;             /**< \brief Bitfield access */
} Ifx_SCU_EMSSW;

/** \brief ESR${x} Input Configuration Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_ESRCFGX_ESRCFGX_Bits B;    /**< \brief Bitfield access */
} Ifx_SCU_ESRCFGX_ESRCFGX;

/** \brief ESR Output Configuration Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_ESROCFG_Bits B;           /**< \brief Bitfield access */
} Ifx_SCU_ESROCFG;

/** \brief External Clock Control Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_EXTCON_Bits B;            /**< \brief Bitfield access */
} Ifx_SCU_EXTCON;

/** \brief Fractional Divider Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_FDR_Bits B;               /**< \brief Bitfield access */
} Ifx_SCU_FDR;

/** \brief Flag Modification Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_FMR_Bits B;               /**< \brief Bitfield access */
} Ifx_SCU_FMR;

/** \brief Identification Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_ID_Bits B;                /**< \brief Bitfield access */
} Ifx_SCU_ID;

/** \brief Flag Gating Register ${j}   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_IGCR_Bits B;              /**< \brief Bitfield access */
} Ifx_SCU_IGCR;

/** \brief ESR Input Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_IN_Bits B;                /**< \brief Bitfield access */
} Ifx_SCU_IN;

/** \brief Input/Output Control Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_IOCR_Bits B;              /**< \brief Bitfield access */
} Ifx_SCU_IOCR;

/** \brief Logic BIST Control 0 Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_LBISTCTRL0_Bits B;        /**< \brief Bitfield access */
} Ifx_SCU_LBISTCTRL0;

/** \brief Logic BIST Control 1 Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_LBISTCTRL1_Bits B;        /**< \brief Bitfield access */
} Ifx_SCU_LBISTCTRL1;

/** \brief Logic BIST Control 2 Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_LBISTCTRL2_Bits B;        /**< \brief Bitfield access */
} Ifx_SCU_LBISTCTRL2;

/** \brief Logic BIST Control 3 Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_LBISTCTRL3_Bits B;        /**< \brief Bitfield access */
} Ifx_SCU_LBISTCTRL3;

/** \brief LCL CPU0 and CPU2 Control Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_LCLCON0_Bits B;           /**< \brief Bitfield access */
} Ifx_SCU_LCLCON0;

/** \brief LCL CPU1 and CPU3 Control Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_LCLCON1_Bits B;           /**< \brief Bitfield access */
} Ifx_SCU_LCLCON1;

/** \brief LCL Test Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_LCLTEST_Bits B;           /**< \brief Bitfield access */
} Ifx_SCU_LCLTEST;

/** \brief Manufacturer Identification Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_MANID_Bits B;             /**< \brief Bitfield access */
} Ifx_SCU_MANID;

/** \brief ESR Output Modification Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_OMR_Bits B;               /**< \brief Bitfield access */
} Ifx_SCU_OMR;

/** \brief OSC Control Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_OSCCON_Bits B;            /**< \brief Bitfield access */
} Ifx_SCU_OSCCON;

/** \brief ESR Output Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_OUT_Bits B;               /**< \brief Bitfield access */
} Ifx_SCU_OUT;

/** \brief Overlay Control Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_OVCCON_Bits B;            /**< \brief Bitfield access */
} Ifx_SCU_OVCCON;

/** \brief Overlay Enable Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_OVCENABLE_Bits B;         /**< \brief Bitfield access */
} Ifx_SCU_OVCENABLE;

/** \brief Pad Disable Control Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_PDISC_Bits B;             /**< \brief Bitfield access */
} Ifx_SCU_PDISC;

/** \brief ESR Pad Driver Mode Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_PDR_Bits B;               /**< \brief Bitfield access */
} Ifx_SCU_PDR;

/** \brief Pattern Detection Result Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_PDRR_Bits B;              /**< \brief Bitfield access */
} Ifx_SCU_PDRR;

/** \brief Peripheral PLL Configuration 0 Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_PERPLLCON0_Bits B;        /**< \brief Bitfield access */
} Ifx_SCU_PERPLLCON0;

/** \brief Peripheral PLL Configuration 1 Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_PERPLLCON1_Bits B;        /**< \brief Bitfield access */
} Ifx_SCU_PERPLLCON1;

/** \brief Peripheral PLL Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_PERPLLSTAT_Bits B;        /**< \brief Bitfield access */
} Ifx_SCU_PERPLLSTAT;

/** \brief Power Management Control and Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_PMCSR0_Bits B;            /**< \brief Bitfield access */
} Ifx_SCU_PMCSR0;

/** \brief Power Management Control and Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_PMCSR1_Bits B;            /**< \brief Bitfield access */
} Ifx_SCU_PMCSR1;

/** \brief Power Management Control and Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_PMCSR2_Bits B;            /**< \brief Bitfield access */
} Ifx_SCU_PMCSR2;

/** \brief Power Management Control and Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_PMCSR3_Bits B;            /**< \brief Bitfield access */
} Ifx_SCU_PMCSR3;

/** \brief Power Management Control and Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_PMCSR4_Bits B;            /**< \brief Bitfield access */
} Ifx_SCU_PMCSR4;

/** \brief Power Management Control and Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_PMCSR5_Bits B;            /**< \brief Bitfield access */
} Ifx_SCU_PMCSR5;

/** \brief Power Management Status Register 0   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_PMSTAT0_Bits B;           /**< \brief Bitfield access */
} Ifx_SCU_PMSTAT0;

/** \brief Standby and Wake-up Control Register 1   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_PMSWCR1_Bits B;           /**< \brief Bitfield access */
} Ifx_SCU_PMSWCR1;

/** \brief Power Management Transition Control and Status Register 0   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_PMTRCSR0_Bits B;          /**< \brief Bitfield access */
} Ifx_SCU_PMTRCSR0;

/** \brief Power Management Transition Control and Status Register 1   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_PMTRCSR1_Bits B;          /**< \brief Bitfield access */
} Ifx_SCU_PMTRCSR1;

/** \brief Power Management Transition Control and Status Register 2   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_PMTRCSR2_Bits B;          /**< \brief Bitfield access */
} Ifx_SCU_PMTRCSR2;

/** \brief Power Management Transition Control and Status Register 3   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_PMTRCSR3_Bits B;          /**< \brief Bitfield access */
} Ifx_SCU_PMTRCSR3;

/** \brief Reset Configuration Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_RSTCON_Bits B;            /**< \brief Bitfield access */
} Ifx_SCU_RSTCON;

/** \brief Additional Reset Control Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_RSTCON2_Bits B;           /**< \brief Bitfield access */
} Ifx_SCU_RSTCON2;

/** \brief Reset Configuration Register 3   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_RSTCON3_Bits B;           /**< \brief Bitfield access */
} Ifx_SCU_RSTCON3;

/** \brief Reset Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_RSTSTAT_Bits B;           /**< \brief Bitfield access */
} Ifx_SCU_RSTSTAT;

/** \brief Safety ENDINIT Control Register 0   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_SEICON0_Bits B;           /**< \brief Bitfield access */
} Ifx_SCU_SEICON0;

/** \brief Safety ENDINIT Control Register 1   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_SEICON1_Bits B;           /**< \brief Bitfield access */
} Ifx_SCU_SEICON1;

/** \brief Safety ENDINIT Timeout Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_SEISR_Bits B;             /**< \brief Bitfield access */
} Ifx_SCU_SEISR;

/** \brief Start-up Configuration Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_STCON_Bits B;             /**< \brief Bitfield access */
} Ifx_SCU_STCON;

/** \brief Start-up Memory Register 1   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_STMEM1_Bits B;            /**< \brief Bitfield access */
} Ifx_SCU_STMEM1;

/** \brief Start-up Memory Register 2   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_STMEM2_Bits B;            /**< \brief Bitfield access */
} Ifx_SCU_STMEM2;

/** \brief Start-up Memory Register 3   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_STMEM3_Bits B;            /**< \brief Bitfield access */
} Ifx_SCU_STMEM3;

/** \brief Start-up Memory Register 4   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_STMEM4_Bits B;            /**< \brief Bitfield access */
} Ifx_SCU_STMEM4;

/** \brief Start-up Memory Register 5   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_STMEM5_Bits B;            /**< \brief Bitfield access */
} Ifx_SCU_STMEM5;

/** \brief Start-up Memory Register 6   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_STMEM6_Bits B;            /**< \brief Bitfield access */
} Ifx_SCU_STMEM6;

/** \brief Start-up Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_STSTAT_Bits B;            /**< \brief Bitfield access */
} Ifx_SCU_STSTAT;

/** \brief Address Map Control Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_SWAPCTRL_Bits B;          /**< \brief Bitfield access */
} Ifx_SCU_SWAPCTRL;

/** \brief Software Reset Configuration Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_SWRSTCON_Bits B;          /**< \brief Bitfield access */
} Ifx_SCU_SWRSTCON;

/** \brief System Control Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_SYSCON_Bits B;            /**< \brief Bitfield access */
} Ifx_SCU_SYSCON;

/** \brief System PLL Configuration 0 Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_SYSPLLCON0_Bits B;        /**< \brief Bitfield access */
} Ifx_SCU_SYSPLLCON0;

/** \brief System PLL Configuration 1 Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_SYSPLLCON1_Bits B;        /**< \brief Bitfield access */
} Ifx_SCU_SYSPLLCON1;

/** \brief System PLL Configuration 2 Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_SYSPLLCON2_Bits B;        /**< \brief Bitfield access */
} Ifx_SCU_SYSPLLCON2;

/** \brief System PLL Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_SYSPLLSTAT_Bits B;        /**< \brief Bitfield access */
} Ifx_SCU_SYSPLLSTAT;

/** \brief Trap Clear Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_TRAPCLR_Bits B;           /**< \brief Bitfield access */
} Ifx_SCU_TRAPCLR;

/** \brief Trap Disable Register 0   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_TRAPDIS0_Bits B;          /**< \brief Bitfield access */
} Ifx_SCU_TRAPDIS0;

/** \brief Trap Disable Register 1   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_TRAPDIS1_Bits B;          /**< \brief Bitfield access */
} Ifx_SCU_TRAPDIS1;

/** \brief Trap Set Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_TRAPSET_Bits B;           /**< \brief Bitfield access */
} Ifx_SCU_TRAPSET;

/** \brief Trap Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_TRAPSTAT_Bits B;          /**< \brief Bitfield access */
} Ifx_SCU_TRAPSTAT;

/** \brief CPU${y} WDT Control Register 0   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_WDTCPU_CON0_Bits B;       /**< \brief Bitfield access */
} Ifx_SCU_WDTCPU_CON0;

/** \brief CPU${y} WDT Control Register 1   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_WDTCPU_CON1_Bits B;       /**< \brief Bitfield access */
} Ifx_SCU_WDTCPU_CON1;

/** \brief CPU${y} WDT Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_WDTCPU_SR_Bits B;         /**< \brief Bitfield access */
} Ifx_SCU_WDTCPU_SR;

/** \brief Safety WDT Control Register 0   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_WDTS_CON0_Bits B;         /**< \brief Bitfield access */
} Ifx_SCU_WDTS_CON0;

/** \brief Safety WDT Control Register 1   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_WDTS_CON1_Bits B;         /**< \brief Bitfield access */
} Ifx_SCU_WDTS_CON1;

/** \brief Safety WDT Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_WDTS_SR_Bits B;           /**< \brief Bitfield access */
} Ifx_SCU_WDTS_SR;

/** \}  */

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Scu_ESRCFGx_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief ESRCFGX object */
typedef volatile struct _Ifx_SCU_ESRCFGX
{
       Ifx_SCU_ESRCFGX_ESRCFGX             ESRCFGX;                /**< \brief 0, ESR${x} Input Configuration Register*/
} Ifx_SCU_ESRCFGX;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Scu_WDTCPU_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief WDTCPU object */
typedef volatile struct _Ifx_SCU_WDTCPU
{
       Ifx_SCU_WDTCPU_CON0                 CON0;                   /**< \brief 0, */
       Ifx_SCU_WDTCPU_CON1                 CON1;                   /**< \brief 4, */
       Ifx_SCU_WDTCPU_SR                   SR;                     /**< \brief 8, */
} Ifx_SCU_WDTCPU;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Scu_WDTS_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief WDTS object */
typedef volatile struct _Ifx_SCU_WDTS
{
       Ifx_SCU_WDTS_CON0                   CON0;                   /**< \brief 0, Safety WDT Control Register 0*/
       Ifx_SCU_WDTS_CON1                   CON1;                   /**< \brief 4, Safety WDT Control Register 1*/
       Ifx_SCU_WDTS_SR                     SR;                     /**< \brief 8, Safety WDT Status Register*/
} Ifx_SCU_WDTS;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/** \addtogroup IfxSfr_Scu_Registers_struct
 * \{  */
/******************************************************************************/
/** \name Object L0
 * \{  */

/** \brief SCU object */
typedef volatile struct _Ifx_SCU
{
       Ifx_UReg_8Bit                       reserved_0[8];          /**< \brief 0, \internal Reserved */
       Ifx_SCU_ID                          ID;                     /**< \brief 8, Identification Register*/
       Ifx_UReg_8Bit                       reserved_C[4];          /**< \brief C, \internal Reserved */
       Ifx_SCU_OSCCON                      OSCCON;                 /**< \brief 10, OSC Control Register*/
       Ifx_SCU_SYSPLLSTAT                  SYSPLLSTAT;             /**< \brief 14, System PLL Status Register*/
       Ifx_SCU_SYSPLLCON0                  SYSPLLCON0;             /**< \brief 18, System PLL Configuration 0 Register*/
       Ifx_SCU_SYSPLLCON1                  SYSPLLCON1;             /**< \brief 1C, System PLL Configuration 1 Register*/
       Ifx_SCU_SYSPLLCON2                  SYSPLLCON2;             /**< \brief 20, System PLL Configuration 2 Register*/
       Ifx_SCU_PERPLLSTAT                  PERPLLSTAT;             /**< \brief 24, Peripheral PLL Status Register*/
       Ifx_SCU_PERPLLCON0                  PERPLLCON0;             /**< \brief 28, Peripheral PLL Configuration 0 Register*/
       Ifx_SCU_PERPLLCON1                  PERPLLCON1;             /**< \brief 2C, Peripheral PLL Configuration 1 Register*/
       Ifx_SCU_CCUCON0                     CCUCON0;                /**< \brief 30, CCU Clock Control Register 0*/
       Ifx_SCU_CCUCON1                     CCUCON1;                /**< \brief 34, CCU Clock Control Register 1*/
       Ifx_SCU_FDR                         FDR;                    /**< \brief 38, Fractional Divider Register*/
       Ifx_SCU_EXTCON                      EXTCON;                 /**< \brief 3C, External Clock Control Register*/
       Ifx_SCU_CCUCON2                     CCUCON2;                /**< \brief 40, CCU Clock Control Register 2*/
       Ifx_SCU_CCUCON3                     CCUCON3;                /**< \brief 44, CCU Clock Control Register 3*/
       Ifx_SCU_CCUCON4                     CCUCON4;                /**< \brief 48, CCU Clock Control Register 4*/
       Ifx_SCU_CCUCON5                     CCUCON5;                /**< \brief 4C, CCU Clock Control Register 5*/
       Ifx_SCU_RSTSTAT                     RSTSTAT;                /**< \brief 50, */
       Ifx_UReg_8Bit                       reserved_54[4];         /**< \brief 54, \internal Reserved */
       Ifx_SCU_RSTCON                      RSTCON;                 /**< \brief 58, */
       Ifx_SCU_ARSTDIS                     ARSTDIS;                /**< \brief 5C, */
       Ifx_SCU_SWRSTCON                    SWRSTCON;               /**< \brief 60, */
       Ifx_SCU_RSTCON2                     RSTCON2;                /**< \brief 64, */
       Ifx_SCU_RSTCON3                     RSTCON3;                /**< \brief 68, */
       Ifx_UReg_8Bit                       reserved_6C[4];         /**< \brief 6C, \internal Reserved */
       Ifx_SCU_ESRCFGX                     ESRCFGX[2];             /**< \brief 70, ESR${x} Input Configuration Register*/
       Ifx_SCU_ESROCFG                     ESROCFG;                /**< \brief 78, ESR Output Configuration Register*/
       Ifx_SCU_SYSCON                      SYSCON;                 /**< \brief 7C, System Control Register*/
       Ifx_SCU_CCUCON6                     CCUCON6;                /**< \brief 80, CCU Clock Control Register 6*/
       Ifx_SCU_CCUCON7                     CCUCON7;                /**< \brief 84, CCU Clock Control Register 7*/
       Ifx_SCU_CCUCON8                     CCUCON8;                /**< \brief 88, CCU Clock Control Register 8*/
       Ifx_SCU_CCUCON9                     CCUCON9;                /**< \brief 8C, CCU Clock Control Register 9*/
       Ifx_UReg_8Bit                       reserved_90[12];        /**< \brief 90, \internal Reserved */
       Ifx_SCU_PDR                         PDR;                    /**< \brief 9C, ESR Pad Driver Mode Register*/
       Ifx_SCU_IOCR                        IOCR;                   /**< \brief A0, Input/Output Control Register*/
       Ifx_SCU_OUT                         OUT;                    /**< \brief A4, ESR Output Register*/
       Ifx_SCU_OMR                         OMR;                    /**< \brief A8, ESR Output Modification Register*/
       Ifx_SCU_IN                          IN;                     /**< \brief AC, ESR Input Register*/
       Ifx_UReg_8Bit                       reserved_B0[16];        /**< \brief B0, \internal Reserved */
       Ifx_SCU_STSTAT                      STSTAT;                 /**< \brief C0, */
       Ifx_SCU_STCON                       STCON;                  /**< \brief C4, Start-up Configuration Register*/
       Ifx_SCU_PMCSR0                      PMCSR0;                 /**< \brief C8, Power Management Control and Status Register*/
       Ifx_SCU_PMCSR1                      PMCSR1;                 /**< \brief CC, Power Management Control and Status Register*/
       Ifx_SCU_PMCSR2                      PMCSR2;                 /**< \brief D0, Power Management Control and Status Register*/
       Ifx_SCU_PMCSR3                      PMCSR3;                 /**< \brief D4, Power Management Control and Status Register*/
       Ifx_SCU_PMCSR4                      PMCSR4;                 /**< \brief D8, Power Management Control and Status Register*/
       Ifx_SCU_PMCSR5                      PMCSR5;                 /**< \brief DC, Power Management Control and Status Register*/
       Ifx_UReg_8Bit                       reserved_E0[4];         /**< \brief E0, \internal Reserved */
       Ifx_SCU_PMSTAT0                     PMSTAT0;                /**< \brief E4, Power Management Status Register 0*/
       Ifx_SCU_PMSWCR1                     PMSWCR1;                /**< \brief E8, Standby and Wake-up Control Register 1*/
       Ifx_UReg_8Bit                       reserved_EC[16];        /**< \brief EC, \internal Reserved */
       Ifx_SCU_EMSR                        EMSR;                   /**< \brief FC, Emergency Stop Register*/
       Ifx_SCU_EMSSW                       EMSSW;                  /**< \brief 100, Emergency Stop Software set and clear register*/
       Ifx_SCU_DTSCSTAT                    DTSCSTAT;               /**< \brief 104, Core Die Temperature Sensor Status Register*/
       Ifx_SCU_DTSCLIM                     DTSCLIM;                /**< \brief 108, Core Die Temperature Sensor Limit Register*/
       Ifx_UReg_8Bit                       reserved_10C[20];       /**< \brief 10C, \internal Reserved */
       Ifx_SCU_TRAPDIS1                    TRAPDIS1;               /**< \brief 120, Trap Disable Register 1*/
       Ifx_SCU_TRAPSTAT                    TRAPSTAT;               /**< \brief 124, Trap Status Register*/
       Ifx_SCU_TRAPSET                     TRAPSET;                /**< \brief 128, Trap Set Register*/
       Ifx_SCU_TRAPCLR                     TRAPCLR;                /**< \brief 12C, Trap Clear Register*/
       Ifx_SCU_TRAPDIS0                    TRAPDIS0;               /**< \brief 130, Trap Disable Register 0*/
       Ifx_SCU_LCLCON0                     LCLCON0;                /**< \brief 134, LCL CPU0 and CPU2 Control Register*/
       Ifx_SCU_LCLCON1                     LCLCON1;                /**< \brief 138, LCL CPU1 and CPU3 Control Register*/
       Ifx_SCU_LCLTEST                     LCLTEST;                /**< \brief 13C, LCL Test Register*/
       Ifx_SCU_CHIPID                      CHIPID;                 /**< \brief 140, Chip Identification Register*/
       Ifx_SCU_MANID                       MANID;                  /**< \brief 144, Manufacturer Identification Register*/
       Ifx_UReg_8Bit                       reserved_148[4];        /**< \brief 148, \internal Reserved */
       Ifx_SCU_SWAPCTRL                    SWAPCTRL;               /**< \brief 14C, Address Map Control Register*/
       Ifx_UReg_8Bit                       reserved_150[20];       /**< \brief 150, \internal Reserved */
       Ifx_SCU_LBISTCTRL0                  LBISTCTRL0;             /**< \brief 164, Logic BIST Control 0 Register*/
       Ifx_SCU_LBISTCTRL1                  LBISTCTRL1;             /**< \brief 168, Logic BIST Control 1 Register*/
       Ifx_SCU_LBISTCTRL2                  LBISTCTRL2;             /**< \brief 16C, Logic BIST Control 2 Register*/
       Ifx_SCU_LBISTCTRL3                  LBISTCTRL3;             /**< \brief 170, Logic BIST Control 3 Register*/
       Ifx_UReg_8Bit                       reserved_174[16];       /**< \brief 174, \internal Reserved */
       Ifx_SCU_STMEM1                      STMEM1;                 /**< \brief 184, Start-up Memory Register 1*/
       Ifx_SCU_STMEM2                      STMEM2;                 /**< \brief 188, Start-up Memory Register 2*/
       Ifx_SCU_PDISC                       PDISC;                  /**< \brief 18C, Pad Disable Control Register*/
       Ifx_UReg_8Bit                       reserved_190[8];        /**< \brief 190, \internal Reserved */
       Ifx_SCU_PMTRCSR0                    PMTRCSR0;               /**< \brief 198, Power Management Transition Control and Status Register 0*/
       Ifx_SCU_PMTRCSR1                    PMTRCSR1;               /**< \brief 19C, Power Management Transition Control and Status Register 1*/
       Ifx_SCU_PMTRCSR2                    PMTRCSR2;               /**< \brief 1A0, Power Management Transition Control and Status Register 2*/
       Ifx_SCU_PMTRCSR3                    PMTRCSR3;               /**< \brief 1A4, Power Management Transition Control and Status Register 3*/
       Ifx_UReg_8Bit                       reserved_1A8[24];       /**< \brief 1A8, \internal Reserved */
       Ifx_SCU_STMEM3                      STMEM3;                 /**< \brief 1C0, Start-up Memory Register 3*/
       Ifx_SCU_STMEM4                      STMEM4;                 /**< \brief 1C4, Start-up Memory Register 4*/
       Ifx_SCU_STMEM5                      STMEM5;                 /**< \brief 1C8, Start-up Memory Register 5*/
       Ifx_SCU_STMEM6                      STMEM6;                 /**< \brief 1CC, Start-up Memory Register 6*/
       Ifx_UReg_8Bit                       reserved_1D0[16];       /**< \brief 1D0, \internal Reserved */
       Ifx_SCU_OVCENABLE                   OVCENABLE;              /**< \brief 1E0, Overlay Enable Register*/
       Ifx_SCU_OVCCON                      OVCCON;                 /**< \brief 1E4, Overlay Control Register*/
       Ifx_UReg_8Bit                       reserved_1E8[36];       /**< \brief 1E8, \internal Reserved */
       Ifx_SCU_EIFILT                      EIFILT;                 /**< \brief 20C, External Input Filter Register*/
       Ifx_SCU_EICR                        EICR[4];                /**< \brief 210, External Input Channel Register ${i}*/
       Ifx_SCU_EIFR                        EIFR;                   /**< \brief 220, External Input Flag Register*/
       Ifx_SCU_FMR                         FMR;                    /**< \brief 224, Flag Modification Register*/
       Ifx_SCU_PDRR                        PDRR;                   /**< \brief 228, Pattern Detection Result Register*/
       Ifx_SCU_IGCR                        IGCR[4];                /**< \brief 22C, Flag Gating Register ${j}*/
       Ifx_UReg_8Bit                       reserved_23C[16];       /**< \brief 23C, \internal Reserved */
       Ifx_SCU_WDTCPU                      WDTCPU[4];              /**< \brief 24C, */
       Ifx_UReg_8Bit                       reserved_27C[32];       /**< \brief 27C, \internal Reserved */
       Ifx_SCU_EICON0                      EICON0;                 /**< \brief 29C, ENDINIT Global Control Register 0*/
       Ifx_SCU_EICON1                      EICON1;                 /**< \brief 2A0, ENDINIT Global Control Register 1*/
       Ifx_SCU_EISR                        EISR;                   /**< \brief 2A4, ENDINIT Timeout Counter Status Register*/
       Ifx_SCU_WDTS                        WDTS;                   /**< \brief 2A8, Safety WDT Status Register*/
       Ifx_SCU_SEICON0                     SEICON0;                /**< \brief 2B4, Safety ENDINIT Control Register 0*/
       Ifx_SCU_SEICON1                     SEICON1;                /**< \brief 2B8, Safety ENDINIT Control Register 1*/
       Ifx_SCU_SEISR                       SEISR;                  /**< \brief 2BC, Safety ENDINIT Timeout Status Register*/
       Ifx_UReg_8Bit                       reserved_2C0[304];      /**< \brief 2C0, \internal Reserved */
       Ifx_SCU_ACCEN11                     ACCEN11;                /**< \brief 3F0, Access Enable Register 11*/
       Ifx_SCU_ACCEN10                     ACCEN10;                /**< \brief 3F4, Access Enable Register 10*/
       Ifx_SCU_ACCEN01                     ACCEN01;                /**< \brief 3F8, Access Enable Register 01*/
       Ifx_SCU_ACCEN00                     ACCEN00;                /**< \brief 3FC, Access Enable Register 00*/
} Ifx_SCU;

/** \}  */
/******************************************************************************/
/** \}  */


/******************************************************************************/

/******************************************************************************/


#line 57 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\Infra\\Sfr\\TC38A\\_Reg\\IfxScu_reg.h"
/******************************************************************************/

/******************************************************************************/

/******************************************************************************/

/** \addtogroup IfxSfr_Scu_Registers_Cfg_BaseAddress
 * \{  */

/** \brief SCU object */

/** \}  */


/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Scu_Registers_Cfg_Scu
 * \{  */
/** \brief 8, Identification Register */


/** \brief 10, OSC Control Register */


/** \brief 14, System PLL Status Register */


/** \brief 18, System PLL Configuration 0 Register */


/** \brief 1C, System PLL Configuration 1 Register */


/** \brief 20, System PLL Configuration 2 Register */


/** \brief 24, Peripheral PLL Status Register */


/** \brief 28, Peripheral PLL Configuration 0 Register */


/** \brief 2C, Peripheral PLL Configuration 1 Register */


/** \brief 30, CCU Clock Control Register 0 */


/** \brief 34, CCU Clock Control Register 1 */


/** \brief 38, Fractional Divider Register */


/** \brief 3C, External Clock Control Register */


/** \brief 40, CCU Clock Control Register 2 */


/** \brief 44, CCU Clock Control Register 3 */


/** \brief 48, CCU Clock Control Register 4 */


/** \brief 4C, CCU Clock Control Register 5 */


/** \brief 50, Reset Status Register */


/** \brief 58, Reset Configuration Register */


/** \brief 5C, Application Reset Disable Register */


/** \brief 60, Software Reset Configuration Register */


/** \brief 64, Additional Reset Control Register */


/** \brief 68, Reset Configuration Register 3 */


/** \brief 70, ESR0 Input Configuration Register */

/** Alias (User Manual Name) for SCU_ESRCFGX0_ESRCFGX.
* To use register names with standard convension, please use SCU_ESRCFGX0_ESRCFGX.
*/


/** \brief 74, ESR1 Input Configuration Register */

/** Alias (User Manual Name) for SCU_ESRCFGX1_ESRCFGX.
* To use register names with standard convension, please use SCU_ESRCFGX1_ESRCFGX.
*/


/** \brief 78, ESR Output Configuration Register */


/** \brief 7C, System Control Register */


/** \brief 80, CCU Clock Control Register 6 */


/** \brief 84, CCU Clock Control Register 7 */


/** \brief 88, CCU Clock Control Register 8 */


/** \brief 8C, CCU Clock Control Register 9 */


/** \brief 9C, ESR Pad Driver Mode Register */


/** \brief A0, Input/Output Control Register */


/** \brief A4, ESR Output Register */


/** \brief A8, ESR Output Modification Register */


/** \brief AC, ESR Input Register */


/** \brief C0, Start-up Status Register */


/** \brief C4, Start-up Configuration Register */


/** \brief C8, Power Management Control and Status Register */


/** \brief CC, Power Management Control and Status Register */


/** \brief D0, Power Management Control and Status Register */


/** \brief D4, Power Management Control and Status Register */


/** \brief D8, Power Management Control and Status Register */


/** \brief DC, Power Management Control and Status Register */


/** \brief E4, Power Management Status Register 0 */


/** \brief E8, Standby and Wake-up Control Register 1 */


/** \brief FC, Emergency Stop Register */


/** \brief 100, Emergency Stop Software set and clear register */


/** \brief 104, Core Die Temperature Sensor Status Register */


/** \brief 108, Core Die Temperature Sensor Limit Register */


/** \brief 120, Trap Disable Register 1 */


/** \brief 124, Trap Status Register */


/** \brief 128, Trap Set Register */


/** \brief 12C, Trap Clear Register */


/** \brief 130, Trap Disable Register 0 */


/** \brief 134, LCL CPU0 and CPU2 Control Register */


/** \brief 138, LCL CPU1 and CPU3 Control Register */


/** \brief 13C, LCL Test Register */


/** \brief 140, Chip Identification Register */


/** \brief 144, Manufacturer Identification Register */


/** \brief 14C, Address Map Control Register */


/** \brief 164, Logic BIST Control 0 Register */


/** \brief 168, Logic BIST Control 1 Register */


/** \brief 16C, Logic BIST Control 2 Register */


/** \brief 170, Logic BIST Control 3 Register */


/** \brief 184, Start-up Memory Register 1 */


/** \brief 188, Start-up Memory Register 2 */


/** \brief 18C, Pad Disable Control Register */


/** \brief 198, Power Management Transition Control and Status Register 0 */


/** \brief 19C, Power Management Transition Control and Status Register 1 */


/** \brief 1A0, Power Management Transition Control and Status Register 2 */


/** \brief 1A4, Power Management Transition Control and Status Register 3 */


/** \brief 1C0, Start-up Memory Register 3 */


/** \brief 1C4, Start-up Memory Register 4 */


/** \brief 1C8, Start-up Memory Register 5 */


/** \brief 1CC, Start-up Memory Register 6 */


/** \brief 1E0, Overlay Enable Register */


/** \brief 1E4, Overlay Control Register */


/** \brief 20C, External Input Filter Register */


/** \brief 210, External Input Channel Register 0 */


/** \brief 214, External Input Channel Register 1 */


/** \brief 218, External Input Channel Register 2 */


/** \brief 21C, External Input Channel Register 3 */


/** \brief 220, External Input Flag Register */


/** \brief 224, Flag Modification Register */


/** \brief 228, Pattern Detection Result Register */


/** \brief 22C, Flag Gating Register 0 */


/** \brief 230, Flag Gating Register 1 */


/** \brief 234, Flag Gating Register 2 */


/** \brief 238, Flag Gating Register 3 */


/** \brief 24C, CPU0 WDT Control Register 0 */

/** Alias (User Manual Name) for SCU_WDTCPU0_CON0.
* To use register names with standard convension, please use SCU_WDTCPU0_CON0.
*/


/** \brief 250, CPU0 WDT Control Register 1 */

/** Alias (User Manual Name) for SCU_WDTCPU0_CON1.
* To use register names with standard convension, please use SCU_WDTCPU0_CON1.
*/


/** \brief 254, CPU0 WDT Status Register */

/** Alias (User Manual Name) for SCU_WDTCPU0_SR.
* To use register names with standard convension, please use SCU_WDTCPU0_SR.
*/


/** \brief 258, CPU1 WDT Control Register 0 */

/** Alias (User Manual Name) for SCU_WDTCPU1_CON0.
* To use register names with standard convension, please use SCU_WDTCPU1_CON0.
*/


/** \brief 25C, CPU1 WDT Control Register 1 */

/** Alias (User Manual Name) for SCU_WDTCPU1_CON1.
* To use register names with standard convension, please use SCU_WDTCPU1_CON1.
*/


/** \brief 260, CPU1 WDT Status Register */

/** Alias (User Manual Name) for SCU_WDTCPU1_SR.
* To use register names with standard convension, please use SCU_WDTCPU1_SR.
*/


/** \brief 264, CPU2 WDT Control Register 0 */

/** Alias (User Manual Name) for SCU_WDTCPU2_CON0.
* To use register names with standard convension, please use SCU_WDTCPU2_CON0.
*/


/** \brief 268, CPU2 WDT Control Register 1 */

/** Alias (User Manual Name) for SCU_WDTCPU2_CON1.
* To use register names with standard convension, please use SCU_WDTCPU2_CON1.
*/


/** \brief 26C, CPU2 WDT Status Register */

/** Alias (User Manual Name) for SCU_WDTCPU2_SR.
* To use register names with standard convension, please use SCU_WDTCPU2_SR.
*/


/** \brief 270, CPU3 WDT Control Register 0 */

/** Alias (User Manual Name) for SCU_WDTCPU3_CON0.
* To use register names with standard convension, please use SCU_WDTCPU3_CON0.
*/


/** \brief 274, CPU3 WDT Control Register 1 */

/** Alias (User Manual Name) for SCU_WDTCPU3_CON1.
* To use register names with standard convension, please use SCU_WDTCPU3_CON1.
*/


/** \brief 278, CPU3 WDT Status Register */

/** Alias (User Manual Name) for SCU_WDTCPU3_SR.
* To use register names with standard convension, please use SCU_WDTCPU3_SR.
*/


/** \brief 29C, ENDINIT Global Control Register 0 */


/** \brief 2A0, ENDINIT Global Control Register 1 */


/** \brief 2A4, ENDINIT Timeout Counter Status Register */


/** \brief 2A8, Safety WDT Control Register 0 */

/** Alias (User Manual Name) for SCU_WDTS_CON0.
* To use register names with standard convension, please use SCU_WDTS_CON0.
*/


/** \brief 2AC, Safety WDT Control Register 1 */

/** Alias (User Manual Name) for SCU_WDTS_CON1.
* To use register names with standard convension, please use SCU_WDTS_CON1.
*/


/** \brief 2B0, Safety WDT Status Register */

/** Alias (User Manual Name) for SCU_WDTS_SR.
* To use register names with standard convension, please use SCU_WDTS_SR.
*/


/** \brief 2B4, Safety ENDINIT Control Register 0 */


/** \brief 2B8, Safety ENDINIT Control Register 1 */


/** \brief 2BC, Safety ENDINIT Timeout Status Register */


/** \brief 3F0, Access Enable Register 11 */


/** \brief 3F4, Access Enable Register 10 */


/** \brief 3F8, Access Enable Register 01 */


/** \brief 3FC, Access Enable Register 00 */



/** \}  */

/******************************************************************************/

/******************************************************************************/


#line 66 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\ee\\..\\Libraries\\iLLD\\TC38A\\Tricore\\Scu\\Std\\IfxScuWdt.h"


#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\ee\\..\\Libraries\\iLLD\\TC38A\\Tricore\\Scu\\Std\\IfxScuWdt.asm.h"
/**
 * \file IfxScuWdt.asm.h
 * \brief SCU  basic functionality
 * \ingroup IfxLld_Scu
 *
 * \version iLLD_1_0_1_15_0_1
 * \copyright Copyright (c) 2019 Infineon Technologies AG. All rights reserved.
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * \defgroup IfxLld_Scu_Std_Wdt_Operative Wdt Operative Functionality
 * \ingroup IfxLld_Scu_Std_Wdt
 */






/** \addtogroup IfxLld_Scu_Std_Wdt_Operative
 * \{ */

/**
 * \brief SCUWDT Inline API utility to Calculte new 14-bit LFSR.
 *
 * This API will Calculte new 14-bit LFSR (Linear Feedback Shift Register) with characteristic polynomial
 * x14+x13+x12+x2+1.
 *
 * \param password Password for which LFSR value to be calculated.
 * \return New LFSR.
 */
static inline uint16 IfxScuWdt_calculateLfsr(uint16 password);
/** \}  */

/**
 * \brief SCUWDT Inline API utility to Calculte new 14-bit LFSR.
 */
















static inline uint16 IfxScuWdt_calculateLfsr(uint16 pwd)
{
    /* *INDENT-OFF* */
    uint32 temp = pwd;
    uint16 res;

    __asm("xor.t  %0,%1,13,%1,12 \n           xor.t  %0,%0,0,%1,11  \n           sh.xor.t %1,%0,0,%1,1  \n           mov d4,#0 \n           mov d5,#14 \n           extr.u %0,%1,e4     \n" : "=&d" (res) : "d" (temp));





    return res;
    /* *INDENT-ON* */
}


































#line 68 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\ee\\..\\Libraries\\iLLD\\TC38A\\Tricore\\Scu\\Std\\IfxScuWdt.h"

#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Cpu\\Std\\IfxCpu_Intrinsics.h"
/**
 * \file IfxCpu_Intrinsics.h
 * \ingroup IfxLld_Cpu_Intrinsics Intrinsics
 *
 * \version iLLD_1_0_1_15_0_1
 * \copyright Copyright (c) 2013 Infineon Technologies AG. All rights reserved.
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * \defgroup IfxLld_Cpu_Intrinsics Intrinsics
 * \ingroup IfxLld_Cpu_Std
 *
 */


/******************************************************************************/

#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Cpu\\Std\\Ifx_Types.h"
/**
 * \file Ifx_Types.h
 * \brief This files defines all types used by the IFX HAL and libraries
 *
 * \version iLLD_1_0_1_15_0_1
 * \copyright Copyright (c) 2018 Infineon Technologies AG. All rights reserved.
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */
























































































































































































#line 48 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Cpu\\Std\\IfxCpu_Intrinsics.h"









#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Cpu\\Std\\IfxCpu_IntrinsicsTasking.h"
/**
 * \file IfxCpu_IntrinsicsTasking.h
 *
 * \version iLLD_1_0_1_15_0_1
 * \copyright Copyright (c) 2019 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * \defgroup IfxLld_Cpu_Intrinsics_Tasking Intrinsics for TASKING compiler
 * \ingroup IfxLld_Cpu_Intrinsics
 *
 */


/******************************************************************************/

#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Cpu\\Std\\Ifx_Types.h"
/**
 * \file Ifx_Types.h
 * \brief This files defines all types used by the IFX HAL and libraries
 *
 * \version iLLD_1_0_1_15_0_1
 * \copyright Copyright (c) 2018 Infineon Technologies AG. All rights reserved.
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */
























































































































































































#line 48 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Cpu\\Std\\IfxCpu_IntrinsicsTasking.h"
/******************************************************************************/
/* *INDENT-OFF* */


/** Function call without return
 */


/** Jump and link
 */
static inline void Ifx__jump_and_link(void (*fun)(void))
{
	__asm("jli %0"::"a"(fun));
}

static inline void Ifx__moveToDataParam0(unsigned int var)
{
	__asm("mov d4, %0"::"d"(var));
}

static inline void Ifx__moveToAddrParam0(const void *var)
{
	__asm("mov.aa a4, %0"::"a"(var));
}

static inline unsigned int Ifx__getDataParamRet(void)
{
	unsigned int var;
	__asm(" mov\t %0, d2":"=d"(var));
	return var;
}

static inline void Ifx__moveToDataParamRet(unsigned int var)
{
	__asm("mov d2, %0"::"d"(var));
}

static inline void Ifx__jumpToFunction(const void *fun)
{
	__asm("\tji %0"::"a"(fun));
}

static inline void Ifx__jumpToFunctionWithLink(const void *fun)
{
	Ifx__jump_and_link((void (*)(void))fun);
}

static inline void Ifx__jumpBackToLink(void)
{
	__asm("ji a11");
}

/** \defgroup IfxLld_Cpu_Intrinsics_Tasking_any_type Cross type arithmetic operation
 *
 * Macro compatible with float, fix point, signed integer and unsigned integer
 *
 * \ingroup IfxLld_Cpu_Intrinsics_Tasking
 * \{
 */




/** \} */

/** \defgroup IfxLld_Cpu_Intrinsics_Tasking_singed_integer Signed integer operation
 * \ingroup IfxLld_Cpu_Intrinsics_Tasking
 * \{
 */

/** \} */

/** \defgroup IfxLld_Cpu_Intrinsics_Tasking_unsinged_integer Unsigned integer operation
 * \ingroup IfxLld_Cpu_Intrinsics_Tasking
 * \{
 */

/** \} */

/** \defgroup IfxLld_Cpu_Intrinsics_Tasking_float Floating point operation
 * \ingroup IfxLld_Cpu_Intrinsics_Tasking
 * \{
 */




















/** \} */
/** \defgroup IfxLld_Cpu_Intrinsics_Tasking_fractional Fractional Arithmetic Support
 The next table provides an overview of intrinsic functions to convert fractional values. Note that the
 TASKING VX-toolset C compiler for TriCore fully supports the fractional type so normally you should not
 need these intrinsic functions (except for __mulfractlong). For compatibility reasons the TASKING C
 compiler does support these functions.
 * \ingroup IfxLld_Cpu_Intrinsics_Tasking
 * \{
 */






/** \} */

/** \defgroup IfxLld_Cpu_Intrinsics_Tasking_insert Insert / Extract Bit-fields and Bits
 * \ingroup IfxLld_Cpu_Intrinsics_Tasking
 * \{
 */









/** \} */

/** \defgroup IfxLld_Cpu_Intrinsics_Tasking_interrupt_handling Interrupt Handling
 The next table provides an overview of the intrinsic functions to read or set interrupt handling.
 * \ingroup IfxLld_Cpu_Intrinsics_Tasking
 * \{
 */




/** \} */

/** \defgroup IfxLld_Cpu_Intrinsics_Tasking_miscellaneous Miscellaneous Intrinsic Functions
 * \ingroup IfxLld_Cpu_Intrinsics_Tasking
 * \{
 */

/** \} */

/** \defgroup IfxLld_Cpu_Intrinsics_Tasking_packed Packed Data Type Support
 The next table provides an overview of the intrinsic functions for initialization of packed data type.
 * \ingroup IfxLld_Cpu_Intrinsics_Tasking
 * \{
 */

/** \} */


/** \defgroup IfxLld_Cpu_Intrinsics_Tasking_register Register Handling
 The next table provides an overview of the intrinsic functions that you can use to access control registers.
 * \ingroup IfxLld_Cpu_Intrinsics_Tasking
 * \{
 */



/** \} */

/** \defgroup IfxLld_Cpu_Intrinsics_Tasking_saturation Saturation Arithmetic Support
 These intrinsics support saturation arithmetic
 * \ingroup IfxLld_Cpu_Intrinsics_Tasking
 * \{
 */









/** \} */

/** \defgroup IfxLld_Cpu_Intrinsics_Tasking_single_assembly Insert Single Assembly Instruction
 The next table provides an overview of the intrinsic functions that you can use to insert a single assembly
 instruction.You can also use inline assembly but these intrinsics provide a shorthand for frequently used
 assembly instructions.
 * \ingroup IfxLld_Cpu_Intrinsics_Tasking
 * \{
 */

static inline void Ifx__nops(void* cnt)
{
    __asm("nop16 \n\t"
          "loop %0,*-2"
          ::"a"(((char*)cnt) - 1));
}



/** Insert a memory barrier
 */











static inline void Ifx__ldmstAsm(volatile void *addr, uint32 mask, uint32 data)
{
    __asm("\tmov d3, %1 \n"
          "\tmov d2, %2 \n"
          "\tldmst [%0],e2"
          ::"a"(addr), "d"(mask), "d"(data):"d2", "d3");

}

/** Convert float to fract
 */
static inline __fract Ifx__float_to_fract(float a)
{
    __fract res;
    __asm("ftoq31  %0,%1,%2":"=d"(res):"d"(a), "d"(0):"memory");
    return res;
}



/** Convert float to sfract
 */
static inline __sfract Ifx__float_to_sfract(float a)
{
    __fract tmp = Ifx__float_to_fract(a);
    return __round16(tmp);
}




static inline void Ifx__stopPerfCounters(void)
{ //__mtcr (CPU_CCTRL, 0);
    __asm(
            "    mov d0,#0\n"
            "    mtcr #0xFC00,d0\n"
            "    isync\n"
            :::"d0");
}

/** \} */

/* FIXME use inline instead of #define */
/* FIXME is it really required to have #define __setareg(areg,val) ___setareg(areg,val) or can __setareg() implemented directly */




/** \brief This function is a implementation of a binary semaphore using compare and swap instruction
 * \param address address of resource.
 * \param value This variable is updated with status of address
 * \param condition if the value of address matches with the value of condition, then swap of value & address occurs.
 *
 */



/** \brief Convert a fixpoint value to float32
 *
 * This function converts a value from a fixpoint format to a float32 format.
 *
 *
 * \param value value to be converted.
 * \param shift position of the fix point. Range = [-256, 255] => (Qx.y format where x = shift+1).
 *
 * \return Returns the converted value in the float32 format.
 *
 */
static inline float32 Ifx__fixpoint_to_float32(__fract value, sint32 shift)
{
    float32 result;

    __asm(
        "   q31tof\t%0, %1, %2  \n"
        : "=d" (result)
        : "d" (value), "d" (shift));
    return result;
}

static inline void* Ifx__getA11(void)
{
    unsigned int *res;
    __asm("mov.aa %0, a11": "=a" (res) : :"a11");
    return res;
}

static inline void Ifx__setStackPointer(void *stackAddr)
{
    __asm("mov.aa a10, %0": : "a" (stackAddr) :"a10");
}

static inline uint32 IfxCpu_calculateCrc32(uint32 *startaddress, uint8 length)
{
    uint32 returnvalue;
    __asm("MOV d0, #0x0"); /* set seed value to 0 */
    for (;length > 0; length--)
    {
        /* calculate the CRC over all data */
        __asm("LD.W d1,[%0]" : : "a" (startaddress));
        __asm("CRC32 d0,d0,d1");
        startaddress++;
    }
    __asm("MOV %0,d0" : "=d" (returnvalue)); /* return result of CRC*/
    return returnvalue;
}

static inline uint32 IfxCpu_getRandomVal(uint32 a, uint32 x, uint32 m)
{
	uint32 result;
    __asm("      mul.u     e14,%1,%2      ; d15 = Eh; d14 = El    \n"
        "        mov       d12,d14        ;   e12 = El            \n"
        "        mov       d13,#0         ;                       \n"
        "        madd.u    e14,e12,d15,#5 ; e14 = El + 5 * d15    \n"
        " 1:     jge.u     d14,%3,2n      ;                       \n"
        "        jz        d15,3n         ;                       \n"
        " 2:     subx      d14,d14,%3     ;  e12=e12-m            \n"
        "        subc      d15,d15,d13    ; d13=d13-0             \n"
        "        loopu     1p             ;                       \n"
        " 3:     mov       %0,d14         ;                       \n"
        : "=d"(result) : "d"(a), "d"(x), "d"(m) : "e14","e12");
    return result;
}

static inline sint32 Ifx__popcnt(sint32 a)
{ 
	sint32 res; 
	__asm("popcnt.w %0,%1":"=d"(res):"d"(a)); 
		return res; 
}


/* Macros for backward compatibility of the intrinsics*/
/******************************************************************************/










































































































































































































































/******************************************************************************/
/* *INDENT-ON* */
/******************************************************************************/

#line 57 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Cpu\\Std\\IfxCpu_Intrinsics.h"
























//______________________________________________________________________________

/** Convert context pointer to address pointer
 * \param[in] cx context pointer
 * \return address pointer
 */
static inline void *__cx_to_addr(uint32 cx)
{
    uint32 seg_nr = __extru(cx, 16, 4);
    return (void *)__insert(seg_nr << 28, cx, 6, 16);
}


/** Convert address pointer to context pointer
 * \param[in] addr address pointer
 * \return context pointer
 */
static inline uint32 __addr_to_cx(void *addr)
{
    uint32 seg_nr, seg_idx;
    seg_nr  = __extru((int)addr, 28, 4) << 16;
    seg_idx = __extru((int)addr, 6, 16);
    return seg_nr | seg_idx;
}


/******************************************************************************/
static inline void __ldmst_c(volatile void *address, unsigned mask, unsigned value)
{
    *(volatile uint32 *)address = (*(volatile uint32 *)address & ~(mask)) | (mask & value);
}


/** 32bit load operation
 */
static inline uint32 __ld32(void *addr)
{
    return *(volatile uint32 *)addr;
}


/** 32bit store operation
 */
static inline void __st32(void *addr, uint32 value)
{
    *(volatile uint32 *)addr = value;
}


/** 64bit load operation
 */
static inline uint64 __ld64(void *addr)
{
    return *(volatile uint64 *)addr;
}


/** 64bit store operation
 */
static inline void __st64(void *addr, uint64 value)
{
    *(volatile uint64 *)addr = value;
}


/** 64bit load operation which returns the lower and upper 32bit word
 */
static inline void __ld64_lu(void *addr, uint32 *valueLower, uint32 *valueUpper)
{
    register uint64 value;
    value       = __ld64(addr);
    *valueLower = (uint32)value;
    *valueUpper = (uint32)(value >> 32);
}


/** 64bit store operation which stores a lower and upper 32bit word
 */
static inline void __st64_lu(void *addr, uint32 valueLower, uint32 valueUpper)
{
    register uint64 value = ((uint64)valueUpper << 32) | valueLower;
    __st64(addr, value);
}


/******************************************************************************/

#line 69 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\ee\\..\\Libraries\\iLLD\\TC38A\\Tricore\\Scu\\Std\\IfxScuWdt.h"

/******************************************************************************/
/*-----------------------------------Macros-----------------------------------*/
/******************************************************************************/

/** \brief Endinit operation Timeout counter
 */


/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/

/** \brief Configuration structure for Scu Watchdog.
 * IfxScuWdt_Config is a type describing configuration structure of CPU and
 * Safety WDT registers defined in IfxScuWdt.h file.
 */
typedef struct
{
    uint16            password;                            /**< \brief password for access to WDTxCON0 reg */
    uint16            reload;                              /**< \brief WDT reload value */
    IfxScu_WDTCON1_IR inputFrequency;                      /**< \brief input frequency of the WDT */
    boolean           disableWatchdog;                     /**< \brief Disable Request Control Bit */
    boolean           enableSmuRestriction;                /**< \brief Unlock Restriction Request Control Bit */
    boolean           enableAutomaticPasswordChange;       /**< \brief Password Auto-sequence Request Bit */
    boolean           enableTimerCheck;                    /**< \brief Counter Check Request Bit */
    boolean           enableTimerCheckTolerance;           /**< \brief Timer Check Tolerance Request */
    boolean           clrInternalResetFlag;                /**< \brief Clear Internal Reset Flag */
    IfxScu_WDTCON1_IR globalEndInitInputFrequency;         /**< \brief input frequency of the global End init WDT */
} IfxScuWdt_Config;

/** \addtogroup IfxLld_Scu_Std_Wdt_Wdt_Configuration
 * \{ */

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief SCUWDT API to initialize WDT configuration structure - Constructor
 *   This API initialize the ScuWdt configuration structure to default values, these default
 *   values are for software specific, not necessarily hardware reset values.
 *   User must use this API call before IfxScuWdt_Init API call
 * \param config ScuWdt configuration structure to be initialized
 * \return None
 */
extern void IfxScuWdt_initConfig(IfxScuWdt_Config *config);

/** \brief SCUWDT API to initialize an instance of WDT Driver which corresponds to CPU WDT Hardware module.
 *
 *   This API initialize the ScuWdt software driver and corresponding CPU WDT hardware module.
 *   User can configure project specific Watchdog password, Watchdog timer period and other settings
 *   with this interface.
 *   API corresponds to one instance of the hardware module.
 *   User must use this API call for each instance of the WDT hardware module used.
 * \param wdt reference to register map of CPU WDT hardware instance
 * \param config ScuWdt configuration structure
 * \return None
 */
extern void IfxScuWdt_initCpuWatchdog(Ifx_SCU_WDTCPU *wdt, const IfxScuWdt_Config *config);

/** \brief SCUWDT API to initialize an instance of WDT Driver which corresponds to Safety WDT Hardware module.
 *
 *   This API initialize the ScuWdt software driver and corresponding safety WDT hardware module.
 *   User can configure project specific Watchdog password, Watchdog timer period and other settings
 *   with this interface.
 *   API corresponds to one instance of the hardware module.
 *   User must use this API call for each instance of the WDT hardware module used.
 * \param wdt reference to register map of Safety WDT hardware instance
 * \param config ScuWdt configuration structure
 * \return None
 */
extern void IfxScuWdt_initSafetyWatchdog(Ifx_SCU_WDTS *wdt, const IfxScuWdt_Config *config);

/** \} */

/** \addtogroup IfxLld_Scu_Std_Wdt_Wdt_Endinit
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief SCUWDT Inline API to Clear ENDINIT bit provided by CPU WDT Hardware module.
 *
 * This Inline API will disable ENDINIT functionality provided by CPU WDT Hardware module.
 * This API is only meant to be used with startup routines where function call is not possible.
 * User need to use this API call before modifying any ENDINIT protected register. User must
 * always set the ENDINIT bit using other API IfxScuWdt_setCpuEndinit. The sequence clear and set
 * ENDINIT shall not be interrupted by another interrupt/call.
 * User need to have the password stored locally in the caller function, (use IfxScuWdt_getCpuWatchdogPassword).
 * \param watchdog pointer to the watchdog register map of CPU WDT hardware instance
 * \param password Existing (Application specific) password for the Watchdog module.
 * \return None
 */
static inline void IfxScuWdt_clearCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password);

/** \brief Clear the Global safety Endinit password (Inline)
 * \param password Existing (Application specific) password for the Watchdog module.
 * \return None
 */
static inline void IfxScuWdt_clearGlobalSafetyEndinitInline(uint16 password);

/** \brief SCUWDT Inline API to Clear ENDINIT bit provided by Safety WDT Hardware module.
 *
 * This API will disable ENDINIT functionality provided by Safety WDT Hardware module.
 * This API is only meant to be used with startup routines where function call is not possible.
 * User need to use this API call before modifying any ENDINIT protected register. User must
 * always set the ENDINIT bit using other API IfxScuWdt_setCpuEndinit. The sequence clear and set
 * ENDINIT shall not be interrupted by another interrupt/call.
 * User need to have the password stored locally in the caller function, (use IfxScuWdt_getSafetyWatchdogPassword).
 * \param password Existing (Application specific) password for the Watchdog module.
 * \return None
 */
static inline void IfxScuWdt_clearSafetyEndinitInline(uint16 password);

/** \brief API to fetch current password of global safety endinit Watchdog module.
 *
 * This API will fetch current global endinit password for Safety WDT Hardware module. password is needed to be passed
 * with most of the WDT APIs. Normally this API can be used to store the password locally in the caller function
 * or store the password globally in a global variable at the application memory.
 * This API is only meant to be used with startup routines where function call is not possible.
 * \return password Existing (Application specific) password for the Watchdog module.
 */
static inline uint16 IfxScuWdt_getGlobalSafetyEndinitPasswordInline(void);

/** \brief SCUWDT Inline API to Set ENDINIT bit provided by CPU WDT Hardware module.
 *
 * This API will enable ENDINIT functionality provided by CPU WDT Hardware module.
 * This API is only meant to be used with startup routines where function call is not possible.
 * User need to use this API call after modifying any ENDINIT protected register.
 * User need to have the password stored locally in the caller function, (use IfxScuWdt_getCpuWatchdogPassword).
 * \param watchdog pointer to the watchdog register map of CPU WDT hardware instance
 * \param password Existing (Application specific) password for the Watchdog module.
 * \return None
 */
static inline void IfxScuWdt_setCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password);

/** \brief Set the Global safety Endinit password (Inline)
 * \param password Existing (Application specific) password for the Watchdog module.
 * \return None
 */
static inline void IfxScuWdt_setGlobalSafetyEndinitInline(uint16 password);

/** \brief SCUWDT Inline API to Set ENDINIT bit provided by Safety WDT Hardware module.
 *
 * This API will enable ENDINIT functionality provided by Safety WDT Hardware module.
 * This API is only meant to be used with startup routines where function call is not possible.
 * User need to use this API call after modifying any ENDINIT protected register.
 * User need to have the password stored locally in the caller function, (use IfxScuWdt_getSafetyWatchdogPassword).
 * \param password Existing (Application specific) password for the Watchdog module.
 * \return None
 */
static inline void IfxScuWdt_setSafetyEndinitInline(uint16 password);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief SCUWDT API to Clear ENDINIT bit provided by CPU WDT Hardware module.
 *
 *   This API will disable ENDINIT functionality provided by CPU WDT Hardware module.
 *   User need to use this API call before modifying any ENDINIT protected register. User must
 *   always set the ENDINIT bit using other API IfxScuWdt_setCpuEndinit. The sequence clear and set
 *   ENDINIT shall not be interrupted by another interrupt/call.
 *   User need to have the password stored locally in the caller function, (use IfxScuWdt_getCpuWatchdogPassword)
 * \param password Existing (Application specific) password for the Watchdog module.
 * \return None
 */
extern void IfxScuWdt_clearCpuEndinit(uint16 password);

/** \brief API to Clear global ENDINIT bit provided by CPU WDT Hardware module.
 *
 * This API will disable ENDINIT functionality provided by CPU WDT Hardware module.
 * This API is only meant to be used with startup routines where function call is not possible.
 * User need to use this API call before modifying any ENDINIT protected register. User must
 * always set the ENDINIT bit using other API IfxScuWdt_setGlobalEndinit. The sequence clear and set
 * ENDINIT shall not be interrupted by another interrupt/call.
 * User need to have the password stored locally in the caller function, (use IfxScuWdt_getGlobalEndinitPassword).
 * \param password Existing (Application specific) password for the Watchdog module.
 * \return None
 */
extern void IfxScuWdt_clearGlobalEndinit(uint16 password);

/** \brief API to Clear global safety ENDINIT bit provided by safety WDT Hardware module.
 *
 * This API will disable ENDINIT functionality provided by Safety WDT Hardware module.
 * This API is only meant to be used with startup routines where function call is not possible.
 * User need to use this API call before modifying any ENDINIT protected register. User must
 * always set the ENDINIT bit using other API IfxScuWdt_setGlobalSafetyEndinit. The sequence clear and set
 * ENDINIT shall not be interrupted by another interrupt/call.
 * User need to have the password stored locally in the caller function, (use IfxScuWdt_getGlobalSafetyEndinitPassword).
 * \param password Existing (Application specific) password for the Watchdog module.
 * \return None
 */
extern void IfxScuWdt_clearGlobalSafetyEndinit(uint16 password);

/** \brief SCUWDT API to Clear ENDINIT bit provided by Safety WDT Hardware module.
 *
 * This API will disable ENDINIT functionality provided by Safety WDT Hardware module.
 * User need to use this API call before modifying any ENDINIT protected register. User must
 * always set the ENDINIT bit using other API IfxScuWdt_setCpuEndinit. The sequence clear and set
 * ENDINIT shall not be interrupted by another interrupt/call.
 * User need to have the password stored locally in the caller function, (use IfxScuWdt_getSafetyWatchdogPassword).
 * \param password Existing (Application specific) password for the Watchdog module.
 * \return None
 */
extern void IfxScuWdt_clearSafetyEndinit(uint16 password);

/** \brief SCUWDT API to set ENDINIT bit provided by CPU WDT Hardware module.
 *
 *   This API will enable ENDINIT functionality provided by CPU WDT Hardware module.
 *   User need to use this API call after modifying any ENDINIT protected register.
 *   User need to have the password stored locally in the caller function, (use IfxScuWdt_getCpuWatchdogPassword)
 * \param password Existing (Application specific) password for the Watchdog module.
 * \return None
 */
extern void IfxScuWdt_setCpuEndinit(uint16 password);

/** \brief API to set global ENDINIT bit provided by CPU WDT Hardware module.
 *
 *   This API will enable ENDINIT functionality provided by CPU WDT Hardware module.
 *   User need to use this API call after modifying any ENDINIT protected register.
 *   User need to have the password stored locally in the caller function, (use IfxScuWdt_getGlobalEndinitPassword)
 * \param password Existing (Application specific) password for the Watchdog module.
 * \return None
 */
extern void IfxScuWdt_setGlobalEndinit(uint16 password);

/** \brief API to set global safety ENDINIT bit provided by safety WDT Hardware module.
 *
 *   This API will enable ENDINIT functionality provided by Safety WDT Hardware module.
 *   User need to use this API call after modifying any ENDINIT protected register.
 *   User need to have the password stored locally in the caller function, (use IfxScuWdt_getGlobalSafetyEndinitPassword)
 * \param password Existing (Application specific) password for the Watchdog module.
 * \return None
 */
extern void IfxScuWdt_setGlobalSafetyEndinit(uint16 password);

/** \brief SCUWDT API to Set ENDINIT bit provided by Safety WDT Hardware module.
 *
 * This API will enable ENDINIT functionality provided by Safety WDT Hardware module.
 * User need to use this API call after modifying any ENDINIT protected register.
 * User need to have the password stored locally in the caller function, (use IfxScuWdt_getSafetyWatchdogPassword).
 * \param password Existing (Application specific) password for the Watchdog module.
 * \return None
 */
extern void IfxScuWdt_setSafetyEndinit(uint16 password);

/** \} */

/** \addtogroup IfxLld_Scu_Std_Wdt_Wdt_Operative
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief SCUWDT Inline API to fetch current password of CPU Watchdog module.
 *
 * This API will fetch current Watchdog password for CPU WDT Hardware module. password is needed to be passed
 * with most of the WDT APIs. Normally this API can be used to store the password locally in the caller function
 * or store the password globally in a global variable at the application memory.
 * This API is only meant to be used with startup routines where function call is not possible.
 * \param watchdog pointer to the watchdog register map of CPU WDT hardware instance
 * \return password Existing (Application specific) password for the Watchdog module.
 */
static inline uint16 IfxScuWdt_getCpuWatchdogPasswordInline(Ifx_SCU_WDTCPU *watchdog);

/** \brief SCUWDT API to fetch current endinit of CPU Watchdog module.
 * \param watchdog pointer to the watchdog register map of CPU WDT hardware instance
 * \return Endinit status for the CPU Watchdog module.
 */
static inline boolean IfxScuWdt_getCpuWatchdogEndInitInline(Ifx_SCU_WDTCPU *watchdog);

/** \brief SCUWDT API to fetch current endinit of Safety/System Watchdog module.
 * \return Endinit status for the Safety Watchdog module.
 */
static inline boolean IfxScuWdt_getSafetyWatchdogEndInit(void);

/** \brief SCUWDT Inline API to fetch current password of Safety Watchdog module.
 *
 * This API will fetch current Watchdog password for Safety WDT Hardware module. password is needed to be passed
 * with most of the WDT APIs. Normally this API can be used to store the password locally in the caller function
 * or store the password globally in a global variable at the application memory.
 * This API is only meant to be used with startup routines where function call is not possible.
 * \return password Existing (Application specific) password for the Watchdog module.
 */
static inline uint16 IfxScuWdt_getSafetyWatchdogPasswordInline(void);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief SCUWDT API to change CPU Watchdog password.
 *
 *   This API will change password to new one for the corresponding to CPU WDT Hardware module.
 *   User need to have the old password stored locally in the caller function, (use IfxScuWdt_getCpuWatchdogPassword).
 * \param password Existing (Application specific) password for the Watchdog module.
 * \param newPassword Application specific new password to be changed for the Watchdog module.
 * \return None
 */
extern void IfxScuWdt_changeCpuWatchdogPassword(uint16 password, uint16 newPassword);

/** \brief SCUWDT API to change CPU Watchdog timer reload value.
 *
 * This API will change Watchdog timer reload value to new one for CPU WDT Hardware module.
 * The Watchdog timers will be reloaded with this value after every serice of Watchdog.
 * User need to have the password stored locally in the caller function, (use IfxScuWdt_getCpuWatchdogPassword).
 * \param password Existing (Application specific) password for the Watchdog module.
 * \param reload Reload value for the timer.
 * \return None
 */
extern void IfxScuWdt_changeCpuWatchdogReload(uint16 password, uint16 reload);

/** \brief API to change global endinit password.
 *
 *   This API will change password to new one for the corresponding to CPU WDT Hardware module.
 *   User need to have the old password stored locally in the caller function, (use IfxScuWdt_getGlobalEndinitPassword).
 * \param password Existing (Application specific) password for the Watchdog module.
 * \param newPassword Application specific new password to be changed for the Watchdog module.
 * \return None
 */
extern void IfxScuWdt_changeGlobalEndinitPassword(uint16 password, uint16 newPassword);

/** \brief API to change global safety endinit password.
 *
 *   This API will change password to new one for the corresponding to Safety WDT Hardware module.
 *   User need to have the old password stored locally in the caller function, (use IfxScuWdt_getGlobalSafetyEndinitPassword).
 * \param password Existing (Application specific) password for the Watchdog module.
 * \param newPassword Application specific new password to be changed for the Watchdog module.
 * \return None
 */
extern void IfxScuWdt_changeGlobalSafetyEndinitPassword(uint16 password, uint16 newPassword);

/** \brief SCUWDT API to change Safety Watchdog password.
 *
 * This API will change password to new one for the corresponding to Safety WDT Hardware module.
 * User need to have the old password stored locally in the caller function, (use IfxScuWdt_getSafetyWatchdogPassword).
 * \param password Existing (Application specific) password for the Watchdog module.
 * \param newPassword Application specific new password to be changed for the Watchdog module.
 * \return None
 */
extern void IfxScuWdt_changeSafetyWatchdogPassword(uint16 password, uint16 newPassword);

/** \brief SCUWDT API to change Safety Watchdog timer reload value.
 *
 * This API will change Watchdog timer reload value to new one for Safety WDT Hardware module.
 * The Watchdog timers will be reloaded with this value after every serice of Watchdog.
 * User need to have the password stored locally in the caller function, (use IfxScuWdt_getSafetyWatchdogPassword).
 * \param password Existing (Application specific) password for the Watchdog module.
 * \param reload Reload value for the timer.
 * \return None
 */
extern void IfxScuWdt_changeSafetyWatchdogReload(uint16 password, uint16 reload);

/** \brief SCUWDT API to disable CPU Watchdog functionality.
 *
 * This API will disable Watchdog functionality of CPU WDT Hardware module. The Watchdog timers will stop counting
 * after this API call.
 * User need to have the password stored locally in the caller function, (use IfxScuWdt_getCpuWatchdogPassword).
 * \param password Existing (Application specific) password for the Watchdog module.
 * \return None
 */
extern void IfxScuWdt_disableCpuWatchdog(uint16 password);

/** \brief SCUWDT API to disable Safety Watchdog functionality.
 *
 * This API will disable Watchdog functionality of Safety WDT Hardware module. The Watchdog timers will stop counting
 * after this API call.
 * User need to have the password stored locally in the caller function, (use IfxScuWdt_getSafetyWatchdogPassword).
 * \param password Existing (Application specific) password for the Watchdog module.
 * \return None
 */
extern void IfxScuWdt_disableSafetyWatchdog(uint16 password);

/** \brief SCUWDT API to enable CPU Watchdog functionality.
 *
 *   This API will enable Watchdog functionality of CPU WDT Hardware module. The Watchdog timers need to be serviced
 *   periodically after this API call.
 *   User need to have the password stored locally in the caller function, (use IfxScuWdt_getCpuWatchdogPassword).
 * \param password Existing (Application specific) password for the Watchdog module.
 * \return None
 */
extern void IfxScuWdt_enableCpuWatchdog(uint16 password);

/** \brief SCUWDT API to enable Safety Watchdog functionality.
 *
 * This API will enable Watchdog functionality of Safety WDT Hardware module. The Watchdog timers need to be serviced
 * periodically after this API call.
 * User need to have the password stored locally in the caller function, (use IfxScuWdt_getSafetyWatchdogPassword).
 * \param password Existing (Application specific) password for the Watchdog module.
 * \return None
 */
extern void IfxScuWdt_enableSafetyWatchdog(uint16 password);

/** \brief SCUWDT API to fetch current password of CPU Watchdog module.
 *
 * This API will fetch current Watchdog password for CPU WDT Hardware module. password is needed to be passed
 * with most of the WDT APIs. Normally this API can be used to store the password locally in the caller function
 * or store the password globally in a global variable at the application memory.
 * \return password Existing (Application specific) password for the Watchdog module.
 */
extern uint16 IfxScuWdt_getCpuWatchdogPassword(void);

/** \brief SCUWDT API to fetch current endinit of CPU Watchdog module.
 * \return Endinit status for the CPU Watchdog module.
 */
extern boolean IfxScuWdt_getCpuWatchdogEndInit(void);

/** \brief API to fetch current password of global endinit Watchdog module.
 *
 * This API will fetch current global endinit password for CPU WDT Hardware module. password is needed to be passed
 * with most of the WDT APIs. Normally this API can be used to store the password locally in the caller function
 * or store the password globally in a global variable at the application memory.
 * This API is only meant to be used with startup routines where function call is not possible.
 * \return password Existing (Application specific) password for the Watchdog module.
 */
extern uint16 IfxScuWdt_getGlobalEndinitPassword(void);

/** \brief API to fetch current password of global safety endinit Watchdog module.
 *
 * This API will fetch current global endinit password for Safety WDT Hardware module. password is needed to be passed
 * with most of the WDT APIs. Normally this API can be used to store the password locally in the caller function
 * or store the password globally in a global variable at the application memory.
 * This API is only meant to be used with startup routines where function call is not possible.
 * \return password Existing (Application specific) password for the Watchdog module.
 */
extern uint16 IfxScuWdt_getGlobalSafetyEndinitPassword(void);

/** \brief SCUWDT API to fetch current password of Safety Watchdog module.
 *
 * This API will fetch current Watchdog password for Safety WDT Hardware module. password is needed to be passed
 * with most of the WDT APIs. Normally this API can be used to store the password locally in the caller function
 * or store the password globally in a global variable at the application memory.
 * \return password Existing (Application specific) password for the Watchdog module.
 */
extern uint16 IfxScuWdt_getSafetyWatchdogPassword(void);

/** \brief SCUWDT API to service CPU Watchdog functionality.
 *
 *   This API will service Watchdog functionality corresponding to CPU WDT Hardware module.
 *   User need to use this API call periodically. This API results in reloading of the Watchdog Timer.
 *   User need to have the password stored locally in the caller function, (use IfxScuWdt_getCpuWatchdogPassword).
 * \param password Existing (Application specific) password for the Watchdog module.
 * \return None
 */
extern void IfxScuWdt_serviceCpuWatchdog(uint16 password);

/** \brief SCUWDT API to service Safety Watchdog functionality.
 *
 * This API will service Watchdog functionality corresponding to Safety WDT Hardware module.
 * User need to use this API call periodically. This API results in reloading of the Watchdog Timer.
 * User need to have the password stored locally in the caller function, (use IfxScuWdt_getSafetyWatchdogPassword).
 * \param password Existing (Application specific) password for the Watchdog module.
 * \return None
 */
extern void IfxScuWdt_serviceSafetyWatchdog(uint16 password);

/** \brief SCUWDT API to fetch current status of CPU Watchdog module.
 * \return status
 */
extern uint8 IfxScuWdt_getCpuWatchdogStatus(void);

/** \} */

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Enables the watchdog functionality with debugger connected,\n
 * debug interface will also be enabled, if not enabled already.
 * \return Status, Success = 0, Failure = 1.
 */
extern boolean IfxScuWdt_enableWatchdogWithDebugger(void);

/******************************************************************************/
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

static inline void IfxScuWdt_clearCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << (0u)) |
                           (0 << (1u)) |
                           (password << (2u)) |
                           (watchdog->CON0.B.REL << (16u));
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (0 << (0u)) |
                       (1 << (1u)) |
                       (password << (2u)) |
                       (watchdog->CON0.B.REL << (16u));

    /* read back ENDINIT and wait until it has been cleared */
    while (watchdog->CON0.B.ENDINIT == 1)
    {}
}


static inline void IfxScuWdt_clearGlobalSafetyEndinitInline(uint16 password)
{
    /* Clear EndInit Watch-dog*/
    ((*(Ifx_SCU*)0xF0036000u)).SEICON0.U = (0xFFFCU << 16U) | (password << (2u));

    while (((*(Ifx_SCU*)0xF0036000u)).SEICON0.B.ENDINIT == 1)
    {}
}


static inline void IfxScuWdt_clearSafetyEndinitInline(uint16 password)
{
    if ((*(volatile Ifx_SCU_WDTS_CON0*)0xF00362A8u).B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        (*(volatile Ifx_SCU_WDTS_CON0*)0xF00362A8u).U = (1 << (0u)) |
                          (0 << (1u)) |
                          (password << (2u)) |
                          ((*(volatile Ifx_SCU_WDTS_CON0*)0xF00362A8u).B.REL << (16u));
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    (*(volatile Ifx_SCU_WDTS_CON0*)0xF00362A8u).U = (0 << (0u)) |
                      (1 << (1u)) |
                      (password << (2u)) |
                      ((*(volatile Ifx_SCU_WDTS_CON0*)0xF00362A8u).B.REL << (16u));

    /* read back ENDINIT and wait until it has been cleared */
    while ((*(volatile Ifx_SCU_WDTS_CON0*)0xF00362A8u).B.ENDINIT == 1)
    {}
}


static inline uint16 IfxScuWdt_getCpuWatchdogPasswordInline(Ifx_SCU_WDTCPU *watchdog)
{
    uint16 password;

    /* Read Password from CON0 register
     * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
     * to toggle them before returning password */
    password  = watchdog->CON0.B.PW;
    password ^= 0x003F;

    return password;
}


static inline boolean IfxScuWdt_getCpuWatchdogEndInitInline(Ifx_SCU_WDTCPU *watchdog)
{
    return (boolean)watchdog->CON0.B.ENDINIT;
}


static inline uint16 IfxScuWdt_getGlobalSafetyEndinitPasswordInline(void)
{
    /* Read Password from CON0 register
     * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
     * to toggle them before returning password */

    uint16 password = ((*(Ifx_SCU*)0xF0036000u)).SEICON0.B.EPW ^ 0x003F;
    return password;
}


static inline boolean IfxScuWdt_getSafetyWatchdogEndInit(void)
{
    return (boolean)((*(Ifx_SCU*)0xF0036000u)).WDTS.CON0.B.ENDINIT;
}


static inline uint16 IfxScuWdt_getSafetyWatchdogPasswordInline(void)
{
    uint16        password;
    Ifx_SCU_WDTS *watchdog = &((*(Ifx_SCU*)0xF0036000u)).WDTS;

    /* Read Password from Safety WDT CON0 register
     * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
     * to toggle them before returning password */
    password  = watchdog->CON0.B.PW;
    password ^= 0x003F;

    return password;
}


static inline void IfxScuWdt_setCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << (0u)) |
                           (0 << (1u)) |
                           (password << (2u)) |
                           (watchdog->CON0.B.REL << (16u));
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << (0u)) |
                       (1 << (1u)) |
                       (password << (2u)) |
                       (watchdog->CON0.B.REL << (16u));

    /* read back ENDINIT and wait until it has been set */
    while (watchdog->CON0.B.ENDINIT == 0)
    {}
}


static inline void IfxScuWdt_setGlobalSafetyEndinitInline(uint16 password)
{
    /* Set EndInit Watch-dog*/
    ((*(Ifx_SCU*)0xF0036000u)).SEICON0.U = (0xFFFCU << 16U) | (password << (2u)) | (1 << (1u));

    while (((*(Ifx_SCU*)0xF0036000u)).SEICON0.B.ENDINIT == 0)
    {}
}


static inline void IfxScuWdt_setSafetyEndinitInline(uint16 password)
{
    if ((*(volatile Ifx_SCU_WDTS_CON0*)0xF00362A8u).B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        (*(volatile Ifx_SCU_WDTS_CON0*)0xF00362A8u).U = (1 << (0u)) |
                          (0 << (1u)) |
                          (password << (2u)) |
                          ((*(volatile Ifx_SCU_WDTS_CON0*)0xF00362A8u).B.REL << (16u));
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    (*(volatile Ifx_SCU_WDTS_CON0*)0xF00362A8u).U = (1 << (0u)) |
                      (1 << (1u)) |
                      (password << (2u)) |
                      ((*(volatile Ifx_SCU_WDTS_CON0*)0xF00362A8u).B.REL << (16u));

    /* read back ENDINIT and wait until it has been cleared */
    while ((*(volatile Ifx_SCU_WDTS_CON0*)0xF00362A8u).B.ENDINIT == 0)
    {}
}



#line 50 "D:/RTOS_PROJEKT/erica/aurix_workspace/can_erika/ee/../Libraries/iLLD/TC38A/Tricore/Scu/Std/IfxScuWdt.c"

#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Cpu\\Std\\IfxCpu.h"
/**
 * \file IfxCpu.h
 * \brief CPU  basic functionality
 * \ingroup IfxLld_Cpu
 *
 * \version iLLD_1_0_1_15_0_1
 * \copyright Copyright (c) 2021 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 *
 * \defgroup IfxLld_Cpu_Std_Core Cpu Core Functions
 * \ingroup IfxLld_Cpu_Std
 * \defgroup IfxLld_Cpu_Std_Interrupt Interrupt Utility Functions
 * \ingroup IfxLld_Cpu_Std
 * \defgroup IfxLld_Cpu_Std_Cache Cache Management Functions
 * \ingroup IfxLld_Cpu_Std
 * \defgroup IfxLld_Cpu_Std_PerformanceCounter Performance Counter Functions
 * \ingroup IfxLld_Cpu_Std
 * \defgroup IfxLld_Cpu_Std_Synchronization Synchronization Functions
 * \ingroup IfxLld_Cpu_Std
 * \defgroup IfxLld_Cpu_Std_Utility Cpu Utility Functions
 * \ingroup IfxLld_Cpu_Std
 * \defgroup IfxLld_Cpu_Std_Enum Enumerations
 * \ingroup IfxLld_Cpu_Std
 * \defgroup IfxLld_Cpu_Std_DataStructures Data Structures
 * \ingroup IfxLld_Cpu_Std
 */




/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/


#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\_Impl\\IfxCpu_cfg.h"
/**
 * \file IfxCpu_cfg.h
 * \brief CPU on-chip implementation data
 * \ingroup IfxLld_Cpu
 *
 * \version iLLD_1_0_1_15_0_1
 * \copyright Copyright (c) 2018 Infineon Technologies AG. All rights reserved.
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * \defgroup IfxLld_Cpu CPU
 * \ingroup IfxLld
 * \defgroup IfxLld_Cpu_Impl Implementation
 * \ingroup IfxLld_Cpu
 * \defgroup IfxLld_Cpu_Std Standard Driver
 * \ingroup IfxLld_Cpu
 */




/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/


#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Cpu\\Std\\IfxCpu_Intrinsics.h"
/**
 * \file IfxCpu_Intrinsics.h
 * \ingroup IfxLld_Cpu_Intrinsics Intrinsics
 *
 * \version iLLD_1_0_1_15_0_1
 * \copyright Copyright (c) 2013 Infineon Technologies AG. All rights reserved.
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * \defgroup IfxLld_Cpu_Intrinsics Intrinsics
 * \ingroup IfxLld_Cpu_Std
 *
 */




























































































































#line 57 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\_Impl\\IfxCpu_cfg.h"

#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\Infra\\Sfr\\TC38A\\_Reg\\IfxCpu_reg.h"
/**
 * \file IfxCpu_reg.h
 * \brief
 * \copyright Copyright (c) 2020 Infineon Technologies AG. All rights reserved.
 *
 *
 * Version: TC38XA_UM_V1.5.0
 * Specification: TC3xx User Manual V1.5.0
 * MAY BE CHANGED BY USER [yes/no]: No
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * \defgroup IfxSfr_Cpu_Registers_Cfg Cpu address
 * \ingroup IfxSfr_Cpu_Registers
 * 
 * \defgroup IfxSfr_Cpu_Registers_Cfg_BaseAddress Base address
 * \ingroup IfxSfr_Cpu_Registers_Cfg
 *
 * \defgroup IfxSfr_Cpu_Registers_Cfg_Cpu0 2-CPU0
 * \ingroup IfxSfr_Cpu_Registers_Cfg
 *
 * \defgroup IfxSfr_Cpu_Registers_Cfg_Cpu1 2-CPU1
 * \ingroup IfxSfr_Cpu_Registers_Cfg
 *
 * \defgroup IfxSfr_Cpu_Registers_Cfg_Cpu2 2-CPU2
 * \ingroup IfxSfr_Cpu_Registers_Cfg
 *
 * \defgroup IfxSfr_Cpu_Registers_Cfg_Cpu3 2-CPU3
 * \ingroup IfxSfr_Cpu_Registers_Cfg
 *
 *
 */


/******************************************************************************/

#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\Infra\\Sfr\\TC38A\\_Reg\\IfxCpu_regdef.h"
/**
 * \file IfxCpu_regdef.h
 * \brief
 * \copyright Copyright (c) 2020 Infineon Technologies AG. All rights reserved.
 *
 *
 * Version: TC38XA_UM_V1.5.0
 * Specification: TC3xx User Manual V1.5.0
 * MAY BE CHANGED BY USER [yes/no]: No
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * \defgroup IfxSfr_Cpu_Registers Cpu Registers
 * \ingroup IfxSfr
 * 
 * \defgroup IfxSfr_Cpu_Registers_Bitfields Bitfields
 * \ingroup IfxSfr_Cpu_Registers
 * 
 * \defgroup IfxSfr_Cpu_Registers_union Register unions
 * \ingroup IfxSfr_Cpu_Registers
 * 
 * \defgroup IfxSfr_Cpu_Registers_struct Memory map
 * \ingroup IfxSfr_Cpu_Registers
 */


/******************************************************************************/

/******************************************************************************/

/******************************************************************************/

/******************************************************************************/


/** \addtogroup IfxSfr_Cpu_Registers_Bitfields
 * \{  */
/** \brief CPUx Address General Purpose Register ${y} */
typedef struct _Ifx_CPU_A_Bits
{
    unsigned __sfrbit32 ADDR:32;         /**< \brief [31:0] Address Register - ADDR (rw) */
} Ifx_CPU_A_Bits;

/** \brief CPUx Base Interrupt Vector Table Pointer */
typedef struct _Ifx_CPU_BIV_Bits
{
    unsigned __sfrbit32 VSS:1;           /**< \brief [0:0] Vector Spacing Select - VSS (rw) */
    unsigned __sfrbit32 BIV:31;          /**< \brief [31:1] Base Address of Interrupt Vector Table - BIV (rw) */
} Ifx_CPU_BIV_Bits;

/** \brief CPUx Overlay Mask Register ${i} */
typedef struct _Ifx_CPU_BLK_OMASK_Bits
{
    unsigned __sfrbit32 reserved_0:5;    /**< \brief [4:0] \internal Reserved */
    unsigned __sfrbit32 OMASK:12;        /**< \brief [16:5] Overlay Address Mask - OMASK (rw) */
    unsigned __sfrbit32 ONE:11;          /**< \brief [27:17] Fixed "1" Values - ONE (r) */
    unsigned __sfrbit32 reserved_28:4;    /**< \brief [31:28] \internal Reserved */
} Ifx_CPU_BLK_OMASK_Bits;

/** \brief CPUx Overlay Target Address Register ${i} */
typedef struct _Ifx_CPU_BLK_OTAR_Bits
{
    unsigned __sfrbit32 reserved_0:5;    /**< \brief [4:0] \internal Reserved */
    unsigned __sfrbit32 TBASE:23;        /**< \brief [27:5] Target Base - TBASE (rw) */
    unsigned __sfrbit32 reserved_28:4;    /**< \brief [31:28] \internal Reserved */
} Ifx_CPU_BLK_OTAR_Bits;

/** \brief CPUx Redirected Address Base Register ${i} */
typedef struct _Ifx_CPU_BLK_RABR_Bits
{
    unsigned __sfrbit32 reserved_0:5;    /**< \brief [4:0] \internal Reserved */
    unsigned __sfrbit32 OBASE:17;        /**< \brief [21:5] Overlay Block Base Address - OBASE (rw) */
    unsigned __sfrbit32 reserved_22:2;    /**< \brief [23:22] \internal Reserved */
    unsigned __sfrbit32 OMEM:4;          /**< \brief [27:24] Overlay Memory Select - OMEM (rw) */
    unsigned __sfrbit32 reserved_28:3;    /**< \brief [30:28] \internal Reserved */
    unsigned __sfrbit32 OVEN:1;          /**< \brief [31:31] Overlay Enabled - OVEN (rwh) */
} Ifx_CPU_BLK_RABR_Bits;

/** \brief CPUx Base Trap Vector Table Pointer */
typedef struct _Ifx_CPU_BTV_Bits
{
    unsigned __sfrbit32 reserved_0:1;    /**< \brief [0:0] \internal Reserved */
    unsigned __sfrbit32 BTV:31;          /**< \brief [31:1] Base Address of Trap Vector Table - BTV (rw) */
} Ifx_CPU_BTV_Bits;

/** \brief CPUx CPU Clock Cycle Count */
typedef struct _Ifx_CPU_CCNT_Bits
{
    unsigned __sfrbit32 COUNTVALUE:31;    /**< \brief [30:0] Count Value - CountValue (rwh) */
    unsigned __sfrbit32 SOVF:1;          /**< \brief [31:31] Sticky Overflow Bit - SOvf (rwh) */
} Ifx_CPU_CCNT_Bits;

/** \brief CPUx Counter Control */
typedef struct _Ifx_CPU_CCTRL_Bits
{
    unsigned __sfrbit32 CM:1;            /**< \brief [0:0] Counter Mode - CM (rw) */
    unsigned __sfrbit32 CE:1;            /**< \brief [1:1] Count Enable - CE (rw) */
    unsigned __sfrbit32 M1:3;            /**< \brief [4:2] M1CNT Configuration - M1 (rw) */
    unsigned __sfrbit32 M2:3;            /**< \brief [7:5] M2CNT Configuration - M2 (rw) */
    unsigned __sfrbit32 M3:3;            /**< \brief [10:8] M3CNT Configuration - M3 (rw) */
    unsigned __sfrbit32 reserved_11:21;    /**< \brief [31:11] \internal Reserved */
} Ifx_CPU_CCTRL_Bits;

/** \brief CPUx Compatibility Control Register */
typedef struct _Ifx_CPU_COMPAT_Bits
{
    unsigned __sfrbit32 reserved_0:3;    /**< \brief [2:0] \internal Reserved */
    unsigned __sfrbit32 RM:1;            /**< \brief [3:3] Rounding Mode Compatibility - RM (rw) */
    unsigned __sfrbit32 SP:1;            /**< \brief [4:4] SYSCON Safety Protection Mode Compatibility - SP (rw) */
    unsigned __sfrbit32 reserved_5:27;    /**< \brief [31:5] \internal Reserved */
} Ifx_CPU_COMPAT_Bits;

/** \brief CPUx Core Identification Register */
typedef struct _Ifx_CPU_CORE_ID_Bits
{
    unsigned __sfrbit32 CORE_ID:3;       /**< \brief [2:0] Core Identification Number - CORE_ID (r) */
    unsigned __sfrbit32 reserved_3:29;    /**< \brief [31:3] \internal Reserved */
} Ifx_CPU_CORE_ID_Bits;

/** \brief CPUx Code Protection Range ${y} Lower Bound Register */
typedef struct _Ifx_CPU_CPR_L_Bits
{
    unsigned __sfrbit32 reserved_0:5;    /**< \brief [4:0] \internal Reserved */
    unsigned __sfrbit32 LOWBND:27;       /**< \brief [31:5] CPRy Lower Boundary Address - LOWBND (rw) */
} Ifx_CPU_CPR_L_Bits;

/** \brief CPUx Code Protection Range ${y} Upper Bound Register */
typedef struct _Ifx_CPU_CPR_U_Bits
{
    unsigned __sfrbit32 reserved_0:5;    /**< \brief [4:0] \internal Reserved */
    unsigned __sfrbit32 UPPBND:27;       /**< \brief [31:5] CPR0_m Upper Boundary Address - UPPBND (rw) */
} Ifx_CPU_CPR_U_Bits;

/** \brief CPUx Identification Register TC1.6.2P */
typedef struct _Ifx_CPU_CPU_ID_Bits
{
    unsigned __sfrbit32 MOD_REV:8;       /**< \brief [7:0] Revision Number - MOD_REV (r) */
    unsigned __sfrbit32 MOD_32B:8;       /**< \brief [15:8] 32-Bit Module Enable - MOD_32B (r) */
    unsigned __sfrbit32 MOD:16;          /**< \brief [31:16] Module Identification Number - MOD (r) */
} Ifx_CPU_CPU_ID_Bits;

/** \brief  */
typedef struct _Ifx_CPU_CPXE_Bits
{
    unsigned __sfrbit32 XE_N:10;         /**< \brief [9:0] Execute Enable Range select - XE[n] (rw) */
    unsigned __sfrbit32 reserved_10:22;    /**< \brief [31:10] \internal Reserved */
} Ifx_CPU_CPXE_Bits;

/** \brief CPUx Core Register Access Event */
typedef struct _Ifx_CPU_CREVT_Bits
{
    unsigned __sfrbit32 EVTA:3;          /**< \brief [2:0] Event Associated - EVTA (rw) */
    unsigned __sfrbit32 BBM:1;           /**< \brief [3:3] Break Before Make (BBM) or Break After Make (BAM) Selection - BBM (rw) */
    unsigned __sfrbit32 BOD:1;           /**< \brief [4:4] Breakout Disable - BOD (rw) */
    unsigned __sfrbit32 SUSP:1;          /**< \brief [5:5] CDC Suspend-Out Signal State - SUSP (rw) */
    unsigned __sfrbit32 CNT:2;           /**< \brief [7:6] Counter - CNT (rw) */
    unsigned __sfrbit32 reserved_8:24;    /**< \brief [31:8] \internal Reserved */
} Ifx_CPU_CREVT_Bits;

/** \brief CPUx Customer ID register */
typedef struct _Ifx_CPU_CUS_ID_Bits
{
    unsigned __sfrbit32 CID:3;           /**< \brief [2:0] Customer ID - CID (r) */
    unsigned __sfrbit32 reserved_3:29;    /**< \brief [31:3] \internal Reserved */
} Ifx_CPU_CUS_ID_Bits;

/** \brief CPUx Data General Purpose Register ${y} */
typedef struct _Ifx_CPU_D_Bits
{
    unsigned __sfrbit32 DATA:32;         /**< \brief [31:0] Data Register - DATA (rw) */
} Ifx_CPU_D_Bits;

/** \brief CPUx Data Asynchronous Trap Register */
typedef struct _Ifx_CPU_DATR_Bits
{
    unsigned __sfrbit32 reserved_0:3;    /**< \brief [2:0] \internal Reserved */
    unsigned __sfrbit32 SBE:1;           /**< \brief [3:3] Store Bus Error - SBE (rwh) */
    unsigned __sfrbit32 reserved_4:5;    /**< \brief [8:4] \internal Reserved */
    unsigned __sfrbit32 CWE:1;           /**< \brief [9:9] Cache Writeback Error - CWE (rwh) */
    unsigned __sfrbit32 CFE:1;           /**< \brief [10:10] Cache Flush Error - CFE (rwh) */
    unsigned __sfrbit32 reserved_11:3;    /**< \brief [13:11] \internal Reserved */
    unsigned __sfrbit32 SOE:1;           /**< \brief [14:14] Store Overlay Error - SOE (rwh) */
    unsigned __sfrbit32 reserved_15:1;    /**< \brief [15:15] \internal Reserved */
    unsigned __sfrbit32 reserved_16:16;    /**< \brief [31:16] \internal Reserved */
} Ifx_CPU_DATR_Bits;

/** \brief CPUx Debug Status Register */
typedef struct _Ifx_CPU_DBGSR_Bits
{
    unsigned __sfrbit32 DE:1;            /**< \brief [0:0] Debug Enable - DE (rh) */
    unsigned __sfrbit32 HALT:2;          /**< \brief [2:1] CPU Halt Request / Status Field - HALT (rwh) */
    unsigned __sfrbit32 SIH:1;           /**< \brief [3:3] Suspend-in Halt - SIH (rh) */
    unsigned __sfrbit32 SUSP:1;          /**< \brief [4:4] Current State of the Core Suspend-Out Signal - SUSP (rwh) */
    unsigned __sfrbit32 reserved_5:1;    /**< \brief [5:5] \internal Reserved */
    unsigned __sfrbit32 PREVSUSP:1;      /**< \brief [6:6] Previous State of Core Suspend-Out Signal - PREVSUSP (rh) */
    unsigned __sfrbit32 PEVT:1;          /**< \brief [7:7] Posted Event - PEVT (rwh) */
    unsigned __sfrbit32 EVTSRC:5;        /**< \brief [12:8] Event Source - EVTSRC (rh) */
    unsigned __sfrbit32 reserved_13:19;    /**< \brief [31:13] \internal Reserved */
} Ifx_CPU_DBGSR_Bits;

/** \brief CPUx Debug Trap Control Register */
typedef struct _Ifx_CPU_DBGTCR_Bits
{
    unsigned __sfrbit32 DTA:1;           /**< \brief [0:0] Debug Trap Active Bit - DTA (rwh) */
    unsigned __sfrbit32 reserved_1:31;    /**< \brief [31:1] \internal Reserved */
} Ifx_CPU_DBGTCR_Bits;

/** \brief CPUx Data Memory Control Register */
typedef struct _Ifx_CPU_DCON0_Bits
{
    unsigned __sfrbit32 reserved_0:1;    /**< \brief [0:0] \internal Reserved */
    unsigned __sfrbit32 DCBYP:1;         /**< \brief [1:1] Data Cache Bypass - DCBYP (rw) */
    unsigned __sfrbit32 reserved_2:30;    /**< \brief [31:2] \internal Reserved */
} Ifx_CPU_DCON0_Bits;

/** \brief CPUx Data Control Register 2 */
typedef struct _Ifx_CPU_DCON2_Bits
{
    unsigned __sfrbit32 DCACHE_SZE:16;    /**< \brief [15:0] Data Cache Size - DCACHE_SZE (r) */
    unsigned __sfrbit32 DSCRATCH_SZE:16;    /**< \brief [31:16] Data Scratch Size - DSCRATCH_SZE (r) */
} Ifx_CPU_DCON2_Bits;

/** \brief CPUx Debug Context Save Area Pointer */
typedef struct _Ifx_CPU_DCX_Bits
{
    unsigned __sfrbit32 reserved_0:6;    /**< \brief [5:0] \internal Reserved */
    unsigned __sfrbit32 DCXVALUE:26;     /**< \brief [31:6] Debug Context Save Area Pointer - DCXValue (rw) */
} Ifx_CPU_DCX_Bits;

/** \brief CPUx Data Error Address Register */
typedef struct _Ifx_CPU_DEADD_Bits
{
    unsigned __sfrbit32 ERROR_ADDRESS:32;    /**< \brief [31:0] Error Address - ERROR_ADDRESS (rh) */
} Ifx_CPU_DEADD_Bits;

/** \brief CPUx Data Integrity Error Address Register */
typedef struct _Ifx_CPU_DIEAR_Bits
{
    unsigned __sfrbit32 TA:32;           /**< \brief [31:0] Transaction Address - TA (rh) */
} Ifx_CPU_DIEAR_Bits;

/** \brief CPUx Data Integrity Error Trap Register */
typedef struct _Ifx_CPU_DIETR_Bits
{
    unsigned __sfrbit32 IED:1;           /**< \brief [0:0] Integrity Error Detected - IED (rwh) */
    unsigned __sfrbit32 IE_T:1;          /**< \brief [1:1] Integrity Error - Tag Memory - IE_T (rh) */
    unsigned __sfrbit32 IE_C:1;          /**< \brief [2:2] Integrity Error - Cache Memory - IE_C (rh) */
    unsigned __sfrbit32 IE_S:1;          /**< \brief [3:3] Integrity Error - Scratchpad Memory - IE_S (rh) */
    unsigned __sfrbit32 IE_BI:1;         /**< \brief [4:4] Integrity Error - Bus Interface - IE_BI (rh) */
    unsigned __sfrbit32 E_INFO:6;        /**< \brief [10:5] Error Information - E_INFO (rh) */
    unsigned __sfrbit32 IE_UNC:1;        /**< \brief [11:11] Dual Bit Error Detected - IE_UNC (rh) */
    unsigned __sfrbit32 IE_SP:1;         /**< \brief [12:12] Safety Protection Error Detected - IE_SP (rh) */
    unsigned __sfrbit32 IE_BS:1;         /**< \brief [13:13] Bus Slave Access Indicator - IE_BS (rh) */
    unsigned __sfrbit32 IE_DLMU:1;       /**< \brief [14:14] Integrity Error - DLMU - IE_DLMU (rh) */
    unsigned __sfrbit32 IE_LPB:1;        /**< \brief [15:15] Integrity Error - Local Pflash Bank - IE_LPB (rh) */
    unsigned __sfrbit32 IE_MTMV:1;       /**< \brief [16:16] Memory Test Mode Violation detected - IE_MTMV (rh) */
    unsigned __sfrbit32 reserved_17:15;    /**< \brief [31:17] \internal Reserved */
} Ifx_CPU_DIETR_Bits;

/** \brief CPUx Safety Protection Region DLMU Read Access Enable Register A${i} */
typedef struct _Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits
{
    unsigned __sfrbit32 EN0:1;           /**< \brief [0:0] Access Enable for Master TAG ID 0 - EN0 (rw) */
    unsigned __sfrbit32 EN1:1;           /**< \brief [1:1] Access Enable for Master TAG ID 1 - EN1 (rw) */
    unsigned __sfrbit32 EN2:1;           /**< \brief [2:2] Access Enable for Master TAG ID 2 - EN2 (rw) */
    unsigned __sfrbit32 EN3:1;           /**< \brief [3:3] Access Enable for Master TAG ID 3 - EN3 (rw) */
    unsigned __sfrbit32 EN4:1;           /**< \brief [4:4] Access Enable for Master TAG ID 4 - EN4 (rw) */
    unsigned __sfrbit32 EN5:1;           /**< \brief [5:5] Access Enable for Master TAG ID 5 - EN5 (rw) */
    unsigned __sfrbit32 EN6:1;           /**< \brief [6:6] Access Enable for Master TAG ID 6 - EN6 (rw) */
    unsigned __sfrbit32 EN7:1;           /**< \brief [7:7] Access Enable for Master TAG ID 7 - EN7 (rw) */
    unsigned __sfrbit32 EN8:1;           /**< \brief [8:8] Access Enable for Master TAG ID 8 - EN8 (rw) */
    unsigned __sfrbit32 EN9:1;           /**< \brief [9:9] Access Enable for Master TAG ID 9 - EN9 (rw) */
    unsigned __sfrbit32 EN10:1;          /**< \brief [10:10] Access Enable for Master TAG ID 10 - EN10 (rw) */
    unsigned __sfrbit32 EN11:1;          /**< \brief [11:11] Access Enable for Master TAG ID 11 - EN11 (rw) */
    unsigned __sfrbit32 EN12:1;          /**< \brief [12:12] Access Enable for Master TAG ID 12 - EN12 (rw) */
    unsigned __sfrbit32 EN13:1;          /**< \brief [13:13] Access Enable for Master TAG ID 13 - EN13 (rw) */
    unsigned __sfrbit32 EN14:1;          /**< \brief [14:14] Access Enable for Master TAG ID 14 - EN14 (rw) */
    unsigned __sfrbit32 EN15:1;          /**< \brief [15:15] Access Enable for Master TAG ID 15 - EN15 (rw) */
    unsigned __sfrbit32 EN16:1;          /**< \brief [16:16] Access Enable for Master TAG ID 16 - EN16 (rw) */
    unsigned __sfrbit32 EN17:1;          /**< \brief [17:17] Access Enable for Master TAG ID 17 - EN17 (rw) */
    unsigned __sfrbit32 EN18:1;          /**< \brief [18:18] Access Enable for Master TAG ID 18 - EN18 (rw) */
    unsigned __sfrbit32 EN19:1;          /**< \brief [19:19] Access Enable for Master TAG ID 19 - EN19 (rw) */
    unsigned __sfrbit32 EN20:1;          /**< \brief [20:20] Access Enable for Master TAG ID 20 - EN20 (rw) */
    unsigned __sfrbit32 EN21:1;          /**< \brief [21:21] Access Enable for Master TAG ID 21 - EN21 (rw) */
    unsigned __sfrbit32 EN22:1;          /**< \brief [22:22] Access Enable for Master TAG ID 22 - EN22 (rw) */
    unsigned __sfrbit32 EN23:1;          /**< \brief [23:23] Access Enable for Master TAG ID 23 - EN23 (rw) */
    unsigned __sfrbit32 EN24:1;          /**< \brief [24:24] Access Enable for Master TAG ID 24 - EN24 (rw) */
    unsigned __sfrbit32 EN25:1;          /**< \brief [25:25] Access Enable for Master TAG ID 25 - EN25 (rw) */
    unsigned __sfrbit32 EN26:1;          /**< \brief [26:26] Access Enable for Master TAG ID 26 - EN26 (rw) */
    unsigned __sfrbit32 EN27:1;          /**< \brief [27:27] Access Enable for Master TAG ID 27 - EN27 (rw) */
    unsigned __sfrbit32 EN28:1;          /**< \brief [28:28] Access Enable for Master TAG ID 28 - EN28 (rw) */
    unsigned __sfrbit32 EN29:1;          /**< \brief [29:29] Access Enable for Master TAG ID 29 - EN29 (rw) */
    unsigned __sfrbit32 EN30:1;          /**< \brief [30:30] Access Enable for Master TAG ID 30 - EN30 (rw) */
    unsigned __sfrbit32 EN31:1;          /**< \brief [31:31] Access Enable for Master TAG ID 31 - EN31 (rw) */
} Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits;

/** \brief CPUx Safety Protection Region DLMU Write Access Enable Register A${i} */
typedef struct _Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits
{
    unsigned __sfrbit32 EN0:1;           /**< \brief [0:0] Access Enable for Master TAG ID 0 - EN0 (rw) */
    unsigned __sfrbit32 EN1:1;           /**< \brief [1:1] Access Enable for Master TAG ID 1 - EN1 (rw) */
    unsigned __sfrbit32 EN2:1;           /**< \brief [2:2] Access Enable for Master TAG ID 2 - EN2 (rw) */
    unsigned __sfrbit32 EN3:1;           /**< \brief [3:3] Access Enable for Master TAG ID 3 - EN3 (rw) */
    unsigned __sfrbit32 EN4:1;           /**< \brief [4:4] Access Enable for Master TAG ID 4 - EN4 (rw) */
    unsigned __sfrbit32 EN5:1;           /**< \brief [5:5] Access Enable for Master TAG ID 5 - EN5 (rw) */
    unsigned __sfrbit32 EN6:1;           /**< \brief [6:6] Access Enable for Master TAG ID 6 - EN6 (rw) */
    unsigned __sfrbit32 EN7:1;           /**< \brief [7:7] Access Enable for Master TAG ID 7 - EN7 (rw) */
    unsigned __sfrbit32 EN8:1;           /**< \brief [8:8] Access Enable for Master TAG ID 8 - EN8 (rw) */
    unsigned __sfrbit32 EN9:1;           /**< \brief [9:9] Access Enable for Master TAG ID 9 - EN9 (rw) */
    unsigned __sfrbit32 EN10:1;          /**< \brief [10:10] Access Enable for Master TAG ID 10 - EN10 (rw) */
    unsigned __sfrbit32 EN11:1;          /**< \brief [11:11] Access Enable for Master TAG ID 11 - EN11 (rw) */
    unsigned __sfrbit32 EN12:1;          /**< \brief [12:12] Access Enable for Master TAG ID 12 - EN12 (rw) */
    unsigned __sfrbit32 EN13:1;          /**< \brief [13:13] Access Enable for Master TAG ID 13 - EN13 (rw) */
    unsigned __sfrbit32 EN14:1;          /**< \brief [14:14] Access Enable for Master TAG ID 14 - EN14 (rw) */
    unsigned __sfrbit32 EN15:1;          /**< \brief [15:15] Access Enable for Master TAG ID 15 - EN15 (rw) */
    unsigned __sfrbit32 EN16:1;          /**< \brief [16:16] Access Enable for Master TAG ID 16 - EN16 (rw) */
    unsigned __sfrbit32 EN17:1;          /**< \brief [17:17] Access Enable for Master TAG ID 17 - EN17 (rw) */
    unsigned __sfrbit32 EN18:1;          /**< \brief [18:18] Access Enable for Master TAG ID 18 - EN18 (rw) */
    unsigned __sfrbit32 EN19:1;          /**< \brief [19:19] Access Enable for Master TAG ID 19 - EN19 (rw) */
    unsigned __sfrbit32 EN20:1;          /**< \brief [20:20] Access Enable for Master TAG ID 20 - EN20 (rw) */
    unsigned __sfrbit32 EN21:1;          /**< \brief [21:21] Access Enable for Master TAG ID 21 - EN21 (rw) */
    unsigned __sfrbit32 EN22:1;          /**< \brief [22:22] Access Enable for Master TAG ID 22 - EN22 (rw) */
    unsigned __sfrbit32 EN23:1;          /**< \brief [23:23] Access Enable for Master TAG ID 23 - EN23 (rw) */
    unsigned __sfrbit32 EN24:1;          /**< \brief [24:24] Access Enable for Master TAG ID 24 - EN24 (rw) */
    unsigned __sfrbit32 EN25:1;          /**< \brief [25:25] Access Enable for Master TAG ID 25 - EN25 (rw) */
    unsigned __sfrbit32 EN26:1;          /**< \brief [26:26] Access Enable for Master TAG ID 26 - EN26 (rw) */
    unsigned __sfrbit32 EN27:1;          /**< \brief [27:27] Access Enable for Master TAG ID 27 - EN27 (rw) */
    unsigned __sfrbit32 EN28:1;          /**< \brief [28:28] Access Enable for Master TAG ID 28 - EN28 (rw) */
    unsigned __sfrbit32 EN29:1;          /**< \brief [29:29] Access Enable for Master TAG ID 29 - EN29 (rw) */
    unsigned __sfrbit32 EN30:1;          /**< \brief [30:30] Access Enable for Master TAG ID 30 - EN30 (rw) */
    unsigned __sfrbit32 EN31:1;          /**< \brief [31:31] Access Enable for Master TAG ID 31 - EN31 (rw) */
} Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits;

/** \brief CPUx Safety Protection Region DLMU Read Access Enable Register B${i} */
typedef struct _Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits
{
    unsigned __sfrbit32 EN32:1;          /**< \brief [0:0] Access Enable for Master TAG ID 32 - EN32 (rw) */
    unsigned __sfrbit32 EN33:1;          /**< \brief [1:1] Access Enable for Master TAG ID 33 - EN33 (rw) */
    unsigned __sfrbit32 EN34:1;          /**< \brief [2:2] Access Enable for Master TAG ID 34 - EN34 (rw) */
    unsigned __sfrbit32 EN35:1;          /**< \brief [3:3] Access Enable for Master TAG ID 35 - EN35 (rw) */
    unsigned __sfrbit32 EN36:1;          /**< \brief [4:4] Access Enable for Master TAG ID 36 - EN36 (rw) */
    unsigned __sfrbit32 EN37:1;          /**< \brief [5:5] Access Enable for Master TAG ID 37 - EN37 (rw) */
    unsigned __sfrbit32 EN38:1;          /**< \brief [6:6] Access Enable for Master TAG ID 38 - EN38 (rw) */
    unsigned __sfrbit32 EN39:1;          /**< \brief [7:7] Access Enable for Master TAG ID 39 - EN39 (rw) */
    unsigned __sfrbit32 EN40:1;          /**< \brief [8:8] Access Enable for Master TAG ID 40 - EN40 (rw) */
    unsigned __sfrbit32 EN41:1;          /**< \brief [9:9] Access Enable for Master TAG ID 41 - EN41 (rw) */
    unsigned __sfrbit32 EN42:1;          /**< \brief [10:10] Access Enable for Master TAG ID 42 - EN42 (rw) */
    unsigned __sfrbit32 EN43:1;          /**< \brief [11:11] Access Enable for Master TAG ID 43 - EN43 (rw) */
    unsigned __sfrbit32 EN44:1;          /**< \brief [12:12] Access Enable for Master TAG ID 44 - EN44 (rw) */
    unsigned __sfrbit32 EN45:1;          /**< \brief [13:13] Access Enable for Master TAG ID 45 - EN45 (rw) */
    unsigned __sfrbit32 EN46:1;          /**< \brief [14:14] Access Enable for Master TAG ID 46 - EN46 (rw) */
    unsigned __sfrbit32 EN47:1;          /**< \brief [15:15] Access Enable for Master TAG ID 47 - EN47 (rw) */
    unsigned __sfrbit32 EN48:1;          /**< \brief [16:16] Access Enable for Master TAG ID 48 - EN48 (rw) */
    unsigned __sfrbit32 EN49:1;          /**< \brief [17:17] Access Enable for Master TAG ID 49 - EN49 (rw) */
    unsigned __sfrbit32 EN50:1;          /**< \brief [18:18] Access Enable for Master TAG ID 50 - EN50 (rw) */
    unsigned __sfrbit32 EN51:1;          /**< \brief [19:19] Access Enable for Master TAG ID 51 - EN51 (rw) */
    unsigned __sfrbit32 EN52:1;          /**< \brief [20:20] Access Enable for Master TAG ID 52 - EN52 (rw) */
    unsigned __sfrbit32 EN53:1;          /**< \brief [21:21] Access Enable for Master TAG ID 53 - EN53 (rw) */
    unsigned __sfrbit32 EN54:1;          /**< \brief [22:22] Access Enable for Master TAG ID 54 - EN54 (rw) */
    unsigned __sfrbit32 EN55:1;          /**< \brief [23:23] Access Enable for Master TAG ID 55 - EN55 (rw) */
    unsigned __sfrbit32 EN56:1;          /**< \brief [24:24] Access Enable for Master TAG ID 56 - EN56 (rw) */
    unsigned __sfrbit32 EN57:1;          /**< \brief [25:25] Access Enable for Master TAG ID 57 - EN57 (rw) */
    unsigned __sfrbit32 EN58:1;          /**< \brief [26:26] Access Enable for Master TAG ID 58 - EN58 (rw) */
    unsigned __sfrbit32 EN59:1;          /**< \brief [27:27] Access Enable for Master TAG ID 59 - EN59 (rw) */
    unsigned __sfrbit32 EN60:1;          /**< \brief [28:28] Access Enable for Master TAG ID 60 - EN60 (rw) */
    unsigned __sfrbit32 EN61:1;          /**< \brief [29:29] Access Enable for Master TAG ID 61 - EN61 (rw) */
    unsigned __sfrbit32 EN62:1;          /**< \brief [30:30] Access Enable for Master TAG ID 62 - EN62 (rw) */
    unsigned __sfrbit32 EN63:1;          /**< \brief [31:31] Access Enable for Master TAG ID 63 - EN63 (rw) */
} Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits;

/** \brief CPUx Safety Protection Region DLMU Write Access Enable Register B${i} */
typedef struct _Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits
{
    unsigned __sfrbit32 EN32:1;          /**< \brief [0:0] Access Enable for Master TAG ID 32 - EN32 (rw) */
    unsigned __sfrbit32 EN33:1;          /**< \brief [1:1] Access Enable for Master TAG ID 33 - EN33 (rw) */
    unsigned __sfrbit32 EN34:1;          /**< \brief [2:2] Access Enable for Master TAG ID 34 - EN34 (rw) */
    unsigned __sfrbit32 EN35:1;          /**< \brief [3:3] Access Enable for Master TAG ID 35 - EN35 (rw) */
    unsigned __sfrbit32 EN36:1;          /**< \brief [4:4] Access Enable for Master TAG ID 36 - EN36 (rw) */
    unsigned __sfrbit32 EN37:1;          /**< \brief [5:5] Access Enable for Master TAG ID 37 - EN37 (rw) */
    unsigned __sfrbit32 EN38:1;          /**< \brief [6:6] Access Enable for Master TAG ID 38 - EN38 (rw) */
    unsigned __sfrbit32 EN39:1;          /**< \brief [7:7] Access Enable for Master TAG ID 39 - EN39 (rw) */
    unsigned __sfrbit32 EN40:1;          /**< \brief [8:8] Access Enable for Master TAG ID 40 - EN40 (rw) */
    unsigned __sfrbit32 EN41:1;          /**< \brief [9:9] Access Enable for Master TAG ID 41 - EN41 (rw) */
    unsigned __sfrbit32 EN42:1;          /**< \brief [10:10] Access Enable for Master TAG ID 42 - EN42 (rw) */
    unsigned __sfrbit32 EN43:1;          /**< \brief [11:11] Access Enable for Master TAG ID 43 - EN43 (rw) */
    unsigned __sfrbit32 EN44:1;          /**< \brief [12:12] Access Enable for Master TAG ID 44 - EN44 (rw) */
    unsigned __sfrbit32 EN45:1;          /**< \brief [13:13] Access Enable for Master TAG ID 45 - EN45 (rw) */
    unsigned __sfrbit32 EN46:1;          /**< \brief [14:14] Access Enable for Master TAG ID 46 - EN46 (rw) */
    unsigned __sfrbit32 EN47:1;          /**< \brief [15:15] Access Enable for Master TAG ID 47 - EN47 (rw) */
    unsigned __sfrbit32 EN48:1;          /**< \brief [16:16] Access Enable for Master TAG ID 48 - EN48 (rw) */
    unsigned __sfrbit32 EN49:1;          /**< \brief [17:17] Access Enable for Master TAG ID 49 - EN49 (rw) */
    unsigned __sfrbit32 EN50:1;          /**< \brief [18:18] Access Enable for Master TAG ID 50 - EN50 (rw) */
    unsigned __sfrbit32 EN51:1;          /**< \brief [19:19] Access Enable for Master TAG ID 51 - EN51 (rw) */
    unsigned __sfrbit32 EN52:1;          /**< \brief [20:20] Access Enable for Master TAG ID 52 - EN52 (rw) */
    unsigned __sfrbit32 EN53:1;          /**< \brief [21:21] Access Enable for Master TAG ID 53 - EN53 (rw) */
    unsigned __sfrbit32 EN54:1;          /**< \brief [22:22] Access Enable for Master TAG ID 54 - EN54 (rw) */
    unsigned __sfrbit32 EN55:1;          /**< \brief [23:23] Access Enable for Master TAG ID 55 - EN55 (rw) */
    unsigned __sfrbit32 EN56:1;          /**< \brief [24:24] Access Enable for Master TAG ID 56 - EN56 (rw) */
    unsigned __sfrbit32 EN57:1;          /**< \brief [25:25] Access Enable for Master TAG ID 57 - EN57 (rw) */
    unsigned __sfrbit32 EN58:1;          /**< \brief [26:26] Access Enable for Master TAG ID 58 - EN58 (rw) */
    unsigned __sfrbit32 EN59:1;          /**< \brief [27:27] Access Enable for Master TAG ID 59 - EN59 (rw) */
    unsigned __sfrbit32 EN60:1;          /**< \brief [28:28] Access Enable for Master TAG ID 60 - EN60 (rw) */
    unsigned __sfrbit32 EN61:1;          /**< \brief [29:29] Access Enable for Master TAG ID 61 - EN61 (rw) */
    unsigned __sfrbit32 EN62:1;          /**< \brief [30:30] Access Enable for Master TAG ID 62 - EN62 (rw) */
    unsigned __sfrbit32 EN63:1;          /**< \brief [31:31] Access Enable for Master TAG ID 63 - EN63 (rw) */
} Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits;

/** \brief CPUx Safety Protection DLMU Region Lower Address Register ${i} */
typedef struct _Ifx_CPU_DLMU_SPROT_RGNLA_Bits
{
    unsigned __sfrbit32 reserved_0:5;    /**< \brief [4:0] \internal Reserved */
    unsigned __sfrbit32 ADDR:27;         /**< \brief [31:5] Region Lower Address - ADDR (rw) */
} Ifx_CPU_DLMU_SPROT_RGNLA_Bits;

/** \brief CPUx Safety protection DLMU Region Upper Address Register ${i} */
typedef struct _Ifx_CPU_DLMU_SPROT_RGNUA_Bits
{
    unsigned __sfrbit32 reserved_0:5;    /**< \brief [4:0] \internal Reserved */
    unsigned __sfrbit32 ADDR:27;         /**< \brief [31:5] Region Upper Address - ADDR (rw) */
} Ifx_CPU_DLMU_SPROT_RGNUA_Bits;

/** \brief CPUx Debug Monitor Start Address */
typedef struct _Ifx_CPU_DMS_Bits
{
    unsigned __sfrbit32 reserved_0:1;    /**< \brief [0:0] \internal Reserved */
    unsigned __sfrbit32 DMSVALUE:31;     /**< \brief [31:1] Debug Monitor Start Address - DMSValue (rw) */
} Ifx_CPU_DMS_Bits;

/** \brief  */
typedef struct _Ifx_CPU_DPRE_Bits
{
    unsigned __sfrbit32 RE_N:18;         /**< \brief [17:0] Read Enable Range Select - RE[n] (rw) */
    unsigned __sfrbit32 reserved_18:14;    /**< \brief [31:18] \internal Reserved */
} Ifx_CPU_DPRE_Bits;

/** \brief CPUx Data Protection Range ${y}, Lower Bound Register */
typedef struct _Ifx_CPU_DPR_L_Bits
{
    unsigned __sfrbit32 reserved_0:3;    /**< \brief [2:0] \internal Reserved */
    unsigned __sfrbit32 LOWBND:29;       /**< \brief [31:3] DPRy Lower Boundary Address - LOWBND (rw) */
} Ifx_CPU_DPR_L_Bits;

/** \brief CPUx Data Protection Range ${y}, Upper Bound Register */
typedef struct _Ifx_CPU_DPR_U_Bits
{
    unsigned __sfrbit32 reserved_0:3;    /**< \brief [2:0] \internal Reserved */
    unsigned __sfrbit32 UPPBND:29;       /**< \brief [31:3] DPRy Upper Boundary Address - UPPBND (rw) */
} Ifx_CPU_DPR_U_Bits;

/** \brief  */
typedef struct _Ifx_CPU_DPWE_Bits
{
    unsigned __sfrbit32 WE_N:18;         /**< \brief [17:0] Write Enable Range Select - WE[n] (rw) */
    unsigned __sfrbit32 reserved_18:14;    /**< \brief [31:18] \internal Reserved */
} Ifx_CPU_DPWE_Bits;

/** \brief CPUx Data Synchronous Trap Register */
typedef struct _Ifx_CPU_DSTR_Bits
{
    unsigned __sfrbit32 SRE:1;           /**< \brief [0:0] Scratch Range Error - SRE (rwh) */
    unsigned __sfrbit32 GAE:1;           /**< \brief [1:1] Global Address Error - GAE (rwh) */
    unsigned __sfrbit32 LBE:1;           /**< \brief [2:2] Load Bus Error - LBE (rwh) */
    unsigned __sfrbit32 DRE:1;           /**< \brief [3:3] Local DLMU Range Error - DRE (rwh) */
    unsigned __sfrbit32 reserved_4:2;    /**< \brief [5:4] \internal Reserved */
    unsigned __sfrbit32 CRE:1;           /**< \brief [6:6] Cache Refill Error - CRE (rwh) */
    unsigned __sfrbit32 reserved_7:7;    /**< \brief [13:7] \internal Reserved */
    unsigned __sfrbit32 DTME:1;          /**< \brief [14:14] DTAG MSIST Error - DTME (rwh) */
    unsigned __sfrbit32 LOE:1;           /**< \brief [15:15] Load Overlay Error - LOE (rwh) */
    unsigned __sfrbit32 SDE:1;           /**< \brief [16:16] Segment Difference Error - SDE (rwh) */
    unsigned __sfrbit32 SCE:1;           /**< \brief [17:17] Segment Crossing Error - SCE (rwh) */
    unsigned __sfrbit32 CAC:1;           /**< \brief [18:18] CSFR Access Error - CAC (rwh) */
    unsigned __sfrbit32 MPE:1;           /**< \brief [19:19] Memory Protection Error - MPE (rwh) */
    unsigned __sfrbit32 CLE:1;           /**< \brief [20:20] Context Location Error - CLE (rwh) */
    unsigned __sfrbit32 reserved_21:3;    /**< \brief [23:21] \internal Reserved */
    unsigned __sfrbit32 ALN:1;           /**< \brief [24:24] Alignment Error - ALN (rwh) */
    unsigned __sfrbit32 reserved_25:7;    /**< \brief [31:25] \internal Reserved */
} Ifx_CPU_DSTR_Bits;

/** \brief CPUx External Event Register */
typedef struct _Ifx_CPU_EXEVT_Bits
{
    unsigned __sfrbit32 EVTA:3;          /**< \brief [2:0] Event Associated - EVTA (rw) */
    unsigned __sfrbit32 BBM:1;           /**< \brief [3:3] Break Before Make (BBM) or Break After Make (BAM) Selection - BBM (rw) */
    unsigned __sfrbit32 BOD:1;           /**< \brief [4:4] Breakout Disable - BOD (rw) */
    unsigned __sfrbit32 SUSP:1;          /**< \brief [5:5] CDC Suspend-Out Signal State - SUSP (rw) */
    unsigned __sfrbit32 CNT:2;           /**< \brief [7:6] Counter - CNT (rw) */
    unsigned __sfrbit32 reserved_8:24;    /**< \brief [31:8] \internal Reserved */
} Ifx_CPU_EXEVT_Bits;

/** \brief CPUx Free CSA List Head Pointer */
typedef struct _Ifx_CPU_FCX_Bits
{
    unsigned __sfrbit32 FCXO:16;         /**< \brief [15:0] FCX Offset Address Field - FCXO (rwh) */
    unsigned __sfrbit32 FCXS:4;          /**< \brief [19:16] FCX Segment Address Field - FCXS (rwh) */
    unsigned __sfrbit32 reserved_20:12;    /**< \brief [31:20] \internal Reserved */
} Ifx_CPU_FCX_Bits;

/** \brief CPUx Flash Configuration Register 0 */
typedef struct _Ifx_CPU_FLASHCON0_Bits
{
    unsigned __sfrbit32 TAG1:6;          /**< \brief [5:0] Flash Prefetch Buffer 1 Configuration (rw) */
    unsigned __sfrbit32 reserved_6:2;    /**< \brief [7:6] \internal Reserved */
    unsigned __sfrbit32 TAG2:6;          /**< \brief [13:8] Flash Prefetch Buffer 2 Configuration (rw) */
    unsigned __sfrbit32 reserved_14:2;    /**< \brief [15:14] \internal Reserved */
    unsigned __sfrbit32 TAG3:6;          /**< \brief [21:16] Flash Prefetch Buffer 3 Configuration (rw) */
    unsigned __sfrbit32 reserved_22:2;    /**< \brief [23:22] \internal Reserved */
    unsigned __sfrbit32 TAG4:6;          /**< \brief [29:24] Flash Prefetch Buffer 4 Configuration (rw) */
    unsigned __sfrbit32 reserved_30:2;    /**< \brief [31:30] \internal Reserved */
} Ifx_CPU_FLASHCON0_Bits;

/** \brief CPUx Flash Configuration Register 1 */
typedef struct _Ifx_CPU_FLASHCON1_Bits
{
    unsigned __sfrbit32 STALL:1;         /**< \brief [0:0] Stall Bus Request (rw) */
    unsigned __sfrbit32 reserved_1:15;    /**< \brief [15:1] \internal Reserved */
    unsigned __sfrbit32 MASKUECC:2;      /**< \brief [17:16] Mask PFLASH Uncorrectable ECC Bit Error (rw) */
    unsigned __sfrbit32 reserved_18:6;    /**< \brief [23:18] \internal Reserved */
    unsigned __sfrbit32 reserved_24:2;    /**< \brief [25:24] \internal Reserved */
    unsigned __sfrbit32 reserved_26:6;    /**< \brief [31:26] \internal Reserved */
} Ifx_CPU_FLASHCON1_Bits;

/** \brief CPUx Flash Configuration Register 2 */
typedef struct _Ifx_CPU_FLASHCON2_Bits
{
    unsigned __sfrbit32 RECDIS:2;        /**< \brief [1:0] Address Buffer Recording Disable (rw) */
    unsigned __sfrbit32 ECCCORDIS:2;     /**< \brief [3:2] ECC Correction Disable - ECCCORDIS (rw) */
    unsigned __sfrbit32 reserved_4:4;    /**< \brief [7:4] \internal Reserved */
    unsigned __sfrbit32 HMARGIN:2;       /**< \brief [9:8] Hard Margin Selection (rw) */
    unsigned __sfrbit32 MSEL:2;          /**< \brief [11:10] Margin Read Selection (rw) */
    unsigned __sfrbit32 reserved_12:4;    /**< \brief [15:12] \internal Reserved */
    unsigned __sfrbit32 ECCSCLR:2;       /**< \brief [17:16] Clear ECC Status Register (w) */
    unsigned __sfrbit32 reserved_18:6;    /**< \brief [23:18] \internal Reserved */
    unsigned __sfrbit32 SBABCLR:2;       /**< \brief [25:24] Clear SBAB Record Registers (w) */
    unsigned __sfrbit32 DBABCLR:2;       /**< \brief [27:26] Clear DBAB Record Registers (w) */
    unsigned __sfrbit32 MBABCLR:2;       /**< \brief [29:28] Clear MBAB Record Registers (w) */
    unsigned __sfrbit32 ZBABCLR:2;       /**< \brief [31:30] Clear ZBAB Record Registers - ZBABCLR (w) */
} Ifx_CPU_FLASHCON2_Bits;

/** \brief CPUx Flash Configuration Register 3 */
typedef struct _Ifx_CPU_FLASHCON3_Bits
{
    unsigned __sfrbit32 ECCERRINJ:1;     /**< \brief [0:0] ECC Error Injection (rw) */
    unsigned __sfrbit32 EDCERRINJ:1;     /**< \brief [1:1] EDC Error Injection (rw) */
    unsigned __sfrbit32 SBABERRINJ:1;    /**< \brief [2:2] Corrected Single Bits Address Buffer (SBAB) Error Injection (rw) */
    unsigned __sfrbit32 DBABERRINJ:1;    /**< \brief [3:3] Corrected Double Bits Address Buffer (DBAB) Error Injection (rw) */
    unsigned __sfrbit32 MBABERRINJ:1;    /**< \brief [4:4] Uncorrected Multi Bit Address Buffer (MBAB) Error Injection (rw) */
    unsigned __sfrbit32 ZBABERRINJ:1;    /**< \brief [5:5] Uncorrected All Zeros Bits Address Buffer (ZBAB) Error Injection (rw) */
    unsigned __sfrbit32 SBERERRINJ:1;    /**< \brief [6:6] Single Bit Error (SBER) Injection (rw) */
    unsigned __sfrbit32 DBERERRINJ:1;    /**< \brief [7:7] Double Bit Error (DBER) Injection (rw) */
    unsigned __sfrbit32 NVMCERRINJ:1;    /**< \brief [8:8] NVM Configuration (NVMCER) Injection (rw) */
    unsigned __sfrbit32 FLCONERRINJ:1;    /**< \brief [9:9] Flashcon Error (FLCONER) Injection (rw) */
    unsigned __sfrbit32 reserved_10:22;    /**< \brief [31:10] \internal Reserved */
} Ifx_CPU_FLASHCON3_Bits;

/** \brief CPUx Flash Configuration Register 4 */
typedef struct _Ifx_CPU_FLASHCON4_Bits
{
    unsigned __sfrbit32 DDIS:1;          /**< \brief [0:0] Disable direct LPB access (rw) */
    unsigned __sfrbit32 reserved_1:31;    /**< \brief [31:1] \internal Reserved */
} Ifx_CPU_FLASHCON4_Bits;

/** \brief CPUx Trap Control Register */
typedef struct _Ifx_CPU_FPU_TRAP_CON_Bits
{
    unsigned __sfrbit32 TST:1;           /**< \brief [0:0] Trap Status - TST (rh) */
    unsigned __sfrbit32 TCL:1;           /**< \brief [1:1] Trap Clear - TCL (w) */
    unsigned __sfrbit32 reserved_2:6;    /**< \brief [7:2] \internal Reserved */
    unsigned __sfrbit32 RM:2;            /**< \brief [9:8] Captured Rounding Mode - RM (rh) */
    unsigned __sfrbit32 reserved_10:8;    /**< \brief [17:10] \internal Reserved */
    unsigned __sfrbit32 FXE:1;           /**< \brief [18:18] FX Trap Enable - FXE (rw) */
    unsigned __sfrbit32 FUE:1;           /**< \brief [19:19] FU Trap Enable - FUE (rw) */
    unsigned __sfrbit32 FZE:1;           /**< \brief [20:20] FZ Trap Enable - FZE (rw) */
    unsigned __sfrbit32 FVE:1;           /**< \brief [21:21] FV Trap Enable - FVE (rw) */
    unsigned __sfrbit32 FIE:1;           /**< \brief [22:22] FI Trap Enable - FIE (rw) */
    unsigned __sfrbit32 reserved_23:3;    /**< \brief [25:23] \internal Reserved */
    unsigned __sfrbit32 FX:1;            /**< \brief [26:26] Captured FX - FX (rh) */
    unsigned __sfrbit32 FU:1;            /**< \brief [27:27] Captured FU - FU (rh) */
    unsigned __sfrbit32 FZ:1;            /**< \brief [28:28] Captured FZ - FZ (rh) */
    unsigned __sfrbit32 FV:1;            /**< \brief [29:29] Captured FV - FV (rh) */
    unsigned __sfrbit32 FI:1;            /**< \brief [30:30] Captured FI - FI (rh) */
    unsigned __sfrbit32 reserved_31:1;    /**< \brief [31:31] \internal Reserved */
} Ifx_CPU_FPU_TRAP_CON_Bits;

/** \brief CPUx Trapping Instruction Opcode Register */
typedef struct _Ifx_CPU_FPU_TRAP_OPC_Bits
{
    unsigned __sfrbit32 OPC:8;           /**< \brief [7:0] Captured Opcode - OPC (rh) */
    unsigned __sfrbit32 FMT:1;           /**< \brief [8:8] Captured Instruction Format - FMT (rh) */
    unsigned __sfrbit32 reserved_9:7;    /**< \brief [15:9] \internal Reserved */
    unsigned __sfrbit32 DREG:4;          /**< \brief [19:16] Captured Destination Register - DREG (rh) */
    unsigned __sfrbit32 reserved_20:12;    /**< \brief [31:20] \internal Reserved */
} Ifx_CPU_FPU_TRAP_OPC_Bits;

/** \brief CPUx Trapping Instruction Program Counter Register */
typedef struct _Ifx_CPU_FPU_TRAP_PC_Bits
{
    unsigned __sfrbit32 PC:32;           /**< \brief [31:0] Captured Program Counter - PC (rh) */
} Ifx_CPU_FPU_TRAP_PC_Bits;

/** \brief CPUx Trapping Instruction Operand Register */
typedef struct _Ifx_CPU_FPU_TRAP_SRC1_Bits
{
    unsigned __sfrbit32 SRC1:32;         /**< \brief [31:0] Captured SRC1 Operand - SRC1 (rh) */
} Ifx_CPU_FPU_TRAP_SRC1_Bits;

/** \brief CPUx Trapping Instruction Operand Register */
typedef struct _Ifx_CPU_FPU_TRAP_SRC2_Bits
{
    unsigned __sfrbit32 SRC2:32;         /**< \brief [31:0] Captured SRC2 Operand - SRC2 (rh) */
} Ifx_CPU_FPU_TRAP_SRC2_Bits;

/** \brief CPUx Trapping Instruction Operand Register */
typedef struct _Ifx_CPU_FPU_TRAP_SRC3_Bits
{
    unsigned __sfrbit32 SRC3:32;         /**< \brief [31:0] Captured SRC3 Operand - SRC3 (rh) */
} Ifx_CPU_FPU_TRAP_SRC3_Bits;

/** \brief CPUx Instruction Count */
typedef struct _Ifx_CPU_ICNT_Bits
{
    unsigned __sfrbit32 COUNTVALUE:31;    /**< \brief [30:0] Count Value - CountValue (rwh) */
    unsigned __sfrbit32 SOVF:1;          /**< \brief [31:31] Sticky Overflow Bit - SOvf (rwh) */
} Ifx_CPU_ICNT_Bits;

/** \brief CPUx Interrupt Control Register */
typedef struct _Ifx_CPU_ICR_Bits
{
    unsigned __sfrbit32 CCPN:8;          /**< \brief [7:0] Current CPU Priority Number - CCPN (rwh) */
    unsigned __sfrbit32 reserved_8:7;    /**< \brief [14:8] \internal Reserved */
    unsigned __sfrbit32 IE:1;            /**< \brief [15:15] Global Interrupt Enable Bit - IE (rwh) */
    unsigned __sfrbit32 PIPN:8;          /**< \brief [23:16] Pending Interrupt Priority Number - PIPN (rh) */
    unsigned __sfrbit32 reserved_24:8;    /**< \brief [31:24] \internal Reserved */
} Ifx_CPU_ICR_Bits;

/** \brief CPUx Interrupt Stack Pointer */
typedef struct _Ifx_CPU_ISP_Bits
{
    unsigned __sfrbit32 ISP:32;          /**< \brief [31:0] Interrupt Stack Pointer - ISP (rw) */
} Ifx_CPU_ISP_Bits;

/** \brief CPUx  Reset Register 0 */
typedef struct _Ifx_CPU_KRST0_Bits
{
    unsigned __sfrbit32 RST:1;           /**< \brief [0:0] Kernel Reset - RST (rwh) */
    unsigned __sfrbit32 RSTSTAT:2;       /**< \brief [2:1] Kernel Reset Status - RSTSTAT (rh) */
    unsigned __sfrbit32 reserved_3:29;    /**< \brief [31:3] \internal Reserved */
} Ifx_CPU_KRST0_Bits;

/** \brief CPUx  Reset Register 1 */
typedef struct _Ifx_CPU_KRST1_Bits
{
    unsigned __sfrbit32 RST:1;           /**< \brief [0:0] Kernel Reset - RST (rwh) */
    unsigned __sfrbit32 reserved_1:31;    /**< \brief [31:1] \internal Reserved */
} Ifx_CPU_KRST1_Bits;

/** \brief CPUx Reset Clear Register */
typedef struct _Ifx_CPU_KRSTCLR_Bits
{
    unsigned __sfrbit32 CLR:1;           /**< \brief [0:0] Kernel Reset Status Clear - CLR (w) */
    unsigned __sfrbit32 reserved_1:31;    /**< \brief [31:1] \internal Reserved */
} Ifx_CPU_KRSTCLR_Bits;

/** \brief CPUx Free CSA List Limit Pointer */
typedef struct _Ifx_CPU_LCX_Bits
{
    unsigned __sfrbit32 LCXO:16;         /**< \brief [15:0] LCX Offset Field - LCXO (rw) */
    unsigned __sfrbit32 LCXS:4;          /**< \brief [19:16] LCX Segment Address - LCXS (rw) */
    unsigned __sfrbit32 reserved_20:12;    /**< \brief [31:20] \internal Reserved */
} Ifx_CPU_LCX_Bits;

/** \brief CPUx Safety Protection Region LPB Read Access Enable Register A */
typedef struct _Ifx_CPU_LPB_SPROT_ACCENA_R_Bits
{
    unsigned __sfrbit32 EN0:1;           /**< \brief [0:0] Access Enable for Master TAG ID 0 - EN0 (rw) */
    unsigned __sfrbit32 EN1:1;           /**< \brief [1:1] Access Enable for Master TAG ID 1 - EN1 (rw) */
    unsigned __sfrbit32 EN2:1;           /**< \brief [2:2] Access Enable for Master TAG ID 2 - EN2 (rw) */
    unsigned __sfrbit32 EN3:1;           /**< \brief [3:3] Access Enable for Master TAG ID 3 - EN3 (rw) */
    unsigned __sfrbit32 EN4:1;           /**< \brief [4:4] Access Enable for Master TAG ID 4 - EN4 (rw) */
    unsigned __sfrbit32 EN5:1;           /**< \brief [5:5] Access Enable for Master TAG ID 5 - EN5 (rw) */
    unsigned __sfrbit32 EN6:1;           /**< \brief [6:6] Access Enable for Master TAG ID 6 - EN6 (rw) */
    unsigned __sfrbit32 EN7:1;           /**< \brief [7:7] Access Enable for Master TAG ID 7 - EN7 (rw) */
    unsigned __sfrbit32 EN8:1;           /**< \brief [8:8] Access Enable for Master TAG ID 8 - EN8 (rw) */
    unsigned __sfrbit32 EN9:1;           /**< \brief [9:9] Access Enable for Master TAG ID 9 - EN9 (rw) */
    unsigned __sfrbit32 EN10:1;          /**< \brief [10:10] Access Enable for Master TAG ID 10 - EN10 (rw) */
    unsigned __sfrbit32 EN11:1;          /**< \brief [11:11] Access Enable for Master TAG ID 11 - EN11 (rw) */
    unsigned __sfrbit32 EN12:1;          /**< \brief [12:12] Access Enable for Master TAG ID 12 - EN12 (rw) */
    unsigned __sfrbit32 EN13:1;          /**< \brief [13:13] Access Enable for Master TAG ID 13 - EN13 (rw) */
    unsigned __sfrbit32 EN14:1;          /**< \brief [14:14] Access Enable for Master TAG ID 14 - EN14 (rw) */
    unsigned __sfrbit32 EN15:1;          /**< \brief [15:15] Access Enable for Master TAG ID 15 - EN15 (rw) */
    unsigned __sfrbit32 EN16:1;          /**< \brief [16:16] Access Enable for Master TAG ID 16 - EN16 (rw) */
    unsigned __sfrbit32 EN17:1;          /**< \brief [17:17] Access Enable for Master TAG ID 17 - EN17 (rw) */
    unsigned __sfrbit32 EN18:1;          /**< \brief [18:18] Access Enable for Master TAG ID 18 - EN18 (rw) */
    unsigned __sfrbit32 EN19:1;          /**< \brief [19:19] Access Enable for Master TAG ID 19 - EN19 (rw) */
    unsigned __sfrbit32 EN20:1;          /**< \brief [20:20] Access Enable for Master TAG ID 20 - EN20 (rw) */
    unsigned __sfrbit32 EN21:1;          /**< \brief [21:21] Access Enable for Master TAG ID 21 - EN21 (rw) */
    unsigned __sfrbit32 EN22:1;          /**< \brief [22:22] Access Enable for Master TAG ID 22 - EN22 (rw) */
    unsigned __sfrbit32 EN23:1;          /**< \brief [23:23] Access Enable for Master TAG ID 23 - EN23 (rw) */
    unsigned __sfrbit32 EN24:1;          /**< \brief [24:24] Access Enable for Master TAG ID 24 - EN24 (rw) */
    unsigned __sfrbit32 EN25:1;          /**< \brief [25:25] Access Enable for Master TAG ID 25 - EN25 (rw) */
    unsigned __sfrbit32 EN26:1;          /**< \brief [26:26] Access Enable for Master TAG ID 26 - EN26 (rw) */
    unsigned __sfrbit32 EN27:1;          /**< \brief [27:27] Access Enable for Master TAG ID 27 - EN27 (rw) */
    unsigned __sfrbit32 EN28:1;          /**< \brief [28:28] Access Enable for Master TAG ID 28 - EN28 (rw) */
    unsigned __sfrbit32 EN29:1;          /**< \brief [29:29] Access Enable for Master TAG ID 29 - EN29 (rw) */
    unsigned __sfrbit32 EN30:1;          /**< \brief [30:30] Access Enable for Master TAG ID 30 - EN30 (rw) */
    unsigned __sfrbit32 EN31:1;          /**< \brief [31:31] Access Enable for Master TAG ID 31 - EN31 (rw) */
} Ifx_CPU_LPB_SPROT_ACCENA_R_Bits;

/** \brief CPUx Safety Protection Region LPB Read Access Enable Register B */
typedef struct _Ifx_CPU_LPB_SPROT_ACCENB_R_Bits
{
    unsigned __sfrbit32 EN32:1;          /**< \brief [0:0] Access Enable for Master TAG ID 32 - EN32 (rw) */
    unsigned __sfrbit32 EN33:1;          /**< \brief [1:1] Access Enable for Master TAG ID 33 - EN33 (rw) */
    unsigned __sfrbit32 EN34:1;          /**< \brief [2:2] Access Enable for Master TAG ID 34 - EN34 (rw) */
    unsigned __sfrbit32 EN35:1;          /**< \brief [3:3] Access Enable for Master TAG ID 35 - EN35 (rw) */
    unsigned __sfrbit32 EN36:1;          /**< \brief [4:4] Access Enable for Master TAG ID 36 - EN36 (rw) */
    unsigned __sfrbit32 EN37:1;          /**< \brief [5:5] Access Enable for Master TAG ID 37 - EN37 (rw) */
    unsigned __sfrbit32 EN38:1;          /**< \brief [6:6] Access Enable for Master TAG ID 38 - EN38 (rw) */
    unsigned __sfrbit32 EN39:1;          /**< \brief [7:7] Access Enable for Master TAG ID 39 - EN39 (rw) */
    unsigned __sfrbit32 EN40:1;          /**< \brief [8:8] Access Enable for Master TAG ID 40 - EN40 (rw) */
    unsigned __sfrbit32 EN41:1;          /**< \brief [9:9] Access Enable for Master TAG ID 41 - EN41 (rw) */
    unsigned __sfrbit32 EN42:1;          /**< \brief [10:10] Access Enable for Master TAG ID 42 - EN42 (rw) */
    unsigned __sfrbit32 EN43:1;          /**< \brief [11:11] Access Enable for Master TAG ID 43 - EN43 (rw) */
    unsigned __sfrbit32 EN44:1;          /**< \brief [12:12] Access Enable for Master TAG ID 44 - EN44 (rw) */
    unsigned __sfrbit32 EN45:1;          /**< \brief [13:13] Access Enable for Master TAG ID 45 - EN45 (rw) */
    unsigned __sfrbit32 EN46:1;          /**< \brief [14:14] Access Enable for Master TAG ID 46 - EN46 (rw) */
    unsigned __sfrbit32 EN47:1;          /**< \brief [15:15] Access Enable for Master TAG ID 47 - EN47 (rw) */
    unsigned __sfrbit32 EN48:1;          /**< \brief [16:16] Access Enable for Master TAG ID 48 - EN48 (rw) */
    unsigned __sfrbit32 EN49:1;          /**< \brief [17:17] Access Enable for Master TAG ID 49 - EN49 (rw) */
    unsigned __sfrbit32 EN50:1;          /**< \brief [18:18] Access Enable for Master TAG ID 50 - EN50 (rw) */
    unsigned __sfrbit32 EN51:1;          /**< \brief [19:19] Access Enable for Master TAG ID 51 - EN51 (rw) */
    unsigned __sfrbit32 EN52:1;          /**< \brief [20:20] Access Enable for Master TAG ID 52 - EN52 (rw) */
    unsigned __sfrbit32 EN53:1;          /**< \brief [21:21] Access Enable for Master TAG ID 53 - EN53 (rw) */
    unsigned __sfrbit32 EN54:1;          /**< \brief [22:22] Access Enable for Master TAG ID 54 - EN54 (rw) */
    unsigned __sfrbit32 EN55:1;          /**< \brief [23:23] Access Enable for Master TAG ID 55 - EN55 (rw) */
    unsigned __sfrbit32 EN56:1;          /**< \brief [24:24] Access Enable for Master TAG ID 56 - EN56 (rw) */
    unsigned __sfrbit32 EN57:1;          /**< \brief [25:25] Access Enable for Master TAG ID 57 - EN57 (rw) */
    unsigned __sfrbit32 EN58:1;          /**< \brief [26:26] Access Enable for Master TAG ID 58 - EN58 (rw) */
    unsigned __sfrbit32 EN59:1;          /**< \brief [27:27] Access Enable for Master TAG ID 59 - EN59 (rw) */
    unsigned __sfrbit32 EN60:1;          /**< \brief [28:28] Access Enable for Master TAG ID 60 - EN60 (rw) */
    unsigned __sfrbit32 EN61:1;          /**< \brief [29:29] Access Enable for Master TAG ID 61 - EN61 (rw) */
    unsigned __sfrbit32 EN62:1;          /**< \brief [30:30] Access Enable for Master TAG ID 62 - EN62 (rw) */
    unsigned __sfrbit32 EN63:1;          /**< \brief [31:31] Access Enable for Master TAG ID 63 - EN63 (rw) */
} Ifx_CPU_LPB_SPROT_ACCENB_R_Bits;

/** \brief CPUx Multi-Count Register 1 */
typedef struct _Ifx_CPU_M1CNT_Bits
{
    unsigned __sfrbit32 COUNTVALUE:31;    /**< \brief [30:0] Count Value - CountValue (rwh) */
    unsigned __sfrbit32 SOVF:1;          /**< \brief [31:31] Sticky Overflow Bit - SOvf (rwh) */
} Ifx_CPU_M1CNT_Bits;

/** \brief CPUx Multi-Count Register 2 */
typedef struct _Ifx_CPU_M2CNT_Bits
{
    unsigned __sfrbit32 COUNTVALUE:31;    /**< \brief [30:0] Count Value - CountValue (rwh) */
    unsigned __sfrbit32 SOVF:1;          /**< \brief [31:31] Sticky Overflow Bit - SOvf (rwh) */
} Ifx_CPU_M2CNT_Bits;

/** \brief CPUx Multi-Count Register 3 */
typedef struct _Ifx_CPU_M3CNT_Bits
{
    unsigned __sfrbit32 COUNTVALUE:31;    /**< \brief [30:0] Count Value - CountValue (rwh) */
    unsigned __sfrbit32 SOVF:1;          /**< \brief [31:31] Sticky Overflow Bit - SOvf (rwh) */
} Ifx_CPU_M3CNT_Bits;

/** \brief CPUx  Overlay Range Select Register */
typedef struct _Ifx_CPU_OSEL_Bits
{
    unsigned __sfrbit32 SHOVEN_X:32;     /**< \brief [31:0] Shadow Overlay Enable - SHOVEN[x] (rw) */
} Ifx_CPU_OSEL_Bits;

/** \brief CPUx Program Counter */
typedef struct _Ifx_CPU_PC_Bits
{
    unsigned __sfrbit32 reserved_0:1;    /**< \brief [0:0] \internal Reserved */
    unsigned __sfrbit32 PC:31;           /**< \brief [31:1] Program Counter - PC (rwh) */
} Ifx_CPU_PC_Bits;

/** \brief CPUx Program Control 0 */
typedef struct _Ifx_CPU_PCON0_Bits
{
    unsigned __sfrbit32 reserved_0:1;    /**< \brief [0:0] \internal Reserved */
    unsigned __sfrbit32 PCBYP:1;         /**< \brief [1:1] Program Cache Bypass - PCBYP (rw) */
    unsigned __sfrbit32 reserved_2:30;    /**< \brief [31:2] \internal Reserved */
} Ifx_CPU_PCON0_Bits;

/** \brief CPUx Program Control 1 */
typedef struct _Ifx_CPU_PCON1_Bits
{
    unsigned __sfrbit32 PCINV:1;         /**< \brief [0:0] Program Cache Invalidate - PCINV (rw) */
    unsigned __sfrbit32 PBINV:1;         /**< \brief [1:1] Program Buffer Invalidate - PBINV (rw) */
    unsigned __sfrbit32 reserved_2:30;    /**< \brief [31:2] \internal Reserved */
} Ifx_CPU_PCON1_Bits;

/** \brief CPUx Program Control 2 */
typedef struct _Ifx_CPU_PCON2_Bits
{
    unsigned __sfrbit32 PCACHE_SZE:16;    /**< \brief [15:0] Program Cache Size (ICACHE) in KBytes - PCACHE_SZE (r) */
    unsigned __sfrbit32 PSCRATCH_SZE:16;    /**< \brief [31:16] Program Scratch Size in KBytes - PSCRATCH_SZE (r) */
} Ifx_CPU_PCON2_Bits;

/** \brief CPUx Previous Context Information Register */
typedef struct _Ifx_CPU_PCXI_Bits
{
    unsigned __sfrbit32 PCXO:16;         /**< \brief [15:0] Previous Context Pointer Offset Field - PCXO (rwh) */
    unsigned __sfrbit32 PCXS:4;          /**< \brief [19:16] Previous Context Pointer Segment Address - PCXS (rwh) */
    unsigned __sfrbit32 UL:1;            /**< \brief [20:20] Upper or Lower Context Tag - UL (rwh) */
    unsigned __sfrbit32 PIE:1;           /**< \brief [21:21] Previous Interrupt Enable - PIE (rwh) */
    unsigned __sfrbit32 PCPN:8;          /**< \brief [29:22] Previous CPU Priority Number - PCPN (rwh) */
    unsigned __sfrbit32 reserved_30:2;    /**< \brief [31:30] \internal Reserved */
} Ifx_CPU_PCXI_Bits;

/** \brief CPUx Program Integrity Error Address Register */
typedef struct _Ifx_CPU_PIEAR_Bits
{
    unsigned __sfrbit32 TA:32;           /**< \brief [31:0] Transaction Address - TA (rh) */
} Ifx_CPU_PIEAR_Bits;

/** \brief CPUx Program Integrity Error Trap Register */
typedef struct _Ifx_CPU_PIETR_Bits
{
    unsigned __sfrbit32 IED:1;           /**< \brief [0:0] Integrity Error Detected - IED (rwh) */
    unsigned __sfrbit32 IE_T:1;          /**< \brief [1:1] Integrity Error - TAG Memory - IE_T (rh) */
    unsigned __sfrbit32 IE_C:1;          /**< \brief [2:2] Integrity Error - Cache Memory - IE_C (rh) */
    unsigned __sfrbit32 IE_S:1;          /**< \brief [3:3] Integrity Error - Scratchpad Memory - IE_S (rh) */
    unsigned __sfrbit32 IE_BI:1;         /**< \brief [4:4] Integrity Error - Bus Interface - IE_BI (rh) */
    unsigned __sfrbit32 E_INFO:6;        /**< \brief [10:5] Error Information - E_INFO (rh) */
    unsigned __sfrbit32 IE_UNC:1;        /**< \brief [11:11] Integrity Error - Uncorrectable Error Detected - IE_UNC (rh) */
    unsigned __sfrbit32 IE_SP:1;         /**< \brief [12:12] Safety Protection Error Detected - IE_SP (rh) */
    unsigned __sfrbit32 IE_BS:1;         /**< \brief [13:13] Bus Slave Access Indicator - IE_BS (rh) */
    unsigned __sfrbit32 IE_ADDR:1;       /**< \brief [14:14] Address Phase error detected at SRI slave interface - IE_ADDR (rh) */
    unsigned __sfrbit32 IE_LPB:1;        /**< \brief [15:15] Integrity Error - Local Pflash bank - IE_LPB (rh) */
    unsigned __sfrbit32 IE_MTMV:1;       /**< \brief [16:16] Memory Test Mode Violation detected - IE_MTMV (rh) */
    unsigned __sfrbit32 reserved_17:15;    /**< \brief [31:17] \internal Reserved */
} Ifx_CPU_PIETR_Bits;

/** \brief CPUx Data Access CacheabilityRegister */
typedef struct _Ifx_CPU_PMA0_Bits
{
    unsigned __sfrbit32 DAC:16;          /**< \brief [15:0] Data Access Cacheability Segments FHto 0H - DAC (rw) */
    unsigned __sfrbit32 reserved_16:16;    /**< \brief [31:16] \internal Reserved */
} Ifx_CPU_PMA0_Bits;

/** \brief CPUx Code Access CacheabilityRegister */
typedef struct _Ifx_CPU_PMA1_Bits
{
    unsigned __sfrbit32 CAC:16;          /**< \brief [15:0] Code Access Cacheability Segments FH-0H - CAC (rw) */
    unsigned __sfrbit32 reserved_16:16;    /**< \brief [31:16] \internal Reserved */
} Ifx_CPU_PMA1_Bits;

/** \brief CPUx  Peripheral Space Identifier register */
typedef struct _Ifx_CPU_PMA2_Bits
{
    unsigned __sfrbit32 PSI:16;          /**< \brief [15:0] Peripheral Space Identifier Segments FH-0H - PSI (r) */
    unsigned __sfrbit32 reserved_16:16;    /**< \brief [31:16] \internal Reserved */
} Ifx_CPU_PMA2_Bits;

/** \brief CPUx Program Synchronous Trap Register */
typedef struct _Ifx_CPU_PSTR_Bits
{
    unsigned __sfrbit32 FRE:1;           /**< \brief [0:0] Fetch Range Error - FRE (rwh) */
    unsigned __sfrbit32 reserved_1:1;    /**< \brief [1:1] \internal Reserved */
    unsigned __sfrbit32 FBE:1;           /**< \brief [2:2] Fetch Bus Error - FBE (rwh) */
    unsigned __sfrbit32 reserved_3:9;    /**< \brief [11:3] \internal Reserved */
    unsigned __sfrbit32 FPE:1;           /**< \brief [12:12] Fetch Peripheral Error - FPE (rwh) */
    unsigned __sfrbit32 reserved_13:1;    /**< \brief [13:13] \internal Reserved */
    unsigned __sfrbit32 FME:1;           /**< \brief [14:14] Fetch MSIST Error - FME (rwh) */
    unsigned __sfrbit32 reserved_15:17;    /**< \brief [31:15] \internal Reserved */
} Ifx_CPU_PSTR_Bits;

/** \brief CPUx Program Status Word */
typedef struct _Ifx_CPU_PSW_Bits
{
    unsigned __sfrbit32 CDC:7;           /**< \brief [6:0] Call Depth Counter - CDC (rwh) */
    unsigned __sfrbit32 CDE:1;           /**< \brief [7:7] Call Depth Count Enable - CDE (rwh) */
    unsigned __sfrbit32 GW:1;            /**< \brief [8:8] Global Address Register Write Permission - GW (rwh) */
    unsigned __sfrbit32 IS:1;            /**< \brief [9:9] Interrupt Stack Control - IS (rwh) */
    unsigned __sfrbit32 IO:2;            /**< \brief [11:10] Access Privilege Level Control (I/O Privilege) - IO (rwh) */
    unsigned __sfrbit32 PRS:2;           /**< \brief [13:12] Protection Register Set - PRS (rwh) */
    unsigned __sfrbit32 S:1;             /**< \brief [14:14] Safe Task Identifier - S (rwh) */
    unsigned __sfrbit32 PRS2:1;          /**< \brief [15:15] Protection Register Set MSB - PRS2 (rwh) */
    unsigned __sfrbit32 reserved_16:8;    /**< \brief [23:16] \internal Reserved */
    unsigned __sfrbit32 USB:8;           /**< \brief [31:24] User Status Bits - USB (rw) */
} Ifx_CPU_PSW_Bits;

/** \brief CPUx Safety Protection SPR Region Write Access Enable Register A${i} */
typedef struct _Ifx_CPU_RGN_ACCENA_Bits
{
    unsigned __sfrbit32 EN0:1;           /**< \brief [0:0] Access Enable for Master TAG ID 0 - EN0 (rw) */
    unsigned __sfrbit32 EN1:1;           /**< \brief [1:1] Access Enable for Master TAG ID 1 - EN1 (rw) */
    unsigned __sfrbit32 EN2:1;           /**< \brief [2:2] Access Enable for Master TAG ID 2 - EN2 (rw) */
    unsigned __sfrbit32 EN3:1;           /**< \brief [3:3] Access Enable for Master TAG ID 3 - EN3 (rw) */
    unsigned __sfrbit32 EN4:1;           /**< \brief [4:4] Access Enable for Master TAG ID 4 - EN4 (rw) */
    unsigned __sfrbit32 EN5:1;           /**< \brief [5:5] Access Enable for Master TAG ID 5 - EN5 (rw) */
    unsigned __sfrbit32 EN6:1;           /**< \brief [6:6] Access Enable for Master TAG ID 6 - EN6 (rw) */
    unsigned __sfrbit32 EN7:1;           /**< \brief [7:7] Access Enable for Master TAG ID 7 - EN7 (rw) */
    unsigned __sfrbit32 EN8:1;           /**< \brief [8:8] Access Enable for Master TAG ID 8 - EN8 (rw) */
    unsigned __sfrbit32 EN9:1;           /**< \brief [9:9] Access Enable for Master TAG ID 9 - EN9 (rw) */
    unsigned __sfrbit32 EN10:1;          /**< \brief [10:10] Access Enable for Master TAG ID 10 - EN10 (rw) */
    unsigned __sfrbit32 EN11:1;          /**< \brief [11:11] Access Enable for Master TAG ID 11 - EN11 (rw) */
    unsigned __sfrbit32 EN12:1;          /**< \brief [12:12] Access Enable for Master TAG ID 12 - EN12 (rw) */
    unsigned __sfrbit32 EN13:1;          /**< \brief [13:13] Access Enable for Master TAG ID 13 - EN13 (rw) */
    unsigned __sfrbit32 EN14:1;          /**< \brief [14:14] Access Enable for Master TAG ID 14 - EN14 (rw) */
    unsigned __sfrbit32 EN15:1;          /**< \brief [15:15] Access Enable for Master TAG ID 15 - EN15 (rw) */
    unsigned __sfrbit32 EN16:1;          /**< \brief [16:16] Access Enable for Master TAG ID 16 - EN16 (rw) */
    unsigned __sfrbit32 EN17:1;          /**< \brief [17:17] Access Enable for Master TAG ID 17 - EN17 (rw) */
    unsigned __sfrbit32 EN18:1;          /**< \brief [18:18] Access Enable for Master TAG ID 18 - EN18 (rw) */
    unsigned __sfrbit32 EN19:1;          /**< \brief [19:19] Access Enable for Master TAG ID 19 - EN19 (rw) */
    unsigned __sfrbit32 EN20:1;          /**< \brief [20:20] Access Enable for Master TAG ID 20 - EN20 (rw) */
    unsigned __sfrbit32 EN21:1;          /**< \brief [21:21] Access Enable for Master TAG ID 21 - EN21 (rw) */
    unsigned __sfrbit32 EN22:1;          /**< \brief [22:22] Access Enable for Master TAG ID 22 - EN22 (rw) */
    unsigned __sfrbit32 EN23:1;          /**< \brief [23:23] Access Enable for Master TAG ID 23 - EN23 (rw) */
    unsigned __sfrbit32 EN24:1;          /**< \brief [24:24] Access Enable for Master TAG ID 24 - EN24 (rw) */
    unsigned __sfrbit32 EN25:1;          /**< \brief [25:25] Access Enable for Master TAG ID 25 - EN25 (rw) */
    unsigned __sfrbit32 EN26:1;          /**< \brief [26:26] Access Enable for Master TAG ID 26 - EN26 (rw) */
    unsigned __sfrbit32 EN27:1;          /**< \brief [27:27] Access Enable for Master TAG ID 27 - EN27 (rw) */
    unsigned __sfrbit32 EN28:1;          /**< \brief [28:28] Access Enable for Master TAG ID 28 - EN28 (rw) */
    unsigned __sfrbit32 EN29:1;          /**< \brief [29:29] Access Enable for Master TAG ID 29 - EN29 (rw) */
    unsigned __sfrbit32 EN30:1;          /**< \brief [30:30] Access Enable for Master TAG ID 30 - EN30 (rw) */
    unsigned __sfrbit32 EN31:1;          /**< \brief [31:31] Access Enable for Master TAG ID 31 - EN31 (rw) */
} Ifx_CPU_RGN_ACCENA_Bits;

/** \brief CPUx Safety Protection SPR Region Write Access Enable Register B${i} */
typedef struct _Ifx_CPU_RGN_ACCENB_Bits
{
    unsigned __sfrbit32 EN32:1;          /**< \brief [0:0] Access Enable for Master TAG ID 32 - EN32 (rw) */
    unsigned __sfrbit32 EN33:1;          /**< \brief [1:1] Access Enable for Master TAG ID 33 - EN33 (rw) */
    unsigned __sfrbit32 EN34:1;          /**< \brief [2:2] Access Enable for Master TAG ID 34 - EN34 (rw) */
    unsigned __sfrbit32 EN35:1;          /**< \brief [3:3] Access Enable for Master TAG ID 35 - EN35 (rw) */
    unsigned __sfrbit32 EN36:1;          /**< \brief [4:4] Access Enable for Master TAG ID 36 - EN36 (rw) */
    unsigned __sfrbit32 EN37:1;          /**< \brief [5:5] Access Enable for Master TAG ID 37 - EN37 (rw) */
    unsigned __sfrbit32 EN38:1;          /**< \brief [6:6] Access Enable for Master TAG ID 38 - EN38 (rw) */
    unsigned __sfrbit32 EN39:1;          /**< \brief [7:7] Access Enable for Master TAG ID 39 - EN39 (rw) */
    unsigned __sfrbit32 EN40:1;          /**< \brief [8:8] Access Enable for Master TAG ID 40 - EN40 (rw) */
    unsigned __sfrbit32 EN41:1;          /**< \brief [9:9] Access Enable for Master TAG ID 41 - EN41 (rw) */
    unsigned __sfrbit32 EN42:1;          /**< \brief [10:10] Access Enable for Master TAG ID 42 - EN42 (rw) */
    unsigned __sfrbit32 EN43:1;          /**< \brief [11:11] Access Enable for Master TAG ID 43 - EN43 (rw) */
    unsigned __sfrbit32 EN44:1;          /**< \brief [12:12] Access Enable for Master TAG ID 44 - EN44 (rw) */
    unsigned __sfrbit32 EN45:1;          /**< \brief [13:13] Access Enable for Master TAG ID 45 - EN45 (rw) */
    unsigned __sfrbit32 EN46:1;          /**< \brief [14:14] Access Enable for Master TAG ID 46 - EN46 (rw) */
    unsigned __sfrbit32 EN47:1;          /**< \brief [15:15] Access Enable for Master TAG ID 47 - EN47 (rw) */
    unsigned __sfrbit32 EN48:1;          /**< \brief [16:16] Access Enable for Master TAG ID 48 - EN48 (rw) */
    unsigned __sfrbit32 EN49:1;          /**< \brief [17:17] Access Enable for Master TAG ID 49 - EN49 (rw) */
    unsigned __sfrbit32 EN50:1;          /**< \brief [18:18] Access Enable for Master TAG ID 50 - EN50 (rw) */
    unsigned __sfrbit32 EN51:1;          /**< \brief [19:19] Access Enable for Master TAG ID 51 - EN51 (rw) */
    unsigned __sfrbit32 EN52:1;          /**< \brief [20:20] Access Enable for Master TAG ID 52 - EN52 (rw) */
    unsigned __sfrbit32 EN53:1;          /**< \brief [21:21] Access Enable for Master TAG ID 53 - EN53 (rw) */
    unsigned __sfrbit32 EN54:1;          /**< \brief [22:22] Access Enable for Master TAG ID 54 - EN54 (rw) */
    unsigned __sfrbit32 EN55:1;          /**< \brief [23:23] Access Enable for Master TAG ID 55 - EN55 (rw) */
    unsigned __sfrbit32 EN56:1;          /**< \brief [24:24] Access Enable for Master TAG ID 56 - EN56 (rw) */
    unsigned __sfrbit32 EN57:1;          /**< \brief [25:25] Access Enable for Master TAG ID 57 - EN57 (rw) */
    unsigned __sfrbit32 EN58:1;          /**< \brief [26:26] Access Enable for Master TAG ID 58 - EN58 (rw) */
    unsigned __sfrbit32 EN59:1;          /**< \brief [27:27] Access Enable for Master TAG ID 59 - EN59 (rw) */
    unsigned __sfrbit32 EN60:1;          /**< \brief [28:28] Access Enable for Master TAG ID 60 - EN60 (rw) */
    unsigned __sfrbit32 EN61:1;          /**< \brief [29:29] Access Enable for Master TAG ID 61 - EN61 (rw) */
    unsigned __sfrbit32 EN62:1;          /**< \brief [30:30] Access Enable for Master TAG ID 62 - EN62 (rw) */
    unsigned __sfrbit32 EN63:1;          /**< \brief [31:31] Access Enable for Master TAG ID 63 - EN63 (rw) */
} Ifx_CPU_RGN_ACCENB_Bits;

/** \brief CPUx Safety Protection SPR Region Lower Address Register ${i} */
typedef struct _Ifx_CPU_RGN_LA_Bits
{
    unsigned __sfrbit32 reserved_0:5;    /**< \brief [4:0] \internal Reserved */
    unsigned __sfrbit32 ADDR:27;         /**< \brief [31:5] Region Lower Address - ADDR (rw) */
} Ifx_CPU_RGN_LA_Bits;

/** \brief CPUx Safety Protection SPR Region Upper Address Register ${i} */
typedef struct _Ifx_CPU_RGN_UA_Bits
{
    unsigned __sfrbit32 reserved_0:5;    /**< \brief [4:0] \internal Reserved */
    unsigned __sfrbit32 ADDR:27;         /**< \brief [31:5] Region Upper Address - ADDR (rw) */
} Ifx_CPU_RGN_UA_Bits;

/** \brief CPUx SRI Error Generation Register */
typedef struct _Ifx_CPU_SEGEN_Bits
{
    unsigned __sfrbit32 ADFLIP:8;        /**< \brief [7:0] Address ECC Bit Flip - ADFLIP (rw) */
    unsigned __sfrbit32 ADTYPE:2;        /**< \brief [9:8] Type of error - ADTYPE (rw) */
    unsigned __sfrbit32 reserved_10:21;    /**< \brief [30:10] \internal Reserved */
    unsigned __sfrbit32 AE:1;            /**< \brief [31:31] Activate Error Enable - AE (rwh) */
} Ifx_CPU_SEGEN_Bits;

/** \brief CPUx Safety Protection Register Access Enable Register A */
typedef struct _Ifx_CPU_SFR_SPROT_ACCENA_W_Bits
{
    unsigned __sfrbit32 EN0:1;           /**< \brief [0:0] Access Enable for Master TAG ID 0 - EN0 (rw) */
    unsigned __sfrbit32 EN1:1;           /**< \brief [1:1] Access Enable for Master TAG ID 1 - EN1 (rw) */
    unsigned __sfrbit32 EN2:1;           /**< \brief [2:2] Access Enable for Master TAG ID 2 - EN2 (rw) */
    unsigned __sfrbit32 EN3:1;           /**< \brief [3:3] Access Enable for Master TAG ID 3 - EN3 (rw) */
    unsigned __sfrbit32 EN4:1;           /**< \brief [4:4] Access Enable for Master TAG ID 4 - EN4 (rw) */
    unsigned __sfrbit32 EN5:1;           /**< \brief [5:5] Access Enable for Master TAG ID 5 - EN5 (rw) */
    unsigned __sfrbit32 EN6:1;           /**< \brief [6:6] Access Enable for Master TAG ID 6 - EN6 (rw) */
    unsigned __sfrbit32 EN7:1;           /**< \brief [7:7] Access Enable for Master TAG ID 7 - EN7 (rw) */
    unsigned __sfrbit32 EN8:1;           /**< \brief [8:8] Access Enable for Master TAG ID 8 - EN8 (rw) */
    unsigned __sfrbit32 EN9:1;           /**< \brief [9:9] Access Enable for Master TAG ID 9 - EN9 (rw) */
    unsigned __sfrbit32 EN10:1;          /**< \brief [10:10] Access Enable for Master TAG ID 10 - EN10 (rw) */
    unsigned __sfrbit32 EN11:1;          /**< \brief [11:11] Access Enable for Master TAG ID 11 - EN11 (rw) */
    unsigned __sfrbit32 EN12:1;          /**< \brief [12:12] Access Enable for Master TAG ID 12 - EN12 (rw) */
    unsigned __sfrbit32 EN13:1;          /**< \brief [13:13] Access Enable for Master TAG ID 13 - EN13 (rw) */
    unsigned __sfrbit32 EN14:1;          /**< \brief [14:14] Access Enable for Master TAG ID 14 - EN14 (rw) */
    unsigned __sfrbit32 EN15:1;          /**< \brief [15:15] Access Enable for Master TAG ID 15 - EN15 (rw) */
    unsigned __sfrbit32 EN16:1;          /**< \brief [16:16] Access Enable for Master TAG ID 16 - EN16 (rw) */
    unsigned __sfrbit32 EN17:1;          /**< \brief [17:17] Access Enable for Master TAG ID 17 - EN17 (rw) */
    unsigned __sfrbit32 EN18:1;          /**< \brief [18:18] Access Enable for Master TAG ID 18 - EN18 (rw) */
    unsigned __sfrbit32 EN19:1;          /**< \brief [19:19] Access Enable for Master TAG ID 19 - EN19 (rw) */
    unsigned __sfrbit32 EN20:1;          /**< \brief [20:20] Access Enable for Master TAG ID 20 - EN20 (rw) */
    unsigned __sfrbit32 EN21:1;          /**< \brief [21:21] Access Enable for Master TAG ID 21 - EN21 (rw) */
    unsigned __sfrbit32 EN22:1;          /**< \brief [22:22] Access Enable for Master TAG ID 22 - EN22 (rw) */
    unsigned __sfrbit32 EN23:1;          /**< \brief [23:23] Access Enable for Master TAG ID 23 - EN23 (rw) */
    unsigned __sfrbit32 EN24:1;          /**< \brief [24:24] Access Enable for Master TAG ID 24 - EN24 (rw) */
    unsigned __sfrbit32 EN25:1;          /**< \brief [25:25] Access Enable for Master TAG ID 25 - EN25 (rw) */
    unsigned __sfrbit32 EN26:1;          /**< \brief [26:26] Access Enable for Master TAG ID 26 - EN26 (rw) */
    unsigned __sfrbit32 EN27:1;          /**< \brief [27:27] Access Enable for Master TAG ID 27 - EN27 (rw) */
    unsigned __sfrbit32 EN28:1;          /**< \brief [28:28] Access Enable for Master TAG ID 28 - EN28 (rw) */
    unsigned __sfrbit32 EN29:1;          /**< \brief [29:29] Access Enable for Master TAG ID 29 - EN29 (rw) */
    unsigned __sfrbit32 EN30:1;          /**< \brief [30:30] Access Enable for Master TAG ID 30 - EN30 (rw) */
    unsigned __sfrbit32 EN31:1;          /**< \brief [31:31] Access Enable for Master TAG ID 31 - EN31 (rw) */
} Ifx_CPU_SFR_SPROT_ACCENA_W_Bits;

/** \brief CPUx Safety Protection Region Access Enable Register B */
typedef struct _Ifx_CPU_SFR_SPROT_ACCENB_W_Bits
{
    unsigned __sfrbit32 EN32:1;          /**< \brief [0:0] Access Enable for Master TAG ID 32 - EN32 (rw) */
    unsigned __sfrbit32 EN33:1;          /**< \brief [1:1] Access Enable for Master TAG ID 33 - EN33 (rw) */
    unsigned __sfrbit32 EN34:1;          /**< \brief [2:2] Access Enable for Master TAG ID 34 - EN34 (rw) */
    unsigned __sfrbit32 EN35:1;          /**< \brief [3:3] Access Enable for Master TAG ID 35 - EN35 (rw) */
    unsigned __sfrbit32 EN36:1;          /**< \brief [4:4] Access Enable for Master TAG ID 36 - EN36 (rw) */
    unsigned __sfrbit32 EN37:1;          /**< \brief [5:5] Access Enable for Master TAG ID 37 - EN37 (rw) */
    unsigned __sfrbit32 EN38:1;          /**< \brief [6:6] Access Enable for Master TAG ID 38 - EN38 (rw) */
    unsigned __sfrbit32 EN39:1;          /**< \brief [7:7] Access Enable for Master TAG ID 39 - EN39 (rw) */
    unsigned __sfrbit32 EN40:1;          /**< \brief [8:8] Access Enable for Master TAG ID 40 - EN40 (rw) */
    unsigned __sfrbit32 EN41:1;          /**< \brief [9:9] Access Enable for Master TAG ID 41 - EN41 (rw) */
    unsigned __sfrbit32 EN42:1;          /**< \brief [10:10] Access Enable for Master TAG ID 42 - EN42 (rw) */
    unsigned __sfrbit32 EN43:1;          /**< \brief [11:11] Access Enable for Master TAG ID 43 - EN43 (rw) */
    unsigned __sfrbit32 EN44:1;          /**< \brief [12:12] Access Enable for Master TAG ID 44 - EN44 (rw) */
    unsigned __sfrbit32 EN45:1;          /**< \brief [13:13] Access Enable for Master TAG ID 45 - EN45 (rw) */
    unsigned __sfrbit32 EN46:1;          /**< \brief [14:14] Access Enable for Master TAG ID 46 - EN46 (rw) */
    unsigned __sfrbit32 EN47:1;          /**< \brief [15:15] Access Enable for Master TAG ID 47 - EN47 (rw) */
    unsigned __sfrbit32 EN48:1;          /**< \brief [16:16] Access Enable for Master TAG ID 48 - EN48 (rw) */
    unsigned __sfrbit32 EN49:1;          /**< \brief [17:17] Access Enable for Master TAG ID 49 - EN49 (rw) */
    unsigned __sfrbit32 EN50:1;          /**< \brief [18:18] Access Enable for Master TAG ID 50 - EN50 (rw) */
    unsigned __sfrbit32 EN51:1;          /**< \brief [19:19] Access Enable for Master TAG ID 51 - EN51 (rw) */
    unsigned __sfrbit32 EN52:1;          /**< \brief [20:20] Access Enable for Master TAG ID 52 - EN52 (rw) */
    unsigned __sfrbit32 EN53:1;          /**< \brief [21:21] Access Enable for Master TAG ID 53 - EN53 (rw) */
    unsigned __sfrbit32 EN54:1;          /**< \brief [22:22] Access Enable for Master TAG ID 54 - EN54 (rw) */
    unsigned __sfrbit32 EN55:1;          /**< \brief [23:23] Access Enable for Master TAG ID 55 - EN55 (rw) */
    unsigned __sfrbit32 EN56:1;          /**< \brief [24:24] Access Enable for Master TAG ID 56 - EN56 (rw) */
    unsigned __sfrbit32 EN57:1;          /**< \brief [25:25] Access Enable for Master TAG ID 57 - EN57 (rw) */
    unsigned __sfrbit32 EN58:1;          /**< \brief [26:26] Access Enable for Master TAG ID 58 - EN58 (rw) */
    unsigned __sfrbit32 EN59:1;          /**< \brief [27:27] Access Enable for Master TAG ID 59 - EN59 (rw) */
    unsigned __sfrbit32 EN60:1;          /**< \brief [28:28] Access Enable for Master TAG ID 60 - EN60 (rw) */
    unsigned __sfrbit32 EN61:1;          /**< \brief [29:29] Access Enable for Master TAG ID 61 - EN61 (rw) */
    unsigned __sfrbit32 EN62:1;          /**< \brief [30:30] Access Enable for Master TAG ID 62 - EN62 (rw) */
    unsigned __sfrbit32 EN63:1;          /**< \brief [31:31] Access Enable for Master TAG ID 63 - EN63 (rw) */
} Ifx_CPU_SFR_SPROT_ACCENB_W_Bits;

/** \brief CPUx SIST Mode Access Control Register */
typedef struct _Ifx_CPU_SMACON_Bits
{
    unsigned __sfrbit32 reserved_0:24;    /**< \brief [23:0] \internal Reserved */
    unsigned __sfrbit32 IODT:1;          /**< \brief [24:24] In-Order Data Transactions - IODT (rw) */
    unsigned __sfrbit32 reserved_25:7;    /**< \brief [31:25] \internal Reserved */
} Ifx_CPU_SMACON_Bits;

/** \brief CPUx Safety Protection SPR Region Read Access Enable Register A${i} */
typedef struct _Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits
{
    unsigned __sfrbit32 EN0:1;           /**< \brief [0:0] Access Enable for Master TAG ID 0 - EN0 (rw) */
    unsigned __sfrbit32 EN1:1;           /**< \brief [1:1] Access Enable for Master TAG ID 1 - EN1 (rw) */
    unsigned __sfrbit32 EN2:1;           /**< \brief [2:2] Access Enable for Master TAG ID 2 - EN2 (rw) */
    unsigned __sfrbit32 EN3:1;           /**< \brief [3:3] Access Enable for Master TAG ID 3 - EN3 (rw) */
    unsigned __sfrbit32 EN4:1;           /**< \brief [4:4] Access Enable for Master TAG ID 4 - EN4 (rw) */
    unsigned __sfrbit32 EN5:1;           /**< \brief [5:5] Access Enable for Master TAG ID 5 - EN5 (rw) */
    unsigned __sfrbit32 EN6:1;           /**< \brief [6:6] Access Enable for Master TAG ID 6 - EN6 (rw) */
    unsigned __sfrbit32 EN7:1;           /**< \brief [7:7] Access Enable for Master TAG ID 7 - EN7 (rw) */
    unsigned __sfrbit32 EN8:1;           /**< \brief [8:8] Access Enable for Master TAG ID 8 - EN8 (rw) */
    unsigned __sfrbit32 EN9:1;           /**< \brief [9:9] Access Enable for Master TAG ID 9 - EN9 (rw) */
    unsigned __sfrbit32 EN10:1;          /**< \brief [10:10] Access Enable for Master TAG ID 10 - EN10 (rw) */
    unsigned __sfrbit32 EN11:1;          /**< \brief [11:11] Access Enable for Master TAG ID 11 - EN11 (rw) */
    unsigned __sfrbit32 EN12:1;          /**< \brief [12:12] Access Enable for Master TAG ID 12 - EN12 (rw) */
    unsigned __sfrbit32 EN13:1;          /**< \brief [13:13] Access Enable for Master TAG ID 13 - EN13 (rw) */
    unsigned __sfrbit32 EN14:1;          /**< \brief [14:14] Access Enable for Master TAG ID 14 - EN14 (rw) */
    unsigned __sfrbit32 EN15:1;          /**< \brief [15:15] Access Enable for Master TAG ID 15 - EN15 (rw) */
    unsigned __sfrbit32 EN16:1;          /**< \brief [16:16] Access Enable for Master TAG ID 16 - EN16 (rw) */
    unsigned __sfrbit32 EN17:1;          /**< \brief [17:17] Access Enable for Master TAG ID 17 - EN17 (rw) */
    unsigned __sfrbit32 EN18:1;          /**< \brief [18:18] Access Enable for Master TAG ID 18 - EN18 (rw) */
    unsigned __sfrbit32 EN19:1;          /**< \brief [19:19] Access Enable for Master TAG ID 19 - EN19 (rw) */
    unsigned __sfrbit32 EN20:1;          /**< \brief [20:20] Access Enable for Master TAG ID 20 - EN20 (rw) */
    unsigned __sfrbit32 EN21:1;          /**< \brief [21:21] Access Enable for Master TAG ID 21 - EN21 (rw) */
    unsigned __sfrbit32 EN22:1;          /**< \brief [22:22] Access Enable for Master TAG ID 22 - EN22 (rw) */
    unsigned __sfrbit32 EN23:1;          /**< \brief [23:23] Access Enable for Master TAG ID 23 - EN23 (rw) */
    unsigned __sfrbit32 EN24:1;          /**< \brief [24:24] Access Enable for Master TAG ID 24 - EN24 (rw) */
    unsigned __sfrbit32 EN25:1;          /**< \brief [25:25] Access Enable for Master TAG ID 25 - EN25 (rw) */
    unsigned __sfrbit32 EN26:1;          /**< \brief [26:26] Access Enable for Master TAG ID 26 - EN26 (rw) */
    unsigned __sfrbit32 EN27:1;          /**< \brief [27:27] Access Enable for Master TAG ID 27 - EN27 (rw) */
    unsigned __sfrbit32 EN28:1;          /**< \brief [28:28] Access Enable for Master TAG ID 28 - EN28 (rw) */
    unsigned __sfrbit32 EN29:1;          /**< \brief [29:29] Access Enable for Master TAG ID 29 - EN29 (rw) */
    unsigned __sfrbit32 EN30:1;          /**< \brief [30:30] Access Enable for Master TAG ID 30 - EN30 (rw) */
    unsigned __sfrbit32 EN31:1;          /**< \brief [31:31] Access Enable for Master TAG ID 31 - EN31 (rw) */
} Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits;

/** \brief CPUx Safety Protection SPR Region Read Access Enable Register B${i} */
typedef struct _Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits
{
    unsigned __sfrbit32 EN32:1;          /**< \brief [0:0] Access Enable for Master TAG ID 32 - EN32 (rw) */
    unsigned __sfrbit32 EN33:1;          /**< \brief [1:1] Access Enable for Master TAG ID 33 - EN33 (rw) */
    unsigned __sfrbit32 EN34:1;          /**< \brief [2:2] Access Enable for Master TAG ID 34 - EN34 (rw) */
    unsigned __sfrbit32 EN35:1;          /**< \brief [3:3] Access Enable for Master TAG ID 35 - EN35 (rw) */
    unsigned __sfrbit32 EN36:1;          /**< \brief [4:4] Access Enable for Master TAG ID 36 - EN36 (rw) */
    unsigned __sfrbit32 EN37:1;          /**< \brief [5:5] Access Enable for Master TAG ID 37 - EN37 (rw) */
    unsigned __sfrbit32 EN38:1;          /**< \brief [6:6] Access Enable for Master TAG ID 38 - EN38 (rw) */
    unsigned __sfrbit32 EN39:1;          /**< \brief [7:7] Access Enable for Master TAG ID 39 - EN39 (rw) */
    unsigned __sfrbit32 EN40:1;          /**< \brief [8:8] Access Enable for Master TAG ID 40 - EN40 (rw) */
    unsigned __sfrbit32 EN41:1;          /**< \brief [9:9] Access Enable for Master TAG ID 41 - EN41 (rw) */
    unsigned __sfrbit32 EN42:1;          /**< \brief [10:10] Access Enable for Master TAG ID 42 - EN42 (rw) */
    unsigned __sfrbit32 EN43:1;          /**< \brief [11:11] Access Enable for Master TAG ID 43 - EN43 (rw) */
    unsigned __sfrbit32 EN44:1;          /**< \brief [12:12] Access Enable for Master TAG ID 44 - EN44 (rw) */
    unsigned __sfrbit32 EN45:1;          /**< \brief [13:13] Access Enable for Master TAG ID 45 - EN45 (rw) */
    unsigned __sfrbit32 EN46:1;          /**< \brief [14:14] Access Enable for Master TAG ID 46 - EN46 (rw) */
    unsigned __sfrbit32 EN47:1;          /**< \brief [15:15] Access Enable for Master TAG ID 47 - EN47 (rw) */
    unsigned __sfrbit32 EN48:1;          /**< \brief [16:16] Access Enable for Master TAG ID 48 - EN48 (rw) */
    unsigned __sfrbit32 EN49:1;          /**< \brief [17:17] Access Enable for Master TAG ID 49 - EN49 (rw) */
    unsigned __sfrbit32 EN50:1;          /**< \brief [18:18] Access Enable for Master TAG ID 50 - EN50 (rw) */
    unsigned __sfrbit32 EN51:1;          /**< \brief [19:19] Access Enable for Master TAG ID 51 - EN51 (rw) */
    unsigned __sfrbit32 EN52:1;          /**< \brief [20:20] Access Enable for Master TAG ID 52 - EN52 (rw) */
    unsigned __sfrbit32 EN53:1;          /**< \brief [21:21] Access Enable for Master TAG ID 53 - EN53 (rw) */
    unsigned __sfrbit32 EN54:1;          /**< \brief [22:22] Access Enable for Master TAG ID 54 - EN54 (rw) */
    unsigned __sfrbit32 EN55:1;          /**< \brief [23:23] Access Enable for Master TAG ID 55 - EN55 (rw) */
    unsigned __sfrbit32 EN56:1;          /**< \brief [24:24] Access Enable for Master TAG ID 56 - EN56 (rw) */
    unsigned __sfrbit32 EN57:1;          /**< \brief [25:25] Access Enable for Master TAG ID 57 - EN57 (rw) */
    unsigned __sfrbit32 EN58:1;          /**< \brief [26:26] Access Enable for Master TAG ID 58 - EN58 (rw) */
    unsigned __sfrbit32 EN59:1;          /**< \brief [27:27] Access Enable for Master TAG ID 59 - EN59 (rw) */
    unsigned __sfrbit32 EN60:1;          /**< \brief [28:28] Access Enable for Master TAG ID 60 - EN60 (rw) */
    unsigned __sfrbit32 EN61:1;          /**< \brief [29:29] Access Enable for Master TAG ID 61 - EN61 (rw) */
    unsigned __sfrbit32 EN62:1;          /**< \brief [30:30] Access Enable for Master TAG ID 62 - EN62 (rw) */
    unsigned __sfrbit32 EN63:1;          /**< \brief [31:31] Access Enable for Master TAG ID 63 - EN63 (rw) */
} Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits;

/** \brief CPUx Software Debug Event */
typedef struct _Ifx_CPU_SWEVT_Bits
{
    unsigned __sfrbit32 EVTA:3;          /**< \brief [2:0] Event Associated - EVTA (rw) */
    unsigned __sfrbit32 BBM:1;           /**< \brief [3:3] Break Before Make (BBM) or Break After Make (BAM) Selection - BBM (rw) */
    unsigned __sfrbit32 BOD:1;           /**< \brief [4:4] Breakout Disable - BOD (rw) */
    unsigned __sfrbit32 SUSP:1;          /**< \brief [5:5] CDC Suspend-Out Signal State - SUSP (rw) */
    unsigned __sfrbit32 CNT:2;           /**< \brief [7:6] Counter - CNT (rw) */
    unsigned __sfrbit32 reserved_8:24;    /**< \brief [31:8] \internal Reserved */
} Ifx_CPU_SWEVT_Bits;

/** \brief CPUx System Configuration Register */
typedef struct _Ifx_CPU_SYSCON_Bits
{
    unsigned __sfrbit32 FCDSF:1;         /**< \brief [0:0] Free Context List Depleted Sticky Flag - FCDSF (rwh) */
    unsigned __sfrbit32 PROTEN:1;        /**< \brief [1:1] Memory Protection Enable - PROTEN (rw) */
    unsigned __sfrbit32 TPROTEN:1;       /**< \brief [2:2] Temporal Protection Enable - TPROTEN (rw) */
    unsigned __sfrbit32 IS:1;            /**< \brief [3:3] Initial State Interrupt - IS (rw) */
    unsigned __sfrbit32 TS:1;            /**< \brief [4:4] Initial State Trap - TS (rw) */
    unsigned __sfrbit32 reserved_5:3;    /**< \brief [7:5] \internal Reserved */
    unsigned __sfrbit32 ESDIS:1;         /**< \brief [8:8] Emulator Space Disable (rw) */
    unsigned __sfrbit32 reserved_9:7;    /**< \brief [15:9] \internal Reserved */
    unsigned __sfrbit32 U1_IED:1;        /**< \brief [16:16] User-1 Instruction execution disable - U1_IED (rw) */
    unsigned __sfrbit32 U1_IOS:1;        /**< \brief [17:17] User-1 Peripheral access as supervisor - U1_IOS (rw) */
    unsigned __sfrbit32 reserved_18:6;    /**< \brief [23:18] \internal Reserved */
    unsigned __sfrbit32 BHALT:1;         /**< \brief [24:24] Boot Halt - BHALT (rw) */
    unsigned __sfrbit32 reserved_25:7;    /**< \brief [31:25] \internal Reserved */
} Ifx_CPU_SYSCON_Bits;

/** \brief CPUx Task Address Space Identifier Register */
typedef struct _Ifx_CPU_TASK_ASI_Bits
{
    unsigned __sfrbit32 ASI:5;           /**< \brief [4:0] Address Space Identifier - ASI (rw) */
    unsigned __sfrbit32 reserved_5:27;    /**< \brief [31:5] \internal Reserved */
} Ifx_CPU_TASK_ASI_Bits;

/** \brief CPUx Temporal Protection System Control Register */
typedef struct _Ifx_CPU_TPS_CON_Bits
{
    unsigned __sfrbit32 TEXP0:1;         /**< \brief [0:0] Timer0 Expired Flag - TEXP0 (rh) */
    unsigned __sfrbit32 TEXP1:1;         /**< \brief [1:1] Timer1 Expired Flag - TEXP1 (rh) */
    unsigned __sfrbit32 TEXP2:1;         /**< \brief [2:2] Timer1 Expired Flag - TEXP2 (rh) */
    unsigned __sfrbit32 reserved_3:13;    /**< \brief [15:3] \internal Reserved */
    unsigned __sfrbit32 TTRAP:1;         /**< \brief [16:16] Temporal Protection Trap - TTRAP (rh) */
    unsigned __sfrbit32 reserved_17:15;    /**< \brief [31:17] \internal Reserved */
} Ifx_CPU_TPS_CON_Bits;

/** \brief CPUx Exception Timer Class Enable Register */
typedef struct _Ifx_CPU_TPS_EXTIM_CLASS_EN_Bits
{
    unsigned __sfrbit32 EXTIM_CLASS_EN:8;    /**< \brief [7:0] Exception Timer Class Enables - EXTIM_CLASS_EN (rw) */
    unsigned __sfrbit32 reserved_8:24;    /**< \brief [31:8] \internal Reserved */
} Ifx_CPU_TPS_EXTIM_CLASS_EN_Bits;

/** \brief CPUx Exception Entry Timer Current Value */
typedef struct _Ifx_CPU_TPS_EXTIM_ENTRY_CVAL_Bits
{
    unsigned __sfrbit32 ENTRY_CVAL:12;    /**< \brief [11:0] Exception Entry Timer Current Value - ENTRY_CVAL (rh) */
    unsigned __sfrbit32 reserved_12:20;    /**< \brief [31:12] \internal Reserved */
} Ifx_CPU_TPS_EXTIM_ENTRY_CVAL_Bits;

/** \brief CPUx Exception Entry Timer Load Value */
typedef struct _Ifx_CPU_TPS_EXTIM_ENTRY_LVAL_Bits
{
    unsigned __sfrbit32 reserved_0:4;    /**< \brief [3:0] \internal Reserved */
    unsigned __sfrbit32 ENTRY_LVAL:8;    /**< \brief [11:4] Exception Entry Timer Load value - ENTRY_LVAL (rw) */
    unsigned __sfrbit32 reserved_12:20;    /**< \brief [31:12] \internal Reserved */
} Ifx_CPU_TPS_EXTIM_ENTRY_LVAL_Bits;

/** \brief CPUx Exception Exit Timer Current Value */
typedef struct _Ifx_CPU_TPS_EXTIM_EXIT_CVAL_Bits
{
    unsigned __sfrbit32 EXIT_CVAL:24;    /**< \brief [23:0] Exception Exit Timer Current Value - EXIT_CVAL (rh) */
    unsigned __sfrbit32 reserved_24:8;    /**< \brief [31:24] \internal Reserved */
} Ifx_CPU_TPS_EXTIM_EXIT_CVAL_Bits;

/** \brief CPUx Exception Exit  Timer Load Value */
typedef struct _Ifx_CPU_TPS_EXTIM_EXIT_LVAL_Bits
{
    unsigned __sfrbit32 reserved_0:4;    /**< \brief [3:0] \internal Reserved */
    unsigned __sfrbit32 EXIT_LVAL:20;    /**< \brief [23:4] Exception Exit Timer Load value - EXIT_LVAL (rw) */
    unsigned __sfrbit32 reserved_24:8;    /**< \brief [31:24] \internal Reserved */
} Ifx_CPU_TPS_EXTIM_EXIT_LVAL_Bits;

/** \brief CPUx Exception Timer FCX Register */
typedef struct _Ifx_CPU_TPS_EXTIM_FCX_Bits
{
    unsigned __sfrbit32 EXIT_FCX:20;     /**< \brief [19:0] Exception Exit Timer FCX - EXIT_FCX (rh) */
    unsigned __sfrbit32 reserved_20:12;    /**< \brief [31:20] \internal Reserved */
} Ifx_CPU_TPS_EXTIM_FCX_Bits;

/** \brief CPUx Exception Timer Status Register */
typedef struct _Ifx_CPU_TPS_EXTIM_STAT_Bits
{
    unsigned __sfrbit32 EXIT_TIN:8;      /**< \brief [7:0] Exception Exit Timer TIN - EXIT_TIN (rwh) */
    unsigned __sfrbit32 EXIT_CLASS:3;    /**< \brief [10:8] Exception Exit Timer Class - EXIT_CLASS (rwh) */
    unsigned __sfrbit32 reserved_11:4;    /**< \brief [14:11] \internal Reserved */
    unsigned __sfrbit32 EXIT_AT:1;       /**< \brief [15:15] Exception Exit Timer Alarm Triggered - EXIT_AT (rh) */
    unsigned __sfrbit32 ENTRY_TIN:8;     /**< \brief [23:16] Exception Entry Timer TIN - ENTRY_TIN (rwh) */
    unsigned __sfrbit32 ENTRY_CLASS:3;    /**< \brief [26:24] Exception Entry Timer Class - ENTRY_CLASS (rwh) */
    unsigned __sfrbit32 reserved_27:4;    /**< \brief [30:27] \internal Reserved */
    unsigned __sfrbit32 ENTRY_AT:1;      /**< \brief [31:31] Exception Entry Timer Alarm Triggered - ENTRY_AT (rh) */
} Ifx_CPU_TPS_EXTIM_STAT_Bits;

/** \brief CPUx Temporal Protection System Timer Register ${y} */
typedef struct _Ifx_CPU_TPS_TIMER_Bits
{
    unsigned __sfrbit32 TIMER:32;        /**< \brief [31:0] Temporal Protection Timer - Timer (rwh) */
} Ifx_CPU_TPS_TIMER_Bits;

/** \brief CPUx TriggerAddressx */
typedef struct _Ifx_CPU_TRIG_ACC_Bits
{
    unsigned __sfrbit32 T0:1;            /**< \brief [0:0] Trigger-0 - T0 (rh) */
    unsigned __sfrbit32 T1:1;            /**< \brief [1:1] Trigger-1 - T1 (rh) */
    unsigned __sfrbit32 T2:1;            /**< \brief [2:2] Trigger-2 - T2 (rh) */
    unsigned __sfrbit32 T3:1;            /**< \brief [3:3] Trigger-3 - T3 (rh) */
    unsigned __sfrbit32 T4:1;            /**< \brief [4:4] Trigger-4 - T4 (rh) */
    unsigned __sfrbit32 T5:1;            /**< \brief [5:5] Trigger-5 - T5 (rh) */
    unsigned __sfrbit32 T6:1;            /**< \brief [6:6] Trigger-6 - T6 (rh) */
    unsigned __sfrbit32 T7:1;            /**< \brief [7:7] Trigger-7 - T7 (rh) */
    unsigned __sfrbit32 reserved_8:24;    /**< \brief [31:8] \internal Reserved */
} Ifx_CPU_TRIG_ACC_Bits;

/** \brief CPUx Trigger Address ${i} */
typedef struct _Ifx_CPU_TR_ADR_Bits
{
    unsigned __sfrbit32 ADDR:32;         /**< \brief [31:0] Comparison Address - ADDR (rw) */
} Ifx_CPU_TR_ADR_Bits;

/** \brief CPUx Trigger Event ${i} */
typedef struct _Ifx_CPU_TR_EVT_Bits
{
    unsigned __sfrbit32 EVTA:3;          /**< \brief [2:0] Event Associated - EVTA (rw) */
    unsigned __sfrbit32 BBM:1;           /**< \brief [3:3] Break Before Make (BBM) or Break After Make (BAM) Selection - BBM (rw) */
    unsigned __sfrbit32 BOD:1;           /**< \brief [4:4] Breakout Disable - BOD (rw) */
    unsigned __sfrbit32 SUSP:1;          /**< \brief [5:5] CDC Suspend-Out Signal State - SUSP (rw) */
    unsigned __sfrbit32 CNT:2;           /**< \brief [7:6] Counter - CNT (rw) */
    unsigned __sfrbit32 reserved_8:4;    /**< \brief [11:8] \internal Reserved */
    unsigned __sfrbit32 TYP:1;           /**< \brief [12:12] Input Selection - TYP (rw) */
    unsigned __sfrbit32 RNG:1;           /**< \brief [13:13] Compare Type - RNG (rw) */
    unsigned __sfrbit32 reserved_14:1;    /**< \brief [14:14] \internal Reserved */
    unsigned __sfrbit32 ASI_EN:1;        /**< \brief [15:15] Enable ASI Comparison - ASI_EN (rw) */
    unsigned __sfrbit32 ASI:5;           /**< \brief [20:16] Address Space Identifier - ASI (rw) */
    unsigned __sfrbit32 reserved_21:6;    /**< \brief [26:21] \internal Reserved */
    unsigned __sfrbit32 AST:1;           /**< \brief [27:27] Address Store - AST (rw) */
    unsigned __sfrbit32 ALD:1;           /**< \brief [28:28] Address Load - ALD (rw) */
    unsigned __sfrbit32 reserved_29:3;    /**< \brief [31:29] \internal Reserved */
} Ifx_CPU_TR_EVT_Bits;

/** \}  */
/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_cpu_Registers_union
 * \{   */
/** \brief CPUx Address General Purpose Register ${y}   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_A_Bits B;                 /**< \brief Bitfield access */
} Ifx_CPU_A;

/** \brief CPUx Base Interrupt Vector Table Pointer   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_BIV_Bits B;               /**< \brief Bitfield access */
} Ifx_CPU_BIV;

/** \brief CPUx Overlay Mask Register ${i}   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_BLK_OMASK_Bits B;         /**< \brief Bitfield access */
} Ifx_CPU_BLK_OMASK;

/** \brief CPUx Overlay Target Address Register ${i}   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_BLK_OTAR_Bits B;          /**< \brief Bitfield access */
} Ifx_CPU_BLK_OTAR;

/** \brief CPUx Redirected Address Base Register ${i}   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_BLK_RABR_Bits B;          /**< \brief Bitfield access */
} Ifx_CPU_BLK_RABR;

/** \brief CPUx Base Trap Vector Table Pointer   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_BTV_Bits B;               /**< \brief Bitfield access */
} Ifx_CPU_BTV;

/** \brief CPUx CPU Clock Cycle Count   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_CCNT_Bits B;              /**< \brief Bitfield access */
} Ifx_CPU_CCNT;

/** \brief CPUx Counter Control   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_CCTRL_Bits B;             /**< \brief Bitfield access */
} Ifx_CPU_CCTRL;

/** \brief CPUx Compatibility Control Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_COMPAT_Bits B;            /**< \brief Bitfield access */
} Ifx_CPU_COMPAT;

/** \brief CPUx Core Identification Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_CORE_ID_Bits B;           /**< \brief Bitfield access */
} Ifx_CPU_CORE_ID;

/** \brief CPUx Code Protection Range ${y} Lower Bound Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_CPR_L_Bits B;             /**< \brief Bitfield access */
} Ifx_CPU_CPR_L;

/** \brief CPUx Code Protection Range ${y} Upper Bound Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_CPR_U_Bits B;             /**< \brief Bitfield access */
} Ifx_CPU_CPR_U;

/** \brief CPUx Identification Register TC1.6.2P   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_CPU_ID_Bits B;            /**< \brief Bitfield access */
} Ifx_CPU_CPU_ID;

/** \brief    */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_CPXE_Bits B;              /**< \brief Bitfield access */
} Ifx_CPU_CPXE;

/** \brief CPUx Core Register Access Event   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_CREVT_Bits B;             /**< \brief Bitfield access */
} Ifx_CPU_CREVT;

/** \brief CPUx Customer ID register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_CUS_ID_Bits B;            /**< \brief Bitfield access */
} Ifx_CPU_CUS_ID;

/** \brief CPUx Data General Purpose Register ${y}   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_D_Bits B;                 /**< \brief Bitfield access */
} Ifx_CPU_D;

/** \brief CPUx Data Asynchronous Trap Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_DATR_Bits B;              /**< \brief Bitfield access */
} Ifx_CPU_DATR;

/** \brief CPUx Debug Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_DBGSR_Bits B;             /**< \brief Bitfield access */
} Ifx_CPU_DBGSR;

/** \brief CPUx Debug Trap Control Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_DBGTCR_Bits B;            /**< \brief Bitfield access */
} Ifx_CPU_DBGTCR;

/** \brief CPUx Data Memory Control Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_DCON0_Bits B;             /**< \brief Bitfield access */
} Ifx_CPU_DCON0;

/** \brief CPUx Data Control Register 2   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_DCON2_Bits B;             /**< \brief Bitfield access */
} Ifx_CPU_DCON2;

/** \brief CPUx Debug Context Save Area Pointer   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_DCX_Bits B;               /**< \brief Bitfield access */
} Ifx_CPU_DCX;

/** \brief CPUx Data Error Address Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_DEADD_Bits B;             /**< \brief Bitfield access */
} Ifx_CPU_DEADD;

/** \brief CPUx Data Integrity Error Address Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_DIEAR_Bits B;             /**< \brief Bitfield access */
} Ifx_CPU_DIEAR;

/** \brief CPUx Data Integrity Error Trap Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_DIETR_Bits B;             /**< \brief Bitfield access */
} Ifx_CPU_DIETR;

/** \brief CPUx Safety Protection Region DLMU Read Access Enable Register A${i}   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits B;    /**< \brief Bitfield access */
} Ifx_CPU_DLMU_SPROT_RGNACCENA_R;

/** \brief CPUx Safety Protection Region DLMU Write Access Enable Register A${i}   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits B;    /**< \brief Bitfield access */
} Ifx_CPU_DLMU_SPROT_RGNACCENA_W;

/** \brief CPUx Safety Protection Region DLMU Read Access Enable Register B${i}   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits B;    /**< \brief Bitfield access */
} Ifx_CPU_DLMU_SPROT_RGNACCENB_R;

/** \brief CPUx Safety Protection Region DLMU Write Access Enable Register B${i}   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits B;    /**< \brief Bitfield access */
} Ifx_CPU_DLMU_SPROT_RGNACCENB_W;

/** \brief CPUx Safety Protection DLMU Region Lower Address Register ${i}   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_DLMU_SPROT_RGNLA_Bits B;    /**< \brief Bitfield access */
} Ifx_CPU_DLMU_SPROT_RGNLA;

/** \brief CPUx Safety protection DLMU Region Upper Address Register ${i}   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_DLMU_SPROT_RGNUA_Bits B;    /**< \brief Bitfield access */
} Ifx_CPU_DLMU_SPROT_RGNUA;

/** \brief CPUx Debug Monitor Start Address   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_DMS_Bits B;               /**< \brief Bitfield access */
} Ifx_CPU_DMS;

/** \brief    */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_DPRE_Bits B;              /**< \brief Bitfield access */
} Ifx_CPU_DPRE;

/** \brief CPUx Data Protection Range ${y}, Lower Bound Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_DPR_L_Bits B;             /**< \brief Bitfield access */
} Ifx_CPU_DPR_L;

/** \brief CPUx Data Protection Range ${y}, Upper Bound Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_DPR_U_Bits B;             /**< \brief Bitfield access */
} Ifx_CPU_DPR_U;

/** \brief    */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_DPWE_Bits B;              /**< \brief Bitfield access */
} Ifx_CPU_DPWE;

/** \brief CPUx Data Synchronous Trap Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_DSTR_Bits B;              /**< \brief Bitfield access */
} Ifx_CPU_DSTR;

/** \brief CPUx External Event Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_EXEVT_Bits B;             /**< \brief Bitfield access */
} Ifx_CPU_EXEVT;

/** \brief CPUx Free CSA List Head Pointer   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_FCX_Bits B;               /**< \brief Bitfield access */
} Ifx_CPU_FCX;

/** \brief CPUx Flash Configuration Register 0   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_FLASHCON0_Bits B;         /**< \brief Bitfield access */
} Ifx_CPU_FLASHCON0;

/** \brief CPUx Flash Configuration Register 1   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_FLASHCON1_Bits B;         /**< \brief Bitfield access */
} Ifx_CPU_FLASHCON1;

/** \brief CPUx Flash Configuration Register 2   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_FLASHCON2_Bits B;         /**< \brief Bitfield access */
} Ifx_CPU_FLASHCON2;

/** \brief CPUx Flash Configuration Register 3   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_FLASHCON3_Bits B;         /**< \brief Bitfield access */
} Ifx_CPU_FLASHCON3;

/** \brief CPUx Flash Configuration Register 4   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_FLASHCON4_Bits B;         /**< \brief Bitfield access */
} Ifx_CPU_FLASHCON4;

/** \brief CPUx Trap Control Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_FPU_TRAP_CON_Bits B;      /**< \brief Bitfield access */
} Ifx_CPU_FPU_TRAP_CON;

/** \brief CPUx Trapping Instruction Opcode Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_FPU_TRAP_OPC_Bits B;      /**< \brief Bitfield access */
} Ifx_CPU_FPU_TRAP_OPC;

/** \brief CPUx Trapping Instruction Program Counter Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_FPU_TRAP_PC_Bits B;       /**< \brief Bitfield access */
} Ifx_CPU_FPU_TRAP_PC;

/** \brief CPUx Trapping Instruction Operand Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_FPU_TRAP_SRC1_Bits B;     /**< \brief Bitfield access */
} Ifx_CPU_FPU_TRAP_SRC1;

/** \brief CPUx Trapping Instruction Operand Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_FPU_TRAP_SRC2_Bits B;     /**< \brief Bitfield access */
} Ifx_CPU_FPU_TRAP_SRC2;

/** \brief CPUx Trapping Instruction Operand Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_FPU_TRAP_SRC3_Bits B;     /**< \brief Bitfield access */
} Ifx_CPU_FPU_TRAP_SRC3;

/** \brief CPUx Instruction Count   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_ICNT_Bits B;              /**< \brief Bitfield access */
} Ifx_CPU_ICNT;

/** \brief CPUx Interrupt Control Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_ICR_Bits B;               /**< \brief Bitfield access */
} Ifx_CPU_ICR;

/** \brief CPUx Interrupt Stack Pointer   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_ISP_Bits B;               /**< \brief Bitfield access */
} Ifx_CPU_ISP;

/** \brief CPUx  Reset Register 0   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_KRST0_Bits B;             /**< \brief Bitfield access */
} Ifx_CPU_KRST0;

/** \brief CPUx  Reset Register 1   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_KRST1_Bits B;             /**< \brief Bitfield access */
} Ifx_CPU_KRST1;

/** \brief CPUx Reset Clear Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_KRSTCLR_Bits B;           /**< \brief Bitfield access */
} Ifx_CPU_KRSTCLR;

/** \brief CPUx Free CSA List Limit Pointer   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_LCX_Bits B;               /**< \brief Bitfield access */
} Ifx_CPU_LCX;

/** \brief CPUx Safety Protection Region LPB Read Access Enable Register A   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_LPB_SPROT_ACCENA_R_Bits B;    /**< \brief Bitfield access */
} Ifx_CPU_LPB_SPROT_ACCENA_R;

/** \brief CPUx Safety Protection Region LPB Read Access Enable Register B   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_LPB_SPROT_ACCENB_R_Bits B;    /**< \brief Bitfield access */
} Ifx_CPU_LPB_SPROT_ACCENB_R;

/** \brief CPUx Multi-Count Register 1   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_M1CNT_Bits B;             /**< \brief Bitfield access */
} Ifx_CPU_M1CNT;

/** \brief CPUx Multi-Count Register 2   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_M2CNT_Bits B;             /**< \brief Bitfield access */
} Ifx_CPU_M2CNT;

/** \brief CPUx Multi-Count Register 3   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_M3CNT_Bits B;             /**< \brief Bitfield access */
} Ifx_CPU_M3CNT;

/** \brief CPUx  Overlay Range Select Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_OSEL_Bits B;              /**< \brief Bitfield access */
} Ifx_CPU_OSEL;

/** \brief CPUx Program Counter   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_PC_Bits B;                /**< \brief Bitfield access */
} Ifx_CPU_PC;

/** \brief CPUx Program Control 0   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_PCON0_Bits B;             /**< \brief Bitfield access */
} Ifx_CPU_PCON0;

/** \brief CPUx Program Control 1   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_PCON1_Bits B;             /**< \brief Bitfield access */
} Ifx_CPU_PCON1;

/** \brief CPUx Program Control 2   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_PCON2_Bits B;             /**< \brief Bitfield access */
} Ifx_CPU_PCON2;

/** \brief CPUx Previous Context Information Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_PCXI_Bits B;              /**< \brief Bitfield access */
} Ifx_CPU_PCXI;

/** \brief CPUx Program Integrity Error Address Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_PIEAR_Bits B;             /**< \brief Bitfield access */
} Ifx_CPU_PIEAR;

/** \brief CPUx Program Integrity Error Trap Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_PIETR_Bits B;             /**< \brief Bitfield access */
} Ifx_CPU_PIETR;

/** \brief CPUx Data Access CacheabilityRegister   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_PMA0_Bits B;              /**< \brief Bitfield access */
} Ifx_CPU_PMA0;

/** \brief CPUx Code Access CacheabilityRegister   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_PMA1_Bits B;              /**< \brief Bitfield access */
} Ifx_CPU_PMA1;

/** \brief CPUx  Peripheral Space Identifier register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_PMA2_Bits B;              /**< \brief Bitfield access */
} Ifx_CPU_PMA2;

/** \brief CPUx Program Synchronous Trap Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_PSTR_Bits B;              /**< \brief Bitfield access */
} Ifx_CPU_PSTR;

/** \brief CPUx Program Status Word   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_PSW_Bits B;               /**< \brief Bitfield access */
} Ifx_CPU_PSW;

/** \brief CPUx Safety Protection SPR Region Write Access Enable Register A${i}   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_RGN_ACCENA_Bits B;        /**< \brief Bitfield access */
} Ifx_CPU_RGN_ACCENA;

/** \brief CPUx Safety Protection SPR Region Write Access Enable Register B${i}   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_RGN_ACCENB_Bits B;        /**< \brief Bitfield access */
} Ifx_CPU_RGN_ACCENB;

/** \brief CPUx Safety Protection SPR Region Lower Address Register ${i}   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_RGN_LA_Bits B;            /**< \brief Bitfield access */
} Ifx_CPU_RGN_LA;

/** \brief CPUx Safety Protection SPR Region Upper Address Register ${i}   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_RGN_UA_Bits B;            /**< \brief Bitfield access */
} Ifx_CPU_RGN_UA;

/** \brief CPUx SRI Error Generation Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_SEGEN_Bits B;             /**< \brief Bitfield access */
} Ifx_CPU_SEGEN;

/** \brief CPUx Safety Protection Register Access Enable Register A   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_SFR_SPROT_ACCENA_W_Bits B;    /**< \brief Bitfield access */
} Ifx_CPU_SFR_SPROT_ACCENA_W;

/** \brief CPUx Safety Protection Region Access Enable Register B   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_SFR_SPROT_ACCENB_W_Bits B;    /**< \brief Bitfield access */
} Ifx_CPU_SFR_SPROT_ACCENB_W;

/** \brief CPUx SIST Mode Access Control Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_SMACON_Bits B;            /**< \brief Bitfield access */
} Ifx_CPU_SMACON;

/** \brief CPUx Safety Protection SPR Region Read Access Enable Register A${i}   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits B;    /**< \brief Bitfield access */
} Ifx_CPU_SPR_SPROT_RGNACCENA_R;

/** \brief CPUx Safety Protection SPR Region Read Access Enable Register B${i}   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits B;    /**< \brief Bitfield access */
} Ifx_CPU_SPR_SPROT_RGNACCENB_R;

/** \brief CPUx Software Debug Event   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_SWEVT_Bits B;             /**< \brief Bitfield access */
} Ifx_CPU_SWEVT;

/** \brief CPUx System Configuration Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_SYSCON_Bits B;            /**< \brief Bitfield access */
} Ifx_CPU_SYSCON;

/** \brief CPUx Task Address Space Identifier Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_TASK_ASI_Bits B;          /**< \brief Bitfield access */
} Ifx_CPU_TASK_ASI;

/** \brief CPUx Temporal Protection System Control Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_TPS_CON_Bits B;           /**< \brief Bitfield access */
} Ifx_CPU_TPS_CON;

/** \brief CPUx Exception Timer Class Enable Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_TPS_EXTIM_CLASS_EN_Bits B;    /**< \brief Bitfield access */
} Ifx_CPU_TPS_EXTIM_CLASS_EN;

/** \brief CPUx Exception Entry Timer Current Value   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_TPS_EXTIM_ENTRY_CVAL_Bits B;    /**< \brief Bitfield access */
} Ifx_CPU_TPS_EXTIM_ENTRY_CVAL;

/** \brief CPUx Exception Entry Timer Load Value   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_TPS_EXTIM_ENTRY_LVAL_Bits B;    /**< \brief Bitfield access */
} Ifx_CPU_TPS_EXTIM_ENTRY_LVAL;

/** \brief CPUx Exception Exit Timer Current Value   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_TPS_EXTIM_EXIT_CVAL_Bits B;    /**< \brief Bitfield access */
} Ifx_CPU_TPS_EXTIM_EXIT_CVAL;

/** \brief CPUx Exception Exit  Timer Load Value   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_TPS_EXTIM_EXIT_LVAL_Bits B;    /**< \brief Bitfield access */
} Ifx_CPU_TPS_EXTIM_EXIT_LVAL;

/** \brief CPUx Exception Timer FCX Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_TPS_EXTIM_FCX_Bits B;     /**< \brief Bitfield access */
} Ifx_CPU_TPS_EXTIM_FCX;

/** \brief CPUx Exception Timer Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_TPS_EXTIM_STAT_Bits B;    /**< \brief Bitfield access */
} Ifx_CPU_TPS_EXTIM_STAT;

/** \brief CPUx Temporal Protection System Timer Register ${y}   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_TPS_TIMER_Bits B;         /**< \brief Bitfield access */
} Ifx_CPU_TPS_TIMER;

/** \brief CPUx TriggerAddressx   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_TRIG_ACC_Bits B;          /**< \brief Bitfield access */
} Ifx_CPU_TRIG_ACC;

/** \brief CPUx Trigger Address ${i}   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_TR_ADR_Bits B;            /**< \brief Bitfield access */
} Ifx_CPU_TR_ADR;

/** \brief CPUx Trigger Event ${i}   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_TR_EVT_Bits B;            /**< \brief Bitfield access */
} Ifx_CPU_TR_EVT;

/** \}  */

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Cpu_RGN_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief RGN object */
typedef volatile struct _Ifx_CPU_RGN
{
       Ifx_CPU_RGN_LA                      LA;                     /**< \brief 0, CPUx Safety Protection SPR Region Lower Address Register ${i}*/
       Ifx_CPU_RGN_UA                      UA;                     /**< \brief 4, CPUx Safety Protection SPR Region Upper Address Register ${i}*/
       Ifx_CPU_RGN_ACCENA                  ACCENA;                 /**< \brief 8, CPUx Safety Protection SPR Region Write Access Enable Register A${i}*/
       Ifx_CPU_RGN_ACCENB                  ACCENB;                 /**< \brief C, CPUx Safety Protection SPR Region Write Access Enable Register B${i}*/
} Ifx_CPU_RGN;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Cpu_BLK_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief BLK object */
typedef volatile struct _Ifx_CPU_BLK
{
       Ifx_CPU_BLK_RABR                    RABR;                   /**< \brief 0, CPUx Redirected Address Base Register ${i}*/
       Ifx_CPU_BLK_OTAR                    OTAR;                   /**< \brief 4, CPUx Overlay Target Address Register ${i}*/
       Ifx_CPU_BLK_OMASK                   OMASK;                  /**< \brief 8, CPUx Overlay Mask Register ${i}*/
} Ifx_CPU_BLK;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Cpu_FPU_TRAP_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief FPU_TRAP object */
typedef volatile struct _Ifx_CPU_FPU_TRAP
{
       Ifx_CPU_FPU_TRAP_CON                CON;                    /**< \brief 0, CPUx Trap Control Register*/
       Ifx_CPU_FPU_TRAP_PC                 PC;                     /**< \brief 4, CPUx Trapping Instruction Program Counter Register*/
       Ifx_CPU_FPU_TRAP_OPC                OPC;                    /**< \brief 8, CPUx Trapping Instruction Opcode Register*/
       Ifx_UReg_8Bit                       reserved_C[4];          /**< \brief C, \internal Reserved */
       Ifx_CPU_FPU_TRAP_SRC1               SRC1;                   /**< \brief 10, CPUx Trapping Instruction Operand Register*/
       Ifx_CPU_FPU_TRAP_SRC2               SRC2;                   /**< \brief 14, CPUx Trapping Instruction Operand Register*/
       Ifx_CPU_FPU_TRAP_SRC3               SRC3;                   /**< \brief 18, CPUx Trapping Instruction Operand Register*/
} Ifx_CPU_FPU_TRAP;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Cpu_DPR_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief DPR object */
typedef volatile struct _Ifx_CPU_DPR
{
       Ifx_CPU_DPR_L                       L;                      /**< \brief 0, CPUx Data Protection Range ${y}, Lower Bound Register*/
       Ifx_CPU_DPR_U                       U;                      /**< \brief 4, CPUx Data Protection Range ${y}, Upper Bound Register*/
} Ifx_CPU_DPR;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Cpu_CPR_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief CPR object */
typedef volatile struct _Ifx_CPU_CPR
{
       Ifx_CPU_CPR_L                       L;                      /**< \brief 0, CPUx Code Protection Range ${y} Lower Bound Register*/
       Ifx_CPU_CPR_U                       U;                      /**< \brief 4, CPUx Code Protection Range ${y} Upper Bound Register*/
} Ifx_CPU_CPR;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Cpu_TPS_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief TPS object */
typedef volatile struct _Ifx_CPU_TPS
{
       Ifx_CPU_TPS_CON                     CON;                    /**< \brief 0, CPUx Temporal Protection System Control Register*/
       Ifx_CPU_TPS_TIMER                   TIMER[3];               /**< \brief 4, CPUx Temporal Protection System Timer Register ${y}*/
} Ifx_CPU_TPS;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Cpu_TPS_EXTIM_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief TPS_EXTIM object */
typedef volatile struct _Ifx_CPU_TPS_EXTIM
{
       Ifx_CPU_TPS_EXTIM_ENTRY_LVAL        ENTRY_LVAL;             /**< \brief 0, CPUx Exception Entry Timer Load Value*/
       Ifx_CPU_TPS_EXTIM_ENTRY_CVAL        ENTRY_CVAL;             /**< \brief 4, CPUx Exception Entry Timer Current Value*/
       Ifx_CPU_TPS_EXTIM_EXIT_LVAL         EXIT_LVAL;              /**< \brief 8, CPUx Exception Exit  Timer Load Value*/
       Ifx_CPU_TPS_EXTIM_EXIT_CVAL         EXIT_CVAL;              /**< \brief C, CPUx Exception Exit Timer Current Value*/
       Ifx_CPU_TPS_EXTIM_CLASS_EN          CLASS_EN;               /**< \brief 10, CPUx Exception Timer Class Enable Register*/
       Ifx_CPU_TPS_EXTIM_STAT              STAT;                   /**< \brief 14, CPUx Exception Timer Status Register*/
       Ifx_CPU_TPS_EXTIM_FCX               FCX;                    /**< \brief 18, CPUx Exception Timer FCX Register*/
} Ifx_CPU_TPS_EXTIM;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Cpu_TR_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief TR object */
typedef volatile struct _Ifx_CPU_TR
{
       Ifx_CPU_TR_EVT                      EVT;                    /**< \brief 0, CPUx Trigger Event ${i}*/
       Ifx_CPU_TR_ADR                      ADR;                    /**< \brief 4, CPUx Trigger Address ${i}*/
} Ifx_CPU_TR;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/** \addtogroup IfxSfr_Cpu_Registers_struct
 * \{  */
/******************************************************************************/
/** \name Object L0
 * \{  */

/** \brief CPU object */
typedef volatile struct _Ifx_CPU
{
       Ifx_UReg_8Bit                       reserved_0[4352];       /**< \brief 0, \internal Reserved */
       Ifx_CPU_FLASHCON0                   FLASHCON0;              /**< \brief 1100, CPUx Flash Configuration Register 0*/
       Ifx_CPU_FLASHCON1                   FLASHCON1;              /**< \brief 1104, CPUx Flash Configuration Register 1*/
       Ifx_CPU_FLASHCON2                   FLASHCON2;              /**< \brief 1108, CPUx Flash Configuration Register 2*/
       Ifx_CPU_FLASHCON3                   FLASHCON3;              /**< \brief 110C, CPUx Flash Configuration Register 3*/
       Ifx_CPU_FLASHCON4                   FLASHCON4;              /**< \brief 1110, CPUx Flash Configuration Register 4*/
       Ifx_UReg_8Bit                       reserved_1114[48876];    /**< \brief 1114, \internal Reserved */
       Ifx_CPU_KRST0                       KRST0;                  /**< \brief D000, CPUx  Reset Register 0*/
       Ifx_CPU_KRST1                       KRST1;                  /**< \brief D004, CPUx  Reset Register 1*/
       Ifx_CPU_KRSTCLR                     KRSTCLR;                /**< \brief D008, CPUx Reset Clear Register*/
       Ifx_UReg_8Bit                       reserved_D00C[4084];    /**< \brief D00C, \internal Reserved */
       Ifx_CPU_RGN                         RGN[8];                 /**< \brief E000, CPUx Safety Protection SPR Region Write Access Enable Register B${i}*/
       Ifx_UReg_8Bit                       reserved_E080[8];       /**< \brief E080, \internal Reserved */
       Ifx_CPU_SPR_SPROT_RGNACCENA_R       SPR_SPROT_RGNACCENA_R0;    /**< \brief E088, */
       Ifx_CPU_SPR_SPROT_RGNACCENB_R       SPR_SPROT_RGNACCENB_R0;    /**< \brief E08C, */
       Ifx_UReg_8Bit                       reserved_E090[8];       /**< \brief E090, \internal Reserved */
       Ifx_CPU_SPR_SPROT_RGNACCENA_R       SPR_SPROT_RGNACCENA_R1;    /**< \brief E098, */
       Ifx_CPU_SPR_SPROT_RGNACCENB_R       SPR_SPROT_RGNACCENB_R1;    /**< \brief E09C, */
       Ifx_UReg_8Bit                       reserved_E0A0[8];       /**< \brief E0A0, \internal Reserved */
       Ifx_CPU_SPR_SPROT_RGNACCENA_R       SPR_SPROT_RGNACCENA_R2;    /**< \brief E0A8, */
       Ifx_CPU_SPR_SPROT_RGNACCENB_R       SPR_SPROT_RGNACCENB_R2;    /**< \brief E0AC, */
       Ifx_UReg_8Bit                       reserved_E0B0[8];       /**< \brief E0B0, \internal Reserved */
       Ifx_CPU_SPR_SPROT_RGNACCENA_R       SPR_SPROT_RGNACCENA_R3;    /**< \brief E0B8, */
       Ifx_CPU_SPR_SPROT_RGNACCENB_R       SPR_SPROT_RGNACCENB_R3;    /**< \brief E0BC, */
       Ifx_UReg_8Bit                       reserved_E0C0[8];       /**< \brief E0C0, \internal Reserved */
       Ifx_CPU_SPR_SPROT_RGNACCENA_R       SPR_SPROT_RGNACCENA_R4;    /**< \brief E0C8, */
       Ifx_CPU_SPR_SPROT_RGNACCENB_R       SPR_SPROT_RGNACCENB_R4;    /**< \brief E0CC, */
       Ifx_UReg_8Bit                       reserved_E0D0[8];       /**< \brief E0D0, \internal Reserved */
       Ifx_CPU_SPR_SPROT_RGNACCENA_R       SPR_SPROT_RGNACCENA_R5;    /**< \brief E0D8, */
       Ifx_CPU_SPR_SPROT_RGNACCENB_R       SPR_SPROT_RGNACCENB_R5;    /**< \brief E0DC, */
       Ifx_UReg_8Bit                       reserved_E0E0[8];       /**< \brief E0E0, \internal Reserved */
       Ifx_CPU_SPR_SPROT_RGNACCENA_R       SPR_SPROT_RGNACCENA_R6;    /**< \brief E0E8, */
       Ifx_CPU_SPR_SPROT_RGNACCENB_R       SPR_SPROT_RGNACCENB_R6;    /**< \brief E0EC, */
       Ifx_UReg_8Bit                       reserved_E0F0[8];       /**< \brief E0F0, \internal Reserved */
       Ifx_CPU_SPR_SPROT_RGNACCENA_R       SPR_SPROT_RGNACCENA_R7;    /**< \brief E0F8, */
       Ifx_CPU_SPR_SPROT_RGNACCENB_R       SPR_SPROT_RGNACCENB_R7;    /**< \brief E0FC, */
       Ifx_CPU_SFR_SPROT_ACCENA_W          SFR_SPROT_ACCENA_W;     /**< \brief E100, CPUx Safety Protection Register Access Enable Register A*/
       Ifx_CPU_SFR_SPROT_ACCENB_W          SFR_SPROT_ACCENB_W;     /**< \brief E104, CPUx Safety Protection Region Access Enable Register B*/
       Ifx_UReg_8Bit                       reserved_E108[8];       /**< \brief E108, \internal Reserved */
       Ifx_CPU_LPB_SPROT_ACCENA_R          LPB_SPROT_ACCENA_R;     /**< \brief E110, CPUx Safety Protection Region LPB Read Access Enable Register A*/
       Ifx_CPU_LPB_SPROT_ACCENB_R          LPB_SPROT_ACCENB_R;     /**< \brief E114, CPUx Safety Protection Region LPB Read Access Enable Register B*/
       Ifx_UReg_8Bit                       reserved_E118[232];     /**< \brief E118, \internal Reserved */
       Ifx_CPU_DLMU_SPROT_RGNLA            DLMU_SPROT_RGNLA0;      /**< \brief E200, CPUx Safety Protection Region DLMU Write Access Enable Register B${i}*/
       Ifx_CPU_DLMU_SPROT_RGNUA            DLMU_SPROT_RGNUA0;      /**< \brief E204, CPUx Safety Protection Region DLMU Write Access Enable Register B${i}*/
       Ifx_CPU_DLMU_SPROT_RGNACCENA_W      DLMU_SPROT_RGNACCENA_W0;    /**< \brief E208, CPUx Safety Protection Region DLMU Write Access Enable Register B${i}*/
       Ifx_CPU_DLMU_SPROT_RGNACCENB_W      DLMU_SPROT_RGNACCENB_W0;    /**< \brief E20C, CPUx Safety Protection Region DLMU Write Access Enable Register B${i}*/
       Ifx_CPU_DLMU_SPROT_RGNLA            DLMU_SPROT_RGNLA1;      /**< \brief E210, CPUx Safety Protection Region DLMU Write Access Enable Register B${i}*/
       Ifx_CPU_DLMU_SPROT_RGNUA            DLMU_SPROT_RGNUA1;      /**< \brief E214, CPUx Safety Protection Region DLMU Write Access Enable Register B${i}*/
       Ifx_CPU_DLMU_SPROT_RGNACCENA_W      DLMU_SPROT_RGNACCENA_W1;    /**< \brief E218, CPUx Safety Protection Region DLMU Write Access Enable Register B${i}*/
       Ifx_CPU_DLMU_SPROT_RGNACCENB_W      DLMU_SPROT_RGNACCENB_W1;    /**< \brief E21C, CPUx Safety Protection Region DLMU Write Access Enable Register B${i}*/
       Ifx_CPU_DLMU_SPROT_RGNLA            DLMU_SPROT_RGNLA2;      /**< \brief E220, CPUx Safety Protection Region DLMU Write Access Enable Register B${i}*/
       Ifx_CPU_DLMU_SPROT_RGNUA            DLMU_SPROT_RGNUA2;      /**< \brief E224, CPUx Safety Protection Region DLMU Write Access Enable Register B${i}*/
       Ifx_CPU_DLMU_SPROT_RGNACCENA_W      DLMU_SPROT_RGNACCENA_W2;    /**< \brief E228, CPUx Safety Protection Region DLMU Write Access Enable Register B${i}*/
       Ifx_CPU_DLMU_SPROT_RGNACCENB_W      DLMU_SPROT_RGNACCENB_W2;    /**< \brief E22C, CPUx Safety Protection Region DLMU Write Access Enable Register B${i}*/
       Ifx_CPU_DLMU_SPROT_RGNLA            DLMU_SPROT_RGNLA3;      /**< \brief E230, CPUx Safety Protection Region DLMU Write Access Enable Register B${i}*/
       Ifx_CPU_DLMU_SPROT_RGNUA            DLMU_SPROT_RGNUA3;      /**< \brief E234, CPUx Safety Protection Region DLMU Write Access Enable Register B${i}*/
       Ifx_CPU_DLMU_SPROT_RGNACCENA_W      DLMU_SPROT_RGNACCENA_W3;    /**< \brief E238, CPUx Safety Protection Region DLMU Write Access Enable Register B${i}*/
       Ifx_CPU_DLMU_SPROT_RGNACCENB_W      DLMU_SPROT_RGNACCENB_W3;    /**< \brief E23C, CPUx Safety Protection Region DLMU Write Access Enable Register B${i}*/
       Ifx_CPU_DLMU_SPROT_RGNLA            DLMU_SPROT_RGNLA4;      /**< \brief E240, CPUx Safety Protection Region DLMU Write Access Enable Register B${i}*/
       Ifx_CPU_DLMU_SPROT_RGNUA            DLMU_SPROT_RGNUA4;      /**< \brief E244, CPUx Safety Protection Region DLMU Write Access Enable Register B${i}*/
       Ifx_CPU_DLMU_SPROT_RGNACCENA_W      DLMU_SPROT_RGNACCENA_W4;    /**< \brief E248, CPUx Safety Protection Region DLMU Write Access Enable Register B${i}*/
       Ifx_CPU_DLMU_SPROT_RGNACCENB_W      DLMU_SPROT_RGNACCENB_W4;    /**< \brief E24C, CPUx Safety Protection Region DLMU Write Access Enable Register B${i}*/
       Ifx_CPU_DLMU_SPROT_RGNLA            DLMU_SPROT_RGNLA5;      /**< \brief E250, CPUx Safety Protection Region DLMU Write Access Enable Register B${i}*/
       Ifx_CPU_DLMU_SPROT_RGNUA            DLMU_SPROT_RGNUA5;      /**< \brief E254, CPUx Safety Protection Region DLMU Write Access Enable Register B${i}*/
       Ifx_CPU_DLMU_SPROT_RGNACCENA_W      DLMU_SPROT_RGNACCENA_W5;    /**< \brief E258, CPUx Safety Protection Region DLMU Write Access Enable Register B${i}*/
       Ifx_CPU_DLMU_SPROT_RGNACCENB_W      DLMU_SPROT_RGNACCENB_W5;    /**< \brief E25C, CPUx Safety Protection Region DLMU Write Access Enable Register B${i}*/
       Ifx_CPU_DLMU_SPROT_RGNLA            DLMU_SPROT_RGNLA6;      /**< \brief E260, CPUx Safety Protection Region DLMU Write Access Enable Register B${i}*/
       Ifx_CPU_DLMU_SPROT_RGNUA            DLMU_SPROT_RGNUA6;      /**< \brief E264, CPUx Safety Protection Region DLMU Write Access Enable Register B${i}*/
       Ifx_CPU_DLMU_SPROT_RGNACCENA_W      DLMU_SPROT_RGNACCENA_W6;    /**< \brief E268, CPUx Safety Protection Region DLMU Write Access Enable Register B${i}*/
       Ifx_CPU_DLMU_SPROT_RGNACCENB_W      DLMU_SPROT_RGNACCENB_W6;    /**< \brief E26C, CPUx Safety Protection Region DLMU Write Access Enable Register B${i}*/
       Ifx_CPU_DLMU_SPROT_RGNLA            DLMU_SPROT_RGNLA7;      /**< \brief E270, CPUx Safety Protection Region DLMU Write Access Enable Register B${i}*/
       Ifx_CPU_DLMU_SPROT_RGNUA            DLMU_SPROT_RGNUA7;      /**< \brief E274, CPUx Safety Protection Region DLMU Write Access Enable Register B${i}*/
       Ifx_CPU_DLMU_SPROT_RGNACCENA_W      DLMU_SPROT_RGNACCENA_W7;    /**< \brief E278, CPUx Safety Protection Region DLMU Write Access Enable Register B${i}*/
       Ifx_CPU_DLMU_SPROT_RGNACCENB_W      DLMU_SPROT_RGNACCENB_W7;    /**< \brief E27C, CPUx Safety Protection Region DLMU Write Access Enable Register B${i}*/
       Ifx_UReg_8Bit                       reserved_E280[8];       /**< \brief E280, \internal Reserved */
       Ifx_CPU_DLMU_SPROT_RGNACCENA_R      DLMU_SPROT_RGNACCENA_R0;    /**< \brief E288, */
       Ifx_CPU_DLMU_SPROT_RGNACCENB_R      DLMU_SPROT_RGNACCENB_R0;    /**< \brief E28C, */
       Ifx_UReg_8Bit                       reserved_E290[8];       /**< \brief E290, \internal Reserved */
       Ifx_CPU_DLMU_SPROT_RGNACCENA_R      DLMU_SPROT_RGNACCENA_R1;    /**< \brief E298, */
       Ifx_CPU_DLMU_SPROT_RGNACCENB_R      DLMU_SPROT_RGNACCENB_R1;    /**< \brief E29C, */
       Ifx_UReg_8Bit                       reserved_E2A0[8];       /**< \brief E2A0, \internal Reserved */
       Ifx_CPU_DLMU_SPROT_RGNACCENA_R      DLMU_SPROT_RGNACCENA_R2;    /**< \brief E2A8, */
       Ifx_CPU_DLMU_SPROT_RGNACCENB_R      DLMU_SPROT_RGNACCENB_R2;    /**< \brief E2AC, */
       Ifx_UReg_8Bit                       reserved_E2B0[8];       /**< \brief E2B0, \internal Reserved */
       Ifx_CPU_DLMU_SPROT_RGNACCENA_R      DLMU_SPROT_RGNACCENA_R3;    /**< \brief E2B8, */
       Ifx_CPU_DLMU_SPROT_RGNACCENB_R      DLMU_SPROT_RGNACCENB_R3;    /**< \brief E2BC, */
       Ifx_UReg_8Bit                       reserved_E2C0[8];       /**< \brief E2C0, \internal Reserved */
       Ifx_CPU_DLMU_SPROT_RGNACCENA_R      DLMU_SPROT_RGNACCENA_R4;    /**< \brief E2C8, */
       Ifx_CPU_DLMU_SPROT_RGNACCENB_R      DLMU_SPROT_RGNACCENB_R4;    /**< \brief E2CC, */
       Ifx_UReg_8Bit                       reserved_E2D0[8];       /**< \brief E2D0, \internal Reserved */
       Ifx_CPU_DLMU_SPROT_RGNACCENA_R      DLMU_SPROT_RGNACCENA_R5;    /**< \brief E2D8, */
       Ifx_CPU_DLMU_SPROT_RGNACCENB_R      DLMU_SPROT_RGNACCENB_R5;    /**< \brief E2DC, */
       Ifx_UReg_8Bit                       reserved_E2E0[8];       /**< \brief E2E0, \internal Reserved */
       Ifx_CPU_DLMU_SPROT_RGNACCENA_R      DLMU_SPROT_RGNACCENA_R6;    /**< \brief E2E8, */
       Ifx_CPU_DLMU_SPROT_RGNACCENB_R      DLMU_SPROT_RGNACCENB_R6;    /**< \brief E2EC, */
       Ifx_UReg_8Bit                       reserved_E2F0[8];       /**< \brief E2F0, \internal Reserved */
       Ifx_CPU_DLMU_SPROT_RGNACCENA_R      DLMU_SPROT_RGNACCENA_R7;    /**< \brief E2F8, */
       Ifx_CPU_DLMU_SPROT_RGNACCENB_R      DLMU_SPROT_RGNACCENB_R7;    /**< \brief E2FC, */
       Ifx_UReg_8Bit                       reserved_E300[6144];    /**< \brief E300, \internal Reserved */
       Ifx_CPU_OSEL                        OSEL;                   /**< \brief FB00, CPUx  Overlay Range Select Register*/
       Ifx_UReg_8Bit                       reserved_FB04[12];      /**< \brief FB04, \internal Reserved */
       Ifx_CPU_BLK                         BLK[32];                /**< \brief FB10, CPUx Overlay Mask Register ${i}*/
       Ifx_UReg_8Bit                       reserved_FC90[5024];    /**< \brief FC90, \internal Reserved */
       Ifx_CPU_SEGEN                       SEGEN;                  /**< \brief 11030, CPUx SRI Error Generation Register*/
       Ifx_UReg_8Bit                       reserved_11034[28624];    /**< \brief 11034, \internal Reserved */
       Ifx_CPU_TASK_ASI                    TASK_ASI;               /**< \brief 18004, CPUx Task Address Space Identifier Register*/
       Ifx_UReg_8Bit                       reserved_18008[248];    /**< \brief 18008, \internal Reserved */
       Ifx_CPU_PMA0                        PMA0;                   /**< \brief 18100, CPUx Data Access CacheabilityRegister*/
       Ifx_CPU_PMA1                        PMA1;                   /**< \brief 18104, CPUx Code Access CacheabilityRegister*/
       Ifx_CPU_PMA2                        PMA2;                   /**< \brief 18108, CPUx  Peripheral Space Identifier register*/
       Ifx_UReg_8Bit                       reserved_1810C[3828];    /**< \brief 1810C, \internal Reserved */
       Ifx_CPU_DCON2                       DCON2;                  /**< \brief 19000, CPUx Data Control Register 2*/
       Ifx_UReg_8Bit                       reserved_19004[8];      /**< \brief 19004, \internal Reserved */
       Ifx_CPU_SMACON                      SMACON;                 /**< \brief 1900C, CPUx SIST Mode Access Control Register*/
       Ifx_CPU_DSTR                        DSTR;                   /**< \brief 19010, CPUx Data Synchronous Trap Register*/
       Ifx_UReg_8Bit                       reserved_19014[4];      /**< \brief 19014, \internal Reserved */
       Ifx_CPU_DATR                        DATR;                   /**< \brief 19018, CPUx Data Asynchronous Trap Register*/
       Ifx_CPU_DEADD                       DEADD;                  /**< \brief 1901C, CPUx Data Error Address Register*/
       Ifx_CPU_DIEAR                       DIEAR;                  /**< \brief 19020, CPUx Data Integrity Error Address Register*/
       Ifx_CPU_DIETR                       DIETR;                  /**< \brief 19024, CPUx Data Integrity Error Trap Register*/
       Ifx_UReg_8Bit                       reserved_19028[24];     /**< \brief 19028, \internal Reserved */
       Ifx_CPU_DCON0                       DCON0;                  /**< \brief 19040, CPUx Data Memory Control Register*/
       Ifx_UReg_8Bit                       reserved_19044[444];    /**< \brief 19044, \internal Reserved */
       Ifx_CPU_PSTR                        PSTR;                   /**< \brief 19200, CPUx Program Synchronous Trap Register*/
       Ifx_CPU_PCON1                       PCON1;                  /**< \brief 19204, CPUx Program Control 1*/
       Ifx_CPU_PCON2                       PCON2;                  /**< \brief 19208, CPUx Program Control 2*/
       Ifx_CPU_PCON0                       PCON0;                  /**< \brief 1920C, CPUx Program Control 0*/
       Ifx_CPU_PIEAR                       PIEAR;                  /**< \brief 19210, CPUx Program Integrity Error Address Register*/
       Ifx_CPU_PIETR                       PIETR;                  /**< \brief 19214, CPUx Program Integrity Error Trap Register*/
       Ifx_UReg_8Bit                       reserved_19218[488];    /**< \brief 19218, \internal Reserved */
       Ifx_CPU_COMPAT                      COMPAT;                 /**< \brief 19400, CPUx Compatibility Control Register*/
       Ifx_UReg_8Bit                       reserved_19404[3068];    /**< \brief 19404, \internal Reserved */
       Ifx_CPU_FPU_TRAP                    FPU_TRAP;               /**< \brief 1A000, CPUx Trapping Instruction Operand Register*/
       Ifx_UReg_8Bit                       reserved_1A01C[8164];    /**< \brief 1A01C, \internal Reserved */
       Ifx_CPU_DPR                         DPR[18];                /**< \brief 1C000, CPUx Data Protection Range ${y}, Upper Bound Register*/
       Ifx_UReg_8Bit                       reserved_1C090[3952];    /**< \brief 1C090, \internal Reserved */
       Ifx_CPU_CPR                         CPR[10];                /**< \brief 1D000, CPUx Code Protection Range ${y} Upper Bound Register*/
       Ifx_UReg_8Bit                       reserved_1D050[4016];    /**< \brief 1D050, \internal Reserved */
       Ifx_CPU_CPXE                        CPXE_0;                 /**< \brief 1E000, CPUx Code Protection Execute Enable Register Set ${y}*/
       Ifx_CPU_CPXE                        CPXE_1;                 /**< \brief 1E004, CPUx Code Protection Execute Enable Register Set ${y}*/
       Ifx_CPU_CPXE                        CPXE_2;                 /**< \brief 1E008, CPUx Code Protection Execute Enable Register Set ${y}*/
       Ifx_CPU_CPXE                        CPXE_3;                 /**< \brief 1E00C, CPUx Code Protection Execute Enable Register Set ${y}*/
       Ifx_CPU_DPRE                        DPRE_0;                 /**< \brief 1E010, CPUx Data Protection Read Enable Register Set ${y}*/
       Ifx_CPU_DPRE                        DPRE_1;                 /**< \brief 1E014, CPUx Data Protection Read Enable Register Set ${y}*/
       Ifx_CPU_DPRE                        DPRE_2;                 /**< \brief 1E018, CPUx Data Protection Read Enable Register Set ${y}*/
       Ifx_CPU_DPRE                        DPRE_3;                 /**< \brief 1E01C, CPUx Data Protection Read Enable Register Set ${y}*/
       Ifx_CPU_DPWE                        DPWE_0;                 /**< \brief 1E020, CPUx Data Protection Write Enable Register Set ${y}*/
       Ifx_CPU_DPWE                        DPWE_1;                 /**< \brief 1E024, CPUx Data Protection Write Enable Register Set ${y}*/
       Ifx_CPU_DPWE                        DPWE_2;                 /**< \brief 1E028, CPUx Data Protection Write Enable Register Set ${y}*/
       Ifx_CPU_DPWE                        DPWE_3;                 /**< \brief 1E02C, CPUx Data Protection Write Enable Register Set ${y}*/
       Ifx_UReg_8Bit                       reserved_1E030[16];     /**< \brief 1E030, \internal Reserved */
       Ifx_CPU_CPXE                        CPXE_4;                 /**< \brief 1E040, CPUx Code Protection Execute Enable Register Set ${y}*/
       Ifx_CPU_CPXE                        CPXE_5;                 /**< \brief 1E044, CPUx Code Protection Execute Enable Register Set ${y}*/
       Ifx_UReg_8Bit                       reserved_1E048[8];      /**< \brief 1E048, \internal Reserved */
       Ifx_CPU_DPRE                        DPRE_4;                 /**< \brief 1E050, CPUx Data Protection Read Enable Register Set ${y}*/
       Ifx_CPU_DPRE                        DPRE_5;                 /**< \brief 1E054, CPUx Data Protection Read Enable Register Set ${y}*/
       Ifx_UReg_8Bit                       reserved_1E058[8];      /**< \brief 1E058, \internal Reserved */
       Ifx_CPU_DPWE                        DPWE_4;                 /**< \brief 1E060, CPUx Data Protection Write Enable Register Set ${y}*/
       Ifx_CPU_DPWE                        DPWE_5;                 /**< \brief 1E064, CPUx Data Protection Write Enable Register Set ${y}*/
       Ifx_UReg_8Bit                       reserved_1E068[920];    /**< \brief 1E068, \internal Reserved */
       Ifx_CPU_TPS                         TPS;                    /**< \brief 1E400, */
       Ifx_UReg_8Bit                       reserved_1E410[48];     /**< \brief 1E410, \internal Reserved */
       Ifx_CPU_TPS_EXTIM                   TPS_EXTIM;              /**< \brief 1E440, CPUx Exception Timer FCX Register*/
       Ifx_UReg_8Bit                       reserved_1E45C[2980];    /**< \brief 1E45C, \internal Reserved */
       Ifx_CPU_TR                          TR[8];                  /**< \brief 1F000, CPUx Trigger Address ${i}*/
       Ifx_UReg_8Bit                       reserved_1F040[3008];    /**< \brief 1F040, \internal Reserved */
       Ifx_CPU_CCTRL                       CCTRL;                  /**< \brief 1FC00, CPUx Counter Control*/
       Ifx_CPU_CCNT                        CCNT;                   /**< \brief 1FC04, CPUx CPU Clock Cycle Count*/
       Ifx_CPU_ICNT                        ICNT;                   /**< \brief 1FC08, CPUx Instruction Count*/
       Ifx_CPU_M1CNT                       M1CNT;                  /**< \brief 1FC0C, CPUx Multi-Count Register 1*/
       Ifx_CPU_M2CNT                       M2CNT;                  /**< \brief 1FC10, CPUx Multi-Count Register 2*/
       Ifx_CPU_M3CNT                       M3CNT;                  /**< \brief 1FC14, CPUx Multi-Count Register 3*/
       Ifx_UReg_8Bit                       reserved_1FC18[232];    /**< \brief 1FC18, \internal Reserved */
       Ifx_CPU_DBGSR                       DBGSR;                  /**< \brief 1FD00, CPUx Debug Status Register*/
       Ifx_UReg_8Bit                       reserved_1FD04[4];      /**< \brief 1FD04, \internal Reserved */
       Ifx_CPU_EXEVT                       EXEVT;                  /**< \brief 1FD08, CPUx External Event Register*/
       Ifx_CPU_CREVT                       CREVT;                  /**< \brief 1FD0C, CPUx Core Register Access Event*/
       Ifx_CPU_SWEVT                       SWEVT;                  /**< \brief 1FD10, CPUx Software Debug Event*/
       Ifx_UReg_8Bit                       reserved_1FD14[28];     /**< \brief 1FD14, \internal Reserved */
       Ifx_CPU_TRIG_ACC                    TRIG_ACC;               /**< \brief 1FD30, CPUx TriggerAddressx*/
       Ifx_UReg_8Bit                       reserved_1FD34[12];     /**< \brief 1FD34, \internal Reserved */
       Ifx_CPU_DMS                         DMS;                    /**< \brief 1FD40, CPUx Debug Monitor Start Address*/
       Ifx_CPU_DCX                         DCX;                    /**< \brief 1FD44, CPUx Debug Context Save Area Pointer*/
       Ifx_CPU_DBGTCR                      DBGTCR;                 /**< \brief 1FD48, CPUx Debug Trap Control Register*/
       Ifx_UReg_8Bit                       reserved_1FD4C[180];    /**< \brief 1FD4C, \internal Reserved */
       Ifx_CPU_PCXI                        PCXI;                   /**< \brief 1FE00, CPUx Previous Context Information Register*/
       Ifx_CPU_PSW                         PSW;                    /**< \brief 1FE04, CPUx Program Status Word*/
       Ifx_CPU_PC                          PC;                     /**< \brief 1FE08, CPUx Program Counter*/
       Ifx_UReg_8Bit                       reserved_1FE0C[8];      /**< \brief 1FE0C, \internal Reserved */
       Ifx_CPU_SYSCON                      SYSCON;                 /**< \brief 1FE14, CPUx System Configuration Register*/
       Ifx_CPU_CPU_ID                      CPU_ID;                 /**< \brief 1FE18, CPUx Identification Register TC1.6.2P*/
       Ifx_CPU_CORE_ID                     CORE_ID;                /**< \brief 1FE1C, CPUx Core Identification Register*/
       Ifx_CPU_BIV                         BIV;                    /**< \brief 1FE20, CPUx Base Interrupt Vector Table Pointer*/
       Ifx_CPU_BTV                         BTV;                    /**< \brief 1FE24, CPUx Base Trap Vector Table Pointer*/
       Ifx_CPU_ISP                         ISP;                    /**< \brief 1FE28, CPUx Interrupt Stack Pointer*/
       Ifx_CPU_ICR                         ICR;                    /**< \brief 1FE2C, CPUx Interrupt Control Register*/
       Ifx_UReg_8Bit                       reserved_1FE30[8];      /**< \brief 1FE30, \internal Reserved */
       Ifx_CPU_FCX                         FCX;                    /**< \brief 1FE38, CPUx Free CSA List Head Pointer*/
       Ifx_CPU_LCX                         LCX;                    /**< \brief 1FE3C, CPUx Free CSA List Limit Pointer*/
       Ifx_UReg_8Bit                       reserved_1FE40[16];     /**< \brief 1FE40, \internal Reserved */
       Ifx_CPU_CUS_ID                      CUS_ID;                 /**< \brief 1FE50, CPUx Customer ID register*/
       Ifx_UReg_8Bit                       reserved_1FE54[172];    /**< \brief 1FE54, \internal Reserved */
       Ifx_CPU_D                           D[16];                  /**< \brief 1FF00, CPUx Data General Purpose Register ${y}*/
       Ifx_UReg_8Bit                       reserved_1FF40[64];     /**< \brief 1FF40, \internal Reserved */
       Ifx_CPU_A                           A[16];                  /**< \brief 1FF80, CPUx Address General Purpose Register ${y}*/
       Ifx_UReg_8Bit                       reserved_1FFC0[64];     /**< \brief 1FFC0, \internal Reserved */
} Ifx_CPU;

/** \}  */
/******************************************************************************/
/** \}  */


/******************************************************************************/

/******************************************************************************/


#line 66 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\Infra\\Sfr\\TC38A\\_Reg\\IfxCpu_reg.h"
/******************************************************************************/

/******************************************************************************/

/******************************************************************************/

/** \addtogroup IfxSfr_Cpu_Registers_Cfg_BaseAddress
 * \{  */

/** \brief CPU object */




/** \}  */

/** \brief 1030, CPUx SRI Error Generation Register */


/** \brief 8004, CPUx Task Address Space Identifier Register */


/** \brief 8100, CPUx Data Access CacheabilityRegister */


/** \brief 8104, CPUx Code Access CacheabilityRegister */


/** \brief 8108, CPUx  Peripheral Space Identifier register */


/** \brief 9000, CPUx Data Control Register 2 */


/** \brief 900C, CPUx SIST Mode Access Control Register */


/** \brief 9010, CPUx Data Synchronous Trap Register */


/** \brief 9018, CPUx Data Asynchronous Trap Register */


/** \brief 901C, CPUx Data Error Address Register */


/** \brief 9020, CPUx Data Integrity Error Address Register */


/** \brief 9024, CPUx Data Integrity Error Trap Register */


/** \brief 9040, CPUx Data Memory Control Register */


/** \brief 9200, CPUx Program Synchronous Trap Register */


/** \brief 9204, CPUx Program Control 1 */


/** \brief 9208, CPUx Program Control 2 */


/** \brief 920C, CPUx Program Control 0 */


/** \brief 9210, CPUx Program Integrity Error Address Register */


/** \brief 9214, CPUx Program Integrity Error Trap Register */


/** \brief 9400, CPUx Compatibility Control Register */


/** \brief A000, CPUx Trap Control Register */


/** \brief A004, CPUx Trapping Instruction Program Counter Register */


/** \brief A008, CPUx Trapping Instruction Opcode Register */


/** \brief A010, CPUx Trapping Instruction Operand Register */


/** \brief A014, CPUx Trapping Instruction Operand Register */


/** \brief A018, CPUx Trapping Instruction Operand Register */


/** \brief C000, CPUx Data Protection Range 0, Lower Bound Register */


/** \brief C004, CPUx Data Protection Range 0, Upper Bound Register */


/** \brief C008, CPUx Data Protection Range 1, Lower Bound Register */


/** \brief C00C, CPUx Data Protection Range 1, Upper Bound Register */


/** \brief C010, CPUx Data Protection Range 2, Lower Bound Register */


/** \brief C014, CPUx Data Protection Range 2, Upper Bound Register */


/** \brief C018, CPUx Data Protection Range 3, Lower Bound Register */


/** \brief C01C, CPUx Data Protection Range 3, Upper Bound Register */


/** \brief C020, CPUx Data Protection Range 4, Lower Bound Register */


/** \brief C024, CPUx Data Protection Range 4, Upper Bound Register */


/** \brief C028, CPUx Data Protection Range 5, Lower Bound Register */


/** \brief C02C, CPUx Data Protection Range 5, Upper Bound Register */


/** \brief C030, CPUx Data Protection Range 6, Lower Bound Register */


/** \brief C034, CPUx Data Protection Range 6, Upper Bound Register */


/** \brief C038, CPUx Data Protection Range 7, Lower Bound Register */


/** \brief C03C, CPUx Data Protection Range 7, Upper Bound Register */


/** \brief C040, CPUx Data Protection Range 8, Lower Bound Register */


/** \brief C044, CPUx Data Protection Range 8, Upper Bound Register */


/** \brief C048, CPUx Data Protection Range 9, Lower Bound Register */


/** \brief C04C, CPUx Data Protection Range 9, Upper Bound Register */


/** \brief C050, CPUx Data Protection Range 10, Lower Bound Register */


/** \brief C054, CPUx Data Protection Range 10, Upper Bound Register */


/** \brief C058, CPUx Data Protection Range 11, Lower Bound Register */


/** \brief C05C, CPUx Data Protection Range 11, Upper Bound Register */


/** \brief C060, CPUx Data Protection Range 12, Lower Bound Register */


/** \brief C064, CPUx Data Protection Range 12, Upper Bound Register */


/** \brief C068, CPUx Data Protection Range 13, Lower Bound Register */


/** \brief C06C, CPUx Data Protection Range 13, Upper Bound Register */


/** \brief C070, CPUx Data Protection Range 14, Lower Bound Register */


/** \brief C074, CPUx Data Protection Range 14, Upper Bound Register */


/** \brief C078, CPUx Data Protection Range 15, Lower Bound Register */


/** \brief C07C, CPUx Data Protection Range 15, Upper Bound Register */


/** \brief C080, CPUx Data Protection Range 16, Lower Bound Register */


/** \brief C084, CPUx Data Protection Range 16, Upper Bound Register */


/** \brief C088, CPUx Data Protection Range 17, Lower Bound Register */


/** \brief C08C, CPUx Data Protection Range 17, Upper Bound Register */


/** \brief D000, CPUx Code Protection Range 0 Lower Bound Register */


/** \brief D004, CPUx Code Protection Range 0 Upper Bound Register */


/** \brief D008, CPUx Code Protection Range 1 Lower Bound Register */


/** \brief D00C, CPUx Code Protection Range 1 Upper Bound Register */


/** \brief D010, CPUx Code Protection Range 2 Lower Bound Register */


/** \brief D014, CPUx Code Protection Range 2 Upper Bound Register */


/** \brief D018, CPUx Code Protection Range 3 Lower Bound Register */


/** \brief D01C, CPUx Code Protection Range 3 Upper Bound Register */


/** \brief D020, CPUx Code Protection Range 4 Lower Bound Register */


/** \brief D024, CPUx Code Protection Range 4 Upper Bound Register */


/** \brief D028, CPUx Code Protection Range 5 Lower Bound Register */


/** \brief D02C, CPUx Code Protection Range 5 Upper Bound Register */


/** \brief D030, CPUx Code Protection Range 6 Lower Bound Register */


/** \brief D034, CPUx Code Protection Range 6 Upper Bound Register */


/** \brief D038, CPUx Code Protection Range 7 Lower Bound Register */


/** \brief D03C, CPUx Code Protection Range 7 Upper Bound Register */


/** \brief D040, CPUx Code Protection Range 8 Lower Bound Register */


/** \brief D044, CPUx Code Protection Range 8 Upper Bound Register */


/** \brief D048, CPUx Code Protection Range 9 Lower Bound Register */


/** \brief D04C, CPUx Code Protection Range 9 Upper Bound Register */


/** \brief E000, CPUx Code Protection Execute Enable Register Set 0 */


/** \brief E004, CPUx Code Protection Execute Enable Register Set 1 */


/** \brief E008, CPUx Code Protection Execute Enable Register Set 2 */


/** \brief E00C, CPUx Code Protection Execute Enable Register Set 3 */


/** \brief E010, CPUx Data Protection Read Enable Register Set 0 */


/** \brief E014, CPUx Data Protection Read Enable Register Set 1 */


/** \brief E018, CPUx Data Protection Read Enable Register Set 2 */


/** \brief E01C, CPUx Data Protection Read Enable Register Set 3 */


/** \brief E020, CPUx Data Protection Write Enable Register Set 0 */


/** \brief E024, CPUx Data Protection Write Enable Register Set 1 */


/** \brief E028, CPUx Data Protection Write Enable Register Set 2 */


/** \brief E02C, CPUx Data Protection Write Enable Register Set 3 */


/** \brief E040, CPUx Code Protection Execute Enable Register Set 4 */


/** \brief E044, CPUx Code Protection Execute Enable Register Set 5 */


/** \brief E050, CPUx Data Protection Read Enable Register Set 4 */


/** \brief E054, CPUx Data Protection Read Enable Register Set 5 */


/** \brief E060, CPUx Data Protection Write Enable Register Set 4 */


/** \brief E064, CPUx Data Protection Write Enable Register Set 5 */


/** \brief E400, CPUx Temporal Protection System Control Register */


/** \brief E404, CPUx Temporal Protection System Timer Register 0 */


/** \brief E408, CPUx Temporal Protection System Timer Register 1 */


/** \brief E40C, CPUx Temporal Protection System Timer Register 2 */


/** \brief E440, CPUx Exception Entry Timer Load Value */


/** \brief E444, CPUx Exception Entry Timer Current Value */


/** \brief E448, CPUx Exception Exit  Timer Load Value */


/** \brief E44C, CPUx Exception Exit Timer Current Value */


/** \brief E450, CPUx Exception Timer Class Enable Register */


/** \brief E454, CPUx Exception Timer Status Register */


/** \brief E458, CPUx Exception Timer FCX Register */


/** \brief F000, CPUx Trigger Event 0 */

/** Alias (User Manual Name) for CPU_TR0_EVT.
* To use register names with standard convension, please use CPU_TR0_EVT.
*/


/** \brief F004, CPUx Trigger Address 0 */

/** Alias (User Manual Name) for CPU_TR0_ADR.
* To use register names with standard convension, please use CPU_TR0_ADR.
*/


/** \brief F008, CPUx Trigger Event 1 */

/** Alias (User Manual Name) for CPU_TR1_EVT.
* To use register names with standard convension, please use CPU_TR1_EVT.
*/


/** \brief F00C, CPUx Trigger Address 1 */

/** Alias (User Manual Name) for CPU_TR1_ADR.
* To use register names with standard convension, please use CPU_TR1_ADR.
*/


/** \brief F010, CPUx Trigger Event 2 */

/** Alias (User Manual Name) for CPU_TR2_EVT.
* To use register names with standard convension, please use CPU_TR2_EVT.
*/


/** \brief F014, CPUx Trigger Address 2 */

/** Alias (User Manual Name) for CPU_TR2_ADR.
* To use register names with standard convension, please use CPU_TR2_ADR.
*/


/** \brief F018, CPUx Trigger Event 3 */

/** Alias (User Manual Name) for CPU_TR3_EVT.
* To use register names with standard convension, please use CPU_TR3_EVT.
*/


/** \brief F01C, CPUx Trigger Address 3 */

/** Alias (User Manual Name) for CPU_TR3_ADR.
* To use register names with standard convension, please use CPU_TR3_ADR.
*/


/** \brief F020, CPUx Trigger Event 4 */

/** Alias (User Manual Name) for CPU_TR4_EVT.
* To use register names with standard convension, please use CPU_TR4_EVT.
*/


/** \brief F024, CPUx Trigger Address 4 */

/** Alias (User Manual Name) for CPU_TR4_ADR.
* To use register names with standard convension, please use CPU_TR4_ADR.
*/


/** \brief F028, CPUx Trigger Event 5 */

/** Alias (User Manual Name) for CPU_TR5_EVT.
* To use register names with standard convension, please use CPU_TR5_EVT.
*/


/** \brief F02C, CPUx Trigger Address 5 */

/** Alias (User Manual Name) for CPU_TR5_ADR.
* To use register names with standard convension, please use CPU_TR5_ADR.
*/


/** \brief F030, CPUx Trigger Event 6 */

/** Alias (User Manual Name) for CPU_TR6_EVT.
* To use register names with standard convension, please use CPU_TR6_EVT.
*/


/** \brief F034, CPUx Trigger Address 6 */

/** Alias (User Manual Name) for CPU_TR6_ADR.
* To use register names with standard convension, please use CPU_TR6_ADR.
*/


/** \brief F038, CPUx Trigger Event 7 */

/** Alias (User Manual Name) for CPU_TR7_EVT.
* To use register names with standard convension, please use CPU_TR7_EVT.
*/


/** \brief F03C, CPUx Trigger Address 7 */

/** Alias (User Manual Name) for CPU_TR7_ADR.
* To use register names with standard convension, please use CPU_TR7_ADR.
*/


/** \brief FC00, CPUx Counter Control */


/** \brief FC04, CPUx CPU Clock Cycle Count */


/** \brief FC08, CPUx Instruction Count */


/** \brief FC0C, CPUx Multi-Count Register 1 */


/** \brief FC10, CPUx Multi-Count Register 2 */


/** \brief FC14, CPUx Multi-Count Register 3 */


/** \brief FD00, CPUx Debug Status Register */


/** \brief FD08, CPUx External Event Register */


/** \brief FD0C, CPUx Core Register Access Event */


/** \brief FD10, CPUx Software Debug Event */


/** \brief FD30, CPUx TriggerAddressx */


/** \brief FD40, CPUx Debug Monitor Start Address */


/** \brief FD44, CPUx Debug Context Save Area Pointer */


/** \brief FD48, CPUx Debug Trap Control Register */


/** \brief FE00, CPUx Previous Context Information Register */


/** \brief FE04, CPUx Program Status Word */


/** \brief FE08, CPUx Program Counter */


/** \brief FE14, CPUx System Configuration Register */


/** \brief FE18, CPUx Identification Register TC1.6.2P */


/** \brief FE1C, CPUx Core Identification Register */


/** \brief FE20, CPUx Base Interrupt Vector Table Pointer */


/** \brief FE24, CPUx Base Trap Vector Table Pointer */


/** \brief FE28, CPUx Interrupt Stack Pointer */


/** \brief FE2C, CPUx Interrupt Control Register */


/** \brief FE38, CPUx Free CSA List Head Pointer */


/** \brief FE3C, CPUx Free CSA List Limit Pointer */


/** \brief FE50, CPUx Customer ID register */


/** \brief FF00, CPUx Data General Purpose Register 0 */


/** \brief FF04, CPUx Data General Purpose Register 1 */


/** \brief FF08, CPUx Data General Purpose Register 2 */


/** \brief FF0C, CPUx Data General Purpose Register 3 */


/** \brief FF10, CPUx Data General Purpose Register 4 */


/** \brief FF14, CPUx Data General Purpose Register 5 */


/** \brief FF18, CPUx Data General Purpose Register 6 */


/** \brief FF1C, CPUx Data General Purpose Register 7 */


/** \brief FF20, CPUx Data General Purpose Register 8 */


/** \brief FF24, CPUx Data General Purpose Register 9 */


/** \brief FF28, CPUx Data General Purpose Register 10 */


/** \brief FF2C, CPUx Data General Purpose Register 11 */


/** \brief FF30, CPUx Data General Purpose Register 12 */


/** \brief FF34, CPUx Data General Purpose Register 13 */


/** \brief FF38, CPUx Data General Purpose Register 14 */


/** \brief FF3C, CPUx Data General Purpose Register 15 */


/** \brief FF80, CPUx Address General Purpose Register 0 */


/** \brief FF84, CPUx Address General Purpose Register 1 */


/** \brief FF88, CPUx Address General Purpose Register 2 */


/** \brief FF8C, CPUx Address General Purpose Register 3 */


/** \brief FF90, CPUx Address General Purpose Register 4 */


/** \brief FF94, CPUx Address General Purpose Register 5 */


/** \brief FF98, CPUx Address General Purpose Register 6 */


/** \brief FF9C, CPUx Address General Purpose Register 7 */


/** \brief FFA0, CPUx Address General Purpose Register 8 */


/** \brief FFA4, CPUx Address General Purpose Register 9 */


/** \brief FFA8, CPUx Address General Purpose Register 10 */


/** \brief FFAC, CPUx Address General Purpose Register 11 */


/** \brief FFB0, CPUx Address General Purpose Register 12 */


/** \brief FFB4, CPUx Address General Purpose Register 13 */


/** \brief FFB8, CPUx Address General Purpose Register 14 */


/** \brief FFBC, CPUx Address General Purpose Register 15 */



/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Cpu_Registers_Cfg_Cpu0
 * \{  */
/** \brief 1100, CPUx Flash Configuration Register 0 */


/** \brief 1104, CPUx Flash Configuration Register 1 */


/** \brief 1108, CPUx Flash Configuration Register 2 */


/** \brief 110C, CPUx Flash Configuration Register 3 */


/** \brief 1110, CPUx Flash Configuration Register 4 */


/** \brief D000, CPUx  Reset Register 0 */


/** \brief D004, CPUx  Reset Register 1 */


/** \brief D008, CPUx Reset Clear Register */


/** \brief E000, CPUx Safety Protection SPR Region Lower Address Register 0 */

/** Alias (User Manual Name) for CPU0_RGN0_LA.
* To use register names with standard convension, please use CPU0_RGN0_LA.
*/


/** \brief E004, CPUx Safety Protection SPR Region Upper Address Register 0 */

/** Alias (User Manual Name) for CPU0_RGN0_UA.
* To use register names with standard convension, please use CPU0_RGN0_UA.
*/


/** \brief E008, CPUx Safety Protection SPR Region Write Access Enable Register A0 */

/** Alias (User Manual Name) for CPU0_RGN0_ACCENA.
* To use register names with standard convension, please use CPU0_RGN0_ACCENA.
*/


/** \brief E00C, CPUx Safety Protection SPR Region Write Access Enable Register B0 */

/** Alias (User Manual Name) for CPU0_RGN0_ACCENB.
* To use register names with standard convension, please use CPU0_RGN0_ACCENB.
*/


/** \brief E010, CPUx Safety Protection SPR Region Lower Address Register 1 */

/** Alias (User Manual Name) for CPU0_RGN1_LA.
* To use register names with standard convension, please use CPU0_RGN1_LA.
*/


/** \brief E014, CPUx Safety Protection SPR Region Upper Address Register 1 */

/** Alias (User Manual Name) for CPU0_RGN1_UA.
* To use register names with standard convension, please use CPU0_RGN1_UA.
*/


/** \brief E018, CPUx Safety Protection SPR Region Write Access Enable Register A1 */

/** Alias (User Manual Name) for CPU0_RGN1_ACCENA.
* To use register names with standard convension, please use CPU0_RGN1_ACCENA.
*/


/** \brief E01C, CPUx Safety Protection SPR Region Write Access Enable Register B1 */

/** Alias (User Manual Name) for CPU0_RGN1_ACCENB.
* To use register names with standard convension, please use CPU0_RGN1_ACCENB.
*/


/** \brief E020, CPUx Safety Protection SPR Region Lower Address Register 2 */

/** Alias (User Manual Name) for CPU0_RGN2_LA.
* To use register names with standard convension, please use CPU0_RGN2_LA.
*/


/** \brief E024, CPUx Safety Protection SPR Region Upper Address Register 2 */

/** Alias (User Manual Name) for CPU0_RGN2_UA.
* To use register names with standard convension, please use CPU0_RGN2_UA.
*/


/** \brief E028, CPUx Safety Protection SPR Region Write Access Enable Register A2 */

/** Alias (User Manual Name) for CPU0_RGN2_ACCENA.
* To use register names with standard convension, please use CPU0_RGN2_ACCENA.
*/


/** \brief E02C, CPUx Safety Protection SPR Region Write Access Enable Register B2 */

/** Alias (User Manual Name) for CPU0_RGN2_ACCENB.
* To use register names with standard convension, please use CPU0_RGN2_ACCENB.
*/


/** \brief E030, CPUx Safety Protection SPR Region Lower Address Register 3 */

/** Alias (User Manual Name) for CPU0_RGN3_LA.
* To use register names with standard convension, please use CPU0_RGN3_LA.
*/


/** \brief E034, CPUx Safety Protection SPR Region Upper Address Register 3 */

/** Alias (User Manual Name) for CPU0_RGN3_UA.
* To use register names with standard convension, please use CPU0_RGN3_UA.
*/


/** \brief E038, CPUx Safety Protection SPR Region Write Access Enable Register A3 */

/** Alias (User Manual Name) for CPU0_RGN3_ACCENA.
* To use register names with standard convension, please use CPU0_RGN3_ACCENA.
*/


/** \brief E03C, CPUx Safety Protection SPR Region Write Access Enable Register B3 */

/** Alias (User Manual Name) for CPU0_RGN3_ACCENB.
* To use register names with standard convension, please use CPU0_RGN3_ACCENB.
*/


/** \brief E040, CPUx Safety Protection SPR Region Lower Address Register 4 */

/** Alias (User Manual Name) for CPU0_RGN4_LA.
* To use register names with standard convension, please use CPU0_RGN4_LA.
*/


/** \brief E044, CPUx Safety Protection SPR Region Upper Address Register 4 */

/** Alias (User Manual Name) for CPU0_RGN4_UA.
* To use register names with standard convension, please use CPU0_RGN4_UA.
*/


/** \brief E048, CPUx Safety Protection SPR Region Write Access Enable Register A4 */

/** Alias (User Manual Name) for CPU0_RGN4_ACCENA.
* To use register names with standard convension, please use CPU0_RGN4_ACCENA.
*/


/** \brief E04C, CPUx Safety Protection SPR Region Write Access Enable Register B4 */

/** Alias (User Manual Name) for CPU0_RGN4_ACCENB.
* To use register names with standard convension, please use CPU0_RGN4_ACCENB.
*/


/** \brief E050, CPUx Safety Protection SPR Region Lower Address Register 5 */

/** Alias (User Manual Name) for CPU0_RGN5_LA.
* To use register names with standard convension, please use CPU0_RGN5_LA.
*/


/** \brief E054, CPUx Safety Protection SPR Region Upper Address Register 5 */

/** Alias (User Manual Name) for CPU0_RGN5_UA.
* To use register names with standard convension, please use CPU0_RGN5_UA.
*/


/** \brief E058, CPUx Safety Protection SPR Region Write Access Enable Register A5 */

/** Alias (User Manual Name) for CPU0_RGN5_ACCENA.
* To use register names with standard convension, please use CPU0_RGN5_ACCENA.
*/


/** \brief E05C, CPUx Safety Protection SPR Region Write Access Enable Register B5 */

/** Alias (User Manual Name) for CPU0_RGN5_ACCENB.
* To use register names with standard convension, please use CPU0_RGN5_ACCENB.
*/


/** \brief E060, CPUx Safety Protection SPR Region Lower Address Register 6 */

/** Alias (User Manual Name) for CPU0_RGN6_LA.
* To use register names with standard convension, please use CPU0_RGN6_LA.
*/


/** \brief E064, CPUx Safety Protection SPR Region Upper Address Register 6 */

/** Alias (User Manual Name) for CPU0_RGN6_UA.
* To use register names with standard convension, please use CPU0_RGN6_UA.
*/


/** \brief E068, CPUx Safety Protection SPR Region Write Access Enable Register A6 */

/** Alias (User Manual Name) for CPU0_RGN6_ACCENA.
* To use register names with standard convension, please use CPU0_RGN6_ACCENA.
*/


/** \brief E06C, CPUx Safety Protection SPR Region Write Access Enable Register B6 */

/** Alias (User Manual Name) for CPU0_RGN6_ACCENB.
* To use register names with standard convension, please use CPU0_RGN6_ACCENB.
*/


/** \brief E070, CPUx Safety Protection SPR Region Lower Address Register 7 */

/** Alias (User Manual Name) for CPU0_RGN7_LA.
* To use register names with standard convension, please use CPU0_RGN7_LA.
*/


/** \brief E074, CPUx Safety Protection SPR Region Upper Address Register 7 */

/** Alias (User Manual Name) for CPU0_RGN7_UA.
* To use register names with standard convension, please use CPU0_RGN7_UA.
*/


/** \brief E078, CPUx Safety Protection SPR Region Write Access Enable Register A7 */

/** Alias (User Manual Name) for CPU0_RGN7_ACCENA.
* To use register names with standard convension, please use CPU0_RGN7_ACCENA.
*/


/** \brief E07C, CPUx Safety Protection SPR Region Write Access Enable Register B7 */

/** Alias (User Manual Name) for CPU0_RGN7_ACCENB.
* To use register names with standard convension, please use CPU0_RGN7_ACCENB.
*/


/** \brief E088, CPUx Safety Protection SPR Region Read Access Enable Register A0 */

/** Alias (User Manual Name) for CPU0_SPR_SPROT_RGNACCENA_R0.
* To use register names with standard convension, please use CPU0_SPR_SPROT_RGNACCENA_R0.
*/


/** \brief E08C, CPUx Safety Protection SPR Region Read Access Enable Register B0 */

/** Alias (User Manual Name) for CPU0_SPR_SPROT_RGNACCENB_R0.
* To use register names with standard convension, please use CPU0_SPR_SPROT_RGNACCENB_R0.
*/


/** \brief E098, CPUx Safety Protection SPR Region Read Access Enable Register A1 */

/** Alias (User Manual Name) for CPU0_SPR_SPROT_RGNACCENA_R1.
* To use register names with standard convension, please use CPU0_SPR_SPROT_RGNACCENA_R1.
*/


/** \brief E09C, CPUx Safety Protection SPR Region Read Access Enable Register B1 */

/** Alias (User Manual Name) for CPU0_SPR_SPROT_RGNACCENB_R1.
* To use register names with standard convension, please use CPU0_SPR_SPROT_RGNACCENB_R1.
*/


/** \brief E0A8, CPUx Safety Protection SPR Region Read Access Enable Register A2 */

/** Alias (User Manual Name) for CPU0_SPR_SPROT_RGNACCENA_R2.
* To use register names with standard convension, please use CPU0_SPR_SPROT_RGNACCENA_R2.
*/


/** \brief E0AC, CPUx Safety Protection SPR Region Read Access Enable Register B2 */

/** Alias (User Manual Name) for CPU0_SPR_SPROT_RGNACCENB_R2.
* To use register names with standard convension, please use CPU0_SPR_SPROT_RGNACCENB_R2.
*/


/** \brief E0B8, CPUx Safety Protection SPR Region Read Access Enable Register A3 */

/** Alias (User Manual Name) for CPU0_SPR_SPROT_RGNACCENA_R3.
* To use register names with standard convension, please use CPU0_SPR_SPROT_RGNACCENA_R3.
*/


/** \brief E0BC, CPUx Safety Protection SPR Region Read Access Enable Register B3 */

/** Alias (User Manual Name) for CPU0_SPR_SPROT_RGNACCENB_R3.
* To use register names with standard convension, please use CPU0_SPR_SPROT_RGNACCENB_R3.
*/


/** \brief E0C8, CPUx Safety Protection SPR Region Read Access Enable Register A4 */

/** Alias (User Manual Name) for CPU0_SPR_SPROT_RGNACCENA_R4.
* To use register names with standard convension, please use CPU0_SPR_SPROT_RGNACCENA_R4.
*/


/** \brief E0CC, CPUx Safety Protection SPR Region Read Access Enable Register B4 */

/** Alias (User Manual Name) for CPU0_SPR_SPROT_RGNACCENB_R4.
* To use register names with standard convension, please use CPU0_SPR_SPROT_RGNACCENB_R4.
*/


/** \brief E0D8, CPUx Safety Protection SPR Region Read Access Enable Register A5 */

/** Alias (User Manual Name) for CPU0_SPR_SPROT_RGNACCENA_R5.
* To use register names with standard convension, please use CPU0_SPR_SPROT_RGNACCENA_R5.
*/


/** \brief E0DC, CPUx Safety Protection SPR Region Read Access Enable Register B5 */

/** Alias (User Manual Name) for CPU0_SPR_SPROT_RGNACCENB_R5.
* To use register names with standard convension, please use CPU0_SPR_SPROT_RGNACCENB_R5.
*/


/** \brief E0E8, CPUx Safety Protection SPR Region Read Access Enable Register A6 */

/** Alias (User Manual Name) for CPU0_SPR_SPROT_RGNACCENA_R6.
* To use register names with standard convension, please use CPU0_SPR_SPROT_RGNACCENA_R6.
*/


/** \brief E0EC, CPUx Safety Protection SPR Region Read Access Enable Register B6 */

/** Alias (User Manual Name) for CPU0_SPR_SPROT_RGNACCENB_R6.
* To use register names with standard convension, please use CPU0_SPR_SPROT_RGNACCENB_R6.
*/


/** \brief E0F8, CPUx Safety Protection SPR Region Read Access Enable Register A7 */

/** Alias (User Manual Name) for CPU0_SPR_SPROT_RGNACCENA_R7.
* To use register names with standard convension, please use CPU0_SPR_SPROT_RGNACCENA_R7.
*/


/** \brief E0FC, CPUx Safety Protection SPR Region Read Access Enable Register B7 */

/** Alias (User Manual Name) for CPU0_SPR_SPROT_RGNACCENB_R7.
* To use register names with standard convension, please use CPU0_SPR_SPROT_RGNACCENB_R7.
*/


/** \brief E100, CPUx Safety Protection Register Access Enable Register A */


/** \brief E104, CPUx Safety Protection Region Access Enable Register B */


/** \brief E110, CPUx Safety Protection Region LPB Read Access Enable Register A */


/** \brief E114, CPUx Safety Protection Region LPB Read Access Enable Register B */


/** \brief E200, CPUx Safety Protection DLMU Region Lower Address Register 0 */


/** \brief E204, CPUx Safety protection DLMU Region Upper Address Register 0 */


/** \brief E208, CPUx Safety Protection Region DLMU Write Access Enable Register A0 */

/** Alias (User Manual Name) for CPU0_DLMU_SPROT_RGNACCENA_W0.
* To use register names with standard convension, please use CPU0_DLMU_SPROT_RGNACCENA_W0.
*/


/** \brief E20C, CPUx Safety Protection Region DLMU Write Access Enable Register B0 */

/** Alias (User Manual Name) for CPU0_DLMU_SPROT_RGNACCENB_W0.
* To use register names with standard convension, please use CPU0_DLMU_SPROT_RGNACCENB_W0.
*/


/** \brief E210, CPUx Safety Protection DLMU Region Lower Address Register 1 */


/** \brief E214, CPUx Safety protection DLMU Region Upper Address Register 1 */


/** \brief E218, CPUx Safety Protection Region DLMU Write Access Enable Register A1 */

/** Alias (User Manual Name) for CPU0_DLMU_SPROT_RGNACCENA_W1.
* To use register names with standard convension, please use CPU0_DLMU_SPROT_RGNACCENA_W1.
*/


/** \brief E21C, CPUx Safety Protection Region DLMU Write Access Enable Register B1 */

/** Alias (User Manual Name) for CPU0_DLMU_SPROT_RGNACCENB_W1.
* To use register names with standard convension, please use CPU0_DLMU_SPROT_RGNACCENB_W1.
*/


/** \brief E220, CPUx Safety Protection DLMU Region Lower Address Register 2 */


/** \brief E224, CPUx Safety protection DLMU Region Upper Address Register 2 */


/** \brief E228, CPUx Safety Protection Region DLMU Write Access Enable Register A2 */

/** Alias (User Manual Name) for CPU0_DLMU_SPROT_RGNACCENA_W2.
* To use register names with standard convension, please use CPU0_DLMU_SPROT_RGNACCENA_W2.
*/


/** \brief E22C, CPUx Safety Protection Region DLMU Write Access Enable Register B2 */

/** Alias (User Manual Name) for CPU0_DLMU_SPROT_RGNACCENB_W2.
* To use register names with standard convension, please use CPU0_DLMU_SPROT_RGNACCENB_W2.
*/


/** \brief E230, CPUx Safety Protection DLMU Region Lower Address Register 3 */


/** \brief E234, CPUx Safety protection DLMU Region Upper Address Register 3 */


/** \brief E238, CPUx Safety Protection Region DLMU Write Access Enable Register A3 */

/** Alias (User Manual Name) for CPU0_DLMU_SPROT_RGNACCENA_W3.
* To use register names with standard convension, please use CPU0_DLMU_SPROT_RGNACCENA_W3.
*/


/** \brief E23C, CPUx Safety Protection Region DLMU Write Access Enable Register B3 */

/** Alias (User Manual Name) for CPU0_DLMU_SPROT_RGNACCENB_W3.
* To use register names with standard convension, please use CPU0_DLMU_SPROT_RGNACCENB_W3.
*/


/** \brief E240, CPUx Safety Protection DLMU Region Lower Address Register 4 */


/** \brief E244, CPUx Safety protection DLMU Region Upper Address Register 4 */


/** \brief E248, CPUx Safety Protection Region DLMU Write Access Enable Register A4 */

/** Alias (User Manual Name) for CPU0_DLMU_SPROT_RGNACCENA_W4.
* To use register names with standard convension, please use CPU0_DLMU_SPROT_RGNACCENA_W4.
*/


/** \brief E24C, CPUx Safety Protection Region DLMU Write Access Enable Register B4 */

/** Alias (User Manual Name) for CPU0_DLMU_SPROT_RGNACCENB_W4.
* To use register names with standard convension, please use CPU0_DLMU_SPROT_RGNACCENB_W4.
*/


/** \brief E250, CPUx Safety Protection DLMU Region Lower Address Register 5 */


/** \brief E254, CPUx Safety protection DLMU Region Upper Address Register 5 */


/** \brief E258, CPUx Safety Protection Region DLMU Write Access Enable Register A5 */

/** Alias (User Manual Name) for CPU0_DLMU_SPROT_RGNACCENA_W5.
* To use register names with standard convension, please use CPU0_DLMU_SPROT_RGNACCENA_W5.
*/


/** \brief E25C, CPUx Safety Protection Region DLMU Write Access Enable Register B5 */

/** Alias (User Manual Name) for CPU0_DLMU_SPROT_RGNACCENB_W5.
* To use register names with standard convension, please use CPU0_DLMU_SPROT_RGNACCENB_W5.
*/


/** \brief E260, CPUx Safety Protection DLMU Region Lower Address Register 6 */


/** \brief E264, CPUx Safety protection DLMU Region Upper Address Register 6 */


/** \brief E268, CPUx Safety Protection Region DLMU Write Access Enable Register A6 */

/** Alias (User Manual Name) for CPU0_DLMU_SPROT_RGNACCENA_W6.
* To use register names with standard convension, please use CPU0_DLMU_SPROT_RGNACCENA_W6.
*/


/** \brief E26C, CPUx Safety Protection Region DLMU Write Access Enable Register B6 */

/** Alias (User Manual Name) for CPU0_DLMU_SPROT_RGNACCENB_W6.
* To use register names with standard convension, please use CPU0_DLMU_SPROT_RGNACCENB_W6.
*/


/** \brief E270, CPUx Safety Protection DLMU Region Lower Address Register 7 */


/** \brief E274, CPUx Safety protection DLMU Region Upper Address Register 7 */


/** \brief E278, CPUx Safety Protection Region DLMU Write Access Enable Register A7 */

/** Alias (User Manual Name) for CPU0_DLMU_SPROT_RGNACCENA_W7.
* To use register names with standard convension, please use CPU0_DLMU_SPROT_RGNACCENA_W7.
*/


/** \brief E27C, CPUx Safety Protection Region DLMU Write Access Enable Register B7 */

/** Alias (User Manual Name) for CPU0_DLMU_SPROT_RGNACCENB_W7.
* To use register names with standard convension, please use CPU0_DLMU_SPROT_RGNACCENB_W7.
*/


/** \brief E288, CPUx Safety Protection Region DLMU Read Access Enable Register A0 */

/** Alias (User Manual Name) for CPU0_DLMU_SPROT_RGNACCENA_R0.
* To use register names with standard convension, please use CPU0_DLMU_SPROT_RGNACCENA_R0.
*/


/** \brief E28C, CPUx Safety Protection Region DLMU Read Access Enable Register B0 */

/** Alias (User Manual Name) for CPU0_DLMU_SPROT_RGNACCENB_R0.
* To use register names with standard convension, please use CPU0_DLMU_SPROT_RGNACCENB_R0.
*/


/** \brief E298, CPUx Safety Protection Region DLMU Read Access Enable Register A1 */

/** Alias (User Manual Name) for CPU0_DLMU_SPROT_RGNACCENA_R1.
* To use register names with standard convension, please use CPU0_DLMU_SPROT_RGNACCENA_R1.
*/


/** \brief E29C, CPUx Safety Protection Region DLMU Read Access Enable Register B1 */

/** Alias (User Manual Name) for CPU0_DLMU_SPROT_RGNACCENB_R1.
* To use register names with standard convension, please use CPU0_DLMU_SPROT_RGNACCENB_R1.
*/


/** \brief E2A8, CPUx Safety Protection Region DLMU Read Access Enable Register A2 */

/** Alias (User Manual Name) for CPU0_DLMU_SPROT_RGNACCENA_R2.
* To use register names with standard convension, please use CPU0_DLMU_SPROT_RGNACCENA_R2.
*/


/** \brief E2AC, CPUx Safety Protection Region DLMU Read Access Enable Register B2 */

/** Alias (User Manual Name) for CPU0_DLMU_SPROT_RGNACCENB_R2.
* To use register names with standard convension, please use CPU0_DLMU_SPROT_RGNACCENB_R2.
*/


/** \brief E2B8, CPUx Safety Protection Region DLMU Read Access Enable Register A3 */

/** Alias (User Manual Name) for CPU0_DLMU_SPROT_RGNACCENA_R3.
* To use register names with standard convension, please use CPU0_DLMU_SPROT_RGNACCENA_R3.
*/


/** \brief E2BC, CPUx Safety Protection Region DLMU Read Access Enable Register B3 */

/** Alias (User Manual Name) for CPU0_DLMU_SPROT_RGNACCENB_R3.
* To use register names with standard convension, please use CPU0_DLMU_SPROT_RGNACCENB_R3.
*/


/** \brief E2C8, CPUx Safety Protection Region DLMU Read Access Enable Register A4 */

/** Alias (User Manual Name) for CPU0_DLMU_SPROT_RGNACCENA_R4.
* To use register names with standard convension, please use CPU0_DLMU_SPROT_RGNACCENA_R4.
*/


/** \brief E2CC, CPUx Safety Protection Region DLMU Read Access Enable Register B4 */

/** Alias (User Manual Name) for CPU0_DLMU_SPROT_RGNACCENB_R4.
* To use register names with standard convension, please use CPU0_DLMU_SPROT_RGNACCENB_R4.
*/


/** \brief E2D8, CPUx Safety Protection Region DLMU Read Access Enable Register A5 */

/** Alias (User Manual Name) for CPU0_DLMU_SPROT_RGNACCENA_R5.
* To use register names with standard convension, please use CPU0_DLMU_SPROT_RGNACCENA_R5.
*/


/** \brief E2DC, CPUx Safety Protection Region DLMU Read Access Enable Register B5 */

/** Alias (User Manual Name) for CPU0_DLMU_SPROT_RGNACCENB_R5.
* To use register names with standard convension, please use CPU0_DLMU_SPROT_RGNACCENB_R5.
*/


/** \brief E2E8, CPUx Safety Protection Region DLMU Read Access Enable Register A6 */

/** Alias (User Manual Name) for CPU0_DLMU_SPROT_RGNACCENA_R6.
* To use register names with standard convension, please use CPU0_DLMU_SPROT_RGNACCENA_R6.
*/


/** \brief E2EC, CPUx Safety Protection Region DLMU Read Access Enable Register B6 */

/** Alias (User Manual Name) for CPU0_DLMU_SPROT_RGNACCENB_R6.
* To use register names with standard convension, please use CPU0_DLMU_SPROT_RGNACCENB_R6.
*/


/** \brief E2F8, CPUx Safety Protection Region DLMU Read Access Enable Register A7 */

/** Alias (User Manual Name) for CPU0_DLMU_SPROT_RGNACCENA_R7.
* To use register names with standard convension, please use CPU0_DLMU_SPROT_RGNACCENA_R7.
*/


/** \brief E2FC, CPUx Safety Protection Region DLMU Read Access Enable Register B7 */

/** Alias (User Manual Name) for CPU0_DLMU_SPROT_RGNACCENB_R7.
* To use register names with standard convension, please use CPU0_DLMU_SPROT_RGNACCENB_R7.
*/


/** \brief FB00, CPUx  Overlay Range Select Register */


/** \brief FB10, CPUx Redirected Address Base Register 0 */

/** Alias (User Manual Name) for CPU0_BLK0_RABR.
* To use register names with standard convension, please use CPU0_BLK0_RABR.
*/


/** \brief FB14, CPUx Overlay Target Address Register 0 */

/** Alias (User Manual Name) for CPU0_BLK0_OTAR.
* To use register names with standard convension, please use CPU0_BLK0_OTAR.
*/


/** \brief FB18, CPUx Overlay Mask Register 0 */

/** Alias (User Manual Name) for CPU0_BLK0_OMASK.
* To use register names with standard convension, please use CPU0_BLK0_OMASK.
*/


/** \brief FB1C, CPUx Redirected Address Base Register 1 */

/** Alias (User Manual Name) for CPU0_BLK1_RABR.
* To use register names with standard convension, please use CPU0_BLK1_RABR.
*/


/** \brief FB20, CPUx Overlay Target Address Register 1 */

/** Alias (User Manual Name) for CPU0_BLK1_OTAR.
* To use register names with standard convension, please use CPU0_BLK1_OTAR.
*/


/** \brief FB24, CPUx Overlay Mask Register 1 */

/** Alias (User Manual Name) for CPU0_BLK1_OMASK.
* To use register names with standard convension, please use CPU0_BLK1_OMASK.
*/


/** \brief FB28, CPUx Redirected Address Base Register 2 */

/** Alias (User Manual Name) for CPU0_BLK2_RABR.
* To use register names with standard convension, please use CPU0_BLK2_RABR.
*/


/** \brief FB2C, CPUx Overlay Target Address Register 2 */

/** Alias (User Manual Name) for CPU0_BLK2_OTAR.
* To use register names with standard convension, please use CPU0_BLK2_OTAR.
*/


/** \brief FB30, CPUx Overlay Mask Register 2 */

/** Alias (User Manual Name) for CPU0_BLK2_OMASK.
* To use register names with standard convension, please use CPU0_BLK2_OMASK.
*/


/** \brief FB34, CPUx Redirected Address Base Register 3 */

/** Alias (User Manual Name) for CPU0_BLK3_RABR.
* To use register names with standard convension, please use CPU0_BLK3_RABR.
*/


/** \brief FB38, CPUx Overlay Target Address Register 3 */

/** Alias (User Manual Name) for CPU0_BLK3_OTAR.
* To use register names with standard convension, please use CPU0_BLK3_OTAR.
*/


/** \brief FB3C, CPUx Overlay Mask Register 3 */

/** Alias (User Manual Name) for CPU0_BLK3_OMASK.
* To use register names with standard convension, please use CPU0_BLK3_OMASK.
*/


/** \brief FB40, CPUx Redirected Address Base Register 4 */

/** Alias (User Manual Name) for CPU0_BLK4_RABR.
* To use register names with standard convension, please use CPU0_BLK4_RABR.
*/


/** \brief FB44, CPUx Overlay Target Address Register 4 */

/** Alias (User Manual Name) for CPU0_BLK4_OTAR.
* To use register names with standard convension, please use CPU0_BLK4_OTAR.
*/


/** \brief FB48, CPUx Overlay Mask Register 4 */

/** Alias (User Manual Name) for CPU0_BLK4_OMASK.
* To use register names with standard convension, please use CPU0_BLK4_OMASK.
*/


/** \brief FB4C, CPUx Redirected Address Base Register 5 */

/** Alias (User Manual Name) for CPU0_BLK5_RABR.
* To use register names with standard convension, please use CPU0_BLK5_RABR.
*/


/** \brief FB50, CPUx Overlay Target Address Register 5 */

/** Alias (User Manual Name) for CPU0_BLK5_OTAR.
* To use register names with standard convension, please use CPU0_BLK5_OTAR.
*/


/** \brief FB54, CPUx Overlay Mask Register 5 */

/** Alias (User Manual Name) for CPU0_BLK5_OMASK.
* To use register names with standard convension, please use CPU0_BLK5_OMASK.
*/


/** \brief FB58, CPUx Redirected Address Base Register 6 */

/** Alias (User Manual Name) for CPU0_BLK6_RABR.
* To use register names with standard convension, please use CPU0_BLK6_RABR.
*/


/** \brief FB5C, CPUx Overlay Target Address Register 6 */

/** Alias (User Manual Name) for CPU0_BLK6_OTAR.
* To use register names with standard convension, please use CPU0_BLK6_OTAR.
*/


/** \brief FB60, CPUx Overlay Mask Register 6 */

/** Alias (User Manual Name) for CPU0_BLK6_OMASK.
* To use register names with standard convension, please use CPU0_BLK6_OMASK.
*/


/** \brief FB64, CPUx Redirected Address Base Register 7 */

/** Alias (User Manual Name) for CPU0_BLK7_RABR.
* To use register names with standard convension, please use CPU0_BLK7_RABR.
*/


/** \brief FB68, CPUx Overlay Target Address Register 7 */

/** Alias (User Manual Name) for CPU0_BLK7_OTAR.
* To use register names with standard convension, please use CPU0_BLK7_OTAR.
*/


/** \brief FB6C, CPUx Overlay Mask Register 7 */

/** Alias (User Manual Name) for CPU0_BLK7_OMASK.
* To use register names with standard convension, please use CPU0_BLK7_OMASK.
*/


/** \brief FB70, CPUx Redirected Address Base Register 8 */

/** Alias (User Manual Name) for CPU0_BLK8_RABR.
* To use register names with standard convension, please use CPU0_BLK8_RABR.
*/


/** \brief FB74, CPUx Overlay Target Address Register 8 */

/** Alias (User Manual Name) for CPU0_BLK8_OTAR.
* To use register names with standard convension, please use CPU0_BLK8_OTAR.
*/


/** \brief FB78, CPUx Overlay Mask Register 8 */

/** Alias (User Manual Name) for CPU0_BLK8_OMASK.
* To use register names with standard convension, please use CPU0_BLK8_OMASK.
*/


/** \brief FB7C, CPUx Redirected Address Base Register 9 */

/** Alias (User Manual Name) for CPU0_BLK9_RABR.
* To use register names with standard convension, please use CPU0_BLK9_RABR.
*/


/** \brief FB80, CPUx Overlay Target Address Register 9 */

/** Alias (User Manual Name) for CPU0_BLK9_OTAR.
* To use register names with standard convension, please use CPU0_BLK9_OTAR.
*/


/** \brief FB84, CPUx Overlay Mask Register 9 */

/** Alias (User Manual Name) for CPU0_BLK9_OMASK.
* To use register names with standard convension, please use CPU0_BLK9_OMASK.
*/


/** \brief FB88, CPUx Redirected Address Base Register 10 */

/** Alias (User Manual Name) for CPU0_BLK10_RABR.
* To use register names with standard convension, please use CPU0_BLK10_RABR.
*/


/** \brief FB8C, CPUx Overlay Target Address Register 10 */

/** Alias (User Manual Name) for CPU0_BLK10_OTAR.
* To use register names with standard convension, please use CPU0_BLK10_OTAR.
*/


/** \brief FB90, CPUx Overlay Mask Register 10 */

/** Alias (User Manual Name) for CPU0_BLK10_OMASK.
* To use register names with standard convension, please use CPU0_BLK10_OMASK.
*/


/** \brief FB94, CPUx Redirected Address Base Register 11 */

/** Alias (User Manual Name) for CPU0_BLK11_RABR.
* To use register names with standard convension, please use CPU0_BLK11_RABR.
*/


/** \brief FB98, CPUx Overlay Target Address Register 11 */

/** Alias (User Manual Name) for CPU0_BLK11_OTAR.
* To use register names with standard convension, please use CPU0_BLK11_OTAR.
*/


/** \brief FB9C, CPUx Overlay Mask Register 11 */

/** Alias (User Manual Name) for CPU0_BLK11_OMASK.
* To use register names with standard convension, please use CPU0_BLK11_OMASK.
*/


/** \brief FBA0, CPUx Redirected Address Base Register 12 */

/** Alias (User Manual Name) for CPU0_BLK12_RABR.
* To use register names with standard convension, please use CPU0_BLK12_RABR.
*/


/** \brief FBA4, CPUx Overlay Target Address Register 12 */

/** Alias (User Manual Name) for CPU0_BLK12_OTAR.
* To use register names with standard convension, please use CPU0_BLK12_OTAR.
*/


/** \brief FBA8, CPUx Overlay Mask Register 12 */

/** Alias (User Manual Name) for CPU0_BLK12_OMASK.
* To use register names with standard convension, please use CPU0_BLK12_OMASK.
*/


/** \brief FBAC, CPUx Redirected Address Base Register 13 */

/** Alias (User Manual Name) for CPU0_BLK13_RABR.
* To use register names with standard convension, please use CPU0_BLK13_RABR.
*/


/** \brief FBB0, CPUx Overlay Target Address Register 13 */

/** Alias (User Manual Name) for CPU0_BLK13_OTAR.
* To use register names with standard convension, please use CPU0_BLK13_OTAR.
*/


/** \brief FBB4, CPUx Overlay Mask Register 13 */

/** Alias (User Manual Name) for CPU0_BLK13_OMASK.
* To use register names with standard convension, please use CPU0_BLK13_OMASK.
*/


/** \brief FBB8, CPUx Redirected Address Base Register 14 */

/** Alias (User Manual Name) for CPU0_BLK14_RABR.
* To use register names with standard convension, please use CPU0_BLK14_RABR.
*/


/** \brief FBBC, CPUx Overlay Target Address Register 14 */

/** Alias (User Manual Name) for CPU0_BLK14_OTAR.
* To use register names with standard convension, please use CPU0_BLK14_OTAR.
*/


/** \brief FBC0, CPUx Overlay Mask Register 14 */

/** Alias (User Manual Name) for CPU0_BLK14_OMASK.
* To use register names with standard convension, please use CPU0_BLK14_OMASK.
*/


/** \brief FBC4, CPUx Redirected Address Base Register 15 */

/** Alias (User Manual Name) for CPU0_BLK15_RABR.
* To use register names with standard convension, please use CPU0_BLK15_RABR.
*/


/** \brief FBC8, CPUx Overlay Target Address Register 15 */

/** Alias (User Manual Name) for CPU0_BLK15_OTAR.
* To use register names with standard convension, please use CPU0_BLK15_OTAR.
*/


/** \brief FBCC, CPUx Overlay Mask Register 15 */

/** Alias (User Manual Name) for CPU0_BLK15_OMASK.
* To use register names with standard convension, please use CPU0_BLK15_OMASK.
*/


/** \brief FBD0, CPUx Redirected Address Base Register 16 */

/** Alias (User Manual Name) for CPU0_BLK16_RABR.
* To use register names with standard convension, please use CPU0_BLK16_RABR.
*/


/** \brief FBD4, CPUx Overlay Target Address Register 16 */

/** Alias (User Manual Name) for CPU0_BLK16_OTAR.
* To use register names with standard convension, please use CPU0_BLK16_OTAR.
*/


/** \brief FBD8, CPUx Overlay Mask Register 16 */

/** Alias (User Manual Name) for CPU0_BLK16_OMASK.
* To use register names with standard convension, please use CPU0_BLK16_OMASK.
*/


/** \brief FBDC, CPUx Redirected Address Base Register 17 */

/** Alias (User Manual Name) for CPU0_BLK17_RABR.
* To use register names with standard convension, please use CPU0_BLK17_RABR.
*/


/** \brief FBE0, CPUx Overlay Target Address Register 17 */

/** Alias (User Manual Name) for CPU0_BLK17_OTAR.
* To use register names with standard convension, please use CPU0_BLK17_OTAR.
*/


/** \brief FBE4, CPUx Overlay Mask Register 17 */

/** Alias (User Manual Name) for CPU0_BLK17_OMASK.
* To use register names with standard convension, please use CPU0_BLK17_OMASK.
*/


/** \brief FBE8, CPUx Redirected Address Base Register 18 */

/** Alias (User Manual Name) for CPU0_BLK18_RABR.
* To use register names with standard convension, please use CPU0_BLK18_RABR.
*/


/** \brief FBEC, CPUx Overlay Target Address Register 18 */

/** Alias (User Manual Name) for CPU0_BLK18_OTAR.
* To use register names with standard convension, please use CPU0_BLK18_OTAR.
*/


/** \brief FBF0, CPUx Overlay Mask Register 18 */

/** Alias (User Manual Name) for CPU0_BLK18_OMASK.
* To use register names with standard convension, please use CPU0_BLK18_OMASK.
*/


/** \brief FBF4, CPUx Redirected Address Base Register 19 */

/** Alias (User Manual Name) for CPU0_BLK19_RABR.
* To use register names with standard convension, please use CPU0_BLK19_RABR.
*/


/** \brief FBF8, CPUx Overlay Target Address Register 19 */

/** Alias (User Manual Name) for CPU0_BLK19_OTAR.
* To use register names with standard convension, please use CPU0_BLK19_OTAR.
*/


/** \brief FBFC, CPUx Overlay Mask Register 19 */

/** Alias (User Manual Name) for CPU0_BLK19_OMASK.
* To use register names with standard convension, please use CPU0_BLK19_OMASK.
*/


/** \brief FC00, CPUx Redirected Address Base Register 20 */

/** Alias (User Manual Name) for CPU0_BLK20_RABR.
* To use register names with standard convension, please use CPU0_BLK20_RABR.
*/


/** \brief FC04, CPUx Overlay Target Address Register 20 */

/** Alias (User Manual Name) for CPU0_BLK20_OTAR.
* To use register names with standard convension, please use CPU0_BLK20_OTAR.
*/


/** \brief FC08, CPUx Overlay Mask Register 20 */

/** Alias (User Manual Name) for CPU0_BLK20_OMASK.
* To use register names with standard convension, please use CPU0_BLK20_OMASK.
*/


/** \brief FC0C, CPUx Redirected Address Base Register 21 */

/** Alias (User Manual Name) for CPU0_BLK21_RABR.
* To use register names with standard convension, please use CPU0_BLK21_RABR.
*/


/** \brief FC10, CPUx Overlay Target Address Register 21 */

/** Alias (User Manual Name) for CPU0_BLK21_OTAR.
* To use register names with standard convension, please use CPU0_BLK21_OTAR.
*/


/** \brief FC14, CPUx Overlay Mask Register 21 */

/** Alias (User Manual Name) for CPU0_BLK21_OMASK.
* To use register names with standard convension, please use CPU0_BLK21_OMASK.
*/


/** \brief FC18, CPUx Redirected Address Base Register 22 */

/** Alias (User Manual Name) for CPU0_BLK22_RABR.
* To use register names with standard convension, please use CPU0_BLK22_RABR.
*/


/** \brief FC1C, CPUx Overlay Target Address Register 22 */

/** Alias (User Manual Name) for CPU0_BLK22_OTAR.
* To use register names with standard convension, please use CPU0_BLK22_OTAR.
*/


/** \brief FC20, CPUx Overlay Mask Register 22 */

/** Alias (User Manual Name) for CPU0_BLK22_OMASK.
* To use register names with standard convension, please use CPU0_BLK22_OMASK.
*/


/** \brief FC24, CPUx Redirected Address Base Register 23 */

/** Alias (User Manual Name) for CPU0_BLK23_RABR.
* To use register names with standard convension, please use CPU0_BLK23_RABR.
*/


/** \brief FC28, CPUx Overlay Target Address Register 23 */

/** Alias (User Manual Name) for CPU0_BLK23_OTAR.
* To use register names with standard convension, please use CPU0_BLK23_OTAR.
*/


/** \brief FC2C, CPUx Overlay Mask Register 23 */

/** Alias (User Manual Name) for CPU0_BLK23_OMASK.
* To use register names with standard convension, please use CPU0_BLK23_OMASK.
*/


/** \brief FC30, CPUx Redirected Address Base Register 24 */

/** Alias (User Manual Name) for CPU0_BLK24_RABR.
* To use register names with standard convension, please use CPU0_BLK24_RABR.
*/


/** \brief FC34, CPUx Overlay Target Address Register 24 */

/** Alias (User Manual Name) for CPU0_BLK24_OTAR.
* To use register names with standard convension, please use CPU0_BLK24_OTAR.
*/


/** \brief FC38, CPUx Overlay Mask Register 24 */

/** Alias (User Manual Name) for CPU0_BLK24_OMASK.
* To use register names with standard convension, please use CPU0_BLK24_OMASK.
*/


/** \brief FC3C, CPUx Redirected Address Base Register 25 */

/** Alias (User Manual Name) for CPU0_BLK25_RABR.
* To use register names with standard convension, please use CPU0_BLK25_RABR.
*/


/** \brief FC40, CPUx Overlay Target Address Register 25 */

/** Alias (User Manual Name) for CPU0_BLK25_OTAR.
* To use register names with standard convension, please use CPU0_BLK25_OTAR.
*/


/** \brief FC44, CPUx Overlay Mask Register 25 */

/** Alias (User Manual Name) for CPU0_BLK25_OMASK.
* To use register names with standard convension, please use CPU0_BLK25_OMASK.
*/


/** \brief FC48, CPUx Redirected Address Base Register 26 */

/** Alias (User Manual Name) for CPU0_BLK26_RABR.
* To use register names with standard convension, please use CPU0_BLK26_RABR.
*/


/** \brief FC4C, CPUx Overlay Target Address Register 26 */

/** Alias (User Manual Name) for CPU0_BLK26_OTAR.
* To use register names with standard convension, please use CPU0_BLK26_OTAR.
*/


/** \brief FC50, CPUx Overlay Mask Register 26 */

/** Alias (User Manual Name) for CPU0_BLK26_OMASK.
* To use register names with standard convension, please use CPU0_BLK26_OMASK.
*/


/** \brief FC54, CPUx Redirected Address Base Register 27 */

/** Alias (User Manual Name) for CPU0_BLK27_RABR.
* To use register names with standard convension, please use CPU0_BLK27_RABR.
*/


/** \brief FC58, CPUx Overlay Target Address Register 27 */

/** Alias (User Manual Name) for CPU0_BLK27_OTAR.
* To use register names with standard convension, please use CPU0_BLK27_OTAR.
*/


/** \brief FC5C, CPUx Overlay Mask Register 27 */

/** Alias (User Manual Name) for CPU0_BLK27_OMASK.
* To use register names with standard convension, please use CPU0_BLK27_OMASK.
*/


/** \brief FC60, CPUx Redirected Address Base Register 28 */

/** Alias (User Manual Name) for CPU0_BLK28_RABR.
* To use register names with standard convension, please use CPU0_BLK28_RABR.
*/


/** \brief FC64, CPUx Overlay Target Address Register 28 */

/** Alias (User Manual Name) for CPU0_BLK28_OTAR.
* To use register names with standard convension, please use CPU0_BLK28_OTAR.
*/


/** \brief FC68, CPUx Overlay Mask Register 28 */

/** Alias (User Manual Name) for CPU0_BLK28_OMASK.
* To use register names with standard convension, please use CPU0_BLK28_OMASK.
*/


/** \brief FC6C, CPUx Redirected Address Base Register 29 */

/** Alias (User Manual Name) for CPU0_BLK29_RABR.
* To use register names with standard convension, please use CPU0_BLK29_RABR.
*/


/** \brief FC70, CPUx Overlay Target Address Register 29 */

/** Alias (User Manual Name) for CPU0_BLK29_OTAR.
* To use register names with standard convension, please use CPU0_BLK29_OTAR.
*/


/** \brief FC74, CPUx Overlay Mask Register 29 */

/** Alias (User Manual Name) for CPU0_BLK29_OMASK.
* To use register names with standard convension, please use CPU0_BLK29_OMASK.
*/


/** \brief FC78, CPUx Redirected Address Base Register 30 */

/** Alias (User Manual Name) for CPU0_BLK30_RABR.
* To use register names with standard convension, please use CPU0_BLK30_RABR.
*/


/** \brief FC7C, CPUx Overlay Target Address Register 30 */

/** Alias (User Manual Name) for CPU0_BLK30_OTAR.
* To use register names with standard convension, please use CPU0_BLK30_OTAR.
*/


/** \brief FC80, CPUx Overlay Mask Register 30 */

/** Alias (User Manual Name) for CPU0_BLK30_OMASK.
* To use register names with standard convension, please use CPU0_BLK30_OMASK.
*/


/** \brief FC84, CPUx Redirected Address Base Register 31 */

/** Alias (User Manual Name) for CPU0_BLK31_RABR.
* To use register names with standard convension, please use CPU0_BLK31_RABR.
*/


/** \brief FC88, CPUx Overlay Target Address Register 31 */

/** Alias (User Manual Name) for CPU0_BLK31_OTAR.
* To use register names with standard convension, please use CPU0_BLK31_OTAR.
*/


/** \brief FC8C, CPUx Overlay Mask Register 31 */

/** Alias (User Manual Name) for CPU0_BLK31_OMASK.
* To use register names with standard convension, please use CPU0_BLK31_OMASK.
*/


/** \brief 1030, CPUx SRI Error Generation Register */


/** \brief 8004, CPUx Task Address Space Identifier Register */


/** \brief 8100, CPUx Data Access CacheabilityRegister */


/** \brief 8104, CPUx Code Access CacheabilityRegister */


/** \brief 8108, CPUx  Peripheral Space Identifier register */


/** \brief 9000, CPUx Data Control Register 2 */


/** \brief 900C, CPUx SIST Mode Access Control Register */


/** \brief 9010, CPUx Data Synchronous Trap Register */


/** \brief 9018, CPUx Data Asynchronous Trap Register */


/** \brief 901C, CPUx Data Error Address Register */


/** \brief 9020, CPUx Data Integrity Error Address Register */


/** \brief 9024, CPUx Data Integrity Error Trap Register */


/** \brief 9040, CPUx Data Memory Control Register */


/** \brief 9200, CPUx Program Synchronous Trap Register */


/** \brief 9204, CPUx Program Control 1 */


/** \brief 9208, CPUx Program Control 2 */


/** \brief 920C, CPUx Program Control 0 */


/** \brief 9210, CPUx Program Integrity Error Address Register */


/** \brief 9214, CPUx Program Integrity Error Trap Register */


/** \brief 9400, CPUx Compatibility Control Register */


/** \brief A000, CPUx Trap Control Register */


/** \brief A004, CPUx Trapping Instruction Program Counter Register */


/** \brief A008, CPUx Trapping Instruction Opcode Register */


/** \brief A010, CPUx Trapping Instruction Operand Register */


/** \brief A014, CPUx Trapping Instruction Operand Register */


/** \brief A018, CPUx Trapping Instruction Operand Register */


/** \brief C000, CPUx Data Protection Range 0, Lower Bound Register */


/** \brief C004, CPUx Data Protection Range 0, Upper Bound Register */


/** \brief C008, CPUx Data Protection Range 1, Lower Bound Register */


/** \brief C00C, CPUx Data Protection Range 1, Upper Bound Register */


/** \brief C010, CPUx Data Protection Range 2, Lower Bound Register */


/** \brief C014, CPUx Data Protection Range 2, Upper Bound Register */


/** \brief C018, CPUx Data Protection Range 3, Lower Bound Register */


/** \brief C01C, CPUx Data Protection Range 3, Upper Bound Register */


/** \brief C020, CPUx Data Protection Range 4, Lower Bound Register */


/** \brief C024, CPUx Data Protection Range 4, Upper Bound Register */


/** \brief C028, CPUx Data Protection Range 5, Lower Bound Register */


/** \brief C02C, CPUx Data Protection Range 5, Upper Bound Register */


/** \brief C030, CPUx Data Protection Range 6, Lower Bound Register */


/** \brief C034, CPUx Data Protection Range 6, Upper Bound Register */


/** \brief C038, CPUx Data Protection Range 7, Lower Bound Register */


/** \brief C03C, CPUx Data Protection Range 7, Upper Bound Register */


/** \brief C040, CPUx Data Protection Range 8, Lower Bound Register */


/** \brief C044, CPUx Data Protection Range 8, Upper Bound Register */


/** \brief C048, CPUx Data Protection Range 9, Lower Bound Register */


/** \brief C04C, CPUx Data Protection Range 9, Upper Bound Register */


/** \brief C050, CPUx Data Protection Range 10, Lower Bound Register */


/** \brief C054, CPUx Data Protection Range 10, Upper Bound Register */


/** \brief C058, CPUx Data Protection Range 11, Lower Bound Register */


/** \brief C05C, CPUx Data Protection Range 11, Upper Bound Register */


/** \brief C060, CPUx Data Protection Range 12, Lower Bound Register */


/** \brief C064, CPUx Data Protection Range 12, Upper Bound Register */


/** \brief C068, CPUx Data Protection Range 13, Lower Bound Register */


/** \brief C06C, CPUx Data Protection Range 13, Upper Bound Register */


/** \brief C070, CPUx Data Protection Range 14, Lower Bound Register */


/** \brief C074, CPUx Data Protection Range 14, Upper Bound Register */


/** \brief C078, CPUx Data Protection Range 15, Lower Bound Register */


/** \brief C07C, CPUx Data Protection Range 15, Upper Bound Register */


/** \brief C080, CPUx Data Protection Range 16, Lower Bound Register */


/** \brief C084, CPUx Data Protection Range 16, Upper Bound Register */


/** \brief C088, CPUx Data Protection Range 17, Lower Bound Register */


/** \brief C08C, CPUx Data Protection Range 17, Upper Bound Register */


/** \brief D000, CPUx Code Protection Range 0 Lower Bound Register */


/** \brief D004, CPUx Code Protection Range 0 Upper Bound Register */


/** \brief D008, CPUx Code Protection Range 1 Lower Bound Register */


/** \brief D00C, CPUx Code Protection Range 1 Upper Bound Register */


/** \brief D010, CPUx Code Protection Range 2 Lower Bound Register */


/** \brief D014, CPUx Code Protection Range 2 Upper Bound Register */


/** \brief D018, CPUx Code Protection Range 3 Lower Bound Register */


/** \brief D01C, CPUx Code Protection Range 3 Upper Bound Register */


/** \brief D020, CPUx Code Protection Range 4 Lower Bound Register */


/** \brief D024, CPUx Code Protection Range 4 Upper Bound Register */


/** \brief D028, CPUx Code Protection Range 5 Lower Bound Register */


/** \brief D02C, CPUx Code Protection Range 5 Upper Bound Register */


/** \brief D030, CPUx Code Protection Range 6 Lower Bound Register */


/** \brief D034, CPUx Code Protection Range 6 Upper Bound Register */


/** \brief D038, CPUx Code Protection Range 7 Lower Bound Register */


/** \brief D03C, CPUx Code Protection Range 7 Upper Bound Register */


/** \brief D040, CPUx Code Protection Range 8 Lower Bound Register */


/** \brief D044, CPUx Code Protection Range 8 Upper Bound Register */


/** \brief D048, CPUx Code Protection Range 9 Lower Bound Register */


/** \brief D04C, CPUx Code Protection Range 9 Upper Bound Register */


/** \brief E000, CPUx Code Protection Execute Enable Register Set 0 */


/** \brief E004, CPUx Code Protection Execute Enable Register Set 1 */


/** \brief E008, CPUx Code Protection Execute Enable Register Set 2 */


/** \brief E00C, CPUx Code Protection Execute Enable Register Set 3 */


/** \brief E010, CPUx Data Protection Read Enable Register Set 0 */


/** \brief E014, CPUx Data Protection Read Enable Register Set 1 */


/** \brief E018, CPUx Data Protection Read Enable Register Set 2 */


/** \brief E01C, CPUx Data Protection Read Enable Register Set 3 */


/** \brief E020, CPUx Data Protection Write Enable Register Set 0 */


/** \brief E024, CPUx Data Protection Write Enable Register Set 1 */


/** \brief E028, CPUx Data Protection Write Enable Register Set 2 */


/** \brief E02C, CPUx Data Protection Write Enable Register Set 3 */


/** \brief E040, CPUx Code Protection Execute Enable Register Set 4 */


/** \brief E044, CPUx Code Protection Execute Enable Register Set 5 */


/** \brief E050, CPUx Data Protection Read Enable Register Set 4 */


/** \brief E054, CPUx Data Protection Read Enable Register Set 5 */


/** \brief E060, CPUx Data Protection Write Enable Register Set 4 */


/** \brief E064, CPUx Data Protection Write Enable Register Set 5 */


/** \brief E400, CPUx Temporal Protection System Control Register */


/** \brief E404, CPUx Temporal Protection System Timer Register 0 */


/** \brief E408, CPUx Temporal Protection System Timer Register 1 */


/** \brief E40C, CPUx Temporal Protection System Timer Register 2 */


/** \brief E440, CPUx Exception Entry Timer Load Value */


/** \brief E444, CPUx Exception Entry Timer Current Value */


/** \brief E448, CPUx Exception Exit  Timer Load Value */


/** \brief E44C, CPUx Exception Exit Timer Current Value */


/** \brief E450, CPUx Exception Timer Class Enable Register */


/** \brief E454, CPUx Exception Timer Status Register */


/** \brief E458, CPUx Exception Timer FCX Register */


/** \brief F000, CPUx Trigger Event 0 */

/** Alias (User Manual Name) for CPU0_TR0_EVT.
* To use register names with standard convension, please use CPU0_TR0_EVT.
*/


/** \brief F004, CPUx Trigger Address 0 */

/** Alias (User Manual Name) for CPU0_TR0_ADR.
* To use register names with standard convension, please use CPU0_TR0_ADR.
*/


/** \brief F008, CPUx Trigger Event 1 */

/** Alias (User Manual Name) for CPU0_TR1_EVT.
* To use register names with standard convension, please use CPU0_TR1_EVT.
*/


/** \brief F00C, CPUx Trigger Address 1 */

/** Alias (User Manual Name) for CPU0_TR1_ADR.
* To use register names with standard convension, please use CPU0_TR1_ADR.
*/


/** \brief F010, CPUx Trigger Event 2 */

/** Alias (User Manual Name) for CPU0_TR2_EVT.
* To use register names with standard convension, please use CPU0_TR2_EVT.
*/


/** \brief F014, CPUx Trigger Address 2 */

/** Alias (User Manual Name) for CPU0_TR2_ADR.
* To use register names with standard convension, please use CPU0_TR2_ADR.
*/


/** \brief F018, CPUx Trigger Event 3 */

/** Alias (User Manual Name) for CPU0_TR3_EVT.
* To use register names with standard convension, please use CPU0_TR3_EVT.
*/


/** \brief F01C, CPUx Trigger Address 3 */

/** Alias (User Manual Name) for CPU0_TR3_ADR.
* To use register names with standard convension, please use CPU0_TR3_ADR.
*/


/** \brief F020, CPUx Trigger Event 4 */

/** Alias (User Manual Name) for CPU0_TR4_EVT.
* To use register names with standard convension, please use CPU0_TR4_EVT.
*/


/** \brief F024, CPUx Trigger Address 4 */

/** Alias (User Manual Name) for CPU0_TR4_ADR.
* To use register names with standard convension, please use CPU0_TR4_ADR.
*/


/** \brief F028, CPUx Trigger Event 5 */

/** Alias (User Manual Name) for CPU0_TR5_EVT.
* To use register names with standard convension, please use CPU0_TR5_EVT.
*/


/** \brief F02C, CPUx Trigger Address 5 */

/** Alias (User Manual Name) for CPU0_TR5_ADR.
* To use register names with standard convension, please use CPU0_TR5_ADR.
*/


/** \brief F030, CPUx Trigger Event 6 */

/** Alias (User Manual Name) for CPU0_TR6_EVT.
* To use register names with standard convension, please use CPU0_TR6_EVT.
*/


/** \brief F034, CPUx Trigger Address 6 */

/** Alias (User Manual Name) for CPU0_TR6_ADR.
* To use register names with standard convension, please use CPU0_TR6_ADR.
*/


/** \brief F038, CPUx Trigger Event 7 */

/** Alias (User Manual Name) for CPU0_TR7_EVT.
* To use register names with standard convension, please use CPU0_TR7_EVT.
*/


/** \brief F03C, CPUx Trigger Address 7 */

/** Alias (User Manual Name) for CPU0_TR7_ADR.
* To use register names with standard convension, please use CPU0_TR7_ADR.
*/


/** \brief FC00, CPUx Counter Control */


/** \brief FC04, CPUx CPU Clock Cycle Count */


/** \brief FC08, CPUx Instruction Count */


/** \brief FC0C, CPUx Multi-Count Register 1 */


/** \brief FC10, CPUx Multi-Count Register 2 */


/** \brief FC14, CPUx Multi-Count Register 3 */


/** \brief FD00, CPUx Debug Status Register */


/** \brief FD08, CPUx External Event Register */


/** \brief FD0C, CPUx Core Register Access Event */


/** \brief FD10, CPUx Software Debug Event */


/** \brief FD30, CPUx TriggerAddressx */


/** \brief FD40, CPUx Debug Monitor Start Address */


/** \brief FD44, CPUx Debug Context Save Area Pointer */


/** \brief FD48, CPUx Debug Trap Control Register */


/** \brief FE00, CPUx Previous Context Information Register */


/** \brief FE04, CPUx Program Status Word */


/** \brief FE08, CPUx Program Counter */


/** \brief FE14, CPUx System Configuration Register */


/** \brief FE18, CPUx Identification Register TC1.6.2P */


/** \brief FE1C, CPUx Core Identification Register */


/** \brief FE20, CPUx Base Interrupt Vector Table Pointer */


/** \brief FE24, CPUx Base Trap Vector Table Pointer */


/** \brief FE28, CPUx Interrupt Stack Pointer */


/** \brief FE2C, CPUx Interrupt Control Register */


/** \brief FE38, CPUx Free CSA List Head Pointer */


/** \brief FE3C, CPUx Free CSA List Limit Pointer */


/** \brief FE50, CPUx Customer ID register */


/** \brief FF00, CPUx Data General Purpose Register 0 */


/** \brief FF04, CPUx Data General Purpose Register 1 */


/** \brief FF08, CPUx Data General Purpose Register 2 */


/** \brief FF0C, CPUx Data General Purpose Register 3 */


/** \brief FF10, CPUx Data General Purpose Register 4 */


/** \brief FF14, CPUx Data General Purpose Register 5 */


/** \brief FF18, CPUx Data General Purpose Register 6 */


/** \brief FF1C, CPUx Data General Purpose Register 7 */


/** \brief FF20, CPUx Data General Purpose Register 8 */


/** \brief FF24, CPUx Data General Purpose Register 9 */


/** \brief FF28, CPUx Data General Purpose Register 10 */


/** \brief FF2C, CPUx Data General Purpose Register 11 */


/** \brief FF30, CPUx Data General Purpose Register 12 */


/** \brief FF34, CPUx Data General Purpose Register 13 */


/** \brief FF38, CPUx Data General Purpose Register 14 */


/** \brief FF3C, CPUx Data General Purpose Register 15 */


/** \brief FF80, CPUx Address General Purpose Register 0 */


/** \brief FF84, CPUx Address General Purpose Register 1 */


/** \brief FF88, CPUx Address General Purpose Register 2 */


/** \brief FF8C, CPUx Address General Purpose Register 3 */


/** \brief FF90, CPUx Address General Purpose Register 4 */


/** \brief FF94, CPUx Address General Purpose Register 5 */


/** \brief FF98, CPUx Address General Purpose Register 6 */


/** \brief FF9C, CPUx Address General Purpose Register 7 */


/** \brief FFA0, CPUx Address General Purpose Register 8 */


/** \brief FFA4, CPUx Address General Purpose Register 9 */


/** \brief FFA8, CPUx Address General Purpose Register 10 */


/** \brief FFAC, CPUx Address General Purpose Register 11 */


/** \brief FFB0, CPUx Address General Purpose Register 12 */


/** \brief FFB4, CPUx Address General Purpose Register 13 */


/** \brief FFB8, CPUx Address General Purpose Register 14 */


/** \brief FFBC, CPUx Address General Purpose Register 15 */


/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Cpu_Registers_Cfg_Cpu1
 * \{  */
/** \brief 1100, CPUx Flash Configuration Register 0 */


/** \brief 1104, CPUx Flash Configuration Register 1 */


/** \brief 1108, CPUx Flash Configuration Register 2 */


/** \brief 110C, CPUx Flash Configuration Register 3 */


/** \brief 1110, CPUx Flash Configuration Register 4 */


/** \brief D000, CPUx  Reset Register 0 */


/** \brief D004, CPUx  Reset Register 1 */


/** \brief D008, CPUx Reset Clear Register */


/** \brief E000, CPUx Safety Protection SPR Region Lower Address Register 0 */

/** Alias (User Manual Name) for CPU1_RGN0_LA.
* To use register names with standard convension, please use CPU1_RGN0_LA.
*/


/** \brief E004, CPUx Safety Protection SPR Region Upper Address Register 0 */

/** Alias (User Manual Name) for CPU1_RGN0_UA.
* To use register names with standard convension, please use CPU1_RGN0_UA.
*/


/** \brief E008, CPUx Safety Protection SPR Region Write Access Enable Register A0 */

/** Alias (User Manual Name) for CPU1_RGN0_ACCENA.
* To use register names with standard convension, please use CPU1_RGN0_ACCENA.
*/


/** \brief E00C, CPUx Safety Protection SPR Region Write Access Enable Register B0 */

/** Alias (User Manual Name) for CPU1_RGN0_ACCENB.
* To use register names with standard convension, please use CPU1_RGN0_ACCENB.
*/


/** \brief E010, CPUx Safety Protection SPR Region Lower Address Register 1 */

/** Alias (User Manual Name) for CPU1_RGN1_LA.
* To use register names with standard convension, please use CPU1_RGN1_LA.
*/


/** \brief E014, CPUx Safety Protection SPR Region Upper Address Register 1 */

/** Alias (User Manual Name) for CPU1_RGN1_UA.
* To use register names with standard convension, please use CPU1_RGN1_UA.
*/


/** \brief E018, CPUx Safety Protection SPR Region Write Access Enable Register A1 */

/** Alias (User Manual Name) for CPU1_RGN1_ACCENA.
* To use register names with standard convension, please use CPU1_RGN1_ACCENA.
*/


/** \brief E01C, CPUx Safety Protection SPR Region Write Access Enable Register B1 */

/** Alias (User Manual Name) for CPU1_RGN1_ACCENB.
* To use register names with standard convension, please use CPU1_RGN1_ACCENB.
*/


/** \brief E020, CPUx Safety Protection SPR Region Lower Address Register 2 */

/** Alias (User Manual Name) for CPU1_RGN2_LA.
* To use register names with standard convension, please use CPU1_RGN2_LA.
*/


/** \brief E024, CPUx Safety Protection SPR Region Upper Address Register 2 */

/** Alias (User Manual Name) for CPU1_RGN2_UA.
* To use register names with standard convension, please use CPU1_RGN2_UA.
*/


/** \brief E028, CPUx Safety Protection SPR Region Write Access Enable Register A2 */

/** Alias (User Manual Name) for CPU1_RGN2_ACCENA.
* To use register names with standard convension, please use CPU1_RGN2_ACCENA.
*/


/** \brief E02C, CPUx Safety Protection SPR Region Write Access Enable Register B2 */

/** Alias (User Manual Name) for CPU1_RGN2_ACCENB.
* To use register names with standard convension, please use CPU1_RGN2_ACCENB.
*/


/** \brief E030, CPUx Safety Protection SPR Region Lower Address Register 3 */

/** Alias (User Manual Name) for CPU1_RGN3_LA.
* To use register names with standard convension, please use CPU1_RGN3_LA.
*/


/** \brief E034, CPUx Safety Protection SPR Region Upper Address Register 3 */

/** Alias (User Manual Name) for CPU1_RGN3_UA.
* To use register names with standard convension, please use CPU1_RGN3_UA.
*/


/** \brief E038, CPUx Safety Protection SPR Region Write Access Enable Register A3 */

/** Alias (User Manual Name) for CPU1_RGN3_ACCENA.
* To use register names with standard convension, please use CPU1_RGN3_ACCENA.
*/


/** \brief E03C, CPUx Safety Protection SPR Region Write Access Enable Register B3 */

/** Alias (User Manual Name) for CPU1_RGN3_ACCENB.
* To use register names with standard convension, please use CPU1_RGN3_ACCENB.
*/


/** \brief E040, CPUx Safety Protection SPR Region Lower Address Register 4 */

/** Alias (User Manual Name) for CPU1_RGN4_LA.
* To use register names with standard convension, please use CPU1_RGN4_LA.
*/


/** \brief E044, CPUx Safety Protection SPR Region Upper Address Register 4 */

/** Alias (User Manual Name) for CPU1_RGN4_UA.
* To use register names with standard convension, please use CPU1_RGN4_UA.
*/


/** \brief E048, CPUx Safety Protection SPR Region Write Access Enable Register A4 */

/** Alias (User Manual Name) for CPU1_RGN4_ACCENA.
* To use register names with standard convension, please use CPU1_RGN4_ACCENA.
*/


/** \brief E04C, CPUx Safety Protection SPR Region Write Access Enable Register B4 */

/** Alias (User Manual Name) for CPU1_RGN4_ACCENB.
* To use register names with standard convension, please use CPU1_RGN4_ACCENB.
*/


/** \brief E050, CPUx Safety Protection SPR Region Lower Address Register 5 */

/** Alias (User Manual Name) for CPU1_RGN5_LA.
* To use register names with standard convension, please use CPU1_RGN5_LA.
*/


/** \brief E054, CPUx Safety Protection SPR Region Upper Address Register 5 */

/** Alias (User Manual Name) for CPU1_RGN5_UA.
* To use register names with standard convension, please use CPU1_RGN5_UA.
*/


/** \brief E058, CPUx Safety Protection SPR Region Write Access Enable Register A5 */

/** Alias (User Manual Name) for CPU1_RGN5_ACCENA.
* To use register names with standard convension, please use CPU1_RGN5_ACCENA.
*/


/** \brief E05C, CPUx Safety Protection SPR Region Write Access Enable Register B5 */

/** Alias (User Manual Name) for CPU1_RGN5_ACCENB.
* To use register names with standard convension, please use CPU1_RGN5_ACCENB.
*/


/** \brief E060, CPUx Safety Protection SPR Region Lower Address Register 6 */

/** Alias (User Manual Name) for CPU1_RGN6_LA.
* To use register names with standard convension, please use CPU1_RGN6_LA.
*/


/** \brief E064, CPUx Safety Protection SPR Region Upper Address Register 6 */

/** Alias (User Manual Name) for CPU1_RGN6_UA.
* To use register names with standard convension, please use CPU1_RGN6_UA.
*/


/** \brief E068, CPUx Safety Protection SPR Region Write Access Enable Register A6 */

/** Alias (User Manual Name) for CPU1_RGN6_ACCENA.
* To use register names with standard convension, please use CPU1_RGN6_ACCENA.
*/


/** \brief E06C, CPUx Safety Protection SPR Region Write Access Enable Register B6 */

/** Alias (User Manual Name) for CPU1_RGN6_ACCENB.
* To use register names with standard convension, please use CPU1_RGN6_ACCENB.
*/


/** \brief E070, CPUx Safety Protection SPR Region Lower Address Register 7 */

/** Alias (User Manual Name) for CPU1_RGN7_LA.
* To use register names with standard convension, please use CPU1_RGN7_LA.
*/


/** \brief E074, CPUx Safety Protection SPR Region Upper Address Register 7 */

/** Alias (User Manual Name) for CPU1_RGN7_UA.
* To use register names with standard convension, please use CPU1_RGN7_UA.
*/


/** \brief E078, CPUx Safety Protection SPR Region Write Access Enable Register A7 */

/** Alias (User Manual Name) for CPU1_RGN7_ACCENA.
* To use register names with standard convension, please use CPU1_RGN7_ACCENA.
*/


/** \brief E07C, CPUx Safety Protection SPR Region Write Access Enable Register B7 */

/** Alias (User Manual Name) for CPU1_RGN7_ACCENB.
* To use register names with standard convension, please use CPU1_RGN7_ACCENB.
*/


/** \brief E088, CPUx Safety Protection SPR Region Read Access Enable Register A0 */

/** Alias (User Manual Name) for CPU1_SPR_SPROT_RGNACCENA_R0.
* To use register names with standard convension, please use CPU1_SPR_SPROT_RGNACCENA_R0.
*/


/** \brief E08C, CPUx Safety Protection SPR Region Read Access Enable Register B0 */

/** Alias (User Manual Name) for CPU1_SPR_SPROT_RGNACCENB_R0.
* To use register names with standard convension, please use CPU1_SPR_SPROT_RGNACCENB_R0.
*/


/** \brief E098, CPUx Safety Protection SPR Region Read Access Enable Register A1 */

/** Alias (User Manual Name) for CPU1_SPR_SPROT_RGNACCENA_R1.
* To use register names with standard convension, please use CPU1_SPR_SPROT_RGNACCENA_R1.
*/


/** \brief E09C, CPUx Safety Protection SPR Region Read Access Enable Register B1 */

/** Alias (User Manual Name) for CPU1_SPR_SPROT_RGNACCENB_R1.
* To use register names with standard convension, please use CPU1_SPR_SPROT_RGNACCENB_R1.
*/


/** \brief E0A8, CPUx Safety Protection SPR Region Read Access Enable Register A2 */

/** Alias (User Manual Name) for CPU1_SPR_SPROT_RGNACCENA_R2.
* To use register names with standard convension, please use CPU1_SPR_SPROT_RGNACCENA_R2.
*/


/** \brief E0AC, CPUx Safety Protection SPR Region Read Access Enable Register B2 */

/** Alias (User Manual Name) for CPU1_SPR_SPROT_RGNACCENB_R2.
* To use register names with standard convension, please use CPU1_SPR_SPROT_RGNACCENB_R2.
*/


/** \brief E0B8, CPUx Safety Protection SPR Region Read Access Enable Register A3 */

/** Alias (User Manual Name) for CPU1_SPR_SPROT_RGNACCENA_R3.
* To use register names with standard convension, please use CPU1_SPR_SPROT_RGNACCENA_R3.
*/


/** \brief E0BC, CPUx Safety Protection SPR Region Read Access Enable Register B3 */

/** Alias (User Manual Name) for CPU1_SPR_SPROT_RGNACCENB_R3.
* To use register names with standard convension, please use CPU1_SPR_SPROT_RGNACCENB_R3.
*/


/** \brief E0C8, CPUx Safety Protection SPR Region Read Access Enable Register A4 */

/** Alias (User Manual Name) for CPU1_SPR_SPROT_RGNACCENA_R4.
* To use register names with standard convension, please use CPU1_SPR_SPROT_RGNACCENA_R4.
*/


/** \brief E0CC, CPUx Safety Protection SPR Region Read Access Enable Register B4 */

/** Alias (User Manual Name) for CPU1_SPR_SPROT_RGNACCENB_R4.
* To use register names with standard convension, please use CPU1_SPR_SPROT_RGNACCENB_R4.
*/


/** \brief E0D8, CPUx Safety Protection SPR Region Read Access Enable Register A5 */

/** Alias (User Manual Name) for CPU1_SPR_SPROT_RGNACCENA_R5.
* To use register names with standard convension, please use CPU1_SPR_SPROT_RGNACCENA_R5.
*/


/** \brief E0DC, CPUx Safety Protection SPR Region Read Access Enable Register B5 */

/** Alias (User Manual Name) for CPU1_SPR_SPROT_RGNACCENB_R5.
* To use register names with standard convension, please use CPU1_SPR_SPROT_RGNACCENB_R5.
*/


/** \brief E0E8, CPUx Safety Protection SPR Region Read Access Enable Register A6 */

/** Alias (User Manual Name) for CPU1_SPR_SPROT_RGNACCENA_R6.
* To use register names with standard convension, please use CPU1_SPR_SPROT_RGNACCENA_R6.
*/


/** \brief E0EC, CPUx Safety Protection SPR Region Read Access Enable Register B6 */

/** Alias (User Manual Name) for CPU1_SPR_SPROT_RGNACCENB_R6.
* To use register names with standard convension, please use CPU1_SPR_SPROT_RGNACCENB_R6.
*/


/** \brief E0F8, CPUx Safety Protection SPR Region Read Access Enable Register A7 */

/** Alias (User Manual Name) for CPU1_SPR_SPROT_RGNACCENA_R7.
* To use register names with standard convension, please use CPU1_SPR_SPROT_RGNACCENA_R7.
*/


/** \brief E0FC, CPUx Safety Protection SPR Region Read Access Enable Register B7 */

/** Alias (User Manual Name) for CPU1_SPR_SPROT_RGNACCENB_R7.
* To use register names with standard convension, please use CPU1_SPR_SPROT_RGNACCENB_R7.
*/


/** \brief E100, CPUx Safety Protection Register Access Enable Register A */


/** \brief E104, CPUx Safety Protection Region Access Enable Register B */


/** \brief E110, CPUx Safety Protection Region LPB Read Access Enable Register A */


/** \brief E114, CPUx Safety Protection Region LPB Read Access Enable Register B */


/** \brief E200, CPUx Safety Protection DLMU Region Lower Address Register 0 */


/** \brief E204, CPUx Safety protection DLMU Region Upper Address Register 0 */


/** \brief E208, CPUx Safety Protection Region DLMU Write Access Enable Register A0 */

/** Alias (User Manual Name) for CPU1_DLMU_SPROT_RGNACCENA_W0.
* To use register names with standard convension, please use CPU1_DLMU_SPROT_RGNACCENA_W0.
*/


/** \brief E20C, CPUx Safety Protection Region DLMU Write Access Enable Register B0 */

/** Alias (User Manual Name) for CPU1_DLMU_SPROT_RGNACCENB_W0.
* To use register names with standard convension, please use CPU1_DLMU_SPROT_RGNACCENB_W0.
*/


/** \brief E210, CPUx Safety Protection DLMU Region Lower Address Register 1 */


/** \brief E214, CPUx Safety protection DLMU Region Upper Address Register 1 */


/** \brief E218, CPUx Safety Protection Region DLMU Write Access Enable Register A1 */

/** Alias (User Manual Name) for CPU1_DLMU_SPROT_RGNACCENA_W1.
* To use register names with standard convension, please use CPU1_DLMU_SPROT_RGNACCENA_W1.
*/


/** \brief E21C, CPUx Safety Protection Region DLMU Write Access Enable Register B1 */

/** Alias (User Manual Name) for CPU1_DLMU_SPROT_RGNACCENB_W1.
* To use register names with standard convension, please use CPU1_DLMU_SPROT_RGNACCENB_W1.
*/


/** \brief E220, CPUx Safety Protection DLMU Region Lower Address Register 2 */


/** \brief E224, CPUx Safety protection DLMU Region Upper Address Register 2 */


/** \brief E228, CPUx Safety Protection Region DLMU Write Access Enable Register A2 */

/** Alias (User Manual Name) for CPU1_DLMU_SPROT_RGNACCENA_W2.
* To use register names with standard convension, please use CPU1_DLMU_SPROT_RGNACCENA_W2.
*/


/** \brief E22C, CPUx Safety Protection Region DLMU Write Access Enable Register B2 */

/** Alias (User Manual Name) for CPU1_DLMU_SPROT_RGNACCENB_W2.
* To use register names with standard convension, please use CPU1_DLMU_SPROT_RGNACCENB_W2.
*/


/** \brief E230, CPUx Safety Protection DLMU Region Lower Address Register 3 */


/** \brief E234, CPUx Safety protection DLMU Region Upper Address Register 3 */


/** \brief E238, CPUx Safety Protection Region DLMU Write Access Enable Register A3 */

/** Alias (User Manual Name) for CPU1_DLMU_SPROT_RGNACCENA_W3.
* To use register names with standard convension, please use CPU1_DLMU_SPROT_RGNACCENA_W3.
*/


/** \brief E23C, CPUx Safety Protection Region DLMU Write Access Enable Register B3 */

/** Alias (User Manual Name) for CPU1_DLMU_SPROT_RGNACCENB_W3.
* To use register names with standard convension, please use CPU1_DLMU_SPROT_RGNACCENB_W3.
*/


/** \brief E240, CPUx Safety Protection DLMU Region Lower Address Register 4 */


/** \brief E244, CPUx Safety protection DLMU Region Upper Address Register 4 */


/** \brief E248, CPUx Safety Protection Region DLMU Write Access Enable Register A4 */

/** Alias (User Manual Name) for CPU1_DLMU_SPROT_RGNACCENA_W4.
* To use register names with standard convension, please use CPU1_DLMU_SPROT_RGNACCENA_W4.
*/


/** \brief E24C, CPUx Safety Protection Region DLMU Write Access Enable Register B4 */

/** Alias (User Manual Name) for CPU1_DLMU_SPROT_RGNACCENB_W4.
* To use register names with standard convension, please use CPU1_DLMU_SPROT_RGNACCENB_W4.
*/


/** \brief E250, CPUx Safety Protection DLMU Region Lower Address Register 5 */


/** \brief E254, CPUx Safety protection DLMU Region Upper Address Register 5 */


/** \brief E258, CPUx Safety Protection Region DLMU Write Access Enable Register A5 */

/** Alias (User Manual Name) for CPU1_DLMU_SPROT_RGNACCENA_W5.
* To use register names with standard convension, please use CPU1_DLMU_SPROT_RGNACCENA_W5.
*/


/** \brief E25C, CPUx Safety Protection Region DLMU Write Access Enable Register B5 */

/** Alias (User Manual Name) for CPU1_DLMU_SPROT_RGNACCENB_W5.
* To use register names with standard convension, please use CPU1_DLMU_SPROT_RGNACCENB_W5.
*/


/** \brief E260, CPUx Safety Protection DLMU Region Lower Address Register 6 */


/** \brief E264, CPUx Safety protection DLMU Region Upper Address Register 6 */


/** \brief E268, CPUx Safety Protection Region DLMU Write Access Enable Register A6 */

/** Alias (User Manual Name) for CPU1_DLMU_SPROT_RGNACCENA_W6.
* To use register names with standard convension, please use CPU1_DLMU_SPROT_RGNACCENA_W6.
*/


/** \brief E26C, CPUx Safety Protection Region DLMU Write Access Enable Register B6 */

/** Alias (User Manual Name) for CPU1_DLMU_SPROT_RGNACCENB_W6.
* To use register names with standard convension, please use CPU1_DLMU_SPROT_RGNACCENB_W6.
*/


/** \brief E270, CPUx Safety Protection DLMU Region Lower Address Register 7 */


/** \brief E274, CPUx Safety protection DLMU Region Upper Address Register 7 */


/** \brief E278, CPUx Safety Protection Region DLMU Write Access Enable Register A7 */

/** Alias (User Manual Name) for CPU1_DLMU_SPROT_RGNACCENA_W7.
* To use register names with standard convension, please use CPU1_DLMU_SPROT_RGNACCENA_W7.
*/


/** \brief E27C, CPUx Safety Protection Region DLMU Write Access Enable Register B7 */

/** Alias (User Manual Name) for CPU1_DLMU_SPROT_RGNACCENB_W7.
* To use register names with standard convension, please use CPU1_DLMU_SPROT_RGNACCENB_W7.
*/


/** \brief E288, CPUx Safety Protection Region DLMU Read Access Enable Register A0 */

/** Alias (User Manual Name) for CPU1_DLMU_SPROT_RGNACCENA_R0.
* To use register names with standard convension, please use CPU1_DLMU_SPROT_RGNACCENA_R0.
*/


/** \brief E28C, CPUx Safety Protection Region DLMU Read Access Enable Register B0 */

/** Alias (User Manual Name) for CPU1_DLMU_SPROT_RGNACCENB_R0.
* To use register names with standard convension, please use CPU1_DLMU_SPROT_RGNACCENB_R0.
*/


/** \brief E298, CPUx Safety Protection Region DLMU Read Access Enable Register A1 */

/** Alias (User Manual Name) for CPU1_DLMU_SPROT_RGNACCENA_R1.
* To use register names with standard convension, please use CPU1_DLMU_SPROT_RGNACCENA_R1.
*/


/** \brief E29C, CPUx Safety Protection Region DLMU Read Access Enable Register B1 */

/** Alias (User Manual Name) for CPU1_DLMU_SPROT_RGNACCENB_R1.
* To use register names with standard convension, please use CPU1_DLMU_SPROT_RGNACCENB_R1.
*/


/** \brief E2A8, CPUx Safety Protection Region DLMU Read Access Enable Register A2 */

/** Alias (User Manual Name) for CPU1_DLMU_SPROT_RGNACCENA_R2.
* To use register names with standard convension, please use CPU1_DLMU_SPROT_RGNACCENA_R2.
*/


/** \brief E2AC, CPUx Safety Protection Region DLMU Read Access Enable Register B2 */

/** Alias (User Manual Name) for CPU1_DLMU_SPROT_RGNACCENB_R2.
* To use register names with standard convension, please use CPU1_DLMU_SPROT_RGNACCENB_R2.
*/


/** \brief E2B8, CPUx Safety Protection Region DLMU Read Access Enable Register A3 */

/** Alias (User Manual Name) for CPU1_DLMU_SPROT_RGNACCENA_R3.
* To use register names with standard convension, please use CPU1_DLMU_SPROT_RGNACCENA_R3.
*/


/** \brief E2BC, CPUx Safety Protection Region DLMU Read Access Enable Register B3 */

/** Alias (User Manual Name) for CPU1_DLMU_SPROT_RGNACCENB_R3.
* To use register names with standard convension, please use CPU1_DLMU_SPROT_RGNACCENB_R3.
*/


/** \brief E2C8, CPUx Safety Protection Region DLMU Read Access Enable Register A4 */

/** Alias (User Manual Name) for CPU1_DLMU_SPROT_RGNACCENA_R4.
* To use register names with standard convension, please use CPU1_DLMU_SPROT_RGNACCENA_R4.
*/


/** \brief E2CC, CPUx Safety Protection Region DLMU Read Access Enable Register B4 */

/** Alias (User Manual Name) for CPU1_DLMU_SPROT_RGNACCENB_R4.
* To use register names with standard convension, please use CPU1_DLMU_SPROT_RGNACCENB_R4.
*/


/** \brief E2D8, CPUx Safety Protection Region DLMU Read Access Enable Register A5 */

/** Alias (User Manual Name) for CPU1_DLMU_SPROT_RGNACCENA_R5.
* To use register names with standard convension, please use CPU1_DLMU_SPROT_RGNACCENA_R5.
*/


/** \brief E2DC, CPUx Safety Protection Region DLMU Read Access Enable Register B5 */

/** Alias (User Manual Name) for CPU1_DLMU_SPROT_RGNACCENB_R5.
* To use register names with standard convension, please use CPU1_DLMU_SPROT_RGNACCENB_R5.
*/


/** \brief E2E8, CPUx Safety Protection Region DLMU Read Access Enable Register A6 */

/** Alias (User Manual Name) for CPU1_DLMU_SPROT_RGNACCENA_R6.
* To use register names with standard convension, please use CPU1_DLMU_SPROT_RGNACCENA_R6.
*/


/** \brief E2EC, CPUx Safety Protection Region DLMU Read Access Enable Register B6 */

/** Alias (User Manual Name) for CPU1_DLMU_SPROT_RGNACCENB_R6.
* To use register names with standard convension, please use CPU1_DLMU_SPROT_RGNACCENB_R6.
*/


/** \brief E2F8, CPUx Safety Protection Region DLMU Read Access Enable Register A7 */

/** Alias (User Manual Name) for CPU1_DLMU_SPROT_RGNACCENA_R7.
* To use register names with standard convension, please use CPU1_DLMU_SPROT_RGNACCENA_R7.
*/


/** \brief E2FC, CPUx Safety Protection Region DLMU Read Access Enable Register B7 */

/** Alias (User Manual Name) for CPU1_DLMU_SPROT_RGNACCENB_R7.
* To use register names with standard convension, please use CPU1_DLMU_SPROT_RGNACCENB_R7.
*/


/** \brief FB00, CPUx  Overlay Range Select Register */


/** \brief FB10, CPUx Redirected Address Base Register 0 */

/** Alias (User Manual Name) for CPU1_BLK0_RABR.
* To use register names with standard convension, please use CPU1_BLK0_RABR.
*/


/** \brief FB14, CPUx Overlay Target Address Register 0 */

/** Alias (User Manual Name) for CPU1_BLK0_OTAR.
* To use register names with standard convension, please use CPU1_BLK0_OTAR.
*/


/** \brief FB18, CPUx Overlay Mask Register 0 */

/** Alias (User Manual Name) for CPU1_BLK0_OMASK.
* To use register names with standard convension, please use CPU1_BLK0_OMASK.
*/


/** \brief FB1C, CPUx Redirected Address Base Register 1 */

/** Alias (User Manual Name) for CPU1_BLK1_RABR.
* To use register names with standard convension, please use CPU1_BLK1_RABR.
*/


/** \brief FB20, CPUx Overlay Target Address Register 1 */

/** Alias (User Manual Name) for CPU1_BLK1_OTAR.
* To use register names with standard convension, please use CPU1_BLK1_OTAR.
*/


/** \brief FB24, CPUx Overlay Mask Register 1 */

/** Alias (User Manual Name) for CPU1_BLK1_OMASK.
* To use register names with standard convension, please use CPU1_BLK1_OMASK.
*/


/** \brief FB28, CPUx Redirected Address Base Register 2 */

/** Alias (User Manual Name) for CPU1_BLK2_RABR.
* To use register names with standard convension, please use CPU1_BLK2_RABR.
*/


/** \brief FB2C, CPUx Overlay Target Address Register 2 */

/** Alias (User Manual Name) for CPU1_BLK2_OTAR.
* To use register names with standard convension, please use CPU1_BLK2_OTAR.
*/


/** \brief FB30, CPUx Overlay Mask Register 2 */

/** Alias (User Manual Name) for CPU1_BLK2_OMASK.
* To use register names with standard convension, please use CPU1_BLK2_OMASK.
*/


/** \brief FB34, CPUx Redirected Address Base Register 3 */

/** Alias (User Manual Name) for CPU1_BLK3_RABR.
* To use register names with standard convension, please use CPU1_BLK3_RABR.
*/


/** \brief FB38, CPUx Overlay Target Address Register 3 */

/** Alias (User Manual Name) for CPU1_BLK3_OTAR.
* To use register names with standard convension, please use CPU1_BLK3_OTAR.
*/


/** \brief FB3C, CPUx Overlay Mask Register 3 */

/** Alias (User Manual Name) for CPU1_BLK3_OMASK.
* To use register names with standard convension, please use CPU1_BLK3_OMASK.
*/


/** \brief FB40, CPUx Redirected Address Base Register 4 */

/** Alias (User Manual Name) for CPU1_BLK4_RABR.
* To use register names with standard convension, please use CPU1_BLK4_RABR.
*/


/** \brief FB44, CPUx Overlay Target Address Register 4 */

/** Alias (User Manual Name) for CPU1_BLK4_OTAR.
* To use register names with standard convension, please use CPU1_BLK4_OTAR.
*/


/** \brief FB48, CPUx Overlay Mask Register 4 */

/** Alias (User Manual Name) for CPU1_BLK4_OMASK.
* To use register names with standard convension, please use CPU1_BLK4_OMASK.
*/


/** \brief FB4C, CPUx Redirected Address Base Register 5 */

/** Alias (User Manual Name) for CPU1_BLK5_RABR.
* To use register names with standard convension, please use CPU1_BLK5_RABR.
*/


/** \brief FB50, CPUx Overlay Target Address Register 5 */

/** Alias (User Manual Name) for CPU1_BLK5_OTAR.
* To use register names with standard convension, please use CPU1_BLK5_OTAR.
*/


/** \brief FB54, CPUx Overlay Mask Register 5 */

/** Alias (User Manual Name) for CPU1_BLK5_OMASK.
* To use register names with standard convension, please use CPU1_BLK5_OMASK.
*/


/** \brief FB58, CPUx Redirected Address Base Register 6 */

/** Alias (User Manual Name) for CPU1_BLK6_RABR.
* To use register names with standard convension, please use CPU1_BLK6_RABR.
*/


/** \brief FB5C, CPUx Overlay Target Address Register 6 */

/** Alias (User Manual Name) for CPU1_BLK6_OTAR.
* To use register names with standard convension, please use CPU1_BLK6_OTAR.
*/


/** \brief FB60, CPUx Overlay Mask Register 6 */

/** Alias (User Manual Name) for CPU1_BLK6_OMASK.
* To use register names with standard convension, please use CPU1_BLK6_OMASK.
*/


/** \brief FB64, CPUx Redirected Address Base Register 7 */

/** Alias (User Manual Name) for CPU1_BLK7_RABR.
* To use register names with standard convension, please use CPU1_BLK7_RABR.
*/


/** \brief FB68, CPUx Overlay Target Address Register 7 */

/** Alias (User Manual Name) for CPU1_BLK7_OTAR.
* To use register names with standard convension, please use CPU1_BLK7_OTAR.
*/


/** \brief FB6C, CPUx Overlay Mask Register 7 */

/** Alias (User Manual Name) for CPU1_BLK7_OMASK.
* To use register names with standard convension, please use CPU1_BLK7_OMASK.
*/


/** \brief FB70, CPUx Redirected Address Base Register 8 */

/** Alias (User Manual Name) for CPU1_BLK8_RABR.
* To use register names with standard convension, please use CPU1_BLK8_RABR.
*/


/** \brief FB74, CPUx Overlay Target Address Register 8 */

/** Alias (User Manual Name) for CPU1_BLK8_OTAR.
* To use register names with standard convension, please use CPU1_BLK8_OTAR.
*/


/** \brief FB78, CPUx Overlay Mask Register 8 */

/** Alias (User Manual Name) for CPU1_BLK8_OMASK.
* To use register names with standard convension, please use CPU1_BLK8_OMASK.
*/


/** \brief FB7C, CPUx Redirected Address Base Register 9 */

/** Alias (User Manual Name) for CPU1_BLK9_RABR.
* To use register names with standard convension, please use CPU1_BLK9_RABR.
*/


/** \brief FB80, CPUx Overlay Target Address Register 9 */

/** Alias (User Manual Name) for CPU1_BLK9_OTAR.
* To use register names with standard convension, please use CPU1_BLK9_OTAR.
*/


/** \brief FB84, CPUx Overlay Mask Register 9 */

/** Alias (User Manual Name) for CPU1_BLK9_OMASK.
* To use register names with standard convension, please use CPU1_BLK9_OMASK.
*/


/** \brief FB88, CPUx Redirected Address Base Register 10 */

/** Alias (User Manual Name) for CPU1_BLK10_RABR.
* To use register names with standard convension, please use CPU1_BLK10_RABR.
*/


/** \brief FB8C, CPUx Overlay Target Address Register 10 */

/** Alias (User Manual Name) for CPU1_BLK10_OTAR.
* To use register names with standard convension, please use CPU1_BLK10_OTAR.
*/


/** \brief FB90, CPUx Overlay Mask Register 10 */

/** Alias (User Manual Name) for CPU1_BLK10_OMASK.
* To use register names with standard convension, please use CPU1_BLK10_OMASK.
*/


/** \brief FB94, CPUx Redirected Address Base Register 11 */

/** Alias (User Manual Name) for CPU1_BLK11_RABR.
* To use register names with standard convension, please use CPU1_BLK11_RABR.
*/


/** \brief FB98, CPUx Overlay Target Address Register 11 */

/** Alias (User Manual Name) for CPU1_BLK11_OTAR.
* To use register names with standard convension, please use CPU1_BLK11_OTAR.
*/


/** \brief FB9C, CPUx Overlay Mask Register 11 */

/** Alias (User Manual Name) for CPU1_BLK11_OMASK.
* To use register names with standard convension, please use CPU1_BLK11_OMASK.
*/


/** \brief FBA0, CPUx Redirected Address Base Register 12 */

/** Alias (User Manual Name) for CPU1_BLK12_RABR.
* To use register names with standard convension, please use CPU1_BLK12_RABR.
*/


/** \brief FBA4, CPUx Overlay Target Address Register 12 */

/** Alias (User Manual Name) for CPU1_BLK12_OTAR.
* To use register names with standard convension, please use CPU1_BLK12_OTAR.
*/


/** \brief FBA8, CPUx Overlay Mask Register 12 */

/** Alias (User Manual Name) for CPU1_BLK12_OMASK.
* To use register names with standard convension, please use CPU1_BLK12_OMASK.
*/


/** \brief FBAC, CPUx Redirected Address Base Register 13 */

/** Alias (User Manual Name) for CPU1_BLK13_RABR.
* To use register names with standard convension, please use CPU1_BLK13_RABR.
*/


/** \brief FBB0, CPUx Overlay Target Address Register 13 */

/** Alias (User Manual Name) for CPU1_BLK13_OTAR.
* To use register names with standard convension, please use CPU1_BLK13_OTAR.
*/


/** \brief FBB4, CPUx Overlay Mask Register 13 */

/** Alias (User Manual Name) for CPU1_BLK13_OMASK.
* To use register names with standard convension, please use CPU1_BLK13_OMASK.
*/


/** \brief FBB8, CPUx Redirected Address Base Register 14 */

/** Alias (User Manual Name) for CPU1_BLK14_RABR.
* To use register names with standard convension, please use CPU1_BLK14_RABR.
*/


/** \brief FBBC, CPUx Overlay Target Address Register 14 */

/** Alias (User Manual Name) for CPU1_BLK14_OTAR.
* To use register names with standard convension, please use CPU1_BLK14_OTAR.
*/


/** \brief FBC0, CPUx Overlay Mask Register 14 */

/** Alias (User Manual Name) for CPU1_BLK14_OMASK.
* To use register names with standard convension, please use CPU1_BLK14_OMASK.
*/


/** \brief FBC4, CPUx Redirected Address Base Register 15 */

/** Alias (User Manual Name) for CPU1_BLK15_RABR.
* To use register names with standard convension, please use CPU1_BLK15_RABR.
*/


/** \brief FBC8, CPUx Overlay Target Address Register 15 */

/** Alias (User Manual Name) for CPU1_BLK15_OTAR.
* To use register names with standard convension, please use CPU1_BLK15_OTAR.
*/


/** \brief FBCC, CPUx Overlay Mask Register 15 */

/** Alias (User Manual Name) for CPU1_BLK15_OMASK.
* To use register names with standard convension, please use CPU1_BLK15_OMASK.
*/


/** \brief FBD0, CPUx Redirected Address Base Register 16 */

/** Alias (User Manual Name) for CPU1_BLK16_RABR.
* To use register names with standard convension, please use CPU1_BLK16_RABR.
*/


/** \brief FBD4, CPUx Overlay Target Address Register 16 */

/** Alias (User Manual Name) for CPU1_BLK16_OTAR.
* To use register names with standard convension, please use CPU1_BLK16_OTAR.
*/


/** \brief FBD8, CPUx Overlay Mask Register 16 */

/** Alias (User Manual Name) for CPU1_BLK16_OMASK.
* To use register names with standard convension, please use CPU1_BLK16_OMASK.
*/


/** \brief FBDC, CPUx Redirected Address Base Register 17 */

/** Alias (User Manual Name) for CPU1_BLK17_RABR.
* To use register names with standard convension, please use CPU1_BLK17_RABR.
*/


/** \brief FBE0, CPUx Overlay Target Address Register 17 */

/** Alias (User Manual Name) for CPU1_BLK17_OTAR.
* To use register names with standard convension, please use CPU1_BLK17_OTAR.
*/


/** \brief FBE4, CPUx Overlay Mask Register 17 */

/** Alias (User Manual Name) for CPU1_BLK17_OMASK.
* To use register names with standard convension, please use CPU1_BLK17_OMASK.
*/


/** \brief FBE8, CPUx Redirected Address Base Register 18 */

/** Alias (User Manual Name) for CPU1_BLK18_RABR.
* To use register names with standard convension, please use CPU1_BLK18_RABR.
*/


/** \brief FBEC, CPUx Overlay Target Address Register 18 */

/** Alias (User Manual Name) for CPU1_BLK18_OTAR.
* To use register names with standard convension, please use CPU1_BLK18_OTAR.
*/


/** \brief FBF0, CPUx Overlay Mask Register 18 */

/** Alias (User Manual Name) for CPU1_BLK18_OMASK.
* To use register names with standard convension, please use CPU1_BLK18_OMASK.
*/


/** \brief FBF4, CPUx Redirected Address Base Register 19 */

/** Alias (User Manual Name) for CPU1_BLK19_RABR.
* To use register names with standard convension, please use CPU1_BLK19_RABR.
*/


/** \brief FBF8, CPUx Overlay Target Address Register 19 */

/** Alias (User Manual Name) for CPU1_BLK19_OTAR.
* To use register names with standard convension, please use CPU1_BLK19_OTAR.
*/


/** \brief FBFC, CPUx Overlay Mask Register 19 */

/** Alias (User Manual Name) for CPU1_BLK19_OMASK.
* To use register names with standard convension, please use CPU1_BLK19_OMASK.
*/


/** \brief FC00, CPUx Redirected Address Base Register 20 */

/** Alias (User Manual Name) for CPU1_BLK20_RABR.
* To use register names with standard convension, please use CPU1_BLK20_RABR.
*/


/** \brief FC04, CPUx Overlay Target Address Register 20 */

/** Alias (User Manual Name) for CPU1_BLK20_OTAR.
* To use register names with standard convension, please use CPU1_BLK20_OTAR.
*/


/** \brief FC08, CPUx Overlay Mask Register 20 */

/** Alias (User Manual Name) for CPU1_BLK20_OMASK.
* To use register names with standard convension, please use CPU1_BLK20_OMASK.
*/


/** \brief FC0C, CPUx Redirected Address Base Register 21 */

/** Alias (User Manual Name) for CPU1_BLK21_RABR.
* To use register names with standard convension, please use CPU1_BLK21_RABR.
*/


/** \brief FC10, CPUx Overlay Target Address Register 21 */

/** Alias (User Manual Name) for CPU1_BLK21_OTAR.
* To use register names with standard convension, please use CPU1_BLK21_OTAR.
*/


/** \brief FC14, CPUx Overlay Mask Register 21 */

/** Alias (User Manual Name) for CPU1_BLK21_OMASK.
* To use register names with standard convension, please use CPU1_BLK21_OMASK.
*/


/** \brief FC18, CPUx Redirected Address Base Register 22 */

/** Alias (User Manual Name) for CPU1_BLK22_RABR.
* To use register names with standard convension, please use CPU1_BLK22_RABR.
*/


/** \brief FC1C, CPUx Overlay Target Address Register 22 */

/** Alias (User Manual Name) for CPU1_BLK22_OTAR.
* To use register names with standard convension, please use CPU1_BLK22_OTAR.
*/


/** \brief FC20, CPUx Overlay Mask Register 22 */

/** Alias (User Manual Name) for CPU1_BLK22_OMASK.
* To use register names with standard convension, please use CPU1_BLK22_OMASK.
*/


/** \brief FC24, CPUx Redirected Address Base Register 23 */

/** Alias (User Manual Name) for CPU1_BLK23_RABR.
* To use register names with standard convension, please use CPU1_BLK23_RABR.
*/


/** \brief FC28, CPUx Overlay Target Address Register 23 */

/** Alias (User Manual Name) for CPU1_BLK23_OTAR.
* To use register names with standard convension, please use CPU1_BLK23_OTAR.
*/


/** \brief FC2C, CPUx Overlay Mask Register 23 */

/** Alias (User Manual Name) for CPU1_BLK23_OMASK.
* To use register names with standard convension, please use CPU1_BLK23_OMASK.
*/


/** \brief FC30, CPUx Redirected Address Base Register 24 */

/** Alias (User Manual Name) for CPU1_BLK24_RABR.
* To use register names with standard convension, please use CPU1_BLK24_RABR.
*/


/** \brief FC34, CPUx Overlay Target Address Register 24 */

/** Alias (User Manual Name) for CPU1_BLK24_OTAR.
* To use register names with standard convension, please use CPU1_BLK24_OTAR.
*/


/** \brief FC38, CPUx Overlay Mask Register 24 */

/** Alias (User Manual Name) for CPU1_BLK24_OMASK.
* To use register names with standard convension, please use CPU1_BLK24_OMASK.
*/


/** \brief FC3C, CPUx Redirected Address Base Register 25 */

/** Alias (User Manual Name) for CPU1_BLK25_RABR.
* To use register names with standard convension, please use CPU1_BLK25_RABR.
*/


/** \brief FC40, CPUx Overlay Target Address Register 25 */

/** Alias (User Manual Name) for CPU1_BLK25_OTAR.
* To use register names with standard convension, please use CPU1_BLK25_OTAR.
*/


/** \brief FC44, CPUx Overlay Mask Register 25 */

/** Alias (User Manual Name) for CPU1_BLK25_OMASK.
* To use register names with standard convension, please use CPU1_BLK25_OMASK.
*/


/** \brief FC48, CPUx Redirected Address Base Register 26 */

/** Alias (User Manual Name) for CPU1_BLK26_RABR.
* To use register names with standard convension, please use CPU1_BLK26_RABR.
*/


/** \brief FC4C, CPUx Overlay Target Address Register 26 */

/** Alias (User Manual Name) for CPU1_BLK26_OTAR.
* To use register names with standard convension, please use CPU1_BLK26_OTAR.
*/


/** \brief FC50, CPUx Overlay Mask Register 26 */

/** Alias (User Manual Name) for CPU1_BLK26_OMASK.
* To use register names with standard convension, please use CPU1_BLK26_OMASK.
*/


/** \brief FC54, CPUx Redirected Address Base Register 27 */

/** Alias (User Manual Name) for CPU1_BLK27_RABR.
* To use register names with standard convension, please use CPU1_BLK27_RABR.
*/


/** \brief FC58, CPUx Overlay Target Address Register 27 */

/** Alias (User Manual Name) for CPU1_BLK27_OTAR.
* To use register names with standard convension, please use CPU1_BLK27_OTAR.
*/


/** \brief FC5C, CPUx Overlay Mask Register 27 */

/** Alias (User Manual Name) for CPU1_BLK27_OMASK.
* To use register names with standard convension, please use CPU1_BLK27_OMASK.
*/


/** \brief FC60, CPUx Redirected Address Base Register 28 */

/** Alias (User Manual Name) for CPU1_BLK28_RABR.
* To use register names with standard convension, please use CPU1_BLK28_RABR.
*/


/** \brief FC64, CPUx Overlay Target Address Register 28 */

/** Alias (User Manual Name) for CPU1_BLK28_OTAR.
* To use register names with standard convension, please use CPU1_BLK28_OTAR.
*/


/** \brief FC68, CPUx Overlay Mask Register 28 */

/** Alias (User Manual Name) for CPU1_BLK28_OMASK.
* To use register names with standard convension, please use CPU1_BLK28_OMASK.
*/


/** \brief FC6C, CPUx Redirected Address Base Register 29 */

/** Alias (User Manual Name) for CPU1_BLK29_RABR.
* To use register names with standard convension, please use CPU1_BLK29_RABR.
*/


/** \brief FC70, CPUx Overlay Target Address Register 29 */

/** Alias (User Manual Name) for CPU1_BLK29_OTAR.
* To use register names with standard convension, please use CPU1_BLK29_OTAR.
*/


/** \brief FC74, CPUx Overlay Mask Register 29 */

/** Alias (User Manual Name) for CPU1_BLK29_OMASK.
* To use register names with standard convension, please use CPU1_BLK29_OMASK.
*/


/** \brief FC78, CPUx Redirected Address Base Register 30 */

/** Alias (User Manual Name) for CPU1_BLK30_RABR.
* To use register names with standard convension, please use CPU1_BLK30_RABR.
*/


/** \brief FC7C, CPUx Overlay Target Address Register 30 */

/** Alias (User Manual Name) for CPU1_BLK30_OTAR.
* To use register names with standard convension, please use CPU1_BLK30_OTAR.
*/


/** \brief FC80, CPUx Overlay Mask Register 30 */

/** Alias (User Manual Name) for CPU1_BLK30_OMASK.
* To use register names with standard convension, please use CPU1_BLK30_OMASK.
*/


/** \brief FC84, CPUx Redirected Address Base Register 31 */

/** Alias (User Manual Name) for CPU1_BLK31_RABR.
* To use register names with standard convension, please use CPU1_BLK31_RABR.
*/


/** \brief FC88, CPUx Overlay Target Address Register 31 */

/** Alias (User Manual Name) for CPU1_BLK31_OTAR.
* To use register names with standard convension, please use CPU1_BLK31_OTAR.
*/


/** \brief FC8C, CPUx Overlay Mask Register 31 */

/** Alias (User Manual Name) for CPU1_BLK31_OMASK.
* To use register names with standard convension, please use CPU1_BLK31_OMASK.
*/


/** \brief 1030, CPUx SRI Error Generation Register */


/** \brief 8004, CPUx Task Address Space Identifier Register */


/** \brief 8100, CPUx Data Access CacheabilityRegister */


/** \brief 8104, CPUx Code Access CacheabilityRegister */


/** \brief 8108, CPUx  Peripheral Space Identifier register */


/** \brief 9000, CPUx Data Control Register 2 */


/** \brief 900C, CPUx SIST Mode Access Control Register */


/** \brief 9010, CPUx Data Synchronous Trap Register */


/** \brief 9018, CPUx Data Asynchronous Trap Register */


/** \brief 901C, CPUx Data Error Address Register */


/** \brief 9020, CPUx Data Integrity Error Address Register */


/** \brief 9024, CPUx Data Integrity Error Trap Register */


/** \brief 9040, CPUx Data Memory Control Register */


/** \brief 9200, CPUx Program Synchronous Trap Register */


/** \brief 9204, CPUx Program Control 1 */


/** \brief 9208, CPUx Program Control 2 */


/** \brief 920C, CPUx Program Control 0 */


/** \brief 9210, CPUx Program Integrity Error Address Register */


/** \brief 9214, CPUx Program Integrity Error Trap Register */


/** \brief 9400, CPUx Compatibility Control Register */


/** \brief A000, CPUx Trap Control Register */


/** \brief A004, CPUx Trapping Instruction Program Counter Register */


/** \brief A008, CPUx Trapping Instruction Opcode Register */


/** \brief A010, CPUx Trapping Instruction Operand Register */


/** \brief A014, CPUx Trapping Instruction Operand Register */


/** \brief A018, CPUx Trapping Instruction Operand Register */


/** \brief C000, CPUx Data Protection Range 0, Lower Bound Register */


/** \brief C004, CPUx Data Protection Range 0, Upper Bound Register */


/** \brief C008, CPUx Data Protection Range 1, Lower Bound Register */


/** \brief C00C, CPUx Data Protection Range 1, Upper Bound Register */


/** \brief C010, CPUx Data Protection Range 2, Lower Bound Register */


/** \brief C014, CPUx Data Protection Range 2, Upper Bound Register */


/** \brief C018, CPUx Data Protection Range 3, Lower Bound Register */


/** \brief C01C, CPUx Data Protection Range 3, Upper Bound Register */


/** \brief C020, CPUx Data Protection Range 4, Lower Bound Register */


/** \brief C024, CPUx Data Protection Range 4, Upper Bound Register */


/** \brief C028, CPUx Data Protection Range 5, Lower Bound Register */


/** \brief C02C, CPUx Data Protection Range 5, Upper Bound Register */


/** \brief C030, CPUx Data Protection Range 6, Lower Bound Register */


/** \brief C034, CPUx Data Protection Range 6, Upper Bound Register */


/** \brief C038, CPUx Data Protection Range 7, Lower Bound Register */


/** \brief C03C, CPUx Data Protection Range 7, Upper Bound Register */


/** \brief C040, CPUx Data Protection Range 8, Lower Bound Register */


/** \brief C044, CPUx Data Protection Range 8, Upper Bound Register */


/** \brief C048, CPUx Data Protection Range 9, Lower Bound Register */


/** \brief C04C, CPUx Data Protection Range 9, Upper Bound Register */


/** \brief C050, CPUx Data Protection Range 10, Lower Bound Register */


/** \brief C054, CPUx Data Protection Range 10, Upper Bound Register */


/** \brief C058, CPUx Data Protection Range 11, Lower Bound Register */


/** \brief C05C, CPUx Data Protection Range 11, Upper Bound Register */


/** \brief C060, CPUx Data Protection Range 12, Lower Bound Register */


/** \brief C064, CPUx Data Protection Range 12, Upper Bound Register */


/** \brief C068, CPUx Data Protection Range 13, Lower Bound Register */


/** \brief C06C, CPUx Data Protection Range 13, Upper Bound Register */


/** \brief C070, CPUx Data Protection Range 14, Lower Bound Register */


/** \brief C074, CPUx Data Protection Range 14, Upper Bound Register */


/** \brief C078, CPUx Data Protection Range 15, Lower Bound Register */


/** \brief C07C, CPUx Data Protection Range 15, Upper Bound Register */


/** \brief C080, CPUx Data Protection Range 16, Lower Bound Register */


/** \brief C084, CPUx Data Protection Range 16, Upper Bound Register */


/** \brief C088, CPUx Data Protection Range 17, Lower Bound Register */


/** \brief C08C, CPUx Data Protection Range 17, Upper Bound Register */


/** \brief D000, CPUx Code Protection Range 0 Lower Bound Register */


/** \brief D004, CPUx Code Protection Range 0 Upper Bound Register */


/** \brief D008, CPUx Code Protection Range 1 Lower Bound Register */


/** \brief D00C, CPUx Code Protection Range 1 Upper Bound Register */


/** \brief D010, CPUx Code Protection Range 2 Lower Bound Register */


/** \brief D014, CPUx Code Protection Range 2 Upper Bound Register */


/** \brief D018, CPUx Code Protection Range 3 Lower Bound Register */


/** \brief D01C, CPUx Code Protection Range 3 Upper Bound Register */


/** \brief D020, CPUx Code Protection Range 4 Lower Bound Register */


/** \brief D024, CPUx Code Protection Range 4 Upper Bound Register */


/** \brief D028, CPUx Code Protection Range 5 Lower Bound Register */


/** \brief D02C, CPUx Code Protection Range 5 Upper Bound Register */


/** \brief D030, CPUx Code Protection Range 6 Lower Bound Register */


/** \brief D034, CPUx Code Protection Range 6 Upper Bound Register */


/** \brief D038, CPUx Code Protection Range 7 Lower Bound Register */


/** \brief D03C, CPUx Code Protection Range 7 Upper Bound Register */


/** \brief D040, CPUx Code Protection Range 8 Lower Bound Register */


/** \brief D044, CPUx Code Protection Range 8 Upper Bound Register */


/** \brief D048, CPUx Code Protection Range 9 Lower Bound Register */


/** \brief D04C, CPUx Code Protection Range 9 Upper Bound Register */


/** \brief E000, CPUx Code Protection Execute Enable Register Set 0 */


/** \brief E004, CPUx Code Protection Execute Enable Register Set 1 */


/** \brief E008, CPUx Code Protection Execute Enable Register Set 2 */


/** \brief E00C, CPUx Code Protection Execute Enable Register Set 3 */


/** \brief E010, CPUx Data Protection Read Enable Register Set 0 */


/** \brief E014, CPUx Data Protection Read Enable Register Set 1 */


/** \brief E018, CPUx Data Protection Read Enable Register Set 2 */


/** \brief E01C, CPUx Data Protection Read Enable Register Set 3 */


/** \brief E020, CPUx Data Protection Write Enable Register Set 0 */


/** \brief E024, CPUx Data Protection Write Enable Register Set 1 */


/** \brief E028, CPUx Data Protection Write Enable Register Set 2 */


/** \brief E02C, CPUx Data Protection Write Enable Register Set 3 */


/** \brief E040, CPUx Code Protection Execute Enable Register Set 4 */


/** \brief E044, CPUx Code Protection Execute Enable Register Set 5 */


/** \brief E050, CPUx Data Protection Read Enable Register Set 4 */


/** \brief E054, CPUx Data Protection Read Enable Register Set 5 */


/** \brief E060, CPUx Data Protection Write Enable Register Set 4 */


/** \brief E064, CPUx Data Protection Write Enable Register Set 5 */


/** \brief E400, CPUx Temporal Protection System Control Register */


/** \brief E404, CPUx Temporal Protection System Timer Register 0 */


/** \brief E408, CPUx Temporal Protection System Timer Register 1 */


/** \brief E40C, CPUx Temporal Protection System Timer Register 2 */


/** \brief E440, CPUx Exception Entry Timer Load Value */


/** \brief E444, CPUx Exception Entry Timer Current Value */


/** \brief E448, CPUx Exception Exit  Timer Load Value */


/** \brief E44C, CPUx Exception Exit Timer Current Value */


/** \brief E450, CPUx Exception Timer Class Enable Register */


/** \brief E454, CPUx Exception Timer Status Register */


/** \brief E458, CPUx Exception Timer FCX Register */


/** \brief F000, CPUx Trigger Event 0 */

/** Alias (User Manual Name) for CPU1_TR0_EVT.
* To use register names with standard convension, please use CPU1_TR0_EVT.
*/


/** \brief F004, CPUx Trigger Address 0 */

/** Alias (User Manual Name) for CPU1_TR0_ADR.
* To use register names with standard convension, please use CPU1_TR0_ADR.
*/


/** \brief F008, CPUx Trigger Event 1 */

/** Alias (User Manual Name) for CPU1_TR1_EVT.
* To use register names with standard convension, please use CPU1_TR1_EVT.
*/


/** \brief F00C, CPUx Trigger Address 1 */

/** Alias (User Manual Name) for CPU1_TR1_ADR.
* To use register names with standard convension, please use CPU1_TR1_ADR.
*/


/** \brief F010, CPUx Trigger Event 2 */

/** Alias (User Manual Name) for CPU1_TR2_EVT.
* To use register names with standard convension, please use CPU1_TR2_EVT.
*/


/** \brief F014, CPUx Trigger Address 2 */

/** Alias (User Manual Name) for CPU1_TR2_ADR.
* To use register names with standard convension, please use CPU1_TR2_ADR.
*/


/** \brief F018, CPUx Trigger Event 3 */

/** Alias (User Manual Name) for CPU1_TR3_EVT.
* To use register names with standard convension, please use CPU1_TR3_EVT.
*/


/** \brief F01C, CPUx Trigger Address 3 */

/** Alias (User Manual Name) for CPU1_TR3_ADR.
* To use register names with standard convension, please use CPU1_TR3_ADR.
*/


/** \brief F020, CPUx Trigger Event 4 */

/** Alias (User Manual Name) for CPU1_TR4_EVT.
* To use register names with standard convension, please use CPU1_TR4_EVT.
*/


/** \brief F024, CPUx Trigger Address 4 */

/** Alias (User Manual Name) for CPU1_TR4_ADR.
* To use register names with standard convension, please use CPU1_TR4_ADR.
*/


/** \brief F028, CPUx Trigger Event 5 */

/** Alias (User Manual Name) for CPU1_TR5_EVT.
* To use register names with standard convension, please use CPU1_TR5_EVT.
*/


/** \brief F02C, CPUx Trigger Address 5 */

/** Alias (User Manual Name) for CPU1_TR5_ADR.
* To use register names with standard convension, please use CPU1_TR5_ADR.
*/


/** \brief F030, CPUx Trigger Event 6 */

/** Alias (User Manual Name) for CPU1_TR6_EVT.
* To use register names with standard convension, please use CPU1_TR6_EVT.
*/


/** \brief F034, CPUx Trigger Address 6 */

/** Alias (User Manual Name) for CPU1_TR6_ADR.
* To use register names with standard convension, please use CPU1_TR6_ADR.
*/


/** \brief F038, CPUx Trigger Event 7 */

/** Alias (User Manual Name) for CPU1_TR7_EVT.
* To use register names with standard convension, please use CPU1_TR7_EVT.
*/


/** \brief F03C, CPUx Trigger Address 7 */

/** Alias (User Manual Name) for CPU1_TR7_ADR.
* To use register names with standard convension, please use CPU1_TR7_ADR.
*/


/** \brief FC00, CPUx Counter Control */


/** \brief FC04, CPUx CPU Clock Cycle Count */


/** \brief FC08, CPUx Instruction Count */


/** \brief FC0C, CPUx Multi-Count Register 1 */


/** \brief FC10, CPUx Multi-Count Register 2 */


/** \brief FC14, CPUx Multi-Count Register 3 */


/** \brief FD00, CPUx Debug Status Register */


/** \brief FD08, CPUx External Event Register */


/** \brief FD0C, CPUx Core Register Access Event */


/** \brief FD10, CPUx Software Debug Event */


/** \brief FD30, CPUx TriggerAddressx */


/** \brief FD40, CPUx Debug Monitor Start Address */


/** \brief FD44, CPUx Debug Context Save Area Pointer */


/** \brief FD48, CPUx Debug Trap Control Register */


/** \brief FE00, CPUx Previous Context Information Register */


/** \brief FE04, CPUx Program Status Word */


/** \brief FE08, CPUx Program Counter */


/** \brief FE14, CPUx System Configuration Register */


/** \brief FE18, CPUx Identification Register TC1.6.2P */


/** \brief FE1C, CPUx Core Identification Register */


/** \brief FE20, CPUx Base Interrupt Vector Table Pointer */


/** \brief FE24, CPUx Base Trap Vector Table Pointer */


/** \brief FE28, CPUx Interrupt Stack Pointer */


/** \brief FE2C, CPUx Interrupt Control Register */


/** \brief FE38, CPUx Free CSA List Head Pointer */


/** \brief FE3C, CPUx Free CSA List Limit Pointer */


/** \brief FE50, CPUx Customer ID register */


/** \brief FF00, CPUx Data General Purpose Register 0 */


/** \brief FF04, CPUx Data General Purpose Register 1 */


/** \brief FF08, CPUx Data General Purpose Register 2 */


/** \brief FF0C, CPUx Data General Purpose Register 3 */


/** \brief FF10, CPUx Data General Purpose Register 4 */


/** \brief FF14, CPUx Data General Purpose Register 5 */


/** \brief FF18, CPUx Data General Purpose Register 6 */


/** \brief FF1C, CPUx Data General Purpose Register 7 */


/** \brief FF20, CPUx Data General Purpose Register 8 */


/** \brief FF24, CPUx Data General Purpose Register 9 */


/** \brief FF28, CPUx Data General Purpose Register 10 */


/** \brief FF2C, CPUx Data General Purpose Register 11 */


/** \brief FF30, CPUx Data General Purpose Register 12 */


/** \brief FF34, CPUx Data General Purpose Register 13 */


/** \brief FF38, CPUx Data General Purpose Register 14 */


/** \brief FF3C, CPUx Data General Purpose Register 15 */


/** \brief FF80, CPUx Address General Purpose Register 0 */


/** \brief FF84, CPUx Address General Purpose Register 1 */


/** \brief FF88, CPUx Address General Purpose Register 2 */


/** \brief FF8C, CPUx Address General Purpose Register 3 */


/** \brief FF90, CPUx Address General Purpose Register 4 */


/** \brief FF94, CPUx Address General Purpose Register 5 */


/** \brief FF98, CPUx Address General Purpose Register 6 */


/** \brief FF9C, CPUx Address General Purpose Register 7 */


/** \brief FFA0, CPUx Address General Purpose Register 8 */


/** \brief FFA4, CPUx Address General Purpose Register 9 */


/** \brief FFA8, CPUx Address General Purpose Register 10 */


/** \brief FFAC, CPUx Address General Purpose Register 11 */


/** \brief FFB0, CPUx Address General Purpose Register 12 */


/** \brief FFB4, CPUx Address General Purpose Register 13 */


/** \brief FFB8, CPUx Address General Purpose Register 14 */


/** \brief FFBC, CPUx Address General Purpose Register 15 */


/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Cpu_Registers_Cfg_Cpu2
 * \{  */
/** \brief 1100, CPUx Flash Configuration Register 0 */


/** \brief 1104, CPUx Flash Configuration Register 1 */


/** \brief 1108, CPUx Flash Configuration Register 2 */


/** \brief 110C, CPUx Flash Configuration Register 3 */


/** \brief 1110, CPUx Flash Configuration Register 4 */


/** \brief D000, CPUx  Reset Register 0 */


/** \brief D004, CPUx  Reset Register 1 */


/** \brief D008, CPUx Reset Clear Register */


/** \brief E000, CPUx Safety Protection SPR Region Lower Address Register 0 */

/** Alias (User Manual Name) for CPU2_RGN0_LA.
* To use register names with standard convension, please use CPU2_RGN0_LA.
*/


/** \brief E004, CPUx Safety Protection SPR Region Upper Address Register 0 */

/** Alias (User Manual Name) for CPU2_RGN0_UA.
* To use register names with standard convension, please use CPU2_RGN0_UA.
*/


/** \brief E008, CPUx Safety Protection SPR Region Write Access Enable Register A0 */

/** Alias (User Manual Name) for CPU2_RGN0_ACCENA.
* To use register names with standard convension, please use CPU2_RGN0_ACCENA.
*/


/** \brief E00C, CPUx Safety Protection SPR Region Write Access Enable Register B0 */

/** Alias (User Manual Name) for CPU2_RGN0_ACCENB.
* To use register names with standard convension, please use CPU2_RGN0_ACCENB.
*/


/** \brief E010, CPUx Safety Protection SPR Region Lower Address Register 1 */

/** Alias (User Manual Name) for CPU2_RGN1_LA.
* To use register names with standard convension, please use CPU2_RGN1_LA.
*/


/** \brief E014, CPUx Safety Protection SPR Region Upper Address Register 1 */

/** Alias (User Manual Name) for CPU2_RGN1_UA.
* To use register names with standard convension, please use CPU2_RGN1_UA.
*/


/** \brief E018, CPUx Safety Protection SPR Region Write Access Enable Register A1 */

/** Alias (User Manual Name) for CPU2_RGN1_ACCENA.
* To use register names with standard convension, please use CPU2_RGN1_ACCENA.
*/


/** \brief E01C, CPUx Safety Protection SPR Region Write Access Enable Register B1 */

/** Alias (User Manual Name) for CPU2_RGN1_ACCENB.
* To use register names with standard convension, please use CPU2_RGN1_ACCENB.
*/


/** \brief E020, CPUx Safety Protection SPR Region Lower Address Register 2 */

/** Alias (User Manual Name) for CPU2_RGN2_LA.
* To use register names with standard convension, please use CPU2_RGN2_LA.
*/


/** \brief E024, CPUx Safety Protection SPR Region Upper Address Register 2 */

/** Alias (User Manual Name) for CPU2_RGN2_UA.
* To use register names with standard convension, please use CPU2_RGN2_UA.
*/


/** \brief E028, CPUx Safety Protection SPR Region Write Access Enable Register A2 */

/** Alias (User Manual Name) for CPU2_RGN2_ACCENA.
* To use register names with standard convension, please use CPU2_RGN2_ACCENA.
*/


/** \brief E02C, CPUx Safety Protection SPR Region Write Access Enable Register B2 */

/** Alias (User Manual Name) for CPU2_RGN2_ACCENB.
* To use register names with standard convension, please use CPU2_RGN2_ACCENB.
*/


/** \brief E030, CPUx Safety Protection SPR Region Lower Address Register 3 */

/** Alias (User Manual Name) for CPU2_RGN3_LA.
* To use register names with standard convension, please use CPU2_RGN3_LA.
*/


/** \brief E034, CPUx Safety Protection SPR Region Upper Address Register 3 */

/** Alias (User Manual Name) for CPU2_RGN3_UA.
* To use register names with standard convension, please use CPU2_RGN3_UA.
*/


/** \brief E038, CPUx Safety Protection SPR Region Write Access Enable Register A3 */

/** Alias (User Manual Name) for CPU2_RGN3_ACCENA.
* To use register names with standard convension, please use CPU2_RGN3_ACCENA.
*/


/** \brief E03C, CPUx Safety Protection SPR Region Write Access Enable Register B3 */

/** Alias (User Manual Name) for CPU2_RGN3_ACCENB.
* To use register names with standard convension, please use CPU2_RGN3_ACCENB.
*/


/** \brief E040, CPUx Safety Protection SPR Region Lower Address Register 4 */

/** Alias (User Manual Name) for CPU2_RGN4_LA.
* To use register names with standard convension, please use CPU2_RGN4_LA.
*/


/** \brief E044, CPUx Safety Protection SPR Region Upper Address Register 4 */

/** Alias (User Manual Name) for CPU2_RGN4_UA.
* To use register names with standard convension, please use CPU2_RGN4_UA.
*/


/** \brief E048, CPUx Safety Protection SPR Region Write Access Enable Register A4 */

/** Alias (User Manual Name) for CPU2_RGN4_ACCENA.
* To use register names with standard convension, please use CPU2_RGN4_ACCENA.
*/


/** \brief E04C, CPUx Safety Protection SPR Region Write Access Enable Register B4 */

/** Alias (User Manual Name) for CPU2_RGN4_ACCENB.
* To use register names with standard convension, please use CPU2_RGN4_ACCENB.
*/


/** \brief E050, CPUx Safety Protection SPR Region Lower Address Register 5 */

/** Alias (User Manual Name) for CPU2_RGN5_LA.
* To use register names with standard convension, please use CPU2_RGN5_LA.
*/


/** \brief E054, CPUx Safety Protection SPR Region Upper Address Register 5 */

/** Alias (User Manual Name) for CPU2_RGN5_UA.
* To use register names with standard convension, please use CPU2_RGN5_UA.
*/


/** \brief E058, CPUx Safety Protection SPR Region Write Access Enable Register A5 */

/** Alias (User Manual Name) for CPU2_RGN5_ACCENA.
* To use register names with standard convension, please use CPU2_RGN5_ACCENA.
*/


/** \brief E05C, CPUx Safety Protection SPR Region Write Access Enable Register B5 */

/** Alias (User Manual Name) for CPU2_RGN5_ACCENB.
* To use register names with standard convension, please use CPU2_RGN5_ACCENB.
*/


/** \brief E060, CPUx Safety Protection SPR Region Lower Address Register 6 */

/** Alias (User Manual Name) for CPU2_RGN6_LA.
* To use register names with standard convension, please use CPU2_RGN6_LA.
*/


/** \brief E064, CPUx Safety Protection SPR Region Upper Address Register 6 */

/** Alias (User Manual Name) for CPU2_RGN6_UA.
* To use register names with standard convension, please use CPU2_RGN6_UA.
*/


/** \brief E068, CPUx Safety Protection SPR Region Write Access Enable Register A6 */

/** Alias (User Manual Name) for CPU2_RGN6_ACCENA.
* To use register names with standard convension, please use CPU2_RGN6_ACCENA.
*/


/** \brief E06C, CPUx Safety Protection SPR Region Write Access Enable Register B6 */

/** Alias (User Manual Name) for CPU2_RGN6_ACCENB.
* To use register names with standard convension, please use CPU2_RGN6_ACCENB.
*/


/** \brief E070, CPUx Safety Protection SPR Region Lower Address Register 7 */

/** Alias (User Manual Name) for CPU2_RGN7_LA.
* To use register names with standard convension, please use CPU2_RGN7_LA.
*/


/** \brief E074, CPUx Safety Protection SPR Region Upper Address Register 7 */

/** Alias (User Manual Name) for CPU2_RGN7_UA.
* To use register names with standard convension, please use CPU2_RGN7_UA.
*/


/** \brief E078, CPUx Safety Protection SPR Region Write Access Enable Register A7 */

/** Alias (User Manual Name) for CPU2_RGN7_ACCENA.
* To use register names with standard convension, please use CPU2_RGN7_ACCENA.
*/


/** \brief E07C, CPUx Safety Protection SPR Region Write Access Enable Register B7 */

/** Alias (User Manual Name) for CPU2_RGN7_ACCENB.
* To use register names with standard convension, please use CPU2_RGN7_ACCENB.
*/


/** \brief E088, CPUx Safety Protection SPR Region Read Access Enable Register A0 */

/** Alias (User Manual Name) for CPU2_SPR_SPROT_RGNACCENA_R0.
* To use register names with standard convension, please use CPU2_SPR_SPROT_RGNACCENA_R0.
*/


/** \brief E08C, CPUx Safety Protection SPR Region Read Access Enable Register B0 */

/** Alias (User Manual Name) for CPU2_SPR_SPROT_RGNACCENB_R0.
* To use register names with standard convension, please use CPU2_SPR_SPROT_RGNACCENB_R0.
*/


/** \brief E098, CPUx Safety Protection SPR Region Read Access Enable Register A1 */

/** Alias (User Manual Name) for CPU2_SPR_SPROT_RGNACCENA_R1.
* To use register names with standard convension, please use CPU2_SPR_SPROT_RGNACCENA_R1.
*/


/** \brief E09C, CPUx Safety Protection SPR Region Read Access Enable Register B1 */

/** Alias (User Manual Name) for CPU2_SPR_SPROT_RGNACCENB_R1.
* To use register names with standard convension, please use CPU2_SPR_SPROT_RGNACCENB_R1.
*/


/** \brief E0A8, CPUx Safety Protection SPR Region Read Access Enable Register A2 */

/** Alias (User Manual Name) for CPU2_SPR_SPROT_RGNACCENA_R2.
* To use register names with standard convension, please use CPU2_SPR_SPROT_RGNACCENA_R2.
*/


/** \brief E0AC, CPUx Safety Protection SPR Region Read Access Enable Register B2 */

/** Alias (User Manual Name) for CPU2_SPR_SPROT_RGNACCENB_R2.
* To use register names with standard convension, please use CPU2_SPR_SPROT_RGNACCENB_R2.
*/


/** \brief E0B8, CPUx Safety Protection SPR Region Read Access Enable Register A3 */

/** Alias (User Manual Name) for CPU2_SPR_SPROT_RGNACCENA_R3.
* To use register names with standard convension, please use CPU2_SPR_SPROT_RGNACCENA_R3.
*/


/** \brief E0BC, CPUx Safety Protection SPR Region Read Access Enable Register B3 */

/** Alias (User Manual Name) for CPU2_SPR_SPROT_RGNACCENB_R3.
* To use register names with standard convension, please use CPU2_SPR_SPROT_RGNACCENB_R3.
*/


/** \brief E0C8, CPUx Safety Protection SPR Region Read Access Enable Register A4 */

/** Alias (User Manual Name) for CPU2_SPR_SPROT_RGNACCENA_R4.
* To use register names with standard convension, please use CPU2_SPR_SPROT_RGNACCENA_R4.
*/


/** \brief E0CC, CPUx Safety Protection SPR Region Read Access Enable Register B4 */

/** Alias (User Manual Name) for CPU2_SPR_SPROT_RGNACCENB_R4.
* To use register names with standard convension, please use CPU2_SPR_SPROT_RGNACCENB_R4.
*/


/** \brief E0D8, CPUx Safety Protection SPR Region Read Access Enable Register A5 */

/** Alias (User Manual Name) for CPU2_SPR_SPROT_RGNACCENA_R5.
* To use register names with standard convension, please use CPU2_SPR_SPROT_RGNACCENA_R5.
*/


/** \brief E0DC, CPUx Safety Protection SPR Region Read Access Enable Register B5 */

/** Alias (User Manual Name) for CPU2_SPR_SPROT_RGNACCENB_R5.
* To use register names with standard convension, please use CPU2_SPR_SPROT_RGNACCENB_R5.
*/


/** \brief E0E8, CPUx Safety Protection SPR Region Read Access Enable Register A6 */

/** Alias (User Manual Name) for CPU2_SPR_SPROT_RGNACCENA_R6.
* To use register names with standard convension, please use CPU2_SPR_SPROT_RGNACCENA_R6.
*/


/** \brief E0EC, CPUx Safety Protection SPR Region Read Access Enable Register B6 */

/** Alias (User Manual Name) for CPU2_SPR_SPROT_RGNACCENB_R6.
* To use register names with standard convension, please use CPU2_SPR_SPROT_RGNACCENB_R6.
*/


/** \brief E0F8, CPUx Safety Protection SPR Region Read Access Enable Register A7 */

/** Alias (User Manual Name) for CPU2_SPR_SPROT_RGNACCENA_R7.
* To use register names with standard convension, please use CPU2_SPR_SPROT_RGNACCENA_R7.
*/


/** \brief E0FC, CPUx Safety Protection SPR Region Read Access Enable Register B7 */

/** Alias (User Manual Name) for CPU2_SPR_SPROT_RGNACCENB_R7.
* To use register names with standard convension, please use CPU2_SPR_SPROT_RGNACCENB_R7.
*/


/** \brief E100, CPUx Safety Protection Register Access Enable Register A */


/** \brief E104, CPUx Safety Protection Region Access Enable Register B */


/** \brief E110, CPUx Safety Protection Region LPB Read Access Enable Register A */


/** \brief E114, CPUx Safety Protection Region LPB Read Access Enable Register B */


/** \brief E200, CPUx Safety Protection DLMU Region Lower Address Register 0 */


/** \brief E204, CPUx Safety protection DLMU Region Upper Address Register 0 */


/** \brief E208, CPUx Safety Protection Region DLMU Write Access Enable Register A0 */

/** Alias (User Manual Name) for CPU2_DLMU_SPROT_RGNACCENA_W0.
* To use register names with standard convension, please use CPU2_DLMU_SPROT_RGNACCENA_W0.
*/


/** \brief E20C, CPUx Safety Protection Region DLMU Write Access Enable Register B0 */

/** Alias (User Manual Name) for CPU2_DLMU_SPROT_RGNACCENB_W0.
* To use register names with standard convension, please use CPU2_DLMU_SPROT_RGNACCENB_W0.
*/


/** \brief E210, CPUx Safety Protection DLMU Region Lower Address Register 1 */


/** \brief E214, CPUx Safety protection DLMU Region Upper Address Register 1 */


/** \brief E218, CPUx Safety Protection Region DLMU Write Access Enable Register A1 */

/** Alias (User Manual Name) for CPU2_DLMU_SPROT_RGNACCENA_W1.
* To use register names with standard convension, please use CPU2_DLMU_SPROT_RGNACCENA_W1.
*/


/** \brief E21C, CPUx Safety Protection Region DLMU Write Access Enable Register B1 */

/** Alias (User Manual Name) for CPU2_DLMU_SPROT_RGNACCENB_W1.
* To use register names with standard convension, please use CPU2_DLMU_SPROT_RGNACCENB_W1.
*/


/** \brief E220, CPUx Safety Protection DLMU Region Lower Address Register 2 */


/** \brief E224, CPUx Safety protection DLMU Region Upper Address Register 2 */


/** \brief E228, CPUx Safety Protection Region DLMU Write Access Enable Register A2 */

/** Alias (User Manual Name) for CPU2_DLMU_SPROT_RGNACCENA_W2.
* To use register names with standard convension, please use CPU2_DLMU_SPROT_RGNACCENA_W2.
*/


/** \brief E22C, CPUx Safety Protection Region DLMU Write Access Enable Register B2 */

/** Alias (User Manual Name) for CPU2_DLMU_SPROT_RGNACCENB_W2.
* To use register names with standard convension, please use CPU2_DLMU_SPROT_RGNACCENB_W2.
*/


/** \brief E230, CPUx Safety Protection DLMU Region Lower Address Register 3 */


/** \brief E234, CPUx Safety protection DLMU Region Upper Address Register 3 */


/** \brief E238, CPUx Safety Protection Region DLMU Write Access Enable Register A3 */

/** Alias (User Manual Name) for CPU2_DLMU_SPROT_RGNACCENA_W3.
* To use register names with standard convension, please use CPU2_DLMU_SPROT_RGNACCENA_W3.
*/


/** \brief E23C, CPUx Safety Protection Region DLMU Write Access Enable Register B3 */

/** Alias (User Manual Name) for CPU2_DLMU_SPROT_RGNACCENB_W3.
* To use register names with standard convension, please use CPU2_DLMU_SPROT_RGNACCENB_W3.
*/


/** \brief E240, CPUx Safety Protection DLMU Region Lower Address Register 4 */


/** \brief E244, CPUx Safety protection DLMU Region Upper Address Register 4 */


/** \brief E248, CPUx Safety Protection Region DLMU Write Access Enable Register A4 */

/** Alias (User Manual Name) for CPU2_DLMU_SPROT_RGNACCENA_W4.
* To use register names with standard convension, please use CPU2_DLMU_SPROT_RGNACCENA_W4.
*/


/** \brief E24C, CPUx Safety Protection Region DLMU Write Access Enable Register B4 */

/** Alias (User Manual Name) for CPU2_DLMU_SPROT_RGNACCENB_W4.
* To use register names with standard convension, please use CPU2_DLMU_SPROT_RGNACCENB_W4.
*/


/** \brief E250, CPUx Safety Protection DLMU Region Lower Address Register 5 */


/** \brief E254, CPUx Safety protection DLMU Region Upper Address Register 5 */


/** \brief E258, CPUx Safety Protection Region DLMU Write Access Enable Register A5 */

/** Alias (User Manual Name) for CPU2_DLMU_SPROT_RGNACCENA_W5.
* To use register names with standard convension, please use CPU2_DLMU_SPROT_RGNACCENA_W5.
*/


/** \brief E25C, CPUx Safety Protection Region DLMU Write Access Enable Register B5 */

/** Alias (User Manual Name) for CPU2_DLMU_SPROT_RGNACCENB_W5.
* To use register names with standard convension, please use CPU2_DLMU_SPROT_RGNACCENB_W5.
*/


/** \brief E260, CPUx Safety Protection DLMU Region Lower Address Register 6 */


/** \brief E264, CPUx Safety protection DLMU Region Upper Address Register 6 */


/** \brief E268, CPUx Safety Protection Region DLMU Write Access Enable Register A6 */

/** Alias (User Manual Name) for CPU2_DLMU_SPROT_RGNACCENA_W6.
* To use register names with standard convension, please use CPU2_DLMU_SPROT_RGNACCENA_W6.
*/


/** \brief E26C, CPUx Safety Protection Region DLMU Write Access Enable Register B6 */

/** Alias (User Manual Name) for CPU2_DLMU_SPROT_RGNACCENB_W6.
* To use register names with standard convension, please use CPU2_DLMU_SPROT_RGNACCENB_W6.
*/


/** \brief E270, CPUx Safety Protection DLMU Region Lower Address Register 7 */


/** \brief E274, CPUx Safety protection DLMU Region Upper Address Register 7 */


/** \brief E278, CPUx Safety Protection Region DLMU Write Access Enable Register A7 */

/** Alias (User Manual Name) for CPU2_DLMU_SPROT_RGNACCENA_W7.
* To use register names with standard convension, please use CPU2_DLMU_SPROT_RGNACCENA_W7.
*/


/** \brief E27C, CPUx Safety Protection Region DLMU Write Access Enable Register B7 */

/** Alias (User Manual Name) for CPU2_DLMU_SPROT_RGNACCENB_W7.
* To use register names with standard convension, please use CPU2_DLMU_SPROT_RGNACCENB_W7.
*/


/** \brief E288, CPUx Safety Protection Region DLMU Read Access Enable Register A0 */

/** Alias (User Manual Name) for CPU2_DLMU_SPROT_RGNACCENA_R0.
* To use register names with standard convension, please use CPU2_DLMU_SPROT_RGNACCENA_R0.
*/


/** \brief E28C, CPUx Safety Protection Region DLMU Read Access Enable Register B0 */

/** Alias (User Manual Name) for CPU2_DLMU_SPROT_RGNACCENB_R0.
* To use register names with standard convension, please use CPU2_DLMU_SPROT_RGNACCENB_R0.
*/


/** \brief E298, CPUx Safety Protection Region DLMU Read Access Enable Register A1 */

/** Alias (User Manual Name) for CPU2_DLMU_SPROT_RGNACCENA_R1.
* To use register names with standard convension, please use CPU2_DLMU_SPROT_RGNACCENA_R1.
*/


/** \brief E29C, CPUx Safety Protection Region DLMU Read Access Enable Register B1 */

/** Alias (User Manual Name) for CPU2_DLMU_SPROT_RGNACCENB_R1.
* To use register names with standard convension, please use CPU2_DLMU_SPROT_RGNACCENB_R1.
*/


/** \brief E2A8, CPUx Safety Protection Region DLMU Read Access Enable Register A2 */

/** Alias (User Manual Name) for CPU2_DLMU_SPROT_RGNACCENA_R2.
* To use register names with standard convension, please use CPU2_DLMU_SPROT_RGNACCENA_R2.
*/


/** \brief E2AC, CPUx Safety Protection Region DLMU Read Access Enable Register B2 */

/** Alias (User Manual Name) for CPU2_DLMU_SPROT_RGNACCENB_R2.
* To use register names with standard convension, please use CPU2_DLMU_SPROT_RGNACCENB_R2.
*/


/** \brief E2B8, CPUx Safety Protection Region DLMU Read Access Enable Register A3 */

/** Alias (User Manual Name) for CPU2_DLMU_SPROT_RGNACCENA_R3.
* To use register names with standard convension, please use CPU2_DLMU_SPROT_RGNACCENA_R3.
*/


/** \brief E2BC, CPUx Safety Protection Region DLMU Read Access Enable Register B3 */

/** Alias (User Manual Name) for CPU2_DLMU_SPROT_RGNACCENB_R3.
* To use register names with standard convension, please use CPU2_DLMU_SPROT_RGNACCENB_R3.
*/


/** \brief E2C8, CPUx Safety Protection Region DLMU Read Access Enable Register A4 */

/** Alias (User Manual Name) for CPU2_DLMU_SPROT_RGNACCENA_R4.
* To use register names with standard convension, please use CPU2_DLMU_SPROT_RGNACCENA_R4.
*/


/** \brief E2CC, CPUx Safety Protection Region DLMU Read Access Enable Register B4 */

/** Alias (User Manual Name) for CPU2_DLMU_SPROT_RGNACCENB_R4.
* To use register names with standard convension, please use CPU2_DLMU_SPROT_RGNACCENB_R4.
*/


/** \brief E2D8, CPUx Safety Protection Region DLMU Read Access Enable Register A5 */

/** Alias (User Manual Name) for CPU2_DLMU_SPROT_RGNACCENA_R5.
* To use register names with standard convension, please use CPU2_DLMU_SPROT_RGNACCENA_R5.
*/


/** \brief E2DC, CPUx Safety Protection Region DLMU Read Access Enable Register B5 */

/** Alias (User Manual Name) for CPU2_DLMU_SPROT_RGNACCENB_R5.
* To use register names with standard convension, please use CPU2_DLMU_SPROT_RGNACCENB_R5.
*/


/** \brief E2E8, CPUx Safety Protection Region DLMU Read Access Enable Register A6 */

/** Alias (User Manual Name) for CPU2_DLMU_SPROT_RGNACCENA_R6.
* To use register names with standard convension, please use CPU2_DLMU_SPROT_RGNACCENA_R6.
*/


/** \brief E2EC, CPUx Safety Protection Region DLMU Read Access Enable Register B6 */

/** Alias (User Manual Name) for CPU2_DLMU_SPROT_RGNACCENB_R6.
* To use register names with standard convension, please use CPU2_DLMU_SPROT_RGNACCENB_R6.
*/


/** \brief E2F8, CPUx Safety Protection Region DLMU Read Access Enable Register A7 */

/** Alias (User Manual Name) for CPU2_DLMU_SPROT_RGNACCENA_R7.
* To use register names with standard convension, please use CPU2_DLMU_SPROT_RGNACCENA_R7.
*/


/** \brief E2FC, CPUx Safety Protection Region DLMU Read Access Enable Register B7 */

/** Alias (User Manual Name) for CPU2_DLMU_SPROT_RGNACCENB_R7.
* To use register names with standard convension, please use CPU2_DLMU_SPROT_RGNACCENB_R7.
*/


/** \brief FB00, CPUx  Overlay Range Select Register */


/** \brief FB10, CPUx Redirected Address Base Register 0 */

/** Alias (User Manual Name) for CPU2_BLK0_RABR.
* To use register names with standard convension, please use CPU2_BLK0_RABR.
*/


/** \brief FB14, CPUx Overlay Target Address Register 0 */

/** Alias (User Manual Name) for CPU2_BLK0_OTAR.
* To use register names with standard convension, please use CPU2_BLK0_OTAR.
*/


/** \brief FB18, CPUx Overlay Mask Register 0 */

/** Alias (User Manual Name) for CPU2_BLK0_OMASK.
* To use register names with standard convension, please use CPU2_BLK0_OMASK.
*/


/** \brief FB1C, CPUx Redirected Address Base Register 1 */

/** Alias (User Manual Name) for CPU2_BLK1_RABR.
* To use register names with standard convension, please use CPU2_BLK1_RABR.
*/


/** \brief FB20, CPUx Overlay Target Address Register 1 */

/** Alias (User Manual Name) for CPU2_BLK1_OTAR.
* To use register names with standard convension, please use CPU2_BLK1_OTAR.
*/


/** \brief FB24, CPUx Overlay Mask Register 1 */

/** Alias (User Manual Name) for CPU2_BLK1_OMASK.
* To use register names with standard convension, please use CPU2_BLK1_OMASK.
*/


/** \brief FB28, CPUx Redirected Address Base Register 2 */

/** Alias (User Manual Name) for CPU2_BLK2_RABR.
* To use register names with standard convension, please use CPU2_BLK2_RABR.
*/


/** \brief FB2C, CPUx Overlay Target Address Register 2 */

/** Alias (User Manual Name) for CPU2_BLK2_OTAR.
* To use register names with standard convension, please use CPU2_BLK2_OTAR.
*/


/** \brief FB30, CPUx Overlay Mask Register 2 */

/** Alias (User Manual Name) for CPU2_BLK2_OMASK.
* To use register names with standard convension, please use CPU2_BLK2_OMASK.
*/


/** \brief FB34, CPUx Redirected Address Base Register 3 */

/** Alias (User Manual Name) for CPU2_BLK3_RABR.
* To use register names with standard convension, please use CPU2_BLK3_RABR.
*/


/** \brief FB38, CPUx Overlay Target Address Register 3 */

/** Alias (User Manual Name) for CPU2_BLK3_OTAR.
* To use register names with standard convension, please use CPU2_BLK3_OTAR.
*/


/** \brief FB3C, CPUx Overlay Mask Register 3 */

/** Alias (User Manual Name) for CPU2_BLK3_OMASK.
* To use register names with standard convension, please use CPU2_BLK3_OMASK.
*/


/** \brief FB40, CPUx Redirected Address Base Register 4 */

/** Alias (User Manual Name) for CPU2_BLK4_RABR.
* To use register names with standard convension, please use CPU2_BLK4_RABR.
*/


/** \brief FB44, CPUx Overlay Target Address Register 4 */

/** Alias (User Manual Name) for CPU2_BLK4_OTAR.
* To use register names with standard convension, please use CPU2_BLK4_OTAR.
*/


/** \brief FB48, CPUx Overlay Mask Register 4 */

/** Alias (User Manual Name) for CPU2_BLK4_OMASK.
* To use register names with standard convension, please use CPU2_BLK4_OMASK.
*/


/** \brief FB4C, CPUx Redirected Address Base Register 5 */

/** Alias (User Manual Name) for CPU2_BLK5_RABR.
* To use register names with standard convension, please use CPU2_BLK5_RABR.
*/


/** \brief FB50, CPUx Overlay Target Address Register 5 */

/** Alias (User Manual Name) for CPU2_BLK5_OTAR.
* To use register names with standard convension, please use CPU2_BLK5_OTAR.
*/


/** \brief FB54, CPUx Overlay Mask Register 5 */

/** Alias (User Manual Name) for CPU2_BLK5_OMASK.
* To use register names with standard convension, please use CPU2_BLK5_OMASK.
*/


/** \brief FB58, CPUx Redirected Address Base Register 6 */

/** Alias (User Manual Name) for CPU2_BLK6_RABR.
* To use register names with standard convension, please use CPU2_BLK6_RABR.
*/


/** \brief FB5C, CPUx Overlay Target Address Register 6 */

/** Alias (User Manual Name) for CPU2_BLK6_OTAR.
* To use register names with standard convension, please use CPU2_BLK6_OTAR.
*/


/** \brief FB60, CPUx Overlay Mask Register 6 */

/** Alias (User Manual Name) for CPU2_BLK6_OMASK.
* To use register names with standard convension, please use CPU2_BLK6_OMASK.
*/


/** \brief FB64, CPUx Redirected Address Base Register 7 */

/** Alias (User Manual Name) for CPU2_BLK7_RABR.
* To use register names with standard convension, please use CPU2_BLK7_RABR.
*/


/** \brief FB68, CPUx Overlay Target Address Register 7 */

/** Alias (User Manual Name) for CPU2_BLK7_OTAR.
* To use register names with standard convension, please use CPU2_BLK7_OTAR.
*/


/** \brief FB6C, CPUx Overlay Mask Register 7 */

/** Alias (User Manual Name) for CPU2_BLK7_OMASK.
* To use register names with standard convension, please use CPU2_BLK7_OMASK.
*/


/** \brief FB70, CPUx Redirected Address Base Register 8 */

/** Alias (User Manual Name) for CPU2_BLK8_RABR.
* To use register names with standard convension, please use CPU2_BLK8_RABR.
*/


/** \brief FB74, CPUx Overlay Target Address Register 8 */

/** Alias (User Manual Name) for CPU2_BLK8_OTAR.
* To use register names with standard convension, please use CPU2_BLK8_OTAR.
*/


/** \brief FB78, CPUx Overlay Mask Register 8 */

/** Alias (User Manual Name) for CPU2_BLK8_OMASK.
* To use register names with standard convension, please use CPU2_BLK8_OMASK.
*/


/** \brief FB7C, CPUx Redirected Address Base Register 9 */

/** Alias (User Manual Name) for CPU2_BLK9_RABR.
* To use register names with standard convension, please use CPU2_BLK9_RABR.
*/


/** \brief FB80, CPUx Overlay Target Address Register 9 */

/** Alias (User Manual Name) for CPU2_BLK9_OTAR.
* To use register names with standard convension, please use CPU2_BLK9_OTAR.
*/


/** \brief FB84, CPUx Overlay Mask Register 9 */

/** Alias (User Manual Name) for CPU2_BLK9_OMASK.
* To use register names with standard convension, please use CPU2_BLK9_OMASK.
*/


/** \brief FB88, CPUx Redirected Address Base Register 10 */

/** Alias (User Manual Name) for CPU2_BLK10_RABR.
* To use register names with standard convension, please use CPU2_BLK10_RABR.
*/


/** \brief FB8C, CPUx Overlay Target Address Register 10 */

/** Alias (User Manual Name) for CPU2_BLK10_OTAR.
* To use register names with standard convension, please use CPU2_BLK10_OTAR.
*/


/** \brief FB90, CPUx Overlay Mask Register 10 */

/** Alias (User Manual Name) for CPU2_BLK10_OMASK.
* To use register names with standard convension, please use CPU2_BLK10_OMASK.
*/


/** \brief FB94, CPUx Redirected Address Base Register 11 */

/** Alias (User Manual Name) for CPU2_BLK11_RABR.
* To use register names with standard convension, please use CPU2_BLK11_RABR.
*/


/** \brief FB98, CPUx Overlay Target Address Register 11 */

/** Alias (User Manual Name) for CPU2_BLK11_OTAR.
* To use register names with standard convension, please use CPU2_BLK11_OTAR.
*/


/** \brief FB9C, CPUx Overlay Mask Register 11 */

/** Alias (User Manual Name) for CPU2_BLK11_OMASK.
* To use register names with standard convension, please use CPU2_BLK11_OMASK.
*/


/** \brief FBA0, CPUx Redirected Address Base Register 12 */

/** Alias (User Manual Name) for CPU2_BLK12_RABR.
* To use register names with standard convension, please use CPU2_BLK12_RABR.
*/


/** \brief FBA4, CPUx Overlay Target Address Register 12 */

/** Alias (User Manual Name) for CPU2_BLK12_OTAR.
* To use register names with standard convension, please use CPU2_BLK12_OTAR.
*/


/** \brief FBA8, CPUx Overlay Mask Register 12 */

/** Alias (User Manual Name) for CPU2_BLK12_OMASK.
* To use register names with standard convension, please use CPU2_BLK12_OMASK.
*/


/** \brief FBAC, CPUx Redirected Address Base Register 13 */

/** Alias (User Manual Name) for CPU2_BLK13_RABR.
* To use register names with standard convension, please use CPU2_BLK13_RABR.
*/


/** \brief FBB0, CPUx Overlay Target Address Register 13 */

/** Alias (User Manual Name) for CPU2_BLK13_OTAR.
* To use register names with standard convension, please use CPU2_BLK13_OTAR.
*/


/** \brief FBB4, CPUx Overlay Mask Register 13 */

/** Alias (User Manual Name) for CPU2_BLK13_OMASK.
* To use register names with standard convension, please use CPU2_BLK13_OMASK.
*/


/** \brief FBB8, CPUx Redirected Address Base Register 14 */

/** Alias (User Manual Name) for CPU2_BLK14_RABR.
* To use register names with standard convension, please use CPU2_BLK14_RABR.
*/


/** \brief FBBC, CPUx Overlay Target Address Register 14 */

/** Alias (User Manual Name) for CPU2_BLK14_OTAR.
* To use register names with standard convension, please use CPU2_BLK14_OTAR.
*/


/** \brief FBC0, CPUx Overlay Mask Register 14 */

/** Alias (User Manual Name) for CPU2_BLK14_OMASK.
* To use register names with standard convension, please use CPU2_BLK14_OMASK.
*/


/** \brief FBC4, CPUx Redirected Address Base Register 15 */

/** Alias (User Manual Name) for CPU2_BLK15_RABR.
* To use register names with standard convension, please use CPU2_BLK15_RABR.
*/


/** \brief FBC8, CPUx Overlay Target Address Register 15 */

/** Alias (User Manual Name) for CPU2_BLK15_OTAR.
* To use register names with standard convension, please use CPU2_BLK15_OTAR.
*/


/** \brief FBCC, CPUx Overlay Mask Register 15 */

/** Alias (User Manual Name) for CPU2_BLK15_OMASK.
* To use register names with standard convension, please use CPU2_BLK15_OMASK.
*/


/** \brief FBD0, CPUx Redirected Address Base Register 16 */

/** Alias (User Manual Name) for CPU2_BLK16_RABR.
* To use register names with standard convension, please use CPU2_BLK16_RABR.
*/


/** \brief FBD4, CPUx Overlay Target Address Register 16 */

/** Alias (User Manual Name) for CPU2_BLK16_OTAR.
* To use register names with standard convension, please use CPU2_BLK16_OTAR.
*/


/** \brief FBD8, CPUx Overlay Mask Register 16 */

/** Alias (User Manual Name) for CPU2_BLK16_OMASK.
* To use register names with standard convension, please use CPU2_BLK16_OMASK.
*/


/** \brief FBDC, CPUx Redirected Address Base Register 17 */

/** Alias (User Manual Name) for CPU2_BLK17_RABR.
* To use register names with standard convension, please use CPU2_BLK17_RABR.
*/


/** \brief FBE0, CPUx Overlay Target Address Register 17 */

/** Alias (User Manual Name) for CPU2_BLK17_OTAR.
* To use register names with standard convension, please use CPU2_BLK17_OTAR.
*/


/** \brief FBE4, CPUx Overlay Mask Register 17 */

/** Alias (User Manual Name) for CPU2_BLK17_OMASK.
* To use register names with standard convension, please use CPU2_BLK17_OMASK.
*/


/** \brief FBE8, CPUx Redirected Address Base Register 18 */

/** Alias (User Manual Name) for CPU2_BLK18_RABR.
* To use register names with standard convension, please use CPU2_BLK18_RABR.
*/


/** \brief FBEC, CPUx Overlay Target Address Register 18 */

/** Alias (User Manual Name) for CPU2_BLK18_OTAR.
* To use register names with standard convension, please use CPU2_BLK18_OTAR.
*/


/** \brief FBF0, CPUx Overlay Mask Register 18 */

/** Alias (User Manual Name) for CPU2_BLK18_OMASK.
* To use register names with standard convension, please use CPU2_BLK18_OMASK.
*/


/** \brief FBF4, CPUx Redirected Address Base Register 19 */

/** Alias (User Manual Name) for CPU2_BLK19_RABR.
* To use register names with standard convension, please use CPU2_BLK19_RABR.
*/


/** \brief FBF8, CPUx Overlay Target Address Register 19 */

/** Alias (User Manual Name) for CPU2_BLK19_OTAR.
* To use register names with standard convension, please use CPU2_BLK19_OTAR.
*/


/** \brief FBFC, CPUx Overlay Mask Register 19 */

/** Alias (User Manual Name) for CPU2_BLK19_OMASK.
* To use register names with standard convension, please use CPU2_BLK19_OMASK.
*/


/** \brief FC00, CPUx Redirected Address Base Register 20 */

/** Alias (User Manual Name) for CPU2_BLK20_RABR.
* To use register names with standard convension, please use CPU2_BLK20_RABR.
*/


/** \brief FC04, CPUx Overlay Target Address Register 20 */

/** Alias (User Manual Name) for CPU2_BLK20_OTAR.
* To use register names with standard convension, please use CPU2_BLK20_OTAR.
*/


/** \brief FC08, CPUx Overlay Mask Register 20 */

/** Alias (User Manual Name) for CPU2_BLK20_OMASK.
* To use register names with standard convension, please use CPU2_BLK20_OMASK.
*/


/** \brief FC0C, CPUx Redirected Address Base Register 21 */

/** Alias (User Manual Name) for CPU2_BLK21_RABR.
* To use register names with standard convension, please use CPU2_BLK21_RABR.
*/


/** \brief FC10, CPUx Overlay Target Address Register 21 */

/** Alias (User Manual Name) for CPU2_BLK21_OTAR.
* To use register names with standard convension, please use CPU2_BLK21_OTAR.
*/


/** \brief FC14, CPUx Overlay Mask Register 21 */

/** Alias (User Manual Name) for CPU2_BLK21_OMASK.
* To use register names with standard convension, please use CPU2_BLK21_OMASK.
*/


/** \brief FC18, CPUx Redirected Address Base Register 22 */

/** Alias (User Manual Name) for CPU2_BLK22_RABR.
* To use register names with standard convension, please use CPU2_BLK22_RABR.
*/


/** \brief FC1C, CPUx Overlay Target Address Register 22 */

/** Alias (User Manual Name) for CPU2_BLK22_OTAR.
* To use register names with standard convension, please use CPU2_BLK22_OTAR.
*/


/** \brief FC20, CPUx Overlay Mask Register 22 */

/** Alias (User Manual Name) for CPU2_BLK22_OMASK.
* To use register names with standard convension, please use CPU2_BLK22_OMASK.
*/


/** \brief FC24, CPUx Redirected Address Base Register 23 */

/** Alias (User Manual Name) for CPU2_BLK23_RABR.
* To use register names with standard convension, please use CPU2_BLK23_RABR.
*/


/** \brief FC28, CPUx Overlay Target Address Register 23 */

/** Alias (User Manual Name) for CPU2_BLK23_OTAR.
* To use register names with standard convension, please use CPU2_BLK23_OTAR.
*/


/** \brief FC2C, CPUx Overlay Mask Register 23 */

/** Alias (User Manual Name) for CPU2_BLK23_OMASK.
* To use register names with standard convension, please use CPU2_BLK23_OMASK.
*/


/** \brief FC30, CPUx Redirected Address Base Register 24 */

/** Alias (User Manual Name) for CPU2_BLK24_RABR.
* To use register names with standard convension, please use CPU2_BLK24_RABR.
*/


/** \brief FC34, CPUx Overlay Target Address Register 24 */

/** Alias (User Manual Name) for CPU2_BLK24_OTAR.
* To use register names with standard convension, please use CPU2_BLK24_OTAR.
*/


/** \brief FC38, CPUx Overlay Mask Register 24 */

/** Alias (User Manual Name) for CPU2_BLK24_OMASK.
* To use register names with standard convension, please use CPU2_BLK24_OMASK.
*/


/** \brief FC3C, CPUx Redirected Address Base Register 25 */

/** Alias (User Manual Name) for CPU2_BLK25_RABR.
* To use register names with standard convension, please use CPU2_BLK25_RABR.
*/


/** \brief FC40, CPUx Overlay Target Address Register 25 */

/** Alias (User Manual Name) for CPU2_BLK25_OTAR.
* To use register names with standard convension, please use CPU2_BLK25_OTAR.
*/


/** \brief FC44, CPUx Overlay Mask Register 25 */

/** Alias (User Manual Name) for CPU2_BLK25_OMASK.
* To use register names with standard convension, please use CPU2_BLK25_OMASK.
*/


/** \brief FC48, CPUx Redirected Address Base Register 26 */

/** Alias (User Manual Name) for CPU2_BLK26_RABR.
* To use register names with standard convension, please use CPU2_BLK26_RABR.
*/


/** \brief FC4C, CPUx Overlay Target Address Register 26 */

/** Alias (User Manual Name) for CPU2_BLK26_OTAR.
* To use register names with standard convension, please use CPU2_BLK26_OTAR.
*/


/** \brief FC50, CPUx Overlay Mask Register 26 */

/** Alias (User Manual Name) for CPU2_BLK26_OMASK.
* To use register names with standard convension, please use CPU2_BLK26_OMASK.
*/


/** \brief FC54, CPUx Redirected Address Base Register 27 */

/** Alias (User Manual Name) for CPU2_BLK27_RABR.
* To use register names with standard convension, please use CPU2_BLK27_RABR.
*/


/** \brief FC58, CPUx Overlay Target Address Register 27 */

/** Alias (User Manual Name) for CPU2_BLK27_OTAR.
* To use register names with standard convension, please use CPU2_BLK27_OTAR.
*/


/** \brief FC5C, CPUx Overlay Mask Register 27 */

/** Alias (User Manual Name) for CPU2_BLK27_OMASK.
* To use register names with standard convension, please use CPU2_BLK27_OMASK.
*/


/** \brief FC60, CPUx Redirected Address Base Register 28 */

/** Alias (User Manual Name) for CPU2_BLK28_RABR.
* To use register names with standard convension, please use CPU2_BLK28_RABR.
*/


/** \brief FC64, CPUx Overlay Target Address Register 28 */

/** Alias (User Manual Name) for CPU2_BLK28_OTAR.
* To use register names with standard convension, please use CPU2_BLK28_OTAR.
*/


/** \brief FC68, CPUx Overlay Mask Register 28 */

/** Alias (User Manual Name) for CPU2_BLK28_OMASK.
* To use register names with standard convension, please use CPU2_BLK28_OMASK.
*/


/** \brief FC6C, CPUx Redirected Address Base Register 29 */

/** Alias (User Manual Name) for CPU2_BLK29_RABR.
* To use register names with standard convension, please use CPU2_BLK29_RABR.
*/


/** \brief FC70, CPUx Overlay Target Address Register 29 */

/** Alias (User Manual Name) for CPU2_BLK29_OTAR.
* To use register names with standard convension, please use CPU2_BLK29_OTAR.
*/


/** \brief FC74, CPUx Overlay Mask Register 29 */

/** Alias (User Manual Name) for CPU2_BLK29_OMASK.
* To use register names with standard convension, please use CPU2_BLK29_OMASK.
*/


/** \brief FC78, CPUx Redirected Address Base Register 30 */

/** Alias (User Manual Name) for CPU2_BLK30_RABR.
* To use register names with standard convension, please use CPU2_BLK30_RABR.
*/


/** \brief FC7C, CPUx Overlay Target Address Register 30 */

/** Alias (User Manual Name) for CPU2_BLK30_OTAR.
* To use register names with standard convension, please use CPU2_BLK30_OTAR.
*/


/** \brief FC80, CPUx Overlay Mask Register 30 */

/** Alias (User Manual Name) for CPU2_BLK30_OMASK.
* To use register names with standard convension, please use CPU2_BLK30_OMASK.
*/


/** \brief FC84, CPUx Redirected Address Base Register 31 */

/** Alias (User Manual Name) for CPU2_BLK31_RABR.
* To use register names with standard convension, please use CPU2_BLK31_RABR.
*/


/** \brief FC88, CPUx Overlay Target Address Register 31 */

/** Alias (User Manual Name) for CPU2_BLK31_OTAR.
* To use register names with standard convension, please use CPU2_BLK31_OTAR.
*/


/** \brief FC8C, CPUx Overlay Mask Register 31 */

/** Alias (User Manual Name) for CPU2_BLK31_OMASK.
* To use register names with standard convension, please use CPU2_BLK31_OMASK.
*/


/** \brief 1030, CPUx SRI Error Generation Register */


/** \brief 8004, CPUx Task Address Space Identifier Register */


/** \brief 8100, CPUx Data Access CacheabilityRegister */


/** \brief 8104, CPUx Code Access CacheabilityRegister */


/** \brief 8108, CPUx  Peripheral Space Identifier register */


/** \brief 9000, CPUx Data Control Register 2 */


/** \brief 900C, CPUx SIST Mode Access Control Register */


/** \brief 9010, CPUx Data Synchronous Trap Register */


/** \brief 9018, CPUx Data Asynchronous Trap Register */


/** \brief 901C, CPUx Data Error Address Register */


/** \brief 9020, CPUx Data Integrity Error Address Register */


/** \brief 9024, CPUx Data Integrity Error Trap Register */


/** \brief 9040, CPUx Data Memory Control Register */


/** \brief 9200, CPUx Program Synchronous Trap Register */


/** \brief 9204, CPUx Program Control 1 */


/** \brief 9208, CPUx Program Control 2 */


/** \brief 920C, CPUx Program Control 0 */


/** \brief 9210, CPUx Program Integrity Error Address Register */


/** \brief 9214, CPUx Program Integrity Error Trap Register */


/** \brief 9400, CPUx Compatibility Control Register */


/** \brief A000, CPUx Trap Control Register */


/** \brief A004, CPUx Trapping Instruction Program Counter Register */


/** \brief A008, CPUx Trapping Instruction Opcode Register */


/** \brief A010, CPUx Trapping Instruction Operand Register */


/** \brief A014, CPUx Trapping Instruction Operand Register */


/** \brief A018, CPUx Trapping Instruction Operand Register */


/** \brief C000, CPUx Data Protection Range 0, Lower Bound Register */


/** \brief C004, CPUx Data Protection Range 0, Upper Bound Register */


/** \brief C008, CPUx Data Protection Range 1, Lower Bound Register */


/** \brief C00C, CPUx Data Protection Range 1, Upper Bound Register */


/** \brief C010, CPUx Data Protection Range 2, Lower Bound Register */


/** \brief C014, CPUx Data Protection Range 2, Upper Bound Register */


/** \brief C018, CPUx Data Protection Range 3, Lower Bound Register */


/** \brief C01C, CPUx Data Protection Range 3, Upper Bound Register */


/** \brief C020, CPUx Data Protection Range 4, Lower Bound Register */


/** \brief C024, CPUx Data Protection Range 4, Upper Bound Register */


/** \brief C028, CPUx Data Protection Range 5, Lower Bound Register */


/** \brief C02C, CPUx Data Protection Range 5, Upper Bound Register */


/** \brief C030, CPUx Data Protection Range 6, Lower Bound Register */


/** \brief C034, CPUx Data Protection Range 6, Upper Bound Register */


/** \brief C038, CPUx Data Protection Range 7, Lower Bound Register */


/** \brief C03C, CPUx Data Protection Range 7, Upper Bound Register */


/** \brief C040, CPUx Data Protection Range 8, Lower Bound Register */


/** \brief C044, CPUx Data Protection Range 8, Upper Bound Register */


/** \brief C048, CPUx Data Protection Range 9, Lower Bound Register */


/** \brief C04C, CPUx Data Protection Range 9, Upper Bound Register */


/** \brief C050, CPUx Data Protection Range 10, Lower Bound Register */


/** \brief C054, CPUx Data Protection Range 10, Upper Bound Register */


/** \brief C058, CPUx Data Protection Range 11, Lower Bound Register */


/** \brief C05C, CPUx Data Protection Range 11, Upper Bound Register */


/** \brief C060, CPUx Data Protection Range 12, Lower Bound Register */


/** \brief C064, CPUx Data Protection Range 12, Upper Bound Register */


/** \brief C068, CPUx Data Protection Range 13, Lower Bound Register */


/** \brief C06C, CPUx Data Protection Range 13, Upper Bound Register */


/** \brief C070, CPUx Data Protection Range 14, Lower Bound Register */


/** \brief C074, CPUx Data Protection Range 14, Upper Bound Register */


/** \brief C078, CPUx Data Protection Range 15, Lower Bound Register */


/** \brief C07C, CPUx Data Protection Range 15, Upper Bound Register */


/** \brief C080, CPUx Data Protection Range 16, Lower Bound Register */


/** \brief C084, CPUx Data Protection Range 16, Upper Bound Register */


/** \brief C088, CPUx Data Protection Range 17, Lower Bound Register */


/** \brief C08C, CPUx Data Protection Range 17, Upper Bound Register */


/** \brief D000, CPUx Code Protection Range 0 Lower Bound Register */


/** \brief D004, CPUx Code Protection Range 0 Upper Bound Register */


/** \brief D008, CPUx Code Protection Range 1 Lower Bound Register */


/** \brief D00C, CPUx Code Protection Range 1 Upper Bound Register */


/** \brief D010, CPUx Code Protection Range 2 Lower Bound Register */


/** \brief D014, CPUx Code Protection Range 2 Upper Bound Register */


/** \brief D018, CPUx Code Protection Range 3 Lower Bound Register */


/** \brief D01C, CPUx Code Protection Range 3 Upper Bound Register */


/** \brief D020, CPUx Code Protection Range 4 Lower Bound Register */


/** \brief D024, CPUx Code Protection Range 4 Upper Bound Register */


/** \brief D028, CPUx Code Protection Range 5 Lower Bound Register */


/** \brief D02C, CPUx Code Protection Range 5 Upper Bound Register */


/** \brief D030, CPUx Code Protection Range 6 Lower Bound Register */


/** \brief D034, CPUx Code Protection Range 6 Upper Bound Register */


/** \brief D038, CPUx Code Protection Range 7 Lower Bound Register */


/** \brief D03C, CPUx Code Protection Range 7 Upper Bound Register */


/** \brief D040, CPUx Code Protection Range 8 Lower Bound Register */


/** \brief D044, CPUx Code Protection Range 8 Upper Bound Register */


/** \brief D048, CPUx Code Protection Range 9 Lower Bound Register */


/** \brief D04C, CPUx Code Protection Range 9 Upper Bound Register */


/** \brief E000, CPUx Code Protection Execute Enable Register Set 0 */


/** \brief E004, CPUx Code Protection Execute Enable Register Set 1 */


/** \brief E008, CPUx Code Protection Execute Enable Register Set 2 */


/** \brief E00C, CPUx Code Protection Execute Enable Register Set 3 */


/** \brief E010, CPUx Data Protection Read Enable Register Set 0 */


/** \brief E014, CPUx Data Protection Read Enable Register Set 1 */


/** \brief E018, CPUx Data Protection Read Enable Register Set 2 */


/** \brief E01C, CPUx Data Protection Read Enable Register Set 3 */


/** \brief E020, CPUx Data Protection Write Enable Register Set 0 */


/** \brief E024, CPUx Data Protection Write Enable Register Set 1 */


/** \brief E028, CPUx Data Protection Write Enable Register Set 2 */


/** \brief E02C, CPUx Data Protection Write Enable Register Set 3 */


/** \brief E040, CPUx Code Protection Execute Enable Register Set 4 */


/** \brief E044, CPUx Code Protection Execute Enable Register Set 5 */


/** \brief E050, CPUx Data Protection Read Enable Register Set 4 */


/** \brief E054, CPUx Data Protection Read Enable Register Set 5 */


/** \brief E060, CPUx Data Protection Write Enable Register Set 4 */


/** \brief E064, CPUx Data Protection Write Enable Register Set 5 */


/** \brief E400, CPUx Temporal Protection System Control Register */


/** \brief E404, CPUx Temporal Protection System Timer Register 0 */


/** \brief E408, CPUx Temporal Protection System Timer Register 1 */


/** \brief E40C, CPUx Temporal Protection System Timer Register 2 */


/** \brief E440, CPUx Exception Entry Timer Load Value */


/** \brief E444, CPUx Exception Entry Timer Current Value */


/** \brief E448, CPUx Exception Exit  Timer Load Value */


/** \brief E44C, CPUx Exception Exit Timer Current Value */


/** \brief E450, CPUx Exception Timer Class Enable Register */


/** \brief E454, CPUx Exception Timer Status Register */


/** \brief E458, CPUx Exception Timer FCX Register */


/** \brief F000, CPUx Trigger Event 0 */

/** Alias (User Manual Name) for CPU2_TR0_EVT.
* To use register names with standard convension, please use CPU2_TR0_EVT.
*/


/** \brief F004, CPUx Trigger Address 0 */

/** Alias (User Manual Name) for CPU2_TR0_ADR.
* To use register names with standard convension, please use CPU2_TR0_ADR.
*/


/** \brief F008, CPUx Trigger Event 1 */

/** Alias (User Manual Name) for CPU2_TR1_EVT.
* To use register names with standard convension, please use CPU2_TR1_EVT.
*/


/** \brief F00C, CPUx Trigger Address 1 */

/** Alias (User Manual Name) for CPU2_TR1_ADR.
* To use register names with standard convension, please use CPU2_TR1_ADR.
*/


/** \brief F010, CPUx Trigger Event 2 */

/** Alias (User Manual Name) for CPU2_TR2_EVT.
* To use register names with standard convension, please use CPU2_TR2_EVT.
*/


/** \brief F014, CPUx Trigger Address 2 */

/** Alias (User Manual Name) for CPU2_TR2_ADR.
* To use register names with standard convension, please use CPU2_TR2_ADR.
*/


/** \brief F018, CPUx Trigger Event 3 */

/** Alias (User Manual Name) for CPU2_TR3_EVT.
* To use register names with standard convension, please use CPU2_TR3_EVT.
*/


/** \brief F01C, CPUx Trigger Address 3 */

/** Alias (User Manual Name) for CPU2_TR3_ADR.
* To use register names with standard convension, please use CPU2_TR3_ADR.
*/


/** \brief F020, CPUx Trigger Event 4 */

/** Alias (User Manual Name) for CPU2_TR4_EVT.
* To use register names with standard convension, please use CPU2_TR4_EVT.
*/


/** \brief F024, CPUx Trigger Address 4 */

/** Alias (User Manual Name) for CPU2_TR4_ADR.
* To use register names with standard convension, please use CPU2_TR4_ADR.
*/


/** \brief F028, CPUx Trigger Event 5 */

/** Alias (User Manual Name) for CPU2_TR5_EVT.
* To use register names with standard convension, please use CPU2_TR5_EVT.
*/


/** \brief F02C, CPUx Trigger Address 5 */

/** Alias (User Manual Name) for CPU2_TR5_ADR.
* To use register names with standard convension, please use CPU2_TR5_ADR.
*/


/** \brief F030, CPUx Trigger Event 6 */

/** Alias (User Manual Name) for CPU2_TR6_EVT.
* To use register names with standard convension, please use CPU2_TR6_EVT.
*/


/** \brief F034, CPUx Trigger Address 6 */

/** Alias (User Manual Name) for CPU2_TR6_ADR.
* To use register names with standard convension, please use CPU2_TR6_ADR.
*/


/** \brief F038, CPUx Trigger Event 7 */

/** Alias (User Manual Name) for CPU2_TR7_EVT.
* To use register names with standard convension, please use CPU2_TR7_EVT.
*/


/** \brief F03C, CPUx Trigger Address 7 */

/** Alias (User Manual Name) for CPU2_TR7_ADR.
* To use register names with standard convension, please use CPU2_TR7_ADR.
*/


/** \brief FC00, CPUx Counter Control */


/** \brief FC04, CPUx CPU Clock Cycle Count */


/** \brief FC08, CPUx Instruction Count */


/** \brief FC0C, CPUx Multi-Count Register 1 */


/** \brief FC10, CPUx Multi-Count Register 2 */


/** \brief FC14, CPUx Multi-Count Register 3 */


/** \brief FD00, CPUx Debug Status Register */


/** \brief FD08, CPUx External Event Register */


/** \brief FD0C, CPUx Core Register Access Event */


/** \brief FD10, CPUx Software Debug Event */


/** \brief FD30, CPUx TriggerAddressx */


/** \brief FD40, CPUx Debug Monitor Start Address */


/** \brief FD44, CPUx Debug Context Save Area Pointer */


/** \brief FD48, CPUx Debug Trap Control Register */


/** \brief FE00, CPUx Previous Context Information Register */


/** \brief FE04, CPUx Program Status Word */


/** \brief FE08, CPUx Program Counter */


/** \brief FE14, CPUx System Configuration Register */


/** \brief FE18, CPUx Identification Register TC1.6.2P */


/** \brief FE1C, CPUx Core Identification Register */


/** \brief FE20, CPUx Base Interrupt Vector Table Pointer */


/** \brief FE24, CPUx Base Trap Vector Table Pointer */


/** \brief FE28, CPUx Interrupt Stack Pointer */


/** \brief FE2C, CPUx Interrupt Control Register */


/** \brief FE38, CPUx Free CSA List Head Pointer */


/** \brief FE3C, CPUx Free CSA List Limit Pointer */


/** \brief FE50, CPUx Customer ID register */


/** \brief FF00, CPUx Data General Purpose Register 0 */


/** \brief FF04, CPUx Data General Purpose Register 1 */


/** \brief FF08, CPUx Data General Purpose Register 2 */


/** \brief FF0C, CPUx Data General Purpose Register 3 */


/** \brief FF10, CPUx Data General Purpose Register 4 */


/** \brief FF14, CPUx Data General Purpose Register 5 */


/** \brief FF18, CPUx Data General Purpose Register 6 */


/** \brief FF1C, CPUx Data General Purpose Register 7 */


/** \brief FF20, CPUx Data General Purpose Register 8 */


/** \brief FF24, CPUx Data General Purpose Register 9 */


/** \brief FF28, CPUx Data General Purpose Register 10 */


/** \brief FF2C, CPUx Data General Purpose Register 11 */


/** \brief FF30, CPUx Data General Purpose Register 12 */


/** \brief FF34, CPUx Data General Purpose Register 13 */


/** \brief FF38, CPUx Data General Purpose Register 14 */


/** \brief FF3C, CPUx Data General Purpose Register 15 */


/** \brief FF80, CPUx Address General Purpose Register 0 */


/** \brief FF84, CPUx Address General Purpose Register 1 */


/** \brief FF88, CPUx Address General Purpose Register 2 */


/** \brief FF8C, CPUx Address General Purpose Register 3 */


/** \brief FF90, CPUx Address General Purpose Register 4 */


/** \brief FF94, CPUx Address General Purpose Register 5 */


/** \brief FF98, CPUx Address General Purpose Register 6 */


/** \brief FF9C, CPUx Address General Purpose Register 7 */


/** \brief FFA0, CPUx Address General Purpose Register 8 */


/** \brief FFA4, CPUx Address General Purpose Register 9 */


/** \brief FFA8, CPUx Address General Purpose Register 10 */


/** \brief FFAC, CPUx Address General Purpose Register 11 */


/** \brief FFB0, CPUx Address General Purpose Register 12 */


/** \brief FFB4, CPUx Address General Purpose Register 13 */


/** \brief FFB8, CPUx Address General Purpose Register 14 */


/** \brief FFBC, CPUx Address General Purpose Register 15 */


/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Cpu_Registers_Cfg_Cpu3
 * \{  */
/** \brief 1100, CPUx Flash Configuration Register 0 */


/** \brief 1104, CPUx Flash Configuration Register 1 */


/** \brief 1108, CPUx Flash Configuration Register 2 */


/** \brief 110C, CPUx Flash Configuration Register 3 */


/** \brief 1110, CPUx Flash Configuration Register 4 */


/** \brief D000, CPUx  Reset Register 0 */


/** \brief D004, CPUx  Reset Register 1 */


/** \brief D008, CPUx Reset Clear Register */


/** \brief E000, CPUx Safety Protection SPR Region Lower Address Register 0 */

/** Alias (User Manual Name) for CPU3_RGN0_LA.
* To use register names with standard convension, please use CPU3_RGN0_LA.
*/


/** \brief E004, CPUx Safety Protection SPR Region Upper Address Register 0 */

/** Alias (User Manual Name) for CPU3_RGN0_UA.
* To use register names with standard convension, please use CPU3_RGN0_UA.
*/


/** \brief E008, CPUx Safety Protection SPR Region Write Access Enable Register A0 */

/** Alias (User Manual Name) for CPU3_RGN0_ACCENA.
* To use register names with standard convension, please use CPU3_RGN0_ACCENA.
*/


/** \brief E00C, CPUx Safety Protection SPR Region Write Access Enable Register B0 */

/** Alias (User Manual Name) for CPU3_RGN0_ACCENB.
* To use register names with standard convension, please use CPU3_RGN0_ACCENB.
*/


/** \brief E010, CPUx Safety Protection SPR Region Lower Address Register 1 */

/** Alias (User Manual Name) for CPU3_RGN1_LA.
* To use register names with standard convension, please use CPU3_RGN1_LA.
*/


/** \brief E014, CPUx Safety Protection SPR Region Upper Address Register 1 */

/** Alias (User Manual Name) for CPU3_RGN1_UA.
* To use register names with standard convension, please use CPU3_RGN1_UA.
*/


/** \brief E018, CPUx Safety Protection SPR Region Write Access Enable Register A1 */

/** Alias (User Manual Name) for CPU3_RGN1_ACCENA.
* To use register names with standard convension, please use CPU3_RGN1_ACCENA.
*/


/** \brief E01C, CPUx Safety Protection SPR Region Write Access Enable Register B1 */

/** Alias (User Manual Name) for CPU3_RGN1_ACCENB.
* To use register names with standard convension, please use CPU3_RGN1_ACCENB.
*/


/** \brief E020, CPUx Safety Protection SPR Region Lower Address Register 2 */

/** Alias (User Manual Name) for CPU3_RGN2_LA.
* To use register names with standard convension, please use CPU3_RGN2_LA.
*/


/** \brief E024, CPUx Safety Protection SPR Region Upper Address Register 2 */

/** Alias (User Manual Name) for CPU3_RGN2_UA.
* To use register names with standard convension, please use CPU3_RGN2_UA.
*/


/** \brief E028, CPUx Safety Protection SPR Region Write Access Enable Register A2 */

/** Alias (User Manual Name) for CPU3_RGN2_ACCENA.
* To use register names with standard convension, please use CPU3_RGN2_ACCENA.
*/


/** \brief E02C, CPUx Safety Protection SPR Region Write Access Enable Register B2 */

/** Alias (User Manual Name) for CPU3_RGN2_ACCENB.
* To use register names with standard convension, please use CPU3_RGN2_ACCENB.
*/


/** \brief E030, CPUx Safety Protection SPR Region Lower Address Register 3 */

/** Alias (User Manual Name) for CPU3_RGN3_LA.
* To use register names with standard convension, please use CPU3_RGN3_LA.
*/


/** \brief E034, CPUx Safety Protection SPR Region Upper Address Register 3 */

/** Alias (User Manual Name) for CPU3_RGN3_UA.
* To use register names with standard convension, please use CPU3_RGN3_UA.
*/


/** \brief E038, CPUx Safety Protection SPR Region Write Access Enable Register A3 */

/** Alias (User Manual Name) for CPU3_RGN3_ACCENA.
* To use register names with standard convension, please use CPU3_RGN3_ACCENA.
*/


/** \brief E03C, CPUx Safety Protection SPR Region Write Access Enable Register B3 */

/** Alias (User Manual Name) for CPU3_RGN3_ACCENB.
* To use register names with standard convension, please use CPU3_RGN3_ACCENB.
*/


/** \brief E040, CPUx Safety Protection SPR Region Lower Address Register 4 */

/** Alias (User Manual Name) for CPU3_RGN4_LA.
* To use register names with standard convension, please use CPU3_RGN4_LA.
*/


/** \brief E044, CPUx Safety Protection SPR Region Upper Address Register 4 */

/** Alias (User Manual Name) for CPU3_RGN4_UA.
* To use register names with standard convension, please use CPU3_RGN4_UA.
*/


/** \brief E048, CPUx Safety Protection SPR Region Write Access Enable Register A4 */

/** Alias (User Manual Name) for CPU3_RGN4_ACCENA.
* To use register names with standard convension, please use CPU3_RGN4_ACCENA.
*/


/** \brief E04C, CPUx Safety Protection SPR Region Write Access Enable Register B4 */

/** Alias (User Manual Name) for CPU3_RGN4_ACCENB.
* To use register names with standard convension, please use CPU3_RGN4_ACCENB.
*/


/** \brief E050, CPUx Safety Protection SPR Region Lower Address Register 5 */

/** Alias (User Manual Name) for CPU3_RGN5_LA.
* To use register names with standard convension, please use CPU3_RGN5_LA.
*/


/** \brief E054, CPUx Safety Protection SPR Region Upper Address Register 5 */

/** Alias (User Manual Name) for CPU3_RGN5_UA.
* To use register names with standard convension, please use CPU3_RGN5_UA.
*/


/** \brief E058, CPUx Safety Protection SPR Region Write Access Enable Register A5 */

/** Alias (User Manual Name) for CPU3_RGN5_ACCENA.
* To use register names with standard convension, please use CPU3_RGN5_ACCENA.
*/


/** \brief E05C, CPUx Safety Protection SPR Region Write Access Enable Register B5 */

/** Alias (User Manual Name) for CPU3_RGN5_ACCENB.
* To use register names with standard convension, please use CPU3_RGN5_ACCENB.
*/


/** \brief E060, CPUx Safety Protection SPR Region Lower Address Register 6 */

/** Alias (User Manual Name) for CPU3_RGN6_LA.
* To use register names with standard convension, please use CPU3_RGN6_LA.
*/


/** \brief E064, CPUx Safety Protection SPR Region Upper Address Register 6 */

/** Alias (User Manual Name) for CPU3_RGN6_UA.
* To use register names with standard convension, please use CPU3_RGN6_UA.
*/


/** \brief E068, CPUx Safety Protection SPR Region Write Access Enable Register A6 */

/** Alias (User Manual Name) for CPU3_RGN6_ACCENA.
* To use register names with standard convension, please use CPU3_RGN6_ACCENA.
*/


/** \brief E06C, CPUx Safety Protection SPR Region Write Access Enable Register B6 */

/** Alias (User Manual Name) for CPU3_RGN6_ACCENB.
* To use register names with standard convension, please use CPU3_RGN6_ACCENB.
*/


/** \brief E070, CPUx Safety Protection SPR Region Lower Address Register 7 */

/** Alias (User Manual Name) for CPU3_RGN7_LA.
* To use register names with standard convension, please use CPU3_RGN7_LA.
*/


/** \brief E074, CPUx Safety Protection SPR Region Upper Address Register 7 */

/** Alias (User Manual Name) for CPU3_RGN7_UA.
* To use register names with standard convension, please use CPU3_RGN7_UA.
*/


/** \brief E078, CPUx Safety Protection SPR Region Write Access Enable Register A7 */

/** Alias (User Manual Name) for CPU3_RGN7_ACCENA.
* To use register names with standard convension, please use CPU3_RGN7_ACCENA.
*/


/** \brief E07C, CPUx Safety Protection SPR Region Write Access Enable Register B7 */

/** Alias (User Manual Name) for CPU3_RGN7_ACCENB.
* To use register names with standard convension, please use CPU3_RGN7_ACCENB.
*/


/** \brief E088, CPUx Safety Protection SPR Region Read Access Enable Register A0 */

/** Alias (User Manual Name) for CPU3_SPR_SPROT_RGNACCENA_R0.
* To use register names with standard convension, please use CPU3_SPR_SPROT_RGNACCENA_R0.
*/


/** \brief E08C, CPUx Safety Protection SPR Region Read Access Enable Register B0 */

/** Alias (User Manual Name) for CPU3_SPR_SPROT_RGNACCENB_R0.
* To use register names with standard convension, please use CPU3_SPR_SPROT_RGNACCENB_R0.
*/


/** \brief E098, CPUx Safety Protection SPR Region Read Access Enable Register A1 */

/** Alias (User Manual Name) for CPU3_SPR_SPROT_RGNACCENA_R1.
* To use register names with standard convension, please use CPU3_SPR_SPROT_RGNACCENA_R1.
*/


/** \brief E09C, CPUx Safety Protection SPR Region Read Access Enable Register B1 */

/** Alias (User Manual Name) for CPU3_SPR_SPROT_RGNACCENB_R1.
* To use register names with standard convension, please use CPU3_SPR_SPROT_RGNACCENB_R1.
*/


/** \brief E0A8, CPUx Safety Protection SPR Region Read Access Enable Register A2 */

/** Alias (User Manual Name) for CPU3_SPR_SPROT_RGNACCENA_R2.
* To use register names with standard convension, please use CPU3_SPR_SPROT_RGNACCENA_R2.
*/


/** \brief E0AC, CPUx Safety Protection SPR Region Read Access Enable Register B2 */

/** Alias (User Manual Name) for CPU3_SPR_SPROT_RGNACCENB_R2.
* To use register names with standard convension, please use CPU3_SPR_SPROT_RGNACCENB_R2.
*/


/** \brief E0B8, CPUx Safety Protection SPR Region Read Access Enable Register A3 */

/** Alias (User Manual Name) for CPU3_SPR_SPROT_RGNACCENA_R3.
* To use register names with standard convension, please use CPU3_SPR_SPROT_RGNACCENA_R3.
*/


/** \brief E0BC, CPUx Safety Protection SPR Region Read Access Enable Register B3 */

/** Alias (User Manual Name) for CPU3_SPR_SPROT_RGNACCENB_R3.
* To use register names with standard convension, please use CPU3_SPR_SPROT_RGNACCENB_R3.
*/


/** \brief E0C8, CPUx Safety Protection SPR Region Read Access Enable Register A4 */

/** Alias (User Manual Name) for CPU3_SPR_SPROT_RGNACCENA_R4.
* To use register names with standard convension, please use CPU3_SPR_SPROT_RGNACCENA_R4.
*/


/** \brief E0CC, CPUx Safety Protection SPR Region Read Access Enable Register B4 */

/** Alias (User Manual Name) for CPU3_SPR_SPROT_RGNACCENB_R4.
* To use register names with standard convension, please use CPU3_SPR_SPROT_RGNACCENB_R4.
*/


/** \brief E0D8, CPUx Safety Protection SPR Region Read Access Enable Register A5 */

/** Alias (User Manual Name) for CPU3_SPR_SPROT_RGNACCENA_R5.
* To use register names with standard convension, please use CPU3_SPR_SPROT_RGNACCENA_R5.
*/


/** \brief E0DC, CPUx Safety Protection SPR Region Read Access Enable Register B5 */

/** Alias (User Manual Name) for CPU3_SPR_SPROT_RGNACCENB_R5.
* To use register names with standard convension, please use CPU3_SPR_SPROT_RGNACCENB_R5.
*/


/** \brief E0E8, CPUx Safety Protection SPR Region Read Access Enable Register A6 */

/** Alias (User Manual Name) for CPU3_SPR_SPROT_RGNACCENA_R6.
* To use register names with standard convension, please use CPU3_SPR_SPROT_RGNACCENA_R6.
*/


/** \brief E0EC, CPUx Safety Protection SPR Region Read Access Enable Register B6 */

/** Alias (User Manual Name) for CPU3_SPR_SPROT_RGNACCENB_R6.
* To use register names with standard convension, please use CPU3_SPR_SPROT_RGNACCENB_R6.
*/


/** \brief E0F8, CPUx Safety Protection SPR Region Read Access Enable Register A7 */

/** Alias (User Manual Name) for CPU3_SPR_SPROT_RGNACCENA_R7.
* To use register names with standard convension, please use CPU3_SPR_SPROT_RGNACCENA_R7.
*/


/** \brief E0FC, CPUx Safety Protection SPR Region Read Access Enable Register B7 */

/** Alias (User Manual Name) for CPU3_SPR_SPROT_RGNACCENB_R7.
* To use register names with standard convension, please use CPU3_SPR_SPROT_RGNACCENB_R7.
*/


/** \brief E100, CPUx Safety Protection Register Access Enable Register A */


/** \brief E104, CPUx Safety Protection Region Access Enable Register B */


/** \brief E110, CPUx Safety Protection Region LPB Read Access Enable Register A */


/** \brief E114, CPUx Safety Protection Region LPB Read Access Enable Register B */


/** \brief E200, CPUx Safety Protection DLMU Region Lower Address Register 0 */


/** \brief E204, CPUx Safety protection DLMU Region Upper Address Register 0 */


/** \brief E208, CPUx Safety Protection Region DLMU Write Access Enable Register A0 */

/** Alias (User Manual Name) for CPU3_DLMU_SPROT_RGNACCENA_W0.
* To use register names with standard convension, please use CPU3_DLMU_SPROT_RGNACCENA_W0.
*/


/** \brief E20C, CPUx Safety Protection Region DLMU Write Access Enable Register B0 */

/** Alias (User Manual Name) for CPU3_DLMU_SPROT_RGNACCENB_W0.
* To use register names with standard convension, please use CPU3_DLMU_SPROT_RGNACCENB_W0.
*/


/** \brief E210, CPUx Safety Protection DLMU Region Lower Address Register 1 */


/** \brief E214, CPUx Safety protection DLMU Region Upper Address Register 1 */


/** \brief E218, CPUx Safety Protection Region DLMU Write Access Enable Register A1 */

/** Alias (User Manual Name) for CPU3_DLMU_SPROT_RGNACCENA_W1.
* To use register names with standard convension, please use CPU3_DLMU_SPROT_RGNACCENA_W1.
*/


/** \brief E21C, CPUx Safety Protection Region DLMU Write Access Enable Register B1 */

/** Alias (User Manual Name) for CPU3_DLMU_SPROT_RGNACCENB_W1.
* To use register names with standard convension, please use CPU3_DLMU_SPROT_RGNACCENB_W1.
*/


/** \brief E220, CPUx Safety Protection DLMU Region Lower Address Register 2 */


/** \brief E224, CPUx Safety protection DLMU Region Upper Address Register 2 */


/** \brief E228, CPUx Safety Protection Region DLMU Write Access Enable Register A2 */

/** Alias (User Manual Name) for CPU3_DLMU_SPROT_RGNACCENA_W2.
* To use register names with standard convension, please use CPU3_DLMU_SPROT_RGNACCENA_W2.
*/


/** \brief E22C, CPUx Safety Protection Region DLMU Write Access Enable Register B2 */

/** Alias (User Manual Name) for CPU3_DLMU_SPROT_RGNACCENB_W2.
* To use register names with standard convension, please use CPU3_DLMU_SPROT_RGNACCENB_W2.
*/


/** \brief E230, CPUx Safety Protection DLMU Region Lower Address Register 3 */


/** \brief E234, CPUx Safety protection DLMU Region Upper Address Register 3 */


/** \brief E238, CPUx Safety Protection Region DLMU Write Access Enable Register A3 */

/** Alias (User Manual Name) for CPU3_DLMU_SPROT_RGNACCENA_W3.
* To use register names with standard convension, please use CPU3_DLMU_SPROT_RGNACCENA_W3.
*/


/** \brief E23C, CPUx Safety Protection Region DLMU Write Access Enable Register B3 */

/** Alias (User Manual Name) for CPU3_DLMU_SPROT_RGNACCENB_W3.
* To use register names with standard convension, please use CPU3_DLMU_SPROT_RGNACCENB_W3.
*/


/** \brief E240, CPUx Safety Protection DLMU Region Lower Address Register 4 */


/** \brief E244, CPUx Safety protection DLMU Region Upper Address Register 4 */


/** \brief E248, CPUx Safety Protection Region DLMU Write Access Enable Register A4 */

/** Alias (User Manual Name) for CPU3_DLMU_SPROT_RGNACCENA_W4.
* To use register names with standard convension, please use CPU3_DLMU_SPROT_RGNACCENA_W4.
*/


/** \brief E24C, CPUx Safety Protection Region DLMU Write Access Enable Register B4 */

/** Alias (User Manual Name) for CPU3_DLMU_SPROT_RGNACCENB_W4.
* To use register names with standard convension, please use CPU3_DLMU_SPROT_RGNACCENB_W4.
*/


/** \brief E250, CPUx Safety Protection DLMU Region Lower Address Register 5 */


/** \brief E254, CPUx Safety protection DLMU Region Upper Address Register 5 */


/** \brief E258, CPUx Safety Protection Region DLMU Write Access Enable Register A5 */

/** Alias (User Manual Name) for CPU3_DLMU_SPROT_RGNACCENA_W5.
* To use register names with standard convension, please use CPU3_DLMU_SPROT_RGNACCENA_W5.
*/


/** \brief E25C, CPUx Safety Protection Region DLMU Write Access Enable Register B5 */

/** Alias (User Manual Name) for CPU3_DLMU_SPROT_RGNACCENB_W5.
* To use register names with standard convension, please use CPU3_DLMU_SPROT_RGNACCENB_W5.
*/


/** \brief E260, CPUx Safety Protection DLMU Region Lower Address Register 6 */


/** \brief E264, CPUx Safety protection DLMU Region Upper Address Register 6 */


/** \brief E268, CPUx Safety Protection Region DLMU Write Access Enable Register A6 */

/** Alias (User Manual Name) for CPU3_DLMU_SPROT_RGNACCENA_W6.
* To use register names with standard convension, please use CPU3_DLMU_SPROT_RGNACCENA_W6.
*/


/** \brief E26C, CPUx Safety Protection Region DLMU Write Access Enable Register B6 */

/** Alias (User Manual Name) for CPU3_DLMU_SPROT_RGNACCENB_W6.
* To use register names with standard convension, please use CPU3_DLMU_SPROT_RGNACCENB_W6.
*/


/** \brief E270, CPUx Safety Protection DLMU Region Lower Address Register 7 */


/** \brief E274, CPUx Safety protection DLMU Region Upper Address Register 7 */


/** \brief E278, CPUx Safety Protection Region DLMU Write Access Enable Register A7 */

/** Alias (User Manual Name) for CPU3_DLMU_SPROT_RGNACCENA_W7.
* To use register names with standard convension, please use CPU3_DLMU_SPROT_RGNACCENA_W7.
*/


/** \brief E27C, CPUx Safety Protection Region DLMU Write Access Enable Register B7 */

/** Alias (User Manual Name) for CPU3_DLMU_SPROT_RGNACCENB_W7.
* To use register names with standard convension, please use CPU3_DLMU_SPROT_RGNACCENB_W7.
*/


/** \brief E288, CPUx Safety Protection Region DLMU Read Access Enable Register A0 */

/** Alias (User Manual Name) for CPU3_DLMU_SPROT_RGNACCENA_R0.
* To use register names with standard convension, please use CPU3_DLMU_SPROT_RGNACCENA_R0.
*/


/** \brief E28C, CPUx Safety Protection Region DLMU Read Access Enable Register B0 */

/** Alias (User Manual Name) for CPU3_DLMU_SPROT_RGNACCENB_R0.
* To use register names with standard convension, please use CPU3_DLMU_SPROT_RGNACCENB_R0.
*/


/** \brief E298, CPUx Safety Protection Region DLMU Read Access Enable Register A1 */

/** Alias (User Manual Name) for CPU3_DLMU_SPROT_RGNACCENA_R1.
* To use register names with standard convension, please use CPU3_DLMU_SPROT_RGNACCENA_R1.
*/


/** \brief E29C, CPUx Safety Protection Region DLMU Read Access Enable Register B1 */

/** Alias (User Manual Name) for CPU3_DLMU_SPROT_RGNACCENB_R1.
* To use register names with standard convension, please use CPU3_DLMU_SPROT_RGNACCENB_R1.
*/


/** \brief E2A8, CPUx Safety Protection Region DLMU Read Access Enable Register A2 */

/** Alias (User Manual Name) for CPU3_DLMU_SPROT_RGNACCENA_R2.
* To use register names with standard convension, please use CPU3_DLMU_SPROT_RGNACCENA_R2.
*/


/** \brief E2AC, CPUx Safety Protection Region DLMU Read Access Enable Register B2 */

/** Alias (User Manual Name) for CPU3_DLMU_SPROT_RGNACCENB_R2.
* To use register names with standard convension, please use CPU3_DLMU_SPROT_RGNACCENB_R2.
*/


/** \brief E2B8, CPUx Safety Protection Region DLMU Read Access Enable Register A3 */

/** Alias (User Manual Name) for CPU3_DLMU_SPROT_RGNACCENA_R3.
* To use register names with standard convension, please use CPU3_DLMU_SPROT_RGNACCENA_R3.
*/


/** \brief E2BC, CPUx Safety Protection Region DLMU Read Access Enable Register B3 */

/** Alias (User Manual Name) for CPU3_DLMU_SPROT_RGNACCENB_R3.
* To use register names with standard convension, please use CPU3_DLMU_SPROT_RGNACCENB_R3.
*/


/** \brief E2C8, CPUx Safety Protection Region DLMU Read Access Enable Register A4 */

/** Alias (User Manual Name) for CPU3_DLMU_SPROT_RGNACCENA_R4.
* To use register names with standard convension, please use CPU3_DLMU_SPROT_RGNACCENA_R4.
*/


/** \brief E2CC, CPUx Safety Protection Region DLMU Read Access Enable Register B4 */

/** Alias (User Manual Name) for CPU3_DLMU_SPROT_RGNACCENB_R4.
* To use register names with standard convension, please use CPU3_DLMU_SPROT_RGNACCENB_R4.
*/


/** \brief E2D8, CPUx Safety Protection Region DLMU Read Access Enable Register A5 */

/** Alias (User Manual Name) for CPU3_DLMU_SPROT_RGNACCENA_R5.
* To use register names with standard convension, please use CPU3_DLMU_SPROT_RGNACCENA_R5.
*/


/** \brief E2DC, CPUx Safety Protection Region DLMU Read Access Enable Register B5 */

/** Alias (User Manual Name) for CPU3_DLMU_SPROT_RGNACCENB_R5.
* To use register names with standard convension, please use CPU3_DLMU_SPROT_RGNACCENB_R5.
*/


/** \brief E2E8, CPUx Safety Protection Region DLMU Read Access Enable Register A6 */

/** Alias (User Manual Name) for CPU3_DLMU_SPROT_RGNACCENA_R6.
* To use register names with standard convension, please use CPU3_DLMU_SPROT_RGNACCENA_R6.
*/


/** \brief E2EC, CPUx Safety Protection Region DLMU Read Access Enable Register B6 */

/** Alias (User Manual Name) for CPU3_DLMU_SPROT_RGNACCENB_R6.
* To use register names with standard convension, please use CPU3_DLMU_SPROT_RGNACCENB_R6.
*/


/** \brief E2F8, CPUx Safety Protection Region DLMU Read Access Enable Register A7 */

/** Alias (User Manual Name) for CPU3_DLMU_SPROT_RGNACCENA_R7.
* To use register names with standard convension, please use CPU3_DLMU_SPROT_RGNACCENA_R7.
*/


/** \brief E2FC, CPUx Safety Protection Region DLMU Read Access Enable Register B7 */

/** Alias (User Manual Name) for CPU3_DLMU_SPROT_RGNACCENB_R7.
* To use register names with standard convension, please use CPU3_DLMU_SPROT_RGNACCENB_R7.
*/


/** \brief FB00, CPUx  Overlay Range Select Register */


/** \brief FB10, CPUx Redirected Address Base Register 0 */

/** Alias (User Manual Name) for CPU3_BLK0_RABR.
* To use register names with standard convension, please use CPU3_BLK0_RABR.
*/


/** \brief FB14, CPUx Overlay Target Address Register 0 */

/** Alias (User Manual Name) for CPU3_BLK0_OTAR.
* To use register names with standard convension, please use CPU3_BLK0_OTAR.
*/


/** \brief FB18, CPUx Overlay Mask Register 0 */

/** Alias (User Manual Name) for CPU3_BLK0_OMASK.
* To use register names with standard convension, please use CPU3_BLK0_OMASK.
*/


/** \brief FB1C, CPUx Redirected Address Base Register 1 */

/** Alias (User Manual Name) for CPU3_BLK1_RABR.
* To use register names with standard convension, please use CPU3_BLK1_RABR.
*/


/** \brief FB20, CPUx Overlay Target Address Register 1 */

/** Alias (User Manual Name) for CPU3_BLK1_OTAR.
* To use register names with standard convension, please use CPU3_BLK1_OTAR.
*/


/** \brief FB24, CPUx Overlay Mask Register 1 */

/** Alias (User Manual Name) for CPU3_BLK1_OMASK.
* To use register names with standard convension, please use CPU3_BLK1_OMASK.
*/


/** \brief FB28, CPUx Redirected Address Base Register 2 */

/** Alias (User Manual Name) for CPU3_BLK2_RABR.
* To use register names with standard convension, please use CPU3_BLK2_RABR.
*/


/** \brief FB2C, CPUx Overlay Target Address Register 2 */

/** Alias (User Manual Name) for CPU3_BLK2_OTAR.
* To use register names with standard convension, please use CPU3_BLK2_OTAR.
*/


/** \brief FB30, CPUx Overlay Mask Register 2 */

/** Alias (User Manual Name) for CPU3_BLK2_OMASK.
* To use register names with standard convension, please use CPU3_BLK2_OMASK.
*/


/** \brief FB34, CPUx Redirected Address Base Register 3 */

/** Alias (User Manual Name) for CPU3_BLK3_RABR.
* To use register names with standard convension, please use CPU3_BLK3_RABR.
*/


/** \brief FB38, CPUx Overlay Target Address Register 3 */

/** Alias (User Manual Name) for CPU3_BLK3_OTAR.
* To use register names with standard convension, please use CPU3_BLK3_OTAR.
*/


/** \brief FB3C, CPUx Overlay Mask Register 3 */

/** Alias (User Manual Name) for CPU3_BLK3_OMASK.
* To use register names with standard convension, please use CPU3_BLK3_OMASK.
*/


/** \brief FB40, CPUx Redirected Address Base Register 4 */

/** Alias (User Manual Name) for CPU3_BLK4_RABR.
* To use register names with standard convension, please use CPU3_BLK4_RABR.
*/


/** \brief FB44, CPUx Overlay Target Address Register 4 */

/** Alias (User Manual Name) for CPU3_BLK4_OTAR.
* To use register names with standard convension, please use CPU3_BLK4_OTAR.
*/


/** \brief FB48, CPUx Overlay Mask Register 4 */

/** Alias (User Manual Name) for CPU3_BLK4_OMASK.
* To use register names with standard convension, please use CPU3_BLK4_OMASK.
*/


/** \brief FB4C, CPUx Redirected Address Base Register 5 */

/** Alias (User Manual Name) for CPU3_BLK5_RABR.
* To use register names with standard convension, please use CPU3_BLK5_RABR.
*/


/** \brief FB50, CPUx Overlay Target Address Register 5 */

/** Alias (User Manual Name) for CPU3_BLK5_OTAR.
* To use register names with standard convension, please use CPU3_BLK5_OTAR.
*/


/** \brief FB54, CPUx Overlay Mask Register 5 */

/** Alias (User Manual Name) for CPU3_BLK5_OMASK.
* To use register names with standard convension, please use CPU3_BLK5_OMASK.
*/


/** \brief FB58, CPUx Redirected Address Base Register 6 */

/** Alias (User Manual Name) for CPU3_BLK6_RABR.
* To use register names with standard convension, please use CPU3_BLK6_RABR.
*/


/** \brief FB5C, CPUx Overlay Target Address Register 6 */

/** Alias (User Manual Name) for CPU3_BLK6_OTAR.
* To use register names with standard convension, please use CPU3_BLK6_OTAR.
*/


/** \brief FB60, CPUx Overlay Mask Register 6 */

/** Alias (User Manual Name) for CPU3_BLK6_OMASK.
* To use register names with standard convension, please use CPU3_BLK6_OMASK.
*/


/** \brief FB64, CPUx Redirected Address Base Register 7 */

/** Alias (User Manual Name) for CPU3_BLK7_RABR.
* To use register names with standard convension, please use CPU3_BLK7_RABR.
*/


/** \brief FB68, CPUx Overlay Target Address Register 7 */

/** Alias (User Manual Name) for CPU3_BLK7_OTAR.
* To use register names with standard convension, please use CPU3_BLK7_OTAR.
*/


/** \brief FB6C, CPUx Overlay Mask Register 7 */

/** Alias (User Manual Name) for CPU3_BLK7_OMASK.
* To use register names with standard convension, please use CPU3_BLK7_OMASK.
*/


/** \brief FB70, CPUx Redirected Address Base Register 8 */

/** Alias (User Manual Name) for CPU3_BLK8_RABR.
* To use register names with standard convension, please use CPU3_BLK8_RABR.
*/


/** \brief FB74, CPUx Overlay Target Address Register 8 */

/** Alias (User Manual Name) for CPU3_BLK8_OTAR.
* To use register names with standard convension, please use CPU3_BLK8_OTAR.
*/


/** \brief FB78, CPUx Overlay Mask Register 8 */

/** Alias (User Manual Name) for CPU3_BLK8_OMASK.
* To use register names with standard convension, please use CPU3_BLK8_OMASK.
*/


/** \brief FB7C, CPUx Redirected Address Base Register 9 */

/** Alias (User Manual Name) for CPU3_BLK9_RABR.
* To use register names with standard convension, please use CPU3_BLK9_RABR.
*/


/** \brief FB80, CPUx Overlay Target Address Register 9 */

/** Alias (User Manual Name) for CPU3_BLK9_OTAR.
* To use register names with standard convension, please use CPU3_BLK9_OTAR.
*/


/** \brief FB84, CPUx Overlay Mask Register 9 */

/** Alias (User Manual Name) for CPU3_BLK9_OMASK.
* To use register names with standard convension, please use CPU3_BLK9_OMASK.
*/


/** \brief FB88, CPUx Redirected Address Base Register 10 */

/** Alias (User Manual Name) for CPU3_BLK10_RABR.
* To use register names with standard convension, please use CPU3_BLK10_RABR.
*/


/** \brief FB8C, CPUx Overlay Target Address Register 10 */

/** Alias (User Manual Name) for CPU3_BLK10_OTAR.
* To use register names with standard convension, please use CPU3_BLK10_OTAR.
*/


/** \brief FB90, CPUx Overlay Mask Register 10 */

/** Alias (User Manual Name) for CPU3_BLK10_OMASK.
* To use register names with standard convension, please use CPU3_BLK10_OMASK.
*/


/** \brief FB94, CPUx Redirected Address Base Register 11 */

/** Alias (User Manual Name) for CPU3_BLK11_RABR.
* To use register names with standard convension, please use CPU3_BLK11_RABR.
*/


/** \brief FB98, CPUx Overlay Target Address Register 11 */

/** Alias (User Manual Name) for CPU3_BLK11_OTAR.
* To use register names with standard convension, please use CPU3_BLK11_OTAR.
*/


/** \brief FB9C, CPUx Overlay Mask Register 11 */

/** Alias (User Manual Name) for CPU3_BLK11_OMASK.
* To use register names with standard convension, please use CPU3_BLK11_OMASK.
*/


/** \brief FBA0, CPUx Redirected Address Base Register 12 */

/** Alias (User Manual Name) for CPU3_BLK12_RABR.
* To use register names with standard convension, please use CPU3_BLK12_RABR.
*/


/** \brief FBA4, CPUx Overlay Target Address Register 12 */

/** Alias (User Manual Name) for CPU3_BLK12_OTAR.
* To use register names with standard convension, please use CPU3_BLK12_OTAR.
*/


/** \brief FBA8, CPUx Overlay Mask Register 12 */

/** Alias (User Manual Name) for CPU3_BLK12_OMASK.
* To use register names with standard convension, please use CPU3_BLK12_OMASK.
*/


/** \brief FBAC, CPUx Redirected Address Base Register 13 */

/** Alias (User Manual Name) for CPU3_BLK13_RABR.
* To use register names with standard convension, please use CPU3_BLK13_RABR.
*/


/** \brief FBB0, CPUx Overlay Target Address Register 13 */

/** Alias (User Manual Name) for CPU3_BLK13_OTAR.
* To use register names with standard convension, please use CPU3_BLK13_OTAR.
*/


/** \brief FBB4, CPUx Overlay Mask Register 13 */

/** Alias (User Manual Name) for CPU3_BLK13_OMASK.
* To use register names with standard convension, please use CPU3_BLK13_OMASK.
*/


/** \brief FBB8, CPUx Redirected Address Base Register 14 */

/** Alias (User Manual Name) for CPU3_BLK14_RABR.
* To use register names with standard convension, please use CPU3_BLK14_RABR.
*/


/** \brief FBBC, CPUx Overlay Target Address Register 14 */

/** Alias (User Manual Name) for CPU3_BLK14_OTAR.
* To use register names with standard convension, please use CPU3_BLK14_OTAR.
*/


/** \brief FBC0, CPUx Overlay Mask Register 14 */

/** Alias (User Manual Name) for CPU3_BLK14_OMASK.
* To use register names with standard convension, please use CPU3_BLK14_OMASK.
*/


/** \brief FBC4, CPUx Redirected Address Base Register 15 */

/** Alias (User Manual Name) for CPU3_BLK15_RABR.
* To use register names with standard convension, please use CPU3_BLK15_RABR.
*/


/** \brief FBC8, CPUx Overlay Target Address Register 15 */

/** Alias (User Manual Name) for CPU3_BLK15_OTAR.
* To use register names with standard convension, please use CPU3_BLK15_OTAR.
*/


/** \brief FBCC, CPUx Overlay Mask Register 15 */

/** Alias (User Manual Name) for CPU3_BLK15_OMASK.
* To use register names with standard convension, please use CPU3_BLK15_OMASK.
*/


/** \brief FBD0, CPUx Redirected Address Base Register 16 */

/** Alias (User Manual Name) for CPU3_BLK16_RABR.
* To use register names with standard convension, please use CPU3_BLK16_RABR.
*/


/** \brief FBD4, CPUx Overlay Target Address Register 16 */

/** Alias (User Manual Name) for CPU3_BLK16_OTAR.
* To use register names with standard convension, please use CPU3_BLK16_OTAR.
*/


/** \brief FBD8, CPUx Overlay Mask Register 16 */

/** Alias (User Manual Name) for CPU3_BLK16_OMASK.
* To use register names with standard convension, please use CPU3_BLK16_OMASK.
*/


/** \brief FBDC, CPUx Redirected Address Base Register 17 */

/** Alias (User Manual Name) for CPU3_BLK17_RABR.
* To use register names with standard convension, please use CPU3_BLK17_RABR.
*/


/** \brief FBE0, CPUx Overlay Target Address Register 17 */

/** Alias (User Manual Name) for CPU3_BLK17_OTAR.
* To use register names with standard convension, please use CPU3_BLK17_OTAR.
*/


/** \brief FBE4, CPUx Overlay Mask Register 17 */

/** Alias (User Manual Name) for CPU3_BLK17_OMASK.
* To use register names with standard convension, please use CPU3_BLK17_OMASK.
*/


/** \brief FBE8, CPUx Redirected Address Base Register 18 */

/** Alias (User Manual Name) for CPU3_BLK18_RABR.
* To use register names with standard convension, please use CPU3_BLK18_RABR.
*/


/** \brief FBEC, CPUx Overlay Target Address Register 18 */

/** Alias (User Manual Name) for CPU3_BLK18_OTAR.
* To use register names with standard convension, please use CPU3_BLK18_OTAR.
*/


/** \brief FBF0, CPUx Overlay Mask Register 18 */

/** Alias (User Manual Name) for CPU3_BLK18_OMASK.
* To use register names with standard convension, please use CPU3_BLK18_OMASK.
*/


/** \brief FBF4, CPUx Redirected Address Base Register 19 */

/** Alias (User Manual Name) for CPU3_BLK19_RABR.
* To use register names with standard convension, please use CPU3_BLK19_RABR.
*/


/** \brief FBF8, CPUx Overlay Target Address Register 19 */

/** Alias (User Manual Name) for CPU3_BLK19_OTAR.
* To use register names with standard convension, please use CPU3_BLK19_OTAR.
*/


/** \brief FBFC, CPUx Overlay Mask Register 19 */

/** Alias (User Manual Name) for CPU3_BLK19_OMASK.
* To use register names with standard convension, please use CPU3_BLK19_OMASK.
*/


/** \brief FC00, CPUx Redirected Address Base Register 20 */

/** Alias (User Manual Name) for CPU3_BLK20_RABR.
* To use register names with standard convension, please use CPU3_BLK20_RABR.
*/


/** \brief FC04, CPUx Overlay Target Address Register 20 */

/** Alias (User Manual Name) for CPU3_BLK20_OTAR.
* To use register names with standard convension, please use CPU3_BLK20_OTAR.
*/


/** \brief FC08, CPUx Overlay Mask Register 20 */

/** Alias (User Manual Name) for CPU3_BLK20_OMASK.
* To use register names with standard convension, please use CPU3_BLK20_OMASK.
*/


/** \brief FC0C, CPUx Redirected Address Base Register 21 */

/** Alias (User Manual Name) for CPU3_BLK21_RABR.
* To use register names with standard convension, please use CPU3_BLK21_RABR.
*/


/** \brief FC10, CPUx Overlay Target Address Register 21 */

/** Alias (User Manual Name) for CPU3_BLK21_OTAR.
* To use register names with standard convension, please use CPU3_BLK21_OTAR.
*/


/** \brief FC14, CPUx Overlay Mask Register 21 */

/** Alias (User Manual Name) for CPU3_BLK21_OMASK.
* To use register names with standard convension, please use CPU3_BLK21_OMASK.
*/


/** \brief FC18, CPUx Redirected Address Base Register 22 */

/** Alias (User Manual Name) for CPU3_BLK22_RABR.
* To use register names with standard convension, please use CPU3_BLK22_RABR.
*/


/** \brief FC1C, CPUx Overlay Target Address Register 22 */

/** Alias (User Manual Name) for CPU3_BLK22_OTAR.
* To use register names with standard convension, please use CPU3_BLK22_OTAR.
*/


/** \brief FC20, CPUx Overlay Mask Register 22 */

/** Alias (User Manual Name) for CPU3_BLK22_OMASK.
* To use register names with standard convension, please use CPU3_BLK22_OMASK.
*/


/** \brief FC24, CPUx Redirected Address Base Register 23 */

/** Alias (User Manual Name) for CPU3_BLK23_RABR.
* To use register names with standard convension, please use CPU3_BLK23_RABR.
*/


/** \brief FC28, CPUx Overlay Target Address Register 23 */

/** Alias (User Manual Name) for CPU3_BLK23_OTAR.
* To use register names with standard convension, please use CPU3_BLK23_OTAR.
*/


/** \brief FC2C, CPUx Overlay Mask Register 23 */

/** Alias (User Manual Name) for CPU3_BLK23_OMASK.
* To use register names with standard convension, please use CPU3_BLK23_OMASK.
*/


/** \brief FC30, CPUx Redirected Address Base Register 24 */

/** Alias (User Manual Name) for CPU3_BLK24_RABR.
* To use register names with standard convension, please use CPU3_BLK24_RABR.
*/


/** \brief FC34, CPUx Overlay Target Address Register 24 */

/** Alias (User Manual Name) for CPU3_BLK24_OTAR.
* To use register names with standard convension, please use CPU3_BLK24_OTAR.
*/


/** \brief FC38, CPUx Overlay Mask Register 24 */

/** Alias (User Manual Name) for CPU3_BLK24_OMASK.
* To use register names with standard convension, please use CPU3_BLK24_OMASK.
*/


/** \brief FC3C, CPUx Redirected Address Base Register 25 */

/** Alias (User Manual Name) for CPU3_BLK25_RABR.
* To use register names with standard convension, please use CPU3_BLK25_RABR.
*/


/** \brief FC40, CPUx Overlay Target Address Register 25 */

/** Alias (User Manual Name) for CPU3_BLK25_OTAR.
* To use register names with standard convension, please use CPU3_BLK25_OTAR.
*/


/** \brief FC44, CPUx Overlay Mask Register 25 */

/** Alias (User Manual Name) for CPU3_BLK25_OMASK.
* To use register names with standard convension, please use CPU3_BLK25_OMASK.
*/


/** \brief FC48, CPUx Redirected Address Base Register 26 */

/** Alias (User Manual Name) for CPU3_BLK26_RABR.
* To use register names with standard convension, please use CPU3_BLK26_RABR.
*/


/** \brief FC4C, CPUx Overlay Target Address Register 26 */

/** Alias (User Manual Name) for CPU3_BLK26_OTAR.
* To use register names with standard convension, please use CPU3_BLK26_OTAR.
*/


/** \brief FC50, CPUx Overlay Mask Register 26 */

/** Alias (User Manual Name) for CPU3_BLK26_OMASK.
* To use register names with standard convension, please use CPU3_BLK26_OMASK.
*/


/** \brief FC54, CPUx Redirected Address Base Register 27 */

/** Alias (User Manual Name) for CPU3_BLK27_RABR.
* To use register names with standard convension, please use CPU3_BLK27_RABR.
*/


/** \brief FC58, CPUx Overlay Target Address Register 27 */

/** Alias (User Manual Name) for CPU3_BLK27_OTAR.
* To use register names with standard convension, please use CPU3_BLK27_OTAR.
*/


/** \brief FC5C, CPUx Overlay Mask Register 27 */

/** Alias (User Manual Name) for CPU3_BLK27_OMASK.
* To use register names with standard convension, please use CPU3_BLK27_OMASK.
*/


/** \brief FC60, CPUx Redirected Address Base Register 28 */

/** Alias (User Manual Name) for CPU3_BLK28_RABR.
* To use register names with standard convension, please use CPU3_BLK28_RABR.
*/


/** \brief FC64, CPUx Overlay Target Address Register 28 */

/** Alias (User Manual Name) for CPU3_BLK28_OTAR.
* To use register names with standard convension, please use CPU3_BLK28_OTAR.
*/


/** \brief FC68, CPUx Overlay Mask Register 28 */

/** Alias (User Manual Name) for CPU3_BLK28_OMASK.
* To use register names with standard convension, please use CPU3_BLK28_OMASK.
*/


/** \brief FC6C, CPUx Redirected Address Base Register 29 */

/** Alias (User Manual Name) for CPU3_BLK29_RABR.
* To use register names with standard convension, please use CPU3_BLK29_RABR.
*/


/** \brief FC70, CPUx Overlay Target Address Register 29 */

/** Alias (User Manual Name) for CPU3_BLK29_OTAR.
* To use register names with standard convension, please use CPU3_BLK29_OTAR.
*/


/** \brief FC74, CPUx Overlay Mask Register 29 */

/** Alias (User Manual Name) for CPU3_BLK29_OMASK.
* To use register names with standard convension, please use CPU3_BLK29_OMASK.
*/


/** \brief FC78, CPUx Redirected Address Base Register 30 */

/** Alias (User Manual Name) for CPU3_BLK30_RABR.
* To use register names with standard convension, please use CPU3_BLK30_RABR.
*/


/** \brief FC7C, CPUx Overlay Target Address Register 30 */

/** Alias (User Manual Name) for CPU3_BLK30_OTAR.
* To use register names with standard convension, please use CPU3_BLK30_OTAR.
*/


/** \brief FC80, CPUx Overlay Mask Register 30 */

/** Alias (User Manual Name) for CPU3_BLK30_OMASK.
* To use register names with standard convension, please use CPU3_BLK30_OMASK.
*/


/** \brief FC84, CPUx Redirected Address Base Register 31 */

/** Alias (User Manual Name) for CPU3_BLK31_RABR.
* To use register names with standard convension, please use CPU3_BLK31_RABR.
*/


/** \brief FC88, CPUx Overlay Target Address Register 31 */

/** Alias (User Manual Name) for CPU3_BLK31_OTAR.
* To use register names with standard convension, please use CPU3_BLK31_OTAR.
*/


/** \brief FC8C, CPUx Overlay Mask Register 31 */

/** Alias (User Manual Name) for CPU3_BLK31_OMASK.
* To use register names with standard convension, please use CPU3_BLK31_OMASK.
*/


/** \brief 1030, CPUx SRI Error Generation Register */


/** \brief 8004, CPUx Task Address Space Identifier Register */


/** \brief 8100, CPUx Data Access CacheabilityRegister */


/** \brief 8104, CPUx Code Access CacheabilityRegister */


/** \brief 8108, CPUx  Peripheral Space Identifier register */


/** \brief 9000, CPUx Data Control Register 2 */


/** \brief 900C, CPUx SIST Mode Access Control Register */


/** \brief 9010, CPUx Data Synchronous Trap Register */


/** \brief 9018, CPUx Data Asynchronous Trap Register */


/** \brief 901C, CPUx Data Error Address Register */


/** \brief 9020, CPUx Data Integrity Error Address Register */


/** \brief 9024, CPUx Data Integrity Error Trap Register */


/** \brief 9040, CPUx Data Memory Control Register */


/** \brief 9200, CPUx Program Synchronous Trap Register */


/** \brief 9204, CPUx Program Control 1 */


/** \brief 9208, CPUx Program Control 2 */


/** \brief 920C, CPUx Program Control 0 */


/** \brief 9210, CPUx Program Integrity Error Address Register */


/** \brief 9214, CPUx Program Integrity Error Trap Register */


/** \brief 9400, CPUx Compatibility Control Register */


/** \brief A000, CPUx Trap Control Register */


/** \brief A004, CPUx Trapping Instruction Program Counter Register */


/** \brief A008, CPUx Trapping Instruction Opcode Register */


/** \brief A010, CPUx Trapping Instruction Operand Register */


/** \brief A014, CPUx Trapping Instruction Operand Register */


/** \brief A018, CPUx Trapping Instruction Operand Register */


/** \brief C000, CPUx Data Protection Range 0, Lower Bound Register */


/** \brief C004, CPUx Data Protection Range 0, Upper Bound Register */


/** \brief C008, CPUx Data Protection Range 1, Lower Bound Register */


/** \brief C00C, CPUx Data Protection Range 1, Upper Bound Register */


/** \brief C010, CPUx Data Protection Range 2, Lower Bound Register */


/** \brief C014, CPUx Data Protection Range 2, Upper Bound Register */


/** \brief C018, CPUx Data Protection Range 3, Lower Bound Register */


/** \brief C01C, CPUx Data Protection Range 3, Upper Bound Register */


/** \brief C020, CPUx Data Protection Range 4, Lower Bound Register */


/** \brief C024, CPUx Data Protection Range 4, Upper Bound Register */


/** \brief C028, CPUx Data Protection Range 5, Lower Bound Register */


/** \brief C02C, CPUx Data Protection Range 5, Upper Bound Register */


/** \brief C030, CPUx Data Protection Range 6, Lower Bound Register */


/** \brief C034, CPUx Data Protection Range 6, Upper Bound Register */


/** \brief C038, CPUx Data Protection Range 7, Lower Bound Register */


/** \brief C03C, CPUx Data Protection Range 7, Upper Bound Register */


/** \brief C040, CPUx Data Protection Range 8, Lower Bound Register */


/** \brief C044, CPUx Data Protection Range 8, Upper Bound Register */


/** \brief C048, CPUx Data Protection Range 9, Lower Bound Register */


/** \brief C04C, CPUx Data Protection Range 9, Upper Bound Register */


/** \brief C050, CPUx Data Protection Range 10, Lower Bound Register */


/** \brief C054, CPUx Data Protection Range 10, Upper Bound Register */


/** \brief C058, CPUx Data Protection Range 11, Lower Bound Register */


/** \brief C05C, CPUx Data Protection Range 11, Upper Bound Register */


/** \brief C060, CPUx Data Protection Range 12, Lower Bound Register */


/** \brief C064, CPUx Data Protection Range 12, Upper Bound Register */


/** \brief C068, CPUx Data Protection Range 13, Lower Bound Register */


/** \brief C06C, CPUx Data Protection Range 13, Upper Bound Register */


/** \brief C070, CPUx Data Protection Range 14, Lower Bound Register */


/** \brief C074, CPUx Data Protection Range 14, Upper Bound Register */


/** \brief C078, CPUx Data Protection Range 15, Lower Bound Register */


/** \brief C07C, CPUx Data Protection Range 15, Upper Bound Register */


/** \brief C080, CPUx Data Protection Range 16, Lower Bound Register */


/** \brief C084, CPUx Data Protection Range 16, Upper Bound Register */


/** \brief C088, CPUx Data Protection Range 17, Lower Bound Register */


/** \brief C08C, CPUx Data Protection Range 17, Upper Bound Register */


/** \brief D000, CPUx Code Protection Range 0 Lower Bound Register */


/** \brief D004, CPUx Code Protection Range 0 Upper Bound Register */


/** \brief D008, CPUx Code Protection Range 1 Lower Bound Register */


/** \brief D00C, CPUx Code Protection Range 1 Upper Bound Register */


/** \brief D010, CPUx Code Protection Range 2 Lower Bound Register */


/** \brief D014, CPUx Code Protection Range 2 Upper Bound Register */


/** \brief D018, CPUx Code Protection Range 3 Lower Bound Register */


/** \brief D01C, CPUx Code Protection Range 3 Upper Bound Register */


/** \brief D020, CPUx Code Protection Range 4 Lower Bound Register */


/** \brief D024, CPUx Code Protection Range 4 Upper Bound Register */


/** \brief D028, CPUx Code Protection Range 5 Lower Bound Register */


/** \brief D02C, CPUx Code Protection Range 5 Upper Bound Register */


/** \brief D030, CPUx Code Protection Range 6 Lower Bound Register */


/** \brief D034, CPUx Code Protection Range 6 Upper Bound Register */


/** \brief D038, CPUx Code Protection Range 7 Lower Bound Register */


/** \brief D03C, CPUx Code Protection Range 7 Upper Bound Register */


/** \brief D040, CPUx Code Protection Range 8 Lower Bound Register */


/** \brief D044, CPUx Code Protection Range 8 Upper Bound Register */


/** \brief D048, CPUx Code Protection Range 9 Lower Bound Register */


/** \brief D04C, CPUx Code Protection Range 9 Upper Bound Register */


/** \brief E000, CPUx Code Protection Execute Enable Register Set 0 */


/** \brief E004, CPUx Code Protection Execute Enable Register Set 1 */


/** \brief E008, CPUx Code Protection Execute Enable Register Set 2 */


/** \brief E00C, CPUx Code Protection Execute Enable Register Set 3 */


/** \brief E010, CPUx Data Protection Read Enable Register Set 0 */


/** \brief E014, CPUx Data Protection Read Enable Register Set 1 */


/** \brief E018, CPUx Data Protection Read Enable Register Set 2 */


/** \brief E01C, CPUx Data Protection Read Enable Register Set 3 */


/** \brief E020, CPUx Data Protection Write Enable Register Set 0 */


/** \brief E024, CPUx Data Protection Write Enable Register Set 1 */


/** \brief E028, CPUx Data Protection Write Enable Register Set 2 */


/** \brief E02C, CPUx Data Protection Write Enable Register Set 3 */


/** \brief E040, CPUx Code Protection Execute Enable Register Set 4 */


/** \brief E044, CPUx Code Protection Execute Enable Register Set 5 */


/** \brief E050, CPUx Data Protection Read Enable Register Set 4 */


/** \brief E054, CPUx Data Protection Read Enable Register Set 5 */


/** \brief E060, CPUx Data Protection Write Enable Register Set 4 */


/** \brief E064, CPUx Data Protection Write Enable Register Set 5 */


/** \brief E400, CPUx Temporal Protection System Control Register */


/** \brief E404, CPUx Temporal Protection System Timer Register 0 */


/** \brief E408, CPUx Temporal Protection System Timer Register 1 */


/** \brief E40C, CPUx Temporal Protection System Timer Register 2 */


/** \brief E440, CPUx Exception Entry Timer Load Value */


/** \brief E444, CPUx Exception Entry Timer Current Value */


/** \brief E448, CPUx Exception Exit  Timer Load Value */


/** \brief E44C, CPUx Exception Exit Timer Current Value */


/** \brief E450, CPUx Exception Timer Class Enable Register */


/** \brief E454, CPUx Exception Timer Status Register */


/** \brief E458, CPUx Exception Timer FCX Register */


/** \brief F000, CPUx Trigger Event 0 */

/** Alias (User Manual Name) for CPU3_TR0_EVT.
* To use register names with standard convension, please use CPU3_TR0_EVT.
*/


/** \brief F004, CPUx Trigger Address 0 */

/** Alias (User Manual Name) for CPU3_TR0_ADR.
* To use register names with standard convension, please use CPU3_TR0_ADR.
*/


/** \brief F008, CPUx Trigger Event 1 */

/** Alias (User Manual Name) for CPU3_TR1_EVT.
* To use register names with standard convension, please use CPU3_TR1_EVT.
*/


/** \brief F00C, CPUx Trigger Address 1 */

/** Alias (User Manual Name) for CPU3_TR1_ADR.
* To use register names with standard convension, please use CPU3_TR1_ADR.
*/


/** \brief F010, CPUx Trigger Event 2 */

/** Alias (User Manual Name) for CPU3_TR2_EVT.
* To use register names with standard convension, please use CPU3_TR2_EVT.
*/


/** \brief F014, CPUx Trigger Address 2 */

/** Alias (User Manual Name) for CPU3_TR2_ADR.
* To use register names with standard convension, please use CPU3_TR2_ADR.
*/


/** \brief F018, CPUx Trigger Event 3 */

/** Alias (User Manual Name) for CPU3_TR3_EVT.
* To use register names with standard convension, please use CPU3_TR3_EVT.
*/


/** \brief F01C, CPUx Trigger Address 3 */

/** Alias (User Manual Name) for CPU3_TR3_ADR.
* To use register names with standard convension, please use CPU3_TR3_ADR.
*/


/** \brief F020, CPUx Trigger Event 4 */

/** Alias (User Manual Name) for CPU3_TR4_EVT.
* To use register names with standard convension, please use CPU3_TR4_EVT.
*/


/** \brief F024, CPUx Trigger Address 4 */

/** Alias (User Manual Name) for CPU3_TR4_ADR.
* To use register names with standard convension, please use CPU3_TR4_ADR.
*/


/** \brief F028, CPUx Trigger Event 5 */

/** Alias (User Manual Name) for CPU3_TR5_EVT.
* To use register names with standard convension, please use CPU3_TR5_EVT.
*/


/** \brief F02C, CPUx Trigger Address 5 */

/** Alias (User Manual Name) for CPU3_TR5_ADR.
* To use register names with standard convension, please use CPU3_TR5_ADR.
*/


/** \brief F030, CPUx Trigger Event 6 */

/** Alias (User Manual Name) for CPU3_TR6_EVT.
* To use register names with standard convension, please use CPU3_TR6_EVT.
*/


/** \brief F034, CPUx Trigger Address 6 */

/** Alias (User Manual Name) for CPU3_TR6_ADR.
* To use register names with standard convension, please use CPU3_TR6_ADR.
*/


/** \brief F038, CPUx Trigger Event 7 */

/** Alias (User Manual Name) for CPU3_TR7_EVT.
* To use register names with standard convension, please use CPU3_TR7_EVT.
*/


/** \brief F03C, CPUx Trigger Address 7 */

/** Alias (User Manual Name) for CPU3_TR7_ADR.
* To use register names with standard convension, please use CPU3_TR7_ADR.
*/


/** \brief FC00, CPUx Counter Control */


/** \brief FC04, CPUx CPU Clock Cycle Count */


/** \brief FC08, CPUx Instruction Count */


/** \brief FC0C, CPUx Multi-Count Register 1 */


/** \brief FC10, CPUx Multi-Count Register 2 */


/** \brief FC14, CPUx Multi-Count Register 3 */


/** \brief FD00, CPUx Debug Status Register */


/** \brief FD08, CPUx External Event Register */


/** \brief FD0C, CPUx Core Register Access Event */


/** \brief FD10, CPUx Software Debug Event */


/** \brief FD30, CPUx TriggerAddressx */


/** \brief FD40, CPUx Debug Monitor Start Address */


/** \brief FD44, CPUx Debug Context Save Area Pointer */


/** \brief FD48, CPUx Debug Trap Control Register */


/** \brief FE00, CPUx Previous Context Information Register */


/** \brief FE04, CPUx Program Status Word */


/** \brief FE08, CPUx Program Counter */


/** \brief FE14, CPUx System Configuration Register */


/** \brief FE18, CPUx Identification Register TC1.6.2P */


/** \brief FE1C, CPUx Core Identification Register */


/** \brief FE20, CPUx Base Interrupt Vector Table Pointer */


/** \brief FE24, CPUx Base Trap Vector Table Pointer */


/** \brief FE28, CPUx Interrupt Stack Pointer */


/** \brief FE2C, CPUx Interrupt Control Register */


/** \brief FE38, CPUx Free CSA List Head Pointer */


/** \brief FE3C, CPUx Free CSA List Limit Pointer */


/** \brief FE50, CPUx Customer ID register */


/** \brief FF00, CPUx Data General Purpose Register 0 */


/** \brief FF04, CPUx Data General Purpose Register 1 */


/** \brief FF08, CPUx Data General Purpose Register 2 */


/** \brief FF0C, CPUx Data General Purpose Register 3 */


/** \brief FF10, CPUx Data General Purpose Register 4 */


/** \brief FF14, CPUx Data General Purpose Register 5 */


/** \brief FF18, CPUx Data General Purpose Register 6 */


/** \brief FF1C, CPUx Data General Purpose Register 7 */


/** \brief FF20, CPUx Data General Purpose Register 8 */


/** \brief FF24, CPUx Data General Purpose Register 9 */


/** \brief FF28, CPUx Data General Purpose Register 10 */


/** \brief FF2C, CPUx Data General Purpose Register 11 */


/** \brief FF30, CPUx Data General Purpose Register 12 */


/** \brief FF34, CPUx Data General Purpose Register 13 */


/** \brief FF38, CPUx Data General Purpose Register 14 */


/** \brief FF3C, CPUx Data General Purpose Register 15 */


/** \brief FF80, CPUx Address General Purpose Register 0 */


/** \brief FF84, CPUx Address General Purpose Register 1 */


/** \brief FF88, CPUx Address General Purpose Register 2 */


/** \brief FF8C, CPUx Address General Purpose Register 3 */


/** \brief FF90, CPUx Address General Purpose Register 4 */


/** \brief FF94, CPUx Address General Purpose Register 5 */


/** \brief FF98, CPUx Address General Purpose Register 6 */


/** \brief FF9C, CPUx Address General Purpose Register 7 */


/** \brief FFA0, CPUx Address General Purpose Register 8 */


/** \brief FFA4, CPUx Address General Purpose Register 9 */


/** \brief FFA8, CPUx Address General Purpose Register 10 */


/** \brief FFAC, CPUx Address General Purpose Register 11 */


/** \brief FFB0, CPUx Address General Purpose Register 12 */


/** \brief FFB4, CPUx Address General Purpose Register 13 */


/** \brief FFB8, CPUx Address General Purpose Register 14 */


/** \brief FFBC, CPUx Address General Purpose Register 15 */



/** \}  */

/******************************************************************************/

/******************************************************************************/


#line 58 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\_Impl\\IfxCpu_cfg.h"

/******************************************************************************/
/*-----------------------------------Macros-----------------------------------*/
/******************************************************************************/

/** \brief CPU count
 */


/** \brief Segment number of cachable flash region
 */


/** \brief Segment number of cachable LMU region
 */


/** \brief All cores (coreIDs) mask. This macro can be defined by the user according to the number of core being enabled.
 * So that can be used for syncronisation among multiple cores. In case user didn't define this macro, by default this
 * mask will be generated for all the available cores of the device.
 * e.g:
 * 1. Check for synchronisation between core 0 and core 5
 * # define 0x41U
 * 2. Check for synchronisation between core 0 to core 5
 * # define 0x5FU
 *
 * Note:
 * Core id values read from CORE_ID register will be as shown below. The value
 * indicates the position of the bit needs to be set while building the macro.
 * Core 0: 0
 * Core 1: 1
 * Core 2: 2
 * Core 3: 3
 * Core 4: 4
 * Core 5: 6
 */




/** \brief
 */










/******************************************************************************/
/*-------------------------------Enumerations---------------------------------*/
/******************************************************************************/

/** \brief Halt status
 */
typedef enum
{
    IfxCpu_DBGST_HALT_run  = 0,
    IfxCpu_DBGST_HALT_halt = 1
} IfxCpu_DBGST_HALT;

/** \brief List of the available CPU ids
 */
typedef enum
{
    IfxCpu_Id_0 = 0,  /**< \brief CPU 0 */
    IfxCpu_Id_1 = 1,  /**< \brief CPU 1 */
    IfxCpu_Id_2 = 2,  /**< \brief CPU 2 */
    IfxCpu_Id_3 = 3,  /**< \brief CPU 3 */
    IfxCpu_Id_none    /**< \brief None of the CPU */
} IfxCpu_Id;

/** \brief List of the available CPU resources
 */
typedef enum
{
    IfxCpu_Index_0 = 0,  /**< \brief CPU 0 */
    IfxCpu_Index_1 = 1,  /**< \brief CPU 1 */
    IfxCpu_Index_2 = 2,  /**< \brief CPU 2 */
    IfxCpu_Index_3 = 3,  /**< \brief CPU 3 */
    IfxCpu_Index_none    /**< \brief None of the CPU */
} IfxCpu_Index;

/** \brief Power management status
 */
typedef enum
{
    IfxCpu_PMCSR_PMST_normalMode         = 1,
    IfxCpu_PMCSR_PMST_idleModeRequest    = 2,
    IfxCpu_PMCSR_PMST_idleMode           = 3,
    IfxCpu_PMCSR_PMST_sleepModeRequest   = 4,
    IfxCpu_PMCSR_PMST_standbyModeRequest = 6
} IfxCpu_PMCSR_PMST;

/** \brief List of the available CPU resources
 */
typedef enum
{
    IfxCpu_ResourceCpu_0    = IfxCpu_Index_0,    /**< \brief CPU 0 */
    IfxCpu_ResourceCpu_1    = IfxCpu_Index_1,    /**< \brief CPU 1 */
    IfxCpu_ResourceCpu_2    = IfxCpu_Index_2,    /**< \brief CPU 2 */
    IfxCpu_ResourceCpu_3    = IfxCpu_Index_3,    /**< \brief CPU 3 */
    IfxCpu_ResourceCpu_none = IfxCpu_Index_none  /**< \brief None of the CPU */
} IfxCpu_ResourceCpu;

/******************************************************************************/
/*-------------------Global Exported Variables/Constants----------------------*/
/******************************************************************************/

extern const IfxModule_IndexMap IfxCpu_cfg_indexMap[(4)];


#line 70 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Cpu\\Std\\IfxCpu.h"

#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\Infra\\Sfr\\TC38A\\_Reg\\IfxSrc_reg.h"
/**
 * \file IfxSrc_reg.h
 * \brief
 * \copyright Copyright (c) 2020 Infineon Technologies AG. All rights reserved.
 *
 *
 * Version: TC38XA_UM_V1.5.0
 * Specification: TC3xx User Manual V1.5.0
 * MAY BE CHANGED BY USER [yes/no]: No
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * \defgroup IfxSfr_Src_Registers_Cfg Src address
 * \ingroup IfxSfr_Src_Registers
 * 
 * \defgroup IfxSfr_Src_Registers_Cfg_BaseAddress Base address
 * \ingroup IfxSfr_Src_Registers_Cfg
 *
 * \defgroup IfxSfr_Src_Registers_Cfg_Src 2-SRC
 * \ingroup IfxSfr_Src_Registers_Cfg
 *
 *
 */


/******************************************************************************/

#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\Infra\\Sfr\\TC38A\\_Reg\\IfxSrc_regdef.h"
/**
 * \file IfxSrc_regdef.h
 * \brief
 * \copyright Copyright (c) 2020 Infineon Technologies AG. All rights reserved.
 *
 *
 * Version: TC38XA_UM_V1.5.0
 * Specification: TC3xx User Manual V1.5.0
 * MAY BE CHANGED BY USER [yes/no]: No
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * \defgroup IfxSfr_Src_Registers Src Registers
 * \ingroup IfxSfr
 * 
 * \defgroup IfxSfr_Src_Registers_Bitfields Bitfields
 * \ingroup IfxSfr_Src_Registers
 * 
 * \defgroup IfxSfr_Src_Registers_union Register unions
 * \ingroup IfxSfr_Src_Registers
 * 
 * \defgroup IfxSfr_Src_Registers_struct Memory map
 * \ingroup IfxSfr_Src_Registers
 */


/******************************************************************************/

/******************************************************************************/

/******************************************************************************/

/******************************************************************************/


/** \addtogroup IfxSfr_Src_Registers_Bitfields
 * \{  */
/** \brief  */
typedef struct _Ifx_SRC_SRCR_Bits
{
    Ifx_UReg_32Bit SRPN:8;            /**< \brief [7:0] Service Request Priority Number (rw) */
    Ifx_UReg_32Bit reserved_8:2;      /**< \brief [9:8] \internal Reserved */
    Ifx_UReg_32Bit SRE:1;             /**< \brief [10:10] Service Request Enable (rw) */
    Ifx_UReg_32Bit TOS:3;             /**< \brief [13:11] Type of Service Control (rw) */
    Ifx_UReg_32Bit reserved_14:2;     /**< \brief [15:14] \internal Reserved */
    Ifx_UReg_32Bit ECC:5;             /**< \brief [20:16] Error Correction Code (rwh) */
    Ifx_UReg_32Bit reserved_21:3;     /**< \brief [23:21] \internal Reserved */
    Ifx_UReg_32Bit SRR:1;             /**< \brief [24:24] Service Request Flag (rh) */
    Ifx_UReg_32Bit CLRR:1;            /**< \brief [25:25] Request Clear Bit (w) */
    Ifx_UReg_32Bit SETR:1;            /**< \brief [26:26] Request Set Bit (w) */
    Ifx_UReg_32Bit IOV:1;             /**< \brief [27:27] Interrupt Trigger Overflow Bit (rh) */
    Ifx_UReg_32Bit IOVCLR:1;          /**< \brief [28:28] Interrupt Trigger Overflow Clear Bit (w) */
    Ifx_UReg_32Bit SWS:1;             /**< \brief [29:29] SW Sticky Bit (rh) */
    Ifx_UReg_32Bit SWSCLR:1;          /**< \brief [30:30] SW Sticky Clear Bit (w) */
    Ifx_UReg_32Bit reserved_31:1;     /**< \brief [31:31] \internal Reserved */
} Ifx_SRC_SRCR_Bits;

/** \}  */
/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_src_Registers_union
 * \{   */
/** \brief    */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SRC_SRCR_Bits B;              /**< \brief Bitfield access */
} Ifx_SRC_SRCR;

/** \}  */

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_CPU_CPU_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief CPU object */
typedef volatile struct _Ifx_SRC_CPU_CPU
{
       Ifx_SRC_SRCR                        SB;                     /**< \brief 0, CPU${x} Software Breakpoint Service Request*/
} Ifx_SRC_CPU_CPU;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_CPU_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief CPU object */
typedef volatile struct _Ifx_SRC_CPU
{
       Ifx_SRC_CPU_CPU                     CPU[4];                 /**< \brief 0, CPU${x} Software Breakpoint Service Request*/
} Ifx_SRC_CPU;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_CERBERUS_CERBERUS_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief CERBERUS object */
typedef volatile struct _Ifx_SRC_CERBERUS_CERBERUS
{
       Ifx_SRC_SRCR                        SR[2];                  /**< \brief 0, Cerberus Service Request ${y}*/
} Ifx_SRC_CERBERUS_CERBERUS;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_CERBERUS_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief CERBERUS object */
typedef volatile struct _Ifx_SRC_CERBERUS
{
       Ifx_SRC_CERBERUS_CERBERUS           CERBERUS;               /**< \brief 0, */
} Ifx_SRC_CERBERUS;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_ASCLIN_ASCLIN_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief ASCLIN object */
typedef volatile struct _Ifx_SRC_ASCLIN_ASCLIN
{
       Ifx_SRC_SRCR                        TX;                     /**< \brief 0, ASCLIN${x} Transmit Service Request*/
       Ifx_SRC_SRCR                        RX;                     /**< \brief 4, ASCLIN${x} Receive Service Request*/
       Ifx_SRC_SRCR                        ERR;                    /**< \brief 8, ASCLIN${x} Error Service Request*/
} Ifx_SRC_ASCLIN_ASCLIN;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_ASCLIN_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief ASCLIN object */
typedef volatile struct _Ifx_SRC_ASCLIN
{
       Ifx_SRC_ASCLIN_ASCLIN               ASCLIN[12];             /**< \brief 0, ASCLIN${x} Error Service Request*/
} Ifx_SRC_ASCLIN;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_QSPI_QSPI_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief QSPI object */
typedef volatile struct _Ifx_SRC_QSPI_QSPI
{
       Ifx_SRC_SRCR                        TX;                     /**< \brief 0, QSPI${x} Transmit Service Request*/
       Ifx_SRC_SRCR                        RX;                     /**< \brief 4, QSPI${x} Receive Service Request*/
       Ifx_SRC_SRCR                        ERR;                    /**< \brief 8, QSPI${x} Error Service Request*/
       Ifx_SRC_SRCR                        PT;                     /**< \brief C, QSPI${x} Phase Transition Service Request*/
       Ifx_SRC_SRCR                        U;                      /**< \brief 10, QSPI${x} User Defined Service Request*/
} Ifx_SRC_QSPI_QSPI;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_QSPI_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief QSPI object */
typedef volatile struct _Ifx_SRC_QSPI
{
       Ifx_SRC_QSPI_QSPI                   QSPI[5];                /**< \brief 0, QSPI${x} User Defined Service Request*/
} Ifx_SRC_QSPI;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_HSCT_HSCT_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief HSCT object */
typedef volatile struct _Ifx_SRC_HSCT_HSCT
{
       Ifx_SRC_SRCR                        SR;                     /**< \brief 0, HSCT0 Service Request*/
} Ifx_SRC_HSCT_HSCT;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_HSCT_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief HSCT object */
typedef volatile struct _Ifx_SRC_HSCT
{
       Ifx_SRC_HSCT_HSCT                   HSCT[1];                /**< \brief 0, HSCT0 Service Request*/
} Ifx_SRC_HSCT;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_HSSL_HSSL_CH_struct
 * \{  */
/******************************************************************************/
/** \name Object L3
 * \{  */
/** \brief CH object */
typedef volatile struct _Ifx_SRC_HSSL_HSSL_CH
{
       Ifx_SRC_SRCR                        COK;                    /**< \brief 0, HSSL0 Channel ${y} OK Service Request*/
       Ifx_SRC_SRCR                        RDI;                    /**< \brief 4, HSSL0 Channel ${y} Read Data Service Request*/
       Ifx_SRC_SRCR                        ERR;                    /**< \brief 8, HSSL0 Channel ${y} Error Service Request*/
       Ifx_SRC_SRCR                        TRG;                    /**< \brief C, HSSL0 Channel ${y} Trigger Interrupt Service Request*/
} Ifx_SRC_HSSL_HSSL_CH;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_HSSL_HSSL_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief HSSL object */
typedef volatile struct _Ifx_SRC_HSSL_HSSL
{
       Ifx_SRC_HSSL_HSSL_CH                CH[4];                  /**< \brief 0, HSSL0 Channel ${y} Trigger Interrupt Service Request*/
       Ifx_SRC_SRCR                        EXI;                    /**< \brief 40, HSSL${x} Exception Service Request*/
} Ifx_SRC_HSSL_HSSL;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_HSSL_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief HSSL object */
typedef volatile struct _Ifx_SRC_HSSL
{
       Ifx_SRC_HSSL_HSSL                   HSSL[1];                /**< \brief 0, HSSL${x} Exception Service Request*/
} Ifx_SRC_HSSL;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_I2C_I2C_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief I2C object */
typedef volatile struct _Ifx_SRC_I2C_I2C
{
       Ifx_SRC_SRCR                        DTR;                    /**< \brief 0, I2C${x} Data Transfer Request*/
       Ifx_SRC_SRCR                        ERR;                    /**< \brief 4, I2C${x} Error Service Request*/
       Ifx_SRC_SRCR                        P;                      /**< \brief 8, I2C${x} Protocol Service Request*/
       Ifx_UReg_8Bit                       reserved_C[4];          /**< \brief C, \internal Reserved */
} Ifx_SRC_I2C_I2C;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_I2C_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief I2C object */
typedef volatile struct _Ifx_SRC_I2C
{
       Ifx_SRC_I2C_I2C                     I2C[2];                 /**< \brief 0, */
} Ifx_SRC_I2C;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_SENT_SENT_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief SENT object */
typedef volatile struct _Ifx_SRC_SENT_SENT
{
       Ifx_SRC_SRCR                        SR;                     /**< \brief 0, SENT TRIG${x} Service Request*/
} Ifx_SRC_SENT_SENT;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_SENT_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief SENT object */
typedef volatile struct _Ifx_SRC_SENT
{
       Ifx_SRC_SENT_SENT                   SENT[10];               /**< \brief 0, SENT TRIG${x} Service Request*/
} Ifx_SRC_SENT;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_MSC_MSC_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief MSC object */
typedef volatile struct _Ifx_SRC_MSC_MSC
{
       Ifx_SRC_SRCR                        SR[5];                  /**< \brief 0, MSC${x} Service Request ${y}*/
} Ifx_SRC_MSC_MSC;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_MSC_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief MSC object */
typedef volatile struct _Ifx_SRC_MSC
{
       Ifx_SRC_MSC_MSC                     MSC[3];                 /**< \brief 0, */
} Ifx_SRC_MSC;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_CCU6_CCU_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief CCU object */
typedef volatile struct _Ifx_SRC_CCU6_CCU
{
       Ifx_SRC_SRCR                        SR[4];                  /**< \brief 0, CCU${x} Service Request ${y}*/
} Ifx_SRC_CCU6_CCU;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_CCU6_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief CCU6 object */
typedef volatile struct _Ifx_SRC_CCU6
{
       Ifx_SRC_CCU6_CCU                    CCU[2];                 /**< \brief 0, */
} Ifx_SRC_CCU6;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_GPT12_GPT12_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief GPT12 object */
typedef volatile struct _Ifx_SRC_GPT12_GPT12
{
       Ifx_SRC_SRCR                        CIRQ;                   /**< \brief 0, GPT120 CAPREL Service Request*/
       Ifx_SRC_SRCR                        T2;                     /**< \brief 4, GPT120 Timer 2 Service Request*/
       Ifx_SRC_SRCR                        T3;                     /**< \brief 8, GPT120 Timer 3 Service Request*/
       Ifx_SRC_SRCR                        T4;                     /**< \brief C, GPT120 Timer 4 Service Request*/
       Ifx_SRC_SRCR                        T5;                     /**< \brief 10, GPT120 Timer 5 Service Request*/
       Ifx_SRC_SRCR                        T6;                     /**< \brief 14, GPT120 Timer 6 Service Request*/
} Ifx_SRC_GPT12_GPT12;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_GPT12_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief GPT12 object */
typedef volatile struct _Ifx_SRC_GPT12
{
       Ifx_SRC_GPT12_GPT12                 GPT12[1];               /**< \brief 0, GPT120 Timer 6 Service Request*/
} Ifx_SRC_GPT12;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_STM_STM_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief STM object */
typedef volatile struct _Ifx_SRC_STM_STM
{
       Ifx_SRC_SRCR                        SR[2];                  /**< \brief 0, System Timer ${x} Service Request ${y}*/
} Ifx_SRC_STM_STM;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_STM_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief STM object */
typedef volatile struct _Ifx_SRC_STM
{
       Ifx_SRC_STM_STM                     STM[4];                 /**< \brief 0, */
} Ifx_SRC_STM;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_FCE_FCE0_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief FCE0 object */
typedef volatile struct _Ifx_SRC_FCE_FCE0
{
       Ifx_SRC_SRCR                        SR;                     /**< \brief 0, FCE0 Error Service Request*/
} Ifx_SRC_FCE_FCE0;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_FCE_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief FCE object */
typedef volatile struct _Ifx_SRC_FCE
{
       Ifx_SRC_FCE_FCE0                    FCE0;                   /**< \brief 0, FCE0 Error Service Request*/
} Ifx_SRC_FCE;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_DMA_DMA_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief DMA object */
typedef volatile struct _Ifx_SRC_DMA_DMA
{
       Ifx_SRC_SRCR                        ERR[4];                 /**< \brief 0, DMA Error Service Request ${y}*/
       Ifx_UReg_8Bit                       reserved_10[32];        /**< \brief 10, \internal Reserved */
       Ifx_SRC_SRCR                        CH[128];                /**< \brief 30, DMA Channel  ${y} Service Request*/
} Ifx_SRC_DMA_DMA;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_DMA_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief DMA object */
typedef volatile struct _Ifx_SRC_DMA
{
       Ifx_SRC_DMA_DMA                     DMA[1];                 /**< \brief 0, */
} Ifx_SRC_DMA;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_GETH_GETH_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief GETH object */
typedef volatile struct _Ifx_SRC_GETH_GETH
{
       Ifx_SRC_SRCR                        SR[10];                 /**< \brief 0, GETH Service Request ${y}*/
} Ifx_SRC_GETH_GETH;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_GETH_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief GETH object */
typedef volatile struct _Ifx_SRC_GETH
{
       Ifx_SRC_GETH_GETH                   GETH[1];                /**< \brief 0, */
} Ifx_SRC_GETH;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_CAN_CAN_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief CAN object */
typedef volatile struct _Ifx_SRC_CAN_CAN
{
       Ifx_SRC_SRCR                        INT[16];                /**< \brief 0, CAN${x} Service Request ${y}*/
} Ifx_SRC_CAN_CAN;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_CAN_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief CAN object */
typedef volatile struct _Ifx_SRC_CAN
{
       Ifx_SRC_CAN_CAN                     CAN[3];                 /**< \brief 0, */
} Ifx_SRC_CAN;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_VADC_G_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief G object */
typedef volatile struct _Ifx_SRC_VADC_G
{
       Ifx_SRC_SRCR                        SR0;                    /**< \brief 0, EVADC Group ${x} Service Request ${y}*/
       Ifx_SRC_SRCR                        SR1;                    /**< \brief 4, EVADC Group ${x} Service Request ${y}*/
       Ifx_SRC_SRCR                        SR2;                    /**< \brief 8, EVADC Group ${x} Service Request ${y}*/
       Ifx_SRC_SRCR                        SR3;                    /**< \brief C, EVADC Group ${x} Service Request ${y}*/
} Ifx_SRC_VADC_G;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_VADC_FC_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief FC object */
typedef volatile struct _Ifx_SRC_VADC_FC
{
       Ifx_SRC_SRCR                        SR0;                    /**< \brief 0, EVADC Fast Compare ${x} Service Request SR0*/
} Ifx_SRC_VADC_FC;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/


/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_VADC_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief VADC object */
typedef volatile struct _Ifx_SRC_VADC
{
       Ifx_SRC_VADC_G                      G[12];                  /**< \brief 0, */
       Ifx_SRC_VADC_FC                     FC[4];                  /**< \brief C0, EVADC Fast Compare ${x} Service Request SR0*/
       Ifx_UReg_8Bit                       reserved_D0[16];        /**< \brief D0, \internal Reserved */
       Ifx_SRC_VADC_G                      CG[2];                  /**< \brief E0, */
} Ifx_SRC_VADC;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_DSADC_DSADC_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief DSADC object */
typedef volatile struct _Ifx_SRC_DSADC_DSADC
{
       Ifx_SRC_SRCR                        SRM;                    /**< \brief 0, DSADC SRM${x} Service Request*/
       Ifx_SRC_SRCR                        SRA;                    /**< \brief 4, DSADC SRA${x} Service Request*/
} Ifx_SRC_DSADC_DSADC;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_DSADC_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief DSADC object */
typedef volatile struct _Ifx_SRC_DSADC
{
       Ifx_SRC_DSADC_DSADC                 DSADC[10];              /**< \brief 0, DSADC SRA${x} Service Request*/
} Ifx_SRC_DSADC;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/



/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_ERAY_ERAY_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief ERAY object */
typedef volatile struct _Ifx_SRC_ERAY_ERAY
{
       Ifx_SRC_SRCR                        INT0;                   /**< \brief 0, E-RAY ${x} Service Request 0*/
       Ifx_SRC_SRCR                        INT1;                   /**< \brief 4, E-RAY ${x} Service Request 1*/
       Ifx_SRC_SRCR                        TINT0;                  /**< \brief 8, E-RAY ${x} Timer Interrupt 0 Service Request*/
       Ifx_SRC_SRCR                        TINT1;                  /**< \brief C, E-RAY ${x} Timer Interrupt 1 Service Request*/
       Ifx_SRC_SRCR                        NDAT0;                  /**< \brief 10, E-RAY ${x} New Data 0 Service Request*/
       Ifx_SRC_SRCR                        NDAT1;                  /**< \brief 14, E-RAY ${x} New Data 1 Service Request*/
       Ifx_SRC_SRCR                        MBSC0;                  /**< \brief 18, E-RAY ${x} Message Buffer Status Changed 0 Service Request*/
       Ifx_SRC_SRCR                        MBSC1;                  /**< \brief 1C, E-RAY ${x} Message Buffer Status Changed 1 Service Request*/
       Ifx_SRC_SRCR                        OBUSY;                  /**< \brief 20, E-RAY ${x} Output Buffer Busy*/
       Ifx_SRC_SRCR                        IBUSY;                  /**< \brief 24, E-RAY ${x} Input Buffer Busy*/
       Ifx_UReg_8Bit                       reserved_28[8];         /**< \brief 28, \internal Reserved */
} Ifx_SRC_ERAY_ERAY;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_ERAY_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief ERAY object */
typedef volatile struct _Ifx_SRC_ERAY
{
       Ifx_SRC_ERAY_ERAY                   ERAY[2];                /**< \brief 0, */
} Ifx_SRC_ERAY;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_HSM_HSM_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief HSM object */
typedef volatile struct _Ifx_SRC_HSM_HSM
{
       Ifx_SRC_SRCR                        HSM[2];                 /**< \brief 0, HSM Service Request ${y}*/
} Ifx_SRC_HSM_HSM;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_HSM_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief HSM object */
typedef volatile struct _Ifx_SRC_HSM
{
       Ifx_SRC_HSM_HSM                     HSM[1];                 /**< \brief 0, */
} Ifx_SRC_HSM;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_SCU_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief SCU object */
typedef volatile struct _Ifx_SRC_SCU
{
       Ifx_SRC_SRCR                        SCUERU[4];              /**< \brief 0, SCU ERU Service Request ${x}*/
} Ifx_SRC_SCU;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_PMS_PMS_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief PMS object */
typedef volatile struct _Ifx_SRC_PMS_PMS
{
       Ifx_SRC_SRCR                        SR;                     /**< \brief 0, Power Management System Service Request ${x}*/
} Ifx_SRC_PMS_PMS;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_PMS_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief PMS object */
typedef volatile struct _Ifx_SRC_PMS
{
       Ifx_SRC_PMS_PMS                     PMS[4];                 /**< \brief 0, Power Management System Service Request ${x}*/
} Ifx_SRC_PMS;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_SMU_SMU_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief SMU object */
typedef volatile struct _Ifx_SRC_SMU_SMU
{
       Ifx_SRC_SRCR                        SR[3];                  /**< \brief 0, SMU Service Request ${y}*/
} Ifx_SRC_SMU_SMU;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_SMU_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief SMU object */
typedef volatile struct _Ifx_SRC_SMU
{
       Ifx_SRC_SMU_SMU                     SMU[1];                 /**< \brief 0, */
} Ifx_SRC_SMU;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_PSI5_PSI5_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief PSI5 object */
typedef volatile struct _Ifx_SRC_PSI5_PSI5
{
       Ifx_SRC_SRCR                        SR[8];                  /**< \brief 0, PSI5 Service Request ${y}*/
} Ifx_SRC_PSI5_PSI5;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_PSI5_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief PSI5 object */
typedef volatile struct _Ifx_SRC_PSI5
{
       Ifx_SRC_PSI5_PSI5                   PSI5[1];                /**< \brief 0, */
} Ifx_SRC_PSI5;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_DAM_DAM_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief DAM object */
typedef volatile struct _Ifx_SRC_DAM_DAM
{
       Ifx_SRC_SRCR                        LI0;                    /**< \brief 0, DAM${x} Limit 0 Service Request*/
       Ifx_SRC_SRCR                        RI0;                    /**< \brief 4, DAM${x} Ready 0 Service Reques*/
       Ifx_SRC_SRCR                        LI1;                    /**< \brief 8, DAM${x} Limit 1 Service Request*/
       Ifx_SRC_SRCR                        RI1;                    /**< \brief C, DAM${x} Ready 1 Service Request*/
       Ifx_SRC_SRCR                        DR;                     /**< \brief 10, DAM${x} DMA Ready Service Request*/
       Ifx_SRC_SRCR                        ERR;                    /**< \brief 14, DAM${x} Error Service Request*/
} Ifx_SRC_DAM_DAM;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_DAM_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief DAM object */
typedef volatile struct _Ifx_SRC_DAM
{
       Ifx_SRC_DAM_DAM                     DAM[1];                 /**< \brief 0, */
} Ifx_SRC_DAM;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_PSI5S_PSI5S_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief PSI5S object */
typedef volatile struct _Ifx_SRC_PSI5S_PSI5S
{
       Ifx_SRC_SRCR                        SR[8];                  /**< \brief 0, PSI5-S Service Request ${y}*/
} Ifx_SRC_PSI5S_PSI5S;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_PSI5S_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief PSI5S object */
typedef volatile struct _Ifx_SRC_PSI5S
{
       Ifx_SRC_PSI5S_PSI5S                 PSI5S[1];               /**< \brief 0, */
} Ifx_SRC_PSI5S;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_GPSR_GPSR_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief GPSR object */
typedef volatile struct _Ifx_SRC_GPSR_GPSR
{
       Ifx_SRC_SRCR                        SR[8];                  /**< \brief 0, General Purpose Group ${x} Service Request ${y}*/
} Ifx_SRC_GPSR_GPSR;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_GPSR_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief GPSR object */
typedef volatile struct _Ifx_SRC_GPSR
{
       Ifx_SRC_GPSR_GPSR                   GPSR[4];                /**< \brief 0, */
} Ifx_SRC_GPSR;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/











/******************************************************************************/
/** \addtogroup IfxSfr_Src_Registers_struct
 * \{  */
/******************************************************************************/
/** \name Object L0
 * \{  */

/** \brief SRC object */
typedef volatile struct _Ifx_SRC
{
       Ifx_SRC_CPU                         CPU;                    /**< \brief 0, */
       Ifx_UReg_8Bit                       reserved_10[16];        /**< \brief 10, \internal Reserved */
       Ifx_SRC_SRCR                        SBCU;                   /**< \brief 20, SBCU Service Request (SPB Bus Control Unit)*/
       Ifx_UReg_8Bit                       reserved_24[12];        /**< \brief 24, \internal Reserved */
       Ifx_SRC_SRCR                        XBAR0;                  /**< \brief 30, SRI Domain 0 Service Request*/
       Ifx_UReg_8Bit                       reserved_34[12];        /**< \brief 34, \internal Reserved */
       Ifx_SRC_CERBERUS                    CERBERUS;               /**< \brief 40, */
       Ifx_UReg_8Bit                       reserved_48[8];         /**< \brief 48, \internal Reserved */
       Ifx_SRC_ASCLIN                      ASCLIN;                 /**< \brief 50, */
       Ifx_UReg_8Bit                       reserved_E0[12];        /**< \brief E0, \internal Reserved */
       Ifx_SRC_SRCR                        MTUDONE;                /**< \brief EC, MTU Done Service Request*/
       Ifx_SRC_QSPI                        QSPI;                   /**< \brief F0, */
       Ifx_UReg_8Bit                       reserved_154[44];       /**< \brief 154, \internal Reserved */
       Ifx_SRC_HSCT                        HSCT;                   /**< \brief 180, */
       Ifx_UReg_8Bit                       reserved_184[12];       /**< \brief 184, \internal Reserved */
       Ifx_SRC_HSSL                        HSSL;                   /**< \brief 190, */
       Ifx_UReg_8Bit                       reserved_1D4[76];       /**< \brief 1D4, \internal Reserved */
       Ifx_SRC_I2C                         I2C;                    /**< \brief 220, */
       Ifx_SRC_SENT                        SENT;                   /**< \brief 240, */
       Ifx_UReg_8Bit                       reserved_268[8];        /**< \brief 268, \internal Reserved */
       Ifx_SRC_MSC                         MSC;                    /**< \brief 270, */
       Ifx_UReg_8Bit                       reserved_2AC[20];       /**< \brief 2AC, \internal Reserved */
       Ifx_SRC_CCU6                        CCU6;                   /**< \brief 2C0, */
       Ifx_SRC_GPT12                       GPT12;                  /**< \brief 2E0, */
       Ifx_UReg_8Bit                       reserved_2F8[8];        /**< \brief 2F8, \internal Reserved */
       Ifx_SRC_STM                         STM;                    /**< \brief 300, */
       Ifx_UReg_8Bit                       reserved_320[16];       /**< \brief 320, \internal Reserved */
       Ifx_SRC_FCE                         FCE;                    /**< \brief 330, */
       Ifx_UReg_8Bit                       reserved_334[12];       /**< \brief 334, \internal Reserved */
       Ifx_SRC_DMA                         DMA;                    /**< \brief 340, */
       Ifx_UReg_8Bit                       reserved_570[16];       /**< \brief 570, \internal Reserved */
       Ifx_SRC_GETH                        GETH;                   /**< \brief 580, */
       Ifx_UReg_8Bit                       reserved_5A8[8];        /**< \brief 5A8, \internal Reserved */
       Ifx_SRC_CAN                         CAN;                    /**< \brief 5B0, */
       Ifx_SRC_VADC                        VADC;                   /**< \brief 670, */
       Ifx_SRC_DSADC                       DSADC;                  /**< \brief 770, */
       Ifx_UReg_8Bit                       reserved_7C0[32];       /**< \brief 7C0, \internal Reserved */
       Ifx_SRC_ASCLIN_ASCLIN               ASCLIN12;               /**< \brief 7E0, ASCLIN12 Error Service Request*/
       Ifx_SRC_ASCLIN_ASCLIN               ASCLIN13;               /**< \brief 7EC, ASCLIN13 Error Service Request*/
       Ifx_UReg_8Bit                       reserved_7F8[8];        /**< \brief 7F8, \internal Reserved */
       Ifx_SRC_ERAY                        ERAY;                   /**< \brief 800, */
       Ifx_SRC_SRCR                        DMUHOST;                /**< \brief 860, DMU Host Service Request*/
       Ifx_SRC_SRCR                        DMUFSI;                 /**< \brief 864, DMU FSI Service Request*/
       Ifx_UReg_8Bit                       reserved_868[8];        /**< \brief 868, \internal Reserved */
       Ifx_SRC_HSM                         HSM;                    /**< \brief 870, */
       Ifx_UReg_8Bit                       reserved_878[8];        /**< \brief 878, \internal Reserved */
       Ifx_SRC_SCU                         SCU;                    /**< \brief 880, */
       Ifx_UReg_8Bit                       reserved_890[28];       /**< \brief 890, \internal Reserved */
       Ifx_SRC_SRCR                        PMSDTS;                 /**< \brief 8AC, PMS DTS Service Request*/
       Ifx_SRC_PMS                         PMS;                    /**< \brief 8B0, */
       Ifx_SRC_SRCR                        SCR;                    /**< \brief 8C0, Stand By Controller Service Request*/
       Ifx_UReg_8Bit                       reserved_8C4[12];       /**< \brief 8C4, \internal Reserved */
       Ifx_SRC_SMU                         SMU;                    /**< \brief 8D0, */
       Ifx_UReg_8Bit                       reserved_8DC[4];        /**< \brief 8DC, \internal Reserved */
       Ifx_SRC_PSI5                        PSI5;                   /**< \brief 8E0, */
       Ifx_UReg_8Bit                       reserved_900[16];       /**< \brief 900, \internal Reserved */
       Ifx_SRC_DAM                         DAM;                    /**< \brief 910, */
       Ifx_UReg_8Bit                       reserved_928[40];       /**< \brief 928, \internal Reserved */
       Ifx_SRC_PSI5S                       PSI5S;                  /**< \brief 950, */
       Ifx_UReg_8Bit                       reserved_970[32];       /**< \brief 970, \internal Reserved */
       Ifx_SRC_GPSR                        GPSR;                   /**< \brief 990, */
       Ifx_UReg_8Bit                       reserved_A10[64];       /**< \brief A10, \internal Reserved */
       Ifx_SRC_ASCLIN_ASCLIN               ASCLIN14;               /**< \brief A50, ASCLIN14 Error Service Request*/
       Ifx_SRC_ASCLIN_ASCLIN               ASCLIN15;               /**< \brief A5C, ASCLIN15 Error Service Request*/
       Ifx_UReg_8Bit                       reserved_A68[8];        /**< \brief A68, \internal Reserved */
       Ifx_SRC_SRCR                        GTM_AEIIRQ;             /**< \brief A70, AEI Shared Service Request*/
       Ifx_SRC_SRCR                        GTM_ARUIRQ[3];          /**< \brief A74, ARU Shared Service Request ${w}*/
       Ifx_SRC_SRCR                        GTM_BRCIRQ;             /**< \brief A80, BRC Shared Service Request*/
       Ifx_SRC_SRCR                        GTM_CMBIRQ;             /**< \brief A84, CMP Shared Service Request*/
       Ifx_SRC_SRCR                        GTM_SPEIRQ[4];          /**< \brief A88, SPE${w} Shared Service Request*/
       Ifx_UReg_8Bit                       reserved_A98[8];        /**< \brief A98, \internal Reserved */
       Ifx_SRC_SRCR                        GTM_PSM[2][8];          /**< \brief AA0, */
       Ifx_UReg_8Bit                       reserved_AE0[32];       /**< \brief AE0, \internal Reserved */
       Ifx_SRC_SRCR                        GTM_DPLL[27];           /**< \brief B00, DPLL Service Request ${w}*/
       Ifx_UReg_8Bit                       reserved_B6C[4];        /**< \brief B6C, \internal Reserved */
       Ifx_SRC_SRCR                        GTM_ERR;                /**< \brief B70, Error Service Request*/
       Ifx_UReg_8Bit                       reserved_B74[28];       /**< \brief B74, \internal Reserved */
       Ifx_SRC_SRCR                        GTM_TIM[7][8];          /**< \brief B90, */
       Ifx_UReg_8Bit                       reserved_C70[32];       /**< \brief C70, \internal Reserved */
       Ifx_SRC_ASCLIN_ASCLIN               ASCLIN16;               /**< \brief C90, ASCLIN16 Error Service Request*/
       Ifx_SRC_ASCLIN_ASCLIN               ASCLIN17;               /**< \brief C9C, ASCLIN17 Error Service Request*/
       Ifx_UReg_8Bit                       reserved_CA8[8];        /**< \brief CA8, \internal Reserved */
       Ifx_SRC_SRCR                        GTM_MCS[7][8];          /**< \brief CB0, */
       Ifx_UReg_8Bit                       reserved_D90[96];       /**< \brief D90, \internal Reserved */
       Ifx_SRC_ASCLIN_ASCLIN               ASCLIN18;               /**< \brief DF0, ASCLIN18 Error Service Request*/
       Ifx_SRC_ASCLIN_ASCLIN               ASCLIN19;               /**< \brief DFC, ASCLIN19 Error Service Request*/
       Ifx_UReg_8Bit                       reserved_E08[8];        /**< \brief E08, \internal Reserved */
       Ifx_SRC_SRCR                        GTM_TOM[5][8];          /**< \brief E10, */
       Ifx_UReg_8Bit                       reserved_EB0[32];       /**< \brief EB0, \internal Reserved */
       Ifx_SRC_ASCLIN_ASCLIN               ASCLIN20;               /**< \brief ED0, ASCLIN20 Error Service Request*/
       Ifx_SRC_ASCLIN_ASCLIN               ASCLIN21;               /**< \brief EDC, ASCLIN21 Error Service Request*/
       Ifx_UReg_8Bit                       reserved_EE8[8];        /**< \brief EE8, \internal Reserved */
       Ifx_SRC_SRCR                        GTM_ATOM[9][4];         /**< \brief EF0, */
       Ifx_UReg_8Bit                       reserved_F80[48];       /**< \brief F80, \internal Reserved */
       Ifx_SRC_ASCLIN_ASCLIN               ASCLIN22;               /**< \brief FB0, ASCLIN22 Error Service Request*/
       Ifx_SRC_ASCLIN_ASCLIN               ASCLIN23;               /**< \brief FBC, ASCLIN23 Error Service Request*/
       Ifx_UReg_8Bit                       reserved_FC8[8];        /**< \brief FC8, \internal Reserved */
       Ifx_SRC_SRCR                        GTM_MCSW[10];           /**< \brief FD0, GTM Multi Channel Sequencer Service Request ${w}*/
       Ifx_UReg_8Bit                       reserved_FF8[4104];     /**< \brief FF8, \internal Reserved */
} Ifx_SRC;

/** \}  */
/******************************************************************************/
/** \}  */


/******************************************************************************/

/******************************************************************************/


#line 57 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\Infra\\Sfr\\TC38A\\_Reg\\IfxSrc_reg.h"
/******************************************************************************/

/******************************************************************************/

/******************************************************************************/

/** \addtogroup IfxSfr_Src_Registers_Cfg_BaseAddress
 * \{  */

/** \brief SRC object */

/** \}  */


/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_Registers_Cfg_Src
 * \{  */
/** \brief 0, CPU0 Software Breakpoint Service Request */

/** Alias (User Manual Name) for SRC_CPU_CPU0_SB.
* To use register names with standard convension, please use SRC_CPU_CPU0_SB.
*/


/** \brief 4, CPU1 Software Breakpoint Service Request */

/** Alias (User Manual Name) for SRC_CPU_CPU1_SB.
* To use register names with standard convension, please use SRC_CPU_CPU1_SB.
*/


/** \brief 8, CPU2 Software Breakpoint Service Request */

/** Alias (User Manual Name) for SRC_CPU_CPU2_SB.
* To use register names with standard convension, please use SRC_CPU_CPU2_SB.
*/


/** \brief C, CPU3 Software Breakpoint Service Request */

/** Alias (User Manual Name) for SRC_CPU_CPU3_SB.
* To use register names with standard convension, please use SRC_CPU_CPU3_SB.
*/


/** \brief 20, SBCU Service Request (SPB Bus Control Unit) */

/** Alias (User Manual Name) for SRC_SBCU.
* To use register names with standard convension, please use SRC_SBCU.
*/


/** \brief 30, SRI Domain 0 Service Request */


/** \brief 40, Cerberus Service Request 0 */

/** Alias (User Manual Name) for SRC_CERBERUS_CERBERUS_SR0.
* To use register names with standard convension, please use SRC_CERBERUS_CERBERUS_SR0.
*/


/** \brief 44, Cerberus Service Request 1 */

/** Alias (User Manual Name) for SRC_CERBERUS_CERBERUS_SR1.
* To use register names with standard convension, please use SRC_CERBERUS_CERBERUS_SR1.
*/


/** \brief 50, ASCLIN0 Transmit Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN_ASCLIN0_TX.
* To use register names with standard convension, please use SRC_ASCLIN_ASCLIN0_TX.
*/


/** \brief 54, ASCLIN0 Receive Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN_ASCLIN0_RX.
* To use register names with standard convension, please use SRC_ASCLIN_ASCLIN0_RX.
*/


/** \brief 58, ASCLIN0 Error Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN_ASCLIN0_ERR.
* To use register names with standard convension, please use SRC_ASCLIN_ASCLIN0_ERR.
*/


/** \brief 5C, ASCLIN1 Transmit Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN_ASCLIN1_TX.
* To use register names with standard convension, please use SRC_ASCLIN_ASCLIN1_TX.
*/


/** \brief 60, ASCLIN1 Receive Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN_ASCLIN1_RX.
* To use register names with standard convension, please use SRC_ASCLIN_ASCLIN1_RX.
*/


/** \brief 64, ASCLIN1 Error Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN_ASCLIN1_ERR.
* To use register names with standard convension, please use SRC_ASCLIN_ASCLIN1_ERR.
*/


/** \brief 68, ASCLIN2 Transmit Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN_ASCLIN2_TX.
* To use register names with standard convension, please use SRC_ASCLIN_ASCLIN2_TX.
*/


/** \brief 6C, ASCLIN2 Receive Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN_ASCLIN2_RX.
* To use register names with standard convension, please use SRC_ASCLIN_ASCLIN2_RX.
*/


/** \brief 70, ASCLIN2 Error Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN_ASCLIN2_ERR.
* To use register names with standard convension, please use SRC_ASCLIN_ASCLIN2_ERR.
*/


/** \brief 74, ASCLIN3 Transmit Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN_ASCLIN3_TX.
* To use register names with standard convension, please use SRC_ASCLIN_ASCLIN3_TX.
*/


/** \brief 78, ASCLIN3 Receive Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN_ASCLIN3_RX.
* To use register names with standard convension, please use SRC_ASCLIN_ASCLIN3_RX.
*/


/** \brief 7C, ASCLIN3 Error Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN_ASCLIN3_ERR.
* To use register names with standard convension, please use SRC_ASCLIN_ASCLIN3_ERR.
*/


/** \brief 80, ASCLIN4 Transmit Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN_ASCLIN4_TX.
* To use register names with standard convension, please use SRC_ASCLIN_ASCLIN4_TX.
*/


/** \brief 84, ASCLIN4 Receive Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN_ASCLIN4_RX.
* To use register names with standard convension, please use SRC_ASCLIN_ASCLIN4_RX.
*/


/** \brief 88, ASCLIN4 Error Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN_ASCLIN4_ERR.
* To use register names with standard convension, please use SRC_ASCLIN_ASCLIN4_ERR.
*/


/** \brief 8C, ASCLIN5 Transmit Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN_ASCLIN5_TX.
* To use register names with standard convension, please use SRC_ASCLIN_ASCLIN5_TX.
*/


/** \brief 90, ASCLIN5 Receive Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN_ASCLIN5_RX.
* To use register names with standard convension, please use SRC_ASCLIN_ASCLIN5_RX.
*/


/** \brief 94, ASCLIN5 Error Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN_ASCLIN5_ERR.
* To use register names with standard convension, please use SRC_ASCLIN_ASCLIN5_ERR.
*/


/** \brief 98, ASCLIN6 Transmit Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN_ASCLIN6_TX.
* To use register names with standard convension, please use SRC_ASCLIN_ASCLIN6_TX.
*/


/** \brief 9C, ASCLIN6 Receive Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN_ASCLIN6_RX.
* To use register names with standard convension, please use SRC_ASCLIN_ASCLIN6_RX.
*/


/** \brief A0, ASCLIN6 Error Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN_ASCLIN6_ERR.
* To use register names with standard convension, please use SRC_ASCLIN_ASCLIN6_ERR.
*/


/** \brief A4, ASCLIN7 Transmit Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN_ASCLIN7_TX.
* To use register names with standard convension, please use SRC_ASCLIN_ASCLIN7_TX.
*/


/** \brief A8, ASCLIN7 Receive Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN_ASCLIN7_RX.
* To use register names with standard convension, please use SRC_ASCLIN_ASCLIN7_RX.
*/


/** \brief AC, ASCLIN7 Error Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN_ASCLIN7_ERR.
* To use register names with standard convension, please use SRC_ASCLIN_ASCLIN7_ERR.
*/


/** \brief B0, ASCLIN8 Transmit Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN_ASCLIN8_TX.
* To use register names with standard convension, please use SRC_ASCLIN_ASCLIN8_TX.
*/


/** \brief B4, ASCLIN8 Receive Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN_ASCLIN8_RX.
* To use register names with standard convension, please use SRC_ASCLIN_ASCLIN8_RX.
*/


/** \brief B8, ASCLIN8 Error Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN_ASCLIN8_ERR.
* To use register names with standard convension, please use SRC_ASCLIN_ASCLIN8_ERR.
*/


/** \brief BC, ASCLIN9 Transmit Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN_ASCLIN9_TX.
* To use register names with standard convension, please use SRC_ASCLIN_ASCLIN9_TX.
*/


/** \brief C0, ASCLIN9 Receive Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN_ASCLIN9_RX.
* To use register names with standard convension, please use SRC_ASCLIN_ASCLIN9_RX.
*/


/** \brief C4, ASCLIN9 Error Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN_ASCLIN9_ERR.
* To use register names with standard convension, please use SRC_ASCLIN_ASCLIN9_ERR.
*/


/** \brief C8, ASCLIN10 Transmit Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN_ASCLIN10_TX.
* To use register names with standard convension, please use SRC_ASCLIN_ASCLIN10_TX.
*/


/** \brief CC, ASCLIN10 Receive Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN_ASCLIN10_RX.
* To use register names with standard convension, please use SRC_ASCLIN_ASCLIN10_RX.
*/


/** \brief D0, ASCLIN10 Error Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN_ASCLIN10_ERR.
* To use register names with standard convension, please use SRC_ASCLIN_ASCLIN10_ERR.
*/


/** \brief D4, ASCLIN11 Transmit Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN_ASCLIN11_TX.
* To use register names with standard convension, please use SRC_ASCLIN_ASCLIN11_TX.
*/


/** \brief D8, ASCLIN11 Receive Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN_ASCLIN11_RX.
* To use register names with standard convension, please use SRC_ASCLIN_ASCLIN11_RX.
*/


/** \brief DC, ASCLIN11 Error Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN_ASCLIN11_ERR.
* To use register names with standard convension, please use SRC_ASCLIN_ASCLIN11_ERR.
*/


/** \brief EC, MTU Done Service Request */


/** \brief F0, QSPI0 Transmit Service Request */

/** Alias (User Manual Name) for SRC_QSPI_QSPI0_TX.
* To use register names with standard convension, please use SRC_QSPI_QSPI0_TX.
*/


/** \brief F4, QSPI0 Receive Service Request */

/** Alias (User Manual Name) for SRC_QSPI_QSPI0_RX.
* To use register names with standard convension, please use SRC_QSPI_QSPI0_RX.
*/


/** \brief F8, QSPI0 Error Service Request */

/** Alias (User Manual Name) for SRC_QSPI_QSPI0_ERR.
* To use register names with standard convension, please use SRC_QSPI_QSPI0_ERR.
*/


/** \brief FC, QSPI0 Phase Transition Service Request */

/** Alias (User Manual Name) for SRC_QSPI_QSPI0_PT.
* To use register names with standard convension, please use SRC_QSPI_QSPI0_PT.
*/


/** \brief 100, QSPI0 User Defined Service Request */

/** Alias (User Manual Name) for SRC_QSPI_QSPI0_U.
* To use register names with standard convension, please use SRC_QSPI_QSPI0_U.
*/


/** \brief 104, QSPI1 Transmit Service Request */

/** Alias (User Manual Name) for SRC_QSPI_QSPI1_TX.
* To use register names with standard convension, please use SRC_QSPI_QSPI1_TX.
*/


/** \brief 108, QSPI1 Receive Service Request */

/** Alias (User Manual Name) for SRC_QSPI_QSPI1_RX.
* To use register names with standard convension, please use SRC_QSPI_QSPI1_RX.
*/


/** \brief 10C, QSPI1 Error Service Request */

/** Alias (User Manual Name) for SRC_QSPI_QSPI1_ERR.
* To use register names with standard convension, please use SRC_QSPI_QSPI1_ERR.
*/


/** \brief 110, QSPI1 Phase Transition Service Request */

/** Alias (User Manual Name) for SRC_QSPI_QSPI1_PT.
* To use register names with standard convension, please use SRC_QSPI_QSPI1_PT.
*/


/** \brief 114, QSPI1 User Defined Service Request */

/** Alias (User Manual Name) for SRC_QSPI_QSPI1_U.
* To use register names with standard convension, please use SRC_QSPI_QSPI1_U.
*/


/** \brief 118, QSPI2 Transmit Service Request */

/** Alias (User Manual Name) for SRC_QSPI_QSPI2_TX.
* To use register names with standard convension, please use SRC_QSPI_QSPI2_TX.
*/


/** \brief 11C, QSPI2 Receive Service Request */

/** Alias (User Manual Name) for SRC_QSPI_QSPI2_RX.
* To use register names with standard convension, please use SRC_QSPI_QSPI2_RX.
*/


/** \brief 120, QSPI2 Error Service Request */

/** Alias (User Manual Name) for SRC_QSPI_QSPI2_ERR.
* To use register names with standard convension, please use SRC_QSPI_QSPI2_ERR.
*/


/** \brief 124, QSPI2 Phase Transition Service Request */

/** Alias (User Manual Name) for SRC_QSPI_QSPI2_PT.
* To use register names with standard convension, please use SRC_QSPI_QSPI2_PT.
*/


/** \brief 128, QSPI2 User Defined Service Request */

/** Alias (User Manual Name) for SRC_QSPI_QSPI2_U.
* To use register names with standard convension, please use SRC_QSPI_QSPI2_U.
*/


/** \brief 12C, QSPI3 Transmit Service Request */

/** Alias (User Manual Name) for SRC_QSPI_QSPI3_TX.
* To use register names with standard convension, please use SRC_QSPI_QSPI3_TX.
*/


/** \brief 130, QSPI3 Receive Service Request */

/** Alias (User Manual Name) for SRC_QSPI_QSPI3_RX.
* To use register names with standard convension, please use SRC_QSPI_QSPI3_RX.
*/


/** \brief 134, QSPI3 Error Service Request */

/** Alias (User Manual Name) for SRC_QSPI_QSPI3_ERR.
* To use register names with standard convension, please use SRC_QSPI_QSPI3_ERR.
*/


/** \brief 138, QSPI3 Phase Transition Service Request */

/** Alias (User Manual Name) for SRC_QSPI_QSPI3_PT.
* To use register names with standard convension, please use SRC_QSPI_QSPI3_PT.
*/


/** \brief 13C, QSPI3 User Defined Service Request */

/** Alias (User Manual Name) for SRC_QSPI_QSPI3_U.
* To use register names with standard convension, please use SRC_QSPI_QSPI3_U.
*/


/** \brief 140, QSPI4 Transmit Service Request */

/** Alias (User Manual Name) for SRC_QSPI_QSPI4_TX.
* To use register names with standard convension, please use SRC_QSPI_QSPI4_TX.
*/


/** \brief 144, QSPI4 Receive Service Request */

/** Alias (User Manual Name) for SRC_QSPI_QSPI4_RX.
* To use register names with standard convension, please use SRC_QSPI_QSPI4_RX.
*/


/** \brief 148, QSPI4 Error Service Request */

/** Alias (User Manual Name) for SRC_QSPI_QSPI4_ERR.
* To use register names with standard convension, please use SRC_QSPI_QSPI4_ERR.
*/


/** \brief 14C, QSPI4 Phase Transition Service Request */

/** Alias (User Manual Name) for SRC_QSPI_QSPI4_PT.
* To use register names with standard convension, please use SRC_QSPI_QSPI4_PT.
*/


/** \brief 150, QSPI4 User Defined Service Request */

/** Alias (User Manual Name) for SRC_QSPI_QSPI4_U.
* To use register names with standard convension, please use SRC_QSPI_QSPI4_U.
*/


/** \brief 180, HSCT0 Service Request */

/** Alias (User Manual Name) for SRC_HSCT_HSCT0_SR.
* To use register names with standard convension, please use SRC_HSCT_HSCT0_SR.
*/


/** \brief 190, HSSL0 Channel 0 OK Service Request */

/** Alias (User Manual Name) for SRC_HSSL_HSSL0_CH0_COK.
* To use register names with standard convension, please use SRC_HSSL_HSSL0_CH0_COK.
*/


/** \brief 194, HSSL0 Channel 0 Read Data Service Request */

/** Alias (User Manual Name) for SRC_HSSL_HSSL0_CH0_RDI.
* To use register names with standard convension, please use SRC_HSSL_HSSL0_CH0_RDI.
*/


/** \brief 198, HSSL0 Channel 0 Error Service Request */

/** Alias (User Manual Name) for SRC_HSSL_HSSL0_CH0_ERR.
* To use register names with standard convension, please use SRC_HSSL_HSSL0_CH0_ERR.
*/


/** \brief 19C, HSSL0 Channel 0 Trigger Interrupt Service Request */

/** Alias (User Manual Name) for SRC_HSSL_HSSL0_CH0_TRG.
* To use register names with standard convension, please use SRC_HSSL_HSSL0_CH0_TRG.
*/


/** \brief 1A0, HSSL0 Channel 1 OK Service Request */

/** Alias (User Manual Name) for SRC_HSSL_HSSL0_CH1_COK.
* To use register names with standard convension, please use SRC_HSSL_HSSL0_CH1_COK.
*/


/** \brief 1A4, HSSL0 Channel 1 Read Data Service Request */

/** Alias (User Manual Name) for SRC_HSSL_HSSL0_CH1_RDI.
* To use register names with standard convension, please use SRC_HSSL_HSSL0_CH1_RDI.
*/


/** \brief 1A8, HSSL0 Channel 1 Error Service Request */

/** Alias (User Manual Name) for SRC_HSSL_HSSL0_CH1_ERR.
* To use register names with standard convension, please use SRC_HSSL_HSSL0_CH1_ERR.
*/


/** \brief 1AC, HSSL0 Channel 1 Trigger Interrupt Service Request */

/** Alias (User Manual Name) for SRC_HSSL_HSSL0_CH1_TRG.
* To use register names with standard convension, please use SRC_HSSL_HSSL0_CH1_TRG.
*/


/** \brief 1B0, HSSL0 Channel 2 OK Service Request */

/** Alias (User Manual Name) for SRC_HSSL_HSSL0_CH2_COK.
* To use register names with standard convension, please use SRC_HSSL_HSSL0_CH2_COK.
*/


/** \brief 1B4, HSSL0 Channel 2 Read Data Service Request */

/** Alias (User Manual Name) for SRC_HSSL_HSSL0_CH2_RDI.
* To use register names with standard convension, please use SRC_HSSL_HSSL0_CH2_RDI.
*/


/** \brief 1B8, HSSL0 Channel 2 Error Service Request */

/** Alias (User Manual Name) for SRC_HSSL_HSSL0_CH2_ERR.
* To use register names with standard convension, please use SRC_HSSL_HSSL0_CH2_ERR.
*/


/** \brief 1BC, HSSL0 Channel 2 Trigger Interrupt Service Request */

/** Alias (User Manual Name) for SRC_HSSL_HSSL0_CH2_TRG.
* To use register names with standard convension, please use SRC_HSSL_HSSL0_CH2_TRG.
*/


/** \brief 1C0, HSSL0 Channel 3 OK Service Request */

/** Alias (User Manual Name) for SRC_HSSL_HSSL0_CH3_COK.
* To use register names with standard convension, please use SRC_HSSL_HSSL0_CH3_COK.
*/


/** \brief 1C4, HSSL0 Channel 3 Read Data Service Request */

/** Alias (User Manual Name) for SRC_HSSL_HSSL0_CH3_RDI.
* To use register names with standard convension, please use SRC_HSSL_HSSL0_CH3_RDI.
*/


/** \brief 1C8, HSSL0 Channel 3 Error Service Request */

/** Alias (User Manual Name) for SRC_HSSL_HSSL0_CH3_ERR.
* To use register names with standard convension, please use SRC_HSSL_HSSL0_CH3_ERR.
*/


/** \brief 1CC, HSSL0 Channel 3 Trigger Interrupt Service Request */

/** Alias (User Manual Name) for SRC_HSSL_HSSL0_CH3_TRG.
* To use register names with standard convension, please use SRC_HSSL_HSSL0_CH3_TRG.
*/


/** \brief 1D0, HSSL0 Exception Service Request */

/** Alias (User Manual Name) for SRC_HSSL_HSSL0_EXI.
* To use register names with standard convension, please use SRC_HSSL_HSSL0_EXI.
*/


/** \brief 220, I2C0 Data Transfer Request */

/** Alias (User Manual Name) for SRC_I2C_I2C0_DTR.
* To use register names with standard convension, please use SRC_I2C_I2C0_DTR.
*/


/** \brief 224, I2C0 Error Service Request */

/** Alias (User Manual Name) for SRC_I2C_I2C0_ERR.
* To use register names with standard convension, please use SRC_I2C_I2C0_ERR.
*/


/** \brief 228, I2C0 Protocol Service Request */

/** Alias (User Manual Name) for SRC_I2C_I2C0_P.
* To use register names with standard convension, please use SRC_I2C_I2C0_P.
*/


/** \brief 230, I2C1 Data Transfer Request */

/** Alias (User Manual Name) for SRC_I2C_I2C1_DTR.
* To use register names with standard convension, please use SRC_I2C_I2C1_DTR.
*/


/** \brief 234, I2C1 Error Service Request */

/** Alias (User Manual Name) for SRC_I2C_I2C1_ERR.
* To use register names with standard convension, please use SRC_I2C_I2C1_ERR.
*/


/** \brief 238, I2C1 Protocol Service Request */

/** Alias (User Manual Name) for SRC_I2C_I2C1_P.
* To use register names with standard convension, please use SRC_I2C_I2C1_P.
*/


/** \brief 240, SENT TRIG0 Service Request */

/** Alias (User Manual Name) for SRC_SENT_SENT0_SR.
* To use register names with standard convension, please use SRC_SENT_SENT0_SR.
*/


/** \brief 244, SENT TRIG1 Service Request */

/** Alias (User Manual Name) for SRC_SENT_SENT1_SR.
* To use register names with standard convension, please use SRC_SENT_SENT1_SR.
*/


/** \brief 248, SENT TRIG2 Service Request */

/** Alias (User Manual Name) for SRC_SENT_SENT2_SR.
* To use register names with standard convension, please use SRC_SENT_SENT2_SR.
*/


/** \brief 24C, SENT TRIG3 Service Request */

/** Alias (User Manual Name) for SRC_SENT_SENT3_SR.
* To use register names with standard convension, please use SRC_SENT_SENT3_SR.
*/


/** \brief 250, SENT TRIG4 Service Request */

/** Alias (User Manual Name) for SRC_SENT_SENT4_SR.
* To use register names with standard convension, please use SRC_SENT_SENT4_SR.
*/


/** \brief 254, SENT TRIG5 Service Request */

/** Alias (User Manual Name) for SRC_SENT_SENT5_SR.
* To use register names with standard convension, please use SRC_SENT_SENT5_SR.
*/


/** \brief 258, SENT TRIG6 Service Request */

/** Alias (User Manual Name) for SRC_SENT_SENT6_SR.
* To use register names with standard convension, please use SRC_SENT_SENT6_SR.
*/


/** \brief 25C, SENT TRIG7 Service Request */

/** Alias (User Manual Name) for SRC_SENT_SENT7_SR.
* To use register names with standard convension, please use SRC_SENT_SENT7_SR.
*/


/** \brief 260, SENT TRIG8 Service Request */

/** Alias (User Manual Name) for SRC_SENT_SENT8_SR.
* To use register names with standard convension, please use SRC_SENT_SENT8_SR.
*/


/** \brief 264, SENT TRIG9 Service Request */

/** Alias (User Manual Name) for SRC_SENT_SENT9_SR.
* To use register names with standard convension, please use SRC_SENT_SENT9_SR.
*/


/** \brief 270, MSC0 Service Request 0 */

/** Alias (User Manual Name) for SRC_MSC_MSC0_SR0.
* To use register names with standard convension, please use SRC_MSC_MSC0_SR0.
*/


/** \brief 274, MSC0 Service Request 1 */

/** Alias (User Manual Name) for SRC_MSC_MSC0_SR1.
* To use register names with standard convension, please use SRC_MSC_MSC0_SR1.
*/


/** \brief 278, MSC0 Service Request 2 */

/** Alias (User Manual Name) for SRC_MSC_MSC0_SR2.
* To use register names with standard convension, please use SRC_MSC_MSC0_SR2.
*/


/** \brief 27C, MSC0 Service Request 3 */

/** Alias (User Manual Name) for SRC_MSC_MSC0_SR3.
* To use register names with standard convension, please use SRC_MSC_MSC0_SR3.
*/


/** \brief 280, MSC0 Service Request 4 */

/** Alias (User Manual Name) for SRC_MSC_MSC0_SR4.
* To use register names with standard convension, please use SRC_MSC_MSC0_SR4.
*/


/** \brief 284, MSC1 Service Request 0 */

/** Alias (User Manual Name) for SRC_MSC_MSC1_SR0.
* To use register names with standard convension, please use SRC_MSC_MSC1_SR0.
*/


/** \brief 288, MSC1 Service Request 1 */

/** Alias (User Manual Name) for SRC_MSC_MSC1_SR1.
* To use register names with standard convension, please use SRC_MSC_MSC1_SR1.
*/


/** \brief 28C, MSC1 Service Request 2 */

/** Alias (User Manual Name) for SRC_MSC_MSC1_SR2.
* To use register names with standard convension, please use SRC_MSC_MSC1_SR2.
*/


/** \brief 290, MSC1 Service Request 3 */

/** Alias (User Manual Name) for SRC_MSC_MSC1_SR3.
* To use register names with standard convension, please use SRC_MSC_MSC1_SR3.
*/


/** \brief 294, MSC1 Service Request 4 */

/** Alias (User Manual Name) for SRC_MSC_MSC1_SR4.
* To use register names with standard convension, please use SRC_MSC_MSC1_SR4.
*/


/** \brief 298, MSC2 Service Request 0 */

/** Alias (User Manual Name) for SRC_MSC_MSC2_SR0.
* To use register names with standard convension, please use SRC_MSC_MSC2_SR0.
*/


/** \brief 29C, MSC2 Service Request 1 */

/** Alias (User Manual Name) for SRC_MSC_MSC2_SR1.
* To use register names with standard convension, please use SRC_MSC_MSC2_SR1.
*/


/** \brief 2A0, MSC2 Service Request 2 */

/** Alias (User Manual Name) for SRC_MSC_MSC2_SR2.
* To use register names with standard convension, please use SRC_MSC_MSC2_SR2.
*/


/** \brief 2A4, MSC2 Service Request 3 */

/** Alias (User Manual Name) for SRC_MSC_MSC2_SR3.
* To use register names with standard convension, please use SRC_MSC_MSC2_SR3.
*/


/** \brief 2A8, MSC2 Service Request 4 */

/** Alias (User Manual Name) for SRC_MSC_MSC2_SR4.
* To use register names with standard convension, please use SRC_MSC_MSC2_SR4.
*/


/** \brief 2C0, CCU0 Service Request 0 */

/** Alias (User Manual Name) for SRC_CCU6_CCU0_SR0.
* To use register names with standard convension, please use SRC_CCU6_CCU0_SR0.
*/


/** \brief 2C4, CCU0 Service Request 1 */

/** Alias (User Manual Name) for SRC_CCU6_CCU0_SR1.
* To use register names with standard convension, please use SRC_CCU6_CCU0_SR1.
*/


/** \brief 2C8, CCU0 Service Request 2 */

/** Alias (User Manual Name) for SRC_CCU6_CCU0_SR2.
* To use register names with standard convension, please use SRC_CCU6_CCU0_SR2.
*/


/** \brief 2CC, CCU0 Service Request 3 */

/** Alias (User Manual Name) for SRC_CCU6_CCU0_SR3.
* To use register names with standard convension, please use SRC_CCU6_CCU0_SR3.
*/


/** \brief 2D0, CCU1 Service Request 0 */

/** Alias (User Manual Name) for SRC_CCU6_CCU1_SR0.
* To use register names with standard convension, please use SRC_CCU6_CCU1_SR0.
*/


/** \brief 2D4, CCU1 Service Request 1 */

/** Alias (User Manual Name) for SRC_CCU6_CCU1_SR1.
* To use register names with standard convension, please use SRC_CCU6_CCU1_SR1.
*/


/** \brief 2D8, CCU1 Service Request 2 */

/** Alias (User Manual Name) for SRC_CCU6_CCU1_SR2.
* To use register names with standard convension, please use SRC_CCU6_CCU1_SR2.
*/


/** \brief 2DC, CCU1 Service Request 3 */

/** Alias (User Manual Name) for SRC_CCU6_CCU1_SR3.
* To use register names with standard convension, please use SRC_CCU6_CCU1_SR3.
*/


/** \brief 2E0, GPT120 CAPREL Service Request */

/** Alias (User Manual Name) for SRC_GPT12_GPT120_CIRQ.
* To use register names with standard convension, please use SRC_GPT12_GPT120_CIRQ.
*/


/** \brief 2E4, GPT120 Timer 2 Service Request */

/** Alias (User Manual Name) for SRC_GPT12_GPT120_T2.
* To use register names with standard convension, please use SRC_GPT12_GPT120_T2.
*/


/** \brief 2E8, GPT120 Timer 3 Service Request */

/** Alias (User Manual Name) for SRC_GPT12_GPT120_T3.
* To use register names with standard convension, please use SRC_GPT12_GPT120_T3.
*/


/** \brief 2EC, GPT120 Timer 4 Service Request */

/** Alias (User Manual Name) for SRC_GPT12_GPT120_T4.
* To use register names with standard convension, please use SRC_GPT12_GPT120_T4.
*/


/** \brief 2F0, GPT120 Timer 5 Service Request */

/** Alias (User Manual Name) for SRC_GPT12_GPT120_T5.
* To use register names with standard convension, please use SRC_GPT12_GPT120_T5.
*/


/** \brief 2F4, GPT120 Timer 6 Service Request */

/** Alias (User Manual Name) for SRC_GPT12_GPT120_T6.
* To use register names with standard convension, please use SRC_GPT12_GPT120_T6.
*/


/** \brief 300, System Timer 0 Service Request 0 */

/** Alias (User Manual Name) for SRC_STM_STM0_SR0.
* To use register names with standard convension, please use SRC_STM_STM0_SR0.
*/


/** \brief 304, System Timer 0 Service Request 1 */

/** Alias (User Manual Name) for SRC_STM_STM0_SR1.
* To use register names with standard convension, please use SRC_STM_STM0_SR1.
*/


/** \brief 308, System Timer 1 Service Request 0 */

/** Alias (User Manual Name) for SRC_STM_STM1_SR0.
* To use register names with standard convension, please use SRC_STM_STM1_SR0.
*/


/** \brief 30C, System Timer 1 Service Request 1 */

/** Alias (User Manual Name) for SRC_STM_STM1_SR1.
* To use register names with standard convension, please use SRC_STM_STM1_SR1.
*/


/** \brief 310, System Timer 2 Service Request 0 */

/** Alias (User Manual Name) for SRC_STM_STM2_SR0.
* To use register names with standard convension, please use SRC_STM_STM2_SR0.
*/


/** \brief 314, System Timer 2 Service Request 1 */

/** Alias (User Manual Name) for SRC_STM_STM2_SR1.
* To use register names with standard convension, please use SRC_STM_STM2_SR1.
*/


/** \brief 318, System Timer 3 Service Request 0 */

/** Alias (User Manual Name) for SRC_STM_STM3_SR0.
* To use register names with standard convension, please use SRC_STM_STM3_SR0.
*/


/** \brief 31C, System Timer 3 Service Request 1 */

/** Alias (User Manual Name) for SRC_STM_STM3_SR1.
* To use register names with standard convension, please use SRC_STM_STM3_SR1.
*/


/** \brief 330, FCE0 Error Service Request */

/** Alias (User Manual Name) for SRC_FCE_FCE0_SR.
* To use register names with standard convension, please use SRC_FCE_FCE0_SR.
*/


/** \brief 340, DMA Error Service Request 0 */

/** Alias (User Manual Name) for SRC_DMA_DMA0_ERR0.
* To use register names with standard convension, please use SRC_DMA_DMA0_ERR0.
*/


/** \brief 344, DMA Error Service Request 1 */

/** Alias (User Manual Name) for SRC_DMA_DMA0_ERR1.
* To use register names with standard convension, please use SRC_DMA_DMA0_ERR1.
*/


/** \brief 348, DMA Error Service Request 2 */

/** Alias (User Manual Name) for SRC_DMA_DMA0_ERR2.
* To use register names with standard convension, please use SRC_DMA_DMA0_ERR2.
*/


/** \brief 34C, DMA Error Service Request 3 */

/** Alias (User Manual Name) for SRC_DMA_DMA0_ERR3.
* To use register names with standard convension, please use SRC_DMA_DMA0_ERR3.
*/


/** \brief 370, DMA Channel  0 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH0.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH0.
*/


/** \brief 374, DMA Channel  1 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH1.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH1.
*/


/** \brief 378, DMA Channel  2 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH2.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH2.
*/


/** \brief 37C, DMA Channel  3 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH3.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH3.
*/


/** \brief 380, DMA Channel  4 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH4.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH4.
*/


/** \brief 384, DMA Channel  5 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH5.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH5.
*/


/** \brief 388, DMA Channel  6 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH6.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH6.
*/


/** \brief 38C, DMA Channel  7 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH7.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH7.
*/


/** \brief 390, DMA Channel  8 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH8.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH8.
*/


/** \brief 394, DMA Channel  9 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH9.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH9.
*/


/** \brief 398, DMA Channel  10 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH10.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH10.
*/


/** \brief 39C, DMA Channel  11 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH11.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH11.
*/


/** \brief 3A0, DMA Channel  12 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH12.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH12.
*/


/** \brief 3A4, DMA Channel  13 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH13.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH13.
*/


/** \brief 3A8, DMA Channel  14 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH14.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH14.
*/


/** \brief 3AC, DMA Channel  15 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH15.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH15.
*/


/** \brief 3B0, DMA Channel  16 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH16.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH16.
*/


/** \brief 3B4, DMA Channel  17 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH17.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH17.
*/


/** \brief 3B8, DMA Channel  18 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH18.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH18.
*/


/** \brief 3BC, DMA Channel  19 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH19.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH19.
*/


/** \brief 3C0, DMA Channel  20 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH20.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH20.
*/


/** \brief 3C4, DMA Channel  21 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH21.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH21.
*/


/** \brief 3C8, DMA Channel  22 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH22.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH22.
*/


/** \brief 3CC, DMA Channel  23 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH23.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH23.
*/


/** \brief 3D0, DMA Channel  24 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH24.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH24.
*/


/** \brief 3D4, DMA Channel  25 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH25.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH25.
*/


/** \brief 3D8, DMA Channel  26 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH26.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH26.
*/


/** \brief 3DC, DMA Channel  27 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH27.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH27.
*/


/** \brief 3E0, DMA Channel  28 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH28.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH28.
*/


/** \brief 3E4, DMA Channel  29 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH29.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH29.
*/


/** \brief 3E8, DMA Channel  30 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH30.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH30.
*/


/** \brief 3EC, DMA Channel  31 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH31.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH31.
*/


/** \brief 3F0, DMA Channel  32 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH32.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH32.
*/


/** \brief 3F4, DMA Channel  33 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH33.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH33.
*/


/** \brief 3F8, DMA Channel  34 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH34.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH34.
*/


/** \brief 3FC, DMA Channel  35 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH35.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH35.
*/


/** \brief 400, DMA Channel  36 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH36.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH36.
*/


/** \brief 404, DMA Channel  37 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH37.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH37.
*/


/** \brief 408, DMA Channel  38 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH38.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH38.
*/


/** \brief 40C, DMA Channel  39 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH39.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH39.
*/


/** \brief 410, DMA Channel  40 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH40.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH40.
*/


/** \brief 414, DMA Channel  41 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH41.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH41.
*/


/** \brief 418, DMA Channel  42 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH42.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH42.
*/


/** \brief 41C, DMA Channel  43 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH43.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH43.
*/


/** \brief 420, DMA Channel  44 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH44.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH44.
*/


/** \brief 424, DMA Channel  45 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH45.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH45.
*/


/** \brief 428, DMA Channel  46 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH46.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH46.
*/


/** \brief 42C, DMA Channel  47 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH47.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH47.
*/


/** \brief 430, DMA Channel  48 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH48.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH48.
*/


/** \brief 434, DMA Channel  49 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH49.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH49.
*/


/** \brief 438, DMA Channel  50 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH50.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH50.
*/


/** \brief 43C, DMA Channel  51 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH51.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH51.
*/


/** \brief 440, DMA Channel  52 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH52.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH52.
*/


/** \brief 444, DMA Channel  53 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH53.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH53.
*/


/** \brief 448, DMA Channel  54 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH54.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH54.
*/


/** \brief 44C, DMA Channel  55 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH55.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH55.
*/


/** \brief 450, DMA Channel  56 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH56.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH56.
*/


/** \brief 454, DMA Channel  57 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH57.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH57.
*/


/** \brief 458, DMA Channel  58 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH58.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH58.
*/


/** \brief 45C, DMA Channel  59 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH59.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH59.
*/


/** \brief 460, DMA Channel  60 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH60.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH60.
*/


/** \brief 464, DMA Channel  61 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH61.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH61.
*/


/** \brief 468, DMA Channel  62 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH62.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH62.
*/


/** \brief 46C, DMA Channel  63 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH63.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH63.
*/


/** \brief 470, DMA Channel  64 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH64.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH64.
*/


/** \brief 474, DMA Channel  65 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH65.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH65.
*/


/** \brief 478, DMA Channel  66 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH66.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH66.
*/


/** \brief 47C, DMA Channel  67 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH67.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH67.
*/


/** \brief 480, DMA Channel  68 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH68.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH68.
*/


/** \brief 484, DMA Channel  69 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH69.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH69.
*/


/** \brief 488, DMA Channel  70 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH70.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH70.
*/


/** \brief 48C, DMA Channel  71 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH71.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH71.
*/


/** \brief 490, DMA Channel  72 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH72.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH72.
*/


/** \brief 494, DMA Channel  73 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH73.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH73.
*/


/** \brief 498, DMA Channel  74 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH74.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH74.
*/


/** \brief 49C, DMA Channel  75 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH75.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH75.
*/


/** \brief 4A0, DMA Channel  76 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH76.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH76.
*/


/** \brief 4A4, DMA Channel  77 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH77.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH77.
*/


/** \brief 4A8, DMA Channel  78 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH78.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH78.
*/


/** \brief 4AC, DMA Channel  79 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH79.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH79.
*/


/** \brief 4B0, DMA Channel  80 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH80.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH80.
*/


/** \brief 4B4, DMA Channel  81 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH81.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH81.
*/


/** \brief 4B8, DMA Channel  82 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH82.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH82.
*/


/** \brief 4BC, DMA Channel  83 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH83.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH83.
*/


/** \brief 4C0, DMA Channel  84 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH84.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH84.
*/


/** \brief 4C4, DMA Channel  85 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH85.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH85.
*/


/** \brief 4C8, DMA Channel  86 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH86.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH86.
*/


/** \brief 4CC, DMA Channel  87 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH87.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH87.
*/


/** \brief 4D0, DMA Channel  88 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH88.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH88.
*/


/** \brief 4D4, DMA Channel  89 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH89.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH89.
*/


/** \brief 4D8, DMA Channel  90 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH90.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH90.
*/


/** \brief 4DC, DMA Channel  91 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH91.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH91.
*/


/** \brief 4E0, DMA Channel  92 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH92.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH92.
*/


/** \brief 4E4, DMA Channel  93 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH93.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH93.
*/


/** \brief 4E8, DMA Channel  94 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH94.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH94.
*/


/** \brief 4EC, DMA Channel  95 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH95.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH95.
*/


/** \brief 4F0, DMA Channel  96 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH96.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH96.
*/


/** \brief 4F4, DMA Channel  97 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH97.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH97.
*/


/** \brief 4F8, DMA Channel  98 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH98.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH98.
*/


/** \brief 4FC, DMA Channel  99 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH99.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH99.
*/


/** \brief 500, DMA Channel  100 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH100.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH100.
*/


/** \brief 504, DMA Channel  101 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH101.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH101.
*/


/** \brief 508, DMA Channel  102 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH102.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH102.
*/


/** \brief 50C, DMA Channel  103 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH103.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH103.
*/


/** \brief 510, DMA Channel  104 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH104.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH104.
*/


/** \brief 514, DMA Channel  105 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH105.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH105.
*/


/** \brief 518, DMA Channel  106 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH106.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH106.
*/


/** \brief 51C, DMA Channel  107 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH107.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH107.
*/


/** \brief 520, DMA Channel  108 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH108.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH108.
*/


/** \brief 524, DMA Channel  109 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH109.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH109.
*/


/** \brief 528, DMA Channel  110 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH110.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH110.
*/


/** \brief 52C, DMA Channel  111 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH111.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH111.
*/


/** \brief 530, DMA Channel  112 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH112.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH112.
*/


/** \brief 534, DMA Channel  113 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH113.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH113.
*/


/** \brief 538, DMA Channel  114 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH114.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH114.
*/


/** \brief 53C, DMA Channel  115 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH115.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH115.
*/


/** \brief 540, DMA Channel  116 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH116.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH116.
*/


/** \brief 544, DMA Channel  117 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH117.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH117.
*/


/** \brief 548, DMA Channel  118 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH118.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH118.
*/


/** \brief 54C, DMA Channel  119 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH119.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH119.
*/


/** \brief 550, DMA Channel  120 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH120.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH120.
*/


/** \brief 554, DMA Channel  121 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH121.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH121.
*/


/** \brief 558, DMA Channel  122 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH122.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH122.
*/


/** \brief 55C, DMA Channel  123 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH123.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH123.
*/


/** \brief 560, DMA Channel  124 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH124.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH124.
*/


/** \brief 564, DMA Channel  125 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH125.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH125.
*/


/** \brief 568, DMA Channel  126 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH126.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH126.
*/


/** \brief 56C, DMA Channel  127 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH127.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH127.
*/


/** \brief 580, GETH Service Request 0 */

/** Alias (User Manual Name) for SRC_GETH_GETH0_SR0.
* To use register names with standard convension, please use SRC_GETH_GETH0_SR0.
*/


/** \brief 584, GETH Service Request 1 */

/** Alias (User Manual Name) for SRC_GETH_GETH0_SR1.
* To use register names with standard convension, please use SRC_GETH_GETH0_SR1.
*/


/** \brief 588, GETH Service Request 2 */

/** Alias (User Manual Name) for SRC_GETH_GETH0_SR2.
* To use register names with standard convension, please use SRC_GETH_GETH0_SR2.
*/


/** \brief 58C, GETH Service Request 3 */

/** Alias (User Manual Name) for SRC_GETH_GETH0_SR3.
* To use register names with standard convension, please use SRC_GETH_GETH0_SR3.
*/


/** \brief 590, GETH Service Request 4 */

/** Alias (User Manual Name) for SRC_GETH_GETH0_SR4.
* To use register names with standard convension, please use SRC_GETH_GETH0_SR4.
*/


/** \brief 594, GETH Service Request 5 */

/** Alias (User Manual Name) for SRC_GETH_GETH0_SR5.
* To use register names with standard convension, please use SRC_GETH_GETH0_SR5.
*/


/** \brief 598, GETH Service Request 6 */

/** Alias (User Manual Name) for SRC_GETH_GETH0_SR6.
* To use register names with standard convension, please use SRC_GETH_GETH0_SR6.
*/


/** \brief 59C, GETH Service Request 7 */

/** Alias (User Manual Name) for SRC_GETH_GETH0_SR7.
* To use register names with standard convension, please use SRC_GETH_GETH0_SR7.
*/


/** \brief 5A0, GETH Service Request 8 */

/** Alias (User Manual Name) for SRC_GETH_GETH0_SR8.
* To use register names with standard convension, please use SRC_GETH_GETH0_SR8.
*/


/** \brief 5A4, GETH Service Request 9 */

/** Alias (User Manual Name) for SRC_GETH_GETH0_SR9.
* To use register names with standard convension, please use SRC_GETH_GETH0_SR9.
*/


/** \brief 5B0, CAN0 Service Request 0 */

/** Alias (User Manual Name) for SRC_CAN_CAN0_INT0.
* To use register names with standard convension, please use SRC_CAN_CAN0_INT0.
*/


/** \brief 5B4, CAN0 Service Request 1 */

/** Alias (User Manual Name) for SRC_CAN_CAN0_INT1.
* To use register names with standard convension, please use SRC_CAN_CAN0_INT1.
*/


/** \brief 5B8, CAN0 Service Request 2 */

/** Alias (User Manual Name) for SRC_CAN_CAN0_INT2.
* To use register names with standard convension, please use SRC_CAN_CAN0_INT2.
*/


/** \brief 5BC, CAN0 Service Request 3 */

/** Alias (User Manual Name) for SRC_CAN_CAN0_INT3.
* To use register names with standard convension, please use SRC_CAN_CAN0_INT3.
*/


/** \brief 5C0, CAN0 Service Request 4 */

/** Alias (User Manual Name) for SRC_CAN_CAN0_INT4.
* To use register names with standard convension, please use SRC_CAN_CAN0_INT4.
*/


/** \brief 5C4, CAN0 Service Request 5 */

/** Alias (User Manual Name) for SRC_CAN_CAN0_INT5.
* To use register names with standard convension, please use SRC_CAN_CAN0_INT5.
*/


/** \brief 5C8, CAN0 Service Request 6 */

/** Alias (User Manual Name) for SRC_CAN_CAN0_INT6.
* To use register names with standard convension, please use SRC_CAN_CAN0_INT6.
*/


/** \brief 5CC, CAN0 Service Request 7 */

/** Alias (User Manual Name) for SRC_CAN_CAN0_INT7.
* To use register names with standard convension, please use SRC_CAN_CAN0_INT7.
*/


/** \brief 5D0, CAN0 Service Request 8 */

/** Alias (User Manual Name) for SRC_CAN_CAN0_INT8.
* To use register names with standard convension, please use SRC_CAN_CAN0_INT8.
*/


/** \brief 5D4, CAN0 Service Request 9 */

/** Alias (User Manual Name) for SRC_CAN_CAN0_INT9.
* To use register names with standard convension, please use SRC_CAN_CAN0_INT9.
*/


/** \brief 5D8, CAN0 Service Request 10 */

/** Alias (User Manual Name) for SRC_CAN_CAN0_INT10.
* To use register names with standard convension, please use SRC_CAN_CAN0_INT10.
*/


/** \brief 5DC, CAN0 Service Request 11 */

/** Alias (User Manual Name) for SRC_CAN_CAN0_INT11.
* To use register names with standard convension, please use SRC_CAN_CAN0_INT11.
*/


/** \brief 5E0, CAN0 Service Request 12 */

/** Alias (User Manual Name) for SRC_CAN_CAN0_INT12.
* To use register names with standard convension, please use SRC_CAN_CAN0_INT12.
*/


/** \brief 5E4, CAN0 Service Request 13 */

/** Alias (User Manual Name) for SRC_CAN_CAN0_INT13.
* To use register names with standard convension, please use SRC_CAN_CAN0_INT13.
*/


/** \brief 5E8, CAN0 Service Request 14 */

/** Alias (User Manual Name) for SRC_CAN_CAN0_INT14.
* To use register names with standard convension, please use SRC_CAN_CAN0_INT14.
*/


/** \brief 5EC, CAN0 Service Request 15 */

/** Alias (User Manual Name) for SRC_CAN_CAN0_INT15.
* To use register names with standard convension, please use SRC_CAN_CAN0_INT15.
*/


/** \brief 5F0, CAN1 Service Request 0 */

/** Alias (User Manual Name) for SRC_CAN_CAN1_INT0.
* To use register names with standard convension, please use SRC_CAN_CAN1_INT0.
*/


/** \brief 5F4, CAN1 Service Request 1 */

/** Alias (User Manual Name) for SRC_CAN_CAN1_INT1.
* To use register names with standard convension, please use SRC_CAN_CAN1_INT1.
*/


/** \brief 5F8, CAN1 Service Request 2 */

/** Alias (User Manual Name) for SRC_CAN_CAN1_INT2.
* To use register names with standard convension, please use SRC_CAN_CAN1_INT2.
*/


/** \brief 5FC, CAN1 Service Request 3 */

/** Alias (User Manual Name) for SRC_CAN_CAN1_INT3.
* To use register names with standard convension, please use SRC_CAN_CAN1_INT3.
*/


/** \brief 600, CAN1 Service Request 4 */

/** Alias (User Manual Name) for SRC_CAN_CAN1_INT4.
* To use register names with standard convension, please use SRC_CAN_CAN1_INT4.
*/


/** \brief 604, CAN1 Service Request 5 */

/** Alias (User Manual Name) for SRC_CAN_CAN1_INT5.
* To use register names with standard convension, please use SRC_CAN_CAN1_INT5.
*/


/** \brief 608, CAN1 Service Request 6 */

/** Alias (User Manual Name) for SRC_CAN_CAN1_INT6.
* To use register names with standard convension, please use SRC_CAN_CAN1_INT6.
*/


/** \brief 60C, CAN1 Service Request 7 */

/** Alias (User Manual Name) for SRC_CAN_CAN1_INT7.
* To use register names with standard convension, please use SRC_CAN_CAN1_INT7.
*/


/** \brief 610, CAN1 Service Request 8 */

/** Alias (User Manual Name) for SRC_CAN_CAN1_INT8.
* To use register names with standard convension, please use SRC_CAN_CAN1_INT8.
*/


/** \brief 614, CAN1 Service Request 9 */

/** Alias (User Manual Name) for SRC_CAN_CAN1_INT9.
* To use register names with standard convension, please use SRC_CAN_CAN1_INT9.
*/


/** \brief 618, CAN1 Service Request 10 */

/** Alias (User Manual Name) for SRC_CAN_CAN1_INT10.
* To use register names with standard convension, please use SRC_CAN_CAN1_INT10.
*/


/** \brief 61C, CAN1 Service Request 11 */

/** Alias (User Manual Name) for SRC_CAN_CAN1_INT11.
* To use register names with standard convension, please use SRC_CAN_CAN1_INT11.
*/


/** \brief 620, CAN1 Service Request 12 */

/** Alias (User Manual Name) for SRC_CAN_CAN1_INT12.
* To use register names with standard convension, please use SRC_CAN_CAN1_INT12.
*/


/** \brief 624, CAN1 Service Request 13 */

/** Alias (User Manual Name) for SRC_CAN_CAN1_INT13.
* To use register names with standard convension, please use SRC_CAN_CAN1_INT13.
*/


/** \brief 628, CAN1 Service Request 14 */

/** Alias (User Manual Name) for SRC_CAN_CAN1_INT14.
* To use register names with standard convension, please use SRC_CAN_CAN1_INT14.
*/


/** \brief 62C, CAN1 Service Request 15 */

/** Alias (User Manual Name) for SRC_CAN_CAN1_INT15.
* To use register names with standard convension, please use SRC_CAN_CAN1_INT15.
*/


/** \brief 630, CAN2 Service Request 0 */

/** Alias (User Manual Name) for SRC_CAN_CAN2_INT0.
* To use register names with standard convension, please use SRC_CAN_CAN2_INT0.
*/


/** \brief 634, CAN2 Service Request 1 */

/** Alias (User Manual Name) for SRC_CAN_CAN2_INT1.
* To use register names with standard convension, please use SRC_CAN_CAN2_INT1.
*/


/** \brief 638, CAN2 Service Request 2 */

/** Alias (User Manual Name) for SRC_CAN_CAN2_INT2.
* To use register names with standard convension, please use SRC_CAN_CAN2_INT2.
*/


/** \brief 63C, CAN2 Service Request 3 */

/** Alias (User Manual Name) for SRC_CAN_CAN2_INT3.
* To use register names with standard convension, please use SRC_CAN_CAN2_INT3.
*/


/** \brief 640, CAN2 Service Request 4 */

/** Alias (User Manual Name) for SRC_CAN_CAN2_INT4.
* To use register names with standard convension, please use SRC_CAN_CAN2_INT4.
*/


/** \brief 644, CAN2 Service Request 5 */

/** Alias (User Manual Name) for SRC_CAN_CAN2_INT5.
* To use register names with standard convension, please use SRC_CAN_CAN2_INT5.
*/


/** \brief 648, CAN2 Service Request 6 */

/** Alias (User Manual Name) for SRC_CAN_CAN2_INT6.
* To use register names with standard convension, please use SRC_CAN_CAN2_INT6.
*/


/** \brief 64C, CAN2 Service Request 7 */

/** Alias (User Manual Name) for SRC_CAN_CAN2_INT7.
* To use register names with standard convension, please use SRC_CAN_CAN2_INT7.
*/


/** \brief 650, CAN2 Service Request 8 */

/** Alias (User Manual Name) for SRC_CAN_CAN2_INT8.
* To use register names with standard convension, please use SRC_CAN_CAN2_INT8.
*/


/** \brief 654, CAN2 Service Request 9 */

/** Alias (User Manual Name) for SRC_CAN_CAN2_INT9.
* To use register names with standard convension, please use SRC_CAN_CAN2_INT9.
*/


/** \brief 658, CAN2 Service Request 10 */

/** Alias (User Manual Name) for SRC_CAN_CAN2_INT10.
* To use register names with standard convension, please use SRC_CAN_CAN2_INT10.
*/


/** \brief 65C, CAN2 Service Request 11 */

/** Alias (User Manual Name) for SRC_CAN_CAN2_INT11.
* To use register names with standard convension, please use SRC_CAN_CAN2_INT11.
*/


/** \brief 660, CAN2 Service Request 12 */

/** Alias (User Manual Name) for SRC_CAN_CAN2_INT12.
* To use register names with standard convension, please use SRC_CAN_CAN2_INT12.
*/


/** \brief 664, CAN2 Service Request 13 */

/** Alias (User Manual Name) for SRC_CAN_CAN2_INT13.
* To use register names with standard convension, please use SRC_CAN_CAN2_INT13.
*/


/** \brief 668, CAN2 Service Request 14 */

/** Alias (User Manual Name) for SRC_CAN_CAN2_INT14.
* To use register names with standard convension, please use SRC_CAN_CAN2_INT14.
*/


/** \brief 66C, CAN2 Service Request 15 */

/** Alias (User Manual Name) for SRC_CAN_CAN2_INT15.
* To use register names with standard convension, please use SRC_CAN_CAN2_INT15.
*/


/** \brief 670, EVADC Group 0 Service Request 0 */

/** Alias (User Manual Name) for SRC_VADC_G0_SR0.
* To use register names with standard convension, please use SRC_VADC_G0_SR0.
*/


/** \brief 674, EVADC Group 0 Service Request 1 */

/** Alias (User Manual Name) for SRC_VADC_G0_SR1.
* To use register names with standard convension, please use SRC_VADC_G0_SR1.
*/


/** \brief 678, EVADC Group 0 Service Request 2 */

/** Alias (User Manual Name) for SRC_VADC_G0_SR2.
* To use register names with standard convension, please use SRC_VADC_G0_SR2.
*/


/** \brief 67C, EVADC Group 0 Service Request 3 */

/** Alias (User Manual Name) for SRC_VADC_G0_SR3.
* To use register names with standard convension, please use SRC_VADC_G0_SR3.
*/


/** \brief 680, EVADC Group 1 Service Request 0 */

/** Alias (User Manual Name) for SRC_VADC_G1_SR0.
* To use register names with standard convension, please use SRC_VADC_G1_SR0.
*/


/** \brief 684, EVADC Group 1 Service Request 1 */

/** Alias (User Manual Name) for SRC_VADC_G1_SR1.
* To use register names with standard convension, please use SRC_VADC_G1_SR1.
*/


/** \brief 688, EVADC Group 1 Service Request 2 */

/** Alias (User Manual Name) for SRC_VADC_G1_SR2.
* To use register names with standard convension, please use SRC_VADC_G1_SR2.
*/


/** \brief 68C, EVADC Group 1 Service Request 3 */

/** Alias (User Manual Name) for SRC_VADC_G1_SR3.
* To use register names with standard convension, please use SRC_VADC_G1_SR3.
*/


/** \brief 690, EVADC Group 2 Service Request 0 */

/** Alias (User Manual Name) for SRC_VADC_G2_SR0.
* To use register names with standard convension, please use SRC_VADC_G2_SR0.
*/


/** \brief 694, EVADC Group 2 Service Request 1 */

/** Alias (User Manual Name) for SRC_VADC_G2_SR1.
* To use register names with standard convension, please use SRC_VADC_G2_SR1.
*/


/** \brief 698, EVADC Group 2 Service Request 2 */

/** Alias (User Manual Name) for SRC_VADC_G2_SR2.
* To use register names with standard convension, please use SRC_VADC_G2_SR2.
*/


/** \brief 69C, EVADC Group 2 Service Request 3 */

/** Alias (User Manual Name) for SRC_VADC_G2_SR3.
* To use register names with standard convension, please use SRC_VADC_G2_SR3.
*/


/** \brief 6A0, EVADC Group 3 Service Request 0 */

/** Alias (User Manual Name) for SRC_VADC_G3_SR0.
* To use register names with standard convension, please use SRC_VADC_G3_SR0.
*/


/** \brief 6A4, EVADC Group 3 Service Request 1 */

/** Alias (User Manual Name) for SRC_VADC_G3_SR1.
* To use register names with standard convension, please use SRC_VADC_G3_SR1.
*/


/** \brief 6A8, EVADC Group 3 Service Request 2 */

/** Alias (User Manual Name) for SRC_VADC_G3_SR2.
* To use register names with standard convension, please use SRC_VADC_G3_SR2.
*/


/** \brief 6AC, EVADC Group 3 Service Request 3 */

/** Alias (User Manual Name) for SRC_VADC_G3_SR3.
* To use register names with standard convension, please use SRC_VADC_G3_SR3.
*/


/** \brief 6B0, EVADC Group 4 Service Request 0 */

/** Alias (User Manual Name) for SRC_VADC_G4_SR0.
* To use register names with standard convension, please use SRC_VADC_G4_SR0.
*/


/** \brief 6B4, EVADC Group 4 Service Request 1 */

/** Alias (User Manual Name) for SRC_VADC_G4_SR1.
* To use register names with standard convension, please use SRC_VADC_G4_SR1.
*/


/** \brief 6B8, EVADC Group 4 Service Request 2 */

/** Alias (User Manual Name) for SRC_VADC_G4_SR2.
* To use register names with standard convension, please use SRC_VADC_G4_SR2.
*/


/** \brief 6BC, EVADC Group 4 Service Request 3 */

/** Alias (User Manual Name) for SRC_VADC_G4_SR3.
* To use register names with standard convension, please use SRC_VADC_G4_SR3.
*/


/** \brief 6C0, EVADC Group 5 Service Request 0 */

/** Alias (User Manual Name) for SRC_VADC_G5_SR0.
* To use register names with standard convension, please use SRC_VADC_G5_SR0.
*/


/** \brief 6C4, EVADC Group 5 Service Request 1 */

/** Alias (User Manual Name) for SRC_VADC_G5_SR1.
* To use register names with standard convension, please use SRC_VADC_G5_SR1.
*/


/** \brief 6C8, EVADC Group 5 Service Request 2 */

/** Alias (User Manual Name) for SRC_VADC_G5_SR2.
* To use register names with standard convension, please use SRC_VADC_G5_SR2.
*/


/** \brief 6CC, EVADC Group 5 Service Request 3 */

/** Alias (User Manual Name) for SRC_VADC_G5_SR3.
* To use register names with standard convension, please use SRC_VADC_G5_SR3.
*/


/** \brief 6D0, EVADC Group 6 Service Request 0 */

/** Alias (User Manual Name) for SRC_VADC_G6_SR0.
* To use register names with standard convension, please use SRC_VADC_G6_SR0.
*/


/** \brief 6D4, EVADC Group 6 Service Request 1 */

/** Alias (User Manual Name) for SRC_VADC_G6_SR1.
* To use register names with standard convension, please use SRC_VADC_G6_SR1.
*/


/** \brief 6D8, EVADC Group 6 Service Request 2 */

/** Alias (User Manual Name) for SRC_VADC_G6_SR2.
* To use register names with standard convension, please use SRC_VADC_G6_SR2.
*/


/** \brief 6DC, EVADC Group 6 Service Request 3 */

/** Alias (User Manual Name) for SRC_VADC_G6_SR3.
* To use register names with standard convension, please use SRC_VADC_G6_SR3.
*/


/** \brief 6E0, EVADC Group 7 Service Request 0 */

/** Alias (User Manual Name) for SRC_VADC_G7_SR0.
* To use register names with standard convension, please use SRC_VADC_G7_SR0.
*/


/** \brief 6E4, EVADC Group 7 Service Request 1 */

/** Alias (User Manual Name) for SRC_VADC_G7_SR1.
* To use register names with standard convension, please use SRC_VADC_G7_SR1.
*/


/** \brief 6E8, EVADC Group 7 Service Request 2 */

/** Alias (User Manual Name) for SRC_VADC_G7_SR2.
* To use register names with standard convension, please use SRC_VADC_G7_SR2.
*/


/** \brief 6EC, EVADC Group 7 Service Request 3 */

/** Alias (User Manual Name) for SRC_VADC_G7_SR3.
* To use register names with standard convension, please use SRC_VADC_G7_SR3.
*/


/** \brief 6F0, EVADC Group 8 Service Request 0 */

/** Alias (User Manual Name) for SRC_VADC_G8_SR0.
* To use register names with standard convension, please use SRC_VADC_G8_SR0.
*/


/** \brief 6F4, EVADC Group 8 Service Request 1 */

/** Alias (User Manual Name) for SRC_VADC_G8_SR1.
* To use register names with standard convension, please use SRC_VADC_G8_SR1.
*/


/** \brief 6F8, EVADC Group 8 Service Request 2 */

/** Alias (User Manual Name) for SRC_VADC_G8_SR2.
* To use register names with standard convension, please use SRC_VADC_G8_SR2.
*/


/** \brief 6FC, EVADC Group 8 Service Request 3 */

/** Alias (User Manual Name) for SRC_VADC_G8_SR3.
* To use register names with standard convension, please use SRC_VADC_G8_SR3.
*/


/** \brief 700, EVADC Group 9 Service Request 0 */

/** Alias (User Manual Name) for SRC_VADC_G9_SR0.
* To use register names with standard convension, please use SRC_VADC_G9_SR0.
*/


/** \brief 704, EVADC Group 9 Service Request 1 */

/** Alias (User Manual Name) for SRC_VADC_G9_SR1.
* To use register names with standard convension, please use SRC_VADC_G9_SR1.
*/


/** \brief 708, EVADC Group 9 Service Request 2 */

/** Alias (User Manual Name) for SRC_VADC_G9_SR2.
* To use register names with standard convension, please use SRC_VADC_G9_SR2.
*/


/** \brief 70C, EVADC Group 9 Service Request 3 */

/** Alias (User Manual Name) for SRC_VADC_G9_SR3.
* To use register names with standard convension, please use SRC_VADC_G9_SR3.
*/


/** \brief 710, EVADC Group 10 Service Request 0 */

/** Alias (User Manual Name) for SRC_VADC_G10_SR0.
* To use register names with standard convension, please use SRC_VADC_G10_SR0.
*/


/** \brief 714, EVADC Group 10 Service Request 1 */

/** Alias (User Manual Name) for SRC_VADC_G10_SR1.
* To use register names with standard convension, please use SRC_VADC_G10_SR1.
*/


/** \brief 718, EVADC Group 10 Service Request 2 */

/** Alias (User Manual Name) for SRC_VADC_G10_SR2.
* To use register names with standard convension, please use SRC_VADC_G10_SR2.
*/


/** \brief 71C, EVADC Group 10 Service Request 3 */

/** Alias (User Manual Name) for SRC_VADC_G10_SR3.
* To use register names with standard convension, please use SRC_VADC_G10_SR3.
*/


/** \brief 720, EVADC Group 11 Service Request 0 */

/** Alias (User Manual Name) for SRC_VADC_G11_SR0.
* To use register names with standard convension, please use SRC_VADC_G11_SR0.
*/


/** \brief 724, EVADC Group 11 Service Request 1 */

/** Alias (User Manual Name) for SRC_VADC_G11_SR1.
* To use register names with standard convension, please use SRC_VADC_G11_SR1.
*/


/** \brief 728, EVADC Group 11 Service Request 2 */

/** Alias (User Manual Name) for SRC_VADC_G11_SR2.
* To use register names with standard convension, please use SRC_VADC_G11_SR2.
*/


/** \brief 72C, EVADC Group 11 Service Request 3 */

/** Alias (User Manual Name) for SRC_VADC_G11_SR3.
* To use register names with standard convension, please use SRC_VADC_G11_SR3.
*/


/** \brief 730, EVADC Fast Compare 0 Service Request SR0 */

/** Alias (User Manual Name) for SRC_VADC_FC0_SR0.
* To use register names with standard convension, please use SRC_VADC_FC0_SR0.
*/


/** \brief 734, EVADC Fast Compare 1 Service Request SR0 */

/** Alias (User Manual Name) for SRC_VADC_FC1_SR0.
* To use register names with standard convension, please use SRC_VADC_FC1_SR0.
*/


/** \brief 738, EVADC Fast Compare 2 Service Request SR0 */

/** Alias (User Manual Name) for SRC_VADC_FC2_SR0.
* To use register names with standard convension, please use SRC_VADC_FC2_SR0.
*/


/** \brief 73C, EVADC Fast Compare 3 Service Request SR0 */

/** Alias (User Manual Name) for SRC_VADC_FC3_SR0.
* To use register names with standard convension, please use SRC_VADC_FC3_SR0.
*/


/** \brief 750, EVADC Common Group 0 Service Request 0 */

/** Alias (User Manual Name) for SRC_VADC_CG0_SR0.
* To use register names with standard convension, please use SRC_VADC_CG0_SR0.
*/


/** \brief 754, EVADC Common Group 0 Service Request 1 */

/** Alias (User Manual Name) for SRC_VADC_CG0_SR1.
* To use register names with standard convension, please use SRC_VADC_CG0_SR1.
*/


/** \brief 758, EVADC Common Group 0 Service Request 2 */

/** Alias (User Manual Name) for SRC_VADC_CG0_SR2.
* To use register names with standard convension, please use SRC_VADC_CG0_SR2.
*/


/** \brief 75C, EVADC Common Group 0 Service Request 3 */

/** Alias (User Manual Name) for SRC_VADC_CG0_SR3.
* To use register names with standard convension, please use SRC_VADC_CG0_SR3.
*/


/** \brief 760, EVADC Common Group 1 Service Request 0 */

/** Alias (User Manual Name) for SRC_VADC_CG1_SR0.
* To use register names with standard convension, please use SRC_VADC_CG1_SR0.
*/


/** \brief 764, EVADC Common Group 1 Service Request 1 */

/** Alias (User Manual Name) for SRC_VADC_CG1_SR1.
* To use register names with standard convension, please use SRC_VADC_CG1_SR1.
*/


/** \brief 768, EVADC Common Group 1 Service Request 2 */

/** Alias (User Manual Name) for SRC_VADC_CG1_SR2.
* To use register names with standard convension, please use SRC_VADC_CG1_SR2.
*/


/** \brief 76C, EVADC Common Group 1 Service Request 3 */

/** Alias (User Manual Name) for SRC_VADC_CG1_SR3.
* To use register names with standard convension, please use SRC_VADC_CG1_SR3.
*/


/** \brief 770, DSADC SRM0 Service Request */

/** Alias (User Manual Name) for SRC_DSADC_DSADC0_SRM.
* To use register names with standard convension, please use SRC_DSADC_DSADC0_SRM.
*/


/** \brief 774, DSADC SRA0 Service Request */

/** Alias (User Manual Name) for SRC_DSADC_DSADC0_SRA.
* To use register names with standard convension, please use SRC_DSADC_DSADC0_SRA.
*/


/** \brief 778, DSADC SRM1 Service Request */

/** Alias (User Manual Name) for SRC_DSADC_DSADC1_SRM.
* To use register names with standard convension, please use SRC_DSADC_DSADC1_SRM.
*/


/** \brief 77C, DSADC SRA1 Service Request */

/** Alias (User Manual Name) for SRC_DSADC_DSADC1_SRA.
* To use register names with standard convension, please use SRC_DSADC_DSADC1_SRA.
*/


/** \brief 780, DSADC SRM2 Service Request */

/** Alias (User Manual Name) for SRC_DSADC_DSADC2_SRM.
* To use register names with standard convension, please use SRC_DSADC_DSADC2_SRM.
*/


/** \brief 784, DSADC SRA2 Service Request */

/** Alias (User Manual Name) for SRC_DSADC_DSADC2_SRA.
* To use register names with standard convension, please use SRC_DSADC_DSADC2_SRA.
*/


/** \brief 788, DSADC SRM3 Service Request */

/** Alias (User Manual Name) for SRC_DSADC_DSADC3_SRM.
* To use register names with standard convension, please use SRC_DSADC_DSADC3_SRM.
*/


/** \brief 78C, DSADC SRA3 Service Request */

/** Alias (User Manual Name) for SRC_DSADC_DSADC3_SRA.
* To use register names with standard convension, please use SRC_DSADC_DSADC3_SRA.
*/


/** \brief 790, DSADC SRM4 Service Request */

/** Alias (User Manual Name) for SRC_DSADC_DSADC4_SRM.
* To use register names with standard convension, please use SRC_DSADC_DSADC4_SRM.
*/


/** \brief 794, DSADC SRA4 Service Request */

/** Alias (User Manual Name) for SRC_DSADC_DSADC4_SRA.
* To use register names with standard convension, please use SRC_DSADC_DSADC4_SRA.
*/


/** \brief 798, DSADC SRM5 Service Request */

/** Alias (User Manual Name) for SRC_DSADC_DSADC5_SRM.
* To use register names with standard convension, please use SRC_DSADC_DSADC5_SRM.
*/


/** \brief 79C, DSADC SRA5 Service Request */

/** Alias (User Manual Name) for SRC_DSADC_DSADC5_SRA.
* To use register names with standard convension, please use SRC_DSADC_DSADC5_SRA.
*/


/** \brief 7A0, DSADC SRM6 Service Request */

/** Alias (User Manual Name) for SRC_DSADC_DSADC6_SRM.
* To use register names with standard convension, please use SRC_DSADC_DSADC6_SRM.
*/


/** \brief 7A4, DSADC SRA6 Service Request */

/** Alias (User Manual Name) for SRC_DSADC_DSADC6_SRA.
* To use register names with standard convension, please use SRC_DSADC_DSADC6_SRA.
*/


/** \brief 7A8, DSADC SRM7 Service Request */

/** Alias (User Manual Name) for SRC_DSADC_DSADC7_SRM.
* To use register names with standard convension, please use SRC_DSADC_DSADC7_SRM.
*/


/** \brief 7AC, DSADC SRA7 Service Request */

/** Alias (User Manual Name) for SRC_DSADC_DSADC7_SRA.
* To use register names with standard convension, please use SRC_DSADC_DSADC7_SRA.
*/


/** \brief 7B0, DSADC SRM8 Service Request */

/** Alias (User Manual Name) for SRC_DSADC_DSADC8_SRM.
* To use register names with standard convension, please use SRC_DSADC_DSADC8_SRM.
*/


/** \brief 7B4, DSADC SRA8 Service Request */

/** Alias (User Manual Name) for SRC_DSADC_DSADC8_SRA.
* To use register names with standard convension, please use SRC_DSADC_DSADC8_SRA.
*/


/** \brief 7B8, DSADC SRM9 Service Request */

/** Alias (User Manual Name) for SRC_DSADC_DSADC9_SRM.
* To use register names with standard convension, please use SRC_DSADC_DSADC9_SRM.
*/


/** \brief 7BC, DSADC SRA9 Service Request */

/** Alias (User Manual Name) for SRC_DSADC_DSADC9_SRA.
* To use register names with standard convension, please use SRC_DSADC_DSADC9_SRA.
*/


/** \brief 7E0, ASCLIN12 Transmit Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN12_TX.
* To use register names with standard convension, please use SRC_ASCLIN12_TX.
*/


/** \brief 7E4, ASCLIN12 Receive Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN12_RX.
* To use register names with standard convension, please use SRC_ASCLIN12_RX.
*/


/** \brief 7E8, ASCLIN12 Error Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN12_ERR.
* To use register names with standard convension, please use SRC_ASCLIN12_ERR.
*/


/** \brief 7EC, ASCLIN13 Transmit Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN13_TX.
* To use register names with standard convension, please use SRC_ASCLIN13_TX.
*/


/** \brief 7F0, ASCLIN13 Receive Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN13_RX.
* To use register names with standard convension, please use SRC_ASCLIN13_RX.
*/


/** \brief 7F4, ASCLIN13 Error Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN13_ERR.
* To use register names with standard convension, please use SRC_ASCLIN13_ERR.
*/


/** \brief 800, E-RAY 0 Service Request 0 */

/** Alias (User Manual Name) for SRC_ERAY_ERAY0_INT0.
* To use register names with standard convension, please use SRC_ERAY_ERAY0_INT0.
*/


/** \brief 804, E-RAY 0 Service Request 1 */

/** Alias (User Manual Name) for SRC_ERAY_ERAY0_INT1.
* To use register names with standard convension, please use SRC_ERAY_ERAY0_INT1.
*/


/** \brief 808, E-RAY 0 Timer Interrupt 0 Service Request */

/** Alias (User Manual Name) for SRC_ERAY_ERAY0_TINT0.
* To use register names with standard convension, please use SRC_ERAY_ERAY0_TINT0.
*/


/** \brief 80C, E-RAY 0 Timer Interrupt 1 Service Request */

/** Alias (User Manual Name) for SRC_ERAY_ERAY0_TINT1.
* To use register names with standard convension, please use SRC_ERAY_ERAY0_TINT1.
*/


/** \brief 810, E-RAY 0 New Data 0 Service Request */

/** Alias (User Manual Name) for SRC_ERAY_ERAY0_NDAT0.
* To use register names with standard convension, please use SRC_ERAY_ERAY0_NDAT0.
*/


/** \brief 814, E-RAY 0 New Data 1 Service Request */

/** Alias (User Manual Name) for SRC_ERAY_ERAY0_NDAT1.
* To use register names with standard convension, please use SRC_ERAY_ERAY0_NDAT1.
*/


/** \brief 818, E-RAY 0 Message Buffer Status Changed 0 Service Request */

/** Alias (User Manual Name) for SRC_ERAY_ERAY0_MBSC0.
* To use register names with standard convension, please use SRC_ERAY_ERAY0_MBSC0.
*/


/** \brief 81C, E-RAY 0 Message Buffer Status Changed 1 Service Request */

/** Alias (User Manual Name) for SRC_ERAY_ERAY0_MBSC1.
* To use register names with standard convension, please use SRC_ERAY_ERAY0_MBSC1.
*/


/** \brief 820, E-RAY 0 Output Buffer Busy */

/** Alias (User Manual Name) for SRC_ERAY_ERAY0_OBUSY.
* To use register names with standard convension, please use SRC_ERAY_ERAY0_OBUSY.
*/


/** \brief 824, E-RAY 0 Input Buffer Busy */

/** Alias (User Manual Name) for SRC_ERAY_ERAY0_IBUSY.
* To use register names with standard convension, please use SRC_ERAY_ERAY0_IBUSY.
*/


/** \brief 830, E-RAY 1 Service Request 0 */

/** Alias (User Manual Name) for SRC_ERAY_ERAY1_INT0.
* To use register names with standard convension, please use SRC_ERAY_ERAY1_INT0.
*/


/** \brief 834, E-RAY 1 Service Request 1 */

/** Alias (User Manual Name) for SRC_ERAY_ERAY1_INT1.
* To use register names with standard convension, please use SRC_ERAY_ERAY1_INT1.
*/


/** \brief 838, E-RAY 1 Timer Interrupt 0 Service Request */

/** Alias (User Manual Name) for SRC_ERAY_ERAY1_TINT0.
* To use register names with standard convension, please use SRC_ERAY_ERAY1_TINT0.
*/


/** \brief 83C, E-RAY 1 Timer Interrupt 1 Service Request */

/** Alias (User Manual Name) for SRC_ERAY_ERAY1_TINT1.
* To use register names with standard convension, please use SRC_ERAY_ERAY1_TINT1.
*/


/** \brief 840, E-RAY 1 New Data 0 Service Request */

/** Alias (User Manual Name) for SRC_ERAY_ERAY1_NDAT0.
* To use register names with standard convension, please use SRC_ERAY_ERAY1_NDAT0.
*/


/** \brief 844, E-RAY 1 New Data 1 Service Request */

/** Alias (User Manual Name) for SRC_ERAY_ERAY1_NDAT1.
* To use register names with standard convension, please use SRC_ERAY_ERAY1_NDAT1.
*/


/** \brief 848, E-RAY 1 Message Buffer Status Changed 0 Service Request */

/** Alias (User Manual Name) for SRC_ERAY_ERAY1_MBSC0.
* To use register names with standard convension, please use SRC_ERAY_ERAY1_MBSC0.
*/


/** \brief 84C, E-RAY 1 Message Buffer Status Changed 1 Service Request */

/** Alias (User Manual Name) for SRC_ERAY_ERAY1_MBSC1.
* To use register names with standard convension, please use SRC_ERAY_ERAY1_MBSC1.
*/


/** \brief 850, E-RAY 1 Output Buffer Busy */

/** Alias (User Manual Name) for SRC_ERAY_ERAY1_OBUSY.
* To use register names with standard convension, please use SRC_ERAY_ERAY1_OBUSY.
*/


/** \brief 854, E-RAY 1 Input Buffer Busy */

/** Alias (User Manual Name) for SRC_ERAY_ERAY1_IBUSY.
* To use register names with standard convension, please use SRC_ERAY_ERAY1_IBUSY.
*/


/** \brief 860, DMU Host Service Request */


/** \brief 864, DMU FSI Service Request */


/** \brief 870, HSM Service Request 0 */

/** Alias (User Manual Name) for SRC_HSM_HSM0_HSM0.
* To use register names with standard convension, please use SRC_HSM_HSM0_HSM0.
*/


/** \brief 874, HSM Service Request 1 */

/** Alias (User Manual Name) for SRC_HSM_HSM0_HSM1.
* To use register names with standard convension, please use SRC_HSM_HSM0_HSM1.
*/


/** \brief 880, SCU ERU Service Request 0 */

/** Alias (User Manual Name) for SRC_SCU_SCUERU0.
* To use register names with standard convension, please use SRC_SCU_SCUERU0.
*/


/** \brief 884, SCU ERU Service Request 1 */

/** Alias (User Manual Name) for SRC_SCU_SCUERU1.
* To use register names with standard convension, please use SRC_SCU_SCUERU1.
*/


/** \brief 888, SCU ERU Service Request 2 */

/** Alias (User Manual Name) for SRC_SCU_SCUERU2.
* To use register names with standard convension, please use SRC_SCU_SCUERU2.
*/


/** \brief 88C, SCU ERU Service Request 3 */

/** Alias (User Manual Name) for SRC_SCU_SCUERU3.
* To use register names with standard convension, please use SRC_SCU_SCUERU3.
*/


/** \brief 8AC, PMS DTS Service Request */


/** \brief 8B0, Power Management System Service Request 0 */

/** Alias (User Manual Name) for SRC_PMS_PMS0_SR.
* To use register names with standard convension, please use SRC_PMS_PMS0_SR.
*/


/** \brief 8B4, Power Management System Service Request 1 */

/** Alias (User Manual Name) for SRC_PMS_PMS1_SR.
* To use register names with standard convension, please use SRC_PMS_PMS1_SR.
*/


/** \brief 8B8, Power Management System Service Request 2 */

/** Alias (User Manual Name) for SRC_PMS_PMS2_SR.
* To use register names with standard convension, please use SRC_PMS_PMS2_SR.
*/


/** \brief 8BC, Power Management System Service Request 3 */

/** Alias (User Manual Name) for SRC_PMS_PMS3_SR.
* To use register names with standard convension, please use SRC_PMS_PMS3_SR.
*/


/** \brief 8C0, Stand By Controller Service Request */


/** \brief 8D0, SMU Service Request 0 */

/** Alias (User Manual Name) for SRC_SMU_SMU0_SR0.
* To use register names with standard convension, please use SRC_SMU_SMU0_SR0.
*/


/** \brief 8D4, SMU Service Request 1 */

/** Alias (User Manual Name) for SRC_SMU_SMU0_SR1.
* To use register names with standard convension, please use SRC_SMU_SMU0_SR1.
*/


/** \brief 8D8, SMU Service Request 2 */

/** Alias (User Manual Name) for SRC_SMU_SMU0_SR2.
* To use register names with standard convension, please use SRC_SMU_SMU0_SR2.
*/


/** \brief 8E0, PSI5 Service Request 0 */

/** Alias (User Manual Name) for SRC_PSI5_PSI50_SR0.
* To use register names with standard convension, please use SRC_PSI5_PSI50_SR0.
*/


/** \brief 8E4, PSI5 Service Request 1 */

/** Alias (User Manual Name) for SRC_PSI5_PSI50_SR1.
* To use register names with standard convension, please use SRC_PSI5_PSI50_SR1.
*/


/** \brief 8E8, PSI5 Service Request 2 */

/** Alias (User Manual Name) for SRC_PSI5_PSI50_SR2.
* To use register names with standard convension, please use SRC_PSI5_PSI50_SR2.
*/


/** \brief 8EC, PSI5 Service Request 3 */

/** Alias (User Manual Name) for SRC_PSI5_PSI50_SR3.
* To use register names with standard convension, please use SRC_PSI5_PSI50_SR3.
*/


/** \brief 8F0, PSI5 Service Request 4 */

/** Alias (User Manual Name) for SRC_PSI5_PSI50_SR4.
* To use register names with standard convension, please use SRC_PSI5_PSI50_SR4.
*/


/** \brief 8F4, PSI5 Service Request 5 */

/** Alias (User Manual Name) for SRC_PSI5_PSI50_SR5.
* To use register names with standard convension, please use SRC_PSI5_PSI50_SR5.
*/


/** \brief 8F8, PSI5 Service Request 6 */

/** Alias (User Manual Name) for SRC_PSI5_PSI50_SR6.
* To use register names with standard convension, please use SRC_PSI5_PSI50_SR6.
*/


/** \brief 8FC, PSI5 Service Request 7 */

/** Alias (User Manual Name) for SRC_PSI5_PSI50_SR7.
* To use register names with standard convension, please use SRC_PSI5_PSI50_SR7.
*/


/** \brief 910, DAM0 Limit 0 Service Request */

/** Alias (User Manual Name) for SRC_DAM_DAM0_LI0.
* To use register names with standard convension, please use SRC_DAM_DAM0_LI0.
*/


/** \brief 914, DAM0 Ready 0 Service Reques */

/** Alias (User Manual Name) for SRC_DAM_DAM0_RI0.
* To use register names with standard convension, please use SRC_DAM_DAM0_RI0.
*/


/** \brief 918, DAM0 Limit 1 Service Request */

/** Alias (User Manual Name) for SRC_DAM_DAM0_LI1.
* To use register names with standard convension, please use SRC_DAM_DAM0_LI1.
*/


/** \brief 91C, DAM0 Ready 1 Service Request */

/** Alias (User Manual Name) for SRC_DAM_DAM0_RI1.
* To use register names with standard convension, please use SRC_DAM_DAM0_RI1.
*/


/** \brief 920, DAM0 DMA Ready Service Request */

/** Alias (User Manual Name) for SRC_DAM_DAM0_DR.
* To use register names with standard convension, please use SRC_DAM_DAM0_DR.
*/


/** \brief 924, DAM0 Error Service Request */

/** Alias (User Manual Name) for SRC_DAM_DAM0_ERR.
* To use register names with standard convension, please use SRC_DAM_DAM0_ERR.
*/


/** \brief 950, PSI5-S Service Request 0 */

/** Alias (User Manual Name) for SRC_PSI5S_PSI5S0_SR0.
* To use register names with standard convension, please use SRC_PSI5S_PSI5S0_SR0.
*/


/** \brief 954, PSI5-S Service Request 1 */

/** Alias (User Manual Name) for SRC_PSI5S_PSI5S0_SR1.
* To use register names with standard convension, please use SRC_PSI5S_PSI5S0_SR1.
*/


/** \brief 958, PSI5-S Service Request 2 */

/** Alias (User Manual Name) for SRC_PSI5S_PSI5S0_SR2.
* To use register names with standard convension, please use SRC_PSI5S_PSI5S0_SR2.
*/


/** \brief 95C, PSI5-S Service Request 3 */

/** Alias (User Manual Name) for SRC_PSI5S_PSI5S0_SR3.
* To use register names with standard convension, please use SRC_PSI5S_PSI5S0_SR3.
*/


/** \brief 960, PSI5-S Service Request 4 */

/** Alias (User Manual Name) for SRC_PSI5S_PSI5S0_SR4.
* To use register names with standard convension, please use SRC_PSI5S_PSI5S0_SR4.
*/


/** \brief 964, PSI5-S Service Request 5 */

/** Alias (User Manual Name) for SRC_PSI5S_PSI5S0_SR5.
* To use register names with standard convension, please use SRC_PSI5S_PSI5S0_SR5.
*/


/** \brief 968, PSI5-S Service Request 6 */

/** Alias (User Manual Name) for SRC_PSI5S_PSI5S0_SR6.
* To use register names with standard convension, please use SRC_PSI5S_PSI5S0_SR6.
*/


/** \brief 96C, PSI5-S Service Request 7 */

/** Alias (User Manual Name) for SRC_PSI5S_PSI5S0_SR7.
* To use register names with standard convension, please use SRC_PSI5S_PSI5S0_SR7.
*/


/** \brief 990, General Purpose Group 0 Service Request 0 */

/** Alias (User Manual Name) for SRC_GPSR_GPSR0_SR0.
* To use register names with standard convension, please use SRC_GPSR_GPSR0_SR0.
*/


/** \brief 994, General Purpose Group 0 Service Request 1 */

/** Alias (User Manual Name) for SRC_GPSR_GPSR0_SR1.
* To use register names with standard convension, please use SRC_GPSR_GPSR0_SR1.
*/


/** \brief 998, General Purpose Group 0 Service Request 2 */

/** Alias (User Manual Name) for SRC_GPSR_GPSR0_SR2.
* To use register names with standard convension, please use SRC_GPSR_GPSR0_SR2.
*/


/** \brief 99C, General Purpose Group 0 Service Request 3 */

/** Alias (User Manual Name) for SRC_GPSR_GPSR0_SR3.
* To use register names with standard convension, please use SRC_GPSR_GPSR0_SR3.
*/


/** \brief 9A0, General Purpose Group 0 Service Request 4 */

/** Alias (User Manual Name) for SRC_GPSR_GPSR0_SR4.
* To use register names with standard convension, please use SRC_GPSR_GPSR0_SR4.
*/


/** \brief 9A4, General Purpose Group 0 Service Request 5 */

/** Alias (User Manual Name) for SRC_GPSR_GPSR0_SR5.
* To use register names with standard convension, please use SRC_GPSR_GPSR0_SR5.
*/


/** \brief 9A8, General Purpose Group 0 Service Request 6 */

/** Alias (User Manual Name) for SRC_GPSR_GPSR0_SR6.
* To use register names with standard convension, please use SRC_GPSR_GPSR0_SR6.
*/


/** \brief 9AC, General Purpose Group 0 Service Request 7 */

/** Alias (User Manual Name) for SRC_GPSR_GPSR0_SR7.
* To use register names with standard convension, please use SRC_GPSR_GPSR0_SR7.
*/


/** \brief 9B0, General Purpose Group 1 Service Request 0 */

/** Alias (User Manual Name) for SRC_GPSR_GPSR1_SR0.
* To use register names with standard convension, please use SRC_GPSR_GPSR1_SR0.
*/


/** \brief 9B4, General Purpose Group 1 Service Request 1 */

/** Alias (User Manual Name) for SRC_GPSR_GPSR1_SR1.
* To use register names with standard convension, please use SRC_GPSR_GPSR1_SR1.
*/


/** \brief 9B8, General Purpose Group 1 Service Request 2 */

/** Alias (User Manual Name) for SRC_GPSR_GPSR1_SR2.
* To use register names with standard convension, please use SRC_GPSR_GPSR1_SR2.
*/


/** \brief 9BC, General Purpose Group 1 Service Request 3 */

/** Alias (User Manual Name) for SRC_GPSR_GPSR1_SR3.
* To use register names with standard convension, please use SRC_GPSR_GPSR1_SR3.
*/


/** \brief 9C0, General Purpose Group 1 Service Request 4 */

/** Alias (User Manual Name) for SRC_GPSR_GPSR1_SR4.
* To use register names with standard convension, please use SRC_GPSR_GPSR1_SR4.
*/


/** \brief 9C4, General Purpose Group 1 Service Request 5 */

/** Alias (User Manual Name) for SRC_GPSR_GPSR1_SR5.
* To use register names with standard convension, please use SRC_GPSR_GPSR1_SR5.
*/


/** \brief 9C8, General Purpose Group 1 Service Request 6 */

/** Alias (User Manual Name) for SRC_GPSR_GPSR1_SR6.
* To use register names with standard convension, please use SRC_GPSR_GPSR1_SR6.
*/


/** \brief 9CC, General Purpose Group 1 Service Request 7 */

/** Alias (User Manual Name) for SRC_GPSR_GPSR1_SR7.
* To use register names with standard convension, please use SRC_GPSR_GPSR1_SR7.
*/


/** \brief 9D0, General Purpose Group 2 Service Request 0 */

/** Alias (User Manual Name) for SRC_GPSR_GPSR2_SR0.
* To use register names with standard convension, please use SRC_GPSR_GPSR2_SR0.
*/


/** \brief 9D4, General Purpose Group 2 Service Request 1 */

/** Alias (User Manual Name) for SRC_GPSR_GPSR2_SR1.
* To use register names with standard convension, please use SRC_GPSR_GPSR2_SR1.
*/


/** \brief 9D8, General Purpose Group 2 Service Request 2 */

/** Alias (User Manual Name) for SRC_GPSR_GPSR2_SR2.
* To use register names with standard convension, please use SRC_GPSR_GPSR2_SR2.
*/


/** \brief 9DC, General Purpose Group 2 Service Request 3 */

/** Alias (User Manual Name) for SRC_GPSR_GPSR2_SR3.
* To use register names with standard convension, please use SRC_GPSR_GPSR2_SR3.
*/


/** \brief 9E0, General Purpose Group 2 Service Request 4 */

/** Alias (User Manual Name) for SRC_GPSR_GPSR2_SR4.
* To use register names with standard convension, please use SRC_GPSR_GPSR2_SR4.
*/


/** \brief 9E4, General Purpose Group 2 Service Request 5 */

/** Alias (User Manual Name) for SRC_GPSR_GPSR2_SR5.
* To use register names with standard convension, please use SRC_GPSR_GPSR2_SR5.
*/


/** \brief 9E8, General Purpose Group 2 Service Request 6 */

/** Alias (User Manual Name) for SRC_GPSR_GPSR2_SR6.
* To use register names with standard convension, please use SRC_GPSR_GPSR2_SR6.
*/


/** \brief 9EC, General Purpose Group 2 Service Request 7 */

/** Alias (User Manual Name) for SRC_GPSR_GPSR2_SR7.
* To use register names with standard convension, please use SRC_GPSR_GPSR2_SR7.
*/


/** \brief 9F0, General Purpose Group 3 Service Request 0 */

/** Alias (User Manual Name) for SRC_GPSR_GPSR3_SR0.
* To use register names with standard convension, please use SRC_GPSR_GPSR3_SR0.
*/


/** \brief 9F4, General Purpose Group 3 Service Request 1 */

/** Alias (User Manual Name) for SRC_GPSR_GPSR3_SR1.
* To use register names with standard convension, please use SRC_GPSR_GPSR3_SR1.
*/


/** \brief 9F8, General Purpose Group 3 Service Request 2 */

/** Alias (User Manual Name) for SRC_GPSR_GPSR3_SR2.
* To use register names with standard convension, please use SRC_GPSR_GPSR3_SR2.
*/


/** \brief 9FC, General Purpose Group 3 Service Request 3 */

/** Alias (User Manual Name) for SRC_GPSR_GPSR3_SR3.
* To use register names with standard convension, please use SRC_GPSR_GPSR3_SR3.
*/


/** \brief A00, General Purpose Group 3 Service Request 4 */

/** Alias (User Manual Name) for SRC_GPSR_GPSR3_SR4.
* To use register names with standard convension, please use SRC_GPSR_GPSR3_SR4.
*/


/** \brief A04, General Purpose Group 3 Service Request 5 */

/** Alias (User Manual Name) for SRC_GPSR_GPSR3_SR5.
* To use register names with standard convension, please use SRC_GPSR_GPSR3_SR5.
*/


/** \brief A08, General Purpose Group 3 Service Request 6 */

/** Alias (User Manual Name) for SRC_GPSR_GPSR3_SR6.
* To use register names with standard convension, please use SRC_GPSR_GPSR3_SR6.
*/


/** \brief A0C, General Purpose Group 3 Service Request 7 */

/** Alias (User Manual Name) for SRC_GPSR_GPSR3_SR7.
* To use register names with standard convension, please use SRC_GPSR_GPSR3_SR7.
*/


/** \brief A50, ASCLIN14 Transmit Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN14_TX.
* To use register names with standard convension, please use SRC_ASCLIN14_TX.
*/


/** \brief A54, ASCLIN14 Receive Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN14_RX.
* To use register names with standard convension, please use SRC_ASCLIN14_RX.
*/


/** \brief A58, ASCLIN14 Error Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN14_ERR.
* To use register names with standard convension, please use SRC_ASCLIN14_ERR.
*/


/** \brief A5C, ASCLIN15 Transmit Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN15_TX.
* To use register names with standard convension, please use SRC_ASCLIN15_TX.
*/


/** \brief A60, ASCLIN15 Receive Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN15_RX.
* To use register names with standard convension, please use SRC_ASCLIN15_RX.
*/


/** \brief A64, ASCLIN15 Error Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN15_ERR.
* To use register names with standard convension, please use SRC_ASCLIN15_ERR.
*/


/** \brief A70, AEI Shared Service Request */

/** Alias (User Manual Name) for SRC_GTM_AEIIRQ.
* To use register names with standard convension, please use SRC_GTM_AEIIRQ.
*/


/** \brief A74, ARU Shared Service Request 0 */

/** Alias (User Manual Name) for SRC_GTM_ARUIRQ0.
* To use register names with standard convension, please use SRC_GTM_ARUIRQ0.
*/


/** \brief A78, ARU Shared Service Request 1 */

/** Alias (User Manual Name) for SRC_GTM_ARUIRQ1.
* To use register names with standard convension, please use SRC_GTM_ARUIRQ1.
*/


/** \brief A7C, ARU Shared Service Request 2 */

/** Alias (User Manual Name) for SRC_GTM_ARUIRQ2.
* To use register names with standard convension, please use SRC_GTM_ARUIRQ2.
*/


/** \brief A80, BRC Shared Service Request */

/** Alias (User Manual Name) for SRC_GTM_BRCIRQ.
* To use register names with standard convension, please use SRC_GTM_BRCIRQ.
*/


/** \brief A84, CMP Shared Service Request */

/** Alias (User Manual Name) for SRC_GTM_CMBIRQ.
* To use register names with standard convension, please use SRC_GTM_CMBIRQ.
*/


/** \brief A88, SPE0 Shared Service Request */

/** Alias (User Manual Name) for SRC_GTM_SPEIRQ0.
* To use register names with standard convension, please use SRC_GTM_SPEIRQ0.
*/


/** \brief A8C, SPE1 Shared Service Request */

/** Alias (User Manual Name) for SRC_GTM_SPEIRQ1.
* To use register names with standard convension, please use SRC_GTM_SPEIRQ1.
*/


/** \brief A90, SPE2 Shared Service Request */

/** Alias (User Manual Name) for SRC_GTM_SPEIRQ2.
* To use register names with standard convension, please use SRC_GTM_SPEIRQ2.
*/


/** \brief A94, SPE3 Shared Service Request */

/** Alias (User Manual Name) for SRC_GTM_SPEIRQ3.
* To use register names with standard convension, please use SRC_GTM_SPEIRQ3.
*/


/** \brief AA0, PSM0 Shared Service Request 0 */

/** Alias (User Manual Name) for SRC_GTM_PSM0_0.
* To use register names with standard convension, please use SRC_GTM_PSM0_0.
*/


/** \brief AA4, PSM0 Shared Service Request 1 */

/** Alias (User Manual Name) for SRC_GTM_PSM0_1.
* To use register names with standard convension, please use SRC_GTM_PSM0_1.
*/


/** \brief AA8, PSM0 Shared Service Request 2 */

/** Alias (User Manual Name) for SRC_GTM_PSM0_2.
* To use register names with standard convension, please use SRC_GTM_PSM0_2.
*/


/** \brief AAC, PSM0 Shared Service Request 3 */

/** Alias (User Manual Name) for SRC_GTM_PSM0_3.
* To use register names with standard convension, please use SRC_GTM_PSM0_3.
*/


/** \brief AB0, PSM0 Shared Service Request 4 */

/** Alias (User Manual Name) for SRC_GTM_PSM0_4.
* To use register names with standard convension, please use SRC_GTM_PSM0_4.
*/


/** \brief AB4, PSM0 Shared Service Request 5 */

/** Alias (User Manual Name) for SRC_GTM_PSM0_5.
* To use register names with standard convension, please use SRC_GTM_PSM0_5.
*/


/** \brief AB8, PSM0 Shared Service Request 6 */

/** Alias (User Manual Name) for SRC_GTM_PSM0_6.
* To use register names with standard convension, please use SRC_GTM_PSM0_6.
*/


/** \brief ABC, PSM0 Shared Service Request 7 */

/** Alias (User Manual Name) for SRC_GTM_PSM0_7.
* To use register names with standard convension, please use SRC_GTM_PSM0_7.
*/


/** \brief AC0, PSM1 Shared Service Request 0 */

/** Alias (User Manual Name) for SRC_GTM_PSM1_0.
* To use register names with standard convension, please use SRC_GTM_PSM1_0.
*/


/** \brief AC4, PSM1 Shared Service Request 1 */

/** Alias (User Manual Name) for SRC_GTM_PSM1_1.
* To use register names with standard convension, please use SRC_GTM_PSM1_1.
*/


/** \brief AC8, PSM1 Shared Service Request 2 */

/** Alias (User Manual Name) for SRC_GTM_PSM1_2.
* To use register names with standard convension, please use SRC_GTM_PSM1_2.
*/


/** \brief ACC, PSM1 Shared Service Request 3 */

/** Alias (User Manual Name) for SRC_GTM_PSM1_3.
* To use register names with standard convension, please use SRC_GTM_PSM1_3.
*/


/** \brief AD0, PSM1 Shared Service Request 4 */

/** Alias (User Manual Name) for SRC_GTM_PSM1_4.
* To use register names with standard convension, please use SRC_GTM_PSM1_4.
*/


/** \brief AD4, PSM1 Shared Service Request 5 */

/** Alias (User Manual Name) for SRC_GTM_PSM1_5.
* To use register names with standard convension, please use SRC_GTM_PSM1_5.
*/


/** \brief AD8, PSM1 Shared Service Request 6 */

/** Alias (User Manual Name) for SRC_GTM_PSM1_6.
* To use register names with standard convension, please use SRC_GTM_PSM1_6.
*/


/** \brief ADC, PSM1 Shared Service Request 7 */

/** Alias (User Manual Name) for SRC_GTM_PSM1_7.
* To use register names with standard convension, please use SRC_GTM_PSM1_7.
*/


/** \brief B00, DPLL Service Request 0 */

/** Alias (User Manual Name) for SRC_GTM_DPLL0.
* To use register names with standard convension, please use SRC_GTM_DPLL0.
*/


/** \brief B04, DPLL Service Request 1 */

/** Alias (User Manual Name) for SRC_GTM_DPLL1.
* To use register names with standard convension, please use SRC_GTM_DPLL1.
*/


/** \brief B08, DPLL Service Request 2 */

/** Alias (User Manual Name) for SRC_GTM_DPLL2.
* To use register names with standard convension, please use SRC_GTM_DPLL2.
*/


/** \brief B0C, DPLL Service Request 3 */

/** Alias (User Manual Name) for SRC_GTM_DPLL3.
* To use register names with standard convension, please use SRC_GTM_DPLL3.
*/


/** \brief B10, DPLL Service Request 4 */

/** Alias (User Manual Name) for SRC_GTM_DPLL4.
* To use register names with standard convension, please use SRC_GTM_DPLL4.
*/


/** \brief B14, DPLL Service Request 5 */

/** Alias (User Manual Name) for SRC_GTM_DPLL5.
* To use register names with standard convension, please use SRC_GTM_DPLL5.
*/


/** \brief B18, DPLL Service Request 6 */

/** Alias (User Manual Name) for SRC_GTM_DPLL6.
* To use register names with standard convension, please use SRC_GTM_DPLL6.
*/


/** \brief B1C, DPLL Service Request 7 */

/** Alias (User Manual Name) for SRC_GTM_DPLL7.
* To use register names with standard convension, please use SRC_GTM_DPLL7.
*/


/** \brief B20, DPLL Service Request 8 */

/** Alias (User Manual Name) for SRC_GTM_DPLL8.
* To use register names with standard convension, please use SRC_GTM_DPLL8.
*/


/** \brief B24, DPLL Service Request 9 */

/** Alias (User Manual Name) for SRC_GTM_DPLL9.
* To use register names with standard convension, please use SRC_GTM_DPLL9.
*/


/** \brief B28, DPLL Service Request 10 */

/** Alias (User Manual Name) for SRC_GTM_DPLL10.
* To use register names with standard convension, please use SRC_GTM_DPLL10.
*/


/** \brief B2C, DPLL Service Request 11 */

/** Alias (User Manual Name) for SRC_GTM_DPLL11.
* To use register names with standard convension, please use SRC_GTM_DPLL11.
*/


/** \brief B30, DPLL Service Request 12 */

/** Alias (User Manual Name) for SRC_GTM_DPLL12.
* To use register names with standard convension, please use SRC_GTM_DPLL12.
*/


/** \brief B34, DPLL Service Request 13 */

/** Alias (User Manual Name) for SRC_GTM_DPLL13.
* To use register names with standard convension, please use SRC_GTM_DPLL13.
*/


/** \brief B38, DPLL Service Request 14 */

/** Alias (User Manual Name) for SRC_GTM_DPLL14.
* To use register names with standard convension, please use SRC_GTM_DPLL14.
*/


/** \brief B3C, DPLL Service Request 15 */

/** Alias (User Manual Name) for SRC_GTM_DPLL15.
* To use register names with standard convension, please use SRC_GTM_DPLL15.
*/


/** \brief B40, DPLL Service Request 16 */

/** Alias (User Manual Name) for SRC_GTM_DPLL16.
* To use register names with standard convension, please use SRC_GTM_DPLL16.
*/


/** \brief B44, DPLL Service Request 17 */

/** Alias (User Manual Name) for SRC_GTM_DPLL17.
* To use register names with standard convension, please use SRC_GTM_DPLL17.
*/


/** \brief B48, DPLL Service Request 18 */

/** Alias (User Manual Name) for SRC_GTM_DPLL18.
* To use register names with standard convension, please use SRC_GTM_DPLL18.
*/


/** \brief B4C, DPLL Service Request 19 */

/** Alias (User Manual Name) for SRC_GTM_DPLL19.
* To use register names with standard convension, please use SRC_GTM_DPLL19.
*/


/** \brief B50, DPLL Service Request 20 */

/** Alias (User Manual Name) for SRC_GTM_DPLL20.
* To use register names with standard convension, please use SRC_GTM_DPLL20.
*/


/** \brief B54, DPLL Service Request 21 */

/** Alias (User Manual Name) for SRC_GTM_DPLL21.
* To use register names with standard convension, please use SRC_GTM_DPLL21.
*/


/** \brief B58, DPLL Service Request 22 */

/** Alias (User Manual Name) for SRC_GTM_DPLL22.
* To use register names with standard convension, please use SRC_GTM_DPLL22.
*/


/** \brief B5C, DPLL Service Request 23 */

/** Alias (User Manual Name) for SRC_GTM_DPLL23.
* To use register names with standard convension, please use SRC_GTM_DPLL23.
*/


/** \brief B60, DPLL Service Request 24 */

/** Alias (User Manual Name) for SRC_GTM_DPLL24.
* To use register names with standard convension, please use SRC_GTM_DPLL24.
*/


/** \brief B64, DPLL Service Request 25 */

/** Alias (User Manual Name) for SRC_GTM_DPLL25.
* To use register names with standard convension, please use SRC_GTM_DPLL25.
*/


/** \brief B68, DPLL Service Request 26 */

/** Alias (User Manual Name) for SRC_GTM_DPLL26.
* To use register names with standard convension, please use SRC_GTM_DPLL26.
*/


/** \brief B70, Error Service Request */

/** Alias (User Manual Name) for SRC_GTM_ERR.
* To use register names with standard convension, please use SRC_GTM_ERR.
*/


/** \brief B90, TIM0 Shared Service Request 0 */

/** Alias (User Manual Name) for SRC_GTM_TIM0_0.
* To use register names with standard convension, please use SRC_GTM_TIM0_0.
*/


/** \brief B94, TIM0 Shared Service Request 1 */

/** Alias (User Manual Name) for SRC_GTM_TIM0_1.
* To use register names with standard convension, please use SRC_GTM_TIM0_1.
*/


/** \brief B98, TIM0 Shared Service Request 2 */

/** Alias (User Manual Name) for SRC_GTM_TIM0_2.
* To use register names with standard convension, please use SRC_GTM_TIM0_2.
*/


/** \brief B9C, TIM0 Shared Service Request 3 */

/** Alias (User Manual Name) for SRC_GTM_TIM0_3.
* To use register names with standard convension, please use SRC_GTM_TIM0_3.
*/


/** \brief BA0, TIM0 Shared Service Request 4 */

/** Alias (User Manual Name) for SRC_GTM_TIM0_4.
* To use register names with standard convension, please use SRC_GTM_TIM0_4.
*/


/** \brief BA4, TIM0 Shared Service Request 5 */

/** Alias (User Manual Name) for SRC_GTM_TIM0_5.
* To use register names with standard convension, please use SRC_GTM_TIM0_5.
*/


/** \brief BA8, TIM0 Shared Service Request 6 */

/** Alias (User Manual Name) for SRC_GTM_TIM0_6.
* To use register names with standard convension, please use SRC_GTM_TIM0_6.
*/


/** \brief BAC, TIM0 Shared Service Request 7 */

/** Alias (User Manual Name) for SRC_GTM_TIM0_7.
* To use register names with standard convension, please use SRC_GTM_TIM0_7.
*/


/** \brief BB0, TIM1 Shared Service Request 0 */

/** Alias (User Manual Name) for SRC_GTM_TIM1_0.
* To use register names with standard convension, please use SRC_GTM_TIM1_0.
*/


/** \brief BB4, TIM1 Shared Service Request 1 */

/** Alias (User Manual Name) for SRC_GTM_TIM1_1.
* To use register names with standard convension, please use SRC_GTM_TIM1_1.
*/


/** \brief BB8, TIM1 Shared Service Request 2 */

/** Alias (User Manual Name) for SRC_GTM_TIM1_2.
* To use register names with standard convension, please use SRC_GTM_TIM1_2.
*/


/** \brief BBC, TIM1 Shared Service Request 3 */

/** Alias (User Manual Name) for SRC_GTM_TIM1_3.
* To use register names with standard convension, please use SRC_GTM_TIM1_3.
*/


/** \brief BC0, TIM1 Shared Service Request 4 */

/** Alias (User Manual Name) for SRC_GTM_TIM1_4.
* To use register names with standard convension, please use SRC_GTM_TIM1_4.
*/


/** \brief BC4, TIM1 Shared Service Request 5 */

/** Alias (User Manual Name) for SRC_GTM_TIM1_5.
* To use register names with standard convension, please use SRC_GTM_TIM1_5.
*/


/** \brief BC8, TIM1 Shared Service Request 6 */

/** Alias (User Manual Name) for SRC_GTM_TIM1_6.
* To use register names with standard convension, please use SRC_GTM_TIM1_6.
*/


/** \brief BCC, TIM1 Shared Service Request 7 */

/** Alias (User Manual Name) for SRC_GTM_TIM1_7.
* To use register names with standard convension, please use SRC_GTM_TIM1_7.
*/


/** \brief BD0, TIM2 Shared Service Request 0 */

/** Alias (User Manual Name) for SRC_GTM_TIM2_0.
* To use register names with standard convension, please use SRC_GTM_TIM2_0.
*/


/** \brief BD4, TIM2 Shared Service Request 1 */

/** Alias (User Manual Name) for SRC_GTM_TIM2_1.
* To use register names with standard convension, please use SRC_GTM_TIM2_1.
*/


/** \brief BD8, TIM2 Shared Service Request 2 */

/** Alias (User Manual Name) for SRC_GTM_TIM2_2.
* To use register names with standard convension, please use SRC_GTM_TIM2_2.
*/


/** \brief BDC, TIM2 Shared Service Request 3 */

/** Alias (User Manual Name) for SRC_GTM_TIM2_3.
* To use register names with standard convension, please use SRC_GTM_TIM2_3.
*/


/** \brief BE0, TIM2 Shared Service Request 4 */

/** Alias (User Manual Name) for SRC_GTM_TIM2_4.
* To use register names with standard convension, please use SRC_GTM_TIM2_4.
*/


/** \brief BE4, TIM2 Shared Service Request 5 */

/** Alias (User Manual Name) for SRC_GTM_TIM2_5.
* To use register names with standard convension, please use SRC_GTM_TIM2_5.
*/


/** \brief BE8, TIM2 Shared Service Request 6 */

/** Alias (User Manual Name) for SRC_GTM_TIM2_6.
* To use register names with standard convension, please use SRC_GTM_TIM2_6.
*/


/** \brief BEC, TIM2 Shared Service Request 7 */

/** Alias (User Manual Name) for SRC_GTM_TIM2_7.
* To use register names with standard convension, please use SRC_GTM_TIM2_7.
*/


/** \brief BF0, TIM3 Shared Service Request 0 */

/** Alias (User Manual Name) for SRC_GTM_TIM3_0.
* To use register names with standard convension, please use SRC_GTM_TIM3_0.
*/


/** \brief BF4, TIM3 Shared Service Request 1 */

/** Alias (User Manual Name) for SRC_GTM_TIM3_1.
* To use register names with standard convension, please use SRC_GTM_TIM3_1.
*/


/** \brief BF8, TIM3 Shared Service Request 2 */

/** Alias (User Manual Name) for SRC_GTM_TIM3_2.
* To use register names with standard convension, please use SRC_GTM_TIM3_2.
*/


/** \brief BFC, TIM3 Shared Service Request 3 */

/** Alias (User Manual Name) for SRC_GTM_TIM3_3.
* To use register names with standard convension, please use SRC_GTM_TIM3_3.
*/


/** \brief C00, TIM3 Shared Service Request 4 */

/** Alias (User Manual Name) for SRC_GTM_TIM3_4.
* To use register names with standard convension, please use SRC_GTM_TIM3_4.
*/


/** \brief C04, TIM3 Shared Service Request 5 */

/** Alias (User Manual Name) for SRC_GTM_TIM3_5.
* To use register names with standard convension, please use SRC_GTM_TIM3_5.
*/


/** \brief C08, TIM3 Shared Service Request 6 */

/** Alias (User Manual Name) for SRC_GTM_TIM3_6.
* To use register names with standard convension, please use SRC_GTM_TIM3_6.
*/


/** \brief C0C, TIM3 Shared Service Request 7 */

/** Alias (User Manual Name) for SRC_GTM_TIM3_7.
* To use register names with standard convension, please use SRC_GTM_TIM3_7.
*/


/** \brief C10, TIM4 Shared Service Request 0 */

/** Alias (User Manual Name) for SRC_GTM_TIM4_0.
* To use register names with standard convension, please use SRC_GTM_TIM4_0.
*/


/** \brief C14, TIM4 Shared Service Request 1 */

/** Alias (User Manual Name) for SRC_GTM_TIM4_1.
* To use register names with standard convension, please use SRC_GTM_TIM4_1.
*/


/** \brief C18, TIM4 Shared Service Request 2 */

/** Alias (User Manual Name) for SRC_GTM_TIM4_2.
* To use register names with standard convension, please use SRC_GTM_TIM4_2.
*/


/** \brief C1C, TIM4 Shared Service Request 3 */

/** Alias (User Manual Name) for SRC_GTM_TIM4_3.
* To use register names with standard convension, please use SRC_GTM_TIM4_3.
*/


/** \brief C20, TIM4 Shared Service Request 4 */

/** Alias (User Manual Name) for SRC_GTM_TIM4_4.
* To use register names with standard convension, please use SRC_GTM_TIM4_4.
*/


/** \brief C24, TIM4 Shared Service Request 5 */

/** Alias (User Manual Name) for SRC_GTM_TIM4_5.
* To use register names with standard convension, please use SRC_GTM_TIM4_5.
*/


/** \brief C28, TIM4 Shared Service Request 6 */

/** Alias (User Manual Name) for SRC_GTM_TIM4_6.
* To use register names with standard convension, please use SRC_GTM_TIM4_6.
*/


/** \brief C2C, TIM4 Shared Service Request 7 */

/** Alias (User Manual Name) for SRC_GTM_TIM4_7.
* To use register names with standard convension, please use SRC_GTM_TIM4_7.
*/


/** \brief C30, TIM5 Shared Service Request 0 */

/** Alias (User Manual Name) for SRC_GTM_TIM5_0.
* To use register names with standard convension, please use SRC_GTM_TIM5_0.
*/


/** \brief C34, TIM5 Shared Service Request 1 */

/** Alias (User Manual Name) for SRC_GTM_TIM5_1.
* To use register names with standard convension, please use SRC_GTM_TIM5_1.
*/


/** \brief C38, TIM5 Shared Service Request 2 */

/** Alias (User Manual Name) for SRC_GTM_TIM5_2.
* To use register names with standard convension, please use SRC_GTM_TIM5_2.
*/


/** \brief C3C, TIM5 Shared Service Request 3 */

/** Alias (User Manual Name) for SRC_GTM_TIM5_3.
* To use register names with standard convension, please use SRC_GTM_TIM5_3.
*/


/** \brief C40, TIM5 Shared Service Request 4 */

/** Alias (User Manual Name) for SRC_GTM_TIM5_4.
* To use register names with standard convension, please use SRC_GTM_TIM5_4.
*/


/** \brief C44, TIM5 Shared Service Request 5 */

/** Alias (User Manual Name) for SRC_GTM_TIM5_5.
* To use register names with standard convension, please use SRC_GTM_TIM5_5.
*/


/** \brief C48, TIM5 Shared Service Request 6 */

/** Alias (User Manual Name) for SRC_GTM_TIM5_6.
* To use register names with standard convension, please use SRC_GTM_TIM5_6.
*/


/** \brief C4C, TIM5 Shared Service Request 7 */

/** Alias (User Manual Name) for SRC_GTM_TIM5_7.
* To use register names with standard convension, please use SRC_GTM_TIM5_7.
*/


/** \brief C50, TIM6 Shared Service Request 0 */

/** Alias (User Manual Name) for SRC_GTM_TIM6_0.
* To use register names with standard convension, please use SRC_GTM_TIM6_0.
*/


/** \brief C54, TIM6 Shared Service Request 1 */

/** Alias (User Manual Name) for SRC_GTM_TIM6_1.
* To use register names with standard convension, please use SRC_GTM_TIM6_1.
*/


/** \brief C58, TIM6 Shared Service Request 2 */

/** Alias (User Manual Name) for SRC_GTM_TIM6_2.
* To use register names with standard convension, please use SRC_GTM_TIM6_2.
*/


/** \brief C5C, TIM6 Shared Service Request 3 */

/** Alias (User Manual Name) for SRC_GTM_TIM6_3.
* To use register names with standard convension, please use SRC_GTM_TIM6_3.
*/


/** \brief C60, TIM6 Shared Service Request 4 */

/** Alias (User Manual Name) for SRC_GTM_TIM6_4.
* To use register names with standard convension, please use SRC_GTM_TIM6_4.
*/


/** \brief C64, TIM6 Shared Service Request 5 */

/** Alias (User Manual Name) for SRC_GTM_TIM6_5.
* To use register names with standard convension, please use SRC_GTM_TIM6_5.
*/


/** \brief C68, TIM6 Shared Service Request 6 */

/** Alias (User Manual Name) for SRC_GTM_TIM6_6.
* To use register names with standard convension, please use SRC_GTM_TIM6_6.
*/


/** \brief C6C, TIM6 Shared Service Request 7 */

/** Alias (User Manual Name) for SRC_GTM_TIM6_7.
* To use register names with standard convension, please use SRC_GTM_TIM6_7.
*/


/** \brief C90, ASCLIN16 Transmit Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN16_TX.
* To use register names with standard convension, please use SRC_ASCLIN16_TX.
*/


/** \brief C94, ASCLIN16 Receive Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN16_RX.
* To use register names with standard convension, please use SRC_ASCLIN16_RX.
*/


/** \brief C98, ASCLIN16 Error Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN16_ERR.
* To use register names with standard convension, please use SRC_ASCLIN16_ERR.
*/


/** \brief C9C, ASCLIN17 Transmit Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN17_TX.
* To use register names with standard convension, please use SRC_ASCLIN17_TX.
*/


/** \brief CA0, ASCLIN17 Receive Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN17_RX.
* To use register names with standard convension, please use SRC_ASCLIN17_RX.
*/


/** \brief CA4, ASCLIN17 Error Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN17_ERR.
* To use register names with standard convension, please use SRC_ASCLIN17_ERR.
*/


/** \brief CB0, MCS0 Shared Service Request 0 */

/** Alias (User Manual Name) for SRC_GTM_MCS0_0.
* To use register names with standard convension, please use SRC_GTM_MCS0_0.
*/


/** \brief CB4, MCS0 Shared Service Request 1 */

/** Alias (User Manual Name) for SRC_GTM_MCS0_1.
* To use register names with standard convension, please use SRC_GTM_MCS0_1.
*/


/** \brief CB8, MCS0 Shared Service Request 2 */

/** Alias (User Manual Name) for SRC_GTM_MCS0_2.
* To use register names with standard convension, please use SRC_GTM_MCS0_2.
*/


/** \brief CBC, MCS0 Shared Service Request 3 */

/** Alias (User Manual Name) for SRC_GTM_MCS0_3.
* To use register names with standard convension, please use SRC_GTM_MCS0_3.
*/


/** \brief CC0, MCS0 Shared Service Request 4 */

/** Alias (User Manual Name) for SRC_GTM_MCS0_4.
* To use register names with standard convension, please use SRC_GTM_MCS0_4.
*/


/** \brief CC4, MCS0 Shared Service Request 5 */

/** Alias (User Manual Name) for SRC_GTM_MCS0_5.
* To use register names with standard convension, please use SRC_GTM_MCS0_5.
*/


/** \brief CC8, MCS0 Shared Service Request 6 */

/** Alias (User Manual Name) for SRC_GTM_MCS0_6.
* To use register names with standard convension, please use SRC_GTM_MCS0_6.
*/


/** \brief CCC, MCS0 Shared Service Request 7 */

/** Alias (User Manual Name) for SRC_GTM_MCS0_7.
* To use register names with standard convension, please use SRC_GTM_MCS0_7.
*/


/** \brief CD0, MCS1 Shared Service Request 0 */

/** Alias (User Manual Name) for SRC_GTM_MCS1_0.
* To use register names with standard convension, please use SRC_GTM_MCS1_0.
*/


/** \brief CD4, MCS1 Shared Service Request 1 */

/** Alias (User Manual Name) for SRC_GTM_MCS1_1.
* To use register names with standard convension, please use SRC_GTM_MCS1_1.
*/


/** \brief CD8, MCS1 Shared Service Request 2 */

/** Alias (User Manual Name) for SRC_GTM_MCS1_2.
* To use register names with standard convension, please use SRC_GTM_MCS1_2.
*/


/** \brief CDC, MCS1 Shared Service Request 3 */

/** Alias (User Manual Name) for SRC_GTM_MCS1_3.
* To use register names with standard convension, please use SRC_GTM_MCS1_3.
*/


/** \brief CE0, MCS1 Shared Service Request 4 */

/** Alias (User Manual Name) for SRC_GTM_MCS1_4.
* To use register names with standard convension, please use SRC_GTM_MCS1_4.
*/


/** \brief CE4, MCS1 Shared Service Request 5 */

/** Alias (User Manual Name) for SRC_GTM_MCS1_5.
* To use register names with standard convension, please use SRC_GTM_MCS1_5.
*/


/** \brief CE8, MCS1 Shared Service Request 6 */

/** Alias (User Manual Name) for SRC_GTM_MCS1_6.
* To use register names with standard convension, please use SRC_GTM_MCS1_6.
*/


/** \brief CEC, MCS1 Shared Service Request 7 */

/** Alias (User Manual Name) for SRC_GTM_MCS1_7.
* To use register names with standard convension, please use SRC_GTM_MCS1_7.
*/


/** \brief CF0, MCS2 Shared Service Request 0 */

/** Alias (User Manual Name) for SRC_GTM_MCS2_0.
* To use register names with standard convension, please use SRC_GTM_MCS2_0.
*/


/** \brief CF4, MCS2 Shared Service Request 1 */

/** Alias (User Manual Name) for SRC_GTM_MCS2_1.
* To use register names with standard convension, please use SRC_GTM_MCS2_1.
*/


/** \brief CF8, MCS2 Shared Service Request 2 */

/** Alias (User Manual Name) for SRC_GTM_MCS2_2.
* To use register names with standard convension, please use SRC_GTM_MCS2_2.
*/


/** \brief CFC, MCS2 Shared Service Request 3 */

/** Alias (User Manual Name) for SRC_GTM_MCS2_3.
* To use register names with standard convension, please use SRC_GTM_MCS2_3.
*/


/** \brief D00, MCS2 Shared Service Request 4 */

/** Alias (User Manual Name) for SRC_GTM_MCS2_4.
* To use register names with standard convension, please use SRC_GTM_MCS2_4.
*/


/** \brief D04, MCS2 Shared Service Request 5 */

/** Alias (User Manual Name) for SRC_GTM_MCS2_5.
* To use register names with standard convension, please use SRC_GTM_MCS2_5.
*/


/** \brief D08, MCS2 Shared Service Request 6 */

/** Alias (User Manual Name) for SRC_GTM_MCS2_6.
* To use register names with standard convension, please use SRC_GTM_MCS2_6.
*/


/** \brief D0C, MCS2 Shared Service Request 7 */

/** Alias (User Manual Name) for SRC_GTM_MCS2_7.
* To use register names with standard convension, please use SRC_GTM_MCS2_7.
*/


/** \brief D10, MCS3 Shared Service Request 0 */

/** Alias (User Manual Name) for SRC_GTM_MCS3_0.
* To use register names with standard convension, please use SRC_GTM_MCS3_0.
*/


/** \brief D14, MCS3 Shared Service Request 1 */

/** Alias (User Manual Name) for SRC_GTM_MCS3_1.
* To use register names with standard convension, please use SRC_GTM_MCS3_1.
*/


/** \brief D18, MCS3 Shared Service Request 2 */

/** Alias (User Manual Name) for SRC_GTM_MCS3_2.
* To use register names with standard convension, please use SRC_GTM_MCS3_2.
*/


/** \brief D1C, MCS3 Shared Service Request 3 */

/** Alias (User Manual Name) for SRC_GTM_MCS3_3.
* To use register names with standard convension, please use SRC_GTM_MCS3_3.
*/


/** \brief D20, MCS3 Shared Service Request 4 */

/** Alias (User Manual Name) for SRC_GTM_MCS3_4.
* To use register names with standard convension, please use SRC_GTM_MCS3_4.
*/


/** \brief D24, MCS3 Shared Service Request 5 */

/** Alias (User Manual Name) for SRC_GTM_MCS3_5.
* To use register names with standard convension, please use SRC_GTM_MCS3_5.
*/


/** \brief D28, MCS3 Shared Service Request 6 */

/** Alias (User Manual Name) for SRC_GTM_MCS3_6.
* To use register names with standard convension, please use SRC_GTM_MCS3_6.
*/


/** \brief D2C, MCS3 Shared Service Request 7 */

/** Alias (User Manual Name) for SRC_GTM_MCS3_7.
* To use register names with standard convension, please use SRC_GTM_MCS3_7.
*/


/** \brief D30, MCS4 Shared Service Request 0 */

/** Alias (User Manual Name) for SRC_GTM_MCS4_0.
* To use register names with standard convension, please use SRC_GTM_MCS4_0.
*/


/** \brief D34, MCS4 Shared Service Request 1 */

/** Alias (User Manual Name) for SRC_GTM_MCS4_1.
* To use register names with standard convension, please use SRC_GTM_MCS4_1.
*/


/** \brief D38, MCS4 Shared Service Request 2 */

/** Alias (User Manual Name) for SRC_GTM_MCS4_2.
* To use register names with standard convension, please use SRC_GTM_MCS4_2.
*/


/** \brief D3C, MCS4 Shared Service Request 3 */

/** Alias (User Manual Name) for SRC_GTM_MCS4_3.
* To use register names with standard convension, please use SRC_GTM_MCS4_3.
*/


/** \brief D40, MCS4 Shared Service Request 4 */

/** Alias (User Manual Name) for SRC_GTM_MCS4_4.
* To use register names with standard convension, please use SRC_GTM_MCS4_4.
*/


/** \brief D44, MCS4 Shared Service Request 5 */

/** Alias (User Manual Name) for SRC_GTM_MCS4_5.
* To use register names with standard convension, please use SRC_GTM_MCS4_5.
*/


/** \brief D48, MCS4 Shared Service Request 6 */

/** Alias (User Manual Name) for SRC_GTM_MCS4_6.
* To use register names with standard convension, please use SRC_GTM_MCS4_6.
*/


/** \brief D4C, MCS4 Shared Service Request 7 */

/** Alias (User Manual Name) for SRC_GTM_MCS4_7.
* To use register names with standard convension, please use SRC_GTM_MCS4_7.
*/


/** \brief D50, MCS5 Shared Service Request 0 */

/** Alias (User Manual Name) for SRC_GTM_MCS5_0.
* To use register names with standard convension, please use SRC_GTM_MCS5_0.
*/


/** \brief D54, MCS5 Shared Service Request 1 */

/** Alias (User Manual Name) for SRC_GTM_MCS5_1.
* To use register names with standard convension, please use SRC_GTM_MCS5_1.
*/


/** \brief D58, MCS5 Shared Service Request 2 */

/** Alias (User Manual Name) for SRC_GTM_MCS5_2.
* To use register names with standard convension, please use SRC_GTM_MCS5_2.
*/


/** \brief D5C, MCS5 Shared Service Request 3 */

/** Alias (User Manual Name) for SRC_GTM_MCS5_3.
* To use register names with standard convension, please use SRC_GTM_MCS5_3.
*/


/** \brief D60, MCS5 Shared Service Request 4 */

/** Alias (User Manual Name) for SRC_GTM_MCS5_4.
* To use register names with standard convension, please use SRC_GTM_MCS5_4.
*/


/** \brief D64, MCS5 Shared Service Request 5 */

/** Alias (User Manual Name) for SRC_GTM_MCS5_5.
* To use register names with standard convension, please use SRC_GTM_MCS5_5.
*/


/** \brief D68, MCS5 Shared Service Request 6 */

/** Alias (User Manual Name) for SRC_GTM_MCS5_6.
* To use register names with standard convension, please use SRC_GTM_MCS5_6.
*/


/** \brief D6C, MCS5 Shared Service Request 7 */

/** Alias (User Manual Name) for SRC_GTM_MCS5_7.
* To use register names with standard convension, please use SRC_GTM_MCS5_7.
*/


/** \brief D70, MCS6 Shared Service Request 0 */

/** Alias (User Manual Name) for SRC_GTM_MCS6_0.
* To use register names with standard convension, please use SRC_GTM_MCS6_0.
*/


/** \brief D74, MCS6 Shared Service Request 1 */

/** Alias (User Manual Name) for SRC_GTM_MCS6_1.
* To use register names with standard convension, please use SRC_GTM_MCS6_1.
*/


/** \brief D78, MCS6 Shared Service Request 2 */

/** Alias (User Manual Name) for SRC_GTM_MCS6_2.
* To use register names with standard convension, please use SRC_GTM_MCS6_2.
*/


/** \brief D7C, MCS6 Shared Service Request 3 */

/** Alias (User Manual Name) for SRC_GTM_MCS6_3.
* To use register names with standard convension, please use SRC_GTM_MCS6_3.
*/


/** \brief D80, MCS6 Shared Service Request 4 */

/** Alias (User Manual Name) for SRC_GTM_MCS6_4.
* To use register names with standard convension, please use SRC_GTM_MCS6_4.
*/


/** \brief D84, MCS6 Shared Service Request 5 */

/** Alias (User Manual Name) for SRC_GTM_MCS6_5.
* To use register names with standard convension, please use SRC_GTM_MCS6_5.
*/


/** \brief D88, MCS6 Shared Service Request 6 */

/** Alias (User Manual Name) for SRC_GTM_MCS6_6.
* To use register names with standard convension, please use SRC_GTM_MCS6_6.
*/


/** \brief D8C, MCS6 Shared Service Request 7 */

/** Alias (User Manual Name) for SRC_GTM_MCS6_7.
* To use register names with standard convension, please use SRC_GTM_MCS6_7.
*/


/** \brief DF0, ASCLIN18 Transmit Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN18_TX.
* To use register names with standard convension, please use SRC_ASCLIN18_TX.
*/


/** \brief DF4, ASCLIN18 Receive Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN18_RX.
* To use register names with standard convension, please use SRC_ASCLIN18_RX.
*/


/** \brief DF8, ASCLIN18 Error Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN18_ERR.
* To use register names with standard convension, please use SRC_ASCLIN18_ERR.
*/


/** \brief DFC, ASCLIN19 Transmit Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN19_TX.
* To use register names with standard convension, please use SRC_ASCLIN19_TX.
*/


/** \brief E00, ASCLIN19 Receive Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN19_RX.
* To use register names with standard convension, please use SRC_ASCLIN19_RX.
*/


/** \brief E04, ASCLIN19 Error Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN19_ERR.
* To use register names with standard convension, please use SRC_ASCLIN19_ERR.
*/


/** \brief E10, TOM0 Shared Service Request 0 */

/** Alias (User Manual Name) for SRC_GTM_TOM0_0.
* To use register names with standard convension, please use SRC_GTM_TOM0_0.
*/


/** \brief E14, TOM0 Shared Service Request 1 */

/** Alias (User Manual Name) for SRC_GTM_TOM0_1.
* To use register names with standard convension, please use SRC_GTM_TOM0_1.
*/


/** \brief E18, TOM0 Shared Service Request 2 */

/** Alias (User Manual Name) for SRC_GTM_TOM0_2.
* To use register names with standard convension, please use SRC_GTM_TOM0_2.
*/


/** \brief E1C, TOM0 Shared Service Request 3 */

/** Alias (User Manual Name) for SRC_GTM_TOM0_3.
* To use register names with standard convension, please use SRC_GTM_TOM0_3.
*/


/** \brief E20, TOM0 Shared Service Request 4 */

/** Alias (User Manual Name) for SRC_GTM_TOM0_4.
* To use register names with standard convension, please use SRC_GTM_TOM0_4.
*/


/** \brief E24, TOM0 Shared Service Request 5 */

/** Alias (User Manual Name) for SRC_GTM_TOM0_5.
* To use register names with standard convension, please use SRC_GTM_TOM0_5.
*/


/** \brief E28, TOM0 Shared Service Request 6 */

/** Alias (User Manual Name) for SRC_GTM_TOM0_6.
* To use register names with standard convension, please use SRC_GTM_TOM0_6.
*/


/** \brief E2C, TOM0 Shared Service Request 7 */

/** Alias (User Manual Name) for SRC_GTM_TOM0_7.
* To use register names with standard convension, please use SRC_GTM_TOM0_7.
*/


/** \brief E30, TOM1 Shared Service Request 0 */

/** Alias (User Manual Name) for SRC_GTM_TOM1_0.
* To use register names with standard convension, please use SRC_GTM_TOM1_0.
*/


/** \brief E34, TOM1 Shared Service Request 1 */

/** Alias (User Manual Name) for SRC_GTM_TOM1_1.
* To use register names with standard convension, please use SRC_GTM_TOM1_1.
*/


/** \brief E38, TOM1 Shared Service Request 2 */

/** Alias (User Manual Name) for SRC_GTM_TOM1_2.
* To use register names with standard convension, please use SRC_GTM_TOM1_2.
*/


/** \brief E3C, TOM1 Shared Service Request 3 */

/** Alias (User Manual Name) for SRC_GTM_TOM1_3.
* To use register names with standard convension, please use SRC_GTM_TOM1_3.
*/


/** \brief E40, TOM1 Shared Service Request 4 */

/** Alias (User Manual Name) for SRC_GTM_TOM1_4.
* To use register names with standard convension, please use SRC_GTM_TOM1_4.
*/


/** \brief E44, TOM1 Shared Service Request 5 */

/** Alias (User Manual Name) for SRC_GTM_TOM1_5.
* To use register names with standard convension, please use SRC_GTM_TOM1_5.
*/


/** \brief E48, TOM1 Shared Service Request 6 */

/** Alias (User Manual Name) for SRC_GTM_TOM1_6.
* To use register names with standard convension, please use SRC_GTM_TOM1_6.
*/


/** \brief E4C, TOM1 Shared Service Request 7 */

/** Alias (User Manual Name) for SRC_GTM_TOM1_7.
* To use register names with standard convension, please use SRC_GTM_TOM1_7.
*/


/** \brief E50, TOM2 Shared Service Request 0 */

/** Alias (User Manual Name) for SRC_GTM_TOM2_0.
* To use register names with standard convension, please use SRC_GTM_TOM2_0.
*/


/** \brief E54, TOM2 Shared Service Request 1 */

/** Alias (User Manual Name) for SRC_GTM_TOM2_1.
* To use register names with standard convension, please use SRC_GTM_TOM2_1.
*/


/** \brief E58, TOM2 Shared Service Request 2 */

/** Alias (User Manual Name) for SRC_GTM_TOM2_2.
* To use register names with standard convension, please use SRC_GTM_TOM2_2.
*/


/** \brief E5C, TOM2 Shared Service Request 3 */

/** Alias (User Manual Name) for SRC_GTM_TOM2_3.
* To use register names with standard convension, please use SRC_GTM_TOM2_3.
*/


/** \brief E60, TOM2 Shared Service Request 4 */

/** Alias (User Manual Name) for SRC_GTM_TOM2_4.
* To use register names with standard convension, please use SRC_GTM_TOM2_4.
*/


/** \brief E64, TOM2 Shared Service Request 5 */

/** Alias (User Manual Name) for SRC_GTM_TOM2_5.
* To use register names with standard convension, please use SRC_GTM_TOM2_5.
*/


/** \brief E68, TOM2 Shared Service Request 6 */

/** Alias (User Manual Name) for SRC_GTM_TOM2_6.
* To use register names with standard convension, please use SRC_GTM_TOM2_6.
*/


/** \brief E6C, TOM2 Shared Service Request 7 */

/** Alias (User Manual Name) for SRC_GTM_TOM2_7.
* To use register names with standard convension, please use SRC_GTM_TOM2_7.
*/


/** \brief E70, TOM3 Shared Service Request 0 */

/** Alias (User Manual Name) for SRC_GTM_TOM3_0.
* To use register names with standard convension, please use SRC_GTM_TOM3_0.
*/


/** \brief E74, TOM3 Shared Service Request 1 */

/** Alias (User Manual Name) for SRC_GTM_TOM3_1.
* To use register names with standard convension, please use SRC_GTM_TOM3_1.
*/


/** \brief E78, TOM3 Shared Service Request 2 */

/** Alias (User Manual Name) for SRC_GTM_TOM3_2.
* To use register names with standard convension, please use SRC_GTM_TOM3_2.
*/


/** \brief E7C, TOM3 Shared Service Request 3 */

/** Alias (User Manual Name) for SRC_GTM_TOM3_3.
* To use register names with standard convension, please use SRC_GTM_TOM3_3.
*/


/** \brief E80, TOM3 Shared Service Request 4 */

/** Alias (User Manual Name) for SRC_GTM_TOM3_4.
* To use register names with standard convension, please use SRC_GTM_TOM3_4.
*/


/** \brief E84, TOM3 Shared Service Request 5 */

/** Alias (User Manual Name) for SRC_GTM_TOM3_5.
* To use register names with standard convension, please use SRC_GTM_TOM3_5.
*/


/** \brief E88, TOM3 Shared Service Request 6 */

/** Alias (User Manual Name) for SRC_GTM_TOM3_6.
* To use register names with standard convension, please use SRC_GTM_TOM3_6.
*/


/** \brief E8C, TOM3 Shared Service Request 7 */

/** Alias (User Manual Name) for SRC_GTM_TOM3_7.
* To use register names with standard convension, please use SRC_GTM_TOM3_7.
*/


/** \brief E90, TOM4 Shared Service Request 0 */

/** Alias (User Manual Name) for SRC_GTM_TOM4_0.
* To use register names with standard convension, please use SRC_GTM_TOM4_0.
*/


/** \brief E94, TOM4 Shared Service Request 1 */

/** Alias (User Manual Name) for SRC_GTM_TOM4_1.
* To use register names with standard convension, please use SRC_GTM_TOM4_1.
*/


/** \brief E98, TOM4 Shared Service Request 2 */

/** Alias (User Manual Name) for SRC_GTM_TOM4_2.
* To use register names with standard convension, please use SRC_GTM_TOM4_2.
*/


/** \brief E9C, TOM4 Shared Service Request 3 */

/** Alias (User Manual Name) for SRC_GTM_TOM4_3.
* To use register names with standard convension, please use SRC_GTM_TOM4_3.
*/


/** \brief EA0, TOM4 Shared Service Request 4 */

/** Alias (User Manual Name) for SRC_GTM_TOM4_4.
* To use register names with standard convension, please use SRC_GTM_TOM4_4.
*/


/** \brief EA4, TOM4 Shared Service Request 5 */

/** Alias (User Manual Name) for SRC_GTM_TOM4_5.
* To use register names with standard convension, please use SRC_GTM_TOM4_5.
*/


/** \brief EA8, TOM4 Shared Service Request 6 */

/** Alias (User Manual Name) for SRC_GTM_TOM4_6.
* To use register names with standard convension, please use SRC_GTM_TOM4_6.
*/


/** \brief EAC, TOM4 Shared Service Request 7 */

/** Alias (User Manual Name) for SRC_GTM_TOM4_7.
* To use register names with standard convension, please use SRC_GTM_TOM4_7.
*/


/** \brief ED0, ASCLIN20 Transmit Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN20_TX.
* To use register names with standard convension, please use SRC_ASCLIN20_TX.
*/


/** \brief ED4, ASCLIN20 Receive Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN20_RX.
* To use register names with standard convension, please use SRC_ASCLIN20_RX.
*/


/** \brief ED8, ASCLIN20 Error Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN20_ERR.
* To use register names with standard convension, please use SRC_ASCLIN20_ERR.
*/


/** \brief EDC, ASCLIN21 Transmit Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN21_TX.
* To use register names with standard convension, please use SRC_ASCLIN21_TX.
*/


/** \brief EE0, ASCLIN21 Receive Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN21_RX.
* To use register names with standard convension, please use SRC_ASCLIN21_RX.
*/


/** \brief EE4, ASCLIN21 Error Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN21_ERR.
* To use register names with standard convension, please use SRC_ASCLIN21_ERR.
*/


/** \brief EF0, ATOM0 Shared Service Request 0 */

/** Alias (User Manual Name) for SRC_GTM_ATOM0_0.
* To use register names with standard convension, please use SRC_GTM_ATOM0_0.
*/


/** \brief EF4, ATOM0 Shared Service Request 1 */

/** Alias (User Manual Name) for SRC_GTM_ATOM0_1.
* To use register names with standard convension, please use SRC_GTM_ATOM0_1.
*/


/** \brief EF8, ATOM0 Shared Service Request 2 */

/** Alias (User Manual Name) for SRC_GTM_ATOM0_2.
* To use register names with standard convension, please use SRC_GTM_ATOM0_2.
*/


/** \brief EFC, ATOM0 Shared Service Request 3 */

/** Alias (User Manual Name) for SRC_GTM_ATOM0_3.
* To use register names with standard convension, please use SRC_GTM_ATOM0_3.
*/


/** \brief F00, ATOM1 Shared Service Request 0 */

/** Alias (User Manual Name) for SRC_GTM_ATOM1_0.
* To use register names with standard convension, please use SRC_GTM_ATOM1_0.
*/


/** \brief F04, ATOM1 Shared Service Request 1 */

/** Alias (User Manual Name) for SRC_GTM_ATOM1_1.
* To use register names with standard convension, please use SRC_GTM_ATOM1_1.
*/


/** \brief F08, ATOM1 Shared Service Request 2 */

/** Alias (User Manual Name) for SRC_GTM_ATOM1_2.
* To use register names with standard convension, please use SRC_GTM_ATOM1_2.
*/


/** \brief F0C, ATOM1 Shared Service Request 3 */

/** Alias (User Manual Name) for SRC_GTM_ATOM1_3.
* To use register names with standard convension, please use SRC_GTM_ATOM1_3.
*/


/** \brief F10, ATOM2 Shared Service Request 0 */

/** Alias (User Manual Name) for SRC_GTM_ATOM2_0.
* To use register names with standard convension, please use SRC_GTM_ATOM2_0.
*/


/** \brief F14, ATOM2 Shared Service Request 1 */

/** Alias (User Manual Name) for SRC_GTM_ATOM2_1.
* To use register names with standard convension, please use SRC_GTM_ATOM2_1.
*/


/** \brief F18, ATOM2 Shared Service Request 2 */

/** Alias (User Manual Name) for SRC_GTM_ATOM2_2.
* To use register names with standard convension, please use SRC_GTM_ATOM2_2.
*/


/** \brief F1C, ATOM2 Shared Service Request 3 */

/** Alias (User Manual Name) for SRC_GTM_ATOM2_3.
* To use register names with standard convension, please use SRC_GTM_ATOM2_3.
*/


/** \brief F20, ATOM3 Shared Service Request 0 */

/** Alias (User Manual Name) for SRC_GTM_ATOM3_0.
* To use register names with standard convension, please use SRC_GTM_ATOM3_0.
*/


/** \brief F24, ATOM3 Shared Service Request 1 */

/** Alias (User Manual Name) for SRC_GTM_ATOM3_1.
* To use register names with standard convension, please use SRC_GTM_ATOM3_1.
*/


/** \brief F28, ATOM3 Shared Service Request 2 */

/** Alias (User Manual Name) for SRC_GTM_ATOM3_2.
* To use register names with standard convension, please use SRC_GTM_ATOM3_2.
*/


/** \brief F2C, ATOM3 Shared Service Request 3 */

/** Alias (User Manual Name) for SRC_GTM_ATOM3_3.
* To use register names with standard convension, please use SRC_GTM_ATOM3_3.
*/


/** \brief F30, ATOM4 Shared Service Request 0 */

/** Alias (User Manual Name) for SRC_GTM_ATOM4_0.
* To use register names with standard convension, please use SRC_GTM_ATOM4_0.
*/


/** \brief F34, ATOM4 Shared Service Request 1 */

/** Alias (User Manual Name) for SRC_GTM_ATOM4_1.
* To use register names with standard convension, please use SRC_GTM_ATOM4_1.
*/


/** \brief F38, ATOM4 Shared Service Request 2 */

/** Alias (User Manual Name) for SRC_GTM_ATOM4_2.
* To use register names with standard convension, please use SRC_GTM_ATOM4_2.
*/


/** \brief F3C, ATOM4 Shared Service Request 3 */

/** Alias (User Manual Name) for SRC_GTM_ATOM4_3.
* To use register names with standard convension, please use SRC_GTM_ATOM4_3.
*/


/** \brief F40, ATOM5 Shared Service Request 0 */

/** Alias (User Manual Name) for SRC_GTM_ATOM5_0.
* To use register names with standard convension, please use SRC_GTM_ATOM5_0.
*/


/** \brief F44, ATOM5 Shared Service Request 1 */

/** Alias (User Manual Name) for SRC_GTM_ATOM5_1.
* To use register names with standard convension, please use SRC_GTM_ATOM5_1.
*/


/** \brief F48, ATOM5 Shared Service Request 2 */

/** Alias (User Manual Name) for SRC_GTM_ATOM5_2.
* To use register names with standard convension, please use SRC_GTM_ATOM5_2.
*/


/** \brief F4C, ATOM5 Shared Service Request 3 */

/** Alias (User Manual Name) for SRC_GTM_ATOM5_3.
* To use register names with standard convension, please use SRC_GTM_ATOM5_3.
*/


/** \brief F50, ATOM6 Shared Service Request 0 */

/** Alias (User Manual Name) for SRC_GTM_ATOM6_0.
* To use register names with standard convension, please use SRC_GTM_ATOM6_0.
*/


/** \brief F54, ATOM6 Shared Service Request 1 */

/** Alias (User Manual Name) for SRC_GTM_ATOM6_1.
* To use register names with standard convension, please use SRC_GTM_ATOM6_1.
*/


/** \brief F58, ATOM6 Shared Service Request 2 */

/** Alias (User Manual Name) for SRC_GTM_ATOM6_2.
* To use register names with standard convension, please use SRC_GTM_ATOM6_2.
*/


/** \brief F5C, ATOM6 Shared Service Request 3 */

/** Alias (User Manual Name) for SRC_GTM_ATOM6_3.
* To use register names with standard convension, please use SRC_GTM_ATOM6_3.
*/


/** \brief F60, ATOM7 Shared Service Request 0 */

/** Alias (User Manual Name) for SRC_GTM_ATOM7_0.
* To use register names with standard convension, please use SRC_GTM_ATOM7_0.
*/


/** \brief F64, ATOM7 Shared Service Request 1 */

/** Alias (User Manual Name) for SRC_GTM_ATOM7_1.
* To use register names with standard convension, please use SRC_GTM_ATOM7_1.
*/


/** \brief F68, ATOM7 Shared Service Request 2 */

/** Alias (User Manual Name) for SRC_GTM_ATOM7_2.
* To use register names with standard convension, please use SRC_GTM_ATOM7_2.
*/


/** \brief F6C, ATOM7 Shared Service Request 3 */

/** Alias (User Manual Name) for SRC_GTM_ATOM7_3.
* To use register names with standard convension, please use SRC_GTM_ATOM7_3.
*/


/** \brief F70, ATOM8 Shared Service Request 0 */

/** Alias (User Manual Name) for SRC_GTM_ATOM8_0.
* To use register names with standard convension, please use SRC_GTM_ATOM8_0.
*/


/** \brief F74, ATOM8 Shared Service Request 1 */

/** Alias (User Manual Name) for SRC_GTM_ATOM8_1.
* To use register names with standard convension, please use SRC_GTM_ATOM8_1.
*/


/** \brief F78, ATOM8 Shared Service Request 2 */

/** Alias (User Manual Name) for SRC_GTM_ATOM8_2.
* To use register names with standard convension, please use SRC_GTM_ATOM8_2.
*/


/** \brief F7C, ATOM8 Shared Service Request 3 */

/** Alias (User Manual Name) for SRC_GTM_ATOM8_3.
* To use register names with standard convension, please use SRC_GTM_ATOM8_3.
*/


/** \brief FB0, ASCLIN22 Transmit Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN22_TX.
* To use register names with standard convension, please use SRC_ASCLIN22_TX.
*/


/** \brief FB4, ASCLIN22 Receive Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN22_RX.
* To use register names with standard convension, please use SRC_ASCLIN22_RX.
*/


/** \brief FB8, ASCLIN22 Error Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN22_ERR.
* To use register names with standard convension, please use SRC_ASCLIN22_ERR.
*/


/** \brief FBC, ASCLIN23 Transmit Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN23_TX.
* To use register names with standard convension, please use SRC_ASCLIN23_TX.
*/


/** \brief FC0, ASCLIN23 Receive Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN23_RX.
* To use register names with standard convension, please use SRC_ASCLIN23_RX.
*/


/** \brief FC4, ASCLIN23 Error Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN23_ERR.
* To use register names with standard convension, please use SRC_ASCLIN23_ERR.
*/


/** \brief FD0, GTM Multi Channel Sequencer Service Request 0 */

/** Alias (User Manual Name) for SRC_GTM_MCSW0.
* To use register names with standard convension, please use SRC_GTM_MCSW0.
*/


/** \brief FD4, GTM Multi Channel Sequencer Service Request 1 */

/** Alias (User Manual Name) for SRC_GTM_MCSW1.
* To use register names with standard convension, please use SRC_GTM_MCSW1.
*/


/** \brief FD8, GTM Multi Channel Sequencer Service Request 2 */

/** Alias (User Manual Name) for SRC_GTM_MCSW2.
* To use register names with standard convension, please use SRC_GTM_MCSW2.
*/


/** \brief FDC, GTM Multi Channel Sequencer Service Request 3 */

/** Alias (User Manual Name) for SRC_GTM_MCSW3.
* To use register names with standard convension, please use SRC_GTM_MCSW3.
*/


/** \brief FE0, GTM Multi Channel Sequencer Service Request 4 */

/** Alias (User Manual Name) for SRC_GTM_MCSW4.
* To use register names with standard convension, please use SRC_GTM_MCSW4.
*/


/** \brief FE4, GTM Multi Channel Sequencer Service Request 5 */

/** Alias (User Manual Name) for SRC_GTM_MCSW5.
* To use register names with standard convension, please use SRC_GTM_MCSW5.
*/


/** \brief FE8, GTM Multi Channel Sequencer Service Request 6 */

/** Alias (User Manual Name) for SRC_GTM_MCSW6.
* To use register names with standard convension, please use SRC_GTM_MCSW6.
*/


/** \brief FEC, GTM Multi Channel Sequencer Service Request 7 */

/** Alias (User Manual Name) for SRC_GTM_MCSW7.
* To use register names with standard convension, please use SRC_GTM_MCSW7.
*/


/** \brief FF0, GTM Multi Channel Sequencer Service Request 8 */

/** Alias (User Manual Name) for SRC_GTM_MCSW8.
* To use register names with standard convension, please use SRC_GTM_MCSW8.
*/


/** \brief FF4, GTM Multi Channel Sequencer Service Request 9 */

/** Alias (User Manual Name) for SRC_GTM_MCSW9.
* To use register names with standard convension, please use SRC_GTM_MCSW9.
*/



/** \}  */

/******************************************************************************/

/******************************************************************************/


#line 71 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Cpu\\Std\\IfxCpu.h"


#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\Infra\\Sfr\\TC38A\\_Reg\\IfxStm_reg.h"
/**
 * \file IfxStm_reg.h
 * \brief
 * \copyright Copyright (c) 2020 Infineon Technologies AG. All rights reserved.
 *
 *
 * Version: TC38XA_UM_V1.5.0
 * Specification: TC3xx User Manual V1.5.0
 * MAY BE CHANGED BY USER [yes/no]: No
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * \defgroup IfxSfr_Stm_Registers_Cfg Stm address
 * \ingroup IfxSfr_Stm_Registers
 * 
 * \defgroup IfxSfr_Stm_Registers_Cfg_BaseAddress Base address
 * \ingroup IfxSfr_Stm_Registers_Cfg
 *
 * \defgroup IfxSfr_Stm_Registers_Cfg_Stm0 2-STM0
 * \ingroup IfxSfr_Stm_Registers_Cfg
 *
 * \defgroup IfxSfr_Stm_Registers_Cfg_Stm1 2-STM1
 * \ingroup IfxSfr_Stm_Registers_Cfg
 *
 * \defgroup IfxSfr_Stm_Registers_Cfg_Stm2 2-STM2
 * \ingroup IfxSfr_Stm_Registers_Cfg
 *
 * \defgroup IfxSfr_Stm_Registers_Cfg_Stm3 2-STM3
 * \ingroup IfxSfr_Stm_Registers_Cfg
 *
 *
 */


/******************************************************************************/

#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\Infra\\Sfr\\TC38A\\_Reg\\IfxStm_regdef.h"
/**
 * \file IfxStm_regdef.h
 * \brief
 * \copyright Copyright (c) 2020 Infineon Technologies AG. All rights reserved.
 *
 *
 * Version: TC38XA_UM_V1.5.0
 * Specification: TC3xx User Manual V1.5.0
 * MAY BE CHANGED BY USER [yes/no]: No
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * \defgroup IfxSfr_Stm_Registers Stm Registers
 * \ingroup IfxSfr
 * 
 * \defgroup IfxSfr_Stm_Registers_Bitfields Bitfields
 * \ingroup IfxSfr_Stm_Registers
 * 
 * \defgroup IfxSfr_Stm_Registers_union Register unions
 * \ingroup IfxSfr_Stm_Registers
 * 
 * \defgroup IfxSfr_Stm_Registers_struct Memory map
 * \ingroup IfxSfr_Stm_Registers
 */


/******************************************************************************/

/******************************************************************************/

/******************************************************************************/

/******************************************************************************/


/** \addtogroup IfxSfr_Stm_Registers_Bitfields
 * \{  */
/** \brief Access Enable Register 0 */
typedef struct _Ifx_STM_ACCEN0_Bits
{
    Ifx_UReg_32Bit EN0:1;             /**< \brief [0:0] Access Enable for Master TAG ID 0 - EN0 (rw) */
    Ifx_UReg_32Bit EN1:1;             /**< \brief [1:1] Access Enable for Master TAG ID 1 - EN1 (rw) */
    Ifx_UReg_32Bit EN2:1;             /**< \brief [2:2] Access Enable for Master TAG ID 2 - EN2 (rw) */
    Ifx_UReg_32Bit EN3:1;             /**< \brief [3:3] Access Enable for Master TAG ID 3 - EN3 (rw) */
    Ifx_UReg_32Bit EN4:1;             /**< \brief [4:4] Access Enable for Master TAG ID 4 - EN4 (rw) */
    Ifx_UReg_32Bit EN5:1;             /**< \brief [5:5] Access Enable for Master TAG ID 5 - EN5 (rw) */
    Ifx_UReg_32Bit EN6:1;             /**< \brief [6:6] Access Enable for Master TAG ID 6 - EN6 (rw) */
    Ifx_UReg_32Bit EN7:1;             /**< \brief [7:7] Access Enable for Master TAG ID 7 - EN7 (rw) */
    Ifx_UReg_32Bit EN8:1;             /**< \brief [8:8] Access Enable for Master TAG ID 8 - EN8 (rw) */
    Ifx_UReg_32Bit EN9:1;             /**< \brief [9:9] Access Enable for Master TAG ID 9 - EN9 (rw) */
    Ifx_UReg_32Bit EN10:1;            /**< \brief [10:10] Access Enable for Master TAG ID 10 - EN10 (rw) */
    Ifx_UReg_32Bit EN11:1;            /**< \brief [11:11] Access Enable for Master TAG ID 11 - EN11 (rw) */
    Ifx_UReg_32Bit EN12:1;            /**< \brief [12:12] Access Enable for Master TAG ID 12 - EN12 (rw) */
    Ifx_UReg_32Bit EN13:1;            /**< \brief [13:13] Access Enable for Master TAG ID 13 - EN13 (rw) */
    Ifx_UReg_32Bit EN14:1;            /**< \brief [14:14] Access Enable for Master TAG ID 14 - EN14 (rw) */
    Ifx_UReg_32Bit EN15:1;            /**< \brief [15:15] Access Enable for Master TAG ID 15 - EN15 (rw) */
    Ifx_UReg_32Bit EN16:1;            /**< \brief [16:16] Access Enable for Master TAG ID 16 - EN16 (rw) */
    Ifx_UReg_32Bit EN17:1;            /**< \brief [17:17] Access Enable for Master TAG ID 17 - EN17 (rw) */
    Ifx_UReg_32Bit EN18:1;            /**< \brief [18:18] Access Enable for Master TAG ID 18 - EN18 (rw) */
    Ifx_UReg_32Bit EN19:1;            /**< \brief [19:19] Access Enable for Master TAG ID 19 - EN19 (rw) */
    Ifx_UReg_32Bit EN20:1;            /**< \brief [20:20] Access Enable for Master TAG ID 20 - EN20 (rw) */
    Ifx_UReg_32Bit EN21:1;            /**< \brief [21:21] Access Enable for Master TAG ID 21 - EN21 (rw) */
    Ifx_UReg_32Bit EN22:1;            /**< \brief [22:22] Access Enable for Master TAG ID 22 - EN22 (rw) */
    Ifx_UReg_32Bit EN23:1;            /**< \brief [23:23] Access Enable for Master TAG ID 23 - EN23 (rw) */
    Ifx_UReg_32Bit EN24:1;            /**< \brief [24:24] Access Enable for Master TAG ID 24 - EN24 (rw) */
    Ifx_UReg_32Bit EN25:1;            /**< \brief [25:25] Access Enable for Master TAG ID 25 - EN25 (rw) */
    Ifx_UReg_32Bit EN26:1;            /**< \brief [26:26] Access Enable for Master TAG ID 26 - EN26 (rw) */
    Ifx_UReg_32Bit EN27:1;            /**< \brief [27:27] Access Enable for Master TAG ID 27 - EN27 (rw) */
    Ifx_UReg_32Bit EN28:1;            /**< \brief [28:28] Access Enable for Master TAG ID 28 - EN28 (rw) */
    Ifx_UReg_32Bit EN29:1;            /**< \brief [29:29] Access Enable for Master TAG ID 29 - EN29 (rw) */
    Ifx_UReg_32Bit EN30:1;            /**< \brief [30:30] Access Enable for Master TAG ID 30 - EN30 (rw) */
    Ifx_UReg_32Bit EN31:1;            /**< \brief [31:31] Access Enable for Master TAG ID 31 - EN31 (rw) */
} Ifx_STM_ACCEN0_Bits;

/** \brief Access Enable Register 1 */
typedef struct _Ifx_STM_ACCEN1_Bits
{
    Ifx_UReg_32Bit reserved_0:32;     /**< \brief [31:0] \internal Reserved */
} Ifx_STM_ACCEN1_Bits;

/** \brief Timer Capture Register */
typedef struct _Ifx_STM_CAP_Bits
{
    Ifx_UReg_32Bit STMCAP_63_32:32;    /**< \brief [31:0] Captured System Timer Bits [63:32] - STMCAP[63:32] (rh) */
} Ifx_STM_CAP_Bits;

/** \brief Timer Capture Register Second View */
typedef struct _Ifx_STM_CAPSV_Bits
{
    Ifx_UReg_32Bit STMCAP_63_32:32;    /**< \brief [31:0] Captured System Timer Bits [63:32] - STMCAP[63:32] (rh) */
} Ifx_STM_CAPSV_Bits;

/** \brief Clock Control Register */
typedef struct _Ifx_STM_CLC_Bits
{
    Ifx_UReg_32Bit DISR:1;            /**< \brief [0:0] Module Disable Request Bit - DISR (rw) */
    Ifx_UReg_32Bit DISS:1;            /**< \brief [1:1] Module Disable Status Bit - DISS (r) */
    Ifx_UReg_32Bit reserved_2:1;      /**< \brief [2:2] \internal Reserved */
    Ifx_UReg_32Bit EDIS:1;            /**< \brief [3:3] Sleep Mode Enable Control - EDIS (rw) */
    Ifx_UReg_32Bit reserved_4:28;     /**< \brief [31:4] \internal Reserved */
} Ifx_STM_CLC_Bits;

/** \brief Compare Match Control Register */
typedef struct _Ifx_STM_CMCON_Bits
{
    Ifx_UReg_32Bit MSIZE0:5;          /**< \brief [4:0] Compare Register Size for CMP0 - MSIZE0 (rw) */
    Ifx_UReg_32Bit reserved_5:3;      /**< \brief [7:5] \internal Reserved */
    Ifx_UReg_32Bit MSTART0:5;         /**< \brief [12:8] Start Bit Location for CMP0 - MSTART0 (rw) */
    Ifx_UReg_32Bit reserved_13:3;     /**< \brief [15:13] \internal Reserved */
    Ifx_UReg_32Bit MSIZE1:5;          /**< \brief [20:16] Compare Register Size for CMP1 - MSIZE1 (rw) */
    Ifx_UReg_32Bit reserved_21:3;     /**< \brief [23:21] \internal Reserved */
    Ifx_UReg_32Bit MSTART1:5;         /**< \brief [28:24] Start Bit Location for CMP1 - MSTART1 (rw) */
    Ifx_UReg_32Bit reserved_29:3;     /**< \brief [31:29] \internal Reserved */
} Ifx_STM_CMCON_Bits;

/** \brief Compare Register ${x} */
typedef struct _Ifx_STM_CMP_Bits
{
    Ifx_UReg_32Bit CMPVAL:32;         /**< \brief [31:0] Compare Value of Compare Register x - CMPVAL (rw) */
} Ifx_STM_CMP_Bits;

/** \brief Interrupt Control Register */
typedef struct _Ifx_STM_ICR_Bits
{
    Ifx_UReg_32Bit CMP0EN:1;          /**< \brief [0:0] Compare Register CMP0 Interrupt Enable Control - CMP0EN (rw) */
    Ifx_UReg_32Bit CMP0IR:1;          /**< \brief [1:1] Compare Register CMP0 Interrupt Request Flag - CMP0IR (rh) */
    Ifx_UReg_32Bit CMP0OS:1;          /**< \brief [2:2] Compare Register CMP0 Interrupt Output Selection - CMP0OS (rw) */
    Ifx_UReg_32Bit reserved_3:1;      /**< \brief [3:3] \internal Reserved */
    Ifx_UReg_32Bit CMP1EN:1;          /**< \brief [4:4] Compare Register CMP1 Interrupt Enable Control - CMP1EN (rw) */
    Ifx_UReg_32Bit CMP1IR:1;          /**< \brief [5:5] Compare Register CMP1 Interrupt Request Flag - CMP1IR (rh) */
    Ifx_UReg_32Bit CMP1OS:1;          /**< \brief [6:6] Compare Register CMP1 Interrupt Output Selection - CMP1OS (rw) */
    Ifx_UReg_32Bit reserved_7:25;     /**< \brief [31:7] \internal Reserved */
} Ifx_STM_ICR_Bits;

/** \brief Module Identification Register */
typedef struct _Ifx_STM_ID_Bits
{
    Ifx_UReg_32Bit MODREV:8;          /**< \brief [7:0] Module Revision Number - MODREV (r) */
    Ifx_UReg_32Bit MODTYPE:8;         /**< \brief [15:8] Module Type - MODTYPE (r) */
    Ifx_UReg_32Bit MODNUM:16;         /**< \brief [31:16] Module Number Value - MODNUM (r) */
} Ifx_STM_ID_Bits;

/** \brief Interrupt Set/Clear Register */
typedef struct _Ifx_STM_ISCR_Bits
{
    Ifx_UReg_32Bit CMP0IRR:1;         /**< \brief [0:0] Reset Compare Register CMP0 Interrupt Flag - CMP0IRR (w) */
    Ifx_UReg_32Bit CMP0IRS:1;         /**< \brief [1:1] Set Compare Register CMP0 Interrupt Flag - CMP0IRS (w) */
    Ifx_UReg_32Bit CMP1IRR:1;         /**< \brief [2:2] Reset Compare Register CMP1 Interrupt Flag - CMP1IRR (w) */
    Ifx_UReg_32Bit CMP1IRS:1;         /**< \brief [3:3] Set Compare Register CMP1 Interrupt Flag - CMP1IRS (w) */
    Ifx_UReg_32Bit reserved_4:28;     /**< \brief [31:4] \internal Reserved */
} Ifx_STM_ISCR_Bits;

/** \brief Kernel Reset Register 0 */
typedef struct _Ifx_STM_KRST0_Bits
{
    Ifx_UReg_32Bit RST:1;             /**< \brief [0:0] Kernel Reset - RST (rwh) */
    Ifx_UReg_32Bit RSTSTAT:1;         /**< \brief [1:1] Kernel Reset Status - RSTSTAT (rh) */
    Ifx_UReg_32Bit reserved_2:30;     /**< \brief [31:2] \internal Reserved */
} Ifx_STM_KRST0_Bits;

/** \brief Kernel Reset Register 1 */
typedef struct _Ifx_STM_KRST1_Bits
{
    Ifx_UReg_32Bit RST:1;             /**< \brief [0:0] Kernel Reset - RST (rwh) */
    Ifx_UReg_32Bit reserved_1:31;     /**< \brief [31:1] \internal Reserved */
} Ifx_STM_KRST1_Bits;

/** \brief Kernel Reset Status Clear Register */
typedef struct _Ifx_STM_KRSTCLR_Bits
{
    Ifx_UReg_32Bit CLR:1;             /**< \brief [0:0] Kernel Reset Status Clear - CLR (w) */
    Ifx_UReg_32Bit reserved_1:31;     /**< \brief [31:1] \internal Reserved */
} Ifx_STM_KRSTCLR_Bits;

/** \brief OCDS Control and Status Register */
typedef struct _Ifx_STM_OCS_Bits
{
    Ifx_UReg_32Bit reserved_0:3;      /**< \brief [2:0] \internal Reserved */
    Ifx_UReg_32Bit reserved_3:21;     /**< \brief [23:3] \internal Reserved */
    Ifx_UReg_32Bit SUS:4;             /**< \brief [27:24] OCDS Suspend Control - SUS (rw) */
    Ifx_UReg_32Bit SUS_P:1;           /**< \brief [28:28] SUS Write Protection - SUS_P (w) */
    Ifx_UReg_32Bit SUSSTA:1;          /**< \brief [29:29] Suspend State - SUSSTA (rh) */
    Ifx_UReg_32Bit reserved_30:2;     /**< \brief [31:30] \internal Reserved */
} Ifx_STM_OCS_Bits;

/** \brief Timer Register 0 */
typedef struct _Ifx_STM_TIM0_Bits
{
    Ifx_UReg_32Bit STM_31_0:32;       /**< \brief [31:0] System Timer Bits [31:0] - STM[31:0] (r) */
} Ifx_STM_TIM0_Bits;

/** \brief Timer Register 0 Second View */
typedef struct _Ifx_STM_TIM0SV_Bits
{
    Ifx_UReg_32Bit STM_31_0:32;       /**< \brief [31:0] System Timer Bits [31:0] - STM[31:0] (r) */
} Ifx_STM_TIM0SV_Bits;

/** \brief Timer Register 1 */
typedef struct _Ifx_STM_TIM1_Bits
{
    Ifx_UReg_32Bit STM_35_4:32;       /**< \brief [31:0] System Timer Bits [35:4] - STM[35:4] (r) */
} Ifx_STM_TIM1_Bits;

/** \brief Timer Register 2 */
typedef struct _Ifx_STM_TIM2_Bits
{
    Ifx_UReg_32Bit STM_39_8:32;       /**< \brief [31:0] System Timer Bits [39:8] - STM[39:8] (r) */
} Ifx_STM_TIM2_Bits;

/** \brief Timer Register 3 */
typedef struct _Ifx_STM_TIM3_Bits
{
    Ifx_UReg_32Bit STM_43_12:32;      /**< \brief [31:0] System Timer Bits [43:12] - STM[43:12] (r) */
} Ifx_STM_TIM3_Bits;

/** \brief Timer Register 4 */
typedef struct _Ifx_STM_TIM4_Bits
{
    Ifx_UReg_32Bit STM_47_16:32;      /**< \brief [31:0] System Timer Bits [47:16] - STM[47:16] (r) */
} Ifx_STM_TIM4_Bits;

/** \brief Timer Register 5 */
typedef struct _Ifx_STM_TIM5_Bits
{
    Ifx_UReg_32Bit STM_51_20:32;      /**< \brief [31:0] System Timer Bits [51:20] - STM[51:20] (r) */
} Ifx_STM_TIM5_Bits;

/** \brief Timer Register 6 */
typedef struct _Ifx_STM_TIM6_Bits
{
    Ifx_UReg_32Bit STM_63_32:32;      /**< \brief [31:0] System Timer Bits [63:32] - STM[63:32] (r) */
} Ifx_STM_TIM6_Bits;

/** \}  */
/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_stm_Registers_union
 * \{   */
/** \brief Access Enable Register 0   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_STM_ACCEN0_Bits B;            /**< \brief Bitfield access */
} Ifx_STM_ACCEN0;

/** \brief Access Enable Register 1   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_STM_ACCEN1_Bits B;            /**< \brief Bitfield access */
} Ifx_STM_ACCEN1;

/** \brief Timer Capture Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_STM_CAP_Bits B;               /**< \brief Bitfield access */
} Ifx_STM_CAP;

/** \brief Timer Capture Register Second View   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_STM_CAPSV_Bits B;             /**< \brief Bitfield access */
} Ifx_STM_CAPSV;

/** \brief Clock Control Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_STM_CLC_Bits B;               /**< \brief Bitfield access */
} Ifx_STM_CLC;

/** \brief Compare Match Control Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_STM_CMCON_Bits B;             /**< \brief Bitfield access */
} Ifx_STM_CMCON;

/** \brief Compare Register ${x}   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_STM_CMP_Bits B;               /**< \brief Bitfield access */
} Ifx_STM_CMP;

/** \brief Interrupt Control Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_STM_ICR_Bits B;               /**< \brief Bitfield access */
} Ifx_STM_ICR;

/** \brief Module Identification Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_STM_ID_Bits B;                /**< \brief Bitfield access */
} Ifx_STM_ID;

/** \brief Interrupt Set/Clear Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_STM_ISCR_Bits B;              /**< \brief Bitfield access */
} Ifx_STM_ISCR;

/** \brief Kernel Reset Register 0   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_STM_KRST0_Bits B;             /**< \brief Bitfield access */
} Ifx_STM_KRST0;

/** \brief Kernel Reset Register 1   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_STM_KRST1_Bits B;             /**< \brief Bitfield access */
} Ifx_STM_KRST1;

/** \brief Kernel Reset Status Clear Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_STM_KRSTCLR_Bits B;           /**< \brief Bitfield access */
} Ifx_STM_KRSTCLR;

/** \brief OCDS Control and Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_STM_OCS_Bits B;               /**< \brief Bitfield access */
} Ifx_STM_OCS;

/** \brief Timer Register 0   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_STM_TIM0_Bits B;              /**< \brief Bitfield access */
} Ifx_STM_TIM0;

/** \brief Timer Register 0 Second View   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_STM_TIM0SV_Bits B;            /**< \brief Bitfield access */
} Ifx_STM_TIM0SV;

/** \brief Timer Register 1   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_STM_TIM1_Bits B;              /**< \brief Bitfield access */
} Ifx_STM_TIM1;

/** \brief Timer Register 2   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_STM_TIM2_Bits B;              /**< \brief Bitfield access */
} Ifx_STM_TIM2;

/** \brief Timer Register 3   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_STM_TIM3_Bits B;              /**< \brief Bitfield access */
} Ifx_STM_TIM3;

/** \brief Timer Register 4   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_STM_TIM4_Bits B;              /**< \brief Bitfield access */
} Ifx_STM_TIM4;

/** \brief Timer Register 5   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_STM_TIM5_Bits B;              /**< \brief Bitfield access */
} Ifx_STM_TIM5;

/** \brief Timer Register 6   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_STM_TIM6_Bits B;              /**< \brief Bitfield access */
} Ifx_STM_TIM6;

/** \}  */

/******************************************************************************/
/** \addtogroup IfxSfr_Stm_Registers_struct
 * \{  */
/******************************************************************************/
/** \name Object L0
 * \{  */

/** \brief STM object */
typedef volatile struct _Ifx_STM
{
       Ifx_STM_CLC                         CLC;                    /**< \brief 0, Clock Control Register*/
       Ifx_UReg_8Bit                       reserved_4[4];          /**< \brief 4, \internal Reserved */
       Ifx_STM_ID                          ID;                     /**< \brief 8, Module Identification Register*/
       Ifx_UReg_8Bit                       reserved_C[4];          /**< \brief C, \internal Reserved */
       Ifx_STM_TIM0                        TIM0;                   /**< \brief 10, Timer Register 0*/
       Ifx_STM_TIM1                        TIM1;                   /**< \brief 14, Timer Register 1*/
       Ifx_STM_TIM2                        TIM2;                   /**< \brief 18, Timer Register 2*/
       Ifx_STM_TIM3                        TIM3;                   /**< \brief 1C, Timer Register 3*/
       Ifx_STM_TIM4                        TIM4;                   /**< \brief 20, Timer Register 4*/
       Ifx_STM_TIM5                        TIM5;                   /**< \brief 24, Timer Register 5*/
       Ifx_STM_TIM6                        TIM6;                   /**< \brief 28, Timer Register 6*/
       Ifx_STM_CAP                         CAP;                    /**< \brief 2C, Timer Capture Register*/
       Ifx_STM_CMP                         CMP[2];                 /**< \brief 30, Compare Register ${x}*/
       Ifx_STM_CMCON                       CMCON;                  /**< \brief 38, Compare Match Control Register*/
       Ifx_STM_ICR                         ICR;                    /**< \brief 3C, Interrupt Control Register*/
       Ifx_STM_ISCR                        ISCR;                   /**< \brief 40, Interrupt Set/Clear Register*/
       Ifx_UReg_8Bit                       reserved_44[12];        /**< \brief 44, \internal Reserved */
       Ifx_STM_TIM0SV                      TIM0SV;                 /**< \brief 50, Timer Register 0 Second View*/
       Ifx_STM_CAPSV                       CAPSV;                  /**< \brief 54, Timer Capture Register Second View*/
       Ifx_UReg_8Bit                       reserved_58[144];       /**< \brief 58, \internal Reserved */
       Ifx_STM_OCS                         OCS;                    /**< \brief E8, OCDS Control and Status Register*/
       Ifx_STM_KRSTCLR                     KRSTCLR;                /**< \brief EC, Kernel Reset Status Clear Register*/
       Ifx_STM_KRST1                       KRST1;                  /**< \brief F0, Kernel Reset Register 1*/
       Ifx_STM_KRST0                       KRST0;                  /**< \brief F4, Kernel Reset Register 0*/
       Ifx_STM_ACCEN1                      ACCEN1;                 /**< \brief F8, Access Enable Register 1*/
       Ifx_STM_ACCEN0                      ACCEN0;                 /**< \brief FC, Access Enable Register 0*/
} Ifx_STM;

/** \}  */
/******************************************************************************/
/** \}  */


/******************************************************************************/

/******************************************************************************/


#line 66 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\Infra\\Sfr\\TC38A\\_Reg\\IfxStm_reg.h"
/******************************************************************************/

/******************************************************************************/

/******************************************************************************/

/** \addtogroup IfxSfr_Stm_Registers_Cfg_BaseAddress
 * \{  */

/** \brief STM object */




/** \}  */


/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Stm_Registers_Cfg_Stm0
 * \{  */
/** \brief 0, Clock Control Register */


/** \brief 8, Module Identification Register */


/** \brief 10, Timer Register 0 */


/** \brief 14, Timer Register 1 */


/** \brief 18, Timer Register 2 */


/** \brief 1C, Timer Register 3 */


/** \brief 20, Timer Register 4 */


/** \brief 24, Timer Register 5 */


/** \brief 28, Timer Register 6 */


/** \brief 2C, Timer Capture Register */


/** \brief 30, Compare Register 0 */


/** \brief 34, Compare Register 1 */


/** \brief 38, Compare Match Control Register */


/** \brief 3C, Interrupt Control Register */


/** \brief 40, Interrupt Set/Clear Register */


/** \brief 50, Timer Register 0 Second View */


/** \brief 54, Timer Capture Register Second View */


/** \brief E8, OCDS Control and Status Register */


/** \brief EC, Kernel Reset Status Clear Register */


/** \brief F0, Kernel Reset Register 1 */


/** \brief F4, Kernel Reset Register 0 */


/** \brief F8, Access Enable Register 1 */


/** \brief FC, Access Enable Register 0 */


/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Stm_Registers_Cfg_Stm1
 * \{  */
/** \brief 0, Clock Control Register */


/** \brief 8, Module Identification Register */


/** \brief 10, Timer Register 0 */


/** \brief 14, Timer Register 1 */


/** \brief 18, Timer Register 2 */


/** \brief 1C, Timer Register 3 */


/** \brief 20, Timer Register 4 */


/** \brief 24, Timer Register 5 */


/** \brief 28, Timer Register 6 */


/** \brief 2C, Timer Capture Register */


/** \brief 30, Compare Register 0 */


/** \brief 34, Compare Register 1 */


/** \brief 38, Compare Match Control Register */


/** \brief 3C, Interrupt Control Register */


/** \brief 40, Interrupt Set/Clear Register */


/** \brief 50, Timer Register 0 Second View */


/** \brief 54, Timer Capture Register Second View */


/** \brief E8, OCDS Control and Status Register */


/** \brief EC, Kernel Reset Status Clear Register */


/** \brief F0, Kernel Reset Register 1 */


/** \brief F4, Kernel Reset Register 0 */


/** \brief F8, Access Enable Register 1 */


/** \brief FC, Access Enable Register 0 */


/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Stm_Registers_Cfg_Stm2
 * \{  */
/** \brief 0, Clock Control Register */


/** \brief 8, Module Identification Register */


/** \brief 10, Timer Register 0 */


/** \brief 14, Timer Register 1 */


/** \brief 18, Timer Register 2 */


/** \brief 1C, Timer Register 3 */


/** \brief 20, Timer Register 4 */


/** \brief 24, Timer Register 5 */


/** \brief 28, Timer Register 6 */


/** \brief 2C, Timer Capture Register */


/** \brief 30, Compare Register 0 */


/** \brief 34, Compare Register 1 */


/** \brief 38, Compare Match Control Register */


/** \brief 3C, Interrupt Control Register */


/** \brief 40, Interrupt Set/Clear Register */


/** \brief 50, Timer Register 0 Second View */


/** \brief 54, Timer Capture Register Second View */


/** \brief E8, OCDS Control and Status Register */


/** \brief EC, Kernel Reset Status Clear Register */


/** \brief F0, Kernel Reset Register 1 */


/** \brief F4, Kernel Reset Register 0 */


/** \brief F8, Access Enable Register 1 */


/** \brief FC, Access Enable Register 0 */


/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Stm_Registers_Cfg_Stm3
 * \{  */
/** \brief 0, Clock Control Register */


/** \brief 8, Module Identification Register */


/** \brief 10, Timer Register 0 */


/** \brief 14, Timer Register 1 */


/** \brief 18, Timer Register 2 */


/** \brief 1C, Timer Register 3 */


/** \brief 20, Timer Register 4 */


/** \brief 24, Timer Register 5 */


/** \brief 28, Timer Register 6 */


/** \brief 2C, Timer Capture Register */


/** \brief 30, Compare Register 0 */


/** \brief 34, Compare Register 1 */


/** \brief 38, Compare Match Control Register */


/** \brief 3C, Interrupt Control Register */


/** \brief 40, Interrupt Set/Clear Register */


/** \brief 50, Timer Register 0 Second View */


/** \brief 54, Timer Capture Register Second View */


/** \brief E8, OCDS Control and Status Register */


/** \brief EC, Kernel Reset Status Clear Register */


/** \brief F0, Kernel Reset Register 1 */


/** \brief F4, Kernel Reset Register 0 */


/** \brief F8, Access Enable Register 1 */


/** \brief FC, Access Enable Register 0 */



/** \}  */

/******************************************************************************/

/******************************************************************************/


#line 73 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Cpu\\Std\\IfxCpu.h"


#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\Service\\CpuGeneric\\_Utilities\\Ifx_Assert.h"
/**
 * \file Ifx_Assert.h
 * \brief Assert functions.
 * \ingroup library_srvsw_utilities_assert
 *
 * \copyright Copyright (c) 2013 Infineon Technologies AG. All rights reserved.
 *
 * $Date: 2014-02-28 14:15:42 GMT$
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * \defgroup library_srvsw_utilities_assert Assertion
 * This module implements assertion functions.
 * \ingroup library_srvsw_utilities
 *
 */







/** \addtogroup library_srvsw_utilities_assert
 * \{ */








/** \brief Constant to be used to indicate  not implemented feature */

/** \brief Feature is not available on the selected hardware */






















/** \} */


#line 75 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Cpu\\Std\\IfxCpu.h"

#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Scu\\Std\\IfxScuWdt.h"
/**
 * \file IfxScuWdt.h
 * \brief SCU  basic functionality
 * \ingroup IfxLld_Scu
 *
 * \version iLLD_1_0_1_15_0_1
 * \copyright Copyright (c) 2019 Infineon Technologies AG. All rights reserved.
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 * This file contains the APIs for SCU Watchdog and Endinit related functions.
 *
 * \defgroup IfxLld_Scu_Std_Wdt Wdt Basic Functionality
 * \ingroup IfxLld_Scu_Std
 * \defgroup IfxLld_Scu_Std_Wdt_Wdt_Configuration Watchdog Configuration functions
 * \ingroup IfxLld_Scu_Std_Wdt
 * \defgroup IfxLld_Scu_Std_Wdt_Wdt_Endinit Watchdog Endinit functions
 * \ingroup IfxLld_Scu_Std_Wdt
 * \defgroup IfxLld_Scu_Std_Wdt_Wdt_Operative Watchdog Operative functions
 * \ingroup IfxLld_Scu_Std_Wdt
 * \defgroup IfxLld_Scu_Std_Wdt_Wdt_Endinit_Usage How to use Endinit APIs?
 * \ingroup IfxLld_Scu_Std_Wdt
 */


















































































































































































































































































































































































































































































































































































































































































#line 76 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Cpu\\Std\\IfxCpu.h"

#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Scu\\Std\\IfxScuCcu.h"
/**
 * \file IfxScuCcu.h
 * \brief SCU  basic functionality
 * \ingroup IfxLld_Scu
 *
 * \version iLLD_1_0_1_15_0_1
 * \copyright Copyright (c) 2019 Infineon Technologies AG. All rights reserved.
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 * \defgroup IfxLld_Scu SCU
 * \addtogroup IfxLld_Scu
 * \{
 * \defgroup IfxLld_ScuCcu How to use the Scu Clock driver?
 * \addtogroup IfxLld_ScuCcu
 * \{
 *
 * The Scu Clock control unit driver provides a default configuration for pll and Clock initialisation and set of peripheral clock configuration functions.
 *
 * In the following sections it will be described, how to integrate the driver into the application framework.
 *
 * \section IfxLld_ScuCcu_Std_Preparation Preparation
 * \subsection IfxLld_ScuCcu_Std_Include Include Files
 *
 * Include following header file into your C code:
 * \code
 * #include <Scu/Std/IfxScuCcu.h>
 * \endcode
 *
 * \subsection IfxLld_ScuCcu_Std_Variables Variables
 *
 * Declare the Clock Configuration variables in your C code:
 *
 * \code
 * // used globally
 *
 * // configuration for the PLL  steps
 * static IfxScuCcu_PllStepsConfig IfxScuCcu_testPllConfigSteps[] = {
 *     IFXSCU_CFG_PLL_STEPS
 * };
 *
 * static const IfxScuCcu_FlashWaitstateConfig IfxScuCcu_defaultFlashWaitstateConfig = IFXSCU_CFG_FLASH_WAITSTATE;
 * // Default configuration for the Clock Configuration
 * IfxScuCcu_Config                      IfxScuCcu_testClockConfig = {
 *     // IfxScuCcu_InitialStepConfig: Configuration of first step which is same as internal osc frequency.
 *     IFXSCU_CFG_PLL_INITIAL_STEP,
 *     //IfxScuCcu_PllThrottleConfig: Configuration of PLL throttling.
 *     {
 *         sizeof(IfxScuCcu_defaultPllConfigSteps) / sizeof(IfxScuCcu_PllStepConfig),
 *         IfxScuCcu_defaultPllConfigSteps
 *     },
 *     IFXSCU_CFG_CLK_DISTRIBUTION,
 *     &IfxScuCcu_defaultFlashWaitstateConfig,
 *     &IfxScuCcu_defaultModConfig
 * };
 *
 * \endcode
 *
 * \subsection IfxLld_ScuCcu_Std_Init Module Initialisation
 *
 * The module initialisation can be done in the same function. Here an example:
 * \code
 *
 *        // standard PLL & clock initialisation
 *         IfxScuCcu_init(&IfxScuCcu_testClockConfig);
 * \endcode
 *
 *    The SYS PLL, PER PLL1 , PLL2 and clocks are now initialised based on the XTAL and PLL values configured in Ifx_Cfg.h and are ready for use now!
 *
 * Alternately the PLL and clocks can be initialised using below method which provides greater control on the configuration.
 *
 * \code
 * static const IfxScuCcu_PllStepConfig IfxScuCcu_defaultPllConfigSteps[] = {
 *     {                   //Step 0 Config: 150MHz
 *         (4 - 1),        //uint8 k2Step;
 *         0.000100,       //float32 waitTime;
 *     },
 *     {                   //Step 1 Config: 200MHz
 *         (3 - 1),       //uint8 k2Step;
 *         0.000100,       //float32 waitTime;
 *     },
 *     {                   //Step 2 Config: 300MHz
 *         (2 - 1),        //uint8 k2Step;
 *         0.000100,       //float32 waitTime;
 *     }
 * };
 *     IfxScuCcu_Config        IfxScuCcu_sampleClockConfig;
 *
 *     IfxScuCcu_initConfig(&IfxScuCcu_sampleClockConfig);
 *
 *
 *
 *     IfxScuCcu_sampleClockConfig.pllInitialStepConfig.pllsParameters.pllInputClockSelection = IfxScuCcu_PllInputClockSelection_fOsc0;
 *
 *     //SYS PLL = 300Mhz, XTAL = 20Mhz
 *     IfxScuCcu_sampleClockConfig.pllInitialStepConfig.pllsParameters.sysPllConfig.k2Divider = IfxScuCcu_K2divider_2;
 *     IfxScuCcu_sampleClockConfig.pllInitialStepConfig.pllsParameters.sysPllConfig.nDivider = IfxScuCcu_Ndivider_60;
 *     IfxScuCcu_sampleClockConfig.pllInitialStepConfig.pllsParameters.sysPllConfig.pDivider = IfxScuCcu_Pdivider_2;
 *     IfxScuCcu_sampleClockConfig.pllInitialStepConfig.waitTime = 0.000200F;  // wait time
 *
 *     IfxScuCcu_sampleClockConfig.sysPllThrottleConfig.numOfSteps = sizeof(IfxScuCcu_defaultPllConfigSteps) / sizeof(IfxScuCcu_PllStepConfig); //  step clock incr
 *     IfxScuCcu_sampleClockConfig.sysPllThrottleConfig.pllSteps = IfxScuCcu_defaultPllConfigSteps;
 *
 *     // PER PLL1 = 240Mhz, PERPLL2 = 50Mhz
 *     IfxScuCcu_sampleClockConfig.pllInitialStepConfig.pllsParameters.perPllConfig.k2Divider = IfxScuCcu_K2divider_2;
 *     IfxScuCcu_sampleClockConfig.pllInitialStepConfig.pllsParameters.perPllConfig.k3Divider = IfxScuCcu_K3divider_6;
 *     IfxScuCcu_sampleClockConfig.pllInitialStepConfig.pllsParameters.perPllConfig.k3DividerBypass = 0;
 *     IfxScuCcu_sampleClockConfig.pllInitialStepConfig.pllsParameters.perPllConfig.nDivider = IfxScuCcu_Ndivider_24;
 *     IfxScuCcu_sampleClockConfig.pllInitialStepConfig.pllsParameters.perPllConfig.pDivider = IfxScuCcu_Pdivider_1;
 *
 *     // update CCUCON Config use mask and value as below
 *     IfxScuCcu_sampleClockConfig.clockDistribution.ccucon0.mask =IFXSCU_CFG_CCUCON0_MASK;
 *     IfxScuCcu_sampleClockConfig.clockDistribution.ccucon0.value = IFXSCU_CFG_CCUCON0;
 *
 *     // standard PLL & clock initialisation
 *     IfxScuCcu_init(&IfxScuCcu_sampleClockConfig);
 *
 * \endcode
 *
 * ** Modulation Configuration **
 * The SCU CCU module also provides an option to Frequency Modulate the clock.
 * The Modulation configuration can be done as follows:
 *
 * \code
 *
 * //define your modulation configuration structure:
 *
 *  IFX_CONST IfxScuCcu_Mod_Config IfxScuCcu_SampleModConfig = {
 *          IfxScuCcu_ModEn_disabled,          // disable is default //enable / disable modulation
 *          IfxScuCcu_ModulationAmplitude_0p5, // default 0 value  // specify the modulation amplitude %
 *
 *  }
 *  // put this as part of the CCU configuration:
 *  IfxScuCcu_sampleClockConfig.modulationConfig = &IfxScuCcu_SampleModConfig;
 *
 *  // now initalize the CCU PLL and clock with the init function
 *  IfxScuCcu_init(&IfxScuCcu_sampleClockConfig)
 * \endcode
 *
 * \}
 * \}
 *
 * \defgroup IfxLld_Scu_Std_Ccu Ccu Basic Functionality
 * \ingroup IfxLld_Scu_Std
 * \defgroup IfxLld_Scu_Std_Ccu_Ccu Clock Control Functions
 * \ingroup IfxLld_Scu_Std_Ccu
 * \defgroup IfxLld_Scu_Std_Ccu_Ccu_Operative Clock Control Operative Functions
 * \ingroup IfxLld_Scu_Std_Ccu
 * \defgroup IfxLld_Scu_Std_Ccu_Ccu_Configuration Clock Control Configuration Functions
 * \ingroup IfxLld_Scu_Std_Ccu
 * \defgroup IfxLld_Scu_Std_Ccu_Enum Enumerations
 * \ingroup IfxLld_Scu_Std_Ccu
 */




/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/




#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Cpu\\Std\\IfxCpu.h"
/**
 * \file IfxCpu.h
 * \brief CPU  basic functionality
 * \ingroup IfxLld_Cpu
 *
 * \version iLLD_1_0_1_15_0_1
 * \copyright Copyright (c) 2021 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 *
 * \defgroup IfxLld_Cpu_Std_Core Cpu Core Functions
 * \ingroup IfxLld_Cpu_Std
 * \defgroup IfxLld_Cpu_Std_Interrupt Interrupt Utility Functions
 * \ingroup IfxLld_Cpu_Std
 * \defgroup IfxLld_Cpu_Std_Cache Cache Management Functions
 * \ingroup IfxLld_Cpu_Std
 * \defgroup IfxLld_Cpu_Std_PerformanceCounter Performance Counter Functions
 * \ingroup IfxLld_Cpu_Std
 * \defgroup IfxLld_Cpu_Std_Synchronization Synchronization Functions
 * \ingroup IfxLld_Cpu_Std
 * \defgroup IfxLld_Cpu_Std_Utility Cpu Utility Functions
 * \ingroup IfxLld_Cpu_Std
 * \defgroup IfxLld_Cpu_Std_Enum Enumerations
 * \ingroup IfxLld_Cpu_Std
 * \defgroup IfxLld_Cpu_Std_DataStructures Data Structures
 * \ingroup IfxLld_Cpu_Std
 */

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 196 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Scu\\Std\\IfxScuCcu.h"



#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\_PinMap\\IfxScu_PinMap.h"
/**
 * \file IfxScu_PinMap.h
 * \brief SCU I/O map
 * \ingroup IfxLld_Scu
 *
 * \version iLLD_1_0_1_15_0_1
 * \copyright Copyright (c) 2017 Infineon Technologies AG. All rights reserved.
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * \defgroup IfxLld_Scu_pinmap SCU Pin Mapping
 * \ingroup IfxLld_Scu
 */







#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Port\\Std\\IfxPort.h"
/**
 * \file IfxPort.h
 * \brief PORT  basic functionality
 * \ingroup IfxLld_Port
 *
 * \version iLLD_1_0_1_15_0_1
 * \copyright Copyright (c) 2020 Infineon Technologies AG. All rights reserved.
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 *
 * \defgroup IfxLld_Port_Std_Enum Enumerations
 * \ingroup IfxLld_Port_Std
 * \defgroup IfxLld_Port_Std_DataStructures Data structures
 * \ingroup IfxLld_Port_Std
 * \defgroup IfxLld_Port_Std_SinglePin Single Pin Functions
 * \ingroup IfxLld_Port_Std
 * \defgroup IfxLld_Port_Std_PortGroup Group Access Functions
 * \ingroup IfxLld_Port_Std
 */




/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/


#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\_Impl\\IfxPort_cfg.h"
/**
 * \file IfxPort_cfg.h
 * \brief PORT on-chip implementation data
 * \ingroup IfxLld_Port
 *
 * \version iLLD_1_0_1_15_0_1
 * \copyright Copyright (c) 2018 Infineon Technologies AG. All rights reserved.
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 * \defgroup IfxLld_Port PORTS
 * \ingroup IfxLld
 * \defgroup IfxLld_Port_Impl Implementation
 * \ingroup IfxLld_Port
 * \defgroup IfxLld_Port_Std Standard Driver
 * \ingroup IfxLld_Port
 */




/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/


#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Cpu\\Std\\IfxCpu_Intrinsics.h"
/**
 * \file IfxCpu_Intrinsics.h
 * \ingroup IfxLld_Cpu_Intrinsics Intrinsics
 *
 * \version iLLD_1_0_1_15_0_1
 * \copyright Copyright (c) 2013 Infineon Technologies AG. All rights reserved.
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * \defgroup IfxLld_Cpu_Intrinsics Intrinsics
 * \ingroup IfxLld_Cpu_Std
 *
 */




























































































































#line 58 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\_Impl\\IfxPort_cfg.h"

#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\Infra\\Sfr\\TC38A\\_Reg\\IfxPort_reg.h"
/**
 * \file IfxPort_reg.h
 * \brief
 * \copyright Copyright (c) 2020 Infineon Technologies AG. All rights reserved.
 *
 *
 * Version: TC38XA_UM_V1.5.0
 * Specification: TC3xx User Manual V1.5.0
 * MAY BE CHANGED BY USER [yes/no]: No
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * \defgroup IfxSfr_P_Registers_Cfg P address
 * \ingroup IfxSfr_P_Registers
 * 
 * \defgroup IfxSfr_P_Registers_Cfg_BaseAddress Base address
 * \ingroup IfxSfr_P_Registers_Cfg
 *
 * \defgroup IfxSfr_P_Registers_Cfg_P00 2-P00
 * \ingroup IfxSfr_P_Registers_Cfg
 *
 * \defgroup IfxSfr_P_Registers_Cfg_P01 2-P01
 * \ingroup IfxSfr_P_Registers_Cfg
 *
 * \defgroup IfxSfr_P_Registers_Cfg_P02 2-P02
 * \ingroup IfxSfr_P_Registers_Cfg
 *
 * \defgroup IfxSfr_P_Registers_Cfg_P10 2-P10
 * \ingroup IfxSfr_P_Registers_Cfg
 *
 * \defgroup IfxSfr_P_Registers_Cfg_P11 2-P11
 * \ingroup IfxSfr_P_Registers_Cfg
 *
 * \defgroup IfxSfr_P_Registers_Cfg_P12 2-P12
 * \ingroup IfxSfr_P_Registers_Cfg
 *
 * \defgroup IfxSfr_P_Registers_Cfg_P13 2-P13
 * \ingroup IfxSfr_P_Registers_Cfg
 *
 * \defgroup IfxSfr_P_Registers_Cfg_P14 2-P14
 * \ingroup IfxSfr_P_Registers_Cfg
 *
 * \defgroup IfxSfr_P_Registers_Cfg_P15 2-P15
 * \ingroup IfxSfr_P_Registers_Cfg
 *
 * \defgroup IfxSfr_P_Registers_Cfg_P20 2-P20
 * \ingroup IfxSfr_P_Registers_Cfg
 *
 * \defgroup IfxSfr_P_Registers_Cfg_P21 2-P21
 * \ingroup IfxSfr_P_Registers_Cfg
 *
 * \defgroup IfxSfr_P_Registers_Cfg_P22 2-P22
 * \ingroup IfxSfr_P_Registers_Cfg
 *
 * \defgroup IfxSfr_P_Registers_Cfg_P23 2-P23
 * \ingroup IfxSfr_P_Registers_Cfg
 *
 * \defgroup IfxSfr_P_Registers_Cfg_P24 2-P24
 * \ingroup IfxSfr_P_Registers_Cfg
 *
 * \defgroup IfxSfr_P_Registers_Cfg_P25 2-P25
 * \ingroup IfxSfr_P_Registers_Cfg
 *
 * \defgroup IfxSfr_P_Registers_Cfg_P26 2-P26
 * \ingroup IfxSfr_P_Registers_Cfg
 *
 * \defgroup IfxSfr_P_Registers_Cfg_P30 2-P30
 * \ingroup IfxSfr_P_Registers_Cfg
 *
 * \defgroup IfxSfr_P_Registers_Cfg_P31 2-P31
 * \ingroup IfxSfr_P_Registers_Cfg
 *
 * \defgroup IfxSfr_P_Registers_Cfg_P32 2-P32
 * \ingroup IfxSfr_P_Registers_Cfg
 *
 * \defgroup IfxSfr_P_Registers_Cfg_P33 2-P33
 * \ingroup IfxSfr_P_Registers_Cfg
 *
 * \defgroup IfxSfr_P_Registers_Cfg_P34 2-P34
 * \ingroup IfxSfr_P_Registers_Cfg
 *
 * \defgroup IfxSfr_P_Registers_Cfg_P40 2-P40
 * \ingroup IfxSfr_P_Registers_Cfg
 *
 * \defgroup IfxSfr_P_Registers_Cfg_P41 2-P41
 * \ingroup IfxSfr_P_Registers_Cfg
 *
 *
 */


/******************************************************************************/

#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\Infra\\Sfr\\TC38A\\_Reg\\IfxPort_regdef.h"
/**
 * \file IfxPort_regdef.h
 * \brief
 * \copyright Copyright (c) 2020 Infineon Technologies AG. All rights reserved.
 *
 *
 * Version: TC38XA_UM_V1.5.0
 * Specification: TC3xx User Manual V1.5.0
 * MAY BE CHANGED BY USER [yes/no]: No
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * \defgroup IfxSfr_P_Registers P Registers
 * \ingroup IfxSfr
 * 
 * \defgroup IfxSfr_P_Registers_Bitfields Bitfields
 * \ingroup IfxSfr_P_Registers
 * 
 * \defgroup IfxSfr_P_Registers_union Register unions
 * \ingroup IfxSfr_P_Registers
 * 
 * \defgroup IfxSfr_P_Registers_struct Memory map
 * \ingroup IfxSfr_P_Registers
 */


/******************************************************************************/

/******************************************************************************/

/******************************************************************************/

/******************************************************************************/


/** \addtogroup IfxSfr_P_Registers_Bitfields
 * \{  */
/** \brief Port n Access Enable Register 0 */
typedef struct _Ifx_P_ACCEN0_Bits
{
    Ifx_UReg_32Bit EN0:1;             /**< \brief [0:0] Access Enable for Master TAG ID 0 (rw) */
    Ifx_UReg_32Bit EN1:1;             /**< \brief [1:1] Access Enable for Master TAG ID 1 (rw) */
    Ifx_UReg_32Bit EN2:1;             /**< \brief [2:2] Access Enable for Master TAG ID 2 (rw) */
    Ifx_UReg_32Bit EN3:1;             /**< \brief [3:3] Access Enable for Master TAG ID 3 (rw) */
    Ifx_UReg_32Bit EN4:1;             /**< \brief [4:4] Access Enable for Master TAG ID 4 (rw) */
    Ifx_UReg_32Bit EN5:1;             /**< \brief [5:5] Access Enable for Master TAG ID 5 (rw) */
    Ifx_UReg_32Bit EN6:1;             /**< \brief [6:6] Access Enable for Master TAG ID 6 (rw) */
    Ifx_UReg_32Bit EN7:1;             /**< \brief [7:7] Access Enable for Master TAG ID 7 (rw) */
    Ifx_UReg_32Bit EN8:1;             /**< \brief [8:8] Access Enable for Master TAG ID 8 (rw) */
    Ifx_UReg_32Bit EN9:1;             /**< \brief [9:9] Access Enable for Master TAG ID 9 (rw) */
    Ifx_UReg_32Bit EN10:1;            /**< \brief [10:10] Access Enable for Master TAG ID 10 (rw) */
    Ifx_UReg_32Bit EN11:1;            /**< \brief [11:11] Access Enable for Master TAG ID 11 (rw) */
    Ifx_UReg_32Bit EN12:1;            /**< \brief [12:12] Access Enable for Master TAG ID 12 (rw) */
    Ifx_UReg_32Bit EN13:1;            /**< \brief [13:13] Access Enable for Master TAG ID 13 (rw) */
    Ifx_UReg_32Bit EN14:1;            /**< \brief [14:14] Access Enable for Master TAG ID 14 (rw) */
    Ifx_UReg_32Bit EN15:1;            /**< \brief [15:15] Access Enable for Master TAG ID 15 (rw) */
    Ifx_UReg_32Bit EN16:1;            /**< \brief [16:16] Access Enable for Master TAG ID 16 (rw) */
    Ifx_UReg_32Bit EN17:1;            /**< \brief [17:17] Access Enable for Master TAG ID 17 (rw) */
    Ifx_UReg_32Bit EN18:1;            /**< \brief [18:18] Access Enable for Master TAG ID 18 (rw) */
    Ifx_UReg_32Bit EN19:1;            /**< \brief [19:19] Access Enable for Master TAG ID 19 (rw) */
    Ifx_UReg_32Bit EN20:1;            /**< \brief [20:20] Access Enable for Master TAG ID 20 (rw) */
    Ifx_UReg_32Bit EN21:1;            /**< \brief [21:21] Access Enable for Master TAG ID 21 (rw) */
    Ifx_UReg_32Bit EN22:1;            /**< \brief [22:22] Access Enable for Master TAG ID 22 (rw) */
    Ifx_UReg_32Bit EN23:1;            /**< \brief [23:23] Access Enable for Master TAG ID 23 (rw) */
    Ifx_UReg_32Bit EN24:1;            /**< \brief [24:24] Access Enable for Master TAG ID 24 (rw) */
    Ifx_UReg_32Bit EN25:1;            /**< \brief [25:25] Access Enable for Master TAG ID 25 (rw) */
    Ifx_UReg_32Bit EN26:1;            /**< \brief [26:26] Access Enable for Master TAG ID 26 (rw) */
    Ifx_UReg_32Bit EN27:1;            /**< \brief [27:27] Access Enable for Master TAG ID 27 (rw) */
    Ifx_UReg_32Bit EN28:1;            /**< \brief [28:28] Access Enable for Master TAG ID 28 (rw) */
    Ifx_UReg_32Bit EN29:1;            /**< \brief [29:29] Access Enable for Master TAG ID 29 (rw) */
    Ifx_UReg_32Bit EN30:1;            /**< \brief [30:30] Access Enable for Master TAG ID 30 (rw) */
    Ifx_UReg_32Bit EN31:1;            /**< \brief [31:31] Access Enable for Master TAG ID 31 (rw) */
} Ifx_P_ACCEN0_Bits;

/** \brief Port n Access Enable Register 1 */
typedef struct _Ifx_P_ACCEN1_Bits
{
    Ifx_UReg_32Bit reserved_0:32;     /**< \brief [31:0] \internal Reserved */
} Ifx_P_ACCEN1_Bits;

/** \brief Port n Emergency Stop Register */
typedef struct _Ifx_P_ESR_Bits
{
    Ifx_UReg_32Bit EN0:1;             /**< \brief [0:0] Emergency Stop Enable for Pin 0 (rw) */
    Ifx_UReg_32Bit EN1:1;             /**< \brief [1:1] Emergency Stop Enable for Pin 1 (rw) */
    Ifx_UReg_32Bit EN2:1;             /**< \brief [2:2] Emergency Stop Enable for Pin 2 (rw) */
    Ifx_UReg_32Bit EN3:1;             /**< \brief [3:3] Emergency Stop Enable for Pin 3 (rw) */
    Ifx_UReg_32Bit EN4:1;             /**< \brief [4:4] Emergency Stop Enable for Pin 4 (rw) */
    Ifx_UReg_32Bit EN5:1;             /**< \brief [5:5] Emergency Stop Enable for Pin 5 (rw) */
    Ifx_UReg_32Bit EN6:1;             /**< \brief [6:6] Emergency Stop Enable for Pin 6 (rw) */
    Ifx_UReg_32Bit EN7:1;             /**< \brief [7:7] Emergency Stop Enable for Pin 7 (rw) */
    Ifx_UReg_32Bit EN8:1;             /**< \brief [8:8] Emergency Stop Enable for Pin 8 (rw) */
    Ifx_UReg_32Bit EN9:1;             /**< \brief [9:9] Emergency Stop Enable for Pin 9 (rw) */
    Ifx_UReg_32Bit EN10:1;            /**< \brief [10:10] Emergency Stop Enable for Pin 10 (rw) */
    Ifx_UReg_32Bit EN11:1;            /**< \brief [11:11] Emergency Stop Enable for Pin 11 (rw) */
    Ifx_UReg_32Bit EN12:1;            /**< \brief [12:12] Emergency Stop Enable for Pin 12 (rw) */
    Ifx_UReg_32Bit EN13:1;            /**< \brief [13:13] Emergency Stop Enable for Pin 13 (rw) */
    Ifx_UReg_32Bit EN14:1;            /**< \brief [14:14] Emergency Stop Enable for Pin 14 (rw) */
    Ifx_UReg_32Bit EN15:1;            /**< \brief [15:15] Emergency Stop Enable for Pin 15 (rw) */
    Ifx_UReg_32Bit reserved_16:16;    /**< \brief [31:16] \internal Reserved */
} Ifx_P_ESR_Bits;

/** \brief Port n Identification Register */
typedef struct _Ifx_P_ID_Bits
{
    Ifx_UReg_32Bit MODREV:8;          /**< \brief [7:0] Module Revision Number (r) */
    Ifx_UReg_32Bit MODTYPE:8;         /**< \brief [15:8] Module Type (r) */
    Ifx_UReg_32Bit MODNUMBER:16;      /**< \brief [31:16] Module Number (r) */
} Ifx_P_ID_Bits;

/** \brief Port n Input Register */
typedef struct _Ifx_P_IN_Bits
{
    Ifx_UReg_32Bit P0:1;              /**< \brief [0:0] Input Bit 0 (rh) */
    Ifx_UReg_32Bit P1:1;              /**< \brief [1:1] Input Bit 1 (rh) */
    Ifx_UReg_32Bit P2:1;              /**< \brief [2:2] Input Bit 2 (rh) */
    Ifx_UReg_32Bit P3:1;              /**< \brief [3:3] Input Bit 3 (rh) */
    Ifx_UReg_32Bit P4:1;              /**< \brief [4:4] Input Bit 4 (rh) */
    Ifx_UReg_32Bit P5:1;              /**< \brief [5:5] Input Bit 5 (rh) */
    Ifx_UReg_32Bit P6:1;              /**< \brief [6:6] Input Bit 6 (rh) */
    Ifx_UReg_32Bit P7:1;              /**< \brief [7:7] Input Bit 7 (rh) */
    Ifx_UReg_32Bit P8:1;              /**< \brief [8:8] Input Bit 8 (rh) */
    Ifx_UReg_32Bit P9:1;              /**< \brief [9:9] Input Bit 9 (rh) */
    Ifx_UReg_32Bit P10:1;             /**< \brief [10:10] Input Bit 10 (rh) */
    Ifx_UReg_32Bit P11:1;             /**< \brief [11:11] Input Bit 11 (rh) */
    Ifx_UReg_32Bit P12:1;             /**< \brief [12:12] Input Bit 12 (rh) */
    Ifx_UReg_32Bit P13:1;             /**< \brief [13:13] Input Bit 13 (rh) */
    Ifx_UReg_32Bit P14:1;             /**< \brief [14:14] Input Bit 14 (rh) */
    Ifx_UReg_32Bit P15:1;             /**< \brief [15:15] Input Bit 15 (rh) */
    Ifx_UReg_32Bit reserved_16:16;    /**< \brief [31:16] \internal Reserved */
} Ifx_P_IN_Bits;

/** \brief Port n Input/Output Control Register 0 */
typedef struct _Ifx_P_IOCR0_Bits
{
    Ifx_UReg_32Bit reserved_0:3;      /**< \brief [2:0] \internal Reserved */
    Ifx_UReg_32Bit PC0:5;             /**< \brief [7:3] Port Control for Pin 0 (rw) */
    Ifx_UReg_32Bit reserved_8:3;      /**< \brief [10:8] \internal Reserved */
    Ifx_UReg_32Bit PC1:5;             /**< \brief [15:11] Port Control for Pin 1 (rw) */
    Ifx_UReg_32Bit reserved_16:3;     /**< \brief [18:16] \internal Reserved */
    Ifx_UReg_32Bit PC2:5;             /**< \brief [23:19] Port Control for Pin 2 (rw) */
    Ifx_UReg_32Bit reserved_24:3;     /**< \brief [26:24] \internal Reserved */
    Ifx_UReg_32Bit PC3:5;             /**< \brief [31:27] Port Control for Pin 3 (rw) */
} Ifx_P_IOCR0_Bits;

/** \brief Port n Input/Output Control Register 12 */
typedef struct _Ifx_P_IOCR12_Bits
{
    Ifx_UReg_32Bit reserved_0:3;      /**< \brief [2:0] \internal Reserved */
    Ifx_UReg_32Bit PC12:5;            /**< \brief [7:3] Port Control for Port n Pin 12 (rw) */
    Ifx_UReg_32Bit reserved_8:3;      /**< \brief [10:8] \internal Reserved */
    Ifx_UReg_32Bit PC13:5;            /**< \brief [15:11] Port Control for Port n Pin 13 (rw) */
    Ifx_UReg_32Bit reserved_16:3;     /**< \brief [18:16] \internal Reserved */
    Ifx_UReg_32Bit PC14:5;            /**< \brief [23:19] Port Control for Port n Pin 14 (rw) */
    Ifx_UReg_32Bit reserved_24:3;     /**< \brief [26:24] \internal Reserved */
    Ifx_UReg_32Bit PC15:5;            /**< \brief [31:27] Port Control for Port n Pin 15 (rw) */
} Ifx_P_IOCR12_Bits;

/** \brief Port n Input/Output Control Register 4 */
typedef struct _Ifx_P_IOCR4_Bits
{
    Ifx_UReg_32Bit reserved_0:3;      /**< \brief [2:0] \internal Reserved */
    Ifx_UReg_32Bit PC4:5;             /**< \brief [7:3] Port Control for Port n Pin 4 (rw) */
    Ifx_UReg_32Bit reserved_8:3;      /**< \brief [10:8] \internal Reserved */
    Ifx_UReg_32Bit PC5:5;             /**< \brief [15:11] Port Control for Port n Pin 5 (rw) */
    Ifx_UReg_32Bit reserved_16:3;     /**< \brief [18:16] \internal Reserved */
    Ifx_UReg_32Bit PC6:5;             /**< \brief [23:19] Port Control for Port n Pin 6 (rw) */
    Ifx_UReg_32Bit reserved_24:3;     /**< \brief [26:24] \internal Reserved */
    Ifx_UReg_32Bit PC7:5;             /**< \brief [31:27] Port Control for Port n Pin 7 (rw) */
} Ifx_P_IOCR4_Bits;

/** \brief Port n Input/Output Control Register 8 */
typedef struct _Ifx_P_IOCR8_Bits
{
    Ifx_UReg_32Bit reserved_0:3;      /**< \brief [2:0] \internal Reserved */
    Ifx_UReg_32Bit PC8:5;             /**< \brief [7:3] Port Control for Port n Pin 8 (rw) */
    Ifx_UReg_32Bit reserved_8:3;      /**< \brief [10:8] \internal Reserved */
    Ifx_UReg_32Bit PC9:5;             /**< \brief [15:11] Port Control for Port n Pin 9 (rw) */
    Ifx_UReg_32Bit reserved_16:3;     /**< \brief [18:16] \internal Reserved */
    Ifx_UReg_32Bit PC10:5;            /**< \brief [23:19] Port Control for Port n Pin 10 (rw) */
    Ifx_UReg_32Bit reserved_24:3;     /**< \brief [26:24] \internal Reserved */
    Ifx_UReg_32Bit PC11:5;            /**< \brief [31:27] Port Control for Port n Pin 11 (rw) */
} Ifx_P_IOCR8_Bits;

/** \brief Port n LVDS Pad Control Register ${x} */
typedef struct _Ifx_P_LPCR_Bits
{
    Ifx_UReg_32Bit REN_CTRL:1;        /**< \brief [0:0] LVDS RX_EN controller (rw) */
    Ifx_UReg_32Bit RX_EN:1;           /**< \brief [1:1] Enable Receive LVDS (rw) */
    Ifx_UReg_32Bit TERM:1;            /**< \brief [2:2] Select Receiver Termination Mode (rw) */
    Ifx_UReg_32Bit LRXTERM:3;         /**< \brief [5:3] LVDS RX Poly-resistor configuration value (rw) */
    Ifx_UReg_32Bit LVDSM:1;           /**< \brief [6:6] LVDS-M Mode (rw) */
    Ifx_UReg_32Bit PS:1;              /**< \brief [7:7] Pad Supply Selection (rw) */
    Ifx_UReg_32Bit TEN_CTRL:1;        /**< \brief [8:8] LVDS TX_EN controller (rw) */
    Ifx_UReg_32Bit TX_EN:1;           /**< \brief [9:9] Enable Transmit LVDS (rw) */
    Ifx_UReg_32Bit VDIFFADJ:2;        /**< \brief [11:10] LVDS Output Amplitude Tuning (rw) */
    Ifx_UReg_32Bit VOSDYN:1;          /**< \brief [12:12] Tune Bit of VOS Control Loop Static/Dynamic (rw) */
    Ifx_UReg_32Bit VOSEXT:1;          /**< \brief [13:13] Tune Bit of VOS Control Loop Internal/External (rw) */
    Ifx_UReg_32Bit TX_PD:1;           /**< \brief [14:14] LVDS Power Down (rw) */
    Ifx_UReg_32Bit TX_PWDPD:1;        /**< \brief [15:15] Enable TX Power down pull down. (rw) */
    Ifx_UReg_32Bit reserved_16:16;    /**< \brief [31:16] \internal Reserved */
} Ifx_P_LPCR_Bits;

/** \brief Port n Output Modification Clear Register */
typedef struct _Ifx_P_OMCR_Bits
{
    Ifx_UReg_32Bit reserved_0:16;     /**< \brief [15:0] \internal Reserved */
    Ifx_UReg_32Bit PCL0:1;            /**< \brief [16:16] Clear Bit 0 (w) */
    Ifx_UReg_32Bit PCL1:1;            /**< \brief [17:17] Clear Bit 1 (w) */
    Ifx_UReg_32Bit PCL2:1;            /**< \brief [18:18] Clear Bit 2 (w) */
    Ifx_UReg_32Bit PCL3:1;            /**< \brief [19:19] Clear Bit 3 (w) */
    Ifx_UReg_32Bit PCL4:1;            /**< \brief [20:20] Clear Bit 4 (w) */
    Ifx_UReg_32Bit PCL5:1;            /**< \brief [21:21] Clear Bit 5 (w) */
    Ifx_UReg_32Bit PCL6:1;            /**< \brief [22:22] Clear Bit 6 (w) */
    Ifx_UReg_32Bit PCL7:1;            /**< \brief [23:23] Clear Bit 7 (w) */
    Ifx_UReg_32Bit PCL8:1;            /**< \brief [24:24] Clear Bit 8 (w) */
    Ifx_UReg_32Bit PCL9:1;            /**< \brief [25:25] Clear Bit 9 (w) */
    Ifx_UReg_32Bit PCL10:1;           /**< \brief [26:26] Clear Bit 10 (w) */
    Ifx_UReg_32Bit PCL11:1;           /**< \brief [27:27] Clear Bit 11 (w) */
    Ifx_UReg_32Bit PCL12:1;           /**< \brief [28:28] Clear Bit 12 (w) */
    Ifx_UReg_32Bit PCL13:1;           /**< \brief [29:29] Clear Bit 13 (w) */
    Ifx_UReg_32Bit PCL14:1;           /**< \brief [30:30] Clear Bit 14 (w) */
    Ifx_UReg_32Bit PCL15:1;           /**< \brief [31:31] Clear Bit 15 (w) */
} Ifx_P_OMCR_Bits;

/** \brief Port n Output Modification Clear Register 0 */
typedef struct _Ifx_P_OMCR0_Bits
{
    Ifx_UReg_32Bit reserved_0:16;     /**< \brief [15:0] \internal Reserved */
    Ifx_UReg_32Bit PCL0:1;            /**< \brief [16:16] Clear Bit 0 (w) */
    Ifx_UReg_32Bit PCL1:1;            /**< \brief [17:17] Clear Bit 1 (w) */
    Ifx_UReg_32Bit PCL2:1;            /**< \brief [18:18] Clear Bit 2 (w) */
    Ifx_UReg_32Bit PCL3:1;            /**< \brief [19:19] Clear Bit 3 (w) */
    Ifx_UReg_32Bit reserved_20:12;    /**< \brief [31:20] \internal Reserved */
} Ifx_P_OMCR0_Bits;

/** \brief Port n Output Modification Clear Register 12 */
typedef struct _Ifx_P_OMCR12_Bits
{
    Ifx_UReg_32Bit reserved_0:28;     /**< \brief [27:0] \internal Reserved */
    Ifx_UReg_32Bit PCL12:1;           /**< \brief [28:28] Clear Bit 12 (w) */
    Ifx_UReg_32Bit PCL13:1;           /**< \brief [29:29] Clear Bit 13 (w) */
    Ifx_UReg_32Bit PCL14:1;           /**< \brief [30:30] Clear Bit 14 (w) */
    Ifx_UReg_32Bit PCL15:1;           /**< \brief [31:31] Clear Bit 15 (w) */
} Ifx_P_OMCR12_Bits;

/** \brief Port n Output Modification Clear Register 4 */
typedef struct _Ifx_P_OMCR4_Bits
{
    Ifx_UReg_32Bit reserved_0:20;     /**< \brief [19:0] \internal Reserved */
    Ifx_UReg_32Bit PCL4:1;            /**< \brief [20:20] Clear Bit 4 (w) */
    Ifx_UReg_32Bit PCL5:1;            /**< \brief [21:21] Clear Bit 5 (w) */
    Ifx_UReg_32Bit PCL6:1;            /**< \brief [22:22] Clear Bit 6 (w) */
    Ifx_UReg_32Bit PCL7:1;            /**< \brief [23:23] Clear Bit 7 (w) */
    Ifx_UReg_32Bit reserved_24:8;     /**< \brief [31:24] \internal Reserved */
} Ifx_P_OMCR4_Bits;

/** \brief Port n Output Modification Clear Register 8 */
typedef struct _Ifx_P_OMCR8_Bits
{
    Ifx_UReg_32Bit reserved_0:24;     /**< \brief [23:0] \internal Reserved */
    Ifx_UReg_32Bit PCL8:1;            /**< \brief [24:24] Clear Bit 8 (w) */
    Ifx_UReg_32Bit PCL9:1;            /**< \brief [25:25] Clear Bit 9 (w) */
    Ifx_UReg_32Bit PCL10:1;           /**< \brief [26:26] Clear Bit 10 (w) */
    Ifx_UReg_32Bit PCL11:1;           /**< \brief [27:27] Clear Bit 11 (w) */
    Ifx_UReg_32Bit reserved_28:4;     /**< \brief [31:28] \internal Reserved */
} Ifx_P_OMCR8_Bits;

/** \brief Port n Output Modification Register */
typedef struct _Ifx_P_OMR_Bits
{
    Ifx_UReg_32Bit PS0:1;             /**< \brief [0:0] Set Bit 0 (w) */
    Ifx_UReg_32Bit PS1:1;             /**< \brief [1:1] Set Bit 1 (w) */
    Ifx_UReg_32Bit PS2:1;             /**< \brief [2:2] Set Bit 2 (w) */
    Ifx_UReg_32Bit PS3:1;             /**< \brief [3:3] Set Bit 3 (w) */
    Ifx_UReg_32Bit PS4:1;             /**< \brief [4:4] Set Bit 4 (w) */
    Ifx_UReg_32Bit PS5:1;             /**< \brief [5:5] Set Bit 5 (w) */
    Ifx_UReg_32Bit PS6:1;             /**< \brief [6:6] Set Bit 6 (w) */
    Ifx_UReg_32Bit PS7:1;             /**< \brief [7:7] Set Bit 7 (w) */
    Ifx_UReg_32Bit PS8:1;             /**< \brief [8:8] Set Bit 8 (w) */
    Ifx_UReg_32Bit PS9:1;             /**< \brief [9:9] Set Bit 9 (w) */
    Ifx_UReg_32Bit PS10:1;            /**< \brief [10:10] Set Bit 10 (w) */
    Ifx_UReg_32Bit PS11:1;            /**< \brief [11:11] Set Bit 11 (w) */
    Ifx_UReg_32Bit PS12:1;            /**< \brief [12:12] Set Bit 12 (w) */
    Ifx_UReg_32Bit PS13:1;            /**< \brief [13:13] Set Bit 13 (w) */
    Ifx_UReg_32Bit PS14:1;            /**< \brief [14:14] Set Bit 14 (w) */
    Ifx_UReg_32Bit PS15:1;            /**< \brief [15:15] Set Bit 15 (w) */
    Ifx_UReg_32Bit PCL0:1;            /**< \brief [16:16] Clear Bit 0 (w) */
    Ifx_UReg_32Bit PCL1:1;            /**< \brief [17:17] Clear Bit 1 (w) */
    Ifx_UReg_32Bit PCL2:1;            /**< \brief [18:18] Clear Bit 2 (w) */
    Ifx_UReg_32Bit PCL3:1;            /**< \brief [19:19] Clear Bit 3 (w) */
    Ifx_UReg_32Bit PCL4:1;            /**< \brief [20:20] Clear Bit 4 (w) */
    Ifx_UReg_32Bit PCL5:1;            /**< \brief [21:21] Clear Bit 5 (w) */
    Ifx_UReg_32Bit PCL6:1;            /**< \brief [22:22] Clear Bit 6 (w) */
    Ifx_UReg_32Bit PCL7:1;            /**< \brief [23:23] Clear Bit 7 (w) */
    Ifx_UReg_32Bit PCL8:1;            /**< \brief [24:24] Clear Bit 8 (w) */
    Ifx_UReg_32Bit PCL9:1;            /**< \brief [25:25] Clear Bit 9 (w) */
    Ifx_UReg_32Bit PCL10:1;           /**< \brief [26:26] Clear Bit 10 (w) */
    Ifx_UReg_32Bit PCL11:1;           /**< \brief [27:27] Clear Bit 11 (w) */
    Ifx_UReg_32Bit PCL12:1;           /**< \brief [28:28] Clear Bit 12 (w) */
    Ifx_UReg_32Bit PCL13:1;           /**< \brief [29:29] Clear Bit 13 (w) */
    Ifx_UReg_32Bit PCL14:1;           /**< \brief [30:30] Clear Bit 14 (w) */
    Ifx_UReg_32Bit PCL15:1;           /**< \brief [31:31] Clear Bit 15 (w) */
} Ifx_P_OMR_Bits;

/** \brief Port n Output Modification Set Register */
typedef struct _Ifx_P_OMSR_Bits
{
    Ifx_UReg_32Bit PS0:1;             /**< \brief [0:0] Set Bit 0 (w) */
    Ifx_UReg_32Bit PS1:1;             /**< \brief [1:1] Set Bit 1 (w) */
    Ifx_UReg_32Bit PS2:1;             /**< \brief [2:2] Set Bit 2 (w) */
    Ifx_UReg_32Bit PS3:1;             /**< \brief [3:3] Set Bit 3 (w) */
    Ifx_UReg_32Bit PS4:1;             /**< \brief [4:4] Set Bit 4 (w) */
    Ifx_UReg_32Bit PS5:1;             /**< \brief [5:5] Set Bit 5 (w) */
    Ifx_UReg_32Bit PS6:1;             /**< \brief [6:6] Set Bit 6 (w) */
    Ifx_UReg_32Bit PS7:1;             /**< \brief [7:7] Set Bit 7 (w) */
    Ifx_UReg_32Bit PS8:1;             /**< \brief [8:8] Set Bit 8 (w) */
    Ifx_UReg_32Bit PS9:1;             /**< \brief [9:9] Set Bit 9 (w) */
    Ifx_UReg_32Bit PS10:1;            /**< \brief [10:10] Set Bit 10 (w) */
    Ifx_UReg_32Bit PS11:1;            /**< \brief [11:11] Set Bit 11 (w) */
    Ifx_UReg_32Bit PS12:1;            /**< \brief [12:12] Set Bit 12 (w) */
    Ifx_UReg_32Bit PS13:1;            /**< \brief [13:13] Set Bit 13 (w) */
    Ifx_UReg_32Bit PS14:1;            /**< \brief [14:14] Set Bit 14 (w) */
    Ifx_UReg_32Bit PS15:1;            /**< \brief [15:15] Set Bit 15 (w) */
    Ifx_UReg_32Bit reserved_16:16;    /**< \brief [31:16] \internal Reserved */
} Ifx_P_OMSR_Bits;

/** \brief Port n Output Modification Set Register 0 */
typedef struct _Ifx_P_OMSR0_Bits
{
    Ifx_UReg_32Bit PS0:1;             /**< \brief [0:0] Set Bit 0 (w) */
    Ifx_UReg_32Bit PS1:1;             /**< \brief [1:1] Set Bit 1 (w) */
    Ifx_UReg_32Bit PS2:1;             /**< \brief [2:2] Set Bit 2 (w) */
    Ifx_UReg_32Bit PS3:1;             /**< \brief [3:3] Set Bit 3 (w) */
    Ifx_UReg_32Bit reserved_4:28;     /**< \brief [31:4] \internal Reserved */
} Ifx_P_OMSR0_Bits;

/** \brief Port n Output Modification Set Register 12 */
typedef struct _Ifx_P_OMSR12_Bits
{
    Ifx_UReg_32Bit reserved_0:12;     /**< \brief [11:0] \internal Reserved */
    Ifx_UReg_32Bit PS12:1;            /**< \brief [12:12] Set Bit 12 (w) */
    Ifx_UReg_32Bit PS13:1;            /**< \brief [13:13] Set Bit 13 (w) */
    Ifx_UReg_32Bit PS14:1;            /**< \brief [14:14] Set Bit 14 (w) */
    Ifx_UReg_32Bit PS15:1;            /**< \brief [15:15] Set Bit 15 (w) */
    Ifx_UReg_32Bit reserved_16:16;    /**< \brief [31:16] \internal Reserved */
} Ifx_P_OMSR12_Bits;

/** \brief Port n Output Modification Set Register 4 */
typedef struct _Ifx_P_OMSR4_Bits
{
    Ifx_UReg_32Bit reserved_0:4;      /**< \brief [3:0] \internal Reserved */
    Ifx_UReg_32Bit PS4:1;             /**< \brief [4:4] Set Bit 4 (w) */
    Ifx_UReg_32Bit PS5:1;             /**< \brief [5:5] Set Bit 5 (w) */
    Ifx_UReg_32Bit PS6:1;             /**< \brief [6:6] Set Bit 6 (w) */
    Ifx_UReg_32Bit PS7:1;             /**< \brief [7:7] Set Bit 7 (w) */
    Ifx_UReg_32Bit reserved_8:24;     /**< \brief [31:8] \internal Reserved */
} Ifx_P_OMSR4_Bits;

/** \brief Port n Output Modification Set Register 8 */
typedef struct _Ifx_P_OMSR8_Bits
{
    Ifx_UReg_32Bit reserved_0:8;      /**< \brief [7:0] \internal Reserved */
    Ifx_UReg_32Bit PS8:1;             /**< \brief [8:8] Set Bit 8 (w) */
    Ifx_UReg_32Bit PS9:1;             /**< \brief [9:9] Set Bit 9 (w) */
    Ifx_UReg_32Bit PS10:1;            /**< \brief [10:10] Set Bit 10 (w) */
    Ifx_UReg_32Bit PS11:1;            /**< \brief [11:11] Set Bit 11 (w) */
    Ifx_UReg_32Bit reserved_12:20;    /**< \brief [31:12] \internal Reserved */
} Ifx_P_OMSR8_Bits;

/** \brief Port n Output Register */
typedef struct _Ifx_P_OUT_Bits
{
    Ifx_UReg_32Bit P0:1;              /**< \brief [0:0] Output Bit 0 (rwh) */
    Ifx_UReg_32Bit P1:1;              /**< \brief [1:1] Output Bit 1 (rwh) */
    Ifx_UReg_32Bit P2:1;              /**< \brief [2:2] Output Bit 2 (rwh) */
    Ifx_UReg_32Bit P3:1;              /**< \brief [3:3] Output Bit 3 (rwh) */
    Ifx_UReg_32Bit P4:1;              /**< \brief [4:4] Output Bit 4 (rwh) */
    Ifx_UReg_32Bit P5:1;              /**< \brief [5:5] Output Bit 5 (rwh) */
    Ifx_UReg_32Bit P6:1;              /**< \brief [6:6] Output Bit 6 (rwh) */
    Ifx_UReg_32Bit P7:1;              /**< \brief [7:7] Output Bit 7 (rwh) */
    Ifx_UReg_32Bit P8:1;              /**< \brief [8:8] Output Bit 8 (rwh) */
    Ifx_UReg_32Bit P9:1;              /**< \brief [9:9] Output Bit 9 (rwh) */
    Ifx_UReg_32Bit P10:1;             /**< \brief [10:10] Output Bit 10 (rwh) */
    Ifx_UReg_32Bit P11:1;             /**< \brief [11:11] Output Bit 11 (rwh) */
    Ifx_UReg_32Bit P12:1;             /**< \brief [12:12] Output Bit 12 (rwh) */
    Ifx_UReg_32Bit P13:1;             /**< \brief [13:13] Output Bit 13 (rwh) */
    Ifx_UReg_32Bit P14:1;             /**< \brief [14:14] Output Bit 14 (rwh) */
    Ifx_UReg_32Bit P15:1;             /**< \brief [15:15] Output Bit 15 (rwh) */
    Ifx_UReg_32Bit reserved_16:16;    /**< \brief [31:16] \internal Reserved */
} Ifx_P_OUT_Bits;

/** \brief Port n Pin Controller Select Register */
typedef struct _Ifx_P_PCSR_Bits
{
    Ifx_UReg_32Bit SEL0:1;            /**< \brief [0:0] Output Select for Pin 0 (rw) */
    Ifx_UReg_32Bit SEL1:1;            /**< \brief [1:1] Output Select for Pin 1 (rw) */
    Ifx_UReg_32Bit SEL2:1;            /**< \brief [2:2] Output Select for Pin 2 (rw) */
    Ifx_UReg_32Bit SEL3:1;            /**< \brief [3:3] Output Select for Pin 3 (rw) */
    Ifx_UReg_32Bit SEL4:1;            /**< \brief [4:4] Output Select for Pin 4 (rw) */
    Ifx_UReg_32Bit SEL5:1;            /**< \brief [5:5] Output Select for Pin 5 (rw) */
    Ifx_UReg_32Bit SEL6:1;            /**< \brief [6:6] Output Select for Pin 6 (rw) */
    Ifx_UReg_32Bit SEL7:1;            /**< \brief [7:7] Output Select for Pin 7 (rw) */
    Ifx_UReg_32Bit SEL8:1;            /**< \brief [8:8] Output Select for Pin 8 (rw) */
    Ifx_UReg_32Bit SEL9:1;            /**< \brief [9:9] Output Select for Pin 9 (rw) */
    Ifx_UReg_32Bit SEL10:1;           /**< \brief [10:10] Output Select for Pin 10 (rw) */
    Ifx_UReg_32Bit SEL11:1;           /**< \brief [11:11] Output Select for Pin 11 (rw) */
    Ifx_UReg_32Bit SEL12:1;           /**< \brief [12:12] Output Select for Pin 12 (rw) */
    Ifx_UReg_32Bit SEL13:1;           /**< \brief [13:13] Output Select for Pin 13 (rw) */
    Ifx_UReg_32Bit SEL14:1;           /**< \brief [14:14] Output Select for Pin 14 (rw) */
    Ifx_UReg_32Bit SEL15:1;           /**< \brief [15:15] Output Select for Pin 15 (rw) */
    Ifx_UReg_32Bit reserved_16:15;    /**< \brief [30:16] \internal Reserved */
    Ifx_UReg_32Bit LCK:1;             /**< \brief [31:31] Lock Status (rh) */
} Ifx_P_PCSR_Bits;

/** \brief Port n Pin Function Decision Control Register */
typedef struct _Ifx_P_PDISC_Bits
{
    Ifx_UReg_32Bit PDIS0:1;           /**< \brief [0:0] Pin Function Decision Control for Pin 0 (rw) */
    Ifx_UReg_32Bit PDIS1:1;           /**< \brief [1:1] Pin Function Decision Control for Pin 1 (rw) */
    Ifx_UReg_32Bit PDIS2:1;           /**< \brief [2:2] Pin Function Decision Control for Pin 2 (rw) */
    Ifx_UReg_32Bit PDIS3:1;           /**< \brief [3:3] Pin Function Decision Control for Pin 3 (rw) */
    Ifx_UReg_32Bit PDIS4:1;           /**< \brief [4:4] Pin Function Decision Control for Pin 4 (rw) */
    Ifx_UReg_32Bit PDIS5:1;           /**< \brief [5:5] Pin Function Decision Control for Pin 5 (rw) */
    Ifx_UReg_32Bit PDIS6:1;           /**< \brief [6:6] Pin Function Decision Control for Pin 6 (rw) */
    Ifx_UReg_32Bit PDIS7:1;           /**< \brief [7:7] Pin Function Decision Control for Pin 7 (rw) */
    Ifx_UReg_32Bit PDIS8:1;           /**< \brief [8:8] Pin Function Decision Control for Pin 8 (rw) */
    Ifx_UReg_32Bit PDIS9:1;           /**< \brief [9:9] Pin Function Decision Control for Pin 9 (rw) */
    Ifx_UReg_32Bit PDIS10:1;          /**< \brief [10:10] Pin Function Decision Control for Pin 10 (rw) */
    Ifx_UReg_32Bit PDIS11:1;          /**< \brief [11:11] Pin Function Decision Control for Pin 11 (rw) */
    Ifx_UReg_32Bit PDIS12:1;          /**< \brief [12:12] Pin Function Decision Control for Pin 12 (rw) */
    Ifx_UReg_32Bit PDIS13:1;          /**< \brief [13:13] Pin Function Decision Control for Pin 13 (rw) */
    Ifx_UReg_32Bit PDIS14:1;          /**< \brief [14:14] Pin Function Decision Control for Pin 14 (rw) */
    Ifx_UReg_32Bit PDIS15:1;          /**< \brief [15:15] Pin Function Decision Control for Pin 15 (rw) */
    Ifx_UReg_32Bit reserved_16:16;    /**< \brief [31:16] \internal Reserved */
} Ifx_P_PDISC_Bits;

/** \brief Port n Pad Driver Mode Register 0 */
typedef struct _Ifx_P_PDR0_Bits
{
    Ifx_UReg_32Bit PD0:2;             /**< \brief [1:0] Pad Driver Mode for Pin 0 (rw) */
    Ifx_UReg_32Bit PL0:2;             /**< \brief [3:2] Pad Level Selection for Pin 0 (rw) */
    Ifx_UReg_32Bit PD1:2;             /**< \brief [5:4] Pad Driver Mode for Pin 1 (rw) */
    Ifx_UReg_32Bit PL1:2;             /**< \brief [7:6] Pad Level Selection for Pin 1 (rw) */
    Ifx_UReg_32Bit PD2:2;             /**< \brief [9:8] Pad Driver Mode for Pin 2 (rw) */
    Ifx_UReg_32Bit PL2:2;             /**< \brief [11:10] Pad Level Selection for Pin 2 (rw) */
    Ifx_UReg_32Bit PD3:2;             /**< \brief [13:12] Pad Driver Mode for Pin 3 (rw) */
    Ifx_UReg_32Bit PL3:2;             /**< \brief [15:14] Pad Level Selection for Pin 3 (rw) */
    Ifx_UReg_32Bit PD4:2;             /**< \brief [17:16] Pad Driver Mode for Pin 4 (rw) */
    Ifx_UReg_32Bit PL4:2;             /**< \brief [19:18] Pad Level Selection for Pin 4 (rw) */
    Ifx_UReg_32Bit PD5:2;             /**< \brief [21:20] Pad Driver Mode for Pin 5 (rw) */
    Ifx_UReg_32Bit PL5:2;             /**< \brief [23:22] Pad Level Selection for Pin 5 (rw) */
    Ifx_UReg_32Bit PD6:2;             /**< \brief [25:24] Pad Driver Mode for Pin 6 (rw) */
    Ifx_UReg_32Bit PL6:2;             /**< \brief [27:26] Pad Level Selection for Pin 6 (rw) */
    Ifx_UReg_32Bit PD7:2;             /**< \brief [29:28] Pad Driver Mode for Pin 7 (rw) */
    Ifx_UReg_32Bit PL7:2;             /**< \brief [31:30] Pad Level Selection for Pin 7 (rw) */
} Ifx_P_PDR0_Bits;

/** \brief Port n Pad Driver Mode Register 1 */
typedef struct _Ifx_P_PDR1_Bits
{
    Ifx_UReg_32Bit PD8:2;             /**< \brief [1:0] Pad Driver Mode for Pin 8 (rw) */
    Ifx_UReg_32Bit PL8:2;             /**< \brief [3:2] Pad Level Selection for Pin 8 (rw) */
    Ifx_UReg_32Bit PD9:2;             /**< \brief [5:4] Pad Driver Mode for Pin 9 (rw) */
    Ifx_UReg_32Bit PL9:2;             /**< \brief [7:6] Pad Level Selection for Pin 9 (rw) */
    Ifx_UReg_32Bit PD10:2;            /**< \brief [9:8] Pad Driver Mode for Pin 10 (rw) */
    Ifx_UReg_32Bit PL10:2;            /**< \brief [11:10] Pad Level Selection for Pin 10 (rw) */
    Ifx_UReg_32Bit PD11:2;            /**< \brief [13:12] Pad Driver Mode for Pin 11 (rw) */
    Ifx_UReg_32Bit PL11:2;            /**< \brief [15:14] Pad Level Selection for Pin 11 (rw) */
    Ifx_UReg_32Bit PD12:2;            /**< \brief [17:16] Pad Driver Mode for Pin 12 (rw) */
    Ifx_UReg_32Bit PL12:2;            /**< \brief [19:18] Pad Level Selection for Pin 12 (rw) */
    Ifx_UReg_32Bit PD13:2;            /**< \brief [21:20] Pad Driver Mode for Pin 13 (rw) */
    Ifx_UReg_32Bit PL13:2;            /**< \brief [23:22] Pad Level Selection for Pin 13 (rw) */
    Ifx_UReg_32Bit PD14:2;            /**< \brief [25:24] Pad Driver Mode for Pin 14 (rw) */
    Ifx_UReg_32Bit PL14:2;            /**< \brief [27:26] Pad Level Selection for Pin 14 (rw) */
    Ifx_UReg_32Bit PD15:2;            /**< \brief [29:28] Pad Driver Mode for Pin 15 (rw) */
    Ifx_UReg_32Bit PL15:2;            /**< \brief [31:30] Pad Level Selection for Pin 15 (rw) */
} Ifx_P_PDR1_Bits;

/** \}  */
/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_p_Registers_union
 * \{   */
/** \brief Port n Access Enable Register 0   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_P_ACCEN0_Bits B;              /**< \brief Bitfield access */
} Ifx_P_ACCEN0;

/** \brief Port n Access Enable Register 1   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_P_ACCEN1_Bits B;              /**< \brief Bitfield access */
} Ifx_P_ACCEN1;

/** \brief Port n Emergency Stop Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_P_ESR_Bits B;                 /**< \brief Bitfield access */
} Ifx_P_ESR;

/** \brief Port n Identification Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_P_ID_Bits B;                  /**< \brief Bitfield access */
} Ifx_P_ID;

/** \brief Port n Input Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_P_IN_Bits B;                  /**< \brief Bitfield access */
} Ifx_P_IN;

/** \brief Port n Input/Output Control Register 0   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_P_IOCR0_Bits B;               /**< \brief Bitfield access */
} Ifx_P_IOCR0;

/** \brief Port n Input/Output Control Register 12   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_P_IOCR12_Bits B;              /**< \brief Bitfield access */
} Ifx_P_IOCR12;

/** \brief Port n Input/Output Control Register 4   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_P_IOCR4_Bits B;               /**< \brief Bitfield access */
} Ifx_P_IOCR4;

/** \brief Port n Input/Output Control Register 8   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_P_IOCR8_Bits B;               /**< \brief Bitfield access */
} Ifx_P_IOCR8;

/** \brief Port n LVDS Pad Control Register ${x}   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_P_LPCR_Bits B;                /**< \brief Bitfield access */
} Ifx_P_LPCR;

/** \brief Port n Output Modification Clear Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_P_OMCR_Bits B;                /**< \brief Bitfield access */
} Ifx_P_OMCR;

/** \brief Port n Output Modification Clear Register 0   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_P_OMCR0_Bits B;               /**< \brief Bitfield access */
} Ifx_P_OMCR0;

/** \brief Port n Output Modification Clear Register 12   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_P_OMCR12_Bits B;              /**< \brief Bitfield access */
} Ifx_P_OMCR12;

/** \brief Port n Output Modification Clear Register 4   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_P_OMCR4_Bits B;               /**< \brief Bitfield access */
} Ifx_P_OMCR4;

/** \brief Port n Output Modification Clear Register 8   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_P_OMCR8_Bits B;               /**< \brief Bitfield access */
} Ifx_P_OMCR8;

/** \brief Port n Output Modification Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_P_OMR_Bits B;                 /**< \brief Bitfield access */
} Ifx_P_OMR;

/** \brief Port n Output Modification Set Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_P_OMSR_Bits B;                /**< \brief Bitfield access */
} Ifx_P_OMSR;

/** \brief Port n Output Modification Set Register 0   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_P_OMSR0_Bits B;               /**< \brief Bitfield access */
} Ifx_P_OMSR0;

/** \brief Port n Output Modification Set Register 12   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_P_OMSR12_Bits B;              /**< \brief Bitfield access */
} Ifx_P_OMSR12;

/** \brief Port n Output Modification Set Register 4   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_P_OMSR4_Bits B;               /**< \brief Bitfield access */
} Ifx_P_OMSR4;

/** \brief Port n Output Modification Set Register 8   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_P_OMSR8_Bits B;               /**< \brief Bitfield access */
} Ifx_P_OMSR8;

/** \brief Port n Output Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_P_OUT_Bits B;                 /**< \brief Bitfield access */
} Ifx_P_OUT;

/** \brief Port n Pin Controller Select Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_P_PCSR_Bits B;                /**< \brief Bitfield access */
} Ifx_P_PCSR;

/** \brief Port n Pin Function Decision Control Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_P_PDISC_Bits B;               /**< \brief Bitfield access */
} Ifx_P_PDISC;

/** \brief Port n Pad Driver Mode Register 0   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_P_PDR0_Bits B;                /**< \brief Bitfield access */
} Ifx_P_PDR0;

/** \brief Port n Pad Driver Mode Register 1   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_P_PDR1_Bits B;                /**< \brief Bitfield access */
} Ifx_P_PDR1;

/** \}  */

/******************************************************************************/
/** \addtogroup IfxSfr_P_Registers_struct
 * \{  */
/******************************************************************************/
/** \name Object L0
 * \{  */

/** \brief P object */
typedef volatile struct _Ifx_P
{
       Ifx_P_OUT                           OUT;                    /**< \brief 0, Port n Output Register*/
       Ifx_P_OMR                           OMR;                    /**< \brief 4, Port n Output Modification Register*/
       Ifx_P_ID                            ID;                     /**< \brief 8, Port n Identification Register*/
       Ifx_UReg_8Bit                       reserved_C[4];          /**< \brief C, \internal Reserved */
       Ifx_P_IOCR0                         IOCR0;                  /**< \brief 10, Port n Input/Output Control Register 0*/
       Ifx_P_IOCR4                         IOCR4;                  /**< \brief 14, Port n Input/Output Control Register 4*/
       Ifx_P_IOCR8                         IOCR8;                  /**< \brief 18, Port n Input/Output Control Register 8*/
       Ifx_P_IOCR12                        IOCR12;                 /**< \brief 1C, Port n Input/Output Control Register 12*/
       Ifx_UReg_8Bit                       reserved_20[4];         /**< \brief 20, \internal Reserved */
       Ifx_P_IN                            IN;                     /**< \brief 24, Port n Input Register*/
       Ifx_UReg_8Bit                       reserved_28[24];        /**< \brief 28, \internal Reserved */
       Ifx_P_PDR0                          PDR0;                   /**< \brief 40, Port n Pad Driver Mode Register 0*/
       Ifx_P_PDR1                          PDR1;                   /**< \brief 44, Port n Pad Driver Mode Register 1*/
       Ifx_UReg_8Bit                       reserved_48[8];         /**< \brief 48, \internal Reserved */
       Ifx_P_ESR                           ESR;                    /**< \brief 50, Port n Emergency Stop Register*/
       Ifx_UReg_8Bit                       reserved_54[12];        /**< \brief 54, \internal Reserved */
       Ifx_P_PDISC                         PDISC;                  /**< \brief 60, Port n Pin Function Decision Control Register*/
       Ifx_P_PCSR                          PCSR;                   /**< \brief 64, Port n Pin Controller Select Register*/
       Ifx_UReg_8Bit                       reserved_68[8];         /**< \brief 68, \internal Reserved */
       Ifx_P_OMSR0                         OMSR0;                  /**< \brief 70, Port n Output Modification Set Register 0*/
       Ifx_P_OMSR4                         OMSR4;                  /**< \brief 74, Port n Output Modification Set Register 4*/
       Ifx_P_OMSR8                         OMSR8;                  /**< \brief 78, Port n Output Modification Set Register 8*/
       Ifx_P_OMSR12                        OMSR12;                 /**< \brief 7C, Port n Output Modification Set Register 12*/
       Ifx_P_OMCR0                         OMCR0;                  /**< \brief 80, Port n Output Modification Clear Register 0*/
       Ifx_P_OMCR4                         OMCR4;                  /**< \brief 84, Port n Output Modification Clear Register 4*/
       Ifx_P_OMCR8                         OMCR8;                  /**< \brief 88, Port n Output Modification Clear Register 8*/
       Ifx_P_OMCR12                        OMCR12;                 /**< \brief 8C, Port n Output Modification Clear Register 12*/
       Ifx_P_OMSR                          OMSR;                   /**< \brief 90, Port n Output Modification Set Register*/
       Ifx_P_OMCR                          OMCR;                   /**< \brief 94, Port n Output Modification Clear Register*/
       Ifx_UReg_8Bit                       reserved_98[8];         /**< \brief 98, \internal Reserved */
       Ifx_P_LPCR                          LPCR[8];                /**< \brief A0, Port n LVDS Pad Control Register ${x}*/
       Ifx_UReg_8Bit                       reserved_C0[56];        /**< \brief C0, \internal Reserved */
       Ifx_P_ACCEN1                        ACCEN1;                 /**< \brief F8, Port n Access Enable Register 1*/
       Ifx_P_ACCEN0                        ACCEN0;                 /**< \brief FC, Port n Access Enable Register 0*/
} Ifx_P;

/** \}  */
/******************************************************************************/
/** \}  */


/******************************************************************************/

/******************************************************************************/


#line 123 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\Infra\\Sfr\\TC38A\\_Reg\\IfxPort_reg.h"
/******************************************************************************/

/******************************************************************************/

/******************************************************************************/

/** \addtogroup IfxSfr_P_Registers_Cfg_BaseAddress
 * \{  */

/** \brief P object */























/** \}  */


/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_P_Registers_Cfg_P00
 * \{  */
/** \brief 0, Port 00 Output Register */


/** \brief 4, Port 00 Output Modification Register */


/** \brief 8, Port 00 Identification Register */


/** \brief 10, Port 00 Input/Output Control Register 0 */


/** \brief 14, Port 00 Input/Output Control Register 4 */


/** \brief 18, Port 00 Input/Output Control Register 8 */


/** \brief 1C, Port 00 Input/Output Control Register 12 */


/** \brief 24, Port 00 Input Register */


/** \brief 40, Port 00 Pad Driver Mode Register 0 */


/** \brief 44, Port 00 Pad Driver Mode Register 1 */


/** \brief 50, Port 00 Emergency Stop Register */


/** \brief 60, Port 00 Pin Function Decision Control Register */


/** \brief 64, Port 00 Pin Controller Select Register */


/** \brief 70, Port 00 Output Modification Set Register 0 */


/** \brief 74, Port 00 Output Modification Set Register 4 */


/** \brief 78, Port 00 Output Modification Set Register 8 */


/** \brief 7C, Port 00 Output Modification Set Register 12 */


/** \brief 80, Port 00 Output Modification Clear Register 0 */


/** \brief 84, Port 00 Output Modification Clear Register 4 */


/** \brief 88, Port 00 Output Modification Clear Register 8 */


/** \brief 8C, Port 00 Output Modification Clear Register 12 */


/** \brief 90, Port 00 Output Modification Set Register */


/** \brief 94, Port 00 Output Modification Clear Register */


/** \brief F8, Port 00 Access Enable Register 1 */


/** \brief FC, Port 00 Access Enable Register 0 */


/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_P_Registers_Cfg_P01
 * \{  */
/** \brief 0, Port 01 Output Register */


/** \brief 4, Port 01 Output Modification Register */


/** \brief 8, Port 01 Identification Register */


/** \brief 10, Port 01 Input/Output Control Register 0 */


/** \brief 14, Port 01 Input/Output Control Register 4 */


/** \brief 18, Port 01 Input/Output Control Register 8 */


/** \brief 1C, Port 01 Input/Output Control Register 12 */


/** \brief 24, Port 01 Input Register */


/** \brief 40, Port 01 Pad Driver Mode Register 0 */


/** \brief 44, Port 01 Pad Driver Mode Register 1 */


/** \brief 50, Port 01 Emergency Stop Register */


/** \brief 60, Port 01 Pin Function Decision Control Register */


/** \brief 64, Port 01 Pin Controller Select Register */


/** \brief 70, Port 01 Output Modification Set Register 0 */


/** \brief 74, Port 01 Output Modification Set Register 4 */


/** \brief 78, Port 01 Output Modification Set Register 8 */


/** \brief 7C, Port 01 Output Modification Set Register 12 */


/** \brief 80, Port 01 Output Modification Clear Register 0 */


/** \brief 84, Port 01 Output Modification Clear Register 4 */


/** \brief 88, Port 01 Output Modification Clear Register 8 */


/** \brief 8C, Port 01 Output Modification Clear Register 12 */


/** \brief 90, Port 01 Output Modification Set Register */


/** \brief 94, Port 01 Output Modification Clear Register */


/** \brief F8, Port 01 Access Enable Register 1 */


/** \brief FC, Port 01 Access Enable Register 0 */


/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_P_Registers_Cfg_P02
 * \{  */
/** \brief 0, Port 02 Output Register */


/** \brief 4, Port 02 Output Modification Register */


/** \brief 8, Port 02 Identification Register */


/** \brief 10, Port 02 Input/Output Control Register 0 */


/** \brief 14, Port 02 Input/Output Control Register 4 */


/** \brief 18, Port 02 Input/Output Control Register 8 */


/** \brief 1C, Port 02 Input/Output Control Register 12 */


/** \brief 24, Port 02 Input Register */


/** \brief 40, Port 02 Pad Driver Mode Register 0 */


/** \brief 44, Port 02 Pad Driver Mode Register 1 */


/** \brief 50, Port 02 Emergency Stop Register */


/** \brief 60, Port 02 Pin Function Decision Control Register */


/** \brief 64, Port 02 Pin Controller Select Register */


/** \brief 70, Port 02 Output Modification Set Register 0 */


/** \brief 74, Port 02 Output Modification Set Register 4 */


/** \brief 78, Port 02 Output Modification Set Register 8 */


/** \brief 7C, Port 02 Output Modification Set Register 12 */


/** \brief 80, Port 02 Output Modification Clear Register 0 */


/** \brief 84, Port 02 Output Modification Clear Register 4 */


/** \brief 88, Port 02 Output Modification Clear Register 8 */


/** \brief 8C, Port 02 Output Modification Clear Register 12 */


/** \brief 90, Port 02 Output Modification Set Register */


/** \brief 94, Port 02 Output Modification Clear Register */


/** \brief F8, Port 02 Access Enable Register 1 */


/** \brief FC, Port 02 Access Enable Register 0 */


/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_P_Registers_Cfg_P10
 * \{  */
/** \brief 0, Port 10 Output Register */


/** \brief 4, Port 10 Output Modification Register */


/** \brief 8, Port 10 Identification Register */


/** \brief 10, Port 10 Input/Output Control Register 0 */


/** \brief 14, Port 10 Input/Output Control Register 4 */


/** \brief 18, Port 10 Input/Output Control Register 8 */


/** \brief 1C, Port 10 Input/Output Control Register 12 */


/** \brief 24, Port 10 Input Register */


/** \brief 40, Port 10 Pad Driver Mode Register 0 */


/** \brief 44, Port 10 Pad Driver Mode Register 1 */


/** \brief 50, Port 10 Emergency Stop Register */


/** \brief 60, Port 10 Pin Function Decision Control Register */


/** \brief 64, Port 10 Pin Controller Select Register */


/** \brief 70, Port 10 Output Modification Set Register 0 */


/** \brief 74, Port 10 Output Modification Set Register 4 */


/** \brief 78, Port 10 Output Modification Set Register 8 */


/** \brief 7C, Port 10 Output Modification Set Register 12 */


/** \brief 80, Port 10 Output Modification Clear Register 0 */


/** \brief 84, Port 10 Output Modification Clear Register 4 */


/** \brief 88, Port 10 Output Modification Clear Register 8 */


/** \brief 8C, Port 10 Output Modification Clear Register 12 */


/** \brief 90, Port 10 Output Modification Set Register */


/** \brief 94, Port 10 Output Modification Clear Register */


/** \brief F8, Port 10 Access Enable Register 1 */


/** \brief FC, Port 10 Access Enable Register 0 */


/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_P_Registers_Cfg_P11
 * \{  */
/** \brief 0, Port 11 Output Register */


/** \brief 4, Port 11 Output Modification Register */


/** \brief 8, Port 11 Identification Register */


/** \brief 10, Port 11 Input/Output Control Register 0 */


/** \brief 14, Port 11 Input/Output Control Register 4 */


/** \brief 18, Port 11 Input/Output Control Register 8 */


/** \brief 1C, Port 11 Input/Output Control Register 12 */


/** \brief 24, Port 11 Input Register */


/** \brief 40, Port 11 Pad Driver Mode Register 0 */


/** \brief 44, Port 11 Pad Driver Mode Register 1 */


/** \brief 50, Port 11 Emergency Stop Register */


/** \brief 60, Port 11 Pin Function Decision Control Register */


/** \brief 64, Port 11 Pin Controller Select Register */


/** \brief 70, Port 11 Output Modification Set Register 0 */


/** \brief 74, Port 11 Output Modification Set Register 4 */


/** \brief 78, Port 11 Output Modification Set Register 8 */


/** \brief 7C, Port 11 Output Modification Set Register 12 */


/** \brief 80, Port 11 Output Modification Clear Register 0 */


/** \brief 84, Port 11 Output Modification Clear Register 4 */


/** \brief 88, Port 11 Output Modification Clear Register 8 */


/** \brief 8C, Port 11 Output Modification Clear Register 12 */


/** \brief 90, Port 11 Output Modification Set Register */


/** \brief 94, Port 11 Output Modification Clear Register */


/** \brief F8, Port 11 Access Enable Register 1 */


/** \brief FC, Port 11 Access Enable Register 0 */


/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_P_Registers_Cfg_P12
 * \{  */
/** \brief 0, Port 12 Output Register */


/** \brief 4, Port 12 Output Modification Register */


/** \brief 8, Port 12 Identification Register */


/** \brief 10, Port 12 Input/Output Control Register 0 */


/** \brief 24, Port 12 Input Register */


/** \brief 40, Port 12 Pad Driver Mode Register 0 */


/** \brief 50, Port 12 Emergency Stop Register */


/** \brief 60, Port 12 Pin Function Decision Control Register */


/** \brief 64, Port 12 Pin Controller Select Register */


/** \brief 70, Port 12 Output Modification Set Register 0 */


/** \brief 80, Port 12 Output Modification Clear Register 0 */


/** \brief 90, Port 12 Output Modification Set Register */


/** \brief 94, Port 12 Output Modification Clear Register */


/** \brief F8, Port 12 Access Enable Register 1 */


/** \brief FC, Port 12 Access Enable Register 0 */


/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_P_Registers_Cfg_P13
 * \{  */
/** \brief 0, Port 13 Output Register */


/** \brief 4, Port 13 Output Modification Register */


/** \brief 8, Port 13 Identification Register */


/** \brief 10, Port 13 Input/Output Control Register 0 */


/** \brief 14, Port 13 Input/Output Control Register 4 */


/** \brief 18, Port 13 Input/Output Control Register 8 */


/** \brief 1C, Port 13 Input/Output Control Register 12 */


/** \brief 24, Port 13 Input Register */


/** \brief 40, Port 13 Pad Driver Mode Register 0 */


/** \brief 44, Port 13 Pad Driver Mode Register 1 */


/** \brief 50, Port 13 Emergency Stop Register */


/** \brief 60, Port 13 Pin Function Decision Control Register */


/** \brief 64, Port 13 Pin Controller Select Register */


/** \brief 70, Port 13 Output Modification Set Register 0 */


/** \brief 74, Port 13 Output Modification Set Register 4 */


/** \brief 78, Port 13 Output Modification Set Register 8 */


/** \brief 7C, Port 13 Output Modification Set Register 12 */


/** \brief 80, Port 13 Output Modification Clear Register 0 */


/** \brief 84, Port 13 Output Modification Clear Register 4 */


/** \brief 88, Port 13 Output Modification Clear Register 8 */


/** \brief 8C, Port 13 Output Modification Clear Register 12 */


/** \brief 90, Port 13 Output Modification Set Register */


/** \brief 94, Port 13 Output Modification Clear Register */


/** \brief A0, Port 13 LVDS Pad Control Register 0 */


/** \brief A4, Port 13 LVDS Pad Control Register 1 */


/** \brief A8, Port 13 LVDS Pad Control Register 2 */


/** \brief AC, Port 13 LVDS Pad Control Register 3 */


/** \brief F8, Port 13 Access Enable Register 1 */


/** \brief FC, Port 13 Access Enable Register 0 */


/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_P_Registers_Cfg_P14
 * \{  */
/** \brief 0, Port 14 Output Register */


/** \brief 4, Port 14 Output Modification Register */


/** \brief 8, Port 14 Identification Register */


/** \brief 10, Port 14 Input/Output Control Register 0 */


/** \brief 14, Port 14 Input/Output Control Register 4 */


/** \brief 18, Port 14 Input/Output Control Register 8 */


/** \brief 1C, Port 14 Input/Output Control Register 12 */


/** \brief 24, Port 14 Input Register */


/** \brief 40, Port 14 Pad Driver Mode Register 0 */


/** \brief 44, Port 14 Pad Driver Mode Register 1 */


/** \brief 50, Port 14 Emergency Stop Register */


/** \brief 60, Port 14 Pin Function Decision Control Register */


/** \brief 64, Port 14 Pin Controller Select Register */


/** \brief 70, Port 14 Output Modification Set Register 0 */


/** \brief 74, Port 14 Output Modification Set Register 4 */


/** \brief 78, Port 14 Output Modification Set Register 8 */


/** \brief 7C, Port 14 Output Modification Set Register 12 */


/** \brief 80, Port 14 Output Modification Clear Register 0 */


/** \brief 84, Port 14 Output Modification Clear Register 4 */


/** \brief 88, Port 14 Output Modification Clear Register 8 */


/** \brief 8C, Port 14 Output Modification Clear Register 12 */


/** \brief 90, Port 14 Output Modification Set Register */


/** \brief 94, Port 14 Output Modification Clear Register */


/** \brief B4, Port 14 LVDS Pad Control Register 5 */


/** \brief F8, Port 14 Access Enable Register 1 */


/** \brief FC, Port 14 Access Enable Register 0 */


/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_P_Registers_Cfg_P15
 * \{  */
/** \brief 0, Port 15 Output Register */


/** \brief 4, Port 15 Output Modification Register */


/** \brief 8, Port 15 Identification Register */


/** \brief 10, Port 15 Input/Output Control Register 0 */


/** \brief 14, Port 15 Input/Output Control Register 4 */


/** \brief 18, Port 15 Input/Output Control Register 8 */


/** \brief 1C, Port 15 Input/Output Control Register 12 */


/** \brief 24, Port 15 Input Register */


/** \brief 40, Port 15 Pad Driver Mode Register 0 */


/** \brief 44, Port 15 Pad Driver Mode Register 1 */


/** \brief 50, Port 15 Emergency Stop Register */


/** \brief 60, Port 15 Pin Function Decision Control Register */


/** \brief 64, Port 15 Pin Controller Select Register */


/** \brief 70, Port 15 Output Modification Set Register 0 */


/** \brief 74, Port 15 Output Modification Set Register 4 */


/** \brief 78, Port 15 Output Modification Set Register 8 */


/** \brief 7C, Port 15 Output Modification Set Register 12 */


/** \brief 80, Port 15 Output Modification Clear Register 0 */


/** \brief 84, Port 15 Output Modification Clear Register 4 */


/** \brief 88, Port 15 Output Modification Clear Register 8 */


/** \brief 8C, Port 15 Output Modification Clear Register 12 */


/** \brief 90, Port 15 Output Modification Set Register */


/** \brief 94, Port 15 Output Modification Clear Register */


/** \brief F8, Port 15 Access Enable Register 1 */


/** \brief FC, Port 15 Access Enable Register 0 */


/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_P_Registers_Cfg_P20
 * \{  */
/** \brief 0, Port 20 Output Register */


/** \brief 4, Port 20 Output Modification Register */


/** \brief 8, Port 20 Identification Register */


/** \brief 10, Port 20 Input/Output Control Register 0 */


/** \brief 14, Port 20 Input/Output Control Register 4 */


/** \brief 18, Port 20 Input/Output Control Register 8 */


/** \brief 1C, Port 20 Input/Output Control Register 12 */


/** \brief 24, Port 20 Input Register */


/** \brief 40, Port 20 Pad Driver Mode Register 0 */


/** \brief 44, Port 20 Pad Driver Mode Register 1 */


/** \brief 50, Port 20 Emergency Stop Register */


/** \brief 60, Port 20 Pin Function Decision Control Register */


/** \brief 64, Port 20 Pin Controller Select Register */


/** \brief 70, Port 20 Output Modification Set Register 0 */


/** \brief 74, Port 20 Output Modification Set Register 4 */


/** \brief 78, Port 20 Output Modification Set Register 8 */


/** \brief 7C, Port 20 Output Modification Set Register 12 */


/** \brief 80, Port 20 Output Modification Clear Register 0 */


/** \brief 84, Port 20 Output Modification Clear Register 4 */


/** \brief 88, Port 20 Output Modification Clear Register 8 */


/** \brief 8C, Port 20 Output Modification Clear Register 12 */


/** \brief 90, Port 20 Output Modification Set Register */


/** \brief 94, Port 20 Output Modification Clear Register */


/** \brief F8, Port 20 Access Enable Register 1 */


/** \brief FC, Port 20 Access Enable Register 0 */


/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_P_Registers_Cfg_P21
 * \{  */
/** \brief 0, Port 21 Output Register */


/** \brief 4, Port 21 Output Modification Register */


/** \brief 8, Port 21 Identification Register */


/** \brief 10, Port 21 Input/Output Control Register 0 */


/** \brief 14, Port 21 Input/Output Control Register 4 */


/** \brief 24, Port 21 Input Register */


/** \brief 40, Port 21 Pad Driver Mode Register 0 */


/** \brief 50, Port 21 Emergency Stop Register */


/** \brief 60, Port 21 Pin Function Decision Control Register */


/** \brief 64, Port 21 Pin Controller Select Register */


/** \brief 70, Port 21 Output Modification Set Register 0 */


/** \brief 74, Port 21 Output Modification Set Register 4 */


/** \brief 80, Port 21 Output Modification Clear Register 0 */


/** \brief 84, Port 21 Output Modification Clear Register 4 */


/** \brief 90, Port 21 Output Modification Set Register */


/** \brief 94, Port 21 Output Modification Clear Register */


/** \brief A0, Port 21 LVDS Pad Control Register 0 */


/** \brief A4, Port 21 LVDS Pad Control Register 1 */


/** \brief A8, Port 21 LVDS Pad Control Register 2 */


/** \brief F8, Port 21 Access Enable Register 1 */


/** \brief FC, Port 21 Access Enable Register 0 */


/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_P_Registers_Cfg_P22
 * \{  */
/** \brief 0, Port 22 Output Register */


/** \brief 4, Port 22 Output Modification Register */


/** \brief 8, Port 22 Identification Register */


/** \brief 10, Port 22 Input/Output Control Register 0 */


/** \brief 14, Port 22 Input/Output Control Register 4 */


/** \brief 18, Port 22 Input/Output Control Register 8 */


/** \brief 24, Port 22 Input Register */


/** \brief 40, Port 22 Pad Driver Mode Register 0 */


/** \brief 44, Port 22 Pad Driver Mode Register 1 */


/** \brief 50, Port 22 Emergency Stop Register */


/** \brief 60, Port 22 Pin Function Decision Control Register */


/** \brief 64, Port 22 Pin Controller Select Register */


/** \brief 70, Port 22 Output Modification Set Register 0 */


/** \brief 74, Port 22 Output Modification Set Register 4 */


/** \brief 78, Port 22 Output Modification Set Register 8 */


/** \brief 80, Port 22 Output Modification Clear Register 0 */


/** \brief 84, Port 22 Output Modification Clear Register 4 */


/** \brief 88, Port 22 Output Modification Clear Register 8 */


/** \brief 90, Port 22 Output Modification Set Register */


/** \brief 94, Port 22 Output Modification Clear Register */


/** \brief A0, Port 22 LVDS Pad Control Register 0 */


/** \brief A4, Port 22 LVDS Pad Control Register 1 */


/** \brief F8, Port 22 Access Enable Register 1 */


/** \brief FC, Port 22 Access Enable Register 0 */


/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_P_Registers_Cfg_P23
 * \{  */
/** \brief 0, Port 23 Output Register */


/** \brief 4, Port 23 Output Modification Register */


/** \brief 8, Port 23 Identification Register */


/** \brief 10, Port 23 Input/Output Control Register 0 */


/** \brief 14, Port 23 Input/Output Control Register 4 */


/** \brief 24, Port 23 Input Register */


/** \brief 40, Port 23 Pad Driver Mode Register 0 */


/** \brief 50, Port 23 Emergency Stop Register */


/** \brief 60, Port 23 Pin Function Decision Control Register */


/** \brief 64, Port 23 Pin Controller Select Register */


/** \brief 70, Port 23 Output Modification Set Register 0 */


/** \brief 74, Port 23 Output Modification Set Register 4 */


/** \brief 80, Port 23 Output Modification Clear Register 0 */


/** \brief 84, Port 23 Output Modification Clear Register 4 */


/** \brief 90, Port 23 Output Modification Set Register */


/** \brief 94, Port 23 Output Modification Clear Register */


/** \brief F8, Port 23 Access Enable Register 1 */


/** \brief FC, Port 23 Access Enable Register 0 */


/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_P_Registers_Cfg_P24
 * \{  */
/** \brief 0, Port 24 Output Register */


/** \brief 4, Port 24 Output Modification Register */


/** \brief 8, Port 24 Identification Register */


/** \brief 10, Port 24 Input/Output Control Register 0 */


/** \brief 14, Port 24 Input/Output Control Register 4 */


/** \brief 18, Port 24 Input/Output Control Register 8 */


/** \brief 1C, Port 24 Input/Output Control Register 12 */


/** \brief 24, Port 24 Input Register */


/** \brief 40, Port 24 Pad Driver Mode Register 0 */


/** \brief 44, Port 24 Pad Driver Mode Register 1 */


/** \brief 50, Port 24 Emergency Stop Register */


/** \brief 60, Port 24 Pin Function Decision Control Register */


/** \brief 64, Port 24 Pin Controller Select Register */


/** \brief 70, Port 24 Output Modification Set Register 0 */


/** \brief 74, Port 24 Output Modification Set Register 4 */


/** \brief 78, Port 24 Output Modification Set Register 8 */


/** \brief 7C, Port 24 Output Modification Set Register 12 */


/** \brief 80, Port 24 Output Modification Clear Register 0 */


/** \brief 84, Port 24 Output Modification Clear Register 4 */


/** \brief 88, Port 24 Output Modification Clear Register 8 */


/** \brief 8C, Port 24 Output Modification Clear Register 12 */


/** \brief 90, Port 24 Output Modification Set Register */


/** \brief 94, Port 24 Output Modification Clear Register */


/** \brief F8, Port 24 Access Enable Register 1 */


/** \brief FC, Port 24 Access Enable Register 0 */


/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_P_Registers_Cfg_P25
 * \{  */
/** \brief 0, Port 25 Output Register */


/** \brief 4, Port 25 Output Modification Register */


/** \brief 8, Port 25 Identification Register */


/** \brief 10, Port 25 Input/Output Control Register 0 */


/** \brief 14, Port 25 Input/Output Control Register 4 */


/** \brief 18, Port 25 Input/Output Control Register 8 */


/** \brief 1C, Port 25 Input/Output Control Register 12 */


/** \brief 24, Port 25 Input Register */


/** \brief 40, Port 25 Pad Driver Mode Register 0 */


/** \brief 44, Port 25 Pad Driver Mode Register 1 */


/** \brief 50, Port 25 Emergency Stop Register */


/** \brief 60, Port 25 Pin Function Decision Control Register */


/** \brief 64, Port 25 Pin Controller Select Register */


/** \brief 70, Port 25 Output Modification Set Register 0 */


/** \brief 74, Port 25 Output Modification Set Register 4 */


/** \brief 78, Port 25 Output Modification Set Register 8 */


/** \brief 7C, Port 25 Output Modification Set Register 12 */


/** \brief 80, Port 25 Output Modification Clear Register 0 */


/** \brief 84, Port 25 Output Modification Clear Register 4 */


/** \brief 88, Port 25 Output Modification Clear Register 8 */


/** \brief 8C, Port 25 Output Modification Clear Register 12 */


/** \brief 90, Port 25 Output Modification Set Register */


/** \brief 94, Port 25 Output Modification Clear Register */


/** \brief F8, Port 25 Access Enable Register 1 */


/** \brief FC, Port 25 Access Enable Register 0 */


/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_P_Registers_Cfg_P26
 * \{  */
/** \brief 0, Port 26 Output Register */


/** \brief 4, Port 26 Output Modification Register */


/** \brief 8, Port 26 Identification Register */


/** \brief 10, Port 26 Input/Output Control Register 0 */


/** \brief 24, Port 26 Input Register */


/** \brief 40, Port 26 Pad Driver Mode Register 0 */


/** \brief 50, Port 26 Emergency Stop Register */


/** \brief 60, Port 26 Pin Function Decision Control Register */


/** \brief 64, Port 26 Pin Controller Select Register */


/** \brief 70, Port 26 Output Modification Set Register 0 */


/** \brief 80, Port 26 Output Modification Clear Register 0 */


/** \brief 90, Port 26 Output Modification Set Register */


/** \brief 94, Port 26 Output Modification Clear Register */


/** \brief F8, Port 26 Access Enable Register 1 */


/** \brief FC, Port 26 Access Enable Register 0 */


/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_P_Registers_Cfg_P30
 * \{  */
/** \brief 0, Port 30 Output Register */


/** \brief 4, Port 30 Output Modification Register */


/** \brief 8, Port 30 Identification Register */


/** \brief 10, Port 30 Input/Output Control Register 0 */


/** \brief 14, Port 30 Input/Output Control Register 4 */


/** \brief 18, Port 30 Input/Output Control Register 8 */


/** \brief 1C, Port 30 Input/Output Control Register 12 */


/** \brief 24, Port 30 Input Register */


/** \brief 40, Port 30 Pad Driver Mode Register 0 */


/** \brief 44, Port 30 Pad Driver Mode Register 1 */


/** \brief 50, Port 30 Emergency Stop Register */


/** \brief 60, Port 30 Pin Function Decision Control Register */


/** \brief 64, Port 30 Pin Controller Select Register */


/** \brief 70, Port 30 Output Modification Set Register 0 */


/** \brief 74, Port 30 Output Modification Set Register 4 */


/** \brief 78, Port 30 Output Modification Set Register 8 */


/** \brief 7C, Port 30 Output Modification Set Register 12 */


/** \brief 80, Port 30 Output Modification Clear Register 0 */


/** \brief 84, Port 30 Output Modification Clear Register 4 */


/** \brief 88, Port 30 Output Modification Clear Register 8 */


/** \brief 8C, Port 30 Output Modification Clear Register 12 */


/** \brief 90, Port 30 Output Modification Set Register */


/** \brief 94, Port 30 Output Modification Clear Register */


/** \brief F8, Port 30 Access Enable Register 1 */


/** \brief FC, Port 30 Access Enable Register 0 */


/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_P_Registers_Cfg_P31
 * \{  */
/** \brief 0, Port 31 Output Register */


/** \brief 4, Port 31 Output Modification Register */


/** \brief 8, Port 31 Identification Register */


/** \brief 10, Port 31 Input/Output Control Register 0 */


/** \brief 14, Port 31 Input/Output Control Register 4 */


/** \brief 18, Port 31 Input/Output Control Register 8 */


/** \brief 1C, Port 31 Input/Output Control Register 12 */


/** \brief 24, Port 31 Input Register */


/** \brief 40, Port 31 Pad Driver Mode Register 0 */


/** \brief 44, Port 31 Pad Driver Mode Register 1 */


/** \brief 50, Port 31 Emergency Stop Register */


/** \brief 60, Port 31 Pin Function Decision Control Register */


/** \brief 64, Port 31 Pin Controller Select Register */


/** \brief 70, Port 31 Output Modification Set Register 0 */


/** \brief 74, Port 31 Output Modification Set Register 4 */


/** \brief 78, Port 31 Output Modification Set Register 8 */


/** \brief 7C, Port 31 Output Modification Set Register 12 */


/** \brief 80, Port 31 Output Modification Clear Register 0 */


/** \brief 84, Port 31 Output Modification Clear Register 4 */


/** \brief 88, Port 31 Output Modification Clear Register 8 */


/** \brief 8C, Port 31 Output Modification Clear Register 12 */


/** \brief 90, Port 31 Output Modification Set Register */


/** \brief 94, Port 31 Output Modification Clear Register */


/** \brief F8, Port 31 Access Enable Register 1 */


/** \brief FC, Port 31 Access Enable Register 0 */


/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_P_Registers_Cfg_P32
 * \{  */
/** \brief 0, Port 32 Output Register */


/** \brief 4, Port 32 Output Modification Register */


/** \brief 8, Port 32 Identification Register */


/** \brief 10, Port 32 Input/Output Control Register 0 */


/** \brief 14, Port 32 Input/Output Control Register 4 */


/** \brief 24, Port 32 Input Register */


/** \brief 40, Port 32 Pad Driver Mode Register 0 */


/** \brief 50, Port 32 Emergency Stop Register */


/** \brief 60, Port 32 Pin Function Decision Control Register */


/** \brief 64, Port 32 Pin Controller Select Register */


/** \brief 70, Port 32 Output Modification Set Register 0 */


/** \brief 74, Port 32 Output Modification Set Register 4 */


/** \brief 80, Port 32 Output Modification Clear Register 0 */


/** \brief 84, Port 32 Output Modification Clear Register 4 */


/** \brief 90, Port 32 Output Modification Set Register */


/** \brief 94, Port 32 Output Modification Clear Register */


/** \brief F8, Port 32 Access Enable Register 1 */


/** \brief FC, Port 32 Access Enable Register 0 */


/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_P_Registers_Cfg_P33
 * \{  */
/** \brief 0, Port 33 Output Register */


/** \brief 4, Port 33 Output Modification Register */


/** \brief 8, Port 33 Identification Register */


/** \brief 10, Port 33 Input/Output Control Register 0 */


/** \brief 14, Port 33 Input/Output Control Register 4 */


/** \brief 18, Port 33 Input/Output Control Register 8 */


/** \brief 1C, Port 33 Input/Output Control Register 12 */


/** \brief 24, Port 33 Input Register */


/** \brief 40, Port 33 Pad Driver Mode Register 0 */


/** \brief 44, Port 33 Pad Driver Mode Register 1 */


/** \brief 50, Port 33 Emergency Stop Register */


/** \brief 60, Port 33 Pin Function Decision Control Register */


/** \brief 64, Port 33 Pin Controller Select Register */


/** \brief 70, Port 33 Output Modification Set Register 0 */


/** \brief 74, Port 33 Output Modification Set Register 4 */


/** \brief 78, Port 33 Output Modification Set Register 8 */


/** \brief 7C, Port 33 Output Modification Set Register 12 */


/** \brief 80, Port 33 Output Modification Clear Register 0 */


/** \brief 84, Port 33 Output Modification Clear Register 4 */


/** \brief 88, Port 33 Output Modification Clear Register 8 */


/** \brief 8C, Port 33 Output Modification Clear Register 12 */


/** \brief 90, Port 33 Output Modification Set Register */


/** \brief 94, Port 33 Output Modification Clear Register */


/** \brief F8, Port 33 Access Enable Register 1 */


/** \brief FC, Port 33 Access Enable Register 0 */


/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_P_Registers_Cfg_P34
 * \{  */
/** \brief 0, Port 34 Output Register */


/** \brief 4, Port 34 Output Modification Register */


/** \brief 8, Port 34 Identification Register */


/** \brief 10, Port 34 Input/Output Control Register 0 */


/** \brief 14, Port 34 Input/Output Control Register 4 */


/** \brief 24, Port 34 Input Register */


/** \brief 40, Port 34 Pad Driver Mode Register 0 */


/** \brief 50, Port 34 Emergency Stop Register */


/** \brief 60, Port 34 Pin Function Decision Control Register */


/** \brief 64, Port 34 Pin Controller Select Register */


/** \brief 70, Port 34 Output Modification Set Register 0 */


/** \brief 74, Port 34 Output Modification Set Register 4 */


/** \brief 80, Port 34 Output Modification Clear Register 0 */


/** \brief 84, Port 34 Output Modification Clear Register 4 */


/** \brief 90, Port 34 Output Modification Set Register */


/** \brief 94, Port 34 Output Modification Clear Register */


/** \brief F8, Port 34 Access Enable Register 1 */


/** \brief FC, Port 34 Access Enable Register 0 */


/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_P_Registers_Cfg_P40
 * \{  */
/** \brief 0, Port 40 Output Register */


/** \brief 4, Port 40 Output Modification Register */


/** \brief 8, Port 40 Identification Register */


/** \brief 10, Port 40 Input/Output Control Register 0 */


/** \brief 14, Port 40 Input/Output Control Register 4 */


/** \brief 18, Port 40 Input/Output Control Register 8 */


/** \brief 1C, Port 40 Input/Output Control Register 12 */


/** \brief 24, Port 40 Input Register */


/** \brief 40, Port 40 Pad Driver Mode Register 0 */


/** \brief 44, Port 40 Pad Driver Mode Register 1 */


/** \brief 50, Port 40 Emergency Stop Register */


/** \brief 60, Port 40 Pin Function Decision Control Register */


/** \brief 64, Port 40 Pin Controller Select Register */


/** \brief 70, Port 40 Output Modification Set Register 0 */


/** \brief 74, Port 40 Output Modification Set Register 4 */


/** \brief 78, Port 40 Output Modification Set Register 8 */


/** \brief 7C, Port 40 Output Modification Set Register 12 */


/** \brief 80, Port 40 Output Modification Clear Register 0 */


/** \brief 84, Port 40 Output Modification Clear Register 4 */


/** \brief 88, Port 40 Output Modification Clear Register 8 */


/** \brief 8C, Port 40 Output Modification Clear Register 12 */


/** \brief 90, Port 40 Output Modification Set Register */


/** \brief 94, Port 40 Output Modification Clear Register */


/** \brief F8, Port 40 Access Enable Register 1 */


/** \brief FC, Port 40 Access Enable Register 0 */


/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_P_Registers_Cfg_P41
 * \{  */
/** \brief 0, Port 41 Output Register */


/** \brief 4, Port 41 Output Modification Register */


/** \brief 8, Port 41 Identification Register */


/** \brief 10, Port 41 Input/Output Control Register 0 */


/** \brief 14, Port 41 Input/Output Control Register 4 */


/** \brief 18, Port 41 Input/Output Control Register 8 */


/** \brief 24, Port 41 Input Register */


/** \brief 40, Port 41 Pad Driver Mode Register 0 */


/** \brief 44, Port 41 Pad Driver Mode Register 1 */


/** \brief 50, Port 41 Emergency Stop Register */


/** \brief 60, Port 41 Pin Function Decision Control Register */


/** \brief 64, Port 41 Pin Controller Select Register */


/** \brief 70, Port 41 Output Modification Set Register 0 */


/** \brief 74, Port 41 Output Modification Set Register 4 */


/** \brief 78, Port 41 Output Modification Set Register 8 */


/** \brief 80, Port 41 Output Modification Clear Register 0 */


/** \brief 84, Port 41 Output Modification Clear Register 4 */


/** \brief 88, Port 41 Output Modification Clear Register 8 */


/** \brief 90, Port 41 Output Modification Set Register */


/** \brief 94, Port 41 Output Modification Clear Register */


/** \brief F8, Port 41 Access Enable Register 1 */


/** \brief FC, Port 41 Access Enable Register 0 */



/** \}  */

/******************************************************************************/

/******************************************************************************/


#line 59 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\_Impl\\IfxPort_cfg.h"

/******************************************************************************/
/*-----------------------------------Macros-----------------------------------*/
/******************************************************************************/

/** \brief Port count              \ingroup IfxLld_port_cfg
 */




/******************************************************************************/
/*-------------------------------Enumerations---------------------------------*/
/******************************************************************************/

/** \brief List of the available Port resources
 */
typedef enum
{
    IfxPort_Index_00   = 0,  /**< \brief PORT 00 */
    IfxPort_Index_01   = 1,  /**< \brief PORT 01 */
    IfxPort_Index_02   = 2,  /**< \brief PORT 02 */
    IfxPort_Index_10   = 10, /**< \brief PORT 10 */
    IfxPort_Index_11   = 11, /**< \brief PORT 11 */
    IfxPort_Index_12   = 12, /**< \brief PORT 12 */
    IfxPort_Index_13   = 13, /**< \brief PORT 13 */
    IfxPort_Index_14   = 14, /**< \brief PORT 14 */
    IfxPort_Index_15   = 15, /**< \brief PORT 15 */
    IfxPort_Index_20   = 20, /**< \brief PORT 20 */
    IfxPort_Index_21   = 21, /**< \brief PORT 21 */
    IfxPort_Index_22   = 22, /**< \brief PORT 22 */
    IfxPort_Index_23   = 23, /**< \brief PORT 23 */
    IfxPort_Index_24   = 24, /**< \brief PORT 24 */
    IfxPort_Index_25   = 25, /**< \brief PORT 25 */
    IfxPort_Index_26   = 26, /**< \brief PORT 26 */
    IfxPort_Index_30   = 30, /**< \brief PORT 30 */
    IfxPort_Index_31   = 31, /**< \brief PORT 31 */
    IfxPort_Index_32   = 32, /**< \brief PORT 32 */
    IfxPort_Index_33   = 33, /**< \brief PORT 33 */
    IfxPort_Index_34   = 34, /**< \brief PORT 34 */
    IfxPort_Index_40   = 40, /**< \brief PORT 40 */
    IfxPort_Index_41   = 41, /**< \brief PORT 41 */
    IfxPort_Index_none = -1  /**< \brief none */
} IfxPort_Index;

/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/

/** \brief used by IfxPort_Esr_Masks table
 */
typedef struct
{
    Ifx_P *port;
    uint16 masks;
} IfxPort_Esr_Masks;

/******************************************************************************/
/*-------------------Global Exported Variables/Constants----------------------*/
/******************************************************************************/

extern const IfxPort_Esr_Masks  IfxPort_cfg_esrMasks[(23)];

extern const IfxModule_IndexMap IfxPort_cfg_indexMap[(23)];


#line 61 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Port\\Std\\IfxPort.h"



/******************************************************************************/
/*--------------------------------Enumerations--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Port_Std_Enum
 * \{ */
/** \brief The LVDS RX_DIS control function can be selected from the Port (default) or
 * HSCT module.declared in MODULE_PORTx.LPCRx
 */
typedef enum
{
    IfxPort_ControlledBy_port = 0,  /**< \brief port controlled by PORT Module */
    IfxPort_ControlledBy_hsct = 1   /**< \brief Port controlled by HSCT Module */
} IfxPort_ControlledBy;

/** \brief Ifx_P output modification modes definition.
 */
typedef enum
{
    IfxPort_InputMode_undefined    = -1,
    IfxPort_InputMode_noPullDevice = 0 << 3,
        IfxPort_InputMode_pullDown = 1U << 3,
        IfxPort_InputMode_pullUp   = 2U << 3  /**< \brief  */
} IfxPort_InputMode;

/** \brief specifies LVDS-M or LVDS-H mode as declare in Register MODULE_PORT.LPCRx.LVDSM
 */
typedef enum
{
    IfxPort_LvdsMode_high   = 0, /**< \brief LVDS-H Mode */
    IfxPort_LvdsMode_medium = 1  /**< \brief LVDS-M Mode */
} IfxPort_LvdsMode;

/** \brief Ifx_P input / output mode definition.
 *
 * \see Ifx_P.IOCR, IfxPort_setPinMode()
 */
typedef enum
{
    IfxPort_Mode_inputNoPullDevice      = 0,      /**< \brief Input, No pull device connected. */
    IfxPort_Mode_inputPullDown          = 8U,     /**< \brief Input, pull-down device connected. */
    IfxPort_Mode_inputPullUp            = 0x10U,  /**< \brief Input, pull-up device connected. */
    IfxPort_Mode_outputPushPullGeneral  = 0x80U,  /**< \brief Push-pull, General-purpose output */
    IfxPort_Mode_outputPushPullAlt1     = 0x88U,  /**< \brief Push-pull, Alternate output function 1. */
    IfxPort_Mode_outputPushPullAlt2     = 0x90U,  /**< \brief Push-pull, Alternate output function 2. */
    IfxPort_Mode_outputPushPullAlt3     = 0x98U,  /**< \brief Push-pull, Alternate output function 3. */
    IfxPort_Mode_outputPushPullAlt4     = 0xA0U,  /**< \brief Push-pull, Alternate output function 4. */
    IfxPort_Mode_outputPushPullAlt5     = 0xA8U,  /**< \brief Push-pull, Alternate output function 5. */
    IfxPort_Mode_outputPushPullAlt6     = 0xB0U,  /**< \brief Push-pull, Alternate output function 6. */
    IfxPort_Mode_outputPushPullAlt7     = 0xB8U,  /**< \brief Push-pull, Alternate output function 7. */
    IfxPort_Mode_outputOpenDrainGeneral = 0xC0U,  /**< \brief Open-drain, General-purpose output. */
    IfxPort_Mode_outputOpenDrainAlt1    = 0xC8U,  /**< \brief Open-drain, Alternate output function 1. */
    IfxPort_Mode_outputOpenDrainAlt2    = 0xD0U,  /**< \brief Open-drain, Alternate output function 2. */
    IfxPort_Mode_outputOpenDrainAlt3    = 0xD8U,  /**< \brief Open-drain, Alternate output function 3. */
    IfxPort_Mode_outputOpenDrainAlt4    = 0xE0U,  /**< \brief Open-drain, Alternate output function 4. */
    IfxPort_Mode_outputOpenDrainAlt5    = 0xE8U,  /**< \brief Open-drain, Alternate output function 5. */
    IfxPort_Mode_outputOpenDrainAlt6    = 0xF0U,  /**< \brief Open-drain, Alternate output function 6. */
    IfxPort_Mode_outputOpenDrainAlt7    = 0xF8U   /**< \brief Open-drain, Alternate output function 7. */
} IfxPort_Mode;

/** \brief Pin output alternate index
 */
typedef enum
{
    IfxPort_OutputIdx_general  = 0x10U << 3,
        IfxPort_OutputIdx_alt1 = 0x11U << 3,
        IfxPort_OutputIdx_alt2 = 0x12U << 3,
        IfxPort_OutputIdx_alt3 = 0x13U << 3,
        IfxPort_OutputIdx_alt4 = 0x14U << 3,
        IfxPort_OutputIdx_alt5 = 0x15U << 3,
        IfxPort_OutputIdx_alt6 = 0x16U << 3,
        IfxPort_OutputIdx_alt7 = 0x17U << 3
} IfxPort_OutputIdx;

/** \brief Pin output mode definition
 */
typedef enum
{
    IfxPort_OutputMode_pushPull      = 0x10U << 3,
        IfxPort_OutputMode_openDrain = 0x18U << 3,
        IfxPort_OutputMode_none      = 0
} IfxPort_OutputMode;

/** \brief Pad driver mode definition (strength and slew rate).
 *
 * \see Ifx_P.PDR, IfxPort_setPinPadDriver()
 */
typedef enum
{
    IfxPort_PadDriver_cmosAutomotiveSpeed1 = 0,  /**< \brief Speed grade 1. */
    IfxPort_PadDriver_cmosAutomotiveSpeed2 = 1,  /**< \brief Speed grade 2. */
    IfxPort_PadDriver_cmosAutomotiveSpeed3 = 2,  /**< \brief Speed grade 3. */
    IfxPort_PadDriver_cmosAutomotiveSpeed4 = 3,  /**< \brief Speed grade 4. */
    IfxPort_PadDriver_ttlSpeed1            = 8,  /**< \brief Speed grade 1. */
    IfxPort_PadDriver_ttlSpeed2            = 9,  /**< \brief Speed grade 2. */
    IfxPort_PadDriver_ttlSpeed3            = 10, /**< \brief Speed grade 3. */
    IfxPort_PadDriver_ttlSpeed4            = 11, /**< \brief Speed grade 4. */
    IfxPort_PadDriver_ttl3v3Speed1         = 12, /**< \brief 3.3v Pad supply speed1 */
    IfxPort_PadDriver_ttl3v3Speed2         = 13, /**< \brief 3.3v Pad supply speed2 */
    IfxPort_PadDriver_ttl3v3Speed3         = 14, /**< \brief 3.3v Pad supply speed3 */
    IfxPort_PadDriver_ttl3v3Speed4         = 15  /**< \brief 3.3v Pad supply speed4 */
} IfxPort_PadDriver;

/** \brief MODULE_PORTx.LPCRx.B.PS1.Selects between 5v and 3.3v on Vext supply for the LVDSM pair
 */
typedef enum
{
    IfxPort_PadSupply_3v = 0,  /**< \brief select,3.3v */
    IfxPort_PadSupply_5v = 1   /**< \brief select,5V */
} IfxPort_PadSupply;

/** \brief enable analog/digital mode for port pin, as Defined in MODULE_PORTx.PDISC
 */
typedef enum
{
    IfxPort_PinFunctionMode_digital = 0,  /**< \brief Pad Pn.x is enabled and can be selected for digital function */
    IfxPort_PinFunctionMode_analog  = 1   /**< \brief Pad Pn.x is enabled and can be selected for analog function */
} IfxPort_PinFunctionMode;

/** \brief Ifx_P output modification modes definition.
 *
 * \see Ifx_P.OMR, IfxPort_setPinState()
 */
typedef enum
{
    IfxPort_State_notChanged = (0 << 16) | (0 << 0),  /**< \brief Ifx_P pin is left unchanged. */
    IfxPort_State_high       = (0 << 16) | (1U << 0), /**< \brief Ifx_P pin is set to high. */
    IfxPort_State_low        = (1U << 16) | (0 << 0), /**< \brief Ifx_P pin is set to low. */
    IfxPort_State_toggled    = (1U << 16) | (1U << 0) /**< \brief Ifx_P pin is toggled. */
} IfxPort_State;

/** \} */

/** \brief Enable/DIsable LVDS direction TX or RX
 */
typedef enum
{
    IfxPort_LvdsDirection_rx = 0,  /**< \brief LVDS direction RX */
    IfxPort_LvdsDirection_tx = 1   /**< \brief LVDS direction TX */
} IfxPort_LvdsDirection;

/** \brief Enable/DIsable LVDS Path.declared in MODULE_PORTx.LPCRx.TX_EN and MODULE_PORTx.LPCRx.RX_EN
 */
typedef enum
{
    IfxPort_LvdsPath_enable  = 0, /**< \brief LVDS enabled */
    IfxPort_LvdsPath_disable = 1  /**< \brief LVDS disabled */
} IfxPort_LvdsPath;

/** \brief Specifies whether LVDS pull down resistor must be enabled/disabled as declared in Register MODULE_PORT.LPCRx.PWDPD
 */
typedef enum
{
    IfxPort_LvdsPullDown_disable = 0,  /**< \brief Disable Pull Down resistor */
    IfxPort_LvdsPullDown_enable  = 1   /**< \brief Enable Pull Down resistor */
} IfxPort_LvdsPullDown;

/** \brief Specifies LVDS-Termination mode as declare in Register MODULE_PORT.LPCRx.TERM
 */
typedef enum
{
    IfxPort_LvdsTerminationMode_external = 0,  /**< \brief Termination Mode External */
    IfxPort_LvdsTerminationMode_internal = 1   /**< \brief Termination Mode Internal */
} IfxPort_LvdsTerminationMode;

/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Port_Std_DataStructures
 * \{ */
/** \brief To Configure LVDS mode
 */
typedef struct
{
    IfxPort_LvdsMode     lvdsMode;                   /**< \brief specifies LVDS-M or LVDS-H mode */
    IfxPort_ControlledBy enablePortControlled;       /**< \brief specifies whether LVDS is controlled by PORT or HSCT */
    IfxPort_PadSupply    padSupply;                  /**< \brief specify supply voltage */
} IfxPort_LvdsConfig;

/** \brief Defines a pin
 */
typedef struct
{
    Ifx_P *port;
    uint8  pinIndex;
} IfxPort_Pin;

/** \brief To configure pins
 */
typedef struct
{
    Ifx_P            *port;
    uint8             pinIndex;
    IfxPort_OutputIdx mode;
    IfxPort_PadDriver padDriver;
} IfxPort_Pin_Config;

/** \} */

/** \addtogroup IfxLld_Port_Std_SinglePin
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Return the port state.
 * \param port Pointer to the port which should be accessed.
 * \param pinIndex Specifies the pin for which the state should be returned.
 * \return Returns TRUE the pin is high; FALSE the pin is low
 *
 * Coding example:
 * \code
 *    if( IfxPort_getPinState(&MODULE_P33, 0) ) {
 *      // ...
 *    }
 * \endcode
 *
 */
static inline boolean IfxPort_getPinState(Ifx_P *port, uint8 pinIndex);

/** \brief set analog/digital mode for pin
 * \param port Pointer to Port register space
 * \param pinIndex specifies the pin index
 * \param mode set analog/digital mode
 * \return None
 */
static inline void IfxPort_setPinFunctionMode(Ifx_P *port, uint8 pinIndex, IfxPort_PinFunctionMode mode);

/** \brief Set the port output.
 * \param port Pointer to the port which should be accessed.
 * \param pinIndex Specifies the pin to be set.
 * \return None
 *
 * Coding example:
 * \code
 * IfxPort_setPinHigh(&MODULE_P33, 0);
 * \endcode
 *
 * \see IfxPort_setPinState(), IfxPort_setPinLow(), IfxPort_togglePin()
 *
 */
static inline void IfxPort_setPinHigh(Ifx_P *port, uint8 pinIndex);

/** \brief Reset the port output.
 * \param port Pointer to the port which should be accessed.
 * \param pinIndex Specifies the pin to be reset.
 * \return None
 *
 * Coding example:
 * \code
 * IfxPort_setPinLow(&MODULE_P33, 0);
 * \endcode
 *
 * \see IfxPort_setPinState(), IfxPort_setPinHigh(), IfxPort_togglePin()
 *
 */
static inline void IfxPort_setPinLow(Ifx_P *port, uint8 pinIndex);

/** \brief Configure the port input / output mode.
 * \param port Pointer to the port which should be accessed.
 * \param pinIndex Specifies the pin to be configured.
 * \param mode Specifies the port pin mode.
 * \return None
 *
 * Coding example:
 * \code
 *     IfxPort_setPinModeInput(&MODULE_P33, 0, IfxPort_InputMode_pullUp);
 * \endcode
 *
 */
static inline void IfxPort_setPinModeInput(Ifx_P *port, uint8 pinIndex, IfxPort_InputMode mode);

/** \brief Configure the port input / output mode.
 * \param port Pointer to the port which should be accessed.
 * \param pinIndex Specifies the pin to be configured.
 * \param mode Specifies the port pin mode.
 * \param index Specifies the alternate (or general purpose) output channel.
 * \return None
 *
 * Coding example:
 * \code
 *     IfxPort_setPinModeOutput(&MODULE_P33, 0, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
 * \endcode
 *
 */
static inline void IfxPort_setPinModeOutput(Ifx_P *port, uint8 pinIndex, IfxPort_OutputMode mode, IfxPort_OutputIdx index);

/** \brief Set / Resets / Toggle the port output.
 * \param port Pointer to the port which should be accessed.
 * \param pinIndex Specifies the pin to modify.
 * \param action Specifies the action: set, reset, toggle.
 * \return None
 *
 * Coding example:
 * \code
 * IfxPort_setPinState(&MODULE_P33, 0, IfxPort_State_toggled);
 * IfxPort_setPinState(&MODULE_P33, 0, IfxPort_State_toggled);
 * IfxPort_setPinState(&MODULE_P33, 0, IfxPort_State_toggled);
 * \endcode
 *
 */
static inline void IfxPort_setPinState(Ifx_P *port, uint8 pinIndex, IfxPort_State action);

/** \brief Toggle the port output.
 * \param port Pointer to the port which should be accessed.
 * \param pinIndex Specifies the pin to be toggled.
 * \return None
 *
 * Coding example:
 * \code
 * IfxPort_togglePin(&MODULE_P33, 0);
 * \endcode
 *
 * \see IfxPort_setPinState(), IfxPort_setPinLow(), IfxPort_setPinHigh()
 *
 */
static inline void IfxPort_togglePin(Ifx_P *port, uint8 pinIndex);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Disable the emergency stop function.
 * This function disables the emergency stop function. A check is done on port functionality.
 * \param port Pointer to the port which should be accessed.
 * \param pinIndex Specifies the pin for which the emergency stop function should be disabled.
 * \return Returns TRUE if the emergency stop function has been disabled; FALSE if the emergency stop function could not be disabled
 *
 * Coding example:
 * /code
 *     if( !IfxPort_disableEmergencyStop(&MODULE_P33, 0) )
 *     {
 *         // failed to disable emergency stop for P33.0
 *     }
 * /endcode
 *
 * \see IfxPort_disableEmergencyStop(), IfxPort_resetESR()
 *
 */
extern boolean IfxPort_disableEmergencyStop(Ifx_P *port, uint8 pinIndex);

/** \brief Enable the emergency stop function.
 * This function enables the emergency stop function. A check is done on port functionality.
 * \param port Pointer to the port which should be accessed.
 * \param pinIndex Specifies the pin for which the emergency stop function should be enabled.
 * \return Returns TRUE if the emergency stop function has been enabled; FALSE if the emergency stop function could not be enabled
 *
 * Coding example:
 * \code
 *     if( !IfxPort_enableEmergencyStop(&MODULE_P33, 0) ) {
 *       // failed to enable emergency stop for P33.0
 *     }
 * \endcode
 *
 * \see IfxPort_disableEmergencyStop(), IfxPort_setESR()
 *
 */
extern boolean IfxPort_enableEmergencyStop(Ifx_P *port, uint8 pinIndex);

/** \brief Configure the port input / output mode.
 * Also Configures the P40/P41 Port for digital functionality
 * which bydefault support analog functionality.
 * \param port Pointer to the port which should be accessed.
 * \param pinIndex Specifies the pin to be configured.
 * \param mode Specifies the port pin mode.
 * \return None
 *
 * Coding example:
 * \code
 *     IfxPort_setPinMode(&MODULE_P33, 0, IfxPort_Mode_outputPushPullGeneral);
 * \endcode
 *
 */
extern void IfxPort_setPinMode(Ifx_P *port, uint8 pinIndex, IfxPort_Mode mode);

/** \brief set lvds mode
 * \param port pointer to Port Register space
 * \param pinIndex specifies pin index
 * \param pinMode specifes the mode of pin
 * \param lvds config LVDS
 * \return None
 */
extern void IfxPort_setPinModeLVDS(Ifx_P *port, uint8 pinIndex, IfxPort_Mode pinMode, IfxPort_LvdsConfig *lvds);

/** \brief Configure the pad driver mode.
 * \param port Pointer to the port which should be accessed.
 * \param pinIndex Specifies the pin for which the mode will be set.
 * \param padDriver Specifies the driver mode.
 * \return None
 *
 * Coding example:
 * \code
 * // enable strong 3.3V driver
 * IfxPort_setPinPadDriver(&MODULE_P33, 0, IfxPort_PadDriver_cmosAutomotiveSpeed1);
 * \endcode
 *
 */
extern void IfxPort_setPinPadDriver(Ifx_P *port, uint8 pinIndex, IfxPort_PadDriver padDriver);

/** \brief Enable the Pin Controller Selection.
 * \param port Pointer to the port which should be accessed.
 * \param pinIndex Specifies the pin for which the mode has to be set.
 * \return None
 */
extern void IfxPort_setPinControllerSelection(Ifx_P *port, uint8 pinIndex);

/** \brief Disable the Pin Controller Selection.
 * \param port Pointer to the port which should be accessed.
 * \param pinIndex Specifies the pin for which the mode has to be cleared.
 * \return None
 */
extern void IfxPort_resetPinControllerSelection(Ifx_P *port, uint8 pinIndex);

/** \} */

/** \addtogroup IfxLld_Port_Std_PortGroup
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Return the port group state
 * \param port Pointer to the port which should be accessed.
 * \param pinIndex start at the given pin
 * \param mask selects the pins which should be read (starting from pinIndex)
 * \return Returns the selected pin values
 *
 * Coding example:
 * \code
 * // read the current value of P33[7:0]
 * uint16 value = IfxPort_getGroupState(&MODULE_P33, 0, 0xff);
 * \endcode
 *
 */
static inline uint32 IfxPort_getGroupState(Ifx_P *port, uint8 pinIndex, uint16 mask);

/** \brief Set the port group state.
 * \param port Pointer to the port which should be accessed.
 * \param pinIndex start at the given pin
 * \param mask selects the pins which should be modified (starting from pinIndex)
 * \param data specifies the value which should be set
 * \return None
 *
 * Coding example:
 * \code
 * // configure P33.[7:0] as GPIO outputs
 * IfxPort_setGroupModeOutput(&MODULE_P33, 0, 0xff, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
 *
 * // set initial value
 * IfxPort_setGroupState(&MODULE_P33, 0, 0xff, 0x42);
 * \endcode
 *
 */
static inline void IfxPort_setGroupState(Ifx_P *port, uint8 pinIndex, uint16 mask, uint16 data);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Returns the module address of the selected Port module
 * \param port Pointer to PORT module registers
 * \return PORT module register address
 */
extern Ifx_P *IfxPort_getAddress(IfxPort_Index port);

/** \brief Return port index within IfxModule_IndexMap (defined in IfxPort_cfg.c)
 * \param port Pointer to the port for which the index number in IfxModule_IndexMap should be retrieved.
 * \return port index of IfxModule_IndexMap. return -1 in case of unknown port index.
 */
extern IfxPort_Index IfxPort_getIndex(Ifx_P *port);

/** \brief Set pin modes to input at the pin location specified by '1' by the mask
 * \param port Pointer to the port which should be accessed.
 * \param pinIndex start at the given pin
 * \param mask selects the pins which should be modified (starting from pinIndex)
 * \param mode Specifies the port pin mode.
 * \return None
 *
 * Coding example:
 * \code
 * // configure P33.[7:0] as GPIO inputs with Pull-Down enabled
 * IfxPort_setGroupModeInput(&MODULE_P33, 0, 0xff, IfxPort_InputMode_pullDown);
 *  \endcode
 *
 */
extern void IfxPort_setGroupModeInput(Ifx_P *port, uint8 pinIndex, uint16 mask, IfxPort_InputMode mode);

/** \brief Set pin modes to output at the pin location specified by '1' by the mask starting at pinIndex
 * \param port Pointer to the port which should be accessed.
 * \param pinIndex start at the given pin
 * \param mask selects the pins which should be modified (starting from pinIndex)
 * \param mode Specifies the port pin mode.
 * \param index Specifies the alternate (or general purpose) output channel.
 * \return None
 *
 * Coding example:
 * \code
 * // configure P33.[7:0] as GPIO outputs
 * IfxPort_setGroupModeOutput(&MODULE_P33, 0, 0xff, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
 * \endcode
 *
 */
extern void IfxPort_setGroupModeOutput(Ifx_P *port, uint8 pinIndex, uint16 mask, IfxPort_OutputMode mode, IfxPort_OutputIdx index);

/** \brief Set pad driver strength at the pin location specified by '1' by the mask
 * \param port Pointer to the port which should be accessed.
 * \param pinIndex start at the given pin
 * \param mask selects the pins which should be modified (starting from pinIndex)
 * \param padDriver Specifies the pad driver strength.
 * \return None
 *
 * Coding example:
 * \code
 * // configure P33.[7:0] to use CMOS pad driver with speed 1
 * IfxPort_setGroupPadDriver(&MODULE_P33, 0, 0xff, IfxPort_PadDriver_cmosAutomotiveSpeed1);
 * \endcode
 *
 */
extern void IfxPort_setGroupPadDriver(Ifx_P *port, uint8 pinIndex, uint16 mask, IfxPort_PadDriver padDriver);

/** \} */

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Disable the emergency stop function.
 * This function disables the emergency stop function. No check is done on port functionality.
 * \param port Pointer to the port which should be accessed.
 * \param pinIndex Specifies the pin for which the emergency stop function should be disabled.
 * \return None
 *
 * \see IfxPort_disableEmergencyStop()
 *
 */
extern void IfxPort_resetESR(Ifx_P *port, uint8 pinIndex);

/** \brief Enable the emergency stop function.
 * This function enables the emergency stop function. No check is done on port functionality.
 * \param port Pointer to the port which should be accessed.
 * \param pinIndex Specifies the pin for which the emergency stop function should be enabled.
 * \return None
 *
 * \see IfxPort_enableEmergencyStop()
 *
 */
extern void IfxPort_setESR(Ifx_P *port, uint8 pinIndex);

/**
 * \param port Pointer to the port which should be accessed.
 * \param pinIndex Specifies the pin for which the mode has to be set.
 * \param mode Selects the controller for the port pin(Tricore,EVADC,GETH,SCR etc)
 * 0-> normal function
 * 1-> Alternate functionality(SCR pin,EVADC PDD,GETH RGMII/MII etc)
 * \return None
 */
extern void IfxPort_modifyPinControllerSelection(Ifx_P *port, uint8 pinIndex, boolean mode);

/******************************************************************************/
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

static inline uint32 IfxPort_getGroupState(Ifx_P *port, uint8 pinIndex, uint16 mask)
{
    return (uint32)((port->IN.U) >> (pinIndex)) & mask;
}


static inline boolean IfxPort_getPinState(Ifx_P *port, uint8 pinIndex)
{
    return (__getbit(&port->IN.U, pinIndex) != 0) ? (1u) : (0u);
}


static inline void IfxPort_setGroupState(Ifx_P *port, uint8 pinIndex, uint16 mask, uint16 data)
{
    port->OUT.U = (port->OUT.U & ~((uint32)(mask)) << pinIndex) | (data << pinIndex);
}


static inline void IfxPort_setPinFunctionMode(Ifx_P *port, uint8 pinIndex, IfxPort_PinFunctionMode mode)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();

    IfxScuWdt_clearCpuEndinit(passwd);
    port->PDISC.U |= (mode << pinIndex);
    IfxScuWdt_setCpuEndinit(passwd);
}


static inline void IfxPort_setPinHigh(Ifx_P *port, uint8 pinIndex)
{
    IfxPort_setPinState(port, pinIndex, IfxPort_State_high);
}


static inline void IfxPort_setPinLow(Ifx_P *port, uint8 pinIndex)
{
    IfxPort_setPinState(port, pinIndex, IfxPort_State_low);
}


static inline void IfxPort_setPinModeInput(Ifx_P *port, uint8 pinIndex, IfxPort_InputMode mode)
{
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)mode);
}


static inline void IfxPort_setPinModeOutput(Ifx_P *port, uint8 pinIndex, IfxPort_OutputMode mode, IfxPort_OutputIdx index)
{
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)(index | mode));
}


static inline void IfxPort_setPinState(Ifx_P *port, uint8 pinIndex, IfxPort_State action)
{
    port->OMR.U = action << pinIndex;
}


static inline void IfxPort_togglePin(Ifx_P *port, uint8 pinIndex)
{
    IfxPort_setPinState(port, pinIndex, IfxPort_State_toggled);
}



#line 51 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\_PinMap\\IfxScu_PinMap.h"

/** \addtogroup IfxLld_Scu_pinmap
 * \{ */

/** \brief EVR Wakeup pin mapping structure */
typedef const struct
{
    Ifx_SCU*          module;    /**< \brief Base address */
    IfxPort_Pin       pin;       /**< \brief Port pin */
    Ifx_RxSel         select;    /**< \brief Input multiplexer value */
} IfxScu_Evrwup_In;

/** \brief External Request pin mapping structure */
typedef const struct
{
    Ifx_SCU*          module;    /**< \brief Base address */
    uint8             channelId; /**< \brief ERU Channel ID */
    IfxPort_Pin       pin;       /**< \brief Port pin */
    Ifx_RxSel         select;    /**< \brief Input multiplexer value */
} IfxScu_Req_In;

/** \brief DCDC Sync pin mapping structure */
typedef const struct
{
    Ifx_SCU*          module;    /**< \brief Base address */
    IfxPort_Pin       pin;       /**< \brief Port pin */
    IfxPort_OutputIdx select;    /**< \brief Port control code */
} IfxScu_Dcdcsync_Out;

/** \brief Emergency Stop pin mapping structure */
typedef const struct
{
    Ifx_SCU*          module;    /**< \brief Base address */
    IfxPort_Pin       pin;       /**< \brief Port pin */
    Ifx_RxSel         select;    /**< \brief Input multiplexer value */
} IfxScu_Emgstop_In;

/** \brief Watchdog Timer Lock pin mapping structure */
typedef const struct
{
    Ifx_SCU*          module;    /**< \brief Base address */
    IfxPort_Pin       pin;       /**< \brief Port pin */
    IfxPort_OutputIdx select;    /**< \brief Port control code */
} IfxScu_Wdtlck_Out;

/** \brief External Clock pin mapping structure */
typedef const struct
{
    Ifx_SCU*          module;    /**< \brief Base address */
    IfxPort_Pin       pin;       /**< \brief Port pin */
    IfxPort_OutputIdx select;    /**< \brief Port control code */
} IfxScu_Extclk_Out;

extern IfxScu_Emgstop_In IfxScu_EMGSTOPA_P33_8_IN;  /**< \brief Emergency stop Port Pin A input request */
extern IfxScu_Emgstop_In IfxScu_EMGSTOPB_P21_2_IN;  /**< \brief Emergency stop Port Pin B input request */
extern IfxScu_Extclk_Out IfxScu_EXTCLK0_P00_15_OUT;  /**< \brief External Clock 0 */
extern IfxScu_Extclk_Out IfxScu_EXTCLK0_P23_1_OUT;  /**< \brief External Clock 0 */
extern IfxScu_Extclk_Out IfxScu_EXTCLK1_P00_13_OUT;  /**< \brief External Clock 1 */
extern IfxScu_Extclk_Out IfxScu_EXTCLK1_P11_12_OUT;  /**< \brief External Clock 1 */
extern IfxScu_Extclk_Out IfxScu_EXTCLK1_P32_4_OUT;  /**< \brief External Clock 1 */
extern IfxScu_Req_In IfxScu_REQ0A_P15_4_IN;  /**< \brief ERU Channel 0 inputs 0 to 5 (0 is the LSB and 5 is the MSB) */
extern IfxScu_Req_In IfxScu_REQ0C_P10_7_IN;  /**< \brief ERU Channel 0 inputs 0 to 5 (0 is the LSB and 5 is the MSB) */
extern IfxScu_Req_In IfxScu_REQ1A_P14_3_IN;  /**< \brief ERU Channel 1 inputs 0 to 5 (0 is the LSB and 5 is the MSB) */
extern IfxScu_Req_In IfxScu_REQ1C_P10_8_IN;  /**< \brief ERU Channel 1 inputs 0 to 5 (0 is the LSB and 5 is the MSB) */
extern IfxScu_Req_In IfxScu_REQ2A_P10_2_IN;  /**< \brief ERU Channel 2 inputs 0 to 5 (0 is the LSB and 5 is the MSB) */
extern IfxScu_Req_In IfxScu_REQ2B_P02_1_IN;  /**< \brief ERU Channel 2 inputs 0 to 5 (0 is the LSB and 5 is the MSB) */
extern IfxScu_Req_In IfxScu_REQ2C_P00_4_IN;  /**< \brief ERU Channel 2 inputs 0 to 5 (0 is the LSB and 5 is the MSB) */
extern IfxScu_Req_In IfxScu_REQ3A_P10_3_IN;  /**< \brief ERU Channel 3 inputs 0 to 5 (0 is the LSB and 5 is the MSB) */
extern IfxScu_Req_In IfxScu_REQ3B_P14_1_IN;  /**< \brief ERU Channel 3 inputs 0 to 5 (0 is the LSB and 5 is the MSB) */
extern IfxScu_Req_In IfxScu_REQ3C_P02_0_IN;  /**< \brief ERU Channel 3 inputs 0 to 5 (0 is the LSB and 5 is the MSB) */
extern IfxScu_Req_In IfxScu_REQ4A_P33_7_IN;  /**< \brief ERU Channel 4 inputs 0 to 5 (0 is the LSB and 5 is the MSB) */
extern IfxScu_Req_In IfxScu_REQ4D_P15_5_IN;  /**< \brief ERU Channel 4 inputs 0 to 5 (0 is the LSB and 5 is the MSB) */
extern IfxScu_Req_In IfxScu_REQ5A_P15_8_IN;  /**< \brief ERU Channel 5 inputs 0 to 5 (0 is the LSB and 5 is the MSB) */
extern IfxScu_Req_In IfxScu_REQ6A_P20_0_IN;  /**< \brief ERU Channel 6 inputs 0 to 5 (0 is the LSB and 5 is the MSB) */
extern IfxScu_Req_In IfxScu_REQ6D_P11_10_IN;  /**< \brief ERU Channel 6 inputs 0 to 5 (0 is the LSB and 5 is the MSB) */
extern IfxScu_Req_In IfxScu_REQ7A_P20_9_IN;  /**< \brief ERU Channel 7 inputs 0 to 5 (0 is the LSB and 5 is the MSB) */
extern IfxScu_Req_In IfxScu_REQ7C_P15_1_IN;  /**< \brief ERU Channel 7 inputs 0 to 5 (0 is the LSB and 5 is the MSB) */

/** \brief Table dimensions */







/** \brief IfxScu_Emgstop_In table */
extern const IfxScu_Emgstop_In *IfxScu_Emgstop_In_pinTable[1][2];

/** \brief IfxScu_Extclk_Out table */
extern const IfxScu_Extclk_Out *IfxScu_Extclk_Out_pinTable[1][5];

/** \brief IfxScu_Req_In table */
extern const IfxScu_Req_In *IfxScu_Req_In_pinTable[1][8][4];

/** \} */


#line 199 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Scu\\Std\\IfxScuCcu.h"

#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\Infra\\Sfr\\TC38A\\_Reg\\IfxSmu_reg.h"
/**
 * \file IfxSmu_reg.h
 * \brief
 * \copyright Copyright (c) 2020 Infineon Technologies AG. All rights reserved.
 *
 *
 * Version: TC38XA_UM_V1.5.0
 * Specification: TC3xx User Manual V1.5.0
 * MAY BE CHANGED BY USER [yes/no]: No
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * \defgroup IfxSfr_Smu_Registers_Cfg Smu address
 * \ingroup IfxSfr_Smu_Registers
 * 
 * \defgroup IfxSfr_Smu_Registers_Cfg_BaseAddress Base address
 * \ingroup IfxSfr_Smu_Registers_Cfg
 *
 * \defgroup IfxSfr_Smu_Registers_Cfg_Smu 2-SMU
 * \ingroup IfxSfr_Smu_Registers_Cfg
 *
 *
 */


/******************************************************************************/

#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\Infra\\Sfr\\TC38A\\_Reg\\IfxSmu_regdef.h"
/**
 * \file IfxSmu_regdef.h
 * \brief
 * \copyright Copyright (c) 2020 Infineon Technologies AG. All rights reserved.
 *
 *
 * Version: TC38XA_UM_V1.5.0
 * Specification: TC3xx User Manual V1.5.0
 * MAY BE CHANGED BY USER [yes/no]: No
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * \defgroup IfxSfr_Smu_Registers Smu Registers
 * \ingroup IfxSfr
 * 
 * \defgroup IfxSfr_Smu_Registers_Bitfields Bitfields
 * \ingroup IfxSfr_Smu_Registers
 * 
 * \defgroup IfxSfr_Smu_Registers_union Register unions
 * \ingroup IfxSfr_Smu_Registers
 * 
 * \defgroup IfxSfr_Smu_Registers_struct Memory map
 * \ingroup IfxSfr_Smu_Registers
 */


/******************************************************************************/

/******************************************************************************/

/******************************************************************************/

/******************************************************************************/


/** \addtogroup IfxSfr_Smu_Registers_Bitfields
 * \{  */
/** \brief SMU_core Access Enable Register 0 */
typedef struct _Ifx_SMU_ACCEN0_Bits
{
    Ifx_UReg_32Bit EN0:1;             /**< \brief [0:0] Access Enable for Master TAG ID 0 - EN0 (rw) */
    Ifx_UReg_32Bit EN1:1;             /**< \brief [1:1] Access Enable for Master TAG ID 1 - EN1 (rw) */
    Ifx_UReg_32Bit EN2:1;             /**< \brief [2:2] Access Enable for Master TAG ID 2 - EN2 (rw) */
    Ifx_UReg_32Bit EN3:1;             /**< \brief [3:3] Access Enable for Master TAG ID 3 - EN3 (rw) */
    Ifx_UReg_32Bit EN4:1;             /**< \brief [4:4] Access Enable for Master TAG ID 4 - EN4 (rw) */
    Ifx_UReg_32Bit EN5:1;             /**< \brief [5:5] Access Enable for Master TAG ID 5 - EN5 (rw) */
    Ifx_UReg_32Bit EN6:1;             /**< \brief [6:6] Access Enable for Master TAG ID 6 - EN6 (rw) */
    Ifx_UReg_32Bit EN7:1;             /**< \brief [7:7] Access Enable for Master TAG ID 7 - EN7 (rw) */
    Ifx_UReg_32Bit EN8:1;             /**< \brief [8:8] Access Enable for Master TAG ID 8 - EN8 (rw) */
    Ifx_UReg_32Bit EN9:1;             /**< \brief [9:9] Access Enable for Master TAG ID 9 - EN9 (rw) */
    Ifx_UReg_32Bit EN10:1;            /**< \brief [10:10] Access Enable for Master TAG ID 10 - EN10 (rw) */
    Ifx_UReg_32Bit EN11:1;            /**< \brief [11:11] Access Enable for Master TAG ID 11 - EN11 (rw) */
    Ifx_UReg_32Bit EN12:1;            /**< \brief [12:12] Access Enable for Master TAG ID 12 - EN12 (rw) */
    Ifx_UReg_32Bit EN13:1;            /**< \brief [13:13] Access Enable for Master TAG ID 13 - EN13 (rw) */
    Ifx_UReg_32Bit EN14:1;            /**< \brief [14:14] Access Enable for Master TAG ID 14 - EN14 (rw) */
    Ifx_UReg_32Bit EN15:1;            /**< \brief [15:15] Access Enable for Master TAG ID 15 - EN15 (rw) */
    Ifx_UReg_32Bit EN16:1;            /**< \brief [16:16] Access Enable for Master TAG ID 16 - EN16 (rw) */
    Ifx_UReg_32Bit EN17:1;            /**< \brief [17:17] Access Enable for Master TAG ID 17 - EN17 (rw) */
    Ifx_UReg_32Bit EN18:1;            /**< \brief [18:18] Access Enable for Master TAG ID 18 - EN18 (rw) */
    Ifx_UReg_32Bit EN19:1;            /**< \brief [19:19] Access Enable for Master TAG ID 19 - EN19 (rw) */
    Ifx_UReg_32Bit EN20:1;            /**< \brief [20:20] Access Enable for Master TAG ID 20 - EN20 (rw) */
    Ifx_UReg_32Bit EN21:1;            /**< \brief [21:21] Access Enable for Master TAG ID 21 - EN21 (rw) */
    Ifx_UReg_32Bit EN22:1;            /**< \brief [22:22] Access Enable for Master TAG ID 22 - EN22 (rw) */
    Ifx_UReg_32Bit EN23:1;            /**< \brief [23:23] Access Enable for Master TAG ID 23 - EN23 (rw) */
    Ifx_UReg_32Bit EN24:1;            /**< \brief [24:24] Access Enable for Master TAG ID 24 - EN24 (rw) */
    Ifx_UReg_32Bit EN25:1;            /**< \brief [25:25] Access Enable for Master TAG ID 25 - EN25 (rw) */
    Ifx_UReg_32Bit EN26:1;            /**< \brief [26:26] Access Enable for Master TAG ID 26 - EN26 (rw) */
    Ifx_UReg_32Bit EN27:1;            /**< \brief [27:27] Access Enable for Master TAG ID 27 - EN27 (rw) */
    Ifx_UReg_32Bit EN28:1;            /**< \brief [28:28] Access Enable for Master TAG ID 28 - EN28 (rw) */
    Ifx_UReg_32Bit EN29:1;            /**< \brief [29:29] Access Enable for Master TAG ID 29 - EN29 (rw) */
    Ifx_UReg_32Bit EN30:1;            /**< \brief [30:30] Access Enable for Master TAG ID 30 - EN30 (rw) */
    Ifx_UReg_32Bit EN31:1;            /**< \brief [31:31] Access Enable for Master TAG ID 31 - EN31 (rw) */
} Ifx_SMU_ACCEN0_Bits;

/** \brief SMU_core Access Enable Register 1 */
typedef struct _Ifx_SMU_ACCEN1_Bits
{
    Ifx_UReg_32Bit reserved_0:32;     /**< \brief [31:0] \internal Reserved */
} Ifx_SMU_ACCEN1_Bits;

/** \brief Alarm Debug Register */
typedef struct _Ifx_SMU_AD_Bits
{
    Ifx_UReg_32Bit DF0:1;             /**< \brief [0:0] Diagnosis flag for alarm 0 belonging to alarm group i. - DF0 (rh) */
    Ifx_UReg_32Bit DF1:1;             /**< \brief [1:1] Diagnosis flag for alarm 1 belonging to alarm group i. - DF1 (rh) */
    Ifx_UReg_32Bit DF2:1;             /**< \brief [2:2] Diagnosis flag for alarm 2 belonging to alarm group i. - DF2 (rh) */
    Ifx_UReg_32Bit DF3:1;             /**< \brief [3:3] Diagnosis flag for alarm 3 belonging to alarm group i. - DF3 (rh) */
    Ifx_UReg_32Bit DF4:1;             /**< \brief [4:4] Diagnosis flag for alarm 4 belonging to alarm group i. - DF4 (rh) */
    Ifx_UReg_32Bit DF5:1;             /**< \brief [5:5] Diagnosis flag for alarm 5 belonging to alarm group i. - DF5 (rh) */
    Ifx_UReg_32Bit DF6:1;             /**< \brief [6:6] Diagnosis flag for alarm 6 belonging to alarm group i. - DF6 (rh) */
    Ifx_UReg_32Bit DF7:1;             /**< \brief [7:7] Diagnosis flag for alarm 7 belonging to alarm group i. - DF7 (rh) */
    Ifx_UReg_32Bit DF8:1;             /**< \brief [8:8] Diagnosis flag for alarm 8 belonging to alarm group i. - DF8 (rh) */
    Ifx_UReg_32Bit DF9:1;             /**< \brief [9:9] Diagnosis flag for alarm 9 belonging to alarm group i. - DF9 (rh) */
    Ifx_UReg_32Bit DF10:1;            /**< \brief [10:10] Diagnosis flag for alarm 10 belonging to alarm group i. - DF10 (rh) */
    Ifx_UReg_32Bit DF11:1;            /**< \brief [11:11] Diagnosis flag for alarm 11 belonging to alarm group i. - DF11 (rh) */
    Ifx_UReg_32Bit DF12:1;            /**< \brief [12:12] Diagnosis flag for alarm 12 belonging to alarm group i. - DF12 (rh) */
    Ifx_UReg_32Bit DF13:1;            /**< \brief [13:13] Diagnosis flag for alarm 13 belonging to alarm group i. - DF13 (rh) */
    Ifx_UReg_32Bit DF14:1;            /**< \brief [14:14] Diagnosis flag for alarm 14 belonging to alarm group i. - DF14 (rh) */
    Ifx_UReg_32Bit DF15:1;            /**< \brief [15:15] Diagnosis flag for alarm 15 belonging to alarm group i. - DF15 (rh) */
    Ifx_UReg_32Bit DF16:1;            /**< \brief [16:16] Diagnosis flag for alarm 16 belonging to alarm group i. - DF16 (rh) */
    Ifx_UReg_32Bit DF17:1;            /**< \brief [17:17] Diagnosis flag for alarm 17 belonging to alarm group i. - DF17 (rh) */
    Ifx_UReg_32Bit DF18:1;            /**< \brief [18:18] Diagnosis flag for alarm 18 belonging to alarm group i. - DF18 (rh) */
    Ifx_UReg_32Bit DF19:1;            /**< \brief [19:19] Diagnosis flag for alarm 19 belonging to alarm group i. - DF19 (rh) */
    Ifx_UReg_32Bit DF20:1;            /**< \brief [20:20] Diagnosis flag for alarm 20 belonging to alarm group i. - DF20 (rh) */
    Ifx_UReg_32Bit DF21:1;            /**< \brief [21:21] Diagnosis flag for alarm 21 belonging to alarm group i. - DF21 (rh) */
    Ifx_UReg_32Bit DF22:1;            /**< \brief [22:22] Diagnosis flag for alarm 22 belonging to alarm group i. - DF22 (rh) */
    Ifx_UReg_32Bit DF23:1;            /**< \brief [23:23] Diagnosis flag for alarm 23 belonging to alarm group i. - DF23 (rh) */
    Ifx_UReg_32Bit DF24:1;            /**< \brief [24:24] Diagnosis flag for alarm 24 belonging to alarm group i. - DF24 (rh) */
    Ifx_UReg_32Bit DF25:1;            /**< \brief [25:25] Diagnosis flag for alarm 25 belonging to alarm group i. - DF25 (rh) */
    Ifx_UReg_32Bit DF26:1;            /**< \brief [26:26] Diagnosis flag for alarm 26 belonging to alarm group i. - DF26 (rh) */
    Ifx_UReg_32Bit DF27:1;            /**< \brief [27:27] Diagnosis flag for alarm 27 belonging to alarm group i. - DF27 (rh) */
    Ifx_UReg_32Bit DF28:1;            /**< \brief [28:28] Diagnosis flag for alarm 28 belonging to alarm group i. - DF28 (rh) */
    Ifx_UReg_32Bit DF29:1;            /**< \brief [29:29] Diagnosis flag for alarm 29 belonging to alarm group i. - DF29 (rh) */
    Ifx_UReg_32Bit DF30:1;            /**< \brief [30:30] Diagnosis flag for alarm 30 belonging to alarm group i. - DF30 (rh) */
    Ifx_UReg_32Bit DF31:1;            /**< \brief [31:31] Diagnosis flag for alarm 31 belonging to alarm group i. - DF31 (rh) */
} Ifx_SMU_AD_Bits;

/** \brief Alarm Executed Status Register */
typedef struct _Ifx_SMU_AEX_Bits
{
    Ifx_UReg_32Bit IRQ0STS:1;         /**< \brief [0:0] IRQ0 Request Status - IRQ0STS (rh) */
    Ifx_UReg_32Bit IRQ1STS:1;         /**< \brief [1:1] IRQ1 Request Status - IRQ1STS (rh) */
    Ifx_UReg_32Bit IRQ2STS:1;         /**< \brief [2:2] IRQ2 Request Status - IRQ2STS (rh) */
    Ifx_UReg_32Bit RST0STS:1;         /**< \brief [3:3] RST0 Request Status - RST0STS (rh) */
    Ifx_UReg_32Bit RST1STS:1;         /**< \brief [4:4] RST1 Request Status - RST1STS (rh) */
    Ifx_UReg_32Bit RST2STS:1;         /**< \brief [5:5] RST2 Request Status - RST2STS (rh) */
    Ifx_UReg_32Bit RST3STS:1;         /**< \brief [6:6] RST3 Request Status - RST3STS (rh) */
    Ifx_UReg_32Bit RST4STS:1;         /**< \brief [7:7] RST4 Request Status - RST4STS (rh) */
    Ifx_UReg_32Bit RST5STS:1;         /**< \brief [8:8] RST5 Request Status - RST5STS (rh) */
    Ifx_UReg_32Bit NMISTS:1;          /**< \brief [9:9] NMI Request Status - NMISTS (rh) */
    Ifx_UReg_32Bit reserved_10:1;     /**< \brief [10:10] \internal Reserved */
    Ifx_UReg_32Bit EMSSTS:1;          /**< \brief [11:11] EMS Request Status - EMSSTS (rh) */
    Ifx_UReg_32Bit reserved_12:4;     /**< \brief [15:12] \internal Reserved */
    Ifx_UReg_32Bit IRQ0AEM:1;         /**< \brief [16:16] IRQ0 AEM - IRQ0AEM (rh) */
    Ifx_UReg_32Bit IRQ1AEM:1;         /**< \brief [17:17] IRQ1 AEM - IRQ1AEM (rh) */
    Ifx_UReg_32Bit IRQ2AEM:1;         /**< \brief [18:18] IRQ2 AEM - IRQ2AEM (rh) */
    Ifx_UReg_32Bit RST0AEM:1;         /**< \brief [19:19] RST0 AEM - RST0AEM (rh) */
    Ifx_UReg_32Bit RST1AEM:1;         /**< \brief [20:20] RST1 AEM - RST1AEM (rh) */
    Ifx_UReg_32Bit RST2AEM:1;         /**< \brief [21:21] RST2 AEM - RST2AEM (rh) */
    Ifx_UReg_32Bit RST3AEM:1;         /**< \brief [22:22] RST3 AEM - RST3AEM (rh) */
    Ifx_UReg_32Bit RST4AEM:1;         /**< \brief [23:23] RST4 AEM - RST4AEM (rh) */
    Ifx_UReg_32Bit RST5AEM:1;         /**< \brief [24:24] RST5 AEM - RST5AEM (rh) */
    Ifx_UReg_32Bit NMIAEM:1;          /**< \brief [25:25] NMI AEM - NMIAEM (rh) */
    Ifx_UReg_32Bit reserved_26:1;     /**< \brief [26:26] \internal Reserved */
    Ifx_UReg_32Bit EMSAEM:1;          /**< \brief [27:27] EMS AEM - EMSAEM (rh) */
    Ifx_UReg_32Bit reserved_28:4;     /**< \brief [31:28] \internal Reserved */
} Ifx_SMU_AEX_Bits;

/** \brief Alarm Executed Status Clear Register */
typedef struct _Ifx_SMU_AEXCLR_Bits
{
    unsigned __sfrbit32 IRQ0CLR:1;       /**< \brief [0:0] IRQ0 Request Status Clear - IRQ0CLR (w) */
    unsigned __sfrbit32 IRQ1CLR:1;       /**< \brief [1:1] IRQ1 Request Status Clear - IRQ1CLR (w) */
    unsigned __sfrbit32 IRQ2CLR:1;       /**< \brief [2:2] IRQ2 Request Status Clear - IRQ2CLR (w) */
    unsigned __sfrbit32 RST0CLR:1;       /**< \brief [3:3] RST0 Request Status Clear - RST0CLR (w) */
    unsigned __sfrbit32 RST1CLR:1;       /**< \brief [4:4] RST1 Request Status Clear - RST1CLR (w) */
    unsigned __sfrbit32 RST2CLR:1;       /**< \brief [5:5] RST2 Request Status Clear - RST2CLR (w) */
    unsigned __sfrbit32 RST3CLR:1;       /**< \brief [6:6] RST3 Request Status Clear - RST3CLR (w) */
    unsigned __sfrbit32 RST4CLR:1;       /**< \brief [7:7] RST4 Request Status Clear - RST4CLR (w) */
    unsigned __sfrbit32 RST5CLR:1;       /**< \brief [8:8] RST5 Request Status Clear - RST5CLR (w) */
    unsigned __sfrbit32 NMICLR:1;        /**< \brief [9:9] NMI Request Status Clear - NMICLR (w) */
    unsigned __sfrbit32 reserved_10:1;    /**< \brief [10:10] \internal Reserved */
    unsigned __sfrbit32 EMSCLR:1;        /**< \brief [11:11] EMS Request Status Clear - EMSCLR (w) */
    unsigned __sfrbit32 reserved_12:4;    /**< \brief [15:12] \internal Reserved */
    unsigned __sfrbit32 IRQ0AEMCLR:1;    /**< \brief [16:16] IRQ0 AEM Status Clear - IRQ0AEMCLR (w) */
    unsigned __sfrbit32 IRQ1AEMCLR:1;    /**< \brief [17:17] IRQ1 AEM Status Clear - IRQ1AEMCLR (w) */
    unsigned __sfrbit32 IRQ2AEMCLR:1;    /**< \brief [18:18] IRQ2 AEM Status Clear - IRQ2AEMCLR (w) */
    unsigned __sfrbit32 RST0AEMCLR:1;    /**< \brief [19:19] RST0 AEM Status Clear - RST0AEMCLR (w) */
    unsigned __sfrbit32 RST1AEMCLR:1;    /**< \brief [20:20] RST1 AEM Status Clear - RST1AEMCLR (w) */
    unsigned __sfrbit32 RST2AEMCLR:1;    /**< \brief [21:21] RST2 AEM Status Clear - RST2AEMCLR (w) */
    unsigned __sfrbit32 RST3AEMCLR:1;    /**< \brief [22:22] RST3 AEM Status Clear - RST3AEMCLR (w) */
    unsigned __sfrbit32 RST4AEMCLR:1;    /**< \brief [23:23] RST4 AEM Status Clear - RST4AEMCLR (w) */
    unsigned __sfrbit32 RST5AEMCLR:1;    /**< \brief [24:24] RST5 AEM Status Clear - RST5AEMCLR (w) */
    unsigned __sfrbit32 NMIAEMCLR:1;     /**< \brief [25:25] NMI AEM Status Clear - NMIAEMCLR (w) */
    unsigned __sfrbit32 reserved_26:1;    /**< \brief [26:26] \internal Reserved */
    unsigned __sfrbit32 EMSAEMCLR:1;     /**< \brief [27:27] EMS AEM Status Clear - EMSAEMCLR (w) */
    unsigned __sfrbit32 reserved_28:4;    /**< \brief [31:28] \internal Reserved */
} Ifx_SMU_AEXCLR_Bits;

/** \brief Alarm and Fault Counter */
typedef struct _Ifx_SMU_AFCNT_Bits
{
    Ifx_UReg_32Bit FCNT:4;            /**< \brief [3:0] Fault Counter. - FCNT (rh) */
    Ifx_UReg_32Bit ACNT:12;           /**< \brief [15:4] Alarm Counter. - ACNT (rh) */
    Ifx_UReg_32Bit reserved_16:14;    /**< \brief [29:16] \internal Reserved */
    Ifx_UReg_32Bit FCO:1;             /**< \brief [30:30] Fault Counter Overflow. - FCO (rh) */
    Ifx_UReg_32Bit ACO:1;             /**< \brief [31:31] Alarm Counter Overflow. - ACO (rh) */
} Ifx_SMU_AFCNT_Bits;

/** \brief Alarm Status Register */
typedef struct _Ifx_SMU_AG_Bits
{
    unsigned __sfrbit32 SF0:1;           /**< \brief [0:0] Status flag for alarm 0 belonging to alarm group i. - SF0 (rwh) */
    unsigned __sfrbit32 SF1:1;           /**< \brief [1:1] Status flag for alarm 1 belonging to alarm group i. - SF1 (rwh) */
    unsigned __sfrbit32 SF2:1;           /**< \brief [2:2] Status flag for alarm 2 belonging to alarm group i. - SF2 (rwh) */
    unsigned __sfrbit32 SF3:1;           /**< \brief [3:3] Status flag for alarm 3 belonging to alarm group i. - SF3 (rwh) */
    unsigned __sfrbit32 SF4:1;           /**< \brief [4:4] Status flag for alarm 4 belonging to alarm group i. - SF4 (rwh) */
    unsigned __sfrbit32 SF5:1;           /**< \brief [5:5] Status flag for alarm 5 belonging to alarm group i. - SF5 (rwh) */
    unsigned __sfrbit32 SF6:1;           /**< \brief [6:6] Status flag for alarm 6 belonging to alarm group i. - SF6 (rwh) */
    unsigned __sfrbit32 SF7:1;           /**< \brief [7:7] Status flag for alarm 7 belonging to alarm group i. - SF7 (rwh) */
    unsigned __sfrbit32 SF8:1;           /**< \brief [8:8] Status flag for alarm 8 belonging to alarm group i. - SF8 (rwh) */
    unsigned __sfrbit32 SF9:1;           /**< \brief [9:9] Status flag for alarm 9 belonging to alarm group i. - SF9 (rwh) */
    unsigned __sfrbit32 SF10:1;          /**< \brief [10:10] Status flag for alarm 10 belonging to alarm group i. - SF10 (rwh) */
    unsigned __sfrbit32 SF11:1;          /**< \brief [11:11] Status flag for alarm 11 belonging to alarm group i. - SF11 (rwh) */
    unsigned __sfrbit32 SF12:1;          /**< \brief [12:12] Status flag for alarm 12 belonging to alarm group i. - SF12 (rwh) */
    unsigned __sfrbit32 SF13:1;          /**< \brief [13:13] Status flag for alarm 13 belonging to alarm group i. - SF13 (rwh) */
    unsigned __sfrbit32 SF14:1;          /**< \brief [14:14] Status flag for alarm 14 belonging to alarm group i. - SF14 (rwh) */
    unsigned __sfrbit32 SF15:1;          /**< \brief [15:15] Status flag for alarm 15 belonging to alarm group i. - SF15 (rwh) */
    unsigned __sfrbit32 SF16:1;          /**< \brief [16:16] Status flag for alarm 16 belonging to alarm group i. - SF16 (rwh) */
    unsigned __sfrbit32 SF17:1;          /**< \brief [17:17] Status flag for alarm 17 belonging to alarm group i. - SF17 (rwh) */
    unsigned __sfrbit32 SF18:1;          /**< \brief [18:18] Status flag for alarm 18 belonging to alarm group i. - SF18 (rwh) */
    unsigned __sfrbit32 SF19:1;          /**< \brief [19:19] Status flag for alarm 19 belonging to alarm group i. - SF19 (rwh) */
    unsigned __sfrbit32 SF20:1;          /**< \brief [20:20] Status flag for alarm 20 belonging to alarm group i. - SF20 (rwh) */
    unsigned __sfrbit32 SF21:1;          /**< \brief [21:21] Status flag for alarm 21 belonging to alarm group i. - SF21 (rwh) */
    unsigned __sfrbit32 SF22:1;          /**< \brief [22:22] Status flag for alarm 22 belonging to alarm group i. - SF22 (rwh) */
    unsigned __sfrbit32 SF23:1;          /**< \brief [23:23] Status flag for alarm 23 belonging to alarm group i. - SF23 (rwh) */
    unsigned __sfrbit32 SF24:1;          /**< \brief [24:24] Status flag for alarm 24 belonging to alarm group i. - SF24 (rwh) */
    unsigned __sfrbit32 SF25:1;          /**< \brief [25:25] Status flag for alarm 25 belonging to alarm group i. - SF25 (rwh) */
    unsigned __sfrbit32 SF26:1;          /**< \brief [26:26] Status flag for alarm 26 belonging to alarm group i. - SF26 (rwh) */
    unsigned __sfrbit32 SF27:1;          /**< \brief [27:27] Status flag for alarm 27 belonging to alarm group i. - SF27 (rwh) */
    unsigned __sfrbit32 SF28:1;          /**< \brief [28:28] Status flag for alarm 28 belonging to alarm group i. - SF28 (rwh) */
    unsigned __sfrbit32 SF29:1;          /**< \brief [29:29] Status flag for alarm 29 belonging to alarm group i. - SF29 (rwh) */
    unsigned __sfrbit32 SF30:1;          /**< \brief [30:30] Status flag for alarm 30 belonging to alarm group i. - SF30 (rwh) */
    unsigned __sfrbit32 SF31:1;          /**< \brief [31:31] Status flag for alarm 31 belonging to alarm group i. - SF31 (rwh) */
} Ifx_SMU_AG_Bits;

/** \brief Alarm Global Configuration */
typedef struct _Ifx_SMU_AGC_Bits
{
    unsigned __sfrbit32 IGCS0:3;         /**< \brief [2:0] Interrupt Generation Configuration Set 0 - IGCS0 (rw) */
    unsigned __sfrbit32 reserved_3:1;    /**< \brief [3:3] \internal Reserved */
    unsigned __sfrbit32 IGCS1:3;         /**< \brief [6:4] Interrupt Generation Configuration Set 1 - IGCS1 (rw) */
    unsigned __sfrbit32 reserved_7:1;    /**< \brief [7:7] \internal Reserved */
    unsigned __sfrbit32 IGCS2:3;         /**< \brief [10:8] Interrupt Generation Configuration Set 2 - IGCS2 (rw) */
    unsigned __sfrbit32 reserved_11:5;    /**< \brief [15:11] \internal Reserved */
    unsigned __sfrbit32 RCS:6;           /**< \brief [21:16] CPU Reset Configuration Set - RCS (rw) */
    unsigned __sfrbit32 reserved_22:2;    /**< \brief [23:22] \internal Reserved */
    unsigned __sfrbit32 PES:5;           /**< \brief [28:24] Port Emergency Stop - PES (rw) */
    unsigned __sfrbit32 EFRST:1;         /**< \brief [29:29] Enable FAULT to RUN State Transition - EFRST (rw) */
    unsigned __sfrbit32 reserved_30:2;    /**< \brief [31:30] \internal Reserved */
} Ifx_SMU_AGC_Bits;

/** \brief Alarm Configuration Register */
typedef struct _Ifx_SMU_AGCF_Bits
{
    unsigned __sfrbit32 CF0:1;           /**< \brief [0:0] Configuration flag x (x=0-2) for alarm 0 belonging to alarm group i. - CF0 (rw) */
    unsigned __sfrbit32 CF1:1;           /**< \brief [1:1] Configuration flag x (x=0-2) for alarm 1 belonging to alarm group i. - CF1 (rw) */
    unsigned __sfrbit32 CF2:1;           /**< \brief [2:2] Configuration flag x (x=0-2) for alarm 2 belonging to alarm group i. - CF2 (rw) */
    unsigned __sfrbit32 CF3:1;           /**< \brief [3:3] Configuration flag x (x=0-2) for alarm 3 belonging to alarm group i. - CF3 (rw) */
    unsigned __sfrbit32 CF4:1;           /**< \brief [4:4] Configuration flag x (x=0-2) for alarm 4 belonging to alarm group i. - CF4 (rw) */
    unsigned __sfrbit32 CF5:1;           /**< \brief [5:5] Configuration flag x (x=0-2) for alarm 5 belonging to alarm group i. - CF5 (rw) */
    unsigned __sfrbit32 CF6:1;           /**< \brief [6:6] Configuration flag x (x=0-2) for alarm 6 belonging to alarm group i. - CF6 (rw) */
    unsigned __sfrbit32 CF7:1;           /**< \brief [7:7] Configuration flag x (x=0-2) for alarm 7 belonging to alarm group i. - CF7 (rw) */
    unsigned __sfrbit32 CF8:1;           /**< \brief [8:8] Configuration flag x (x=0-2) for alarm 8 belonging to alarm group i. - CF8 (rw) */
    unsigned __sfrbit32 CF9:1;           /**< \brief [9:9] Configuration flag x (x=0-2) for alarm 9 belonging to alarm group i. - CF9 (rw) */
    unsigned __sfrbit32 CF10:1;          /**< \brief [10:10] Configuration flag x (x=0-2) for alarm 10 belonging to alarm group i. - CF10 (rw) */
    unsigned __sfrbit32 CF11:1;          /**< \brief [11:11] Configuration flag x (x=0-2) for alarm 11 belonging to alarm group i. - CF11 (rw) */
    unsigned __sfrbit32 CF12:1;          /**< \brief [12:12] Configuration flag x (x=0-2) for alarm 12 belonging to alarm group i. - CF12 (rw) */
    unsigned __sfrbit32 CF13:1;          /**< \brief [13:13] Configuration flag x (x=0-2) for alarm 13 belonging to alarm group i. - CF13 (rw) */
    unsigned __sfrbit32 CF14:1;          /**< \brief [14:14] Configuration flag x (x=0-2) for alarm 14 belonging to alarm group i. - CF14 (rw) */
    unsigned __sfrbit32 CF15:1;          /**< \brief [15:15] Configuration flag x (x=0-2) for alarm 15 belonging to alarm group i. - CF15 (rw) */
    unsigned __sfrbit32 CF16:1;          /**< \brief [16:16] Configuration flag x (x=0-2) for alarm 16 belonging to alarm group i. - CF16 (rw) */
    unsigned __sfrbit32 CF17:1;          /**< \brief [17:17] Configuration flag x (x=0-2) for alarm 17 belonging to alarm group i. - CF17 (rw) */
    unsigned __sfrbit32 CF18:1;          /**< \brief [18:18] Configuration flag x (x=0-2) for alarm 18 belonging to alarm group i. - CF18 (rw) */
    unsigned __sfrbit32 CF19:1;          /**< \brief [19:19] Configuration flag x (x=0-2) for alarm 19 belonging to alarm group i. - CF19 (rw) */
    unsigned __sfrbit32 CF20:1;          /**< \brief [20:20] Configuration flag x (x=0-2) for alarm 20 belonging to alarm group i. - CF20 (rw) */
    unsigned __sfrbit32 CF21:1;          /**< \brief [21:21] Configuration flag x (x=0-2) for alarm 21 belonging to alarm group i. - CF21 (rw) */
    unsigned __sfrbit32 CF22:1;          /**< \brief [22:22] Configuration flag x (x=0-2) for alarm 22 belonging to alarm group i. - CF22 (rw) */
    unsigned __sfrbit32 CF23:1;          /**< \brief [23:23] Configuration flag x (x=0-2) for alarm 23 belonging to alarm group i. - CF23 (rw) */
    unsigned __sfrbit32 CF24:1;          /**< \brief [24:24] Configuration flag x (x=0-2) for alarm 24 belonging to alarm group i. - CF24 (rw) */
    unsigned __sfrbit32 CF25:1;          /**< \brief [25:25] Configuration flag x (x=0-2) for alarm 25 belonging to alarm group i. - CF25 (rw) */
    unsigned __sfrbit32 CF26:1;          /**< \brief [26:26] Configuration flag x (x=0-2) for alarm 26 belonging to alarm group i. - CF26 (rw) */
    unsigned __sfrbit32 CF27:1;          /**< \brief [27:27] Configuration flag x (x=0-2) for alarm 27 belonging to alarm group i. - CF27 (rw) */
    unsigned __sfrbit32 CF28:1;          /**< \brief [28:28] Configuration flag x (x=0-2) for alarm 28 belonging to alarm group i. - CF28 (rw) */
    unsigned __sfrbit32 CF29:1;          /**< \brief [29:29] Configuration flag x (x=0-2) for alarm 29 belonging to alarm group i. - CF29 (rw) */
    unsigned __sfrbit32 CF30:1;          /**< \brief [30:30] Configuration flag x (x=0-2) for alarm 30 belonging to alarm group i. - CF30 (rw) */
    unsigned __sfrbit32 CF31:1;          /**< \brief [31:31] Configuration flag x (x=0-2) for alarm 31 belonging to alarm group i. - CF31 (rw) */
} Ifx_SMU_AGCF_Bits;

/** \brief SMU_core FSP Configuration Register */
typedef struct _Ifx_SMU_AGFSP_Bits
{
    unsigned __sfrbit32 FE0:1;           /**< \brief [0:0] Fault signaling configuration flag for alarm 0 belonging to alarm group i. - FE0 (rw) */
    unsigned __sfrbit32 FE1:1;           /**< \brief [1:1] Fault signaling configuration flag for alarm 1 belonging to alarm group i. - FE1 (rw) */
    unsigned __sfrbit32 FE2:1;           /**< \brief [2:2] Fault signaling configuration flag for alarm 2 belonging to alarm group i. - FE2 (rw) */
    unsigned __sfrbit32 FE3:1;           /**< \brief [3:3] Fault signaling configuration flag for alarm 3 belonging to alarm group i. - FE3 (rw) */
    unsigned __sfrbit32 FE4:1;           /**< \brief [4:4] Fault signaling configuration flag for alarm 4 belonging to alarm group i. - FE4 (rw) */
    unsigned __sfrbit32 FE5:1;           /**< \brief [5:5] Fault signaling configuration flag for alarm 5 belonging to alarm group i. - FE5 (rw) */
    unsigned __sfrbit32 FE6:1;           /**< \brief [6:6] Fault signaling configuration flag for alarm 6 belonging to alarm group i. - FE6 (rw) */
    unsigned __sfrbit32 FE7:1;           /**< \brief [7:7] Fault signaling configuration flag for alarm 7 belonging to alarm group i. - FE7 (rw) */
    unsigned __sfrbit32 FE8:1;           /**< \brief [8:8] Fault signaling configuration flag for alarm 8 belonging to alarm group i. - FE8 (rw) */
    unsigned __sfrbit32 FE9:1;           /**< \brief [9:9] Fault signaling configuration flag for alarm 9 belonging to alarm group i. - FE9 (rw) */
    unsigned __sfrbit32 FE10:1;          /**< \brief [10:10] Fault signaling configuration flag for alarm 10 belonging to alarm group i. - FE10 (rw) */
    unsigned __sfrbit32 FE11:1;          /**< \brief [11:11] Fault signaling configuration flag for alarm 11 belonging to alarm group i. - FE11 (rw) */
    unsigned __sfrbit32 FE12:1;          /**< \brief [12:12] Fault signaling configuration flag for alarm 12 belonging to alarm group i. - FE12 (rw) */
    unsigned __sfrbit32 FE13:1;          /**< \brief [13:13] Fault signaling configuration flag for alarm 13 belonging to alarm group i. - FE13 (rw) */
    unsigned __sfrbit32 FE14:1;          /**< \brief [14:14] Fault signaling configuration flag for alarm 14 belonging to alarm group i. - FE14 (rw) */
    unsigned __sfrbit32 FE15:1;          /**< \brief [15:15] Fault signaling configuration flag for alarm 15 belonging to alarm group i. - FE15 (rw) */
    unsigned __sfrbit32 FE16:1;          /**< \brief [16:16] Fault signaling configuration flag for alarm 16 belonging to alarm group i. - FE16 (rw) */
    unsigned __sfrbit32 FE17:1;          /**< \brief [17:17] Fault signaling configuration flag for alarm 17 belonging to alarm group i. - FE17 (rw) */
    unsigned __sfrbit32 FE18:1;          /**< \brief [18:18] Fault signaling configuration flag for alarm 18 belonging to alarm group i. - FE18 (rw) */
    unsigned __sfrbit32 FE19:1;          /**< \brief [19:19] Fault signaling configuration flag for alarm 19 belonging to alarm group i. - FE19 (rw) */
    unsigned __sfrbit32 FE20:1;          /**< \brief [20:20] Fault signaling configuration flag for alarm 20 belonging to alarm group i. - FE20 (rw) */
    unsigned __sfrbit32 FE21:1;          /**< \brief [21:21] Fault signaling configuration flag for alarm 21 belonging to alarm group i. - FE21 (rw) */
    unsigned __sfrbit32 FE22:1;          /**< \brief [22:22] Fault signaling configuration flag for alarm 22 belonging to alarm group i. - FE22 (rw) */
    unsigned __sfrbit32 FE23:1;          /**< \brief [23:23] Fault signaling configuration flag for alarm 23 belonging to alarm group i. - FE23 (rw) */
    unsigned __sfrbit32 FE24:1;          /**< \brief [24:24] Fault signaling configuration flag for alarm 24 belonging to alarm group i. - FE24 (rw) */
    unsigned __sfrbit32 FE25:1;          /**< \brief [25:25] Fault signaling configuration flag for alarm 25 belonging to alarm group i. - FE25 (rw) */
    unsigned __sfrbit32 FE26:1;          /**< \brief [26:26] Fault signaling configuration flag for alarm 26 belonging to alarm group i. - FE26 (rw) */
    unsigned __sfrbit32 FE27:1;          /**< \brief [27:27] Fault signaling configuration flag for alarm 27 belonging to alarm group i. - FE27 (rw) */
    unsigned __sfrbit32 FE28:1;          /**< \brief [28:28] Fault signaling configuration flag for alarm 28 belonging to alarm group i. - FE28 (rw) */
    unsigned __sfrbit32 FE29:1;          /**< \brief [29:29] Fault signaling configuration flag for alarm 29 belonging to alarm group i. - FE29 (rw) */
    unsigned __sfrbit32 FE30:1;          /**< \brief [30:30] Fault signaling configuration flag for alarm 30 belonging to alarm group i. - FE30 (rw) */
    unsigned __sfrbit32 FE31:1;          /**< \brief [31:31] Fault signaling configuration flag for alarm 31 belonging to alarm group i. - FE31 (rw) */
} Ifx_SMU_AGFSP_Bits;

/** \brief Clock Control Register */
typedef struct _Ifx_SMU_CLC_Bits
{
    Ifx_UReg_32Bit DISR:1;            /**< \brief [0:0] Module Disable Request Bit - DISR (rw) */
    Ifx_UReg_32Bit DISS:1;            /**< \brief [1:1] Module Disable Status Bit - DISS (rh) */
    Ifx_UReg_32Bit reserved_2:1;      /**< \brief [2:2] \internal Reserved */
    Ifx_UReg_32Bit EDIS:1;            /**< \brief [3:3] Sleep Mode Enable Control - EDIS (rw) */
    Ifx_UReg_32Bit reserved_4:28;     /**< \brief [31:4] \internal Reserved */
} Ifx_SMU_CLC_Bits;

/** \brief Command Register */
typedef struct _Ifx_SMU_CMD_Bits
{
    unsigned __sfrbit32 CMD:4;           /**< \brief [3:0] Implements the SMU_core Command Interface. - CMD (w) */
    unsigned __sfrbit32 ARG:4;           /**< \brief [7:4] Implements the SMU_core Command Interface. - ARG (w) */
    unsigned __sfrbit32 reserved_8:24;    /**< \brief [31:8] \internal Reserved */
} Ifx_SMU_CMD_Bits;

/** \brief Debug Register */
typedef struct _Ifx_SMU_DBG_Bits
{
    Ifx_UReg_32Bit SSM:2;             /**< \brief [1:0] Running state of the SMU_core State Machine - SSM (rh) */
    Ifx_UReg_32Bit reserved_2:30;     /**< \brief [31:2] \internal Reserved */
} Ifx_SMU_DBG_Bits;

/** \brief Fault Signaling Protocol */
typedef struct _Ifx_SMU_FSP_Bits
{
    unsigned __sfrbit32 PRE1:3;          /**< \brief [2:0] Prescaler1 - PRE1 (rw) */
    unsigned __sfrbit32 PRE2:2;          /**< \brief [4:3] Prescaler2 - PRE2 (rw) */
    unsigned __sfrbit32 MODE:2;          /**< \brief [6:5] Fault Signaling Protocol configuration - MODE (rw) */
    unsigned __sfrbit32 PES:1;           /**< \brief [7:7] Port Emergency Stop (PES) - PES (rw) */
    unsigned __sfrbit32 TFSP_LOW:14;     /**< \brief [21:8] Specifies the FSP fault state duration - TFSP_LOW (r) */
    unsigned __sfrbit32 TFSP_HIGH:10;    /**< \brief [31:22] Specifies the FSP fault state duration - TFSP_HIGH (rw) */
} Ifx_SMU_FSP_Bits;

/** \brief Module Identification Register */
typedef struct _Ifx_SMU_ID_Bits
{
    Ifx_UReg_32Bit MOD_REV:8;         /**< \brief [7:0] Module Revision Number - MOD_REV (r) */
    Ifx_UReg_32Bit MOD_TYPE:8;        /**< \brief [15:8] Module Type - MOD_TYPE (r) */
    Ifx_UReg_32Bit MOD_NUMBER:16;     /**< \brief [31:16] Module Number Value - MOD_NUMBER (r) */
} Ifx_SMU_ID_Bits;

/** \brief Key Register */
typedef struct _Ifx_SMU_KEYS_Bits
{
    unsigned __sfrbit32 CFGLCK:8;        /**< \brief [7:0] Configuration Lock - CFGLCK (rw) */
    unsigned __sfrbit32 PERLCK:8;        /**< \brief [15:8] Permanent Lock - PERLCK (rw) */
    unsigned __sfrbit32 reserved_16:16;    /**< \brief [31:16] \internal Reserved */
} Ifx_SMU_KEYS_Bits;

/** \brief OCDS Control and Status */
typedef struct _Ifx_SMU_OCS_Bits
{
    Ifx_UReg_32Bit TGS:2;             /**< \brief [1:0] Trigger Set for OTGB0/1 - TGS (rw) */
    Ifx_UReg_32Bit TGB:1;             /**< \brief [2:2] OTGB0/1 Bus Select - TGB (rw) */
    Ifx_UReg_32Bit TG_P:1;            /**< \brief [3:3] TGS, TGB Write Protection - TG_P (w) */
    Ifx_UReg_32Bit reserved_4:20;     /**< \brief [23:4] \internal Reserved */
    Ifx_UReg_32Bit SUS:4;             /**< \brief [27:24] OCDS Suspend Control - SUS (rw) */
    Ifx_UReg_32Bit SUS_P:1;           /**< \brief [28:28] SUS Write Protection - SUS_P (w) */
    Ifx_UReg_32Bit SUSSTA:1;          /**< \brief [29:29] Suspend State - SUSSTA (rh) */
    Ifx_UReg_32Bit reserved_30:2;     /**< \brief [31:30] \internal Reserved */
} Ifx_SMU_OCS_Bits;

/** \brief Port Control */
typedef struct _Ifx_SMU_PCTL_Bits
{
    unsigned __sfrbit32 HWDIR:2;         /**< \brief [1:0] Port Direction. - HWDIR (rw) */
    unsigned __sfrbit32 HWEN:2;          /**< \brief [3:2] Port Enable - HWEN (rw) */
    unsigned __sfrbit32 GFSCU_EN:1;      /**< \brief [4:4] Glitch Filter for ErrorPin SMU_FSP0 to SCU enable - GFSCU_EN (rw) */
    unsigned __sfrbit32 GFSTS_EN:1;      /**< \brief [5:5] Glitch Filter for ErrorPin SMU_FSP0 to register SMU_STS enable - GFSTS_EN (rw) */
    unsigned __sfrbit32 reserved_6:1;    /**< \brief [6:6] \internal Reserved */
    unsigned __sfrbit32 PCS:1;           /**< \brief [7:7] PAD Configuration Select - PCS (rw) */
    unsigned __sfrbit32 reserved_8:6;    /**< \brief [13:8] \internal Reserved */
    unsigned __sfrbit32 reserved_14:9;    /**< \brief [22:14] \internal Reserved */
    unsigned __sfrbit32 reserved_23:9;    /**< \brief [31:23] \internal Reserved */
} Ifx_SMU_PCTL_Bits;

/** \brief Register Monitor Control */
typedef struct _Ifx_SMU_RMCTL_Bits
{
    unsigned __sfrbit32 TE0:1;           /**< \brief [0:0] Test Enable. - TE0 (rw) */
    unsigned __sfrbit32 TE1:1;           /**< \brief [1:1] Test Enable. - TE1 (rw) */
    unsigned __sfrbit32 TE2:1;           /**< \brief [2:2] Test Enable. - TE2 (rw) */
    unsigned __sfrbit32 TE3:1;           /**< \brief [3:3] Test Enable. - TE3 (rw) */
    unsigned __sfrbit32 TE4:1;           /**< \brief [4:4] Test Enable. - TE4 (rw) */
    unsigned __sfrbit32 TE5:1;           /**< \brief [5:5] Test Enable. - TE5 (rw) */
    unsigned __sfrbit32 TE6:1;           /**< \brief [6:6] Test Enable. - TE6 (rw) */
    unsigned __sfrbit32 TE7:1;           /**< \brief [7:7] Test Enable. - TE7 (rw) */
    unsigned __sfrbit32 TE8:1;           /**< \brief [8:8] Test Enable. - TE8 (rw) */
    unsigned __sfrbit32 TE9:1;           /**< \brief [9:9] Test Enable. - TE9 (rw) */
    unsigned __sfrbit32 TE10:1;          /**< \brief [10:10] Test Enable. - TE10 (rw) */
    unsigned __sfrbit32 reserved_11:1;    /**< \brief [11:11] \internal Reserved */
    unsigned __sfrbit32 reserved_12:1;    /**< \brief [12:12] \internal Reserved */
    unsigned __sfrbit32 reserved_13:1;    /**< \brief [13:13] \internal Reserved */
    unsigned __sfrbit32 reserved_14:1;    /**< \brief [14:14] \internal Reserved */
    unsigned __sfrbit32 reserved_15:1;    /**< \brief [15:15] \internal Reserved */
    unsigned __sfrbit32 reserved_16:1;    /**< \brief [16:16] \internal Reserved */
    unsigned __sfrbit32 reserved_17:1;    /**< \brief [17:17] \internal Reserved */
    unsigned __sfrbit32 reserved_18:1;    /**< \brief [18:18] \internal Reserved */
    unsigned __sfrbit32 reserved_19:1;    /**< \brief [19:19] \internal Reserved */
    unsigned __sfrbit32 reserved_20:1;    /**< \brief [20:20] \internal Reserved */
    unsigned __sfrbit32 reserved_21:1;    /**< \brief [21:21] \internal Reserved */
    unsigned __sfrbit32 reserved_22:1;    /**< \brief [22:22] \internal Reserved */
    unsigned __sfrbit32 reserved_23:1;    /**< \brief [23:23] \internal Reserved */
    unsigned __sfrbit32 reserved_24:1;    /**< \brief [24:24] \internal Reserved */
    unsigned __sfrbit32 reserved_25:1;    /**< \brief [25:25] \internal Reserved */
    unsigned __sfrbit32 reserved_26:1;    /**< \brief [26:26] \internal Reserved */
    unsigned __sfrbit32 reserved_27:1;    /**< \brief [27:27] \internal Reserved */
    unsigned __sfrbit32 reserved_28:1;    /**< \brief [28:28] \internal Reserved */
    unsigned __sfrbit32 reserved_29:1;    /**< \brief [29:29] \internal Reserved */
    unsigned __sfrbit32 reserved_30:1;    /**< \brief [30:30] \internal Reserved */
    unsigned __sfrbit32 reserved_31:1;    /**< \brief [31:31] \internal Reserved */
} Ifx_SMU_RMCTL_Bits;

/** \brief Register Monitor Error Flags */
typedef struct _Ifx_SMU_RMEF_Bits
{
    unsigned __sfrbit32 EF0:1;           /**< \brief [0:0] Status flag related to the different instances of the register monitor safety mechanism. - EF0 (rwh) */
    unsigned __sfrbit32 EF1:1;           /**< \brief [1:1] Status flag related to the different instances of the register monitor safety mechanism. - EF1 (rwh) */
    unsigned __sfrbit32 EF2:1;           /**< \brief [2:2] Status flag related to the different instances of the register monitor safety mechanism. - EF2 (rwh) */
    unsigned __sfrbit32 EF3:1;           /**< \brief [3:3] Status flag related to the different instances of the register monitor safety mechanism. - EF3 (rwh) */
    unsigned __sfrbit32 EF4:1;           /**< \brief [4:4] Status flag related to the different instances of the register monitor safety mechanism. - EF4 (rwh) */
    unsigned __sfrbit32 EF5:1;           /**< \brief [5:5] Status flag related to the different instances of the register monitor safety mechanism. - EF5 (rwh) */
    unsigned __sfrbit32 EF6:1;           /**< \brief [6:6] Status flag related to the different instances of the register monitor safety mechanism. - EF6 (rwh) */
    unsigned __sfrbit32 EF7:1;           /**< \brief [7:7] Status flag related to the different instances of the register monitor safety mechanism. - EF7 (rwh) */
    unsigned __sfrbit32 EF8:1;           /**< \brief [8:8] Status flag related to the different instances of the register monitor safety mechanism. - EF8 (rwh) */
    unsigned __sfrbit32 EF9:1;           /**< \brief [9:9] Status flag related to the different instances of the register monitor safety mechanism. - EF9 (rwh) */
    unsigned __sfrbit32 EF10:1;          /**< \brief [10:10] Status flag related to the different instances of the register monitor safety mechanism. - EF10 (rwh) */
    unsigned __sfrbit32 reserved_11:1;    /**< \brief [11:11] \internal Reserved */
    unsigned __sfrbit32 reserved_12:1;    /**< \brief [12:12] \internal Reserved */
    unsigned __sfrbit32 reserved_13:1;    /**< \brief [13:13] \internal Reserved */
    unsigned __sfrbit32 reserved_14:1;    /**< \brief [14:14] \internal Reserved */
    unsigned __sfrbit32 reserved_15:1;    /**< \brief [15:15] \internal Reserved */
    unsigned __sfrbit32 reserved_16:1;    /**< \brief [16:16] \internal Reserved */
    unsigned __sfrbit32 reserved_17:1;    /**< \brief [17:17] \internal Reserved */
    unsigned __sfrbit32 reserved_18:1;    /**< \brief [18:18] \internal Reserved */
    unsigned __sfrbit32 reserved_19:1;    /**< \brief [19:19] \internal Reserved */
    unsigned __sfrbit32 reserved_20:1;    /**< \brief [20:20] \internal Reserved */
    unsigned __sfrbit32 reserved_21:1;    /**< \brief [21:21] \internal Reserved */
    unsigned __sfrbit32 reserved_22:1;    /**< \brief [22:22] \internal Reserved */
    unsigned __sfrbit32 reserved_23:1;    /**< \brief [23:23] \internal Reserved */
    unsigned __sfrbit32 reserved_24:1;    /**< \brief [24:24] \internal Reserved */
    unsigned __sfrbit32 reserved_25:1;    /**< \brief [25:25] \internal Reserved */
    unsigned __sfrbit32 reserved_26:1;    /**< \brief [26:26] \internal Reserved */
    unsigned __sfrbit32 reserved_27:1;    /**< \brief [27:27] \internal Reserved */
    unsigned __sfrbit32 reserved_28:1;    /**< \brief [28:28] \internal Reserved */
    unsigned __sfrbit32 reserved_29:1;    /**< \brief [29:29] \internal Reserved */
    unsigned __sfrbit32 reserved_30:1;    /**< \brief [30:30] \internal Reserved */
    unsigned __sfrbit32 reserved_31:1;    /**< \brief [31:31] \internal Reserved */
} Ifx_SMU_RMEF_Bits;

/** \brief Register Monitor Self Test Status */
typedef struct _Ifx_SMU_RMSTS_Bits
{
    unsigned __sfrbit32 STS0:1;          /**< \brief [0:0] Ready flag related to the different instances of the register monitor safety mechanism. - STS0 (rwh) */
    unsigned __sfrbit32 STS1:1;          /**< \brief [1:1] Ready flag related to the different instances of the register monitor safety mechanism. - STS1 (rwh) */
    unsigned __sfrbit32 STS2:1;          /**< \brief [2:2] Ready flag related to the different instances of the register monitor safety mechanism. - STS2 (rwh) */
    unsigned __sfrbit32 STS3:1;          /**< \brief [3:3] Ready flag related to the different instances of the register monitor safety mechanism. - STS3 (rwh) */
    unsigned __sfrbit32 STS4:1;          /**< \brief [4:4] Ready flag related to the different instances of the register monitor safety mechanism. - STS4 (rwh) */
    unsigned __sfrbit32 STS5:1;          /**< \brief [5:5] Ready flag related to the different instances of the register monitor safety mechanism. - STS5 (rwh) */
    unsigned __sfrbit32 STS6:1;          /**< \brief [6:6] Ready flag related to the different instances of the register monitor safety mechanism. - STS6 (rwh) */
    unsigned __sfrbit32 STS7:1;          /**< \brief [7:7] Ready flag related to the different instances of the register monitor safety mechanism. - STS7 (rwh) */
    unsigned __sfrbit32 STS8:1;          /**< \brief [8:8] Ready flag related to the different instances of the register monitor safety mechanism. - STS8 (rwh) */
    unsigned __sfrbit32 STS9:1;          /**< \brief [9:9] Ready flag related to the different instances of the register monitor safety mechanism. - STS9 (rwh) */
    unsigned __sfrbit32 STS10:1;         /**< \brief [10:10] Ready flag related to the different instances of the register monitor safety mechanism. - STS10 (rwh) */
    unsigned __sfrbit32 reserved_11:1;    /**< \brief [11:11] \internal Reserved */
    unsigned __sfrbit32 reserved_12:1;    /**< \brief [12:12] \internal Reserved */
    unsigned __sfrbit32 reserved_13:1;    /**< \brief [13:13] \internal Reserved */
    unsigned __sfrbit32 reserved_14:1;    /**< \brief [14:14] \internal Reserved */
    unsigned __sfrbit32 reserved_15:1;    /**< \brief [15:15] \internal Reserved */
    unsigned __sfrbit32 reserved_16:1;    /**< \brief [16:16] \internal Reserved */
    unsigned __sfrbit32 reserved_17:1;    /**< \brief [17:17] \internal Reserved */
    unsigned __sfrbit32 reserved_18:1;    /**< \brief [18:18] \internal Reserved */
    unsigned __sfrbit32 reserved_19:1;    /**< \brief [19:19] \internal Reserved */
    unsigned __sfrbit32 reserved_20:1;    /**< \brief [20:20] \internal Reserved */
    unsigned __sfrbit32 reserved_21:1;    /**< \brief [21:21] \internal Reserved */
    unsigned __sfrbit32 reserved_22:1;    /**< \brief [22:22] \internal Reserved */
    unsigned __sfrbit32 reserved_23:1;    /**< \brief [23:23] \internal Reserved */
    unsigned __sfrbit32 reserved_24:1;    /**< \brief [24:24] \internal Reserved */
    unsigned __sfrbit32 reserved_25:1;    /**< \brief [25:25] \internal Reserved */
    unsigned __sfrbit32 reserved_26:1;    /**< \brief [26:26] \internal Reserved */
    unsigned __sfrbit32 reserved_27:1;    /**< \brief [27:27] \internal Reserved */
    unsigned __sfrbit32 reserved_28:1;    /**< \brief [28:28] \internal Reserved */
    unsigned __sfrbit32 reserved_29:1;    /**< \brief [29:29] \internal Reserved */
    unsigned __sfrbit32 reserved_30:1;    /**< \brief [30:30] \internal Reserved */
    unsigned __sfrbit32 reserved_31:1;    /**< \brief [31:31] \internal Reserved */
} Ifx_SMU_RMSTS_Bits;

/** \brief Recovery Timer 0 Alarm Configuration 0 */
typedef struct _Ifx_SMU_RTAC00_Bits
{
    unsigned __sfrbit32 GID0:4;          /**< \brief [3:0] Group Index 0. - GID0 (rw) */
    unsigned __sfrbit32 ALID0:5;         /**< \brief [8:4] Alarm Identifier 0. - ALID0 (rw) */
    unsigned __sfrbit32 reserved_9:7;    /**< \brief [15:9] \internal Reserved */
    unsigned __sfrbit32 GID1:4;          /**< \brief [19:16] Group Index 1. - GID1 (rw) */
    unsigned __sfrbit32 ALID1:5;         /**< \brief [24:20] Alarm Identifier 1. - ALID1 (rw) */
    unsigned __sfrbit32 reserved_25:7;    /**< \brief [31:25] \internal Reserved */
} Ifx_SMU_RTAC00_Bits;

/** \brief Recovery Timer 0 Alarm Configuration 1 */
typedef struct _Ifx_SMU_RTAC01_Bits
{
    unsigned __sfrbit32 GID2:4;          /**< \brief [3:0] Group Index 2. - GID2 (rw) */
    unsigned __sfrbit32 ALID2:5;         /**< \brief [8:4] Alarm Identifier 0. - ALID2 (rw) */
    unsigned __sfrbit32 reserved_9:7;    /**< \brief [15:9] \internal Reserved */
    unsigned __sfrbit32 GID3:4;          /**< \brief [19:16] Group Index 3. - GID3 (rw) */
    unsigned __sfrbit32 ALID3:5;         /**< \brief [24:20] Alarm Identifier 1. - ALID3 (rw) */
    unsigned __sfrbit32 reserved_25:7;    /**< \brief [31:25] \internal Reserved */
} Ifx_SMU_RTAC01_Bits;

/** \brief Recovery Timer 1 Alarm Configuration 0 */
typedef struct _Ifx_SMU_RTAC10_Bits
{
    unsigned __sfrbit32 GID0:4;          /**< \brief [3:0] Group Index 0. - GID0 (rw) */
    unsigned __sfrbit32 ALID0:5;         /**< \brief [8:4] Alarm Identifier 0. - ALID0 (rw) */
    unsigned __sfrbit32 reserved_9:7;    /**< \brief [15:9] \internal Reserved */
    unsigned __sfrbit32 GID1:4;          /**< \brief [19:16] Group Index 1. - GID1 (rw) */
    unsigned __sfrbit32 ALID1:5;         /**< \brief [24:20] Alarm Identifier 1. - ALID1 (rw) */
    unsigned __sfrbit32 reserved_25:7;    /**< \brief [31:25] \internal Reserved */
} Ifx_SMU_RTAC10_Bits;

/** \brief Recovery Timer 1 Alarm Configuration 1 */
typedef struct _Ifx_SMU_RTAC11_Bits
{
    unsigned __sfrbit32 GID2:4;          /**< \brief [3:0] Group Index 2. - GID2 (rw) */
    unsigned __sfrbit32 ALID2:5;         /**< \brief [8:4] Alarm Identifier 2. - ALID2 (rw) */
    unsigned __sfrbit32 reserved_9:7;    /**< \brief [15:9] \internal Reserved */
    unsigned __sfrbit32 GID3:4;          /**< \brief [19:16] Group Index 3. - GID3 (rw) */
    unsigned __sfrbit32 ALID3:5;         /**< \brief [24:20] Alarm Identifier 3. - ALID3 (rw) */
    unsigned __sfrbit32 reserved_25:7;    /**< \brief [31:25] \internal Reserved */
} Ifx_SMU_RTAC11_Bits;

/** \brief Recovery Timer Configuration */
typedef struct _Ifx_SMU_RTC_Bits
{
    unsigned __sfrbit32 RT0E:1;          /**< \brief [0:0] RT0 Enable Bit - RT0E (rw) */
    unsigned __sfrbit32 RT1E:1;          /**< \brief [1:1] RT1 Enable Bit - RT1E (rw) */
    unsigned __sfrbit32 reserved_2:6;    /**< \brief [7:2] \internal Reserved */
    unsigned __sfrbit32 RTD:24;          /**< \brief [31:8] Recovery Timer Duration - RTD (rw) */
} Ifx_SMU_RTC_Bits;

/** \brief Status Register */
typedef struct _Ifx_SMU_STS_Bits
{
    unsigned __sfrbit32 CMD:4;           /**< \brief [3:0] Last command received - CMD (rwh) */
    unsigned __sfrbit32 ARG:4;           /**< \brief [7:4] Last command argument received - ARG (rwh) */
    unsigned __sfrbit32 RES:1;           /**< \brief [8:8] Result of last received command - RES (rwh) */
    unsigned __sfrbit32 ASCE:1;          /**< \brief [9:9] Alarm Status Clear Enable - ASCE (rwh) */
    unsigned __sfrbit32 FSP:2;           /**< \brief [11:10] Fault Signaling Protocol status - FSP (rh) */
    unsigned __sfrbit32 FSTS:1;          /**< \brief [12:12] Fault State Timing Status - FSTS (rwh) */
    unsigned __sfrbit32 reserved_13:3;    /**< \brief [15:13] \internal Reserved */
    unsigned __sfrbit32 RTS0:1;          /**< \brief [16:16] Recovery Timer 0 Status - RTS0 (rwh) */
    unsigned __sfrbit32 RTME0:1;         /**< \brief [17:17] Recovery Timer 0 Missed Event - RTME0 (rwh) */
    unsigned __sfrbit32 RTS1:1;          /**< \brief [18:18] Recovery Timer 1 Status - RTS1 (rwh) */
    unsigned __sfrbit32 RTME1:1;         /**< \brief [19:19] Recovery Timer 1 Missed Event - RTME1 (rwh) */
    unsigned __sfrbit32 reserved_20:12;    /**< \brief [31:20] \internal Reserved */
} Ifx_SMU_STS_Bits;

/** \}  */
/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_smu_Registers_union
 * \{   */
/** \brief SMU_core Access Enable Register 0   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SMU_ACCEN0_Bits B;            /**< \brief Bitfield access */
} Ifx_SMU_ACCEN0;

/** \brief SMU_core Access Enable Register 1   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SMU_ACCEN1_Bits B;            /**< \brief Bitfield access */
} Ifx_SMU_ACCEN1;

/** \brief Alarm Debug Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SMU_AD_Bits B;                /**< \brief Bitfield access */
} Ifx_SMU_AD;

/** \brief Alarm Executed Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SMU_AEX_Bits B;               /**< \brief Bitfield access */
} Ifx_SMU_AEX;

/** \brief Alarm Executed Status Clear Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SMU_AEXCLR_Bits B;            /**< \brief Bitfield access */
} Ifx_SMU_AEXCLR;

/** \brief Alarm and Fault Counter   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SMU_AFCNT_Bits B;             /**< \brief Bitfield access */
} Ifx_SMU_AFCNT;

/** \brief Alarm Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SMU_AG_Bits B;                /**< \brief Bitfield access */
} Ifx_SMU_AG;

/** \brief Alarm Global Configuration   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SMU_AGC_Bits B;               /**< \brief Bitfield access */
} Ifx_SMU_AGC;

/** \brief Alarm Configuration Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SMU_AGCF_Bits B;              /**< \brief Bitfield access */
} Ifx_SMU_AGCF;

/** \brief SMU_core FSP Configuration Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SMU_AGFSP_Bits B;             /**< \brief Bitfield access */
} Ifx_SMU_AGFSP;

/** \brief Clock Control Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SMU_CLC_Bits B;               /**< \brief Bitfield access */
} Ifx_SMU_CLC;

/** \brief Command Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SMU_CMD_Bits B;               /**< \brief Bitfield access */
} Ifx_SMU_CMD;

/** \brief Debug Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SMU_DBG_Bits B;               /**< \brief Bitfield access */
} Ifx_SMU_DBG;

/** \brief Fault Signaling Protocol   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SMU_FSP_Bits B;               /**< \brief Bitfield access */
} Ifx_SMU_FSP;

/** \brief Module Identification Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SMU_ID_Bits B;                /**< \brief Bitfield access */
} Ifx_SMU_ID;

/** \brief Key Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SMU_KEYS_Bits B;              /**< \brief Bitfield access */
} Ifx_SMU_KEYS;

/** \brief OCDS Control and Status   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SMU_OCS_Bits B;               /**< \brief Bitfield access */
} Ifx_SMU_OCS;

/** \brief Port Control   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SMU_PCTL_Bits B;              /**< \brief Bitfield access */
} Ifx_SMU_PCTL;

/** \brief Register Monitor Control   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SMU_RMCTL_Bits B;             /**< \brief Bitfield access */
} Ifx_SMU_RMCTL;

/** \brief Register Monitor Error Flags   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SMU_RMEF_Bits B;              /**< \brief Bitfield access */
} Ifx_SMU_RMEF;

/** \brief Register Monitor Self Test Status   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SMU_RMSTS_Bits B;             /**< \brief Bitfield access */
} Ifx_SMU_RMSTS;

/** \brief Recovery Timer 0 Alarm Configuration 0   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SMU_RTAC00_Bits B;            /**< \brief Bitfield access */
} Ifx_SMU_RTAC00;

/** \brief Recovery Timer 0 Alarm Configuration 1   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SMU_RTAC01_Bits B;            /**< \brief Bitfield access */
} Ifx_SMU_RTAC01;

/** \brief Recovery Timer 1 Alarm Configuration 0   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SMU_RTAC10_Bits B;            /**< \brief Bitfield access */
} Ifx_SMU_RTAC10;

/** \brief Recovery Timer 1 Alarm Configuration 1   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SMU_RTAC11_Bits B;            /**< \brief Bitfield access */
} Ifx_SMU_RTAC11;

/** \brief Recovery Timer Configuration   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SMU_RTC_Bits B;               /**< \brief Bitfield access */
} Ifx_SMU_RTC;

/** \brief Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SMU_STS_Bits B;               /**< \brief Bitfield access */
} Ifx_SMU_STS;

/** \}  */

/******************************************************************************/
/** \addtogroup IfxSfr_Smu_Registers_struct
 * \{  */
/******************************************************************************/
/** \name Object L0
 * \{  */

/** \brief SMU object */
typedef volatile struct _Ifx_SMU
{
       Ifx_SMU_CLC                         CLC;                    /**< \brief 0, Clock Control Register*/
       Ifx_UReg_8Bit                       reserved_4[4];          /**< \brief 4, \internal Reserved */
       Ifx_SMU_ID                          ID;                     /**< \brief 8, Module Identification Register*/
       Ifx_UReg_8Bit                       reserved_C[20];         /**< \brief C, \internal Reserved */
       Ifx_SMU_CMD                         CMD;                    /**< \brief 20, Command Register*/
       Ifx_SMU_STS                         STS;                    /**< \brief 24, Status Register*/
       Ifx_SMU_FSP                         FSP;                    /**< \brief 28, Fault Signaling Protocol*/
       Ifx_SMU_AGC                         AGC;                    /**< \brief 2C, Alarm Global Configuration*/
       Ifx_SMU_RTC                         RTC;                    /**< \brief 30, Recovery Timer Configuration*/
       Ifx_SMU_KEYS                        KEYS;                   /**< \brief 34, Key Register*/
       Ifx_SMU_DBG                         DBG;                    /**< \brief 38, Debug Register*/
       Ifx_SMU_PCTL                        PCTL;                   /**< \brief 3C, Port Control*/
       Ifx_SMU_AFCNT                       AFCNT;                  /**< \brief 40, Alarm and Fault Counter*/
       Ifx_UReg_8Bit                       reserved_44[28];        /**< \brief 44, \internal Reserved */
       Ifx_SMU_RTAC00                      RTAC00;                 /**< \brief 60, Recovery Timer 0 Alarm Configuration 0*/
       Ifx_SMU_RTAC01                      RTAC01;                 /**< \brief 64, Recovery Timer 0 Alarm Configuration 1*/
       Ifx_SMU_RTAC10                      RTAC10;                 /**< \brief 68, Recovery Timer 1 Alarm Configuration 0*/
       Ifx_SMU_RTAC11                      RTAC11;                 /**< \brief 6C, Recovery Timer 1 Alarm Configuration 1*/
       Ifx_SMU_AEX                         AEX;                    /**< \brief 70, Alarm Executed Status Register*/
       Ifx_SMU_AEXCLR                      AEXCLR;                 /**< \brief 74, Alarm Executed Status Clear Register*/
       Ifx_UReg_8Bit                       reserved_78[136];       /**< \brief 78, \internal Reserved */
       Ifx_SMU_AGCF                        AGCF[12][3];            /**< \brief 100, */
       Ifx_SMU_AGFSP                       AGFSP[12];              /**< \brief 190, SMU_core FSP Configuration Register*/
       Ifx_SMU_AG                          AG[12];                 /**< \brief 1C0, Alarm Status Register*/
       Ifx_UReg_8Bit                       reserved_1F0[16];       /**< \brief 1F0, \internal Reserved */
       Ifx_SMU_AD                          AD[12];                 /**< \brief 200, Alarm Debug Register*/
       Ifx_UReg_8Bit                       reserved_230[208];      /**< \brief 230, \internal Reserved */
       Ifx_SMU_RMCTL                       RMCTL;                  /**< \brief 300, Register Monitor Control*/
       Ifx_SMU_RMEF                        RMEF;                   /**< \brief 304, Register Monitor Error Flags*/
       Ifx_SMU_RMSTS                       RMSTS;                  /**< \brief 308, Register Monitor Self Test Status*/
       Ifx_UReg_8Bit                       reserved_30C[1244];     /**< \brief 30C, \internal Reserved */
       Ifx_SMU_OCS                         OCS;                    /**< \brief 7E8, OCDS Control and Status*/
       Ifx_UReg_8Bit                       reserved_7EC[12];       /**< \brief 7EC, \internal Reserved */
       Ifx_SMU_ACCEN1                      ACCEN1;                 /**< \brief 7F8, SMU_core Access Enable Register 1*/
       Ifx_SMU_ACCEN0                      ACCEN0;                 /**< \brief 7FC, SMU_core Access Enable Register 0*/
} Ifx_SMU;

/** \}  */
/******************************************************************************/
/** \}  */


/******************************************************************************/

/******************************************************************************/


#line 57 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\Infra\\Sfr\\TC38A\\_Reg\\IfxSmu_reg.h"
/******************************************************************************/

/******************************************************************************/

/******************************************************************************/

/** \addtogroup IfxSfr_Smu_Registers_Cfg_BaseAddress
 * \{  */

/** \brief SMU object */

/** \}  */


/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Smu_Registers_Cfg_Smu
 * \{  */
/** \brief 0, Clock Control Register */


/** \brief 8, Module Identification Register */


/** \brief 20, Command Register */


/** \brief 24, Status Register */


/** \brief 28, Fault Signaling Protocol */


/** \brief 2C, Alarm Global Configuration */


/** \brief 30, Recovery Timer Configuration */


/** \brief 34, Key Register */


/** \brief 38, Debug Register */


/** \brief 3C, Port Control */


/** \brief 40, Alarm and Fault Counter */


/** \brief 60, Recovery Timer 0 Alarm Configuration 0 */


/** \brief 64, Recovery Timer 0 Alarm Configuration 1 */


/** \brief 68, Recovery Timer 1 Alarm Configuration 0 */


/** \brief 6C, Recovery Timer 1 Alarm Configuration 1 */


/** \brief 70, Alarm Executed Status Register */


/** \brief 74, Alarm Executed Status Clear Register */


/** \brief 100, Alarm Configuration Register */

/** Alias (User Manual Name) for SMU_AGCF0_0.
* To use register names with standard convension, please use SMU_AGCF0_0.
*/


/** \brief 104, Alarm Configuration Register */

/** Alias (User Manual Name) for SMU_AGCF0_1.
* To use register names with standard convension, please use SMU_AGCF0_1.
*/


/** \brief 108, Alarm Configuration Register */

/** Alias (User Manual Name) for SMU_AGCF0_2.
* To use register names with standard convension, please use SMU_AGCF0_2.
*/


/** \brief 10C, Alarm Configuration Register */

/** Alias (User Manual Name) for SMU_AGCF1_0.
* To use register names with standard convension, please use SMU_AGCF1_0.
*/


/** \brief 110, Alarm Configuration Register */

/** Alias (User Manual Name) for SMU_AGCF1_1.
* To use register names with standard convension, please use SMU_AGCF1_1.
*/


/** \brief 114, Alarm Configuration Register */

/** Alias (User Manual Name) for SMU_AGCF1_2.
* To use register names with standard convension, please use SMU_AGCF1_2.
*/


/** \brief 118, Alarm Configuration Register */

/** Alias (User Manual Name) for SMU_AGCF2_0.
* To use register names with standard convension, please use SMU_AGCF2_0.
*/


/** \brief 11C, Alarm Configuration Register */

/** Alias (User Manual Name) for SMU_AGCF2_1.
* To use register names with standard convension, please use SMU_AGCF2_1.
*/


/** \brief 120, Alarm Configuration Register */

/** Alias (User Manual Name) for SMU_AGCF2_2.
* To use register names with standard convension, please use SMU_AGCF2_2.
*/


/** \brief 124, Alarm Configuration Register */

/** Alias (User Manual Name) for SMU_AGCF3_0.
* To use register names with standard convension, please use SMU_AGCF3_0.
*/


/** \brief 128, Alarm Configuration Register */

/** Alias (User Manual Name) for SMU_AGCF3_1.
* To use register names with standard convension, please use SMU_AGCF3_1.
*/


/** \brief 12C, Alarm Configuration Register */

/** Alias (User Manual Name) for SMU_AGCF3_2.
* To use register names with standard convension, please use SMU_AGCF3_2.
*/


/** \brief 130, Alarm Configuration Register */

/** Alias (User Manual Name) for SMU_AGCF4_0.
* To use register names with standard convension, please use SMU_AGCF4_0.
*/


/** \brief 134, Alarm Configuration Register */

/** Alias (User Manual Name) for SMU_AGCF4_1.
* To use register names with standard convension, please use SMU_AGCF4_1.
*/


/** \brief 138, Alarm Configuration Register */

/** Alias (User Manual Name) for SMU_AGCF4_2.
* To use register names with standard convension, please use SMU_AGCF4_2.
*/


/** \brief 13C, Alarm Configuration Register */

/** Alias (User Manual Name) for SMU_AGCF5_0.
* To use register names with standard convension, please use SMU_AGCF5_0.
*/


/** \brief 140, Alarm Configuration Register */

/** Alias (User Manual Name) for SMU_AGCF5_1.
* To use register names with standard convension, please use SMU_AGCF5_1.
*/


/** \brief 144, Alarm Configuration Register */

/** Alias (User Manual Name) for SMU_AGCF5_2.
* To use register names with standard convension, please use SMU_AGCF5_2.
*/


/** \brief 148, Alarm Configuration Register */

/** Alias (User Manual Name) for SMU_AGCF6_0.
* To use register names with standard convension, please use SMU_AGCF6_0.
*/


/** \brief 14C, Alarm Configuration Register */

/** Alias (User Manual Name) for SMU_AGCF6_1.
* To use register names with standard convension, please use SMU_AGCF6_1.
*/


/** \brief 150, Alarm Configuration Register */

/** Alias (User Manual Name) for SMU_AGCF6_2.
* To use register names with standard convension, please use SMU_AGCF6_2.
*/


/** \brief 154, Alarm Configuration Register */

/** Alias (User Manual Name) for SMU_AGCF7_0.
* To use register names with standard convension, please use SMU_AGCF7_0.
*/


/** \brief 158, Alarm Configuration Register */

/** Alias (User Manual Name) for SMU_AGCF7_1.
* To use register names with standard convension, please use SMU_AGCF7_1.
*/


/** \brief 15C, Alarm Configuration Register */

/** Alias (User Manual Name) for SMU_AGCF7_2.
* To use register names with standard convension, please use SMU_AGCF7_2.
*/


/** \brief 160, Alarm Configuration Register */

/** Alias (User Manual Name) for SMU_AGCF8_0.
* To use register names with standard convension, please use SMU_AGCF8_0.
*/


/** \brief 164, Alarm Configuration Register */

/** Alias (User Manual Name) for SMU_AGCF8_1.
* To use register names with standard convension, please use SMU_AGCF8_1.
*/


/** \brief 168, Alarm Configuration Register */

/** Alias (User Manual Name) for SMU_AGCF8_2.
* To use register names with standard convension, please use SMU_AGCF8_2.
*/


/** \brief 16C, Alarm Configuration Register */

/** Alias (User Manual Name) for SMU_AGCF9_0.
* To use register names with standard convension, please use SMU_AGCF9_0.
*/


/** \brief 170, Alarm Configuration Register */

/** Alias (User Manual Name) for SMU_AGCF9_1.
* To use register names with standard convension, please use SMU_AGCF9_1.
*/


/** \brief 174, Alarm Configuration Register */

/** Alias (User Manual Name) for SMU_AGCF9_2.
* To use register names with standard convension, please use SMU_AGCF9_2.
*/


/** \brief 178, Alarm Configuration Register */

/** Alias (User Manual Name) for SMU_AGCF10_0.
* To use register names with standard convension, please use SMU_AGCF10_0.
*/


/** \brief 17C, Alarm Configuration Register */

/** Alias (User Manual Name) for SMU_AGCF10_1.
* To use register names with standard convension, please use SMU_AGCF10_1.
*/


/** \brief 180, Alarm Configuration Register */

/** Alias (User Manual Name) for SMU_AGCF10_2.
* To use register names with standard convension, please use SMU_AGCF10_2.
*/


/** \brief 184, Alarm Configuration Register */

/** Alias (User Manual Name) for SMU_AGCF11_0.
* To use register names with standard convension, please use SMU_AGCF11_0.
*/


/** \brief 188, Alarm Configuration Register */

/** Alias (User Manual Name) for SMU_AGCF11_1.
* To use register names with standard convension, please use SMU_AGCF11_1.
*/


/** \brief 18C, Alarm Configuration Register */

/** Alias (User Manual Name) for SMU_AGCF11_2.
* To use register names with standard convension, please use SMU_AGCF11_2.
*/


/** \brief 190, SMU_core FSP Configuration Register */

/** Alias (User Manual Name) for SMU_AGFSP0.
* To use register names with standard convension, please use SMU_AGFSP0.
*/


/** \brief 194, SMU_core FSP Configuration Register */

/** Alias (User Manual Name) for SMU_AGFSP1.
* To use register names with standard convension, please use SMU_AGFSP1.
*/


/** \brief 198, SMU_core FSP Configuration Register */

/** Alias (User Manual Name) for SMU_AGFSP2.
* To use register names with standard convension, please use SMU_AGFSP2.
*/


/** \brief 19C, SMU_core FSP Configuration Register */

/** Alias (User Manual Name) for SMU_AGFSP3.
* To use register names with standard convension, please use SMU_AGFSP3.
*/


/** \brief 1A0, SMU_core FSP Configuration Register */

/** Alias (User Manual Name) for SMU_AGFSP4.
* To use register names with standard convension, please use SMU_AGFSP4.
*/


/** \brief 1A4, SMU_core FSP Configuration Register */

/** Alias (User Manual Name) for SMU_AGFSP5.
* To use register names with standard convension, please use SMU_AGFSP5.
*/


/** \brief 1A8, SMU_core FSP Configuration Register */

/** Alias (User Manual Name) for SMU_AGFSP6.
* To use register names with standard convension, please use SMU_AGFSP6.
*/


/** \brief 1AC, SMU_core FSP Configuration Register */

/** Alias (User Manual Name) for SMU_AGFSP7.
* To use register names with standard convension, please use SMU_AGFSP7.
*/


/** \brief 1B0, SMU_core FSP Configuration Register */

/** Alias (User Manual Name) for SMU_AGFSP8.
* To use register names with standard convension, please use SMU_AGFSP8.
*/


/** \brief 1B4, SMU_core FSP Configuration Register */

/** Alias (User Manual Name) for SMU_AGFSP9.
* To use register names with standard convension, please use SMU_AGFSP9.
*/


/** \brief 1B8, SMU_core FSP Configuration Register */

/** Alias (User Manual Name) for SMU_AGFSP10.
* To use register names with standard convension, please use SMU_AGFSP10.
*/


/** \brief 1BC, SMU_core FSP Configuration Register */

/** Alias (User Manual Name) for SMU_AGFSP11.
* To use register names with standard convension, please use SMU_AGFSP11.
*/


/** \brief 1C0, Alarm Status Register */


/** \brief 1C4, Alarm Status Register */


/** \brief 1C8, Alarm Status Register */


/** \brief 1CC, Alarm Status Register */


/** \brief 1D0, Alarm Status Register */


/** \brief 1D4, Alarm Status Register */


/** \brief 1D8, Alarm Status Register */


/** \brief 1DC, Alarm Status Register */


/** \brief 1E0, Alarm Status Register */


/** \brief 1E4, Alarm Status Register */


/** \brief 1E8, Alarm Status Register */


/** \brief 1EC, Alarm Status Register */


/** \brief 200, Alarm Debug Register */


/** \brief 204, Alarm Debug Register */


/** \brief 208, Alarm Debug Register */


/** \brief 20C, Alarm Debug Register */


/** \brief 210, Alarm Debug Register */


/** \brief 214, Alarm Debug Register */


/** \brief 218, Alarm Debug Register */


/** \brief 21C, Alarm Debug Register */


/** \brief 220, Alarm Debug Register */


/** \brief 224, Alarm Debug Register */


/** \brief 228, Alarm Debug Register */


/** \brief 22C, Alarm Debug Register */


/** \brief 300, Register Monitor Control */


/** \brief 304, Register Monitor Error Flags */


/** \brief 308, Register Monitor Self Test Status */


/** \brief 7E8, OCDS Control and Status */


/** \brief 7F8, SMU_core Access Enable Register 1 */


/** \brief 7FC, SMU_core Access Enable Register 0 */



/** \}  */

/******************************************************************************/

/******************************************************************************/


#line 200 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Scu\\Std\\IfxScuCcu.h"

/******************************************************************************/
/*-----------------------------------Macros-----------------------------------*/
/******************************************************************************/

/** \brief Oscillator stability check timeout count
 */




/** \brief
 */


/** \brief ~40uS max wait time
 */




/** \brief ~122uS max wait time for PLL locking
 */


/** \brief ~122uS max wait time for PLL power down/up state update
 */


/** \brief ~244uS max wait time
 */


/** \brief 3mS max wait time for PLL power down/up state update
 */














/** \brief Modulation frequency
 */


/** \brief MODCFG shift value for SYSPLLCON2
 */


/** \brief MODCFG default value - for SYSPLLCON2[15:10]
 */


/** \brief get Rgain from MA and FDco
 */


/** \brief Get RGAin HEX from RGain Nominal value
 */


/** \brief Get MODCFG from RGAIN_HEX
 */


/** \brief Define to include the flash wait state check in ScuCcu_init()
 */


/** \brief 10 microsecond wait time between steps to jump back to normal mode.
 */




/******************************************************************************/
/*------------------------------Type Definitions------------------------------*/
/******************************************************************************/

/** \brief Function pointer type for the hooks
 * \return None
 */
typedef void (*IfxScuCcu_PllStepsFunctionHook)(void);

/******************************************************************************/
/*--------------------------------Enumerations--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Scu_Std_Ccu_Enum
 * \{ */
/** \brief clock source selection
 */
typedef enum
{
    IfxScuCcu_Fsource_0 = 0,      /**< \brief fSource0  */
    IfxScuCcu_Fsource_1,          /**< \brief fSource1  */
    IfxScuCcu_Fsource_2           /**< \brief fSource2  */
} IfxScuCcu_Fsource;

/** \brief MODULE_SCU.PLLCON1.B.K2DIV, specifies the K2-Divider
 */
typedef enum
{
    IfxScuCcu_K2divider_1 = 0,      /**< \brief K2-Divider 1  */
    IfxScuCcu_K2divider_2,          /**< \brief K2-Divider 2  */
    IfxScuCcu_K2divider_3,          /**< \brief K2-Divider 3  */
    IfxScuCcu_K2divider_4,          /**< \brief K2-Divider 4  */
    IfxScuCcu_K2divider_5,          /**< \brief K2-Divider 5  */
    IfxScuCcu_K2divider_6,          /**< \brief K2-Divider 6  */
    IfxScuCcu_K2divider_7,          /**< \brief K2-Divider 7  */
    IfxScuCcu_K2divider_8           /**< \brief K2-Divider 8  */
} IfxScuCcu_K2divider;

/** \brief MODULE_SCU.PLLCON1.B.K3DIV, specifies the K3-Divider
 */
typedef enum
{
    IfxScuCcu_K3divider_1 = 0,      /**< \brief K3-Divider 1  */
    IfxScuCcu_K3divider_2,          /**< \brief K3-Divider 2  */
    IfxScuCcu_K3divider_3,          /**< \brief K3-Divider 3  */
    IfxScuCcu_K3divider_4,          /**< \brief K3-Divider 4  */
    IfxScuCcu_K3divider_5,          /**< \brief K3-Divider 5  */
    IfxScuCcu_K3divider_6,          /**< \brief K3-Divider 6  */
    IfxScuCcu_K3divider_7,          /**< \brief K3-Divider 7  */
    IfxScuCcu_K3divider_8           /**< \brief K3-Divider 8  */
} IfxScuCcu_K3divider;

/** \brief Low Power Division Ratios.
 * Corresponds to values of LPDIV in CCUCON0.
 */
typedef enum
{
    IfxScuCcu_LowPowerDivRatio_divBy30 = 1,  /**< \brief Divide by 30 */
    IfxScuCcu_LowPowerDivRatio_divBy60,      /**< \brief Divide by 60 */
    IfxScuCcu_LowPowerDivRatio_divBy120,     /**< \brief Divide by 120 */
    IfxScuCcu_LowPowerDivRatio_divBy240      /**< \brief Divide by 240 */
} IfxScuCcu_LowPowerDivRatio;

/** \brief ENUM for MA (%) values
 */
typedef enum
{
    IfxScuCcu_ModulationAmplitude_0p5 = 0,      /**< \brief 0.5%  */
    IfxScuCcu_ModulationAmplitude_1p0,          /**< \brief 1.0%  */
    IfxScuCcu_ModulationAmplitude_1p25,         /**< \brief 1.25%  */
    IfxScuCcu_ModulationAmplitude_1p5,          /**< \brief 1.5%  */
    IfxScuCcu_ModulationAmplitude_2p0,          /**< \brief 2%  */
    IfxScuCcu_ModulationAmplitude_2p5,          /**< \brief 2.5%  */
    IfxScuCcu_ModulationAmplitude_count,        /**< \brief range  */
} IfxScuCcu_ModulationAmplitude;

/** \brief MODULE_SCU.PLLCON0.B.NDIV, specifies the N-Divider
 */
typedef enum
{
    IfxScuCcu_Ndivider_1 = 0,      /**< \brief  N-divider 1  */
    IfxScuCcu_Ndivider_2,          /**< \brief  N-divider 2  */
    IfxScuCcu_Ndivider_3,          /**< \brief  N-divider 3  */
    IfxScuCcu_Ndivider_4,          /**< \brief  N-divider 4  */
    IfxScuCcu_Ndivider_5,          /**< \brief  N-divider 5  */
    IfxScuCcu_Ndivider_6,          /**< \brief  N-divider 6  */
    IfxScuCcu_Ndivider_7,          /**< \brief  N-divider 7  */
    IfxScuCcu_Ndivider_8,          /**< \brief  N-divider 8  */
    IfxScuCcu_Ndivider_9,          /**< \brief  N-divider 9  */
    IfxScuCcu_Ndivider_10,         /**< \brief  N-divider 10  */
    IfxScuCcu_Ndivider_11,         /**< \brief  N-divider 11  */
    IfxScuCcu_Ndivider_12,         /**< \brief  N-divider 12  */
    IfxScuCcu_Ndivider_13,         /**< \brief  N-divider 13  */
    IfxScuCcu_Ndivider_14,         /**< \brief  N-divider 14  */
    IfxScuCcu_Ndivider_15,         /**< \brief  N-divider 15  */
    IfxScuCcu_Ndivider_16,         /**< \brief  N-divider 16  */
    IfxScuCcu_Ndivider_17,         /**< \brief  N-divider 17  */
    IfxScuCcu_Ndivider_18,         /**< \brief  N-divider 18  */
    IfxScuCcu_Ndivider_19,         /**< \brief  N-divider 19  */
    IfxScuCcu_Ndivider_20,         /**< \brief  N-divider 20  */
    IfxScuCcu_Ndivider_21,         /**< \brief  N-divider 21  */
    IfxScuCcu_Ndivider_22,         /**< \brief  N-divider 22  */
    IfxScuCcu_Ndivider_23,         /**< \brief  N-divider 23  */
    IfxScuCcu_Ndivider_24,         /**< \brief  N-divider 24  */
    IfxScuCcu_Ndivider_25,         /**< \brief  N-divider 25  */
    IfxScuCcu_Ndivider_26,         /**< \brief  N-divider 26  */
    IfxScuCcu_Ndivider_27,         /**< \brief  N-divider 27  */
    IfxScuCcu_Ndivider_28,         /**< \brief  N-divider 28  */
    IfxScuCcu_Ndivider_29,         /**< \brief  N-divider 29  */
    IfxScuCcu_Ndivider_30,         /**< \brief  N-divider 30  */
    IfxScuCcu_Ndivider_31,         /**< \brief  N-divider 31  */
    IfxScuCcu_Ndivider_32,         /**< \brief  N-divider 32  */
    IfxScuCcu_Ndivider_33,         /**< \brief  N-divider 33  */
    IfxScuCcu_Ndivider_34,         /**< \brief  N-divider 34  */
    IfxScuCcu_Ndivider_35,         /**< \brief  N-divider 35  */
    IfxScuCcu_Ndivider_36,         /**< \brief  N-divider 36  */
    IfxScuCcu_Ndivider_37,         /**< \brief  N-divider 37  */
    IfxScuCcu_Ndivider_38,         /**< \brief  N-divider 38  */
    IfxScuCcu_Ndivider_39,         /**< \brief  N-divider 39  */
    IfxScuCcu_Ndivider_40,         /**< \brief  N-divider 40  */
    IfxScuCcu_Ndivider_41,         /**< \brief  N-divider 41  */
    IfxScuCcu_Ndivider_42,         /**< \brief  N-divider 42  */
    IfxScuCcu_Ndivider_43,         /**< \brief  N-divider 43  */
    IfxScuCcu_Ndivider_44,         /**< \brief  N-divider 44  */
    IfxScuCcu_Ndivider_45,         /**< \brief  N-divider 45  */
    IfxScuCcu_Ndivider_46,         /**< \brief  N-divider 46  */
    IfxScuCcu_Ndivider_47,         /**< \brief  N-divider 47  */
    IfxScuCcu_Ndivider_48,         /**< \brief  N-divider 48  */
    IfxScuCcu_Ndivider_49,         /**< \brief  N-divider 49  */
    IfxScuCcu_Ndivider_50,         /**< \brief  N-divider 50  */
    IfxScuCcu_Ndivider_51,         /**< \brief  N-divider 51  */
    IfxScuCcu_Ndivider_52,         /**< \brief  N-divider 52  */
    IfxScuCcu_Ndivider_53,         /**< \brief  N-divider 53  */
    IfxScuCcu_Ndivider_54,         /**< \brief  N-divider 54  */
    IfxScuCcu_Ndivider_55,         /**< \brief  N-divider 55  */
    IfxScuCcu_Ndivider_56,         /**< \brief  N-divider 56  */
    IfxScuCcu_Ndivider_57,         /**< \brief  N-divider 57  */
    IfxScuCcu_Ndivider_58,         /**< \brief  N-divider 58  */
    IfxScuCcu_Ndivider_59,         /**< \brief  N-divider 59  */
    IfxScuCcu_Ndivider_60,         /**< \brief  N-divider 60  */
    IfxScuCcu_Ndivider_61,         /**< \brief  N-divider 61  */
    IfxScuCcu_Ndivider_62,         /**< \brief  N-divider 62  */
    IfxScuCcu_Ndivider_63,         /**< \brief  N-divider 63  */
    IfxScuCcu_Ndivider_64,         /**< \brief  N-divider 64  */
    IfxScuCcu_Ndivider_65,         /**< \brief  N-divider 65  */
    IfxScuCcu_Ndivider_66,         /**< \brief  N-divider 66  */
    IfxScuCcu_Ndivider_67,         /**< \brief  N-divider 67  */
    IfxScuCcu_Ndivider_68,         /**< \brief  N-divider 68  */
    IfxScuCcu_Ndivider_69,         /**< \brief  N-divider 69  */
    IfxScuCcu_Ndivider_70,         /**< \brief  N-divider 70  */
    IfxScuCcu_Ndivider_71,         /**< \brief  N-divider 71  */
    IfxScuCcu_Ndivider_72,         /**< \brief  N-divider 72  */
    IfxScuCcu_Ndivider_73,         /**< \brief  N-divider 73  */
    IfxScuCcu_Ndivider_74,         /**< \brief  N-divider 74  */
    IfxScuCcu_Ndivider_75,         /**< \brief  N-divider 75  */
    IfxScuCcu_Ndivider_76,         /**< \brief  N-divider 76  */
    IfxScuCcu_Ndivider_77,         /**< \brief  N-divider 77  */
    IfxScuCcu_Ndivider_78,         /**< \brief  N-divider 78  */
    IfxScuCcu_Ndivider_79,         /**< \brief  N-divider 79  */
    IfxScuCcu_Ndivider_80,         /**< \brief  N-divider 80  */
    IfxScuCcu_Ndivider_81,         /**< \brief  N-divider 81  */
    IfxScuCcu_Ndivider_82,         /**< \brief  N-divider 82  */
    IfxScuCcu_Ndivider_83,         /**< \brief  N-divider 83  */
    IfxScuCcu_Ndivider_84,         /**< \brief  N-divider 84  */
    IfxScuCcu_Ndivider_85,         /**< \brief  N-divider 85  */
    IfxScuCcu_Ndivider_86,         /**< \brief  N-divider 86  */
    IfxScuCcu_Ndivider_87,         /**< \brief  N-divider 87  */
    IfxScuCcu_Ndivider_88,         /**< \brief  N-divider 88  */
    IfxScuCcu_Ndivider_89,         /**< \brief  N-divider 89  */
    IfxScuCcu_Ndivider_90,         /**< \brief  N-divider 90  */
    IfxScuCcu_Ndivider_91,         /**< \brief  N-divider 91  */
    IfxScuCcu_Ndivider_92,         /**< \brief  N-divider 92  */
    IfxScuCcu_Ndivider_93,         /**< \brief  N-divider 93  */
    IfxScuCcu_Ndivider_94,         /**< \brief  N-divider 94  */
    IfxScuCcu_Ndivider_95,         /**< \brief  N-divider 95  */
    IfxScuCcu_Ndivider_96,         /**< \brief  N-divider 96  */
    IfxScuCcu_Ndivider_97,         /**< \brief  N-divider 97  */
    IfxScuCcu_Ndivider_98,         /**< \brief  N-divider 98  */
    IfxScuCcu_Ndivider_99,         /**< \brief  N-divider 99  */
    IfxScuCcu_Ndivider_100,        /**< \brief  N-divider 100  */
    IfxScuCcu_Ndivider_101,        /**< \brief  N-divider 101  */
    IfxScuCcu_Ndivider_102,        /**< \brief  N-divider 102  */
    IfxScuCcu_Ndivider_103,        /**< \brief  N-divider 103  */
    IfxScuCcu_Ndivider_104,        /**< \brief  N-divider 104  */
    IfxScuCcu_Ndivider_105,        /**< \brief  N-divider 105  */
    IfxScuCcu_Ndivider_106,        /**< \brief  N-divider 106  */
    IfxScuCcu_Ndivider_107,        /**< \brief  N-divider 107  */
    IfxScuCcu_Ndivider_108,        /**< \brief  N-divider 108  */
    IfxScuCcu_Ndivider_109,        /**< \brief  N-divider 109  */
    IfxScuCcu_Ndivider_110,        /**< \brief  N-divider 110  */
    IfxScuCcu_Ndivider_111,        /**< \brief  N-divider 111  */
    IfxScuCcu_Ndivider_112,        /**< \brief  N-divider 112  */
    IfxScuCcu_Ndivider_113,        /**< \brief  N-divider 113  */
    IfxScuCcu_Ndivider_114,        /**< \brief  N-divider 114  */
    IfxScuCcu_Ndivider_115,        /**< \brief  N-divider 115  */
    IfxScuCcu_Ndivider_116,        /**< \brief  N-divider 116  */
    IfxScuCcu_Ndivider_117,        /**< \brief  N-divider 117  */
    IfxScuCcu_Ndivider_118,        /**< \brief  N-divider 118  */
    IfxScuCcu_Ndivider_119,        /**< \brief  N-divider 119  */
    IfxScuCcu_Ndivider_120,        /**< \brief  N-divider 120  */
    IfxScuCcu_Ndivider_121,        /**< \brief  N-divider 121  */
    IfxScuCcu_Ndivider_122,        /**< \brief  N-divider 122  */
    IfxScuCcu_Ndivider_123,        /**< \brief  N-divider 123  */
    IfxScuCcu_Ndivider_124,        /**< \brief  N-divider 124  */
    IfxScuCcu_Ndivider_125,        /**< \brief  N-divider 125  */
    IfxScuCcu_Ndivider_126,        /**< \brief  N-divider 126  */
    IfxScuCcu_Ndivider_127,        /**< \brief  N-divider 127  */
    IfxScuCcu_Ndivider_128         /**< \brief  N-divider 128  */
} IfxScuCcu_Ndivider;

/** \brief MODULE_SCU.PLLCON0.B.PDIV, specifies the P-Divider
 */
typedef enum
{
    IfxScuCcu_Pdivider_1 = 0,      /**< \brief  P-divider 1  */
    IfxScuCcu_Pdivider_2,          /**< \brief  P-divider 2  */
    IfxScuCcu_Pdivider_3,          /**< \brief  P-divider 3  */
    IfxScuCcu_Pdivider_4,          /**< \brief  P-divider 4  */
    IfxScuCcu_Pdivider_5,          /**< \brief  P-divider 5  */
    IfxScuCcu_Pdivider_6,          /**< \brief  P-divider 6  */
    IfxScuCcu_Pdivider_7,          /**< \brief  P-divider 7  */
    IfxScuCcu_Pdivider_8           /**< \brief  P-divider 8  */
} IfxScuCcu_Pdivider;

/** \brief SysPll & Per Pll input clock selection.
 * SYSPLLCON0.B.INSEL
 */
typedef enum
{
    IfxScuCcu_PllInputClockSelection_fOsc1   = 0, /**< \brief Backup clock select */
    IfxScuCcu_PllInputClockSelection_fOsc0   = 1, /**< \brief fOsc0 or XTAL clock select */
    IfxScuCcu_PllInputClockSelection_fSysclk = 2  /**< \brief fOsc1 */
} IfxScuCcu_PllInputClockSelection;

/** \brief trap request type
 */
typedef enum
{
    IfxScuCcu_Traprequest_esr0 = 0,  /**< \brief external service request 0 */
    IfxScuCcu_Traprequest_esr1,      /**< \brief external service request 1 */
    IfxScuCcu_Traprequest_trap2,     /**< \brief trap2 */
    IfxScuCcu_Traprequest_smu        /**< \brief safety management unit */
} IfxScuCcu_Traprequest;

/** \} */

/** \brief modulation enable
 */
typedef enum
{
    IfxScuCcu_ModEn_disabled = 0,  /**< \brief disable modulation */
    IfxScuCcu_ModEn_enabled  = 1   /**< \brief enable modulation */
} IfxScuCcu_ModEn;

/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Scu_Std_Ccu_Ccu_Configuration
 * \{ */
/** \brief Configuration structure type for the Per Pll step.
 * This structure must be used to configure the P, N and K2, K3 dividers .
 */
typedef struct
{
    uint8 pDivider;              /**< \brief P divider value for basic (initial) step */
    uint8 nDivider;              /**< \brief N divider value for basic (initial) step */
    uint8 k2Divider;             /**< \brief K2 divider value */
    uint8 k3Divider;             /**< \brief K3 divider value */
    uint8 k3DividerBypass;       /**< \brief Divider Bypass
                                  * 0 - The divide by block in front of the K3-Divider is not bypassed.
                                  * 1-  The divide by block in front of the K3-Divider is bypassed. */
} IfxScuCcu_PerPllConfig;

/** \brief Configuration structure type for the Pll initial step.
 * This structure must be used to configure the P, N and K2 dividers for initial step.
 */
typedef struct
{
    uint8 pDivider;        /**< \brief P divider value */
    uint8 nDivider;        /**< \brief N divider value */
    uint8 k2Divider;       /**< \brief K2 divider value */
} IfxScuCcu_SysPllConfig;

/** \} */

/** \addtogroup IfxLld_Scu_Std_Ccu_Ccu_Configuration
 * \{ */
/** \brief Configuration structure type for CCUCON registers.
 */
typedef struct
{
    uint32 value;       /**< \brief CCUCON Register value to be updated. */
    uint32 mask;        /**< \brief CCUCON Mask to select the bit fields to be updated. */
} IfxScuCcu_CcuconRegConfig;

/** \brief Configuration structure type for the Pll Steps for current jump control.
 */
typedef struct
{
    uint8   k2Step;         /**< \brief K2 divider value for this step. */
    float32 waitTime;       /**< \brief Wait time for for this step. */
} IfxScuCcu_PllStepConfig;

/** \brief Configuration structure type for the Pll Parameters.
 */
typedef struct
{
    uint32                           xtalFrequency;                /**< \brief Xtal frequency */
    IfxScuCcu_PllInputClockSelection pllInputClockSelection;       /**< \brief Pll input clock selection */
    IfxScuCcu_SysPllConfig           sysPllConfig;                 /**< \brief System PLL Configurations */
    IfxScuCcu_PerPllConfig           perPllConfig;                 /**< \brief Peripheral PLL Configurations */
} IfxScuCcu_pllsParameterConfig;

/** \} */

/** \addtogroup IfxLld_Scu_Std_Ccu_Ccu
 * \{ */
/** \brief Configuration structure type for the Flash waitstate configuration.
 */
typedef struct
{
    uint32 value;       /**< \brief FLASH.FCON Register value to be updated. */
    uint32 mask;        /**< \brief FLASH.FCON Mask to select the bit fields to be updated. */
} IfxScuCcu_FlashWaitstateConfig;

/** \} */

/** \addtogroup IfxLld_Scu_Std_Ccu_Ccu_Configuration
 * \{ */
/** \brief Configuration structure type for all the CCUCON registers to configure clock distribution.
 */
typedef struct
{
    IfxScuCcu_CcuconRegConfig ccucon0;       /**< \brief CCUCON0 Register configuration */
    IfxScuCcu_CcuconRegConfig ccucon1;       /**< \brief CCUCON1 Register configuration */
    IfxScuCcu_CcuconRegConfig ccucon2;       /**< \brief CCUCON2 Register configuration */
    IfxScuCcu_CcuconRegConfig ccucon5;       /**< \brief CCUCON5 Register configuration */
    IfxScuCcu_CcuconRegConfig ccucon6;       /**< \brief CCUCON6 Register configuration */
    IfxScuCcu_CcuconRegConfig ccucon7;       /**< \brief CCUCON7 Register configuration */
    IfxScuCcu_CcuconRegConfig ccucon8;       /**< \brief CCUCON8 Register configuration */
    IfxScuCcu_CcuconRegConfig ccucon9;       /**< \brief CCUCON9 Register configuration */
} IfxScuCcu_ClockDistributionConfig;

/** \brief Configuration structure type for the Pll Initial Step Configuration.
 */
typedef struct
{
    IfxScuCcu_pllsParameterConfig pllsParameters;       /**< \brief Configuration Parameters for both PLLs */
    float32                       waitTime;             /**< \brief Wait time for for basic (initial) step */
} IfxScuCcu_InitialStepConfig;

/** \brief
 */
typedef struct
{
    uint8                              numOfSteps;       /**< \brief Number of PLL divider steps during clock throttling */
    const IfxScuCcu_PllStepConfig *pllSteps;         /**< \brief Pointer to the array of Pll divider step configuration. */
} IfxScuCcu_PllThrottleConfig;

/** \} */

/** \brief modulation config
 */
typedef struct
{
    IfxScuCcu_ModEn               Mod_Enable;       /**< \brief modulation enable */
    IfxScuCcu_ModulationAmplitude Mod_Amp;          /**< \brief modulation amplitude */
} IfxScuCcu_Mod_Config;

/** \addtogroup IfxLld_Scu_Std_Ccu_Ccu_Configuration
 * \{ */
/** \brief Configuration structure SCU module
 */
typedef struct
{
    IfxScuCcu_InitialStepConfig               pllInitialStepConfig;           /**< \brief Configuration of first step which is same as internal osc frequency. */
    IfxScuCcu_PllThrottleConfig               sysPllThrottleConfig;           /**< \brief Configuration of PLL throttling. */
    IfxScuCcu_ClockDistributionConfig         clockDistribution;              /**< \brief Configuration of of bus clocks and other module clock distribution. */
    const IfxScuCcu_FlashWaitstateConfig *flashFconWaitStateConfig;       /**< \brief Configuration of flash waitstate */
    const IfxScuCcu_Mod_Config           *modulationConfig;               /**< \brief modulation configuration */
} IfxScuCcu_Config;

/** \} */

/** \brief structure holding the RGain parameters for modulation
 */
typedef struct
{
    float32 RGainNom;       /**< \brief RGain Nominal value */
    uint16  RGainHex;       /**< \brief RGain Hex value */
} IfxScuCcu_RGain_Values;

/** \addtogroup IfxLld_Scu_Std_Ccu_Ccu
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief API to wait for requested duration.
 * Note: IfxScuCcu_wait shall not use STM in future, because we can guarantee that STM is enabled after reset but  If PLL init is called for changing the frequency during runtime, there is no guarantee that STM is enabled
 * \return None
 */
static inline void IfxScuCcu_wait(float32 timeSec);

/** \brief API to wait for requested duration along with watchdog service to avoid any reset case during startup of the chip.
 * Note: IfxScuCcu_wait shall not use STM in future, because we can guarantee that STM is enabled after reset but  If PLL init is called for changing the frequency during runtime, there is no guarantee that STM is enabled
 * \return None
 */
static inline void IfxScuCcu_waitWithWdtService(float32 timeSec);

/** \brief API to configure the LPDIV value to enter into Low Power mode.
 *
 * Caution:
 * write to LPDIV with non-zero division ratio will cause system to enter low power mode.
 * Low power mode will affect different SPBDIV and SRIDIV ratios.
 *
 * The original CCUCON0 ratios should be preserved by user prior to calling this function.
 * The "normal" CCUCON0 ratios have to be passed to API: "IfxScuCcu_switchToNormalMode" to go back to the original division ratios.
 * \param lpDiv Low Power Division Ratio
 * \return None
 */
static inline void IfxScuCcu_switchToLowPowerMode(IfxScuCcu_LowPowerDivRatio lpDiv);

/** \brief API to switch back to normal mode from low power mode.
 *
 * Caution:
 * The original CCUCON0 setting has to be saved by user prior to entering Low Power mode.
 * Pass the original CCUCON0 register as a whole word to this function to restore the normal settings.
 *
 * Ramp back to normal mode is done in steps to avoid sudden jump in frequency and power usage.
 * \param ccucon0 CCUCON0 values at normal mode
 * \return None
 *
 * Switch to low power mode and back using iLLD functions as below
 * \code
 *     uint32 ccucon0 = SCU_CCUCON0.U;
 *     IfxScuCcu_LowPowerDivRatio lpDiv = IfxScuCcu_LowPowerDivRatio_divBy30;
 *     IfxScuCcu_switchToLowPowerMode(lpDiv);
 * \endcode
 *
 * Switch back to normal mode  with the saved ccucon0 value
 * \code
 *     IfxScuCcu_switchToNormalMode(ccucon0);
 * \endcode
 *
 */
static inline void IfxScuCcu_switchToNormalMode(const uint32 ccucon0);

/** \} */

/** \addtogroup IfxLld_Scu_Std_Ccu_Ccu_Operative
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief API to get Adc (EVADC, EDSADC)  frequency.
 * This API returns the based on the divider value in CCUCON register and fSOURCE.
 * \return Adc frequency (fADC) in Hz
 */
static inline float32 IfxScuCcu_getAdcFrequency(void);

/** \brief API to get ASCLINF divider frequency.
 * This API returns the based on the divider value in CCUCON register and fSOURCE.
 * \return AsclinF frequency (fASCLINF) in Hz
 */
static inline float32 IfxScuCcu_getAsclinFFrequency(void);

/** \brief API to get EVR Oscillator frequency.
 * This API returns the constant which is specific to the ScuCcu of the controller.
 * \return EVR Oscillator frequency (fBACK or fEVR) in Hz.
 */
static inline float32 IfxScuCcu_getEvrFrequency(void);

/** \brief API to get GETH divider frequency.
 * This API returns the based on the divider value in CCUCON register and fSOURCE.
 * \return GETH frequency (fGETH) in Hz
 */
static inline float32 IfxScuCcu_getGethFrequency(void);

/** \brief API to get GTMdivider frequency
 * This API returns the based on the divider value in CCUCON register and fSOURCE.
 * return GTM frequency (fGTM) in Hz
 * \return Gtm Frequency
 */
static inline float32 IfxScuCcu_getGtmFrequency(void);

/** \brief API to get I2C frequency.
 * This API returns the based on the divider value in CCUCON register and fSOURCE.
 * \return I2C frequency (fI2C) in Hz
 */
static inline float32 IfxScuCcu_getI2cFrequency(void);

/** \brief API to get MCANH divider frequency.
 * This API returns the based on the divider value in CCUCON register and fSOURCE.
 * \return MCANH frequency (fMCANH) in Hz
 */
static inline float32 IfxScuCcu_getMcanhFrequency(void);

/** \brief API to get Oscillator 0 frequency.
 * This API returns the fOsc0 frequency based on the divider value in CCUCON register and the input oscillator.
 * \return Osc0 frequency (fOSC0) in Hz.
 */
static inline float32 IfxScuCcu_getOsc0Frequency(void);

/** \brief API to get Oscillator 0 frequency.
 * This API returns the fOsc0 frequency based on the divider value in CCUCON register and the input oscillator.
 * \return Osc frequency (fOSC) in Hz.
 */
static inline float32 IfxScuCcu_getOscFrequency(void);

/** \brief Returns the clock source selection
 * \return Clock source selection
 */
static inline IfxScuCcu_PllInputClockSelection IfxScuCcu_getSourceSelection(void);

/** \brief API to get STM divider frequency.
 * This API returns the based on the divider value in CCUCON register and fSOURCE.
 * \return STM frequency (fSTM) in Hz
 */
static inline float32 IfxScuCcu_getStmFrequency(void);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief API to get ASCLINS divider frequency.
 * This API returns the ASCLINS frequency  based on the divider value in CCUCON register and fSOURCE.
 * \return AsclinS frequency (fASCLINS) in Hz
 */
extern float32 IfxScuCcu_getAsclinSFrequency(void);

/** \brief API to get BBB divider frequency.
 * This API returns the BBBDivider frequency based on the divider value in CCUCON register and the input oscillator.
 * \return BBB frequency (fBBB) in Hz
 */
extern float32 IfxScuCcu_getBbbFrequency(void);

/** \brief This API returns the Cpu frequency based on the divider value in CCUCON register and fSource frequency
 * \param cpu CPU number for which effective fCPU is sought
 * \return Cpu[x] frequency in Hz, where x is cpu number passed as parameter
 */
extern float32 IfxScuCcu_getCpuFrequency(const IfxCpu_ResourceCpu cpu);

/** \brief API to get FSI2 divider frequency in Hz.
 * This API returns the fFSI2 frequency based on the divider value in CCUCON register and the input oscillator.
 * \return FSI2 frequency (fFSI2) in Hz.
 */
extern float32 IfxScuCcu_getFsi2Frequency(void);

/** \brief API to get FSI divider frequency in Hz.
 * This API returns the fFSI based on the divider value in CCUCON register and the input oscillator.
 * \return FSI frequency (fFSI) in Hz.
 */
extern float32 IfxScuCcu_getFsiFrequency(void);

/** \brief API to get MCAN divider frequency.
 * This API returns the based on the divider value in CCUCON register and fSOURCE.
 * \return Mcan frequency (fMCAN) in Hz
 */
extern float32 IfxScuCcu_getMcanFrequency(void);

/** \brief get source frequency fSOURCE.
 * This API returns the source frequency based on the configurations with CCUCON register configuration.
 * \return Module frequency in Hz
 */
extern float32 IfxScuCcu_getModuleFrequency(void);

/** \brief API to get MSC divider frequency.
 * This API returns the based on the divider value in CCUCON register and fSOURCE.
 * \return Msc frequency (fMSC) in Hz
 */
extern float32 IfxScuCcu_getMscFrequency(void);

/** \brief API to get actual PER PLL1  frequency
 * This API returns the PER PLL1 frequency based on the K2 divider value in PLLCON and the VCO frequency.
 * Fpll1= (Fosc*N)/(P*K2)
 * \return PER PLL1 (K2 Divider) frequency in Hz
 */
extern float32 IfxScuCcu_getPerPllFrequency1(void);

/** \brief API to get actual PER PLL2 (K3 Divider) frequency
 * This API returns the PER PLL2 frequency based on the K3 divider value in PLLCON and the VCO frequency.
 * Fpll2= (Fosc*N)/(P*K3*1.6)  // DIVBY = 0,
 * Fpll2= (Fosc*N)/(P*K3*2)  // DIVBY = 1
 * \return PER PLL2 (K3 Divider ) frequency in Hz
 */
extern float32 IfxScuCcu_getPerPllFrequency2(void);

/** \brief API to get actual Sys PLL output frequency.
 * This API returns the based on the divider values in CCUCON, PLLCON registers and the input oscillator.
 * \return System Pll (fSysPLL) frequency in Hz
 */
extern float32 IfxScuCcu_getPllFrequency(void);

/** \brief API to get Qspi divider frequency.
 * This API returns the based on the divider value in CCUCON register and fSOURCE.
 * \return Qspi frequency (fQspi) in Hz
 */
extern float32 IfxScuCcu_getQspiFrequency(void);

/** \brief get source frequency fSOURCE.
 * This API returns the source frequency based on the configurations with CCUCON register configuration.
 * \param fsource fsource selection
 * \return Effective fSOURCE in Hz
 */
extern float32 IfxScuCcu_getSourceFrequency(IfxScuCcu_Fsource fsource);

/** \brief API to get SPB divider frequency.
 * This API returns the based on fSOURCE and also on Low power divider mode and/or SPBDIV divider value in CCUCON registers.
 * \return SPB frequency (fSPB) in Hz
 */
extern float32 IfxScuCcu_getSpbFrequency(void);

/** \brief API to get SRI divider frequency.
 * This API returns the Sri frequency based on the divider values in CCUCON registers and fSOURCE.
 * \return Sri frequency (fSRI) in Hz
 */
extern float32 IfxScuCcu_getSriFrequency(void);

/** \brief API to set ASCLINF frequency (with ASCLINF divider)
 * This API configure ASCLINF divider values in CCUCON registers. The actual frequency always depends on the feasibility with the divider value
 * \param asclinFFreq AsclinF frequency (fASCLINF) in Hz
 * \return Actual AsclinF frequency (fASCLINF) in Hz
 */
extern float32 IfxScuCcu_setAsclinFFrequency(float32 asclinFFreq);

/** \brief API to set ASCLINS frequency (with ASCLINS divider)
 * This API configure ASCLINS divider values in CCUCON registers. The actual frequency always depends on the feasibility with the divider value
 * \param asclinSFreq Desired AscLinS frequency in Hz
 * \return Actual AsclinS frequency (fASCLINS) in Hz
 */
extern float32 IfxScuCcu_setAsclinSFrequency(float32 asclinSFreq);

/** \brief API to set BBB frequency (with Bbb divider)
 * This API configure Bbb divider values in CCUCON registers. The actual frequency always depends on the feasibility with the divider value
 * \param bbbFreq Bbb frequency (fBBB) in Hz
 * \return Actual Bbb frequency (fBBB) in Hz
 */
extern float32 IfxScuCcu_setBbbFrequency(float32 bbbFreq);

/** \brief API to set CPU frequency (with CPU divider)
 * This API configure CPU divider values in CCUCON registers. The actual frequency is always depends on the feasibility with the divider value
 * \param cpu CPU number for which fCPU to be configured
 * \param cpuFreq Desired CPU frequency in Hz
 * \return Actual CPU[x] frequency in Hz, where x is the cpu number passed as parameter
 */
extern float32 IfxScuCcu_setCpuFrequency(IfxCpu_ResourceCpu cpu, float32 cpuFreq);

/** \brief API to set FSI2 frequency (with FSI2 divider)
 * This API configure Fsi2 divider values in CCUCON registers. The actual frequency always depends on the feasibility with the divider value
 * \param fsi2Freq FSI2 frequency (fFSI) in Hz
 * \return Actual Fsi2 frequency (fFSI2) in Hz
 */
extern float32 IfxScuCcu_setFsi2Frequency(float32 fsi2Freq);

/** \brief API to set FSI frequency (with FSI divider)
 * This API configure Fsi divider values in CCUCON registers. The actual frequency always depends on the feasibility with the divider value
 * \param fsiFreq FSI frequency (fFSI) in Hz
 * \return Actual Fsi frequency (fFSI) in Hz
 */
extern float32 IfxScuCcu_setFsiFrequency(float32 fsiFreq);

/** \brief API to set GETH frequency (with GETH divider)
 * This API configure geth divider values in CCUCON registers. The actual frequency always depends on the feasibility with the divider value
 * \param gethFreq GETH frequency (fGETH) in Hz
 * \return Actual Geth frequency (fGETH) in Hz
 */
extern float32 IfxScuCcu_setGethFrequency(float32 gethFreq);

/** \brief API to set GTM frequency (with GTM divider)
 * This API configure GTM divider values in CCUCON registers. The actual frequency always depends on the feasibility with the divider value
 * \param gtmFreq Desired GTM frequency in Hz
 * \return Actual GTM frequency in HZ
 */
extern float32 IfxScuCcu_setGtmFrequency(float32 gtmFreq);

/** \brief API to set I2C frequency (with I2C divider)
 * This API configure adas divider values in CCUCON registers. The actual frequency always depends on the feasibility with the divider value
 * \param i2cFreq I2C frequency (fI2C) in Hz
 * \return Actual I2C frequency (fI2C) in Hz
 */
extern float32 IfxScuCcu_setI2cFrequency(float32 i2cFreq);

/** \brief API to set MCAN frequency (with MCAN divider)
 * This API configure MCAN divider values in CCUCON registers. The actual frequency always depends on the feasibility with the divider value
 * \param mcanFreq Desired MSC frequency in Hz
 * \return Actual Mcan frequency (fMCAN) in Hz
 */
extern float32 IfxScuCcu_setMcanFrequency(float32 mcanFreq);

/** \brief API to set MCANH frequency (with MCANH divider)
 * This API configure mcanh divider values in CCUCON registers. The actual frequency always depends on the feasibility with the divider value
 * \param mcanhFreq MCANH frequency (fMCANH) in Hz
 * \return Actual MCanh frequency (fMCANH) in Hz
 */
extern float32 IfxScuCcu_setMcanhFrequency(float32 mcanhFreq);

/** \brief API to set MSC frequency (with MSC divider)
 * This API configure MSC divider values in CCUCON registers. The actual frequency always depends on the feasibility with the divider value
 * \param mscFreq Desired MSC frequency in Hz
 * \return Actual Msc frequency (fMSC) in Hz
 */
extern float32 IfxScuCcu_setMscFrequency(float32 mscFreq);

/** \brief API to set QSPI frequency (with QSPI divider)
 * This API configure Qspi divider values in CCUCON registers. The actual frequency always depends on the feasibility with the divider value
 * \param qspiFreq Desired QSPI frequency in Hz
 * \return Actual Qspi frequency (fQspi) in Hz
 */
extern float32 IfxScuCcu_setQspiFrequency(float32 qspiFreq);

/** \brief API to set SPB frequency (with SPB divider)
 * This API configure SPB divider values in CCUCON registers. The actual frequency always depends on the feasibility with the divider value
 * \param spbFreq Desired SPB frequency in Hz
 * \return Actual SPB frequency in Hz
 */
extern float32 IfxScuCcu_setSpbFrequency(float32 spbFreq);

/** \brief API to set SRI frequency (with SRI divider)
 * This API configure Sri divider values in CCUCON registers. The actual frequency always depends on the feasibility with the divider value
 * \param sriFreq Sri frequency (fSRI) in Hz
 * \return Actual Sri frequency (fSRI) in Hz
 */
extern float32 IfxScuCcu_setSriFrequency(float32 sriFreq);

/** \brief API to set STM frequency (with STM divider)
 * This API configure Stm divider values in CCUCON registers. The actual frequency always depends on the feasibility with the divider value
 * \param stmFreq Stm frequency (fASCLINF) in Hz
 * \return Actual Stm frequency (fSTM) in Hz
 */
extern float32 IfxScuCcu_setStmFrequency(float32 stmFreq);

/** \} */

/** \addtogroup IfxLld_Scu_Std_Ccu_Ccu_Configuration
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief This inline function configures the Ccu SYS PLLs initial step and PER PLL.
 */
static inline boolean IfxScuCcu_configureCcuInitialStep(const IfxScuCcu_InitialStepConfig *pllInitStepCfg);

/** \brief Inlined API for clock distribution
 * For each CCUCON register update the configured value with the mask.
 * \param clockDistributionConfig pointer to clock distribution structure
 * \return TRUE: Operation successful, FALSE: Operation Failure
 */
static inline boolean IfxScuCcu_distributeClockInline(const IfxScuCcu_ClockDistributionConfig *clockDistributionConfig);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief API for clock distribution.
 * \return None
 */
extern void IfxScuCcu_distributeClock(IfxScuCcu_ClockDistributionConfig *clockDistributionConfig);

/** \brief API to initialize the SCU Clock Control Unit.
 * This API initialize the Sys PLL with ramp steps, BUS dividers and Per PLL for the configuration provided by the configuration structure.
 * FSyspll = (Fosc * Nsys)/(Psys * K2sys);
 * Fpll1= (Fosc * Nper)/(Pper * K2per);
 * Fpll2= (Fosc * Nper)/(Pper * K3per * 1.6); // if DIVBY = 0, else Fpll2= (Fosc * Nper)/(Pper * K3per * 2) // if DIVBY = 1
 *
 * Note: Following SMU alarms are disabled before the PLL configuration and Enabled at the end of PLL lock in the function.
 * PLL0,1,2 clock out of range frequency
 * PLL0,1 VCO loss of lock event
 * System PLL Oscillator Watchdog, input clock out of range
 * The application should store/restore these alarm configurations if required.
 * \param config Pointer to the configuration structure of the ScuCcu
 * \return Error status of the ScuCcu initialization process.
 * \retval TRUE: If an error occurred during initialization.
 * \retval FALSE: If initialization was successful.
 */
extern boolean IfxScuCcu_init(const IfxScuCcu_Config *config);

/** \brief Initializes the clock configuration with default values
 * \param cfg Pointer to the configuration structure of the ScuCcu
 * \return None
 */
extern void IfxScuCcu_initConfig(IfxScuCcu_Config *cfg);

/** \brief API to switch to Backup clock from the current PLL frequency.
 * \param cfg Pointer to the configuration structure of the ScuCcu
 * \return None
 */
extern void IfxScuCcu_switchToBackupClock(const IfxScuCcu_Config *cfg);

/** \} */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Clear the trap status flag.
 * \param request Trap request type.
 * \return None
 */
static inline void IfxScuCcu_clearTrapStatusFlag(IfxScuCcu_Traprequest request);

/** \brief Get trap disable flag.
 * \param cpuIndex Cpu index
 * \param request Trap request type.
 * \return Trap request can be generated or not.
 */
static inline boolean IfxScuCcu_getTrapDisableFlag(IfxCpu_ResourceCpu cpuIndex, IfxScuCcu_Traprequest request);

/** \brief Get the trap status.
 * \param request Trap request type.
 * \return Trap was requested or not.
 */
static inline boolean IfxScuCcu_getTrapStatusFlag(IfxScuCcu_Traprequest request);

/** \brief Set the trap disable flag
 * \param cpuIndex Cpu index.
 * \param request Trap request type.
 * \return None
 */
static inline void IfxScuCcu_setTrapDisableFlag(IfxCpu_ResourceCpu cpuIndex, IfxScuCcu_Traprequest request);

/** \brief Set the trap status flag.
 * \param request Trap request type.
 * \return None
 */
static inline void IfxScuCcu_setTrapStatusFlag(IfxScuCcu_Traprequest request);

/**
 */
static inline boolean IfxScuCcu_throttleSysPllClockInline(const IfxScuCcu_PllThrottleConfig *pllThrottleConfig);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/**
 * \param modamp modulation amplitude
 * \param RGain_P RGain values
 * \return None
 */
extern void IfxScuCcu_calRGainParameters(IfxScuCcu_ModulationAmplitude modamp, IfxScuCcu_RGain_Values *RGain_P);

/** \brief initialize modulation parameters
 * \param Mod_Cfg modulation configuration
 * \return None
 */
extern void IfxScuCcu_modulation_init(const IfxScuCcu_Mod_Config *Mod_Cfg);

/**
 * \return None
 */
extern void IfxScuCcu_throttleSysPllClock(IfxScuCcu_PllThrottleConfig *pllThrottleConfig);

/******************************************************************************/
/*-------------------Global Exported Variables/Constants----------------------*/
/******************************************************************************/

/** \brief maps to the IfxScuCcu_ModulationAmplitude enum
 */
extern const float32 IfxScuCcu_MA_percent[IfxScuCcu_ModulationAmplitude_count];

/** \brief Configuration structure for SCU CCU driver.
 * The values of this structure are defined as # defined macros in the implementation of Scu
 */
extern const IfxScuCcu_Config     IfxScuCcu_defaultClockConfig;

/** \brief default modulation config
 */
extern const IfxScuCcu_Mod_Config IfxScuCcu_defaultModConfig;

extern uint32                         IfxScuCcu_xtalFrequency;

/******************************************************************************/
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

static inline void IfxScuCcu_clearTrapStatusFlag(IfxScuCcu_Traprequest request)
{
    uint32 trapclear = 1;
    (*(volatile Ifx_SCU_TRAPCLR*)0xF003612Cu).U |= (trapclear << request);
}


static inline boolean IfxScuCcu_configureCcuInitialStep(const IfxScuCcu_InitialStepConfig *pllInitStepCfg)
{
    uint8                                initError = 0;
    uint16                               endinitSfty_pw;

    uint32                               timeoutCycleCount;
    const IfxScuCcu_pllsParameterConfig *pllsParamCfg;
    pllsParamCfg   = &pllInitStepCfg->pllsParameters;
    /*get the watch-dog passwords for usage with this function*/
    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPasswordInline();

    /* Reset Safety ENDINIT, SCU_CCUCON registers are protected*/
    IfxScuWdt_clearSafetyEndinitInline(endinitSfty_pw);

    timeoutCycleCount = (0x1000U);

    while ((*(volatile Ifx_SCU_CCUCON0*)0xF0036030u).B.LCK != 0U)
    {
        {                                                    if (((sint32)--timeoutCycleCount) <= 0)                       {                                                    initError = (uint8)1;                                 break;                                       }                                                else                                             {                                                }                                            };
    }

    {
        Ifx_SCU_CCUCON0 scuCcucon0;
        scuCcucon0.U        = (*(volatile Ifx_SCU_CCUCON0*)0xF0036030u).U;
        scuCcucon0.B.CLKSEL = 0; /*Select the EVR as fsource0/1/2 for the clock distribution */
        scuCcucon0.B.UP     = 1; /*Update the ccucon0 register */
        (*(volatile Ifx_SCU_CCUCON0*)0xF0036030u).U       = scuCcucon0.U;
    }

    timeoutCycleCount = (0x1000U);

    while ((*(volatile Ifx_SCU_CCUCON0*)0xF0036030u).B.LCK != 0U)
    {
        {                                                    if (((sint32)--timeoutCycleCount) <= 0)                       {                                                    initError = (uint8)1;                                 break;                                       }                                                else                                             {                                                }                                            };
    }

    /*Disable SMU Alarms */
    {
        (*(volatile Ifx_SMU_KEYS*)0xF0036834u).U    = (uint32)0xBCU;        /* Enable access to SMU registers */
        ((*(volatile Ifx_SMU_AGCF*)0xF0036960u)).U &= ~(0x1DU);
        ((*(volatile Ifx_SMU_AGCF*)0xF0036964u)).U &= ~(0x1DU);
        ((*(volatile Ifx_SMU_AGCF*)0xF0036968u)).U &= ~(0x1DU);
        (*(volatile Ifx_SMU_KEYS*)0xF0036834u).U    = (uint32)0U;
    }

    /* Power down the both the PLLs before configuring registers*/
    /* Both the PLLs are powered down to be sure for asynchronous PLL registers update cause no glitches */
    (*(volatile Ifx_SCU_SYSPLLCON0*)0xF0036018u).B.PLLPWD = 0;
    (*(volatile Ifx_SCU_PERPLLCON0*)0xF0036028u).B.PLLPWD = 0;

    timeoutCycleCount       = (0x3000U);

    while (((*(volatile Ifx_SCU_SYSPLLSTAT*)0xF0036014u).B.PWDSTAT == 0) || ((*(volatile Ifx_SCU_PERPLLSTAT*)0xF0036024u).B.PWDSTAT == 0))
    {
        {                                                    if (((sint32)--timeoutCycleCount) <= 0)                       {                                                    initError = (uint8)1;                                 break;                                       }                                                else                                             {                                                }                                            };
    }

    /* Now configure the oscillator, required oscillator mode is external crystal */

    if ((pllsParamCfg->pllInputClockSelection == IfxScuCcu_PllInputClockSelection_fOsc0) || (pllsParamCfg->pllInputClockSelection == IfxScuCcu_PllInputClockSelection_fSysclk))

    {
        Ifx_SCU_OSCCON scuOsccon;
        scuOsccon.U      = (*(volatile Ifx_SCU_OSCCON*)0xF0036010u).U;



        scuOsccon.B.MODE = 0U;


        scuOsccon.B.OSCVAL = (uint32)(pllsParamCfg->xtalFrequency / 1000000U) - 15; /*XTAL range 16MHz to 40MHz*/
        /*Note: Oscillator Watchdog Reset (OSCRES) is not required when the PLLs are powered down*/
        (*(volatile Ifx_SCU_OSCCON*)0xF0036010u).U       = scuOsccon.U;
    }

    /* Configure the initial steps for the system PLL*/
    {
        Ifx_SCU_SYSPLLCON0 sysPllCon0;
        sysPllCon0.U       = (*(volatile Ifx_SCU_SYSPLLCON0*)0xF0036018u).U;
        sysPllCon0.B.PDIV  = pllsParamCfg->sysPllConfig.pDivider;
        sysPllCon0.B.NDIV  = pllsParamCfg->sysPllConfig.nDivider;
        sysPllCon0.B.INSEL = pllsParamCfg->pllInputClockSelection;
        (*(volatile Ifx_SCU_SYSPLLCON0*)0xF0036018u).U   = sysPllCon0.U;
    }

    /* Configure the initial steps for the peripheral PLL*/
    {
        Ifx_SCU_PERPLLCON0 scuPerPllCon0;
        scuPerPllCon0.U       = (*(volatile Ifx_SCU_PERPLLCON0*)0xF0036028u).U;
        scuPerPllCon0.B.DIVBY = pllsParamCfg->perPllConfig.k3DividerBypass;
        scuPerPllCon0.B.PDIV  = pllsParamCfg->perPllConfig.pDivider;
        scuPerPllCon0.B.NDIV  = pllsParamCfg->perPllConfig.nDivider;
        (*(volatile Ifx_SCU_PERPLLCON0*)0xF0036028u).U      = scuPerPllCon0.U;
    }

    /* Power up the both the PLLs before configuring registers*/
    (*(volatile Ifx_SCU_SYSPLLCON0*)0xF0036018u).B.PLLPWD = 1;
    (*(volatile Ifx_SCU_PERPLLCON0*)0xF0036028u).B.PLLPWD = 1;

    timeoutCycleCount       = (0x3000U);

    while (((*(volatile Ifx_SCU_SYSPLLSTAT*)0xF0036014u).B.PWDSTAT == 1) || ((*(volatile Ifx_SCU_PERPLLSTAT*)0xF0036024u).B.PWDSTAT == 1))
    {
        {                                                    if (((sint32)--timeoutCycleCount) <= 0)                       {                                                    initError = (uint8)1;                                 break;                                       }                                                else                                             {                                                }                                            };
    }

    timeoutCycleCount = (0x6000U);

    while (((*(volatile Ifx_SCU_SYSPLLSTAT*)0xF0036014u).B.K2RDY == 0U) ||
           ((*(volatile Ifx_SCU_PERPLLSTAT*)0xF0036024u).B.K2RDY == 0U) ||
           ((*(volatile Ifx_SCU_PERPLLSTAT*)0xF0036024u).B.K3RDY == 0U))
    {
        {                                                    if (((sint32)--timeoutCycleCount) <= 0)                       {                                                    initError = (uint8)1;                                 break;                                       }                                                else                                             {                                                }                                            };
    }

    (*(volatile Ifx_SCU_SYSPLLCON1*)0xF003601Cu).B.K2DIV = pllsParamCfg->sysPllConfig.k2Divider;
    {
        Ifx_SCU_PERPLLCON1 scuPerPllCon1;
        scuPerPllCon1.U       = (*(volatile Ifx_SCU_PERPLLCON1*)0xF003602Cu).U;
        scuPerPllCon1.B.K2DIV = pllsParamCfg->perPllConfig.k2Divider;
        scuPerPllCon1.B.K3DIV = pllsParamCfg->perPllConfig.k3Divider;
        (*(volatile Ifx_SCU_PERPLLCON1*)0xF003602Cu).U      = scuPerPllCon1.U;
    }

    timeoutCycleCount = (0x6000U);

    while (((*(volatile Ifx_SCU_SYSPLLSTAT*)0xF0036014u).B.K2RDY == 0U) ||
           ((*(volatile Ifx_SCU_PERPLLSTAT*)0xF0036024u).B.K2RDY == 0U) ||
           ((*(volatile Ifx_SCU_PERPLLSTAT*)0xF0036024u).B.K3RDY == 0U))
    {
        {                                                    if (((sint32)--timeoutCycleCount) <= 0)                       {                                                    initError = (uint8)1;                                 break;                                       }                                                else                                             {                                                }                                            };
    }

    /*Check if the OSC frequencies are in the limit*/
    timeoutCycleCount = (0x493E0U);

    while (((*(volatile Ifx_SCU_OSCCON*)0xF0036010u).B.PLLLV == 0) && ((*(volatile Ifx_SCU_OSCCON*)0xF0036010u).B.PLLHV == 0))
    {
        {                                                    if (((sint32)--timeoutCycleCount) <= 0)                       {                                                    initError = (uint8)1;                                 break;                                       }                                                else                                             {                                                }                                            };
    }

    /* Now start PLL locking for latest set values*/
    {
        (*(volatile Ifx_SCU_SYSPLLCON0*)0xF0036018u).B.RESLD = 1;             /* Restart Sys PLL lock detection */
        (*(volatile Ifx_SCU_PERPLLCON0*)0xF0036028u).B.RESLD = 1;             /* Restart Per PLL lock detection */

        timeoutCycleCount      = (0x3000U);

        while (((*(volatile Ifx_SCU_SYSPLLSTAT*)0xF0036014u).B.LOCK == 0) || ((*(volatile Ifx_SCU_PERPLLSTAT*)0xF0036024u).B.LOCK == 0))
        {
            {                                                    if (((sint32)--timeoutCycleCount) <= 0)                       {                                                    initError = (uint8)1;                                 break;                                       }                                                else                                             {                                                }                                            };
        }
    }
    /*Enable SMU Alarms */
    {
        (*(volatile Ifx_SMU_KEYS*)0xF0036834u).U = (uint32)0xBCU;           /* Enable access to SMU registers */
        (*(volatile Ifx_SMU_CMD*)0xF0036820u).U  = (uint32)0x00000005;
        (*(volatile Ifx_SMU_AG*)0xF00369E0u).U  = (0x1DU); /* Clear SMU Alarms*/
        (*(volatile Ifx_SMU_KEYS*)0xF0036834u).U = (uint32)0U;
    }
    {
        Ifx_SCU_CCUCON0 scu_ccucon0;
        scu_ccucon0.U        = (*(volatile Ifx_SCU_CCUCON0*)0xF0036030u).U;
        scu_ccucon0.B.CLKSEL = 1; /*Select the PLLs for fsource0/1/2 */
        scu_ccucon0.B.UP     = 1; /*Update the ccucon0 register */

        timeoutCycleCount    = (0x1000U);

        while ((*(volatile Ifx_SCU_CCUCON0*)0xF0036030u).B.LCK != 0U)
        {
            {                                                    if (((sint32)--timeoutCycleCount) <= 0)                       {                                                    initError = (uint8)1;                                 break;                                       }                                                else                                             {                                                }                                            };
        }

        (*(volatile Ifx_SCU_CCUCON0*)0xF0036030u).U     = scu_ccucon0.U;

        timeoutCycleCount = (0x1000U);

        while ((*(volatile Ifx_SCU_CCUCON0*)0xF0036030u).B.LCK != 0U)
        {
            {                                                    if (((sint32)--timeoutCycleCount) <= 0)                       {                                                    initError = (uint8)1;                                 break;                                       }                                                else                                             {                                                }                                            };
        }
    }

    IfxScuWdt_setSafetyEndinitInline(endinitSfty_pw);
    return (boolean)initError;
}


static inline boolean IfxScuCcu_distributeClockInline(const IfxScuCcu_ClockDistributionConfig *clockDistributionConfig)
{
    uint16 endinitSfty_pw;
    uint32 timeoutCycleCount;
    uint32 initError = 0;

    /*get the watch-dog passwords for usage with this function*/
    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPasswordInline();

    /* Reset Safety ENDINIT, SCU_CCUCON registers are protected*/
    IfxScuWdt_clearSafetyEndinitInline(endinitSfty_pw);

    /*Configure the clock distribution */
    {                                                    /*Write CCUCON0 configuration */
        Ifx_SCU_CCUCON0 ccucon0;
        ccucon0.U         = (*(volatile Ifx_SCU_CCUCON0*)0xF0036030u).U & ~clockDistributionConfig->ccucon0.mask;
        /*update with configured value */
        ccucon0.U        |= (clockDistributionConfig->ccucon0.mask & clockDistributionConfig->ccucon0.value);
        timeoutCycleCount = (0x1000U);

        while ((*(volatile Ifx_SCU_CCUCON0*)0xF0036030u).B.LCK != 0U)
        {
            {                                                    if (((sint32)--timeoutCycleCount) <= 0)                       {                                                    initError = (uint8)1;                                 break;                                       }                                                else                                             {                                                }                                            };
        }

        (*(volatile Ifx_SCU_CCUCON0*)0xF0036030u).U     = ccucon0.U;      /*Set update bit explicitly to make above configurations effective */
        timeoutCycleCount = (0x1000U);

        while ((*(volatile Ifx_SCU_CCUCON0*)0xF0036030u).B.LCK != 0U)
        {
            {                                                    if (((sint32)--timeoutCycleCount) <= 0)                       {                                                    initError = (uint8)1;                                 break;                                       }                                                else                                             {                                                }                                            };
        }
    }
    {
        /*Write CCUCON1 configuration */
        Ifx_SCU_CCUCON1 ccucon1;
        ccucon1.U = (*(volatile Ifx_SCU_CCUCON1*)0xF0036034u).U;

        if (ccucon1.B.CLKSELMCAN
            || ccucon1.B.CLKSELMSC
            || ccucon1.B.CLKSELQSPI)
        {
            /* Non Zero ClockSel exists - set to Zero */
            /* CAUTION: this would briefly reset and set all clocks in CCUCON1! */
            ccucon1.U  = (*(volatile Ifx_SCU_CCUCON1*)0xF0036034u).U & ~clockDistributionConfig->ccucon1.mask;
            /*update with configured value */
            ccucon1.U |= (clockDistributionConfig->ccucon1.mask & clockDistributionConfig->ccucon1.value);

            /* set Clock selects to 0 */
            ccucon1.B.CLKSELMCAN = (uint32)0;
            ccucon1.B.CLKSELMSC  = (uint32)0;
            ccucon1.B.CLKSELQSPI = (uint32)0;

            timeoutCycleCount    = (0x1000U);

            while ((*(volatile Ifx_SCU_CCUCON1*)0xF0036034u).B.LCK != 0U)
            {
                {                                                    if (((sint32)--timeoutCycleCount) <= 0)                       {                                                    initError = (uint8)1;                                 break;                                       }                                                else                                             {                                                }                                            };
            }

            (*(volatile Ifx_SCU_CCUCON1*)0xF0036034u).U     = ccucon1.U;

            timeoutCycleCount = (0x1000U);

            while ((*(volatile Ifx_SCU_CCUCON1*)0xF0036034u).B.LCK != 0U)
            {
                {                                                    if (((sint32)--timeoutCycleCount) <= 0)                       {                                                    initError = (uint8)1;                                 break;                                       }                                                else                                             {                                                }                                            };
            }
        }

        ccucon1.U         = (*(volatile Ifx_SCU_CCUCON1*)0xF0036034u).U & ~clockDistributionConfig->ccucon1.mask;
        /*update with configured value */
        ccucon1.U        |= (clockDistributionConfig->ccucon1.mask & clockDistributionConfig->ccucon1.value);

        timeoutCycleCount = (0x1000U);

        while ((*(volatile Ifx_SCU_CCUCON1*)0xF0036034u).B.LCK != 0U)
        {
            {                                                    if (((sint32)--timeoutCycleCount) <= 0)                       {                                                    initError = (uint8)1;                                 break;                                       }                                                else                                             {                                                }                                            };
        }

        (*(volatile Ifx_SCU_CCUCON1*)0xF0036034u).U     = ccucon1.U;

        timeoutCycleCount = (0x1000U);

        while ((*(volatile Ifx_SCU_CCUCON1*)0xF0036034u).B.LCK != 0U)
        {
            {                                                    if (((sint32)--timeoutCycleCount) <= 0)                       {                                                    initError = (uint8)1;                                 break;                                       }                                                else                                             {                                                }                                            };
        }
    }

    {
        /*Write CCUCON2 configuration */
        Ifx_SCU_CCUCON2 ccucon2;
        ccucon2.U = (*(volatile Ifx_SCU_CCUCON2*)0xF0036040u).U;

        if (ccucon2.B.CLKSELASCLINS)
        {
            /* Non Zero ClockSel exists - set to Zero */
            /* CAUTION: this would briefly reset and set ASCLINS clock in CCUCON2! */
            ccucon2.U               = (*(volatile Ifx_SCU_CCUCON2*)0xF0036040u).U & ~clockDistributionConfig->ccucon2.mask;
            /*update with configured value */
            ccucon2.U              |= (clockDistributionConfig->ccucon2.mask & clockDistributionConfig->ccucon2.value);

            ccucon2.B.CLKSELASCLINS = (uint32)0;

            timeoutCycleCount       = (0x1000U);

            while ((*(volatile Ifx_SCU_CCUCON2*)0xF0036040u).B.LCK != 0U)
            {
                {                                                    if (((sint32)--timeoutCycleCount) <= 0)                       {                                                    initError = (uint8)1;                                 break;                                       }                                                else                                             {                                                }                                            };
            }

            (*(volatile Ifx_SCU_CCUCON2*)0xF0036040u).U     = ccucon2.U;

            timeoutCycleCount = (0x1000U);

            while ((*(volatile Ifx_SCU_CCUCON2*)0xF0036040u).B.LCK != 0U)
            {
                {                                                    if (((sint32)--timeoutCycleCount) <= 0)                       {                                                    initError = (uint8)1;                                 break;                                       }                                                else                                             {                                                }                                            };
            }
        }

        ccucon2.U         = (*(volatile Ifx_SCU_CCUCON2*)0xF0036040u).U & ~clockDistributionConfig->ccucon2.mask;
        /*update with configured value */
        ccucon2.U        |= (clockDistributionConfig->ccucon2.mask & clockDistributionConfig->ccucon2.value);

        timeoutCycleCount = (0x1000U);

        while ((*(volatile Ifx_SCU_CCUCON2*)0xF0036040u).B.LCK != 0U)
        {
            {                                                    if (((sint32)--timeoutCycleCount) <= 0)                       {                                                    initError = (uint8)1;                                 break;                                       }                                                else                                             {                                                }                                            };
        }

        (*(volatile Ifx_SCU_CCUCON2*)0xF0036040u).U     = ccucon2.U;

        timeoutCycleCount = (0x1000U);

        while ((*(volatile Ifx_SCU_CCUCON2*)0xF0036040u).B.LCK != 0U)
        {
            {                                                    if (((sint32)--timeoutCycleCount) <= 0)                       {                                                    initError = (uint8)1;                                 break;                                       }                                                else                                             {                                                }                                            };
        }
    }
    {
        /*Write CCUCON5 configuration */
        Ifx_SCU_CCUCON5 ccucon5;
        ccucon5.U         = (*(volatile Ifx_SCU_CCUCON5*)0xF003604Cu).U & ~clockDistributionConfig->ccucon5.mask;
        /*update with configured value */
        ccucon5.U        |= (clockDistributionConfig->ccucon5.mask & clockDistributionConfig->ccucon5.value);
        ccucon5.B.UP      = 1;
        timeoutCycleCount = (0x1000U);

        while ((*(volatile Ifx_SCU_CCUCON5*)0xF003604Cu).B.LCK != 0U)
        {
            {                                                    if (((sint32)--timeoutCycleCount) <= 0)                       {                                                    initError = (uint8)1;                                 break;                                       }                                                else                                             {                                                }                                            };
        }

        (*(volatile Ifx_SCU_CCUCON5*)0xF003604Cu).U     = ccucon5.U;
        timeoutCycleCount = (0x1000U);

        while ((*(volatile Ifx_SCU_CCUCON5*)0xF003604Cu).B.LCK != 0U)
        {
            {                                                    if (((sint32)--timeoutCycleCount) <= 0)                       {                                                    initError = (uint8)1;                                 break;                                       }                                                else                                             {                                                }                                            };
        }
    }
    {
        /*Write CCUCON6 configuration */
        Ifx_SCU_CCUCON6 ccucon6;
        ccucon6.U     = (*(volatile Ifx_SCU_CCUCON6*)0xF0036080u).U & ~clockDistributionConfig->ccucon6.mask;
        /*update with configured value */
        ccucon6.U    |= (clockDistributionConfig->ccucon6.mask & clockDistributionConfig->ccucon6.value);
        (*(volatile Ifx_SCU_CCUCON6*)0xF0036080u).U = ccucon6.U;
    }

    {
        /*Write CCUCON7 configuration */
        Ifx_SCU_CCUCON7 ccucon7;
        ccucon7.U     = (*(volatile Ifx_SCU_CCUCON7*)0xF0036084u).U & ~clockDistributionConfig->ccucon7.mask;
        /*update with configured value */
        ccucon7.U    |= (clockDistributionConfig->ccucon7.mask & clockDistributionConfig->ccucon7.value);
        (*(volatile Ifx_SCU_CCUCON7*)0xF0036084u).U = ccucon7.U;
    }

    {
        /*Write CCUCON8 configuration */
        Ifx_SCU_CCUCON8 ccucon8;
        ccucon8.U     = (*(volatile Ifx_SCU_CCUCON8*)0xF0036088u).U & ~clockDistributionConfig->ccucon8.mask;
        /*update with configured value */
        ccucon8.U    |= (clockDistributionConfig->ccucon8.mask & clockDistributionConfig->ccucon8.value);
        (*(volatile Ifx_SCU_CCUCON8*)0xF0036088u).U = ccucon8.U;
    }
    {
        /*Write CCUCON9 configuration */
        Ifx_SCU_CCUCON9 ccucon9;
        ccucon9.U     = (*(volatile Ifx_SCU_CCUCON9*)0xF003608Cu).U & ~clockDistributionConfig->ccucon9.mask;
        /*update with configured value */
        ccucon9.U    |= (clockDistributionConfig->ccucon9.mask & clockDistributionConfig->ccucon9.value);
        (*(volatile Ifx_SCU_CCUCON9*)0xF003608Cu).U = ccucon9.U;
    }
    IfxScuWdt_setSafetyEndinitInline(endinitSfty_pw);
    return (boolean)initError;
}


static inline float32 IfxScuCcu_getAdcFrequency(void)
{
    return IfxScuCcu_getSourceFrequency(IfxScuCcu_Fsource_1);
}


static inline float32 IfxScuCcu_getAsclinFFrequency(void)
{
    float32 freq          = 0;

    uint8   asclindiv[16] = {1, 1, 2, 3, 4, 5, 6, 6, 8, 8, 10, 10, 12, 12, 12, 15};

    if ((*(volatile Ifx_SCU_CCUCON2*)0xF0036040u).B.ASCLINFDIV)
    {
        freq = IfxScuCcu_getSourceFrequency(IfxScuCcu_Fsource_2) / asclindiv[(*(volatile Ifx_SCU_CCUCON2*)0xF0036040u).B.ASCLINFDIV];
    }

    return freq;
}


static inline float32 IfxScuCcu_getEvrFrequency(void)
{
    return (100000000.0);
}


static inline float32 IfxScuCcu_getGethFrequency(void)
{
    return IfxScuCcu_getSourceFrequency(IfxScuCcu_Fsource_0) / (*(volatile Ifx_SCU_CCUCON5*)0xF003604Cu).B.GETHDIV;
}


static inline float32 IfxScuCcu_getGtmFrequency(void)
{
    /* fGTM = fSOURCEGTM / GTMDIV ;
     * fSOURCEGTM = fSPB *2
     */
    uint8   gtmDiv  = (*(volatile Ifx_SCU_CCUCON0*)0xF0036030u).B.GTMDIV;
    float32 gtmFreq = 0;

    if (gtmDiv == 0u)
    {
        gtmFreq = 0.0;
    }
    else if (gtmDiv == 1U)
    {
        gtmFreq = IfxScuCcu_getSpbFrequency() * 2;
    }
    else

    {
        gtmFreq = IfxScuCcu_getSourceFrequency(IfxScuCcu_Fsource_0) / gtmDiv;
    }

    return gtmFreq;
}


static inline float32 IfxScuCcu_getI2cFrequency(void)
{
    return IfxScuCcu_getSourceFrequency(IfxScuCcu_Fsource_2) / (*(volatile Ifx_SCU_CCUCON1*)0xF0036034u).B.I2CDIV;
}


static inline float32 IfxScuCcu_getMcanhFrequency(void)
{
    return IfxScuCcu_getSourceFrequency(IfxScuCcu_Fsource_0) / (*(volatile Ifx_SCU_CCUCON5*)0xF003604Cu).B.MCANHDIV;
}


static inline float32 IfxScuCcu_getOsc0Frequency(void)
{
    return (float32)(20000000);
}


static inline float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if ((*(volatile Ifx_SCU_SYSPLLCON0*)0xF0036018u).B.INSEL == IfxScuCcu_PllInputClockSelection_fOsc1)
    {
        freq = (100000000.0);
    }
    else if ((*(volatile Ifx_SCU_SYSPLLCON0*)0xF0036018u).B.INSEL == IfxScuCcu_PllInputClockSelection_fOsc0)
    {
        freq = (float32)(20000000);
    }
    else if ((*(volatile Ifx_SCU_SYSPLLCON0*)0xF0036018u).B.INSEL == IfxScuCcu_PllInputClockSelection_fSysclk)
    {
        freq = 20000000;
    }
    else
    {
        /* Reserved values, this */
        freq = 0.0;
    }

    return freq;
}


static inline IfxScuCcu_PllInputClockSelection IfxScuCcu_getSourceSelection(void)
{
    return (IfxScuCcu_PllInputClockSelection)(*(volatile Ifx_SCU_CCUCON0*)0xF0036030u).B.CLKSEL;
}


static inline float32 IfxScuCcu_getStmFrequency(void)
{
    return IfxScuCcu_getSourceFrequency(IfxScuCcu_Fsource_0) / (*(volatile Ifx_SCU_CCUCON0*)0xF0036030u).B.STMDIV;
}


static inline boolean IfxScuCcu_getTrapDisableFlag(IfxCpu_ResourceCpu cpuIndex, IfxScuCcu_Traprequest request)
{
    boolean trapdisable = 0;

    trapdisable = (((*(volatile Ifx_SCU_TRAPDIS0*)0xF0036130u).U >> ((cpuIndex << 3) + request)) & 0x1);
    return trapdisable;
}


static inline boolean IfxScuCcu_getTrapStatusFlag(IfxScuCcu_Traprequest request)
{
    boolean trapstatus = 0;

    trapstatus = ((((*(volatile Ifx_SCU_TRAPSTAT*)0xF0036124u).U) >> request) & (0x1));

    return trapstatus;
}


static inline void IfxScuCcu_setTrapDisableFlag(IfxCpu_ResourceCpu cpuIndex, IfxScuCcu_Traprequest request)
{
    uint32 trapdis = 1;
    trapdis         = (trapdis << (cpuIndex << 3));
    (*(volatile Ifx_SCU_TRAPDIS0*)0xF0036130u).U |= (trapdis << request);
}


static inline void IfxScuCcu_setTrapStatusFlag(IfxScuCcu_Traprequest request)
{
    uint32 trapset = 1;
    (*(volatile Ifx_SCU_TRAPSET*)0xF0036128u).U |= (trapset << request);
}


static inline boolean IfxScuCcu_throttleSysPllClockInline(const IfxScuCcu_PllThrottleConfig *pllThrottleConfig)
{
    uint8  initError = 0;
    uint8  pllStepsCount;
    uint16 endinitSfty_pw;
    uint32 timeoutCycleCount;

    /*get the watch-dog passwords for usage with this function*/
    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPasswordInline();

    /*Start Pll ramp up sequence */
    for (pllStepsCount = 0; pllStepsCount < pllThrottleConfig->numOfSteps; pllStepsCount++)
    {                       /*iterate through number of pll steps */
        {
            IfxScuWdt_clearSafetyEndinitInline(endinitSfty_pw);

            /*Configure K2 divider */
            timeoutCycleCount = (0x6000U);

            while ((*(volatile Ifx_SCU_SYSPLLSTAT*)0xF0036014u).B.K2RDY == 0U)
            {
                {                                                    if (((sint32)--timeoutCycleCount) <= 0)                       {                                                    initError = (uint8)1;                                 break;                                       }                                                else                                             {                                                }                                            };
            }

            /*Now set the K2 divider value for the step corresponding to step count */
            (*(volatile Ifx_SCU_SYSPLLCON1*)0xF003601Cu).B.K2DIV = pllThrottleConfig->pllSteps[pllStepsCount].k2Step;
            IfxScuWdt_setSafetyEndinitInline(endinitSfty_pw);
        }

        /*Wait for waitCounter corresponding to the pll step */
        IfxScuCcu_wait(pllThrottleConfig->pllSteps[pllStepsCount].waitTime);
    }

    return (boolean)initError;
}


static inline void IfxScuCcu_wait(float32 timeSec)
{
    uint32 stmCount      = (uint32)(IfxScuCcu_getStmFrequency() * timeSec);
    uint32 stmCountBegin = (*(volatile Ifx_STM_TIM0*)0xF0001010u).U;

    while ((uint32)((*(volatile Ifx_STM_TIM0*)0xF0001010u).U - stmCountBegin) < stmCount)
    {
        /* There is no need to check overflow of the STM timer.
         * When counter after overflow subtracted with counter before overflow,
         * the subtraction result will be as expected, as long as both are unsigned 32 bits
         * eg: stmCountBegin= 0xFFFFFFFE (before overflow)
         *     stmCountNow = 0x00000002 (before overflow)
         *     diff= stmCountNow - stmCountBegin = 4 as expected.*/
    }
}


static inline void IfxScuCcu_waitWithWdtService(float32 timeSec)
{
    uint32 stmCount          = (uint32)(IfxScuCcu_getStmFrequency() * timeSec);
    uint32 stmCountBegin     = (*(volatile Ifx_STM_TIM0*)0xF0001010u).U;
    uint16 cpuWdtPassword    = IfxScuWdt_getCpuWatchdogPassword();
    uint16 safetyWdtPassword = IfxScuWdt_getSafetyWatchdogPassword();

    while ((uint32)((*(volatile Ifx_STM_TIM0*)0xF0001010u).U - stmCountBegin) < stmCount)
    {
        /* There is no need to check overflow of the STM timer.
         * When counter after overflow subtracted with counter before overflow,
         * the subtraction result will be as expected, as long as both are unsigned 32 bits
         * eg: stmCountBegin= 0xFFFFFFFE (before overflow)
         *     stmCountNow = 0x00000002 (before overflow)
         *     diff= stmCountNow - stmCountBegin = 4 as expected.*/
        IfxScuWdt_serviceCpuWatchdog(cpuWdtPassword);
        IfxScuWdt_serviceSafetyWatchdog(safetyWdtPassword);
    }
}


static inline void IfxScuCcu_switchToLowPowerMode(IfxScuCcu_LowPowerDivRatio lpDiv)
{
    uint16 endinitSfty_pw;

    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();

    /* clear safety ENDINIT prior to write to SCU_CCUCON0 */
    IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);

    /* wait for unlock status - safety watchdog ensures timeout */
    while ((*(volatile Ifx_SCU_CCUCON0*)0xF0036030u).B.LCK != 0U)
    {} /*Wait till ccucon0 lock is set, No "timeout" required, ENDINIT watch-dog is active! */

    Ifx_SCU_CCUCON0 scu_ccucon0;
    scu_ccucon0.U       = (*(volatile Ifx_SCU_CCUCON0*)0xF0036030u).U;  /* read ccucon0*/
    scu_ccucon0.B.LPDIV = lpDiv;                /* write Div ratio to LPDIV */
    scu_ccucon0.B.UP    = 1;                    /*Update the ccucon0 register */
    (*(volatile Ifx_SCU_CCUCON0*)0xF0036030u).U       = scu_ccucon0.U;        /* write back */

    IfxScuWdt_setSafetyEndinit(endinitSfty_pw); /* set Safety ENDINIT */
}


static inline void IfxScuCcu_switchToNormalMode(const uint32 ccucon0)
{
    uint16 endinitSfty_pw;

    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();

    /* clear safety ENDINIT prior to write to SCU_CCUCON0 */
    IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);

    /* wait for unlock status - safety watchdog ensures timeout */
    while ((*(volatile Ifx_SCU_CCUCON0*)0xF0036030u).B.LCK != 0U)
    {} /*Wait till ccucon0 lock is set, No "timeout" required, ENDINIT watch-dog is active! */

    /* Intermediate step : SPBDIV = 12 and SRIDIV = 3
     *  NOTE: This intermediate step in division ratio is done to avoid a sudden jump in clock frequency
     *  while jumping back from Low Power to Normal mode. The division ratios used in this step is hard
     *  coded into this function after proving on HW.
     */
    Ifx_SCU_CCUCON0 scu_ccucon0;
    scu_ccucon0.U        = (*(volatile Ifx_SCU_CCUCON0*)0xF0036030u).U;          /* read ccucon0*/
    scu_ccucon0.B.SRIDIV = 3;                      /* SRIDIV = 1:3*/
    scu_ccucon0.B.SPBDIV = 12;                     /* SPBDIV = 1:12 */
    scu_ccucon0.B.LPDIV  = 0;                      /* Exit Low Power Mode */
    scu_ccucon0.B.UP     = 1;
    (*(volatile Ifx_SCU_CCUCON0*)0xF0036030u).U        = scu_ccucon0.U;          /* write back */
    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);    /* set Safety ENDINIT */

    /* wait  */
    IfxScuCcu_wait((0.00001f)); /* wait */

    /* Now back to original settings for normal mode */
    /* clear safety ENDINIT prior to write to SCU_CCUCON0 */
    IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);

    /* wait for unlock status - safety watchdog ensures timeout */
    while ((*(volatile Ifx_SCU_CCUCON0*)0xF0036030u).B.LCK != 0U)
    {} /*Wait till ccucon0 lock is set, No "timeout" required, ENDINIT watch-dog is active! */

    scu_ccucon0.U    = (*(volatile Ifx_SCU_CCUCON0*)0xF0036030u).U;     /* read ccucon0*/
    scu_ccucon0.U    = ccucon0;      /* original setting */
    scu_ccucon0.B.UP = 1;                       /* update */
    (*(volatile Ifx_SCU_CCUCON0*)0xF0036030u).U    = scu_ccucon0.U;           /* write back */
    IfxScuWdt_setSafetyEndinit(endinitSfty_pw); /* set Safety ENDINIT */
}



#line 77 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Cpu\\Std\\IfxCpu.h"

/******************************************************************************/
/*-----------------------------------Macros-----------------------------------*/
/******************************************************************************/

/** \brief Convert local DSPR address to global DSPR address which can be accessed from the SRI bus.
 * Use this macro to convert a local DSPR address (in segment 0xd00.....) to
 * a global DSPR address (in segment 0x700....., 0x600....., 0x500..... downwards) depending on
 * the CPU number.
 * Example usage:
 *  \code
 *     dmaChConfig.sourceAddress      = IFXCPU_GLB_ADDR_DSPR(IfxCpu_getCoreId(), &sourceBuffer[i][0]);
 *     dmaChConfig.destinationAddress = IFXCPU_GLB_ADDR_DSPR(IfxCpu_getCoreId(), &destinationBuffer[i][0]);
 *  \endcode
 */


/** \brief Convert local PSPR address to global PSPR address which can be accessed from the SRI bus.
 * Use this macro to convert a local PSPR address (in segment 0xc......) to
 * a global PSPR address (in segment 0x701....., 0x601....., 0x501..... downwards) depending on
 * the CPU number.
 *
 *   Example usage:
 *   \code
 *     dmaChConfig.sourceAddress      = IFXCPU_GLB_ADDR_PSPR(IfxCpu_getCoreId(), &sourceBufferInPsprMemory);
 *     dmaChConfig.destinationAddress = IFXCPU_GLB_ADDR_PSPR(IfxCpu_getCoreId(), &destinationBufferInPsprMemory);
 *   \endcode
 */


/******************************************************************************/
/*------------------------------Type Definitions------------------------------*/
/******************************************************************************/

/** \brief Lock type Spin lock
 */
typedef unsigned int IfxCpu_spinLock;

/** \brief Lock type Mutex lock
 */
typedef unsigned int IfxCpu_mutexLock;

/** \brief Event used for synchronisation.
 */
typedef unsigned int IfxCpu_syncEvent;

/******************************************************************************/
/*--------------------------------Enumerations--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Cpu_Std_Enum
 * \{ */
/** \brief Enumeration for the Cpu mode
 */
typedef enum
{
    IfxCpu_CoreMode_halt,
    IfxCpu_CoreMode_run,
    IfxCpu_CoreMode_idle,
    IfxCpu_CoreMode_sleep,
    IfxCpu_CoreMode_stby,
    IfxCpu_CoreMode_unknown
} IfxCpu_CoreMode;

/** \brief Performance conunter modes
 */
typedef enum
{
    IfxCpu_CounterMode_normal = 0,  /**< \brief Normal counter mode:the counter increments on their respective triggers */
    IfxCpu_CounterMode_task   = 1   /**< \brief Normal counter mode:additional gating control from the debug unit which allows the data gathered in the performance counters to be filtered by some specific criteria */
} IfxCpu_CounterMode;

/** \brief Overlay Address Mask: determines the overlay block size and the bits used for address comparison and translation
 */
typedef enum
{
    IfxCpu_OverlayAddressMask_32byte  = 0xFFF,  /**< \brief 32 byte block size Mask */
    IfxCpu_OverlayAddressMask_64byte  = 0xFFE,  /**< \brief 64 byte block size Mask */
    IfxCpu_OverlayAddressMask_128byte = 0xFFC,  /**< \brief 128 byte block size Mask */
    IfxCpu_OverlayAddressMask_256byte = 0xFF8,  /**< \brief 256 byte block size Mask */
    IfxCpu_OverlayAddressMask_512byte = 0xFF0,  /**< \brief 512 byte block size Mask */
    IfxCpu_OverlayAddressMask_1KB     = 0xFE0,  /**< \brief 1K byte block size Mask */
    IfxCpu_OverlayAddressMask_2KB     = 0xFC0,  /**< \brief 2K byte block size Mask */
    IfxCpu_OverlayAddressMask_4KB     = 0xF80,  /**< \brief 4K byte block size Mask */
    IfxCpu_OverlayAddressMask_8KB     = 0xF00,  /**< \brief 8K byte block size Mask */
    IfxCpu_OverlayAddressMask_16KB    = 0xE00,  /**< \brief 16K byte block size Mask */
    IfxCpu_OverlayAddressMask_32KB    = 0xC00,  /**< \brief 32K byte block size Mask */
    IfxCpu_OverlayAddressMask_64KB    = 0x800,  /**< \brief 64K byte block size Mask */
    IfxCpu_OverlayAddressMask_128KB   = 0x0     /**< \brief 128K byte block size Mask */
} IfxCpu_OverlayAddressMask;

/** \brief Selects overlay memory used for redirection
 */
typedef enum
{
    IfxCpu_OverlayMemorySelect_core0DsprPspr = 0,  /**< \brief Redirection to Core 0 DSPR/PSPR memory */
    IfxCpu_OverlayMemorySelect_core1DsprPspr = 1,  /**< \brief Redirection to Core 1 DSPR/PSPR memory */
    IfxCpu_OverlayMemorySelect_core2DsprPspr = 2,  /**< \brief Redirection to Core 2 DSPR/PSPR memory */
    IfxCpu_OverlayMemorySelect_core3DsprPspr = 3,  /**< \brief Redirection to Core 3 DSPR/PSPR memory */
    IfxCpu_OverlayMemorySelect_lmu           = 8   /**< \brief Redirection to LMU memory */
} IfxCpu_OverlayMemorySelect;

typedef enum
{
    IfxCpu_ResetStatus_notCpuReset   = 0,  /**< \brief No Kernel Reset was executed */
    IfxCpu_ResetStatus_cpuResetBySmu = 1,  /**< \brief Kernel reset was requested by hardware since last clear (SMU) */
    IfxCpu_ResetStatus_cpuResetBySw  = 2   /**< \brief Kernel reset was requested by software since last clear (by writing KRST0.RST=1 and KRST1.RST=1) */
} IfxCpu_ResetStatus;

/** \} */

/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Cpu_Std_DataStructures
 * \{ */
/** \brief counter
 */
typedef struct
{
    uint32  counter;        /**< \brief Counter value */
    boolean overlfow;       /**< \brief sticky overlfow */
} IfxCpu_Counter;

/** \} */

/** \addtogroup IfxLld_Cpu_Std_DataStructures
 * \{ */
/** \brief Performance counter result
 */
typedef struct
{
    IfxCpu_Counter instruction;       /**< \brief Instruction counter */
    IfxCpu_Counter clock;             /**< \brief CPU clock counter */
    IfxCpu_Counter counter1;          /**< \brief Multi counter 1 */
    IfxCpu_Counter counter2;          /**< \brief Multi counter 2 */
    IfxCpu_Counter counter3;          /**< \brief Multi counter 3 */
} IfxCpu_Perf;

/** \} */

/** \addtogroup IfxLld_Cpu_Std_Core
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief API to get the address for CPU HW module register memory map
 * \param cpu Resource index of the CPU
 * \return CPU module register address
 */
static inline Ifx_CPU *IfxCpu_getAddress(IfxCpu_ResourceCpu cpu);

/** \brief API to get core id of the CPU of the caller.
 * Caution: Core id of the cpu's may not be continguous and shouldn't be used to index cpu.
 * Use IfxCpu_getCoreIndex() to get cpu no.
 * \return Resource index of the CPU.
 */
static inline IfxCpu_Id IfxCpu_getCoreId(void);

/** \brief API to get cpu index of the caller CPU.
 * Note: This api can be used whereever cpu no/index is needed.
 * \return Resource index of the CPU.
 */
static inline IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void);

/** \brief API to initialize the context save area of the CPU where this is called.
 *
 * This API can initialize the CSA of the host CPU where this API is called. This API
 * shall not be used to initialize the CSA of another CPU
 * \param csaBegin Pointer to start of context save area, shall not be NULL pointer
 * \param csaEnd Pointer to end of context save area, shall be higher address than csaBegin
 * \return None
 */
static inline void IfxCpu_initCSA(uint32 *csaBegin, uint32 *csaEnd);

/** \brief Set/Clear safety task identifier (PSW.S) on current CPU
 * \return None
 */
static inline void IfxCpu_setSafetyTaskIdentifier(boolean safetyId);

/** \brief Triggers Software Reset
 * \return None
 */
static inline void IfxCpu_triggerSwReset(void);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief API to get current mode of CPU
 * \param cpu Pointer to the CPU HW module (register memory map)
 * \return Current mode of the CPU
 */
extern IfxCpu_CoreMode IfxCpu_getCoreMode(Ifx_CPU *cpu);

/** \brief API to get current mode of CPU
 * \param cpu Pointer to the CPU HW module (register memory map)
 * \return Resource index of the CPU
 */
extern IfxCpu_ResourceCpu IfxCpu_getIndex(Ifx_CPU *cpu);

/** \brief API to set mode of the CPU
 * \param cpu Pointer to the CPU HW module (register memory map)
 * \param mode CPU mode to be set by this API
 * \return Success status of the activity (setting the core mode).
 * \retval TRUE: If the activity successfully be performed.
 * \retval FALSE: If the activity can't be performed.
 */
extern boolean IfxCpu_setCoreMode(Ifx_CPU *cpu, IfxCpu_CoreMode mode);

/** \brief API to set the program counter for the CPU specified.
 * \param cpu Pointer to the CPU HW module (register memory map)
 * \param programCounter Program counter value to be set
 * \return success status of the activity (setting program counter value).
 * \retval TRUE: If the activity successfully be performed.
 * \retval FALSE: If the activity can't be performed
 */
extern boolean IfxCpu_setProgramCounter(Ifx_CPU *cpu, uint32 programCounter);

/** \brief API to set the program counter for the CPU specified and start the CPU
 * \param cpu Pointer to the CPU HW module (register memory map)
 * \param programCounter Program counter value to start the CPU
 * \return success status of the activity (setting program counter value).
 * \retval TRUE: If the activity successfully be performed.
 * \retval FALSE: If the activity can't be performed
 */
extern boolean IfxCpu_startCore(Ifx_CPU *cpu, uint32 programCounter);

/** \brief To request reset of a particular core, given by coreId
 * \return None
 */
extern void IfxCpu_triggerCpuReset(IfxCpu_ResourceCpu coreIndex);

/** \brief Retrieve the cause of reset(no reset, hardware(SMU) or software) since last clear by reading KRST0.RSTSTAT and clear it.
 */
extern IfxCpu_ResetStatus IfxCpu_getCpuResetStatus(IfxCpu_ResourceCpu coreIndex);

/** \} */

/** \addtogroup IfxLld_Cpu_Std_Interrupt
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief API to get the status of global interrupt enable (ICR.IE) for the CPU which calls this API
 * This API provides the status of CPU where this API is called
 * \return Status of global interrupt enable bit.
 * \retval TRUE: Global interrupts enabled.
 * \retval FALSE: Global interrupts disabled
 */
static inline boolean IfxCpu_areInterruptsEnabled(void);

/** \brief API to disable global interrupt and return the previous status.
 *
 * This API can be used only to disable the global interrupts of caller CPU. It cannot be
 * used for this activity towards other CPUs
 * \return Previous status of global interrupt enable bit.
 * \retval TRUE: Previously, global interrupts enabled.
 * \retval FALSE: Previously, global interrupts disabled
 */
static inline boolean IfxCpu_disableInterrupts(void);

/** \brief API to enable global interrupt.
 * This API simply enables the global interrupt.
 * \return None
 */
static inline void IfxCpu_enableInterrupts(void);

/** \brief Disable the Global Interrupt
 * \return None
 */
static inline void IfxCpu_forceDisableInterrupts(void);

/** \brief API to restore global interrupt with that of the passed parameter.
 *
 * This API can be used only to disable the global interrupts of caller CPU. It cannot be
 * used for this activity towards other CPUs
 * \param enabled Previous status of the global interrupt enable bit
 * \return None
 */
static inline void IfxCpu_restoreInterrupts(boolean enabled);

/** \} */

/** \addtogroup IfxLld_Cpu_Std_Cache
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief API to enable/ disable the data cacheability for selected segments
 * With this API cacheability for one or more segment can be enabled/disabled for the CPU core where this API is called.
 * \Note This API is to be called only if the PCACHE or DCACHE are not enabled before
 * \param segmentNumberMask Mask where bitfield 0 represents segment 0 and bitfield 16 represent segment F.
 * \param enable TRUE: to enable the cacheability for selected segment, FALSE: to disable.
 * \return None
 */
static inline void IfxCpu_enableSegmentSpecificDataAccessCacheability(uint16 segmentNumberMask, boolean enable);

/** \brief API to enable/ disable the instruction cacheability for selected segments
 * With this API cacheability for one or more segment can be enabled/disabled for the CPU core where this API is called.
 * \Note This API is to be called only if the PCACHE or DCACHE are not enabled before
 * \param segmentNumberMask Mask where bitfield 0 represents segment 0 and bitfield 16 represent segment F.
 * \param enable TRUE: to enable the cacheability for selected segment, FALSE: to disable.
 * \return None
 */
static inline void IfxCpu_enableSegmentSpecificInstructionAccessCacheability(uint16 segmentNumberMask, boolean enable);

/** \brief API to invalidate the program cache
 * \return None
 */
static inline void IfxCpu_invalidateProgramCache(void);

/** \brief API to determine if an address is in a cachable or non-cachable Flash/LMU section
 * \param address Address
 * \return Status TRUE/FALSE
 */
static inline boolean IfxCpu_isAddressCachable(void *address);

/** \brief API to enable or bypass the data cache for the CPU which calls this API.
 *
 * This API can be used only to enable or bypass the data cache of caller CPU. It cannot be
 * used for this activity towards other CPUs
 * \param enable Command to enable or bypass the data cache
 * TRUE: Enable the data cache.
 * FALSE: Bypass the data cache.
 * \return None
 */
static inline void IfxCpu_setDataCache(boolean enable);

/** \brief API to enable or bypass the program cache for the CPU which calls this API.
 *
 * This API can be used only to enable or bypass the program cache of caller CPU. It cannot be
 * used for this activity towards other CPUs
 * \param enable Command to enable or bypass the program cache.
 * TRUE: Enable the program cache.
 * FALSE: Bypass the program cache
 * \return None
 */
static inline void IfxCpu_setProgramCache(boolean enable);

/** \} */

/** \addtogroup IfxLld_Cpu_Std_PerformanceCounter
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief API to read the clock counter for the CPU which calls this API.
 *
 * This API can be used to read clock counter of only the caller CPU. It cannot be
 * used for this activity towards other CPUs.
 * \return Counter value. 0 to 0x7FFFFFFF.
 */
static inline uint32 IfxCpu_getClockCounter(void);

/** \brief API to get sticky overflow bit of clock counter for the CPU, which calls this API.
 *
 * This API can be used to get sticky overflow bit of clock counter of only the caller CPU.
 * It cannot be used for this activity towards other CPUs.
 * This API also clears the sticky overflow after the read. While reading the sticky bit this API disables
 * the counter for short time. (otherwise sticky bit cannot be cleared). This API shall be used after
 * reading the counter
 * \return Status of sticky overflow bit.
 * \retval TRUE: Sticky overflow bit is set.
 * \retval FALSE: Sticky overflow bit is reset
 */
static inline boolean IfxCpu_getClockCounterStickyOverflow(void);

/** \brief API to read the instruction counter for the CPU which calls this API.
 *
 * This API can be used to read instruction counter of only the caller CPU. It cannot be
 * used for this activity towards other CPUs
 * \return Counter value. 0 to 0x7FFFFFFF.
 */
static inline uint32 IfxCpu_getInstructionCounter(void);

/** \brief API to get sticky overflow bit of Instruction counter for the CPU, which calls this API.
 *
 * This API can be used to get sticky overflow bit of Instruction counter of only the caller CPU.
 * It cannot be used for this activity towards other CPUs.
 * This API also clears the sticky overflow after the read. While reading the sticky bit this API disables
 * the counter for short time. (otherwise sticky bit cannot be cleared). This API shall be used after
 * reading the counter
 * \return Status of sticky overflow bit.
 * \retval TRUE: Sticky overflow bit is set.
 * \retval FALSE: Sticky overflow bit is reset
 */
static inline boolean IfxCpu_getInstructionCounterStickyOverflow(void);

/** \brief API to read the performance counter for the CPU which calls this API.
 * \param address Address
 * \return counter value
 */
static inline uint32 IfxCpu_getPerformanceCounter(uint16 address);

/** \brief API to get sticky overflow bit of performance counter for the CPU, which calls this API.
 * This is generic function to get sticky overflow bit of any performance counters
 * \param address Address
 * \return Status
 */
static inline boolean IfxCpu_getPerformanceCounterStickyOverflow(uint16 address);

/** \brief Reset and start instruction, clock and multi counters
 *
 * Reset and start CCNT, ICNT, M1CNT, M2CNT, M3CNT. the overflow bits are cleared.
 * \param mode Counter mode
 * \return None
 */
static inline void IfxCpu_resetAndStartCounters(IfxCpu_CounterMode mode);

/** \brief API to enable or disable performance counter for the CPU which calls this API.
 *
 * This API can be used to enable or disable performance counter of only the caller CPU. It cannot be
 * used for this activity towards other CPUs.
 * \param enable enable Command to enable or disable the performance counter.
 * TRUE: Enable the performance counter.
 * FALSE: Disable the performance counter
 * \return None
 */
static inline void IfxCpu_setPerformanceCountersEnableBit(uint32 enable);


/** \brief Stop instruction and clock counters, return their values
 *
 * Stop CCNT, ICNT, M1CNT, M2CNT, M3CNT and return their values;
 *  \Note The CCTRL is reset to 0, for more accurate measurements and has to be initialized again before strating the next performance measurement.
 * \return Performance counter result
 */
static inline IfxCpu_Perf IfxCpu_stopCounters(void);


/** \brief API to update clock counter for the CPU which calls this API.
 *
 * This API can be used to update clock counter of only the caller CPU. It cannot be
 * used for this activity towards other CPUs.
 * \param count Counter value to be updated. 0 to 0x7FFFFFFF
 * \return None
 */
static inline void IfxCpu_updateClockCounter(uint32 count);

/** \brief API to update Instruction counter for the CPU which calls this API.
 *
 * This API can be used to update Instruction counter of only the caller CPU. It cannot be
 * used for this activity towards other CPUs.
 * \param count Counter value to be updated. 0 to 0x7FFFFFFF
 * \return None
 */
static inline void IfxCpu_updateInstructionCounter(uint32 count);

/** \brief API to update performance counter for the CPU which calls this API.
 * This is generic function to update any of the performance counters
 * \param address Address
 * \param count Count
 * \return None
 */
static inline void IfxCpu_updatePerformanceCounter(uint32 address, uint32 count);

/** \} */

/** \addtogroup IfxLld_Cpu_Std_Synchronization
 * \{ */

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief API to acquire the mutex (binary semaphore).
 *
 * This API can be used to acquire/get the mutex.
 * \param lock lock pointer
 * \return TRUE : lock acquired successfully. FALSE: Failed to acquire the lock
 *
 * \code
 *    IfxCpu_mutexLock resourceLock;
 *    boolean flag = IfxCpu_acquireMutex(&resourceLock);
 *    if (flag){
 *      // critical section
 *      IfxCpu_releaseMutex(&resourceLock);
 *    }
 * \endcode
 *
 */
extern boolean IfxCpu_acquireMutex(IfxCpu_mutexLock *lock);

/** \brief API to unlock the mutex .
 *
 * This API can be used to unlock the previously acquired mutex
 * \param lock lock pointer
 * \return None
 *
 * \code
 *    IfxCpu_mutexLock resourceLock;
 *    boolean flag = IfxCpu_acquireMutex(&resourceLock);
 *    if (flag){
 *      // critical section
 *      IfxCpu_releaseMutex(&resourceLock);
 *    }
 * \endcode
 *
 */
extern void IfxCpu_releaseMutex(IfxCpu_mutexLock *lock);

/** \brief API to unlock the resource .
 *
 * This API can be used to unlock the previously acquired lock
 * \param lock lock pointer
 * \return None
 */
extern void IfxCpu_resetSpinLock(IfxCpu_spinLock *lock);

/** \brief API to lock the resource in spin mode with the given timeout.
 *
 * This API can be used to spin lock for the lock for the given timeout period.
 * \param lock lock pointer
 * \param timeoutCount loop counter value used for timeout to acquire lock
 * \return TRUE : lock acquired successfully. FALSE: Failed to acquire the lock
 *
 * \code
 *    IfxCpu_spinLock resourceLock;
 *    boolean flag = IfxCpu_setSpinLock(&resourceLock, 0xFFFF);
 *    if (flag){
 *      // critical section
 *      IfxCpu_resetSpinLock(&resourceLock);
 *    }
 * \endcode
 *
 */
extern boolean IfxCpu_setSpinLock(IfxCpu_spinLock *lock, uint32 timeoutCount);

/** \} */

/** \addtogroup IfxLld_Cpu_Std_Utility
 * \{ */

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief This function disables the overlay memory.
 * \param cpu Core no
 * \param overlayBlock Overlay Block
 * \return None
 */
extern void IfxCpu_disableOverlayBlock(IfxCpu_ResourceCpu cpu, uint16 overlayBlock);

/** \brief This function configures and enables the overlay memory.
 * Note:
 * The data overlay provides the capability to redirect selected data accesses to the Overlay memory. Data accesses made by the TriCore to Program Flash, Online Data Acquisition space, or EBU space can be redirected. Overlay memory may be located in the Local Memory (if present), in the Emulation Memory (Emulation Device only), or in the EBU space,or in the DPSR/PSPR memory.
 *
 * How the overlay Memory works?
 * Any data access to segment 8 or segment A is checked against all the activated overlay blocks. For each activated overlay block, address bits 27..5 are compared with the target base address , and this bit-wise comparison is qualified by the content of address mask. Address bits participate in the comparison if the corresponding mask bits are set to one. The access is redirected, if all the address bits selected by mask equal to the corresponding bits in target address.
 * The address for redirection is constructed as follows:
 * 1. Address bits 31..22 are set according to the overlay memory selection and the cache-ability of the original address.
 * 2. For address bits 21..5:
 * - If the corresponding address mask bit is set, the address bit value is taken from overlay base address .
 * - If the corresponding address mask bit is cleared, the address bit value is taken from the original address.
 * 3. Address bits 4..0 are always taken directly from the original address.
 * If there is no redirection, the original address is used to perform the access.
 * Target address ranges for activated overlay blocks should not overlap or an exception may occur.
 * \param cpu Core no
 * \param overlayBlock Overlay Block
 * \param overlayMemorySelect Overlay Memory Select
 * \param overlayAddressMask overlay Address Mask
 * \param targetBaseAddress Target Base address (i.e Source address to be re-directed)
 * \param overlayBaseAddress Overlay or Re-directed Base address (Bits 21..5 of the base address the overlay memory block in the overlay memory)
 * \return None
 */
extern void IfxCpu_enableOverlayBlock(IfxCpu_ResourceCpu cpu, uint16 overlayBlock, IfxCpu_OverlayMemorySelect overlayMemorySelect, IfxCpu_OverlayAddressMask overlayAddressMask, uint32 targetBaseAddress, uint32 overlayBaseAddress);

/** \brief API to get random value
 * \param seed Pointer to seed value
 * \return random value
 */
extern uint32 IfxCpu_getRandomValue(uint32 *seed);

/** \brief API to get random value with in the range
 * \param seed Pointer to seed value
 * \param min minimum range value
 * \param max maximum range value
 * \return random value
 */
extern uint32 IfxCpu_getRandomValueWithinRange(uint32 *seed, uint32 min, uint32 max);

/** \brief This function waits till all the cores have set their corresponding bits in the event. This function along with
 * IfxCpu_emitEvent() are used to achieve the synchronisation between the configured cores. By default
 * "IFXCPU_CFG_ALLCORE_DONE" macro defined for all the cores. In case the user wants to check for
 * synchronisation among the required cores, the macro can be redefined with the value accroing to the
 * CORE_ID register.
 * The IfxCpu_emitEvent() is to be used in the Main functions of the Cores where the user wants to check for synchronisation.
 *
 * e.g:
 * 1. Check for synchronisation between core 0 and core 5
 * # define 0x41U
 * 2. Check for synchronisation between core 0 to core 5
 * # define 0x5FU
 *
 * Note:
 * Core id values read from CORE_ID register will be as shown below. The value indicates the position of the bit needs to be set while building the macro.
 * Core 0: 0
 * Core 1: 1
 * Core 2: 2
 * Core 3: 3
 * Core 4: 4
 * Core 5: 6
 * \param event Synchronous Event
 * \param timeoutMilliSec timeout in millisec
 * \return Error condition
 *
 * The functions IfxCpu_waitEvent and IfxCpu_emitEvent are used to achieve synchronisation between all cores (i.e individual cores wait till all cores have reached the synchronisation point). The IfxCpu_waitEvent returns 1 incase a timeout occurs.
 *
 * \code
 * // Global variable. preferably located in  shared memory.
 * IfxCpu_syncEvent event;
 * boolean errorVal;
 *
 * // Below code should be repeated in Each core
 *
 * // Upon reaching Synchonisation point
 * IfxCpu_emitEvent(&event);
 * errorVal = IfxCpu_waitEvent(&event, timeoutMilliSec); // timeoutMilliSec is timeout value to wait
 *
 * \endcode
 *
 */
extern boolean IfxCpu_waitEvent(IfxCpu_syncEvent *event, uint32 timeoutMilliSec);

/** \brief This function sets a bit corresponding to the core in the event.
 * \param event Synchronous Event
 * \return None
 *
 * A coding example can be found in \ref IfxCpu_waitEvent
 *
 */
extern void IfxCpu_emitEvent(IfxCpu_syncEvent *event);

/** \} */

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Sets all CPUs to Idle mode except the Master CPU,index of which is given as the parameter
 * \param masterCpu Master CPU Index- All except this will be set to Idle Mode
 * \return None
 */
extern void IfxCpu_setAllIdleExceptMasterCpu(IfxCpu_ResourceCpu masterCpu);

/** \brief Disables interrupts for all CPUs except the Master CPU,index of which is given as the parameter
 * \param masterCpu Master CPU Index- All except this will have their interrupts disabled
 * \return None
 */
extern void IfxCpu_disableInterruptsAllExceptMaster(IfxCpu_ResourceCpu masterCpu);

/******************************************************************************/
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

static inline boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(0xFE2C);
    return reg.B.IE != 0;
}


static inline boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
    __nop();
    return enabled;
}


static inline void IfxCpu_enableInterrupts(void)
{
    __enable();
}


static inline void IfxCpu_enableSegmentSpecificDataAccessCacheability(uint16 segmentNumberMask, boolean enable)
{
    uint32 cpu_pmaVal;
    uint16 checkRestrictionMask;
    uint32 coreIndex   = IfxCpu_getCoreIndex();
    uint16 wdtPassword = IfxScuWdt_getCpuWatchdogPasswordInline(&((*(Ifx_SCU*)0xF0036000u)).WDTCPU[coreIndex]);

    /*resolve the restrictions*/
    /*In PMA0 Segment-C and Segment[7-CoreID] must have the same value */
    checkRestrictionMask = ((uint16)1 << (7 - coreIndex)) | ((uint16)1 << 0xC);

    if ((segmentNumberMask & checkRestrictionMask) != 0)
    {
        segmentNumberMask |= checkRestrictionMask;
    }

    cpu_pmaVal = __mfcr(0x8100);                                                              /* Read the CPU_PMA0 */

    cpu_pmaVal = enable ? (cpu_pmaVal | segmentNumberMask) : (cpu_pmaVal & ~segmentNumberMask); /* enable or disable the corresponding bitfield */

    /*The CPU_PMA registers are ENDINIT protected*/
    IfxScuWdt_clearCpuEndinitInline(&((*(Ifx_SCU*)0xF0036000u)).WDTCPU[coreIndex], wdtPassword);
    /*When changing the value of the CPU_PMAx registers both the instruction and data caches should be invalidated*/
    /*Write to PMA0 register for selecting the cacheability for data cache*/
    __dsync();      /* DSYNC instruction should be executed immediately prior to the MTCR*/
    __mtcr(0x8100, cpu_pmaVal);
    __isync();      /* ISYNC instruction executed immediately following MTCR */
    IfxScuWdt_setCpuEndinitInline(&((*(Ifx_SCU*)0xF0036000u)).WDTCPU[coreIndex], wdtPassword);
}


static inline void IfxCpu_enableSegmentSpecificInstructionAccessCacheability(uint16 segmentNumberMask, boolean enable)
{
    uint32 cpu_pmaVal;
    uint16 checkRestrictionMask;
    uint32 coreIndex   = IfxCpu_getCoreIndex();
    uint16 wdtPassword = IfxScuWdt_getCpuWatchdogPasswordInline(&((*(Ifx_SCU*)0xF0036000u)).WDTCPU[coreIndex]);

    /*resolve the restrictions*/
    /*In PMA1 Segment-D and Segment[7-CoreID] must have the same value */
    checkRestrictionMask = ((uint16)1 << (7 - coreIndex)) | ((uint16)1 << 0xD);

    if ((segmentNumberMask & checkRestrictionMask) != 0)
    {
        segmentNumberMask |= checkRestrictionMask;
    }

    cpu_pmaVal = __mfcr(0x8104);                                                              /* Read the CPU_PMA1 */

    cpu_pmaVal = enable ? (cpu_pmaVal | segmentNumberMask) : (cpu_pmaVal & ~segmentNumberMask); /* enable or disable the corresponding bitfield */

    /*The CPU_PMA registers are ENDINIT protected*/
    IfxScuWdt_clearCpuEndinitInline(&((*(Ifx_SCU*)0xF0036000u)).WDTCPU[coreIndex], wdtPassword);
    /*When changing the value of the CPU_PMAx registers both the instruction and data caches should be invalidated*/
    /*Write to PMA1 register for selecting the cacheability for data cache*/
    __dsync();      /* DSYNC instruction should be executed immediately prior to the MTCR */
    __mtcr(0x8104, cpu_pmaVal);
    __isync();      /* ISYNC instruction executed immediately following MTCR */
    IfxScuWdt_setCpuEndinitInline(&((*(Ifx_SCU*)0xF0036000u)).WDTCPU[coreIndex], wdtPassword);
}


static inline void IfxCpu_forceDisableInterrupts(void)
{
    __disable();
    __nop();
}


static inline Ifx_CPU *IfxCpu_getAddress(IfxCpu_ResourceCpu cpu)
{
    Ifx_CPU *module;

    if (cpu < IfxCpu_ResourceCpu_none)
    {
        module = (Ifx_CPU *)IfxCpu_cfg_indexMap[cpu].module;
    }
    else
    {
        module = ((void *)0);
    }

    return module;
}


static inline uint32 IfxCpu_getClockCounter(void)
{
    return IfxCpu_getPerformanceCounter(0xFC04);
}


static inline boolean IfxCpu_getClockCounterStickyOverflow(void)
{
    return IfxCpu_getPerformanceCounterStickyOverflow(0xFC04);
}


static inline IfxCpu_Id IfxCpu_getCoreId(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(0xFE1C);
    return (IfxCpu_Id)reg.B.CORE_ID;
}


static inline IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(0xFE1C);
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
}


static inline uint32 IfxCpu_getInstructionCounter(void)
{
    return IfxCpu_getPerformanceCounter(0xFC08);
}


static inline boolean IfxCpu_getInstructionCounterStickyOverflow(void)
{
    return IfxCpu_getPerformanceCounterStickyOverflow(0xFC08);
}


static inline uint32 IfxCpu_getPerformanceCounter(uint16 address)
{
    Ifx_CPU_CCNT ccnt;

    if (address == 0xFC04)
    {
        ccnt.U = __mfcr(0xFC04);
    }
    else if (address == 0xFC08)
    {
        ccnt.U = __mfcr(0xFC08);
    }
    else if (address == 0xFC0C)
    {
        ccnt.U = __mfcr(0xFC0C);
    }
    else if (address == 0xFC10)
    {
        ccnt.U = __mfcr(0xFC10);
    }
    else if (address == 0xFC14)
    {
        ccnt.U = __mfcr(0xFC14);
    }

    return ccnt.B.COUNTVALUE;
}


static inline boolean IfxCpu_getPerformanceCounterStickyOverflow(uint16 address)
{
    Ifx_CPU_CCNT ccnt;

    if (address == 0xFC04)
    {
        ccnt.U = __mfcr(0xFC04);
    }
    else if (address == 0xFC08)
    {
        ccnt.U = __mfcr(0xFC08);
    }
    else if (address == 0xFC0C)
    {
        ccnt.U = __mfcr(0xFC0C);
    }
    else if (address == 0xFC10)
    {
        ccnt.U = __mfcr(0xFC10);
    }
    else if (address == 0xFC14)
    {
        ccnt.U = __mfcr(0xFC14);
    }

    return ccnt.B.SOVF;
}


static inline void IfxCpu_initCSA(uint32 *csaBegin, uint32 *csaEnd)
{
    uint32  k;
    uint32  nxt_cxi_val = 0U;
    uint32 *prvCsa      = csaBegin;
    uint32 *nxtCsa      = csaBegin;
    uint32  numOfCsa    = (((uint32)csaEnd - (uint32)csaBegin) / 64U);

    for (k = 0U; k < numOfCsa; k++)
    {
        nxt_cxi_val = ((uint32)nxtCsa & (0XFU << 28U)) >> 12U | ((uint32)nxtCsa & (0XFFFFU << 6U)) >> 6U;

        if (k == 0U)
        {
            __mtcr(0xFE38, nxt_cxi_val);   /* store the new pcxi value to LCX */
        }
        else
        {
            *prvCsa = nxt_cxi_val;  /* Store null pointer in last CSA (= very first time!) */
        }

        if (k == (numOfCsa - 3U))
        {
            __mtcr(0xFE3C, nxt_cxi_val);   /* Last but 2 context save area is pointed in LCX to know if there is CSA depletion */
        }

        prvCsa  = (uint32 *)nxtCsa;
        nxtCsa += 16U;           /* next CSA */
    }

    *prvCsa = 0U;
}


static inline void IfxCpu_invalidateProgramCache(void)
{
    uint16 cpuWdtPassword = IfxScuWdt_getCpuWatchdogPassword();
    {
        IfxScuWdt_clearCpuEndinit(cpuWdtPassword);
        Ifx_CPU_PCON1 pcon1;
        pcon1.U       = __mfcr(0x9204);
        pcon1.B.PCINV = 1;
        __mtcr(0x9204, pcon1.U);
        IfxScuWdt_setCpuEndinit(cpuWdtPassword);
    }
}


static inline boolean IfxCpu_isAddressCachable(void *address)
{
    uint8 segment = (uint32)address >> 24;
    return ((segment == (8)) || (segment == (9))) ? (1u) : (0u);
}


static inline void IfxCpu_resetAndStartCounters(IfxCpu_CounterMode mode)
{
    Ifx_CPU_CCTRL cctrl;
    cctrl.U    = __mfcr(0xFC00);
    /*Disable the counters */
    cctrl.B.CE = 0;
    __mtcr(0xFC00, cctrl.U);

    /* reset the counters */
    __mtcr(0xFC04, 0);
    __mtcr(0xFC08, 0);
    __mtcr(0xFC0C, 0);
    __mtcr(0xFC10, 0);
    __mtcr(0xFC14, 0);

    /*Enable the counters, set the counter mode */
    cctrl.B.CE = 1;
    cctrl.B.CM = mode;
    __mtcr(0xFC00, cctrl.U);
}


static inline void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != (0u))
    {
        __enable();
    }
}


static inline void IfxCpu_setDataCache(boolean enable)
{
    uint32 coreIndex   = IfxCpu_getCoreIndex();
    uint16 wdtPassword = IfxScuWdt_getCpuWatchdogPasswordInline(&((*(Ifx_SCU*)0xF0036000u)).WDTCPU[coreIndex]);
    /*PCACHE enable steps */
    {                           /* Step 1: Set PCBYP to 0 if cache is enabled */
        IfxScuWdt_clearCpuEndinitInline(&((*(Ifx_SCU*)0xF0036000u)).WDTCPU[coreIndex], wdtPassword);
        Ifx_CPU_DCON0 dcon0;
        dcon0.U       = 0;
        dcon0.B.DCBYP = enable ? 0 : 1; /*depending on the enable bypas bit is reset/set */
        __mtcr(0x9040, dcon0.U);
        IfxScuWdt_setCpuEndinitInline(&((*(Ifx_SCU*)0xF0036000u)).WDTCPU[coreIndex], wdtPassword);
    }
    /* Step 2: Call Isync */
    __isync();
}


static inline void IfxCpu_setPerformanceCountersEnableBit(uint32 enable)
{
    Ifx_CPU_CCTRL cctrl;
    cctrl.U    = __mfcr(0xFC00);
    cctrl.B.CE = enable;
    __mtcr(0xFC00, cctrl.U);
}


static inline void IfxCpu_setProgramCache(boolean enable)
{
    if (enable)
    {                           /* Step 3: Initiate invalidation of current cache contents if any */
        Ifx_CPU_PCON1 pcon1;
        pcon1.U       = 0;
        pcon1.B.PCINV = 1;
        __mtcr(0x9204, pcon1.U);
    }

    uint32 coreIndex   = IfxCpu_getCoreIndex();
    uint16 wdtPassword = IfxScuWdt_getCpuWatchdogPasswordInline(&((*(Ifx_SCU*)0xF0036000u)).WDTCPU[coreIndex]);
    /*PCACHE enable steps */
    {                           /* Step 1: Set PCBYP to 0 if cache is enabled */
        IfxScuWdt_clearCpuEndinitInline(&((*(Ifx_SCU*)0xF0036000u)).WDTCPU[coreIndex], wdtPassword);
        Ifx_CPU_PCON0 pcon0;
        pcon0.U       = 0;
        pcon0.B.PCBYP = enable ? 0 : 1; /*depending on the enable bypass bit is reset/set */
        __mtcr(0x920C, pcon0.U);
        IfxScuWdt_setCpuEndinitInline(&((*(Ifx_SCU*)0xF0036000u)).WDTCPU[coreIndex], wdtPassword);
    }
    /* Step 2: Call Isync */
    __isync();
}


static inline void IfxCpu_setSafetyTaskIdentifier(boolean safetyId)
{
    Ifx_CPU_PSW psw;
    ((void)0);
    psw.U   = __mfcr(0xFE04);
    psw.B.S = safetyId;
    __mtcr(0xFE04, (uint32)psw.U);
}



static inline IfxCpu_Perf IfxCpu_stopCounters(void)
{
    IfxCpu_Perf result;
    /*Disable the counters, reset the control reg */
    /* Use inline assembly to ensure constant implementation, and execution of the measurement routines */
    Ifx__stopPerfCounters();

    Ifx_CPU_CCNT ccnt;
    ccnt.U                = __mfcr(0xFC04);
    result.clock.counter  = ccnt.B.COUNTVALUE;
    result.clock.overlfow = ccnt.B.SOVF;

    Ifx_CPU_ICNT icnt;
    icnt.U                      = __mfcr(0xFC08);
    result.instruction.counter  = icnt.B.COUNTVALUE;
    result.instruction.overlfow = icnt.B.SOVF;

    Ifx_CPU_M1CNT m1cnt;
    m1cnt.U                  = __mfcr(0xFC0C);
    result.counter1.counter  = m1cnt.B.COUNTVALUE;
    result.counter1.overlfow = m1cnt.B.SOVF;

    Ifx_CPU_M2CNT m2cnt;
    m2cnt.U                  = __mfcr(0xFC10);
    result.counter2.counter  = m2cnt.B.COUNTVALUE;
    result.counter2.overlfow = m2cnt.B.SOVF;

    Ifx_CPU_M3CNT m3cnt;
    m3cnt.U                  = __mfcr(0xFC14);
    result.counter3.counter  = m3cnt.B.COUNTVALUE;
    result.counter3.overlfow = m3cnt.B.SOVF;

    return result;
}



static inline void IfxCpu_triggerSwReset(void)
{
    ((*(Ifx_SCU*)0xF0036000u)).SWRSTCON.B.SWRSTREQ = 1;

    /* Wait till reset */
    while (1)
    {}
}


static inline void IfxCpu_updateClockCounter(uint32 count)
{
    IfxCpu_updatePerformanceCounter(0xFC04, count);
}


static inline void IfxCpu_updateInstructionCounter(uint32 count)
{
    IfxCpu_updatePerformanceCounter(0xFC08, count);
}


static inline void IfxCpu_updatePerformanceCounter(uint32 address, uint32 count)
{
    if(address){};
    Ifx_CPU_CCTRL cctrl;
    boolean       enableBit;
    /*Disable the counters */
    cctrl.U    = __mfcr(0xFC00);
    enableBit  = cctrl.B.CE;
    cctrl.B.CE = 0;
    __mtcr(0xFC00, cctrl.U);

    /*Update the counter value */
    count &= ~(1U << 31);       /*clear sticky overflow bit if set */
    __mtcr(address, count);

    /*restore the enable bit */
    cctrl.B.CE = enableBit;
    __mtcr(0xFC00, cctrl.U);
}



#line 51 "D:/RTOS_PROJEKT/erica/aurix_workspace/can_erika/ee/../Libraries/iLLD/TC38A/Tricore/Scu/Std/IfxScuWdt.c"

/******************************************************************************/
/*----------------------------------Macros------------------------------------*/
/******************************************************************************/

/** \brief Reset password of watchdog module.
 */


/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxScuWdt_changeCpuWatchdogPassword(uint16 password, uint16 newPassword)
{
    Ifx_SCU_WDTCPU     *watchdog = &((*(Ifx_SCU*)0xF0036000u)).WDTCPU[IfxCpu_getCoreIndex()];

    /* Read Config_0 register */
    Ifx_SCU_WDTCPU_CON0 wdt_con0;
    wdt_con0.U = watchdog->CON0.U;

    if (wdt_con0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        wdt_con0.B.ENDINIT = 1;
        wdt_con0.B.LCK     = 0;
        wdt_con0.B.PW      = password;

        /* Password ready. Store it to WDT_CON0 to unprotect the register */
        watchdog->CON0.U = wdt_con0.U;
    }

    /* Set new Password, ENDINT and LCK bit in Config_0 register */
    wdt_con0.B.ENDINIT = 1;
    wdt_con0.B.LCK     = 1;
    wdt_con0.B.PW      = newPassword;
    watchdog->CON0.U   = wdt_con0.U;

    /* read back ENDINIT and wait until it has been set */
    while (watchdog->CON0.B.ENDINIT == 0)
    {}
}


void IfxScuWdt_changeCpuWatchdogReload(uint16 password, uint16 reload)
{
    /* Select CPU Watchdog based on Core Id */
    uint32              coreId = IfxCpu_getCoreIndex();
    Ifx_SCU_WDTCPU     *wdt    = &((*(Ifx_SCU*)0xF0036000u)).WDTCPU[coreId];

    /* Read Config_0 register */
    Ifx_SCU_WDTCPU_CON0 wdt_con0;
    wdt_con0.U = wdt->CON0.U;

    if (wdt_con0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        wdt_con0.B.ENDINIT = 1;
        wdt_con0.B.LCK     = 0;
        wdt_con0.B.PW      = password;

        /* Password ready. Store it to WDT_CON0 to unprotect the register */
        wdt->CON0.U = wdt_con0.U;
    }

    /* Set new Reload value, set ENDINT and LCK bit in Config_0 register */
    wdt_con0.B.ENDINIT = 1;
    wdt_con0.B.LCK     = 1;
    wdt_con0.B.REL     = reload;
    wdt->CON0.U        = wdt_con0.U;

    /* read back ENDINIT and wait until it has been set */
    while (wdt->CON0.B.ENDINIT == 0)
    {}
}


void IfxScuWdt_changeGlobalEndinitPassword(uint16 password, uint16 newPassword)
{
    Ifx_SCU       *scu = &((*(Ifx_SCU*)0xF0036000u));

    /* Read EICON0 register */
    Ifx_SCU_EICON0 eicon0;
    eicon0.U = scu->EICON0.U;

    if (scu->EICON0.B.ENDINIT == 1)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        eicon0.B.ENDINIT = 0;
        eicon0.B.EPW     = password;

        /* Password ready. Store it to WDT_CON0 to unprotect the register */
        scu->EICON0.U = eicon0.U;
    }

    /* Set new Password, ENDINT  in EICON0 register */
    eicon0.U         = scu->EICON0.U;
    eicon0.B.ENDINIT = 1;
    eicon0.B.EPW     = newPassword;
    scu->EICON0.U    = eicon0.U;

    /* read back ENDINIT and wait until it has been set */
    while (scu->EICON0.B.ENDINIT == 0)
    {}
}


void IfxScuWdt_changeGlobalSafetyEndinitPassword(uint16 password, uint16 newPassword)
{
    Ifx_SCU        *scu = &((*(Ifx_SCU*)0xF0036000u));

    /* Read SEICON0 register */
    Ifx_SCU_SEICON0 seicon0;
    seicon0.U = scu->SEICON0.U;

    if (scu->SEICON0.B.ENDINIT == 1)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        seicon0.B.ENDINIT = 0;
        seicon0.B.EPW     = password;

        /* Password ready. Store it to SEICON0 to unprotect the register */
        scu->SEICON0.U = seicon0.U;
    }

    /* Set new Password, ENDINT  in SEICON0 register */
    seicon0.U         = scu->SEICON0.U;
    seicon0.B.ENDINIT = 1;
    seicon0.B.EPW     = newPassword;
    scu->SEICON0.U    = seicon0.U;

    /* read back ENDINIT and wait until it has been set */
    while (scu->SEICON0.B.ENDINIT == 0)
    {}
}


void IfxScuWdt_changeSafetyWatchdogPassword(uint16 password, uint16 newPassword)
{
    Ifx_SCU_WDTS     *watchdog = &((*(Ifx_SCU*)0xF0036000u)).WDTS;

    /* Read Config_0 register */
    Ifx_SCU_WDTS_CON0 wdt_con0;
    wdt_con0.U = watchdog->CON0.U;

    if (wdt_con0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        wdt_con0.B.ENDINIT = 1;
        wdt_con0.B.LCK     = 0;
        wdt_con0.B.PW      = password;

        /* Password ready. Store it to WDT_CON0 to unprotect the register */
        watchdog->CON0.U = wdt_con0.U;
    }

    /* Set new Password, ENDINT and LCK bit in Config_0 register */
    wdt_con0.B.ENDINIT = 1;
    wdt_con0.B.LCK     = 1;
    wdt_con0.B.PW      = newPassword;
    watchdog->CON0.U   = wdt_con0.U;

    /* read back ENDINIT and wait until it has been set */
    while (watchdog->CON0.B.ENDINIT == 0)
    {}
}


void IfxScuWdt_changeSafetyWatchdogReload(uint16 password, uint16 reload)
{
    /* Initialize pointer to Safety Watchdog */
    Ifx_SCU_WDTS     *wdt = &((*(Ifx_SCU*)0xF0036000u)).WDTS;

    /* Read Config_0 register */
    Ifx_SCU_WDTS_CON0 wdt_con0;
    wdt_con0.U = wdt->CON0.U;

    if (wdt_con0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        wdt_con0.B.ENDINIT = 1;
        wdt_con0.B.LCK     = 0;
        wdt_con0.B.PW      = password;

        /* Password ready. Store it to WDT_CON0 to unprotect the register */
        wdt->CON0.U = wdt_con0.U;
    }

    /* Set new Reload value, set ENDINT and LCK bit in Config_0 register */
    wdt_con0.B.ENDINIT = 1;
    wdt_con0.B.LCK     = 1;
    wdt_con0.B.REL     = reload;
    wdt->CON0.U        = wdt_con0.U;

    /* read back ENDINIT and wait until it has been set */
    while (wdt->CON0.B.ENDINIT == 0)
    {}
}


void IfxScuWdt_clearCpuEndinit(uint16 password)
{
    IfxScuWdt_clearCpuEndinitInline(&((*(Ifx_SCU*)0xF0036000u)).WDTCPU[IfxCpu_getCoreIndex()], password);
}


void IfxScuWdt_clearGlobalEndinit(uint16 password)
{
    Ifx_SCU       *scu = &((*(Ifx_SCU*)0xF0036000u));

    /* Read EICON0 register */
    Ifx_SCU_EICON0 eicon0;
    eicon0.U = scu->EICON0.U;

    if (scu->EICON0.B.ENDINIT == 1)
    {
        /* Clear ENDINT a bit in EICON0 register */
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        eicon0.B.ENDINIT = 0;
        eicon0.B.EPW     = password;

        /* Password ready. Store it to EICON0 to unprotect the register */
        scu->EICON0.U = eicon0.U;
    }

    /* read back ENDINIT and wait until it has been cleared */
    while (scu->EICON0.B.ENDINIT == 1)
    {}
}


void IfxScuWdt_clearGlobalSafetyEndinit(uint16 password)
{
    Ifx_SCU        *scu = &((*(Ifx_SCU*)0xF0036000u));

    /* Read SEICON0 register */
    Ifx_SCU_SEICON0 seicon0;
    seicon0.U = scu->SEICON0.U;

    if (scu->SEICON0.B.ENDINIT == 1)
    {
        /* Clear ENDINT a bit in SEICON0 register */
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        seicon0.B.ENDINIT = 0;
        seicon0.B.EPW     = password;

        /* Password ready. Store it to SEICON0 to unprotect the register */
        scu->SEICON0.U = seicon0.U;
    }

    /* read back ENDINIT and wait until it has been cleared */
    while (scu->SEICON0.B.ENDINIT == 1)
    {}
}


void IfxScuWdt_clearSafetyEndinit(uint16 password)
{
    IfxScuWdt_clearSafetyEndinitInline(password);
}


void IfxScuWdt_disableCpuWatchdog(uint16 password)
{
    /* Select CPU Watchdog based on Core Id */
    uint32          coreId = (uint32)IfxCpu_getCoreIndex();
    Ifx_SCU_WDTCPU *wdt    = &((*(Ifx_SCU*)0xF0036000u)).WDTCPU[coreId];

    IfxScuWdt_clearCpuEndinitInline(wdt, password);
    wdt->CON1.B.DR = 1;         //Set DR bit in Config_1 register
    IfxScuWdt_setCpuEndinitInline(wdt, password);
}


void IfxScuWdt_disableSafetyWatchdog(uint16 password)
{
    IfxScuWdt_clearSafetyEndinitInline(password);
    (*(volatile Ifx_SCU_WDTS_CON1*)0xF00362ACu).B.DR = 1;     //Set DR bit in Config_1 register
    IfxScuWdt_setSafetyEndinitInline(password);
}


void IfxScuWdt_enableCpuWatchdog(uint16 password)
{
    /* Select CPU Watchdog based on Core Id */
    uint32          coreId = (uint32)IfxCpu_getCoreIndex();
    Ifx_SCU_WDTCPU *wdt    = &((*(Ifx_SCU*)0xF0036000u)).WDTCPU[coreId];

    IfxScuWdt_clearCpuEndinitInline(wdt, password);
    wdt->CON1.B.DR = 0;         //Clear DR bit in Config_1 register
    IfxScuWdt_setCpuEndinitInline(wdt, password);
}


void IfxScuWdt_enableSafetyWatchdog(uint16 password)
{
    IfxScuWdt_clearSafetyEndinitInline(password);
    (*(volatile Ifx_SCU_WDTS_CON1*)0xF00362ACu).B.DR = 0;     //Clear DR bit in Config_1 register
    IfxScuWdt_setSafetyEndinitInline(password);
}


uint16 IfxScuWdt_getCpuWatchdogPassword(void)
{
    return IfxScuWdt_getCpuWatchdogPasswordInline(&((*(Ifx_SCU*)0xF0036000u)).WDTCPU[IfxCpu_getCoreIndex()]);
}


boolean IfxScuWdt_getCpuWatchdogEndInit(void)
{
    return (boolean)IfxScuWdt_getCpuWatchdogEndInitInline(&((*(Ifx_SCU*)0xF0036000u)).WDTCPU[IfxCpu_getCoreIndex()]);
}


uint16 IfxScuWdt_getGlobalEndinitPassword(void)
{
    Ifx_SCU *scu = &((*(Ifx_SCU*)0xF0036000u));
    uint16   password;

    /* Read Password from CON0 register
     * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
     * to toggle them before returning password */
    password  = scu->EICON0.B.EPW;
    password ^= 0x003F;

    return password;
}


uint16 IfxScuWdt_getGlobalSafetyEndinitPassword(void)
{
    Ifx_SCU *scu = &((*(Ifx_SCU*)0xF0036000u));
    uint16   password;

    /* Read Password from CON0 register
     * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
     * to toggle them before returning password */
    password  = scu->SEICON0.B.EPW;
    password ^= 0x003F;

    return password;
}


uint16 IfxScuWdt_getSafetyWatchdogPassword(void)
{
    return IfxScuWdt_getSafetyWatchdogPasswordInline();
}


void IfxScuWdt_initConfig(IfxScuWdt_Config *config)
{
    config->password                      = (0x3CU);
    config->reload                        = 0xFFFC;
    config->inputFrequency                = IfxScu_WDTCON1_IR_divBy16384;
    config->disableWatchdog               = (0u);
    config->enableSmuRestriction          = (0u);
    config->enableAutomaticPasswordChange = (0u);
    config->enableTimerCheck              = (0u);
    config->enableTimerCheckTolerance     = (0u);
    config->clrInternalResetFlag          = (0u);
    config->globalEndInitInputFrequency   = IfxScu_WDTCON1_IR_divBy16384;
}


void IfxScuWdt_initCpuWatchdog(Ifx_SCU_WDTCPU *wdt, const IfxScuWdt_Config *config)
{
    Ifx_SCU_WDTCPU_CON0 wdt_con0;
    Ifx_SCU_WDTCPU_CON1 wdt_con1;

    /* Read Config_0 register and clear wdt_con1 variable */
    wdt_con0.U = wdt->CON0.U;
    wdt_con1.U = 0;

    if (wdt_con0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        wdt_con0.B.ENDINIT = 1;
        wdt_con0.B.LCK     = 0;
        wdt_con0.B.PW     ^= 0x003F;

        /* Password ready. Store it to WDT_CON0 to unprotect the register */
        wdt->CON0.U = wdt_con0.U;
    }

    /* Initialize CON0 register, with modify access, with user defined parameters
     * Clear ENDINT bit to unprotect CON1 register for initialization
     * see Table 3 (Modify Access Bit Pattern Requirements) */
    wdt_con0.B.ENDINIT = 0;
    wdt_con0.B.LCK     = 1;
    wdt_con0.B.PW      = config->password; //user defined password
    wdt_con0.B.REL     = config->reload;   //user defined reload value

    /* Modify access ready - write WDT_CON0 register */
    wdt->CON0.U = wdt_con0.U;

    /* read back ENDINIT and wait until it has been cleared */
    while (wdt->CON0.B.ENDINIT == 1)
    {}

    /* Initialize CON1 register */
    switch (config->inputFrequency)
    {
    case IfxScu_WDTCON1_IR_divBy16384:
        wdt_con1.B.IR0 = 0;
        wdt_con1.B.IR1 = 0;
        break;
    case IfxScu_WDTCON1_IR_divBy256:
        wdt_con1.B.IR0 = 1;
        wdt_con1.B.IR1 = 0;
        break;
    case IfxScu_WDTCON1_IR_divBy64:
        wdt_con1.B.IR0 = 0;
        wdt_con1.B.IR1 = 1;
        break;
    }

    wdt_con1.B.DR   = config->disableWatchdog ? 1 : 0;
    wdt_con1.B.UR   = config->enableSmuRestriction ? 1 : 0;
    wdt_con1.B.PAR  = config->enableAutomaticPasswordChange ? 1 : 0;
    wdt_con1.B.TCR  = config->enableTimerCheck ? 1 : 0;
    wdt_con1.B.TCTR = config->enableTimerCheckTolerance ? 1 : 0;

    /* Finally write CON1 with user defined configuration */
    wdt->CON1.U = wdt_con1.U;

    /* Global EI register initialisation */
    {
        Ifx_SCU_EICON1 eicon1;
        Ifx_SCU       *scu = &((*(Ifx_SCU*)0xF0036000u));

        eicon1.U = 0;

        switch (config->globalEndInitInputFrequency)
        {
        case IfxScu_WDTCON1_IR_divBy16384:
            eicon1.B.IR0 = 0;
            eicon1.B.IR1 = 0;
            break;
        case IfxScu_WDTCON1_IR_divBy256:
            eicon1.B.IR0 = 1;
            eicon1.B.IR1 = 0;
            break;
        case IfxScu_WDTCON1_IR_divBy64:
            eicon1.B.IR0 = 0;
            eicon1.B.IR1 = 1;
            break;
        }

        eicon1.B.DR   = config->disableWatchdog ? 1 : 0;
        scu->EICON1.U = eicon1.U;
    }

    /* Initialization finished - set CPU ENDINIT protection */
    IfxScuWdt_setCpuEndinit(config->password);
}


void IfxScuWdt_initSafetyWatchdog(Ifx_SCU_WDTS *wdt, const IfxScuWdt_Config *config)
{
    Ifx_SCU_WDTS_CON0 wdt_con0;
    Ifx_SCU_WDTS_CON1 wdt_con1;

    /* Read Config_0 register and clear wdt_con1 variable */
    wdt_con0.U = wdt->CON0.U;
    wdt_con1.U = 0;

    if (wdt_con0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        wdt_con0.B.ENDINIT = 1;
        wdt_con0.B.LCK     = 0;
        wdt_con0.B.PW     ^= 0x003F;

        /* Password ready. Store it to WDT_CON0 to unprotect the register */
        wdt->CON0.U = wdt_con0.U;
    }

    /* Initialize CON0 register, with modify access, with user defined parameters
     * Clear ENDINT bit to unprotect CON1 register for initialization
     * see Table 3 (Modify Access Bit Pattern Requirements) */
    wdt_con0.B.ENDINIT = 0;
    wdt_con0.B.LCK     = 1;
    wdt_con0.B.PW      = config->password; //user defined password
    wdt_con0.B.REL     = config->reload;   //user defined reload value

    /* Modify access ready - write WDT_CON0 register */
    wdt->CON0.U = wdt_con0.U;

    /* read back ENDINIT and wait until it has been cleared */
    while (wdt->CON0.B.ENDINIT == 1)
    {}

    /* Initialize CON1 register */
    switch (config->inputFrequency)
    {
    case IfxScu_WDTCON1_IR_divBy16384:
        wdt_con1.B.IR0 = 0;
        wdt_con1.B.IR1 = 0;
        break;
    case IfxScu_WDTCON1_IR_divBy256:
        wdt_con1.B.IR0 = 1;
        wdt_con1.B.IR1 = 0;
        break;
    case IfxScu_WDTCON1_IR_divBy64:
        wdt_con1.B.IR0 = 0;
        wdt_con1.B.IR1 = 1;
        break;
    }

    wdt_con1.B.DR     = config->disableWatchdog ? 1 : 0;
    wdt_con1.B.UR     = config->enableSmuRestriction ? 1 : 0;
    wdt_con1.B.PAR    = config->enableAutomaticPasswordChange ? 1 : 0;
    wdt_con1.B.TCR    = config->enableTimerCheck ? 1 : 0;
    wdt_con1.B.TCTR   = config->enableTimerCheckTolerance ? 1 : 0;
    wdt_con1.B.CLRIRF = config->clrInternalResetFlag ? 1 : 0;

    /* Finally write CON1 with user defined configuration */
    wdt->CON1.U = wdt_con1.U;

    /* Global EI register initialisation */
    {
        Ifx_SCU_SEICON1 seicon1;
        Ifx_SCU        *scu = &((*(Ifx_SCU*)0xF0036000u));

        seicon1.U = 0;

        switch (config->globalEndInitInputFrequency)
        {
        case IfxScu_WDTCON1_IR_divBy16384:
            seicon1.B.IR0 = 0;
            seicon1.B.IR1 = 0;
            break;
        case IfxScu_WDTCON1_IR_divBy256:
            seicon1.B.IR0 = 1;
            seicon1.B.IR1 = 0;
            break;
        case IfxScu_WDTCON1_IR_divBy64:
            seicon1.B.IR0 = 0;
            seicon1.B.IR1 = 1;
            break;
        }

        seicon1.B.DR   = config->disableWatchdog ? 1 : 0;
        scu->SEICON1.U = seicon1.U;
    }

    /* Initialization finished - set Safety ENDINIT protection */
    IfxScuWdt_setSafetyEndinit(config->password);
}


void IfxScuWdt_serviceCpuWatchdog(uint16 password)
{
    IfxScuWdt_setCpuEndinit(password);
}


void IfxScuWdt_serviceSafetyWatchdog(uint16 password)
{
    IfxScuWdt_setSafetyEndinit(password);
}


void IfxScuWdt_setCpuEndinit(uint16 password)
{
    IfxScuWdt_setCpuEndinitInline(&((*(Ifx_SCU*)0xF0036000u)).WDTCPU[IfxCpu_getCoreIndex()], password);
}


void IfxScuWdt_setGlobalEndinit(uint16 password)
{
    Ifx_SCU       *scu = &((*(Ifx_SCU*)0xF0036000u));
    /* Read EICON0 register */
    Ifx_SCU_EICON0 eicon0;
    eicon0.U = scu->EICON0.U;

    /* Set ENDINT bit in EICON register */
    if (scu->EICON0.B.ENDINIT == 0)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        eicon0.B.ENDINIT = 1;
        eicon0.B.EPW     = password;

        /* Password ready. Store it to EICON0 to unprotect the register */
        scu->EICON0.U = eicon0.U;
    }

    /* read back ENDINIT and wait until it has been set */
    while (scu->EICON0.B.ENDINIT == 0)
    {}
}


void IfxScuWdt_setGlobalSafetyEndinit(uint16 password)
{
    Ifx_SCU        *scu = &((*(Ifx_SCU*)0xF0036000u));

    /* Read SEICON0 register */
    Ifx_SCU_SEICON0 seicon0;
    seicon0.U = scu->SEICON0.U;

    if (scu->SEICON0.B.ENDINIT == 0)
    {
        /* Set ENDINT bit in SEICON register */
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        seicon0.B.ENDINIT = 1;
        seicon0.B.EPW     = password;

        /* Password ready. Store it to SEICON0 to unprotect the register */
        scu->SEICON0.U = seicon0.U;
    }

    /* read back ENDINIT and wait until it has been set */
    while (scu->SEICON0.B.ENDINIT == 0)
    {}
}


void IfxScuWdt_setSafetyEndinit(uint16 password)
{
    IfxScuWdt_setSafetyEndinitInline(password);
}


boolean IfxScuWdt_enableWatchdogWithDebugger(void)
{
    boolean          status = 0, oenEnabled = 0, watchdogEnabled = 0;
    uint32           ostateValue;

    volatile uint32 *oecPtr    = (volatile uint32 *)0xF0000478;
    volatile uint32 *ostatePtr = (volatile uint32 *)0xF0000480;
    volatile uint32 *ocntrlPtr = (volatile uint32 *)0xF000047C;

    /* read OSTATE.OEN */
    ostateValue = *ostatePtr;
    oenEnabled  = (ostateValue & 0x00000001);

    if (!oenEnabled)
    {
        /* enable the debug interface (OSTATE.OEN )if it is not already enabled */
        /* pattern for enabling OSTATE.OEN */
        *oecPtr = 0xA1;
        *oecPtr = 0x5E;
        *oecPtr = 0xA1;
        *oecPtr = 0x5E;

        /* read OSTATE.OEN again*/
        ostateValue = *ostatePtr;
        oenEnabled  = (ostateValue & 0x00000001);
    }

    if (oenEnabled)
    {
        /* set watchdog suspend bit in OSTATE reg, by writing OCNTRL.WDTSUS and OCNTRL.WDTSUS_P together */
        *ocntrlPtr = 0x00003000;
    }
    else
    {
        status = 1;
    }

    ((void)0);

    /* read OSTATE.WDTSUS */
    ostateValue     = *ostatePtr;
    watchdogEnabled = (ostateValue & 0x00000080);

    if (!watchdogEnabled)
    {
        status = 1;
    }

    ((void)0);

    return status;
}


uint8 IfxScuWdt_getCpuWatchdogStatus(void)
{
    Ifx_SCU *scu = &((*(Ifx_SCU*)0xF0036000u));
    return scu->WDTCPU[IfxCpu_getCoreIndex()].SR.B.DS;
}
