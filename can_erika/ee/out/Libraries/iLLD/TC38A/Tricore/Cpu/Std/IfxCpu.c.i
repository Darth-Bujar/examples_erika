#line 1 "D:/RTOS_PROJEKT/erica/aurix_workspace/can_erika/ee/../Libraries/iLLD/TC38A/Tricore/Cpu/Std/IfxCpu.c"
/**
 * \file IfxCpu.c
 * \brief CPU  basic functionality
 *
 * \version iLLD_1_0_1_15_0_1
 * \copyright Copyright (c) 2019 Infineon Technologies AG. All rights reserved.
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 */

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/


#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\ee\\..\\Libraries\\iLLD\\TC38A\\Tricore\\Cpu\\Std\\IfxCpu.h"
/**
 * \file IfxCpu.h
 * \brief CPU  basic functionality
 * \ingroup IfxLld_Cpu
 *
 * \version iLLD_1_0_1_15_0_1
 * \copyright Copyright (c) 2021 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 *
 * \defgroup IfxLld_Cpu_Std_Core Cpu Core Functions
 * \ingroup IfxLld_Cpu_Std
 * \defgroup IfxLld_Cpu_Std_Interrupt Interrupt Utility Functions
 * \ingroup IfxLld_Cpu_Std
 * \defgroup IfxLld_Cpu_Std_Cache Cache Management Functions
 * \ingroup IfxLld_Cpu_Std
 * \defgroup IfxLld_Cpu_Std_PerformanceCounter Performance Counter Functions
 * \ingroup IfxLld_Cpu_Std
 * \defgroup IfxLld_Cpu_Std_Synchronization Synchronization Functions
 * \ingroup IfxLld_Cpu_Std
 * \defgroup IfxLld_Cpu_Std_Utility Cpu Utility Functions
 * \ingroup IfxLld_Cpu_Std
 * \defgroup IfxLld_Cpu_Std_Enum Enumerations
 * \ingroup IfxLld_Cpu_Std
 * \defgroup IfxLld_Cpu_Std_DataStructures Data Structures
 * \ingroup IfxLld_Cpu_Std
 */




/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/


#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\_Impl\\IfxCpu_cfg.h"
/**
 * \file IfxCpu_cfg.h
 * \brief CPU on-chip implementation data
 * \ingroup IfxLld_Cpu
 *
 * \version iLLD_1_0_1_15_0_1
 * \copyright Copyright (c) 2018 Infineon Technologies AG. All rights reserved.
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * \defgroup IfxLld_Cpu CPU
 * \ingroup IfxLld
 * \defgroup IfxLld_Cpu_Impl Implementation
 * \ingroup IfxLld_Cpu
 * \defgroup IfxLld_Cpu_Std Standard Driver
 * \ingroup IfxLld_Cpu
 */




/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/


#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Cpu\\Std\\IfxCpu_Intrinsics.h"
/**
 * \file IfxCpu_Intrinsics.h
 * \ingroup IfxLld_Cpu_Intrinsics Intrinsics
 *
 * \version iLLD_1_0_1_15_0_1
 * \copyright Copyright (c) 2013 Infineon Technologies AG. All rights reserved.
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * \defgroup IfxLld_Cpu_Intrinsics Intrinsics
 * \ingroup IfxLld_Cpu_Std
 *
 */


/******************************************************************************/

#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Cpu\\Std\\Ifx_Types.h"
/**
 * \file Ifx_Types.h
 * \brief This files defines all types used by the IFX HAL and libraries
 *
 * \version iLLD_1_0_1_15_0_1
 * \copyright Copyright (c) 2018 Infineon Technologies AG. All rights reserved.
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */




/******************************************************************************/

#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\Infra\\Platform\\Tricore\\Compilers\\Compilers.h"
/**
 * \file Compilers.h
 *
 * \copyright Copyright (c) 2013 Infineon Technologies AG. All rights reserved.
 *
 * $Date: 2014-04-07 12:13:19 GMT$
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */




/******************************************************************************/


#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Configurations\\Ifx_Cfg.h"
/**********************************************************************************************************************
 * \file Ifx_Cfg.h
 * \brief Project configuration file.
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/




/*********************************************************************************************************************/
/*------------------------------------------Configuration for IfxScu_cfg.h-------------------------------------------*/
/*********************************************************************************************************************/
/* External oscillator frequency in Hz */

/* System PLL frequency in Hz */


/* Peripheral PLL1 frequency in Hz */

/* Peripheral PLL2 frequency in Hz */


/*********************************************************************************************************************/
/*-----------------------------------Configuration for Software managed interrupt------------------------------------*/
/*********************************************************************************************************************/
/* #define IFX_USE_SW_MANAGED_INT */ /* Decomment this line if the project needs to use Software managed interrupts */

/*********************************************************************************************************************/
/*---------------------------------Configuration for Trap Hook Functions' Extensions---------------------------------*/
/*********************************************************************************************************************/
/* #define IFX_CFG_EXTEND_TRAP_HOOKS */ /* Decomment this line if the project needs to extend trap hook functions */


#line 47 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\Infra\\Platform\\Tricore\\Compilers\\Compilers.h"

/*this file shall not be modified by the user, IFX_XXXX defines shall be defined in Ifx_Cfg.h */





































#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\Infra\\Platform\\Tricore\\Compilers\\CompilerTasking.h"
/**
 * \file CompilerTasking.h
 *
 * \version iLLD_New
 * \copyright Copyright (c) 2013 Infineon Technologies AG. All rights reserved.
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */




/******************************************************************************/


#line 1 "C:\\Infineon\\AURIX-Studio-1.9.4\\plugins\\com.infineon.aurix.tools_1.9.4\\build_system\\tools\\Compilers\\Tasking_1.1r8\\ctc\\include\\stddef.h"
/**************************************************************************
**                                                                        *
**  FILE        :  stddef.h                                               *
**                                                                        *
**  DESCRIPTION :  Include file with macros for common use                *
**                                                                        *
**  Copyright 1996-2022 Altium BV                                         *
**                                                                        *
**************************************************************************/






#pragma nomisrac 19.7,19.10,20.1







typedef __size_t        size_t;




typedef __wchar_t       wchar_t;



typedef __ptrdiff_t     ptrdiff_t;













#pragma nomisrac restore


#line 47 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\Infra\\Platform\\Tricore\\Compilers\\CompilerTasking.h"

/*Linker definitions which are specific to Tasking */
/* IFX_CFG_USE_COMPILER_DEFAULT_LINKER shall be defined in Ifx_Cfg.h
 * to use the default compiler linker varaibles and startup */



/*Start: Common definitions ********************************************** */



/*End: Common definitions ********************************************** */

/*Start: Core 0 definitions ********************************************** */

















/*Wrapper macros for the tool specific definitions */















/******************************************************************************/






/* FXIME check how to pack structure members */





/* Note that __REVISION__ is only available for tasking compiler! */


/******************************************************************************/








/* *INDENT-OFF* */









/* *INDENT-ON* */

/******************************************************************************/



/******************************************************************************/
/*Memory qualifiers*/























/******************************************************************************/


#line 86 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\Infra\\Platform\\Tricore\\Compilers\\Compilers.h"

















































/* Functions prototypes                                                       */
/******************************************************************************/
void Ifx_C_Init(void);
/******************************************************************************/



#line 47 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Cpu\\Std\\Ifx_Types.h"

#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Cpu\\Std\\Platform_Types.h"
/**
 * \file Platform_Types.h
 *
 * \version iLLD_1_0_1_15_0_1
 * \copyright Copyright (c) 2020 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */



/******************************************************************************
**                      Includes                                             **
******************************************************************************/

/******************************************************************************
**                      Global Macro Definitions                             **
******************************************************************************/








/* [cover parentID={5294D975-045A-4d91-9A1A-B1765FAB4653}] */
/* CPU register width type definition */



/* Register width of CPU*/

/* [/cover] */


/* [cover parentID={FBA2FA55-430B-4dfb-82B1-C791F0878F9B}] */
/* Bit order type definition*/


/* Bit order of Register level*/

/* [/cover] */


/* [cover parentID={0E2E6A28-264A-4d32-96EE-5F5C93286311}] */
/* Byte order type definition*/


/* Byte order on Memory level*/

/* [/cover] */


/* TRUE, FALSE symbol for Boolean types*/
/* [cover parentID={FF7F9840-8904-4b7d-83A7-988524B795DE}] */






/* [/cover] */
/******************************************************************************
**                      Global Type Definitions                              **
******************************************************************************/
/* AUTOSAR integer data types*/

/* unsigned char with a bit length that is the shortest one natively supported
  by the platform.*/
/* [cover parentID={F7B51F71-6687-4e05-8408-7F5AAC55C638}] boolean [/cover]*/
typedef unsigned char       boolean;        /* for use with TRUE/FALSE      */

/* 8bit unsigned :  0 .. 255 [0X00 .. 0XFF]*/
/* [cover parentID={4269E5AB-7F28-4803-8D60-7B4EC91CB087}] uint8 [/cover] */
typedef unsigned char       uint8;

/* 16bit unsigned:  0..65535 [0x0000..0xFFFF]*/
/* [cover parentID={66E964CA-35D5-4013-BB61-1E824636D713}] uint16 [/cover] */
typedef unsigned short      uint16;

/* 32bit unsigned:  0..4294967295 [0x00000000..0xFFFFFFFF]*/
/* [cover parentID={DA33B7A0-7CD3-45e7-9C9A-6D63FB8BA3DC}] uint32 [/cover] */
typedef unsigned long       uint32;

/* 64bit unsigned
*          0..18446744073709551615   [0x0000000000000000..0xFFFFFFFFFFFFFFFF]*/
/* [cover parentID={3409E2A3-BF2D-44a5-9B00-A72300848166}] uint64 */
typedef unsigned long long  uint64;

/* 8bit signed, 7 bit + 1 bit sign -128..+127 [0x80..0x7F]*/
/* [cover parentID={94E0756B-993D-4cae-9499-416CDFD6FEAF}] sint8[/cover]*/
typedef signed char         sint8;

/* 16bit signed, 15 bit + 1 bit sign -32768..+32767 [0x8000..0x7FFF]*/
/* [cover parentID={B3482DFF-8DFF-41bd-95E0-0406E2451CB0}] sint16 [/cover]*/
typedef short               sint16;

/* 32bit signed, 31 bit + 1 bit sign
 -2147483648..+2147483647 [0x80000000..0x7FFFFFFF]*/
/* [cover parentID={B027B471-A1A2-456c-A015-35F4A34A88EF}] sint32 [/cover]*/
typedef long                sint32;
/*
* 64bit signed, 63 bit + 1 bit sign
* -9223372036854775808..9223372036854775807
* [0x8000000000000000..0x7FFFFFFFFFFFFFFF]
*/
/* [cover parentID={3CF3471C-EB1A-450c-B78F-4B96D226A1F5}] sint64 [/cover]*/
typedef long long           sint64;

/* At least 8 bit*/
/* [cover parentID={F8719785-0A16-486e-AB85-0A2859402037}] uint8_least[/cover]*/
typedef unsigned long       uint8_least;

/* At least 16 bit*/
/* [cover parentID={BEAD868D-0EC1-44f0-AFEE-B57401CC9E65}]uint16_least[/cover]*/
typedef unsigned long       uint16_least;

/* least 32 bit*/
/* [cover parentID={9B9CC46A-0F61-4d25-8001-679CF210C135}]uint32_least[/cover]*/
typedef unsigned long       uint32_least;

/* At least 7 bit + 1 bit sign*/
/* [cover parentID={5C0DE046-8407-4708-8D26-41B96731D89D}]sint8_least[/cover]*/
typedef signed long         sint8_least;

/* At least 15 bit + 1 bit sign*/
/* [cover parentID={0A83DB6E-ECD8-42f0-B97C-057F9FBFEB6E}]sint16_least[/cover]*/
typedef signed long         sint16_least;

/* At least 31 bit + 1 bit sign*/
/* [cover parentID={A65F0248-A0A7-4ab7-BAFA-A5428F4E8A96}]sint32_least[/cover]*/
typedef signed long         sint32_least;

/* IEEE754-2008 single precision
* -3.4028235e+38..+3.4028235e+38*/
/* [cover parentID={BBC4F70E-DA81-4d37-BCA4-628A89B29517}] float32  [/cover]*/
typedef float               float32;        /* IEEE754-2008 single precision */

/* IEEE754-2008 double precision
* -1.7976931348623157e+308..+1.7976931348623157e+308*/
/* [cover parentID={0D62172C-9309-493a-8028-06A7299D7906}] float64 [/cover]*/
typedef double              float64;        /* IEEE754-2008 double precision */


/******************************************************************************
**                      Global Constant Declarations                         **
******************************************************************************/

/******************************************************************************
**                      Global Variable Declarations                         **
******************************************************************************/

/******************************************************************************
**                      Global Function Declarations                         **
******************************************************************************/


#line 48 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Cpu\\Std\\Ifx_Types.h"

/*******************************************************************************
**                      Global Data Types                                     **
**                      (Types not defined by AUTOSAR)                        **
*******************************************************************************/
typedef const char        *pchar;                           /**< \brief const char pointer                               */
typedef void              *pvoid;                           /**< \brief void pointer                                     */
typedef volatile void     *vvoid;                           /**< \brief volatile void pointer                            */
typedef void              (*voidfuncvoid) (void);           /**< \brief void pointer which takes void argument           */

typedef struct
{
    float32 real;               /**< \brief Real part */
    float32 imag;               /**< \brief Imaginary part */
} cfloat32;

typedef struct
{
    sint32 real;				/**< \brief Real part */
    sint32 imag;				/**< \brief Imaginary part */
} csint32;

typedef struct
{
    sint16 real;				/**< \brief Real part */
    sint16 imag;				/**< \brief Imaginary part */
} csint16;

typedef sint64             Ifx_TickTime;    /**< \brief Time in ticks */












typedef sint16 Ifx_SizeT;                       /**< \brief Type used for data stream size */


/** \brief Circular buffer definition. */
typedef struct
{
    void  *base;                   /**< \brief buffer base address */
    uint16 index;                  /**< \brief buffer current index */
    uint16 length;                 /**< \brief buffer length*/
} Ifx_CircularBuffer;

typedef uint16 Ifx_Priority;       /**< \brief Used in interrupt service priorities */
typedef uint32 Ifx_TimerValue;     /**< \brief Used in timer values */
typedef sint32 Ifx_SignedTimerVal; /**< \brief Used in signed timer values */

typedef pvoid  Ifx_AddressValue;   /**< \brief Used in address values */

typedef struct
{
    uint16 priority;
    uint16 provider;
} Ifx_IsrSetting;

/** \brief Signal active state definition. */
typedef enum
{
    Ifx_ActiveState_low  = 0,       /**< \brief The signal is low active */
    Ifx_ActiveState_high = 1        /**< \brief The signal is high active */
} Ifx_ActiveState;

typedef enum
{
    Ifx_ParityMode_even = 0,
    Ifx_ParityMode_odd  = 1
} Ifx_ParityMode;

/** \brief input multiplexer definition used in PinMaps
 */
typedef enum
{
    Ifx_RxSel_a,
    Ifx_RxSel_b,
    Ifx_RxSel_c,
    Ifx_RxSel_d,
    Ifx_RxSel_e,
    Ifx_RxSel_f,
    Ifx_RxSel_g,
    Ifx_RxSel_h
} Ifx_RxSel;

/** \brief Module address and index map */
typedef struct
{
    volatile void *module;      /**< \brief Module address */
    sint32         index;       /**< \brief Module index */
} IfxModule_IndexMap;

typedef struct
{
    Ifx_TickTime timestamp;
    uint8        data;
}Ifx_DataBufferMode_TimeStampSingle;

/*
 * typedef struct
 * {
 *  Ifx_TickTime timestamp;
 *  uint8 count[1];     // Number of valid data
 *  uint8 data[7];
 * }Ifx_DataBufferMode_TimeStampBurst;
 */

typedef enum
{
    Ifx_DataBufferMode_normal = 0,           /**< \brief normal mode, each received byte is moved to the rx fifo */
    Ifx_DataBufferMode_timeStampSingle,      /**< \brief Single byte type stamp mode. The rx fifo is filled in with Ifx_DataBufferMode_TimeStampSingle items. */
//    Ifx_DataBufferMode_timeStameBurst      /**< \brief Burst byte type stamp mode. The rx fifo is filled in with Ifx_DataBufferMode_TimeStampBurst items. */
}Ifx_DataBufferMode;

/**
 * Defines the PWM modes
 *
 * The 1st member shall start with value 0, and the next members value shall be the previous member +1
 * pwmMode_off shall be the member with the higher index
 * \note enum order and values should not be modified, except Ifx_Pwm_Mode_init and Ifx_Pwm_Mode_count
 */
typedef enum
{
    Ifx_Pwm_Mode_centerAligned         = 0, /**< \brief Center aligned mode */
    Ifx_Pwm_Mode_centerAlignedInverted = 1, /**< \brief Center aligned inverted aligned mode */
    Ifx_Pwm_Mode_leftAligned           = 2, /**< \brief Left aligned mode. The PWM period starts with a rising edge */
    Ifx_Pwm_Mode_rightAligned          = 3, /**< \brief Right aligned mode. The PWM period starts with a falling edge*/
    Ifx_Pwm_Mode_off                   = 4, /**< \brief All switch open */
    Ifx_Pwm_Mode_init                  = 5, /**< \brief Initialisation mode, do not use at run time */
    Ifx_Pwm_Mode_count                      /**< \brief Number of defined modes */
} Ifx_Pwm_Mode;






#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Cpu\\Std\\Ifx_TypesTasking.h"
/**
 * \file Ifx_TypesTasking.h
 * \version iLLD_1_0_1_15_0_1
 * \copyright Copyright (c) 2012 Infineon Technologies AG. All rights reserved.
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */


/******************************************************************************/




/******************************************************************************/

/******************************************************************************/


#line 191 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Cpu\\Std\\Ifx_Types.h"














typedef struct
{
    __fract real;				/**< \brief Real part */
    __fract imag;				/**< \brief Imaginary part */
} cfract;

typedef struct
{
    __sfract real;				/**< \brief Real part */
    __sfract imag;				/**< \brief Imaginary part */
} csfract;









#line 48 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Cpu\\Std\\IfxCpu_Intrinsics.h"









#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Cpu\\Std\\IfxCpu_IntrinsicsTasking.h"
/**
 * \file IfxCpu_IntrinsicsTasking.h
 *
 * \version iLLD_1_0_1_15_0_1
 * \copyright Copyright (c) 2019 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * \defgroup IfxLld_Cpu_Intrinsics_Tasking Intrinsics for TASKING compiler
 * \ingroup IfxLld_Cpu_Intrinsics
 *
 */


/******************************************************************************/

/******************************************************************************/
/* *INDENT-OFF* */


/** Function call without return
 */


/** Jump and link
 */
static inline void Ifx__jump_and_link(void (*fun)(void))
{
	__asm("jli %0"::"a"(fun));
}

static inline void Ifx__moveToDataParam0(unsigned int var)
{
	__asm("mov d4, %0"::"d"(var));
}

static inline void Ifx__moveToAddrParam0(const void *var)
{
	__asm("mov.aa a4, %0"::"a"(var));
}

static inline unsigned int Ifx__getDataParamRet(void)
{
	unsigned int var;
	__asm(" mov\t %0, d2":"=d"(var));
	return var;
}

static inline void Ifx__moveToDataParamRet(unsigned int var)
{
	__asm("mov d2, %0"::"d"(var));
}

static inline void Ifx__jumpToFunction(const void *fun)
{
	__asm("\tji %0"::"a"(fun));
}

static inline void Ifx__jumpToFunctionWithLink(const void *fun)
{
	Ifx__jump_and_link((void (*)(void))fun);
}

static inline void Ifx__jumpBackToLink(void)
{
	__asm("ji a11");
}

/** \defgroup IfxLld_Cpu_Intrinsics_Tasking_any_type Cross type arithmetic operation
 *
 * Macro compatible with float, fix point, signed integer and unsigned integer
 *
 * \ingroup IfxLld_Cpu_Intrinsics_Tasking
 * \{
 */




/** \} */

/** \defgroup IfxLld_Cpu_Intrinsics_Tasking_singed_integer Signed integer operation
 * \ingroup IfxLld_Cpu_Intrinsics_Tasking
 * \{
 */

/** \} */

/** \defgroup IfxLld_Cpu_Intrinsics_Tasking_unsinged_integer Unsigned integer operation
 * \ingroup IfxLld_Cpu_Intrinsics_Tasking
 * \{
 */

/** \} */

/** \defgroup IfxLld_Cpu_Intrinsics_Tasking_float Floating point operation
 * \ingroup IfxLld_Cpu_Intrinsics_Tasking
 * \{
 */




















/** \} */
/** \defgroup IfxLld_Cpu_Intrinsics_Tasking_fractional Fractional Arithmetic Support
 The next table provides an overview of intrinsic functions to convert fractional values. Note that the
 TASKING VX-toolset C compiler for TriCore fully supports the fractional type so normally you should not
 need these intrinsic functions (except for __mulfractlong). For compatibility reasons the TASKING C
 compiler does support these functions.
 * \ingroup IfxLld_Cpu_Intrinsics_Tasking
 * \{
 */






/** \} */

/** \defgroup IfxLld_Cpu_Intrinsics_Tasking_insert Insert / Extract Bit-fields and Bits
 * \ingroup IfxLld_Cpu_Intrinsics_Tasking
 * \{
 */









/** \} */

/** \defgroup IfxLld_Cpu_Intrinsics_Tasking_interrupt_handling Interrupt Handling
 The next table provides an overview of the intrinsic functions to read or set interrupt handling.
 * \ingroup IfxLld_Cpu_Intrinsics_Tasking
 * \{
 */




/** \} */

/** \defgroup IfxLld_Cpu_Intrinsics_Tasking_miscellaneous Miscellaneous Intrinsic Functions
 * \ingroup IfxLld_Cpu_Intrinsics_Tasking
 * \{
 */

/** \} */

/** \defgroup IfxLld_Cpu_Intrinsics_Tasking_packed Packed Data Type Support
 The next table provides an overview of the intrinsic functions for initialization of packed data type.
 * \ingroup IfxLld_Cpu_Intrinsics_Tasking
 * \{
 */

/** \} */


/** \defgroup IfxLld_Cpu_Intrinsics_Tasking_register Register Handling
 The next table provides an overview of the intrinsic functions that you can use to access control registers.
 * \ingroup IfxLld_Cpu_Intrinsics_Tasking
 * \{
 */



/** \} */

/** \defgroup IfxLld_Cpu_Intrinsics_Tasking_saturation Saturation Arithmetic Support
 These intrinsics support saturation arithmetic
 * \ingroup IfxLld_Cpu_Intrinsics_Tasking
 * \{
 */









/** \} */

/** \defgroup IfxLld_Cpu_Intrinsics_Tasking_single_assembly Insert Single Assembly Instruction
 The next table provides an overview of the intrinsic functions that you can use to insert a single assembly
 instruction.You can also use inline assembly but these intrinsics provide a shorthand for frequently used
 assembly instructions.
 * \ingroup IfxLld_Cpu_Intrinsics_Tasking
 * \{
 */

static inline void Ifx__nops(void* cnt)
{
    __asm("nop16 \n\t"
          "loop %0,*-2"
          ::"a"(((char*)cnt) - 1));
}



/** Insert a memory barrier
 */











static inline void Ifx__ldmstAsm(volatile void *addr, uint32 mask, uint32 data)
{
    __asm("\tmov d3, %1 \n"
          "\tmov d2, %2 \n"
          "\tldmst [%0],e2"
          ::"a"(addr), "d"(mask), "d"(data):"d2", "d3");

}

/** Convert float to fract
 */
static inline __fract Ifx__float_to_fract(float a)
{
    __fract res;
    __asm("ftoq31  %0,%1,%2":"=d"(res):"d"(a), "d"(0):"memory");
    return res;
}



/** Convert float to sfract
 */
static inline __sfract Ifx__float_to_sfract(float a)
{
    __fract tmp = Ifx__float_to_fract(a);
    return __round16(tmp);
}




static inline void Ifx__stopPerfCounters(void)
{ //__mtcr (CPU_CCTRL, 0);
    __asm(
            "    mov d0,#0\n"
            "    mtcr #0xFC00,d0\n"
            "    isync\n"
            :::"d0");
}

/** \} */

/* FIXME use inline instead of #define */
/* FIXME is it really required to have #define __setareg(areg,val) ___setareg(areg,val) or can __setareg() implemented directly */




/** \brief This function is a implementation of a binary semaphore using compare and swap instruction
 * \param address address of resource.
 * \param value This variable is updated with status of address
 * \param condition if the value of address matches with the value of condition, then swap of value & address occurs.
 *
 */



/** \brief Convert a fixpoint value to float32
 *
 * This function converts a value from a fixpoint format to a float32 format.
 *
 *
 * \param value value to be converted.
 * \param shift position of the fix point. Range = [-256, 255] => (Qx.y format where x = shift+1).
 *
 * \return Returns the converted value in the float32 format.
 *
 */
static inline float32 Ifx__fixpoint_to_float32(__fract value, sint32 shift)
{
    float32 result;

    __asm(
        "   q31tof\t%0, %1, %2  \n"
        : "=d" (result)
        : "d" (value), "d" (shift));
    return result;
}

static inline void* Ifx__getA11(void)
{
    unsigned int *res;
    __asm("mov.aa %0, a11": "=a" (res) : :"a11");
    return res;
}

static inline void Ifx__setStackPointer(void *stackAddr)
{
    __asm("mov.aa a10, %0": : "a" (stackAddr) :"a10");
}

static inline uint32 IfxCpu_calculateCrc32(uint32 *startaddress, uint8 length)
{
    uint32 returnvalue;
    __asm("MOV d0, #0x0"); /* set seed value to 0 */
    for (;length > 0; length--)
    {
        /* calculate the CRC over all data */
        __asm("LD.W d1,[%0]" : : "a" (startaddress));
        __asm("CRC32 d0,d0,d1");
        startaddress++;
    }
    __asm("MOV %0,d0" : "=d" (returnvalue)); /* return result of CRC*/
    return returnvalue;
}

static inline uint32 IfxCpu_getRandomVal(uint32 a, uint32 x, uint32 m)
{
	uint32 result;
    __asm("      mul.u     e14,%1,%2      ; d15 = Eh; d14 = El    \n"
        "        mov       d12,d14        ;   e12 = El            \n"
        "        mov       d13,#0         ;                       \n"
        "        madd.u    e14,e12,d15,#5 ; e14 = El + 5 * d15    \n"
        " 1:     jge.u     d14,%3,2n      ;                       \n"
        "        jz        d15,3n         ;                       \n"
        " 2:     subx      d14,d14,%3     ;  e12=e12-m            \n"
        "        subc      d15,d15,d13    ; d13=d13-0             \n"
        "        loopu     1p             ;                       \n"
        " 3:     mov       %0,d14         ;                       \n"
        : "=d"(result) : "d"(a), "d"(x), "d"(m) : "e14","e12");
    return result;
}

static inline sint32 Ifx__popcnt(sint32 a)
{ 
	sint32 res; 
	__asm("popcnt.w %0,%1":"=d"(res):"d"(a)); 
		return res; 
}


/* Macros for backward compatibility of the intrinsics*/
/******************************************************************************/










































































































































































































































/******************************************************************************/
/* *INDENT-ON* */
/******************************************************************************/

#line 57 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Cpu\\Std\\IfxCpu_Intrinsics.h"
























//______________________________________________________________________________

/** Convert context pointer to address pointer
 * \param[in] cx context pointer
 * \return address pointer
 */
static inline void *__cx_to_addr(uint32 cx)
{
    uint32 seg_nr = __extru(cx, 16, 4);
    return (void *)__insert(seg_nr << 28, cx, 6, 16);
}


/** Convert address pointer to context pointer
 * \param[in] addr address pointer
 * \return context pointer
 */
static inline uint32 __addr_to_cx(void *addr)
{
    uint32 seg_nr, seg_idx;
    seg_nr  = __extru((int)addr, 28, 4) << 16;
    seg_idx = __extru((int)addr, 6, 16);
    return seg_nr | seg_idx;
}


/******************************************************************************/
static inline void __ldmst_c(volatile void *address, unsigned mask, unsigned value)
{
    *(volatile uint32 *)address = (*(volatile uint32 *)address & ~(mask)) | (mask & value);
}


/** 32bit load operation
 */
static inline uint32 __ld32(void *addr)
{
    return *(volatile uint32 *)addr;
}


/** 32bit store operation
 */
static inline void __st32(void *addr, uint32 value)
{
    *(volatile uint32 *)addr = value;
}


/** 64bit load operation
 */
static inline uint64 __ld64(void *addr)
{
    return *(volatile uint64 *)addr;
}


/** 64bit store operation
 */
static inline void __st64(void *addr, uint64 value)
{
    *(volatile uint64 *)addr = value;
}


/** 64bit load operation which returns the lower and upper 32bit word
 */
static inline void __ld64_lu(void *addr, uint32 *valueLower, uint32 *valueUpper)
{
    register uint64 value;
    value       = __ld64(addr);
    *valueLower = (uint32)value;
    *valueUpper = (uint32)(value >> 32);
}


/** 64bit store operation which stores a lower and upper 32bit word
 */
static inline void __st64_lu(void *addr, uint32 valueLower, uint32 valueUpper)
{
    register uint64 value = ((uint64)valueUpper << 32) | valueLower;
    __st64(addr, value);
}


/******************************************************************************/

#line 57 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\_Impl\\IfxCpu_cfg.h"

#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\Infra\\Sfr\\TC38A\\_Reg\\IfxCpu_reg.h"
/**
 * \file IfxCpu_reg.h
 * \brief
 * \copyright Copyright (c) 2020 Infineon Technologies AG. All rights reserved.
 *
 *
 * Version: TC38XA_UM_V1.5.0
 * Specification: TC3xx User Manual V1.5.0
 * MAY BE CHANGED BY USER [yes/no]: No
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * \defgroup IfxSfr_Cpu_Registers_Cfg Cpu address
 * \ingroup IfxSfr_Cpu_Registers
 * 
 * \defgroup IfxSfr_Cpu_Registers_Cfg_BaseAddress Base address
 * \ingroup IfxSfr_Cpu_Registers_Cfg
 *
 * \defgroup IfxSfr_Cpu_Registers_Cfg_Cpu0 2-CPU0
 * \ingroup IfxSfr_Cpu_Registers_Cfg
 *
 * \defgroup IfxSfr_Cpu_Registers_Cfg_Cpu1 2-CPU1
 * \ingroup IfxSfr_Cpu_Registers_Cfg
 *
 * \defgroup IfxSfr_Cpu_Registers_Cfg_Cpu2 2-CPU2
 * \ingroup IfxSfr_Cpu_Registers_Cfg
 *
 * \defgroup IfxSfr_Cpu_Registers_Cfg_Cpu3 2-CPU3
 * \ingroup IfxSfr_Cpu_Registers_Cfg
 *
 *
 */


/******************************************************************************/

#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\Infra\\Sfr\\TC38A\\_Reg\\IfxCpu_regdef.h"
/**
 * \file IfxCpu_regdef.h
 * \brief
 * \copyright Copyright (c) 2020 Infineon Technologies AG. All rights reserved.
 *
 *
 * Version: TC38XA_UM_V1.5.0
 * Specification: TC3xx User Manual V1.5.0
 * MAY BE CHANGED BY USER [yes/no]: No
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * \defgroup IfxSfr_Cpu_Registers Cpu Registers
 * \ingroup IfxSfr
 * 
 * \defgroup IfxSfr_Cpu_Registers_Bitfields Bitfields
 * \ingroup IfxSfr_Cpu_Registers
 * 
 * \defgroup IfxSfr_Cpu_Registers_union Register unions
 * \ingroup IfxSfr_Cpu_Registers
 * 
 * \defgroup IfxSfr_Cpu_Registers_struct Memory map
 * \ingroup IfxSfr_Cpu_Registers
 */


/******************************************************************************/

#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\Infra\\Sfr\\TC38A\\_Reg\\Ifx_TypesReg.h"
/**
 * \file Ifx_TypesReg.h
 * \brief
 * \copyright Copyright (c) 2018 Infineon Technologies AG. All rights reserved.
 *
 * Version: IFXREGTYPES_V1.0.R0
 *
 * MAY BE CHANGED BY USER [yes/no]: No
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 * Data type access rules for peripheral space
 * data type                               | Allowed access size   | Alignment of address in memory
 * ----------------------------------------|-----------------------|-----------------------------------
 * Ifx_UReg_8Bit, Ifx_SReg_8Bit            | Byte                  | Byte (1H)                         
 * Ifx_UReg_16Bit, Ifx_SReg_16Bit          | Byte, Half-Word       | 2 bytes (2H)                      
 * Ifx_UReg_32Bit, Ifx_SReg_32Bit          | Byte, Half-Word, Word | 4 bytes (4H)                      
 * Ifx_Strict_16Bit                        | Half-Word             | 2 bytes (2H)                      
 * Ifx_Strict_32Bit                        | Word                  | 4 bytes (4H)                      
 * 
 * 
 * Alignment rules for peripheral space (From TriCoreTM TC1.6.2 core architecture manual, 2.2.1 Alignment Requirements)
 * Access type                             | Access size           | Required alignment of address in memory    
 * ----------------------------------------|-----------------------|-----------------------------------
 * Load, Store Data Register               | Byte (8-bits)         | Byte (1H)                         
 * Load, Store Data Register               | Half-Word (16-bits)   | 2 bytes (2H)                      
 * Load, Store Data Register               | Word (32-bits)        | 4 bytes (4H)                      
 * Load, Store Data Register               | Double-Word (64-bits) | 8 bytes (8H)                      
 * Load, Store Address Register            | Word                  | 4 bytes (4H)                      
 * Load, Store Address Register            | Double-Word           | 8 bytes (8H)                      
 * SWAP.W, LDMST, ST.T                     | Word                  | 4 bytes (4H)                      
 * CMPSWAP.W, SWAPMSK.W                    | Word                  | 4 bytes (4H)                      
 * Context Load / Store / Restore / Save   | 16 x 32-bit registers | Not Permitted                     
 * 
 * 
 * 
 *  Peripheral space : segment F and E (From TriCoreTM TC1.6.2 core architecture manual, 8.3.4 Default Memory types for all segments)
 */



/******************************************************************************/


 
 
 
 

















typedef unsigned char  Ifx_UReg_8Bit;
typedef unsigned short Ifx_UReg_16Bit;
typedef unsigned int   Ifx_UReg_32Bit;
typedef signed char    Ifx_SReg_8Bit;
typedef signed short   Ifx_SReg_16Bit;
typedef signed int     Ifx_SReg_32Bit;


/******************************************************************************/

#line 58 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\Infra\\Sfr\\TC38A\\_Reg\\IfxCpu_regdef.h"
/******************************************************************************/

/******************************************************************************/

/******************************************************************************/


/** \addtogroup IfxSfr_Cpu_Registers_Bitfields
 * \{  */
/** \brief CPUx Address General Purpose Register ${y} */
typedef struct _Ifx_CPU_A_Bits
{
    unsigned __sfrbit32 ADDR:32;         /**< \brief [31:0] Address Register - ADDR (rw) */
} Ifx_CPU_A_Bits;

/** \brief CPUx Base Interrupt Vector Table Pointer */
typedef struct _Ifx_CPU_BIV_Bits
{
    unsigned __sfrbit32 VSS:1;           /**< \brief [0:0] Vector Spacing Select - VSS (rw) */
    unsigned __sfrbit32 BIV:31;          /**< \brief [31:1] Base Address of Interrupt Vector Table - BIV (rw) */
} Ifx_CPU_BIV_Bits;

/** \brief CPUx Overlay Mask Register ${i} */
typedef struct _Ifx_CPU_BLK_OMASK_Bits
{
    unsigned __sfrbit32 reserved_0:5;    /**< \brief [4:0] \internal Reserved */
    unsigned __sfrbit32 OMASK:12;        /**< \brief [16:5] Overlay Address Mask - OMASK (rw) */
    unsigned __sfrbit32 ONE:11;          /**< \brief [27:17] Fixed "1" Values - ONE (r) */
    unsigned __sfrbit32 reserved_28:4;    /**< \brief [31:28] \internal Reserved */
} Ifx_CPU_BLK_OMASK_Bits;

/** \brief CPUx Overlay Target Address Register ${i} */
typedef struct _Ifx_CPU_BLK_OTAR_Bits
{
    unsigned __sfrbit32 reserved_0:5;    /**< \brief [4:0] \internal Reserved */
    unsigned __sfrbit32 TBASE:23;        /**< \brief [27:5] Target Base - TBASE (rw) */
    unsigned __sfrbit32 reserved_28:4;    /**< \brief [31:28] \internal Reserved */
} Ifx_CPU_BLK_OTAR_Bits;

/** \brief CPUx Redirected Address Base Register ${i} */
typedef struct _Ifx_CPU_BLK_RABR_Bits
{
    unsigned __sfrbit32 reserved_0:5;    /**< \brief [4:0] \internal Reserved */
    unsigned __sfrbit32 OBASE:17;        /**< \brief [21:5] Overlay Block Base Address - OBASE (rw) */
    unsigned __sfrbit32 reserved_22:2;    /**< \brief [23:22] \internal Reserved */
    unsigned __sfrbit32 OMEM:4;          /**< \brief [27:24] Overlay Memory Select - OMEM (rw) */
    unsigned __sfrbit32 reserved_28:3;    /**< \brief [30:28] \internal Reserved */
    unsigned __sfrbit32 OVEN:1;          /**< \brief [31:31] Overlay Enabled - OVEN (rwh) */
} Ifx_CPU_BLK_RABR_Bits;

/** \brief CPUx Base Trap Vector Table Pointer */
typedef struct _Ifx_CPU_BTV_Bits
{
    unsigned __sfrbit32 reserved_0:1;    /**< \brief [0:0] \internal Reserved */
    unsigned __sfrbit32 BTV:31;          /**< \brief [31:1] Base Address of Trap Vector Table - BTV (rw) */
} Ifx_CPU_BTV_Bits;

/** \brief CPUx CPU Clock Cycle Count */
typedef struct _Ifx_CPU_CCNT_Bits
{
    unsigned __sfrbit32 COUNTVALUE:31;    /**< \brief [30:0] Count Value - CountValue (rwh) */
    unsigned __sfrbit32 SOVF:1;          /**< \brief [31:31] Sticky Overflow Bit - SOvf (rwh) */
} Ifx_CPU_CCNT_Bits;

/** \brief CPUx Counter Control */
typedef struct _Ifx_CPU_CCTRL_Bits
{
    unsigned __sfrbit32 CM:1;            /**< \brief [0:0] Counter Mode - CM (rw) */
    unsigned __sfrbit32 CE:1;            /**< \brief [1:1] Count Enable - CE (rw) */
    unsigned __sfrbit32 M1:3;            /**< \brief [4:2] M1CNT Configuration - M1 (rw) */
    unsigned __sfrbit32 M2:3;            /**< \brief [7:5] M2CNT Configuration - M2 (rw) */
    unsigned __sfrbit32 M3:3;            /**< \brief [10:8] M3CNT Configuration - M3 (rw) */
    unsigned __sfrbit32 reserved_11:21;    /**< \brief [31:11] \internal Reserved */
} Ifx_CPU_CCTRL_Bits;

/** \brief CPUx Compatibility Control Register */
typedef struct _Ifx_CPU_COMPAT_Bits
{
    unsigned __sfrbit32 reserved_0:3;    /**< \brief [2:0] \internal Reserved */
    unsigned __sfrbit32 RM:1;            /**< \brief [3:3] Rounding Mode Compatibility - RM (rw) */
    unsigned __sfrbit32 SP:1;            /**< \brief [4:4] SYSCON Safety Protection Mode Compatibility - SP (rw) */
    unsigned __sfrbit32 reserved_5:27;    /**< \brief [31:5] \internal Reserved */
} Ifx_CPU_COMPAT_Bits;

/** \brief CPUx Core Identification Register */
typedef struct _Ifx_CPU_CORE_ID_Bits
{
    unsigned __sfrbit32 CORE_ID:3;       /**< \brief [2:0] Core Identification Number - CORE_ID (r) */
    unsigned __sfrbit32 reserved_3:29;    /**< \brief [31:3] \internal Reserved */
} Ifx_CPU_CORE_ID_Bits;

/** \brief CPUx Code Protection Range ${y} Lower Bound Register */
typedef struct _Ifx_CPU_CPR_L_Bits
{
    unsigned __sfrbit32 reserved_0:5;    /**< \brief [4:0] \internal Reserved */
    unsigned __sfrbit32 LOWBND:27;       /**< \brief [31:5] CPRy Lower Boundary Address - LOWBND (rw) */
} Ifx_CPU_CPR_L_Bits;

/** \brief CPUx Code Protection Range ${y} Upper Bound Register */
typedef struct _Ifx_CPU_CPR_U_Bits
{
    unsigned __sfrbit32 reserved_0:5;    /**< \brief [4:0] \internal Reserved */
    unsigned __sfrbit32 UPPBND:27;       /**< \brief [31:5] CPR0_m Upper Boundary Address - UPPBND (rw) */
} Ifx_CPU_CPR_U_Bits;

/** \brief CPUx Identification Register TC1.6.2P */
typedef struct _Ifx_CPU_CPU_ID_Bits
{
    unsigned __sfrbit32 MOD_REV:8;       /**< \brief [7:0] Revision Number - MOD_REV (r) */
    unsigned __sfrbit32 MOD_32B:8;       /**< \brief [15:8] 32-Bit Module Enable - MOD_32B (r) */
    unsigned __sfrbit32 MOD:16;          /**< \brief [31:16] Module Identification Number - MOD (r) */
} Ifx_CPU_CPU_ID_Bits;

/** \brief  */
typedef struct _Ifx_CPU_CPXE_Bits
{
    unsigned __sfrbit32 XE_N:10;         /**< \brief [9:0] Execute Enable Range select - XE[n] (rw) */
    unsigned __sfrbit32 reserved_10:22;    /**< \brief [31:10] \internal Reserved */
} Ifx_CPU_CPXE_Bits;

/** \brief CPUx Core Register Access Event */
typedef struct _Ifx_CPU_CREVT_Bits
{
    unsigned __sfrbit32 EVTA:3;          /**< \brief [2:0] Event Associated - EVTA (rw) */
    unsigned __sfrbit32 BBM:1;           /**< \brief [3:3] Break Before Make (BBM) or Break After Make (BAM) Selection - BBM (rw) */
    unsigned __sfrbit32 BOD:1;           /**< \brief [4:4] Breakout Disable - BOD (rw) */
    unsigned __sfrbit32 SUSP:1;          /**< \brief [5:5] CDC Suspend-Out Signal State - SUSP (rw) */
    unsigned __sfrbit32 CNT:2;           /**< \brief [7:6] Counter - CNT (rw) */
    unsigned __sfrbit32 reserved_8:24;    /**< \brief [31:8] \internal Reserved */
} Ifx_CPU_CREVT_Bits;

/** \brief CPUx Customer ID register */
typedef struct _Ifx_CPU_CUS_ID_Bits
{
    unsigned __sfrbit32 CID:3;           /**< \brief [2:0] Customer ID - CID (r) */
    unsigned __sfrbit32 reserved_3:29;    /**< \brief [31:3] \internal Reserved */
} Ifx_CPU_CUS_ID_Bits;

/** \brief CPUx Data General Purpose Register ${y} */
typedef struct _Ifx_CPU_D_Bits
{
    unsigned __sfrbit32 DATA:32;         /**< \brief [31:0] Data Register - DATA (rw) */
} Ifx_CPU_D_Bits;

/** \brief CPUx Data Asynchronous Trap Register */
typedef struct _Ifx_CPU_DATR_Bits
{
    unsigned __sfrbit32 reserved_0:3;    /**< \brief [2:0] \internal Reserved */
    unsigned __sfrbit32 SBE:1;           /**< \brief [3:3] Store Bus Error - SBE (rwh) */
    unsigned __sfrbit32 reserved_4:5;    /**< \brief [8:4] \internal Reserved */
    unsigned __sfrbit32 CWE:1;           /**< \brief [9:9] Cache Writeback Error - CWE (rwh) */
    unsigned __sfrbit32 CFE:1;           /**< \brief [10:10] Cache Flush Error - CFE (rwh) */
    unsigned __sfrbit32 reserved_11:3;    /**< \brief [13:11] \internal Reserved */
    unsigned __sfrbit32 SOE:1;           /**< \brief [14:14] Store Overlay Error - SOE (rwh) */
    unsigned __sfrbit32 reserved_15:1;    /**< \brief [15:15] \internal Reserved */
    unsigned __sfrbit32 reserved_16:16;    /**< \brief [31:16] \internal Reserved */
} Ifx_CPU_DATR_Bits;

/** \brief CPUx Debug Status Register */
typedef struct _Ifx_CPU_DBGSR_Bits
{
    unsigned __sfrbit32 DE:1;            /**< \brief [0:0] Debug Enable - DE (rh) */
    unsigned __sfrbit32 HALT:2;          /**< \brief [2:1] CPU Halt Request / Status Field - HALT (rwh) */
    unsigned __sfrbit32 SIH:1;           /**< \brief [3:3] Suspend-in Halt - SIH (rh) */
    unsigned __sfrbit32 SUSP:1;          /**< \brief [4:4] Current State of the Core Suspend-Out Signal - SUSP (rwh) */
    unsigned __sfrbit32 reserved_5:1;    /**< \brief [5:5] \internal Reserved */
    unsigned __sfrbit32 PREVSUSP:1;      /**< \brief [6:6] Previous State of Core Suspend-Out Signal - PREVSUSP (rh) */
    unsigned __sfrbit32 PEVT:1;          /**< \brief [7:7] Posted Event - PEVT (rwh) */
    unsigned __sfrbit32 EVTSRC:5;        /**< \brief [12:8] Event Source - EVTSRC (rh) */
    unsigned __sfrbit32 reserved_13:19;    /**< \brief [31:13] \internal Reserved */
} Ifx_CPU_DBGSR_Bits;

/** \brief CPUx Debug Trap Control Register */
typedef struct _Ifx_CPU_DBGTCR_Bits
{
    unsigned __sfrbit32 DTA:1;           /**< \brief [0:0] Debug Trap Active Bit - DTA (rwh) */
    unsigned __sfrbit32 reserved_1:31;    /**< \brief [31:1] \internal Reserved */
} Ifx_CPU_DBGTCR_Bits;

/** \brief CPUx Data Memory Control Register */
typedef struct _Ifx_CPU_DCON0_Bits
{
    unsigned __sfrbit32 reserved_0:1;    /**< \brief [0:0] \internal Reserved */
    unsigned __sfrbit32 DCBYP:1;         /**< \brief [1:1] Data Cache Bypass - DCBYP (rw) */
    unsigned __sfrbit32 reserved_2:30;    /**< \brief [31:2] \internal Reserved */
} Ifx_CPU_DCON0_Bits;

/** \brief CPUx Data Control Register 2 */
typedef struct _Ifx_CPU_DCON2_Bits
{
    unsigned __sfrbit32 DCACHE_SZE:16;    /**< \brief [15:0] Data Cache Size - DCACHE_SZE (r) */
    unsigned __sfrbit32 DSCRATCH_SZE:16;    /**< \brief [31:16] Data Scratch Size - DSCRATCH_SZE (r) */
} Ifx_CPU_DCON2_Bits;

/** \brief CPUx Debug Context Save Area Pointer */
typedef struct _Ifx_CPU_DCX_Bits
{
    unsigned __sfrbit32 reserved_0:6;    /**< \brief [5:0] \internal Reserved */
    unsigned __sfrbit32 DCXVALUE:26;     /**< \brief [31:6] Debug Context Save Area Pointer - DCXValue (rw) */
} Ifx_CPU_DCX_Bits;

/** \brief CPUx Data Error Address Register */
typedef struct _Ifx_CPU_DEADD_Bits
{
    unsigned __sfrbit32 ERROR_ADDRESS:32;    /**< \brief [31:0] Error Address - ERROR_ADDRESS (rh) */
} Ifx_CPU_DEADD_Bits;

/** \brief CPUx Data Integrity Error Address Register */
typedef struct _Ifx_CPU_DIEAR_Bits
{
    unsigned __sfrbit32 TA:32;           /**< \brief [31:0] Transaction Address - TA (rh) */
} Ifx_CPU_DIEAR_Bits;

/** \brief CPUx Data Integrity Error Trap Register */
typedef struct _Ifx_CPU_DIETR_Bits
{
    unsigned __sfrbit32 IED:1;           /**< \brief [0:0] Integrity Error Detected - IED (rwh) */
    unsigned __sfrbit32 IE_T:1;          /**< \brief [1:1] Integrity Error - Tag Memory - IE_T (rh) */
    unsigned __sfrbit32 IE_C:1;          /**< \brief [2:2] Integrity Error - Cache Memory - IE_C (rh) */
    unsigned __sfrbit32 IE_S:1;          /**< \brief [3:3] Integrity Error - Scratchpad Memory - IE_S (rh) */
    unsigned __sfrbit32 IE_BI:1;         /**< \brief [4:4] Integrity Error - Bus Interface - IE_BI (rh) */
    unsigned __sfrbit32 E_INFO:6;        /**< \brief [10:5] Error Information - E_INFO (rh) */
    unsigned __sfrbit32 IE_UNC:1;        /**< \brief [11:11] Dual Bit Error Detected - IE_UNC (rh) */
    unsigned __sfrbit32 IE_SP:1;         /**< \brief [12:12] Safety Protection Error Detected - IE_SP (rh) */
    unsigned __sfrbit32 IE_BS:1;         /**< \brief [13:13] Bus Slave Access Indicator - IE_BS (rh) */
    unsigned __sfrbit32 IE_DLMU:1;       /**< \brief [14:14] Integrity Error - DLMU - IE_DLMU (rh) */
    unsigned __sfrbit32 IE_LPB:1;        /**< \brief [15:15] Integrity Error - Local Pflash Bank - IE_LPB (rh) */
    unsigned __sfrbit32 IE_MTMV:1;       /**< \brief [16:16] Memory Test Mode Violation detected - IE_MTMV (rh) */
    unsigned __sfrbit32 reserved_17:15;    /**< \brief [31:17] \internal Reserved */
} Ifx_CPU_DIETR_Bits;

/** \brief CPUx Safety Protection Region DLMU Read Access Enable Register A${i} */
typedef struct _Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits
{
    unsigned __sfrbit32 EN0:1;           /**< \brief [0:0] Access Enable for Master TAG ID 0 - EN0 (rw) */
    unsigned __sfrbit32 EN1:1;           /**< \brief [1:1] Access Enable for Master TAG ID 1 - EN1 (rw) */
    unsigned __sfrbit32 EN2:1;           /**< \brief [2:2] Access Enable for Master TAG ID 2 - EN2 (rw) */
    unsigned __sfrbit32 EN3:1;           /**< \brief [3:3] Access Enable for Master TAG ID 3 - EN3 (rw) */
    unsigned __sfrbit32 EN4:1;           /**< \brief [4:4] Access Enable for Master TAG ID 4 - EN4 (rw) */
    unsigned __sfrbit32 EN5:1;           /**< \brief [5:5] Access Enable for Master TAG ID 5 - EN5 (rw) */
    unsigned __sfrbit32 EN6:1;           /**< \brief [6:6] Access Enable for Master TAG ID 6 - EN6 (rw) */
    unsigned __sfrbit32 EN7:1;           /**< \brief [7:7] Access Enable for Master TAG ID 7 - EN7 (rw) */
    unsigned __sfrbit32 EN8:1;           /**< \brief [8:8] Access Enable for Master TAG ID 8 - EN8 (rw) */
    unsigned __sfrbit32 EN9:1;           /**< \brief [9:9] Access Enable for Master TAG ID 9 - EN9 (rw) */
    unsigned __sfrbit32 EN10:1;          /**< \brief [10:10] Access Enable for Master TAG ID 10 - EN10 (rw) */
    unsigned __sfrbit32 EN11:1;          /**< \brief [11:11] Access Enable for Master TAG ID 11 - EN11 (rw) */
    unsigned __sfrbit32 EN12:1;          /**< \brief [12:12] Access Enable for Master TAG ID 12 - EN12 (rw) */
    unsigned __sfrbit32 EN13:1;          /**< \brief [13:13] Access Enable for Master TAG ID 13 - EN13 (rw) */
    unsigned __sfrbit32 EN14:1;          /**< \brief [14:14] Access Enable for Master TAG ID 14 - EN14 (rw) */
    unsigned __sfrbit32 EN15:1;          /**< \brief [15:15] Access Enable for Master TAG ID 15 - EN15 (rw) */
    unsigned __sfrbit32 EN16:1;          /**< \brief [16:16] Access Enable for Master TAG ID 16 - EN16 (rw) */
    unsigned __sfrbit32 EN17:1;          /**< \brief [17:17] Access Enable for Master TAG ID 17 - EN17 (rw) */
    unsigned __sfrbit32 EN18:1;          /**< \brief [18:18] Access Enable for Master TAG ID 18 - EN18 (rw) */
    unsigned __sfrbit32 EN19:1;          /**< \brief [19:19] Access Enable for Master TAG ID 19 - EN19 (rw) */
    unsigned __sfrbit32 EN20:1;          /**< \brief [20:20] Access Enable for Master TAG ID 20 - EN20 (rw) */
    unsigned __sfrbit32 EN21:1;          /**< \brief [21:21] Access Enable for Master TAG ID 21 - EN21 (rw) */
    unsigned __sfrbit32 EN22:1;          /**< \brief [22:22] Access Enable for Master TAG ID 22 - EN22 (rw) */
    unsigned __sfrbit32 EN23:1;          /**< \brief [23:23] Access Enable for Master TAG ID 23 - EN23 (rw) */
    unsigned __sfrbit32 EN24:1;          /**< \brief [24:24] Access Enable for Master TAG ID 24 - EN24 (rw) */
    unsigned __sfrbit32 EN25:1;          /**< \brief [25:25] Access Enable for Master TAG ID 25 - EN25 (rw) */
    unsigned __sfrbit32 EN26:1;          /**< \brief [26:26] Access Enable for Master TAG ID 26 - EN26 (rw) */
    unsigned __sfrbit32 EN27:1;          /**< \brief [27:27] Access Enable for Master TAG ID 27 - EN27 (rw) */
    unsigned __sfrbit32 EN28:1;          /**< \brief [28:28] Access Enable for Master TAG ID 28 - EN28 (rw) */
    unsigned __sfrbit32 EN29:1;          /**< \brief [29:29] Access Enable for Master TAG ID 29 - EN29 (rw) */
    unsigned __sfrbit32 EN30:1;          /**< \brief [30:30] Access Enable for Master TAG ID 30 - EN30 (rw) */
    unsigned __sfrbit32 EN31:1;          /**< \brief [31:31] Access Enable for Master TAG ID 31 - EN31 (rw) */
} Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits;

/** \brief CPUx Safety Protection Region DLMU Write Access Enable Register A${i} */
typedef struct _Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits
{
    unsigned __sfrbit32 EN0:1;           /**< \brief [0:0] Access Enable for Master TAG ID 0 - EN0 (rw) */
    unsigned __sfrbit32 EN1:1;           /**< \brief [1:1] Access Enable for Master TAG ID 1 - EN1 (rw) */
    unsigned __sfrbit32 EN2:1;           /**< \brief [2:2] Access Enable for Master TAG ID 2 - EN2 (rw) */
    unsigned __sfrbit32 EN3:1;           /**< \brief [3:3] Access Enable for Master TAG ID 3 - EN3 (rw) */
    unsigned __sfrbit32 EN4:1;           /**< \brief [4:4] Access Enable for Master TAG ID 4 - EN4 (rw) */
    unsigned __sfrbit32 EN5:1;           /**< \brief [5:5] Access Enable for Master TAG ID 5 - EN5 (rw) */
    unsigned __sfrbit32 EN6:1;           /**< \brief [6:6] Access Enable for Master TAG ID 6 - EN6 (rw) */
    unsigned __sfrbit32 EN7:1;           /**< \brief [7:7] Access Enable for Master TAG ID 7 - EN7 (rw) */
    unsigned __sfrbit32 EN8:1;           /**< \brief [8:8] Access Enable for Master TAG ID 8 - EN8 (rw) */
    unsigned __sfrbit32 EN9:1;           /**< \brief [9:9] Access Enable for Master TAG ID 9 - EN9 (rw) */
    unsigned __sfrbit32 EN10:1;          /**< \brief [10:10] Access Enable for Master TAG ID 10 - EN10 (rw) */
    unsigned __sfrbit32 EN11:1;          /**< \brief [11:11] Access Enable for Master TAG ID 11 - EN11 (rw) */
    unsigned __sfrbit32 EN12:1;          /**< \brief [12:12] Access Enable for Master TAG ID 12 - EN12 (rw) */
    unsigned __sfrbit32 EN13:1;          /**< \brief [13:13] Access Enable for Master TAG ID 13 - EN13 (rw) */
    unsigned __sfrbit32 EN14:1;          /**< \brief [14:14] Access Enable for Master TAG ID 14 - EN14 (rw) */
    unsigned __sfrbit32 EN15:1;          /**< \brief [15:15] Access Enable for Master TAG ID 15 - EN15 (rw) */
    unsigned __sfrbit32 EN16:1;          /**< \brief [16:16] Access Enable for Master TAG ID 16 - EN16 (rw) */
    unsigned __sfrbit32 EN17:1;          /**< \brief [17:17] Access Enable for Master TAG ID 17 - EN17 (rw) */
    unsigned __sfrbit32 EN18:1;          /**< \brief [18:18] Access Enable for Master TAG ID 18 - EN18 (rw) */
    unsigned __sfrbit32 EN19:1;          /**< \brief [19:19] Access Enable for Master TAG ID 19 - EN19 (rw) */
    unsigned __sfrbit32 EN20:1;          /**< \brief [20:20] Access Enable for Master TAG ID 20 - EN20 (rw) */
    unsigned __sfrbit32 EN21:1;          /**< \brief [21:21] Access Enable for Master TAG ID 21 - EN21 (rw) */
    unsigned __sfrbit32 EN22:1;          /**< \brief [22:22] Access Enable for Master TAG ID 22 - EN22 (rw) */
    unsigned __sfrbit32 EN23:1;          /**< \brief [23:23] Access Enable for Master TAG ID 23 - EN23 (rw) */
    unsigned __sfrbit32 EN24:1;          /**< \brief [24:24] Access Enable for Master TAG ID 24 - EN24 (rw) */
    unsigned __sfrbit32 EN25:1;          /**< \brief [25:25] Access Enable for Master TAG ID 25 - EN25 (rw) */
    unsigned __sfrbit32 EN26:1;          /**< \brief [26:26] Access Enable for Master TAG ID 26 - EN26 (rw) */
    unsigned __sfrbit32 EN27:1;          /**< \brief [27:27] Access Enable for Master TAG ID 27 - EN27 (rw) */
    unsigned __sfrbit32 EN28:1;          /**< \brief [28:28] Access Enable for Master TAG ID 28 - EN28 (rw) */
    unsigned __sfrbit32 EN29:1;          /**< \brief [29:29] Access Enable for Master TAG ID 29 - EN29 (rw) */
    unsigned __sfrbit32 EN30:1;          /**< \brief [30:30] Access Enable for Master TAG ID 30 - EN30 (rw) */
    unsigned __sfrbit32 EN31:1;          /**< \brief [31:31] Access Enable for Master TAG ID 31 - EN31 (rw) */
} Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits;

/** \brief CPUx Safety Protection Region DLMU Read Access Enable Register B${i} */
typedef struct _Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits
{
    unsigned __sfrbit32 EN32:1;          /**< \brief [0:0] Access Enable for Master TAG ID 32 - EN32 (rw) */
    unsigned __sfrbit32 EN33:1;          /**< \brief [1:1] Access Enable for Master TAG ID 33 - EN33 (rw) */
    unsigned __sfrbit32 EN34:1;          /**< \brief [2:2] Access Enable for Master TAG ID 34 - EN34 (rw) */
    unsigned __sfrbit32 EN35:1;          /**< \brief [3:3] Access Enable for Master TAG ID 35 - EN35 (rw) */
    unsigned __sfrbit32 EN36:1;          /**< \brief [4:4] Access Enable for Master TAG ID 36 - EN36 (rw) */
    unsigned __sfrbit32 EN37:1;          /**< \brief [5:5] Access Enable for Master TAG ID 37 - EN37 (rw) */
    unsigned __sfrbit32 EN38:1;          /**< \brief [6:6] Access Enable for Master TAG ID 38 - EN38 (rw) */
    unsigned __sfrbit32 EN39:1;          /**< \brief [7:7] Access Enable for Master TAG ID 39 - EN39 (rw) */
    unsigned __sfrbit32 EN40:1;          /**< \brief [8:8] Access Enable for Master TAG ID 40 - EN40 (rw) */
    unsigned __sfrbit32 EN41:1;          /**< \brief [9:9] Access Enable for Master TAG ID 41 - EN41 (rw) */
    unsigned __sfrbit32 EN42:1;          /**< \brief [10:10] Access Enable for Master TAG ID 42 - EN42 (rw) */
    unsigned __sfrbit32 EN43:1;          /**< \brief [11:11] Access Enable for Master TAG ID 43 - EN43 (rw) */
    unsigned __sfrbit32 EN44:1;          /**< \brief [12:12] Access Enable for Master TAG ID 44 - EN44 (rw) */
    unsigned __sfrbit32 EN45:1;          /**< \brief [13:13] Access Enable for Master TAG ID 45 - EN45 (rw) */
    unsigned __sfrbit32 EN46:1;          /**< \brief [14:14] Access Enable for Master TAG ID 46 - EN46 (rw) */
    unsigned __sfrbit32 EN47:1;          /**< \brief [15:15] Access Enable for Master TAG ID 47 - EN47 (rw) */
    unsigned __sfrbit32 EN48:1;          /**< \brief [16:16] Access Enable for Master TAG ID 48 - EN48 (rw) */
    unsigned __sfrbit32 EN49:1;          /**< \brief [17:17] Access Enable for Master TAG ID 49 - EN49 (rw) */
    unsigned __sfrbit32 EN50:1;          /**< \brief [18:18] Access Enable for Master TAG ID 50 - EN50 (rw) */
    unsigned __sfrbit32 EN51:1;          /**< \brief [19:19] Access Enable for Master TAG ID 51 - EN51 (rw) */
    unsigned __sfrbit32 EN52:1;          /**< \brief [20:20] Access Enable for Master TAG ID 52 - EN52 (rw) */
    unsigned __sfrbit32 EN53:1;          /**< \brief [21:21] Access Enable for Master TAG ID 53 - EN53 (rw) */
    unsigned __sfrbit32 EN54:1;          /**< \brief [22:22] Access Enable for Master TAG ID 54 - EN54 (rw) */
    unsigned __sfrbit32 EN55:1;          /**< \brief [23:23] Access Enable for Master TAG ID 55 - EN55 (rw) */
    unsigned __sfrbit32 EN56:1;          /**< \brief [24:24] Access Enable for Master TAG ID 56 - EN56 (rw) */
    unsigned __sfrbit32 EN57:1;          /**< \brief [25:25] Access Enable for Master TAG ID 57 - EN57 (rw) */
    unsigned __sfrbit32 EN58:1;          /**< \brief [26:26] Access Enable for Master TAG ID 58 - EN58 (rw) */
    unsigned __sfrbit32 EN59:1;          /**< \brief [27:27] Access Enable for Master TAG ID 59 - EN59 (rw) */
    unsigned __sfrbit32 EN60:1;          /**< \brief [28:28] Access Enable for Master TAG ID 60 - EN60 (rw) */
    unsigned __sfrbit32 EN61:1;          /**< \brief [29:29] Access Enable for Master TAG ID 61 - EN61 (rw) */
    unsigned __sfrbit32 EN62:1;          /**< \brief [30:30] Access Enable for Master TAG ID 62 - EN62 (rw) */
    unsigned __sfrbit32 EN63:1;          /**< \brief [31:31] Access Enable for Master TAG ID 63 - EN63 (rw) */
} Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits;

/** \brief CPUx Safety Protection Region DLMU Write Access Enable Register B${i} */
typedef struct _Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits
{
    unsigned __sfrbit32 EN32:1;          /**< \brief [0:0] Access Enable for Master TAG ID 32 - EN32 (rw) */
    unsigned __sfrbit32 EN33:1;          /**< \brief [1:1] Access Enable for Master TAG ID 33 - EN33 (rw) */
    unsigned __sfrbit32 EN34:1;          /**< \brief [2:2] Access Enable for Master TAG ID 34 - EN34 (rw) */
    unsigned __sfrbit32 EN35:1;          /**< \brief [3:3] Access Enable for Master TAG ID 35 - EN35 (rw) */
    unsigned __sfrbit32 EN36:1;          /**< \brief [4:4] Access Enable for Master TAG ID 36 - EN36 (rw) */
    unsigned __sfrbit32 EN37:1;          /**< \brief [5:5] Access Enable for Master TAG ID 37 - EN37 (rw) */
    unsigned __sfrbit32 EN38:1;          /**< \brief [6:6] Access Enable for Master TAG ID 38 - EN38 (rw) */
    unsigned __sfrbit32 EN39:1;          /**< \brief [7:7] Access Enable for Master TAG ID 39 - EN39 (rw) */
    unsigned __sfrbit32 EN40:1;          /**< \brief [8:8] Access Enable for Master TAG ID 40 - EN40 (rw) */
    unsigned __sfrbit32 EN41:1;          /**< \brief [9:9] Access Enable for Master TAG ID 41 - EN41 (rw) */
    unsigned __sfrbit32 EN42:1;          /**< \brief [10:10] Access Enable for Master TAG ID 42 - EN42 (rw) */
    unsigned __sfrbit32 EN43:1;          /**< \brief [11:11] Access Enable for Master TAG ID 43 - EN43 (rw) */
    unsigned __sfrbit32 EN44:1;          /**< \brief [12:12] Access Enable for Master TAG ID 44 - EN44 (rw) */
    unsigned __sfrbit32 EN45:1;          /**< \brief [13:13] Access Enable for Master TAG ID 45 - EN45 (rw) */
    unsigned __sfrbit32 EN46:1;          /**< \brief [14:14] Access Enable for Master TAG ID 46 - EN46 (rw) */
    unsigned __sfrbit32 EN47:1;          /**< \brief [15:15] Access Enable for Master TAG ID 47 - EN47 (rw) */
    unsigned __sfrbit32 EN48:1;          /**< \brief [16:16] Access Enable for Master TAG ID 48 - EN48 (rw) */
    unsigned __sfrbit32 EN49:1;          /**< \brief [17:17] Access Enable for Master TAG ID 49 - EN49 (rw) */
    unsigned __sfrbit32 EN50:1;          /**< \brief [18:18] Access Enable for Master TAG ID 50 - EN50 (rw) */
    unsigned __sfrbit32 EN51:1;          /**< \brief [19:19] Access Enable for Master TAG ID 51 - EN51 (rw) */
    unsigned __sfrbit32 EN52:1;          /**< \brief [20:20] Access Enable for Master TAG ID 52 - EN52 (rw) */
    unsigned __sfrbit32 EN53:1;          /**< \brief [21:21] Access Enable for Master TAG ID 53 - EN53 (rw) */
    unsigned __sfrbit32 EN54:1;          /**< \brief [22:22] Access Enable for Master TAG ID 54 - EN54 (rw) */
    unsigned __sfrbit32 EN55:1;          /**< \brief [23:23] Access Enable for Master TAG ID 55 - EN55 (rw) */
    unsigned __sfrbit32 EN56:1;          /**< \brief [24:24] Access Enable for Master TAG ID 56 - EN56 (rw) */
    unsigned __sfrbit32 EN57:1;          /**< \brief [25:25] Access Enable for Master TAG ID 57 - EN57 (rw) */
    unsigned __sfrbit32 EN58:1;          /**< \brief [26:26] Access Enable for Master TAG ID 58 - EN58 (rw) */
    unsigned __sfrbit32 EN59:1;          /**< \brief [27:27] Access Enable for Master TAG ID 59 - EN59 (rw) */
    unsigned __sfrbit32 EN60:1;          /**< \brief [28:28] Access Enable for Master TAG ID 60 - EN60 (rw) */
    unsigned __sfrbit32 EN61:1;          /**< \brief [29:29] Access Enable for Master TAG ID 61 - EN61 (rw) */
    unsigned __sfrbit32 EN62:1;          /**< \brief [30:30] Access Enable for Master TAG ID 62 - EN62 (rw) */
    unsigned __sfrbit32 EN63:1;          /**< \brief [31:31] Access Enable for Master TAG ID 63 - EN63 (rw) */
} Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits;

/** \brief CPUx Safety Protection DLMU Region Lower Address Register ${i} */
typedef struct _Ifx_CPU_DLMU_SPROT_RGNLA_Bits
{
    unsigned __sfrbit32 reserved_0:5;    /**< \brief [4:0] \internal Reserved */
    unsigned __sfrbit32 ADDR:27;         /**< \brief [31:5] Region Lower Address - ADDR (rw) */
} Ifx_CPU_DLMU_SPROT_RGNLA_Bits;

/** \brief CPUx Safety protection DLMU Region Upper Address Register ${i} */
typedef struct _Ifx_CPU_DLMU_SPROT_RGNUA_Bits
{
    unsigned __sfrbit32 reserved_0:5;    /**< \brief [4:0] \internal Reserved */
    unsigned __sfrbit32 ADDR:27;         /**< \brief [31:5] Region Upper Address - ADDR (rw) */
} Ifx_CPU_DLMU_SPROT_RGNUA_Bits;

/** \brief CPUx Debug Monitor Start Address */
typedef struct _Ifx_CPU_DMS_Bits
{
    unsigned __sfrbit32 reserved_0:1;    /**< \brief [0:0] \internal Reserved */
    unsigned __sfrbit32 DMSVALUE:31;     /**< \brief [31:1] Debug Monitor Start Address - DMSValue (rw) */
} Ifx_CPU_DMS_Bits;

/** \brief  */
typedef struct _Ifx_CPU_DPRE_Bits
{
    unsigned __sfrbit32 RE_N:18;         /**< \brief [17:0] Read Enable Range Select - RE[n] (rw) */
    unsigned __sfrbit32 reserved_18:14;    /**< \brief [31:18] \internal Reserved */
} Ifx_CPU_DPRE_Bits;

/** \brief CPUx Data Protection Range ${y}, Lower Bound Register */
typedef struct _Ifx_CPU_DPR_L_Bits
{
    unsigned __sfrbit32 reserved_0:3;    /**< \brief [2:0] \internal Reserved */
    unsigned __sfrbit32 LOWBND:29;       /**< \brief [31:3] DPRy Lower Boundary Address - LOWBND (rw) */
} Ifx_CPU_DPR_L_Bits;

/** \brief CPUx Data Protection Range ${y}, Upper Bound Register */
typedef struct _Ifx_CPU_DPR_U_Bits
{
    unsigned __sfrbit32 reserved_0:3;    /**< \brief [2:0] \internal Reserved */
    unsigned __sfrbit32 UPPBND:29;       /**< \brief [31:3] DPRy Upper Boundary Address - UPPBND (rw) */
} Ifx_CPU_DPR_U_Bits;

/** \brief  */
typedef struct _Ifx_CPU_DPWE_Bits
{
    unsigned __sfrbit32 WE_N:18;         /**< \brief [17:0] Write Enable Range Select - WE[n] (rw) */
    unsigned __sfrbit32 reserved_18:14;    /**< \brief [31:18] \internal Reserved */
} Ifx_CPU_DPWE_Bits;

/** \brief CPUx Data Synchronous Trap Register */
typedef struct _Ifx_CPU_DSTR_Bits
{
    unsigned __sfrbit32 SRE:1;           /**< \brief [0:0] Scratch Range Error - SRE (rwh) */
    unsigned __sfrbit32 GAE:1;           /**< \brief [1:1] Global Address Error - GAE (rwh) */
    unsigned __sfrbit32 LBE:1;           /**< \brief [2:2] Load Bus Error - LBE (rwh) */
    unsigned __sfrbit32 DRE:1;           /**< \brief [3:3] Local DLMU Range Error - DRE (rwh) */
    unsigned __sfrbit32 reserved_4:2;    /**< \brief [5:4] \internal Reserved */
    unsigned __sfrbit32 CRE:1;           /**< \brief [6:6] Cache Refill Error - CRE (rwh) */
    unsigned __sfrbit32 reserved_7:7;    /**< \brief [13:7] \internal Reserved */
    unsigned __sfrbit32 DTME:1;          /**< \brief [14:14] DTAG MSIST Error - DTME (rwh) */
    unsigned __sfrbit32 LOE:1;           /**< \brief [15:15] Load Overlay Error - LOE (rwh) */
    unsigned __sfrbit32 SDE:1;           /**< \brief [16:16] Segment Difference Error - SDE (rwh) */
    unsigned __sfrbit32 SCE:1;           /**< \brief [17:17] Segment Crossing Error - SCE (rwh) */
    unsigned __sfrbit32 CAC:1;           /**< \brief [18:18] CSFR Access Error - CAC (rwh) */
    unsigned __sfrbit32 MPE:1;           /**< \brief [19:19] Memory Protection Error - MPE (rwh) */
    unsigned __sfrbit32 CLE:1;           /**< \brief [20:20] Context Location Error - CLE (rwh) */
    unsigned __sfrbit32 reserved_21:3;    /**< \brief [23:21] \internal Reserved */
    unsigned __sfrbit32 ALN:1;           /**< \brief [24:24] Alignment Error - ALN (rwh) */
    unsigned __sfrbit32 reserved_25:7;    /**< \brief [31:25] \internal Reserved */
} Ifx_CPU_DSTR_Bits;

/** \brief CPUx External Event Register */
typedef struct _Ifx_CPU_EXEVT_Bits
{
    unsigned __sfrbit32 EVTA:3;          /**< \brief [2:0] Event Associated - EVTA (rw) */
    unsigned __sfrbit32 BBM:1;           /**< \brief [3:3] Break Before Make (BBM) or Break After Make (BAM) Selection - BBM (rw) */
    unsigned __sfrbit32 BOD:1;           /**< \brief [4:4] Breakout Disable - BOD (rw) */
    unsigned __sfrbit32 SUSP:1;          /**< \brief [5:5] CDC Suspend-Out Signal State - SUSP (rw) */
    unsigned __sfrbit32 CNT:2;           /**< \brief [7:6] Counter - CNT (rw) */
    unsigned __sfrbit32 reserved_8:24;    /**< \brief [31:8] \internal Reserved */
} Ifx_CPU_EXEVT_Bits;

/** \brief CPUx Free CSA List Head Pointer */
typedef struct _Ifx_CPU_FCX_Bits
{
    unsigned __sfrbit32 FCXO:16;         /**< \brief [15:0] FCX Offset Address Field - FCXO (rwh) */
    unsigned __sfrbit32 FCXS:4;          /**< \brief [19:16] FCX Segment Address Field - FCXS (rwh) */
    unsigned __sfrbit32 reserved_20:12;    /**< \brief [31:20] \internal Reserved */
} Ifx_CPU_FCX_Bits;

/** \brief CPUx Flash Configuration Register 0 */
typedef struct _Ifx_CPU_FLASHCON0_Bits
{
    unsigned __sfrbit32 TAG1:6;          /**< \brief [5:0] Flash Prefetch Buffer 1 Configuration (rw) */
    unsigned __sfrbit32 reserved_6:2;    /**< \brief [7:6] \internal Reserved */
    unsigned __sfrbit32 TAG2:6;          /**< \brief [13:8] Flash Prefetch Buffer 2 Configuration (rw) */
    unsigned __sfrbit32 reserved_14:2;    /**< \brief [15:14] \internal Reserved */
    unsigned __sfrbit32 TAG3:6;          /**< \brief [21:16] Flash Prefetch Buffer 3 Configuration (rw) */
    unsigned __sfrbit32 reserved_22:2;    /**< \brief [23:22] \internal Reserved */
    unsigned __sfrbit32 TAG4:6;          /**< \brief [29:24] Flash Prefetch Buffer 4 Configuration (rw) */
    unsigned __sfrbit32 reserved_30:2;    /**< \brief [31:30] \internal Reserved */
} Ifx_CPU_FLASHCON0_Bits;

/** \brief CPUx Flash Configuration Register 1 */
typedef struct _Ifx_CPU_FLASHCON1_Bits
{
    unsigned __sfrbit32 STALL:1;         /**< \brief [0:0] Stall Bus Request (rw) */
    unsigned __sfrbit32 reserved_1:15;    /**< \brief [15:1] \internal Reserved */
    unsigned __sfrbit32 MASKUECC:2;      /**< \brief [17:16] Mask PFLASH Uncorrectable ECC Bit Error (rw) */
    unsigned __sfrbit32 reserved_18:6;    /**< \brief [23:18] \internal Reserved */
    unsigned __sfrbit32 reserved_24:2;    /**< \brief [25:24] \internal Reserved */
    unsigned __sfrbit32 reserved_26:6;    /**< \brief [31:26] \internal Reserved */
} Ifx_CPU_FLASHCON1_Bits;

/** \brief CPUx Flash Configuration Register 2 */
typedef struct _Ifx_CPU_FLASHCON2_Bits
{
    unsigned __sfrbit32 RECDIS:2;        /**< \brief [1:0] Address Buffer Recording Disable (rw) */
    unsigned __sfrbit32 ECCCORDIS:2;     /**< \brief [3:2] ECC Correction Disable - ECCCORDIS (rw) */
    unsigned __sfrbit32 reserved_4:4;    /**< \brief [7:4] \internal Reserved */
    unsigned __sfrbit32 HMARGIN:2;       /**< \brief [9:8] Hard Margin Selection (rw) */
    unsigned __sfrbit32 MSEL:2;          /**< \brief [11:10] Margin Read Selection (rw) */
    unsigned __sfrbit32 reserved_12:4;    /**< \brief [15:12] \internal Reserved */
    unsigned __sfrbit32 ECCSCLR:2;       /**< \brief [17:16] Clear ECC Status Register (w) */
    unsigned __sfrbit32 reserved_18:6;    /**< \brief [23:18] \internal Reserved */
    unsigned __sfrbit32 SBABCLR:2;       /**< \brief [25:24] Clear SBAB Record Registers (w) */
    unsigned __sfrbit32 DBABCLR:2;       /**< \brief [27:26] Clear DBAB Record Registers (w) */
    unsigned __sfrbit32 MBABCLR:2;       /**< \brief [29:28] Clear MBAB Record Registers (w) */
    unsigned __sfrbit32 ZBABCLR:2;       /**< \brief [31:30] Clear ZBAB Record Registers - ZBABCLR (w) */
} Ifx_CPU_FLASHCON2_Bits;

/** \brief CPUx Flash Configuration Register 3 */
typedef struct _Ifx_CPU_FLASHCON3_Bits
{
    unsigned __sfrbit32 ECCERRINJ:1;     /**< \brief [0:0] ECC Error Injection (rw) */
    unsigned __sfrbit32 EDCERRINJ:1;     /**< \brief [1:1] EDC Error Injection (rw) */
    unsigned __sfrbit32 SBABERRINJ:1;    /**< \brief [2:2] Corrected Single Bits Address Buffer (SBAB) Error Injection (rw) */
    unsigned __sfrbit32 DBABERRINJ:1;    /**< \brief [3:3] Corrected Double Bits Address Buffer (DBAB) Error Injection (rw) */
    unsigned __sfrbit32 MBABERRINJ:1;    /**< \brief [4:4] Uncorrected Multi Bit Address Buffer (MBAB) Error Injection (rw) */
    unsigned __sfrbit32 ZBABERRINJ:1;    /**< \brief [5:5] Uncorrected All Zeros Bits Address Buffer (ZBAB) Error Injection (rw) */
    unsigned __sfrbit32 SBERERRINJ:1;    /**< \brief [6:6] Single Bit Error (SBER) Injection (rw) */
    unsigned __sfrbit32 DBERERRINJ:1;    /**< \brief [7:7] Double Bit Error (DBER) Injection (rw) */
    unsigned __sfrbit32 NVMCERRINJ:1;    /**< \brief [8:8] NVM Configuration (NVMCER) Injection (rw) */
    unsigned __sfrbit32 FLCONERRINJ:1;    /**< \brief [9:9] Flashcon Error (FLCONER) Injection (rw) */
    unsigned __sfrbit32 reserved_10:22;    /**< \brief [31:10] \internal Reserved */
} Ifx_CPU_FLASHCON3_Bits;

/** \brief CPUx Flash Configuration Register 4 */
typedef struct _Ifx_CPU_FLASHCON4_Bits
{
    unsigned __sfrbit32 DDIS:1;          /**< \brief [0:0] Disable direct LPB access (rw) */
    unsigned __sfrbit32 reserved_1:31;    /**< \brief [31:1] \internal Reserved */
} Ifx_CPU_FLASHCON4_Bits;

/** \brief CPUx Trap Control Register */
typedef struct _Ifx_CPU_FPU_TRAP_CON_Bits
{
    unsigned __sfrbit32 TST:1;           /**< \brief [0:0] Trap Status - TST (rh) */
    unsigned __sfrbit32 TCL:1;           /**< \brief [1:1] Trap Clear - TCL (w) */
    unsigned __sfrbit32 reserved_2:6;    /**< \brief [7:2] \internal Reserved */
    unsigned __sfrbit32 RM:2;            /**< \brief [9:8] Captured Rounding Mode - RM (rh) */
    unsigned __sfrbit32 reserved_10:8;    /**< \brief [17:10] \internal Reserved */
    unsigned __sfrbit32 FXE:1;           /**< \brief [18:18] FX Trap Enable - FXE (rw) */
    unsigned __sfrbit32 FUE:1;           /**< \brief [19:19] FU Trap Enable - FUE (rw) */
    unsigned __sfrbit32 FZE:1;           /**< \brief [20:20] FZ Trap Enable - FZE (rw) */
    unsigned __sfrbit32 FVE:1;           /**< \brief [21:21] FV Trap Enable - FVE (rw) */
    unsigned __sfrbit32 FIE:1;           /**< \brief [22:22] FI Trap Enable - FIE (rw) */
    unsigned __sfrbit32 reserved_23:3;    /**< \brief [25:23] \internal Reserved */
    unsigned __sfrbit32 FX:1;            /**< \brief [26:26] Captured FX - FX (rh) */
    unsigned __sfrbit32 FU:1;            /**< \brief [27:27] Captured FU - FU (rh) */
    unsigned __sfrbit32 FZ:1;            /**< \brief [28:28] Captured FZ - FZ (rh) */
    unsigned __sfrbit32 FV:1;            /**< \brief [29:29] Captured FV - FV (rh) */
    unsigned __sfrbit32 FI:1;            /**< \brief [30:30] Captured FI - FI (rh) */
    unsigned __sfrbit32 reserved_31:1;    /**< \brief [31:31] \internal Reserved */
} Ifx_CPU_FPU_TRAP_CON_Bits;

/** \brief CPUx Trapping Instruction Opcode Register */
typedef struct _Ifx_CPU_FPU_TRAP_OPC_Bits
{
    unsigned __sfrbit32 OPC:8;           /**< \brief [7:0] Captured Opcode - OPC (rh) */
    unsigned __sfrbit32 FMT:1;           /**< \brief [8:8] Captured Instruction Format - FMT (rh) */
    unsigned __sfrbit32 reserved_9:7;    /**< \brief [15:9] \internal Reserved */
    unsigned __sfrbit32 DREG:4;          /**< \brief [19:16] Captured Destination Register - DREG (rh) */
    unsigned __sfrbit32 reserved_20:12;    /**< \brief [31:20] \internal Reserved */
} Ifx_CPU_FPU_TRAP_OPC_Bits;

/** \brief CPUx Trapping Instruction Program Counter Register */
typedef struct _Ifx_CPU_FPU_TRAP_PC_Bits
{
    unsigned __sfrbit32 PC:32;           /**< \brief [31:0] Captured Program Counter - PC (rh) */
} Ifx_CPU_FPU_TRAP_PC_Bits;

/** \brief CPUx Trapping Instruction Operand Register */
typedef struct _Ifx_CPU_FPU_TRAP_SRC1_Bits
{
    unsigned __sfrbit32 SRC1:32;         /**< \brief [31:0] Captured SRC1 Operand - SRC1 (rh) */
} Ifx_CPU_FPU_TRAP_SRC1_Bits;

/** \brief CPUx Trapping Instruction Operand Register */
typedef struct _Ifx_CPU_FPU_TRAP_SRC2_Bits
{
    unsigned __sfrbit32 SRC2:32;         /**< \brief [31:0] Captured SRC2 Operand - SRC2 (rh) */
} Ifx_CPU_FPU_TRAP_SRC2_Bits;

/** \brief CPUx Trapping Instruction Operand Register */
typedef struct _Ifx_CPU_FPU_TRAP_SRC3_Bits
{
    unsigned __sfrbit32 SRC3:32;         /**< \brief [31:0] Captured SRC3 Operand - SRC3 (rh) */
} Ifx_CPU_FPU_TRAP_SRC3_Bits;

/** \brief CPUx Instruction Count */
typedef struct _Ifx_CPU_ICNT_Bits
{
    unsigned __sfrbit32 COUNTVALUE:31;    /**< \brief [30:0] Count Value - CountValue (rwh) */
    unsigned __sfrbit32 SOVF:1;          /**< \brief [31:31] Sticky Overflow Bit - SOvf (rwh) */
} Ifx_CPU_ICNT_Bits;

/** \brief CPUx Interrupt Control Register */
typedef struct _Ifx_CPU_ICR_Bits
{
    unsigned __sfrbit32 CCPN:8;          /**< \brief [7:0] Current CPU Priority Number - CCPN (rwh) */
    unsigned __sfrbit32 reserved_8:7;    /**< \brief [14:8] \internal Reserved */
    unsigned __sfrbit32 IE:1;            /**< \brief [15:15] Global Interrupt Enable Bit - IE (rwh) */
    unsigned __sfrbit32 PIPN:8;          /**< \brief [23:16] Pending Interrupt Priority Number - PIPN (rh) */
    unsigned __sfrbit32 reserved_24:8;    /**< \brief [31:24] \internal Reserved */
} Ifx_CPU_ICR_Bits;

/** \brief CPUx Interrupt Stack Pointer */
typedef struct _Ifx_CPU_ISP_Bits
{
    unsigned __sfrbit32 ISP:32;          /**< \brief [31:0] Interrupt Stack Pointer - ISP (rw) */
} Ifx_CPU_ISP_Bits;

/** \brief CPUx  Reset Register 0 */
typedef struct _Ifx_CPU_KRST0_Bits
{
    unsigned __sfrbit32 RST:1;           /**< \brief [0:0] Kernel Reset - RST (rwh) */
    unsigned __sfrbit32 RSTSTAT:2;       /**< \brief [2:1] Kernel Reset Status - RSTSTAT (rh) */
    unsigned __sfrbit32 reserved_3:29;    /**< \brief [31:3] \internal Reserved */
} Ifx_CPU_KRST0_Bits;

/** \brief CPUx  Reset Register 1 */
typedef struct _Ifx_CPU_KRST1_Bits
{
    unsigned __sfrbit32 RST:1;           /**< \brief [0:0] Kernel Reset - RST (rwh) */
    unsigned __sfrbit32 reserved_1:31;    /**< \brief [31:1] \internal Reserved */
} Ifx_CPU_KRST1_Bits;

/** \brief CPUx Reset Clear Register */
typedef struct _Ifx_CPU_KRSTCLR_Bits
{
    unsigned __sfrbit32 CLR:1;           /**< \brief [0:0] Kernel Reset Status Clear - CLR (w) */
    unsigned __sfrbit32 reserved_1:31;    /**< \brief [31:1] \internal Reserved */
} Ifx_CPU_KRSTCLR_Bits;

/** \brief CPUx Free CSA List Limit Pointer */
typedef struct _Ifx_CPU_LCX_Bits
{
    unsigned __sfrbit32 LCXO:16;         /**< \brief [15:0] LCX Offset Field - LCXO (rw) */
    unsigned __sfrbit32 LCXS:4;          /**< \brief [19:16] LCX Segment Address - LCXS (rw) */
    unsigned __sfrbit32 reserved_20:12;    /**< \brief [31:20] \internal Reserved */
} Ifx_CPU_LCX_Bits;

/** \brief CPUx Safety Protection Region LPB Read Access Enable Register A */
typedef struct _Ifx_CPU_LPB_SPROT_ACCENA_R_Bits
{
    unsigned __sfrbit32 EN0:1;           /**< \brief [0:0] Access Enable for Master TAG ID 0 - EN0 (rw) */
    unsigned __sfrbit32 EN1:1;           /**< \brief [1:1] Access Enable for Master TAG ID 1 - EN1 (rw) */
    unsigned __sfrbit32 EN2:1;           /**< \brief [2:2] Access Enable for Master TAG ID 2 - EN2 (rw) */
    unsigned __sfrbit32 EN3:1;           /**< \brief [3:3] Access Enable for Master TAG ID 3 - EN3 (rw) */
    unsigned __sfrbit32 EN4:1;           /**< \brief [4:4] Access Enable for Master TAG ID 4 - EN4 (rw) */
    unsigned __sfrbit32 EN5:1;           /**< \brief [5:5] Access Enable for Master TAG ID 5 - EN5 (rw) */
    unsigned __sfrbit32 EN6:1;           /**< \brief [6:6] Access Enable for Master TAG ID 6 - EN6 (rw) */
    unsigned __sfrbit32 EN7:1;           /**< \brief [7:7] Access Enable for Master TAG ID 7 - EN7 (rw) */
    unsigned __sfrbit32 EN8:1;           /**< \brief [8:8] Access Enable for Master TAG ID 8 - EN8 (rw) */
    unsigned __sfrbit32 EN9:1;           /**< \brief [9:9] Access Enable for Master TAG ID 9 - EN9 (rw) */
    unsigned __sfrbit32 EN10:1;          /**< \brief [10:10] Access Enable for Master TAG ID 10 - EN10 (rw) */
    unsigned __sfrbit32 EN11:1;          /**< \brief [11:11] Access Enable for Master TAG ID 11 - EN11 (rw) */
    unsigned __sfrbit32 EN12:1;          /**< \brief [12:12] Access Enable for Master TAG ID 12 - EN12 (rw) */
    unsigned __sfrbit32 EN13:1;          /**< \brief [13:13] Access Enable for Master TAG ID 13 - EN13 (rw) */
    unsigned __sfrbit32 EN14:1;          /**< \brief [14:14] Access Enable for Master TAG ID 14 - EN14 (rw) */
    unsigned __sfrbit32 EN15:1;          /**< \brief [15:15] Access Enable for Master TAG ID 15 - EN15 (rw) */
    unsigned __sfrbit32 EN16:1;          /**< \brief [16:16] Access Enable for Master TAG ID 16 - EN16 (rw) */
    unsigned __sfrbit32 EN17:1;          /**< \brief [17:17] Access Enable for Master TAG ID 17 - EN17 (rw) */
    unsigned __sfrbit32 EN18:1;          /**< \brief [18:18] Access Enable for Master TAG ID 18 - EN18 (rw) */
    unsigned __sfrbit32 EN19:1;          /**< \brief [19:19] Access Enable for Master TAG ID 19 - EN19 (rw) */
    unsigned __sfrbit32 EN20:1;          /**< \brief [20:20] Access Enable for Master TAG ID 20 - EN20 (rw) */
    unsigned __sfrbit32 EN21:1;          /**< \brief [21:21] Access Enable for Master TAG ID 21 - EN21 (rw) */
    unsigned __sfrbit32 EN22:1;          /**< \brief [22:22] Access Enable for Master TAG ID 22 - EN22 (rw) */
    unsigned __sfrbit32 EN23:1;          /**< \brief [23:23] Access Enable for Master TAG ID 23 - EN23 (rw) */
    unsigned __sfrbit32 EN24:1;          /**< \brief [24:24] Access Enable for Master TAG ID 24 - EN24 (rw) */
    unsigned __sfrbit32 EN25:1;          /**< \brief [25:25] Access Enable for Master TAG ID 25 - EN25 (rw) */
    unsigned __sfrbit32 EN26:1;          /**< \brief [26:26] Access Enable for Master TAG ID 26 - EN26 (rw) */
    unsigned __sfrbit32 EN27:1;          /**< \brief [27:27] Access Enable for Master TAG ID 27 - EN27 (rw) */
    unsigned __sfrbit32 EN28:1;          /**< \brief [28:28] Access Enable for Master TAG ID 28 - EN28 (rw) */
    unsigned __sfrbit32 EN29:1;          /**< \brief [29:29] Access Enable for Master TAG ID 29 - EN29 (rw) */
    unsigned __sfrbit32 EN30:1;          /**< \brief [30:30] Access Enable for Master TAG ID 30 - EN30 (rw) */
    unsigned __sfrbit32 EN31:1;          /**< \brief [31:31] Access Enable for Master TAG ID 31 - EN31 (rw) */
} Ifx_CPU_LPB_SPROT_ACCENA_R_Bits;

/** \brief CPUx Safety Protection Region LPB Read Access Enable Register B */
typedef struct _Ifx_CPU_LPB_SPROT_ACCENB_R_Bits
{
    unsigned __sfrbit32 EN32:1;          /**< \brief [0:0] Access Enable for Master TAG ID 32 - EN32 (rw) */
    unsigned __sfrbit32 EN33:1;          /**< \brief [1:1] Access Enable for Master TAG ID 33 - EN33 (rw) */
    unsigned __sfrbit32 EN34:1;          /**< \brief [2:2] Access Enable for Master TAG ID 34 - EN34 (rw) */
    unsigned __sfrbit32 EN35:1;          /**< \brief [3:3] Access Enable for Master TAG ID 35 - EN35 (rw) */
    unsigned __sfrbit32 EN36:1;          /**< \brief [4:4] Access Enable for Master TAG ID 36 - EN36 (rw) */
    unsigned __sfrbit32 EN37:1;          /**< \brief [5:5] Access Enable for Master TAG ID 37 - EN37 (rw) */
    unsigned __sfrbit32 EN38:1;          /**< \brief [6:6] Access Enable for Master TAG ID 38 - EN38 (rw) */
    unsigned __sfrbit32 EN39:1;          /**< \brief [7:7] Access Enable for Master TAG ID 39 - EN39 (rw) */
    unsigned __sfrbit32 EN40:1;          /**< \brief [8:8] Access Enable for Master TAG ID 40 - EN40 (rw) */
    unsigned __sfrbit32 EN41:1;          /**< \brief [9:9] Access Enable for Master TAG ID 41 - EN41 (rw) */
    unsigned __sfrbit32 EN42:1;          /**< \brief [10:10] Access Enable for Master TAG ID 42 - EN42 (rw) */
    unsigned __sfrbit32 EN43:1;          /**< \brief [11:11] Access Enable for Master TAG ID 43 - EN43 (rw) */
    unsigned __sfrbit32 EN44:1;          /**< \brief [12:12] Access Enable for Master TAG ID 44 - EN44 (rw) */
    unsigned __sfrbit32 EN45:1;          /**< \brief [13:13] Access Enable for Master TAG ID 45 - EN45 (rw) */
    unsigned __sfrbit32 EN46:1;          /**< \brief [14:14] Access Enable for Master TAG ID 46 - EN46 (rw) */
    unsigned __sfrbit32 EN47:1;          /**< \brief [15:15] Access Enable for Master TAG ID 47 - EN47 (rw) */
    unsigned __sfrbit32 EN48:1;          /**< \brief [16:16] Access Enable for Master TAG ID 48 - EN48 (rw) */
    unsigned __sfrbit32 EN49:1;          /**< \brief [17:17] Access Enable for Master TAG ID 49 - EN49 (rw) */
    unsigned __sfrbit32 EN50:1;          /**< \brief [18:18] Access Enable for Master TAG ID 50 - EN50 (rw) */
    unsigned __sfrbit32 EN51:1;          /**< \brief [19:19] Access Enable for Master TAG ID 51 - EN51 (rw) */
    unsigned __sfrbit32 EN52:1;          /**< \brief [20:20] Access Enable for Master TAG ID 52 - EN52 (rw) */
    unsigned __sfrbit32 EN53:1;          /**< \brief [21:21] Access Enable for Master TAG ID 53 - EN53 (rw) */
    unsigned __sfrbit32 EN54:1;          /**< \brief [22:22] Access Enable for Master TAG ID 54 - EN54 (rw) */
    unsigned __sfrbit32 EN55:1;          /**< \brief [23:23] Access Enable for Master TAG ID 55 - EN55 (rw) */
    unsigned __sfrbit32 EN56:1;          /**< \brief [24:24] Access Enable for Master TAG ID 56 - EN56 (rw) */
    unsigned __sfrbit32 EN57:1;          /**< \brief [25:25] Access Enable for Master TAG ID 57 - EN57 (rw) */
    unsigned __sfrbit32 EN58:1;          /**< \brief [26:26] Access Enable for Master TAG ID 58 - EN58 (rw) */
    unsigned __sfrbit32 EN59:1;          /**< \brief [27:27] Access Enable for Master TAG ID 59 - EN59 (rw) */
    unsigned __sfrbit32 EN60:1;          /**< \brief [28:28] Access Enable for Master TAG ID 60 - EN60 (rw) */
    unsigned __sfrbit32 EN61:1;          /**< \brief [29:29] Access Enable for Master TAG ID 61 - EN61 (rw) */
    unsigned __sfrbit32 EN62:1;          /**< \brief [30:30] Access Enable for Master TAG ID 62 - EN62 (rw) */
    unsigned __sfrbit32 EN63:1;          /**< \brief [31:31] Access Enable for Master TAG ID 63 - EN63 (rw) */
} Ifx_CPU_LPB_SPROT_ACCENB_R_Bits;

/** \brief CPUx Multi-Count Register 1 */
typedef struct _Ifx_CPU_M1CNT_Bits
{
    unsigned __sfrbit32 COUNTVALUE:31;    /**< \brief [30:0] Count Value - CountValue (rwh) */
    unsigned __sfrbit32 SOVF:1;          /**< \brief [31:31] Sticky Overflow Bit - SOvf (rwh) */
} Ifx_CPU_M1CNT_Bits;

/** \brief CPUx Multi-Count Register 2 */
typedef struct _Ifx_CPU_M2CNT_Bits
{
    unsigned __sfrbit32 COUNTVALUE:31;    /**< \brief [30:0] Count Value - CountValue (rwh) */
    unsigned __sfrbit32 SOVF:1;          /**< \brief [31:31] Sticky Overflow Bit - SOvf (rwh) */
} Ifx_CPU_M2CNT_Bits;

/** \brief CPUx Multi-Count Register 3 */
typedef struct _Ifx_CPU_M3CNT_Bits
{
    unsigned __sfrbit32 COUNTVALUE:31;    /**< \brief [30:0] Count Value - CountValue (rwh) */
    unsigned __sfrbit32 SOVF:1;          /**< \brief [31:31] Sticky Overflow Bit - SOvf (rwh) */
} Ifx_CPU_M3CNT_Bits;

/** \brief CPUx  Overlay Range Select Register */
typedef struct _Ifx_CPU_OSEL_Bits
{
    unsigned __sfrbit32 SHOVEN_X:32;     /**< \brief [31:0] Shadow Overlay Enable - SHOVEN[x] (rw) */
} Ifx_CPU_OSEL_Bits;

/** \brief CPUx Program Counter */
typedef struct _Ifx_CPU_PC_Bits
{
    unsigned __sfrbit32 reserved_0:1;    /**< \brief [0:0] \internal Reserved */
    unsigned __sfrbit32 PC:31;           /**< \brief [31:1] Program Counter - PC (rwh) */
} Ifx_CPU_PC_Bits;

/** \brief CPUx Program Control 0 */
typedef struct _Ifx_CPU_PCON0_Bits
{
    unsigned __sfrbit32 reserved_0:1;    /**< \brief [0:0] \internal Reserved */
    unsigned __sfrbit32 PCBYP:1;         /**< \brief [1:1] Program Cache Bypass - PCBYP (rw) */
    unsigned __sfrbit32 reserved_2:30;    /**< \brief [31:2] \internal Reserved */
} Ifx_CPU_PCON0_Bits;

/** \brief CPUx Program Control 1 */
typedef struct _Ifx_CPU_PCON1_Bits
{
    unsigned __sfrbit32 PCINV:1;         /**< \brief [0:0] Program Cache Invalidate - PCINV (rw) */
    unsigned __sfrbit32 PBINV:1;         /**< \brief [1:1] Program Buffer Invalidate - PBINV (rw) */
    unsigned __sfrbit32 reserved_2:30;    /**< \brief [31:2] \internal Reserved */
} Ifx_CPU_PCON1_Bits;

/** \brief CPUx Program Control 2 */
typedef struct _Ifx_CPU_PCON2_Bits
{
    unsigned __sfrbit32 PCACHE_SZE:16;    /**< \brief [15:0] Program Cache Size (ICACHE) in KBytes - PCACHE_SZE (r) */
    unsigned __sfrbit32 PSCRATCH_SZE:16;    /**< \brief [31:16] Program Scratch Size in KBytes - PSCRATCH_SZE (r) */
} Ifx_CPU_PCON2_Bits;

/** \brief CPUx Previous Context Information Register */
typedef struct _Ifx_CPU_PCXI_Bits
{
    unsigned __sfrbit32 PCXO:16;         /**< \brief [15:0] Previous Context Pointer Offset Field - PCXO (rwh) */
    unsigned __sfrbit32 PCXS:4;          /**< \brief [19:16] Previous Context Pointer Segment Address - PCXS (rwh) */
    unsigned __sfrbit32 UL:1;            /**< \brief [20:20] Upper or Lower Context Tag - UL (rwh) */
    unsigned __sfrbit32 PIE:1;           /**< \brief [21:21] Previous Interrupt Enable - PIE (rwh) */
    unsigned __sfrbit32 PCPN:8;          /**< \brief [29:22] Previous CPU Priority Number - PCPN (rwh) */
    unsigned __sfrbit32 reserved_30:2;    /**< \brief [31:30] \internal Reserved */
} Ifx_CPU_PCXI_Bits;

/** \brief CPUx Program Integrity Error Address Register */
typedef struct _Ifx_CPU_PIEAR_Bits
{
    unsigned __sfrbit32 TA:32;           /**< \brief [31:0] Transaction Address - TA (rh) */
} Ifx_CPU_PIEAR_Bits;

/** \brief CPUx Program Integrity Error Trap Register */
typedef struct _Ifx_CPU_PIETR_Bits
{
    unsigned __sfrbit32 IED:1;           /**< \brief [0:0] Integrity Error Detected - IED (rwh) */
    unsigned __sfrbit32 IE_T:1;          /**< \brief [1:1] Integrity Error - TAG Memory - IE_T (rh) */
    unsigned __sfrbit32 IE_C:1;          /**< \brief [2:2] Integrity Error - Cache Memory - IE_C (rh) */
    unsigned __sfrbit32 IE_S:1;          /**< \brief [3:3] Integrity Error - Scratchpad Memory - IE_S (rh) */
    unsigned __sfrbit32 IE_BI:1;         /**< \brief [4:4] Integrity Error - Bus Interface - IE_BI (rh) */
    unsigned __sfrbit32 E_INFO:6;        /**< \brief [10:5] Error Information - E_INFO (rh) */
    unsigned __sfrbit32 IE_UNC:1;        /**< \brief [11:11] Integrity Error - Uncorrectable Error Detected - IE_UNC (rh) */
    unsigned __sfrbit32 IE_SP:1;         /**< \brief [12:12] Safety Protection Error Detected - IE_SP (rh) */
    unsigned __sfrbit32 IE_BS:1;         /**< \brief [13:13] Bus Slave Access Indicator - IE_BS (rh) */
    unsigned __sfrbit32 IE_ADDR:1;       /**< \brief [14:14] Address Phase error detected at SRI slave interface - IE_ADDR (rh) */
    unsigned __sfrbit32 IE_LPB:1;        /**< \brief [15:15] Integrity Error - Local Pflash bank - IE_LPB (rh) */
    unsigned __sfrbit32 IE_MTMV:1;       /**< \brief [16:16] Memory Test Mode Violation detected - IE_MTMV (rh) */
    unsigned __sfrbit32 reserved_17:15;    /**< \brief [31:17] \internal Reserved */
} Ifx_CPU_PIETR_Bits;

/** \brief CPUx Data Access CacheabilityRegister */
typedef struct _Ifx_CPU_PMA0_Bits
{
    unsigned __sfrbit32 DAC:16;          /**< \brief [15:0] Data Access Cacheability Segments FHto 0H - DAC (rw) */
    unsigned __sfrbit32 reserved_16:16;    /**< \brief [31:16] \internal Reserved */
} Ifx_CPU_PMA0_Bits;

/** \brief CPUx Code Access CacheabilityRegister */
typedef struct _Ifx_CPU_PMA1_Bits
{
    unsigned __sfrbit32 CAC:16;          /**< \brief [15:0] Code Access Cacheability Segments FH-0H - CAC (rw) */
    unsigned __sfrbit32 reserved_16:16;    /**< \brief [31:16] \internal Reserved */
} Ifx_CPU_PMA1_Bits;

/** \brief CPUx  Peripheral Space Identifier register */
typedef struct _Ifx_CPU_PMA2_Bits
{
    unsigned __sfrbit32 PSI:16;          /**< \brief [15:0] Peripheral Space Identifier Segments FH-0H - PSI (r) */
    unsigned __sfrbit32 reserved_16:16;    /**< \brief [31:16] \internal Reserved */
} Ifx_CPU_PMA2_Bits;

/** \brief CPUx Program Synchronous Trap Register */
typedef struct _Ifx_CPU_PSTR_Bits
{
    unsigned __sfrbit32 FRE:1;           /**< \brief [0:0] Fetch Range Error - FRE (rwh) */
    unsigned __sfrbit32 reserved_1:1;    /**< \brief [1:1] \internal Reserved */
    unsigned __sfrbit32 FBE:1;           /**< \brief [2:2] Fetch Bus Error - FBE (rwh) */
    unsigned __sfrbit32 reserved_3:9;    /**< \brief [11:3] \internal Reserved */
    unsigned __sfrbit32 FPE:1;           /**< \brief [12:12] Fetch Peripheral Error - FPE (rwh) */
    unsigned __sfrbit32 reserved_13:1;    /**< \brief [13:13] \internal Reserved */
    unsigned __sfrbit32 FME:1;           /**< \brief [14:14] Fetch MSIST Error - FME (rwh) */
    unsigned __sfrbit32 reserved_15:17;    /**< \brief [31:15] \internal Reserved */
} Ifx_CPU_PSTR_Bits;

/** \brief CPUx Program Status Word */
typedef struct _Ifx_CPU_PSW_Bits
{
    unsigned __sfrbit32 CDC:7;           /**< \brief [6:0] Call Depth Counter - CDC (rwh) */
    unsigned __sfrbit32 CDE:1;           /**< \brief [7:7] Call Depth Count Enable - CDE (rwh) */
    unsigned __sfrbit32 GW:1;            /**< \brief [8:8] Global Address Register Write Permission - GW (rwh) */
    unsigned __sfrbit32 IS:1;            /**< \brief [9:9] Interrupt Stack Control - IS (rwh) */
    unsigned __sfrbit32 IO:2;            /**< \brief [11:10] Access Privilege Level Control (I/O Privilege) - IO (rwh) */
    unsigned __sfrbit32 PRS:2;           /**< \brief [13:12] Protection Register Set - PRS (rwh) */
    unsigned __sfrbit32 S:1;             /**< \brief [14:14] Safe Task Identifier - S (rwh) */
    unsigned __sfrbit32 PRS2:1;          /**< \brief [15:15] Protection Register Set MSB - PRS2 (rwh) */
    unsigned __sfrbit32 reserved_16:8;    /**< \brief [23:16] \internal Reserved */
    unsigned __sfrbit32 USB:8;           /**< \brief [31:24] User Status Bits - USB (rw) */
} Ifx_CPU_PSW_Bits;

/** \brief CPUx Safety Protection SPR Region Write Access Enable Register A${i} */
typedef struct _Ifx_CPU_RGN_ACCENA_Bits
{
    unsigned __sfrbit32 EN0:1;           /**< \brief [0:0] Access Enable for Master TAG ID 0 - EN0 (rw) */
    unsigned __sfrbit32 EN1:1;           /**< \brief [1:1] Access Enable for Master TAG ID 1 - EN1 (rw) */
    unsigned __sfrbit32 EN2:1;           /**< \brief [2:2] Access Enable for Master TAG ID 2 - EN2 (rw) */
    unsigned __sfrbit32 EN3:1;           /**< \brief [3:3] Access Enable for Master TAG ID 3 - EN3 (rw) */
    unsigned __sfrbit32 EN4:1;           /**< \brief [4:4] Access Enable for Master TAG ID 4 - EN4 (rw) */
    unsigned __sfrbit32 EN5:1;           /**< \brief [5:5] Access Enable for Master TAG ID 5 - EN5 (rw) */
    unsigned __sfrbit32 EN6:1;           /**< \brief [6:6] Access Enable for Master TAG ID 6 - EN6 (rw) */
    unsigned __sfrbit32 EN7:1;           /**< \brief [7:7] Access Enable for Master TAG ID 7 - EN7 (rw) */
    unsigned __sfrbit32 EN8:1;           /**< \brief [8:8] Access Enable for Master TAG ID 8 - EN8 (rw) */
    unsigned __sfrbit32 EN9:1;           /**< \brief [9:9] Access Enable for Master TAG ID 9 - EN9 (rw) */
    unsigned __sfrbit32 EN10:1;          /**< \brief [10:10] Access Enable for Master TAG ID 10 - EN10 (rw) */
    unsigned __sfrbit32 EN11:1;          /**< \brief [11:11] Access Enable for Master TAG ID 11 - EN11 (rw) */
    unsigned __sfrbit32 EN12:1;          /**< \brief [12:12] Access Enable for Master TAG ID 12 - EN12 (rw) */
    unsigned __sfrbit32 EN13:1;          /**< \brief [13:13] Access Enable for Master TAG ID 13 - EN13 (rw) */
    unsigned __sfrbit32 EN14:1;          /**< \brief [14:14] Access Enable for Master TAG ID 14 - EN14 (rw) */
    unsigned __sfrbit32 EN15:1;          /**< \brief [15:15] Access Enable for Master TAG ID 15 - EN15 (rw) */
    unsigned __sfrbit32 EN16:1;          /**< \brief [16:16] Access Enable for Master TAG ID 16 - EN16 (rw) */
    unsigned __sfrbit32 EN17:1;          /**< \brief [17:17] Access Enable for Master TAG ID 17 - EN17 (rw) */
    unsigned __sfrbit32 EN18:1;          /**< \brief [18:18] Access Enable for Master TAG ID 18 - EN18 (rw) */
    unsigned __sfrbit32 EN19:1;          /**< \brief [19:19] Access Enable for Master TAG ID 19 - EN19 (rw) */
    unsigned __sfrbit32 EN20:1;          /**< \brief [20:20] Access Enable for Master TAG ID 20 - EN20 (rw) */
    unsigned __sfrbit32 EN21:1;          /**< \brief [21:21] Access Enable for Master TAG ID 21 - EN21 (rw) */
    unsigned __sfrbit32 EN22:1;          /**< \brief [22:22] Access Enable for Master TAG ID 22 - EN22 (rw) */
    unsigned __sfrbit32 EN23:1;          /**< \brief [23:23] Access Enable for Master TAG ID 23 - EN23 (rw) */
    unsigned __sfrbit32 EN24:1;          /**< \brief [24:24] Access Enable for Master TAG ID 24 - EN24 (rw) */
    unsigned __sfrbit32 EN25:1;          /**< \brief [25:25] Access Enable for Master TAG ID 25 - EN25 (rw) */
    unsigned __sfrbit32 EN26:1;          /**< \brief [26:26] Access Enable for Master TAG ID 26 - EN26 (rw) */
    unsigned __sfrbit32 EN27:1;          /**< \brief [27:27] Access Enable for Master TAG ID 27 - EN27 (rw) */
    unsigned __sfrbit32 EN28:1;          /**< \brief [28:28] Access Enable for Master TAG ID 28 - EN28 (rw) */
    unsigned __sfrbit32 EN29:1;          /**< \brief [29:29] Access Enable for Master TAG ID 29 - EN29 (rw) */
    unsigned __sfrbit32 EN30:1;          /**< \brief [30:30] Access Enable for Master TAG ID 30 - EN30 (rw) */
    unsigned __sfrbit32 EN31:1;          /**< \brief [31:31] Access Enable for Master TAG ID 31 - EN31 (rw) */
} Ifx_CPU_RGN_ACCENA_Bits;

/** \brief CPUx Safety Protection SPR Region Write Access Enable Register B${i} */
typedef struct _Ifx_CPU_RGN_ACCENB_Bits
{
    unsigned __sfrbit32 EN32:1;          /**< \brief [0:0] Access Enable for Master TAG ID 32 - EN32 (rw) */
    unsigned __sfrbit32 EN33:1;          /**< \brief [1:1] Access Enable for Master TAG ID 33 - EN33 (rw) */
    unsigned __sfrbit32 EN34:1;          /**< \brief [2:2] Access Enable for Master TAG ID 34 - EN34 (rw) */
    unsigned __sfrbit32 EN35:1;          /**< \brief [3:3] Access Enable for Master TAG ID 35 - EN35 (rw) */
    unsigned __sfrbit32 EN36:1;          /**< \brief [4:4] Access Enable for Master TAG ID 36 - EN36 (rw) */
    unsigned __sfrbit32 EN37:1;          /**< \brief [5:5] Access Enable for Master TAG ID 37 - EN37 (rw) */
    unsigned __sfrbit32 EN38:1;          /**< \brief [6:6] Access Enable for Master TAG ID 38 - EN38 (rw) */
    unsigned __sfrbit32 EN39:1;          /**< \brief [7:7] Access Enable for Master TAG ID 39 - EN39 (rw) */
    unsigned __sfrbit32 EN40:1;          /**< \brief [8:8] Access Enable for Master TAG ID 40 - EN40 (rw) */
    unsigned __sfrbit32 EN41:1;          /**< \brief [9:9] Access Enable for Master TAG ID 41 - EN41 (rw) */
    unsigned __sfrbit32 EN42:1;          /**< \brief [10:10] Access Enable for Master TAG ID 42 - EN42 (rw) */
    unsigned __sfrbit32 EN43:1;          /**< \brief [11:11] Access Enable for Master TAG ID 43 - EN43 (rw) */
    unsigned __sfrbit32 EN44:1;          /**< \brief [12:12] Access Enable for Master TAG ID 44 - EN44 (rw) */
    unsigned __sfrbit32 EN45:1;          /**< \brief [13:13] Access Enable for Master TAG ID 45 - EN45 (rw) */
    unsigned __sfrbit32 EN46:1;          /**< \brief [14:14] Access Enable for Master TAG ID 46 - EN46 (rw) */
    unsigned __sfrbit32 EN47:1;          /**< \brief [15:15] Access Enable for Master TAG ID 47 - EN47 (rw) */
    unsigned __sfrbit32 EN48:1;          /**< \brief [16:16] Access Enable for Master TAG ID 48 - EN48 (rw) */
    unsigned __sfrbit32 EN49:1;          /**< \brief [17:17] Access Enable for Master TAG ID 49 - EN49 (rw) */
    unsigned __sfrbit32 EN50:1;          /**< \brief [18:18] Access Enable for Master TAG ID 50 - EN50 (rw) */
    unsigned __sfrbit32 EN51:1;          /**< \brief [19:19] Access Enable for Master TAG ID 51 - EN51 (rw) */
    unsigned __sfrbit32 EN52:1;          /**< \brief [20:20] Access Enable for Master TAG ID 52 - EN52 (rw) */
    unsigned __sfrbit32 EN53:1;          /**< \brief [21:21] Access Enable for Master TAG ID 53 - EN53 (rw) */
    unsigned __sfrbit32 EN54:1;          /**< \brief [22:22] Access Enable for Master TAG ID 54 - EN54 (rw) */
    unsigned __sfrbit32 EN55:1;          /**< \brief [23:23] Access Enable for Master TAG ID 55 - EN55 (rw) */
    unsigned __sfrbit32 EN56:1;          /**< \brief [24:24] Access Enable for Master TAG ID 56 - EN56 (rw) */
    unsigned __sfrbit32 EN57:1;          /**< \brief [25:25] Access Enable for Master TAG ID 57 - EN57 (rw) */
    unsigned __sfrbit32 EN58:1;          /**< \brief [26:26] Access Enable for Master TAG ID 58 - EN58 (rw) */
    unsigned __sfrbit32 EN59:1;          /**< \brief [27:27] Access Enable for Master TAG ID 59 - EN59 (rw) */
    unsigned __sfrbit32 EN60:1;          /**< \brief [28:28] Access Enable for Master TAG ID 60 - EN60 (rw) */
    unsigned __sfrbit32 EN61:1;          /**< \brief [29:29] Access Enable for Master TAG ID 61 - EN61 (rw) */
    unsigned __sfrbit32 EN62:1;          /**< \brief [30:30] Access Enable for Master TAG ID 62 - EN62 (rw) */
    unsigned __sfrbit32 EN63:1;          /**< \brief [31:31] Access Enable for Master TAG ID 63 - EN63 (rw) */
} Ifx_CPU_RGN_ACCENB_Bits;

/** \brief CPUx Safety Protection SPR Region Lower Address Register ${i} */
typedef struct _Ifx_CPU_RGN_LA_Bits
{
    unsigned __sfrbit32 reserved_0:5;    /**< \brief [4:0] \internal Reserved */
    unsigned __sfrbit32 ADDR:27;         /**< \brief [31:5] Region Lower Address - ADDR (rw) */
} Ifx_CPU_RGN_LA_Bits;

/** \brief CPUx Safety Protection SPR Region Upper Address Register ${i} */
typedef struct _Ifx_CPU_RGN_UA_Bits
{
    unsigned __sfrbit32 reserved_0:5;    /**< \brief [4:0] \internal Reserved */
    unsigned __sfrbit32 ADDR:27;         /**< \brief [31:5] Region Upper Address - ADDR (rw) */
} Ifx_CPU_RGN_UA_Bits;

/** \brief CPUx SRI Error Generation Register */
typedef struct _Ifx_CPU_SEGEN_Bits
{
    unsigned __sfrbit32 ADFLIP:8;        /**< \brief [7:0] Address ECC Bit Flip - ADFLIP (rw) */
    unsigned __sfrbit32 ADTYPE:2;        /**< \brief [9:8] Type of error - ADTYPE (rw) */
    unsigned __sfrbit32 reserved_10:21;    /**< \brief [30:10] \internal Reserved */
    unsigned __sfrbit32 AE:1;            /**< \brief [31:31] Activate Error Enable - AE (rwh) */
} Ifx_CPU_SEGEN_Bits;

/** \brief CPUx Safety Protection Register Access Enable Register A */
typedef struct _Ifx_CPU_SFR_SPROT_ACCENA_W_Bits
{
    unsigned __sfrbit32 EN0:1;           /**< \brief [0:0] Access Enable for Master TAG ID 0 - EN0 (rw) */
    unsigned __sfrbit32 EN1:1;           /**< \brief [1:1] Access Enable for Master TAG ID 1 - EN1 (rw) */
    unsigned __sfrbit32 EN2:1;           /**< \brief [2:2] Access Enable for Master TAG ID 2 - EN2 (rw) */
    unsigned __sfrbit32 EN3:1;           /**< \brief [3:3] Access Enable for Master TAG ID 3 - EN3 (rw) */
    unsigned __sfrbit32 EN4:1;           /**< \brief [4:4] Access Enable for Master TAG ID 4 - EN4 (rw) */
    unsigned __sfrbit32 EN5:1;           /**< \brief [5:5] Access Enable for Master TAG ID 5 - EN5 (rw) */
    unsigned __sfrbit32 EN6:1;           /**< \brief [6:6] Access Enable for Master TAG ID 6 - EN6 (rw) */
    unsigned __sfrbit32 EN7:1;           /**< \brief [7:7] Access Enable for Master TAG ID 7 - EN7 (rw) */
    unsigned __sfrbit32 EN8:1;           /**< \brief [8:8] Access Enable for Master TAG ID 8 - EN8 (rw) */
    unsigned __sfrbit32 EN9:1;           /**< \brief [9:9] Access Enable for Master TAG ID 9 - EN9 (rw) */
    unsigned __sfrbit32 EN10:1;          /**< \brief [10:10] Access Enable for Master TAG ID 10 - EN10 (rw) */
    unsigned __sfrbit32 EN11:1;          /**< \brief [11:11] Access Enable for Master TAG ID 11 - EN11 (rw) */
    unsigned __sfrbit32 EN12:1;          /**< \brief [12:12] Access Enable for Master TAG ID 12 - EN12 (rw) */
    unsigned __sfrbit32 EN13:1;          /**< \brief [13:13] Access Enable for Master TAG ID 13 - EN13 (rw) */
    unsigned __sfrbit32 EN14:1;          /**< \brief [14:14] Access Enable for Master TAG ID 14 - EN14 (rw) */
    unsigned __sfrbit32 EN15:1;          /**< \brief [15:15] Access Enable for Master TAG ID 15 - EN15 (rw) */
    unsigned __sfrbit32 EN16:1;          /**< \brief [16:16] Access Enable for Master TAG ID 16 - EN16 (rw) */
    unsigned __sfrbit32 EN17:1;          /**< \brief [17:17] Access Enable for Master TAG ID 17 - EN17 (rw) */
    unsigned __sfrbit32 EN18:1;          /**< \brief [18:18] Access Enable for Master TAG ID 18 - EN18 (rw) */
    unsigned __sfrbit32 EN19:1;          /**< \brief [19:19] Access Enable for Master TAG ID 19 - EN19 (rw) */
    unsigned __sfrbit32 EN20:1;          /**< \brief [20:20] Access Enable for Master TAG ID 20 - EN20 (rw) */
    unsigned __sfrbit32 EN21:1;          /**< \brief [21:21] Access Enable for Master TAG ID 21 - EN21 (rw) */
    unsigned __sfrbit32 EN22:1;          /**< \brief [22:22] Access Enable for Master TAG ID 22 - EN22 (rw) */
    unsigned __sfrbit32 EN23:1;          /**< \brief [23:23] Access Enable for Master TAG ID 23 - EN23 (rw) */
    unsigned __sfrbit32 EN24:1;          /**< \brief [24:24] Access Enable for Master TAG ID 24 - EN24 (rw) */
    unsigned __sfrbit32 EN25:1;          /**< \brief [25:25] Access Enable for Master TAG ID 25 - EN25 (rw) */
    unsigned __sfrbit32 EN26:1;          /**< \brief [26:26] Access Enable for Master TAG ID 26 - EN26 (rw) */
    unsigned __sfrbit32 EN27:1;          /**< \brief [27:27] Access Enable for Master TAG ID 27 - EN27 (rw) */
    unsigned __sfrbit32 EN28:1;          /**< \brief [28:28] Access Enable for Master TAG ID 28 - EN28 (rw) */
    unsigned __sfrbit32 EN29:1;          /**< \brief [29:29] Access Enable for Master TAG ID 29 - EN29 (rw) */
    unsigned __sfrbit32 EN30:1;          /**< \brief [30:30] Access Enable for Master TAG ID 30 - EN30 (rw) */
    unsigned __sfrbit32 EN31:1;          /**< \brief [31:31] Access Enable for Master TAG ID 31 - EN31 (rw) */
} Ifx_CPU_SFR_SPROT_ACCENA_W_Bits;

/** \brief CPUx Safety Protection Region Access Enable Register B */
typedef struct _Ifx_CPU_SFR_SPROT_ACCENB_W_Bits
{
    unsigned __sfrbit32 EN32:1;          /**< \brief [0:0] Access Enable for Master TAG ID 32 - EN32 (rw) */
    unsigned __sfrbit32 EN33:1;          /**< \brief [1:1] Access Enable for Master TAG ID 33 - EN33 (rw) */
    unsigned __sfrbit32 EN34:1;          /**< \brief [2:2] Access Enable for Master TAG ID 34 - EN34 (rw) */
    unsigned __sfrbit32 EN35:1;          /**< \brief [3:3] Access Enable for Master TAG ID 35 - EN35 (rw) */
    unsigned __sfrbit32 EN36:1;          /**< \brief [4:4] Access Enable for Master TAG ID 36 - EN36 (rw) */
    unsigned __sfrbit32 EN37:1;          /**< \brief [5:5] Access Enable for Master TAG ID 37 - EN37 (rw) */
    unsigned __sfrbit32 EN38:1;          /**< \brief [6:6] Access Enable for Master TAG ID 38 - EN38 (rw) */
    unsigned __sfrbit32 EN39:1;          /**< \brief [7:7] Access Enable for Master TAG ID 39 - EN39 (rw) */
    unsigned __sfrbit32 EN40:1;          /**< \brief [8:8] Access Enable for Master TAG ID 40 - EN40 (rw) */
    unsigned __sfrbit32 EN41:1;          /**< \brief [9:9] Access Enable for Master TAG ID 41 - EN41 (rw) */
    unsigned __sfrbit32 EN42:1;          /**< \brief [10:10] Access Enable for Master TAG ID 42 - EN42 (rw) */
    unsigned __sfrbit32 EN43:1;          /**< \brief [11:11] Access Enable for Master TAG ID 43 - EN43 (rw) */
    unsigned __sfrbit32 EN44:1;          /**< \brief [12:12] Access Enable for Master TAG ID 44 - EN44 (rw) */
    unsigned __sfrbit32 EN45:1;          /**< \brief [13:13] Access Enable for Master TAG ID 45 - EN45 (rw) */
    unsigned __sfrbit32 EN46:1;          /**< \brief [14:14] Access Enable for Master TAG ID 46 - EN46 (rw) */
    unsigned __sfrbit32 EN47:1;          /**< \brief [15:15] Access Enable for Master TAG ID 47 - EN47 (rw) */
    unsigned __sfrbit32 EN48:1;          /**< \brief [16:16] Access Enable for Master TAG ID 48 - EN48 (rw) */
    unsigned __sfrbit32 EN49:1;          /**< \brief [17:17] Access Enable for Master TAG ID 49 - EN49 (rw) */
    unsigned __sfrbit32 EN50:1;          /**< \brief [18:18] Access Enable for Master TAG ID 50 - EN50 (rw) */
    unsigned __sfrbit32 EN51:1;          /**< \brief [19:19] Access Enable for Master TAG ID 51 - EN51 (rw) */
    unsigned __sfrbit32 EN52:1;          /**< \brief [20:20] Access Enable for Master TAG ID 52 - EN52 (rw) */
    unsigned __sfrbit32 EN53:1;          /**< \brief [21:21] Access Enable for Master TAG ID 53 - EN53 (rw) */
    unsigned __sfrbit32 EN54:1;          /**< \brief [22:22] Access Enable for Master TAG ID 54 - EN54 (rw) */
    unsigned __sfrbit32 EN55:1;          /**< \brief [23:23] Access Enable for Master TAG ID 55 - EN55 (rw) */
    unsigned __sfrbit32 EN56:1;          /**< \brief [24:24] Access Enable for Master TAG ID 56 - EN56 (rw) */
    unsigned __sfrbit32 EN57:1;          /**< \brief [25:25] Access Enable for Master TAG ID 57 - EN57 (rw) */
    unsigned __sfrbit32 EN58:1;          /**< \brief [26:26] Access Enable for Master TAG ID 58 - EN58 (rw) */
    unsigned __sfrbit32 EN59:1;          /**< \brief [27:27] Access Enable for Master TAG ID 59 - EN59 (rw) */
    unsigned __sfrbit32 EN60:1;          /**< \brief [28:28] Access Enable for Master TAG ID 60 - EN60 (rw) */
    unsigned __sfrbit32 EN61:1;          /**< \brief [29:29] Access Enable for Master TAG ID 61 - EN61 (rw) */
    unsigned __sfrbit32 EN62:1;          /**< \brief [30:30] Access Enable for Master TAG ID 62 - EN62 (rw) */
    unsigned __sfrbit32 EN63:1;          /**< \brief [31:31] Access Enable for Master TAG ID 63 - EN63 (rw) */
} Ifx_CPU_SFR_SPROT_ACCENB_W_Bits;

/** \brief CPUx SIST Mode Access Control Register */
typedef struct _Ifx_CPU_SMACON_Bits
{
    unsigned __sfrbit32 reserved_0:24;    /**< \brief [23:0] \internal Reserved */
    unsigned __sfrbit32 IODT:1;          /**< \brief [24:24] In-Order Data Transactions - IODT (rw) */
    unsigned __sfrbit32 reserved_25:7;    /**< \brief [31:25] \internal Reserved */
} Ifx_CPU_SMACON_Bits;

/** \brief CPUx Safety Protection SPR Region Read Access Enable Register A${i} */
typedef struct _Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits
{
    unsigned __sfrbit32 EN0:1;           /**< \brief [0:0] Access Enable for Master TAG ID 0 - EN0 (rw) */
    unsigned __sfrbit32 EN1:1;           /**< \brief [1:1] Access Enable for Master TAG ID 1 - EN1 (rw) */
    unsigned __sfrbit32 EN2:1;           /**< \brief [2:2] Access Enable for Master TAG ID 2 - EN2 (rw) */
    unsigned __sfrbit32 EN3:1;           /**< \brief [3:3] Access Enable for Master TAG ID 3 - EN3 (rw) */
    unsigned __sfrbit32 EN4:1;           /**< \brief [4:4] Access Enable for Master TAG ID 4 - EN4 (rw) */
    unsigned __sfrbit32 EN5:1;           /**< \brief [5:5] Access Enable for Master TAG ID 5 - EN5 (rw) */
    unsigned __sfrbit32 EN6:1;           /**< \brief [6:6] Access Enable for Master TAG ID 6 - EN6 (rw) */
    unsigned __sfrbit32 EN7:1;           /**< \brief [7:7] Access Enable for Master TAG ID 7 - EN7 (rw) */
    unsigned __sfrbit32 EN8:1;           /**< \brief [8:8] Access Enable for Master TAG ID 8 - EN8 (rw) */
    unsigned __sfrbit32 EN9:1;           /**< \brief [9:9] Access Enable for Master TAG ID 9 - EN9 (rw) */
    unsigned __sfrbit32 EN10:1;          /**< \brief [10:10] Access Enable for Master TAG ID 10 - EN10 (rw) */
    unsigned __sfrbit32 EN11:1;          /**< \brief [11:11] Access Enable for Master TAG ID 11 - EN11 (rw) */
    unsigned __sfrbit32 EN12:1;          /**< \brief [12:12] Access Enable for Master TAG ID 12 - EN12 (rw) */
    unsigned __sfrbit32 EN13:1;          /**< \brief [13:13] Access Enable for Master TAG ID 13 - EN13 (rw) */
    unsigned __sfrbit32 EN14:1;          /**< \brief [14:14] Access Enable for Master TAG ID 14 - EN14 (rw) */
    unsigned __sfrbit32 EN15:1;          /**< \brief [15:15] Access Enable for Master TAG ID 15 - EN15 (rw) */
    unsigned __sfrbit32 EN16:1;          /**< \brief [16:16] Access Enable for Master TAG ID 16 - EN16 (rw) */
    unsigned __sfrbit32 EN17:1;          /**< \brief [17:17] Access Enable for Master TAG ID 17 - EN17 (rw) */
    unsigned __sfrbit32 EN18:1;          /**< \brief [18:18] Access Enable for Master TAG ID 18 - EN18 (rw) */
    unsigned __sfrbit32 EN19:1;          /**< \brief [19:19] Access Enable for Master TAG ID 19 - EN19 (rw) */
    unsigned __sfrbit32 EN20:1;          /**< \brief [20:20] Access Enable for Master TAG ID 20 - EN20 (rw) */
    unsigned __sfrbit32 EN21:1;          /**< \brief [21:21] Access Enable for Master TAG ID 21 - EN21 (rw) */
    unsigned __sfrbit32 EN22:1;          /**< \brief [22:22] Access Enable for Master TAG ID 22 - EN22 (rw) */
    unsigned __sfrbit32 EN23:1;          /**< \brief [23:23] Access Enable for Master TAG ID 23 - EN23 (rw) */
    unsigned __sfrbit32 EN24:1;          /**< \brief [24:24] Access Enable for Master TAG ID 24 - EN24 (rw) */
    unsigned __sfrbit32 EN25:1;          /**< \brief [25:25] Access Enable for Master TAG ID 25 - EN25 (rw) */
    unsigned __sfrbit32 EN26:1;          /**< \brief [26:26] Access Enable for Master TAG ID 26 - EN26 (rw) */
    unsigned __sfrbit32 EN27:1;          /**< \brief [27:27] Access Enable for Master TAG ID 27 - EN27 (rw) */
    unsigned __sfrbit32 EN28:1;          /**< \brief [28:28] Access Enable for Master TAG ID 28 - EN28 (rw) */
    unsigned __sfrbit32 EN29:1;          /**< \brief [29:29] Access Enable for Master TAG ID 29 - EN29 (rw) */
    unsigned __sfrbit32 EN30:1;          /**< \brief [30:30] Access Enable for Master TAG ID 30 - EN30 (rw) */
    unsigned __sfrbit32 EN31:1;          /**< \brief [31:31] Access Enable for Master TAG ID 31 - EN31 (rw) */
} Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits;

/** \brief CPUx Safety Protection SPR Region Read Access Enable Register B${i} */
typedef struct _Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits
{
    unsigned __sfrbit32 EN32:1;          /**< \brief [0:0] Access Enable for Master TAG ID 32 - EN32 (rw) */
    unsigned __sfrbit32 EN33:1;          /**< \brief [1:1] Access Enable for Master TAG ID 33 - EN33 (rw) */
    unsigned __sfrbit32 EN34:1;          /**< \brief [2:2] Access Enable for Master TAG ID 34 - EN34 (rw) */
    unsigned __sfrbit32 EN35:1;          /**< \brief [3:3] Access Enable for Master TAG ID 35 - EN35 (rw) */
    unsigned __sfrbit32 EN36:1;          /**< \brief [4:4] Access Enable for Master TAG ID 36 - EN36 (rw) */
    unsigned __sfrbit32 EN37:1;          /**< \brief [5:5] Access Enable for Master TAG ID 37 - EN37 (rw) */
    unsigned __sfrbit32 EN38:1;          /**< \brief [6:6] Access Enable for Master TAG ID 38 - EN38 (rw) */
    unsigned __sfrbit32 EN39:1;          /**< \brief [7:7] Access Enable for Master TAG ID 39 - EN39 (rw) */
    unsigned __sfrbit32 EN40:1;          /**< \brief [8:8] Access Enable for Master TAG ID 40 - EN40 (rw) */
    unsigned __sfrbit32 EN41:1;          /**< \brief [9:9] Access Enable for Master TAG ID 41 - EN41 (rw) */
    unsigned __sfrbit32 EN42:1;          /**< \brief [10:10] Access Enable for Master TAG ID 42 - EN42 (rw) */
    unsigned __sfrbit32 EN43:1;          /**< \brief [11:11] Access Enable for Master TAG ID 43 - EN43 (rw) */
    unsigned __sfrbit32 EN44:1;          /**< \brief [12:12] Access Enable for Master TAG ID 44 - EN44 (rw) */
    unsigned __sfrbit32 EN45:1;          /**< \brief [13:13] Access Enable for Master TAG ID 45 - EN45 (rw) */
    unsigned __sfrbit32 EN46:1;          /**< \brief [14:14] Access Enable for Master TAG ID 46 - EN46 (rw) */
    unsigned __sfrbit32 EN47:1;          /**< \brief [15:15] Access Enable for Master TAG ID 47 - EN47 (rw) */
    unsigned __sfrbit32 EN48:1;          /**< \brief [16:16] Access Enable for Master TAG ID 48 - EN48 (rw) */
    unsigned __sfrbit32 EN49:1;          /**< \brief [17:17] Access Enable for Master TAG ID 49 - EN49 (rw) */
    unsigned __sfrbit32 EN50:1;          /**< \brief [18:18] Access Enable for Master TAG ID 50 - EN50 (rw) */
    unsigned __sfrbit32 EN51:1;          /**< \brief [19:19] Access Enable for Master TAG ID 51 - EN51 (rw) */
    unsigned __sfrbit32 EN52:1;          /**< \brief [20:20] Access Enable for Master TAG ID 52 - EN52 (rw) */
    unsigned __sfrbit32 EN53:1;          /**< \brief [21:21] Access Enable for Master TAG ID 53 - EN53 (rw) */
    unsigned __sfrbit32 EN54:1;          /**< \brief [22:22] Access Enable for Master TAG ID 54 - EN54 (rw) */
    unsigned __sfrbit32 EN55:1;          /**< \brief [23:23] Access Enable for Master TAG ID 55 - EN55 (rw) */
    unsigned __sfrbit32 EN56:1;          /**< \brief [24:24] Access Enable for Master TAG ID 56 - EN56 (rw) */
    unsigned __sfrbit32 EN57:1;          /**< \brief [25:25] Access Enable for Master TAG ID 57 - EN57 (rw) */
    unsigned __sfrbit32 EN58:1;          /**< \brief [26:26] Access Enable for Master TAG ID 58 - EN58 (rw) */
    unsigned __sfrbit32 EN59:1;          /**< \brief [27:27] Access Enable for Master TAG ID 59 - EN59 (rw) */
    unsigned __sfrbit32 EN60:1;          /**< \brief [28:28] Access Enable for Master TAG ID 60 - EN60 (rw) */
    unsigned __sfrbit32 EN61:1;          /**< \brief [29:29] Access Enable for Master TAG ID 61 - EN61 (rw) */
    unsigned __sfrbit32 EN62:1;          /**< \brief [30:30] Access Enable for Master TAG ID 62 - EN62 (rw) */
    unsigned __sfrbit32 EN63:1;          /**< \brief [31:31] Access Enable for Master TAG ID 63 - EN63 (rw) */
} Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits;

/** \brief CPUx Software Debug Event */
typedef struct _Ifx_CPU_SWEVT_Bits
{
    unsigned __sfrbit32 EVTA:3;          /**< \brief [2:0] Event Associated - EVTA (rw) */
    unsigned __sfrbit32 BBM:1;           /**< \brief [3:3] Break Before Make (BBM) or Break After Make (BAM) Selection - BBM (rw) */
    unsigned __sfrbit32 BOD:1;           /**< \brief [4:4] Breakout Disable - BOD (rw) */
    unsigned __sfrbit32 SUSP:1;          /**< \brief [5:5] CDC Suspend-Out Signal State - SUSP (rw) */
    unsigned __sfrbit32 CNT:2;           /**< \brief [7:6] Counter - CNT (rw) */
    unsigned __sfrbit32 reserved_8:24;    /**< \brief [31:8] \internal Reserved */
} Ifx_CPU_SWEVT_Bits;

/** \brief CPUx System Configuration Register */
typedef struct _Ifx_CPU_SYSCON_Bits
{
    unsigned __sfrbit32 FCDSF:1;         /**< \brief [0:0] Free Context List Depleted Sticky Flag - FCDSF (rwh) */
    unsigned __sfrbit32 PROTEN:1;        /**< \brief [1:1] Memory Protection Enable - PROTEN (rw) */
    unsigned __sfrbit32 TPROTEN:1;       /**< \brief [2:2] Temporal Protection Enable - TPROTEN (rw) */
    unsigned __sfrbit32 IS:1;            /**< \brief [3:3] Initial State Interrupt - IS (rw) */
    unsigned __sfrbit32 TS:1;            /**< \brief [4:4] Initial State Trap - TS (rw) */
    unsigned __sfrbit32 reserved_5:3;    /**< \brief [7:5] \internal Reserved */
    unsigned __sfrbit32 ESDIS:1;         /**< \brief [8:8] Emulator Space Disable (rw) */
    unsigned __sfrbit32 reserved_9:7;    /**< \brief [15:9] \internal Reserved */
    unsigned __sfrbit32 U1_IED:1;        /**< \brief [16:16] User-1 Instruction execution disable - U1_IED (rw) */
    unsigned __sfrbit32 U1_IOS:1;        /**< \brief [17:17] User-1 Peripheral access as supervisor - U1_IOS (rw) */
    unsigned __sfrbit32 reserved_18:6;    /**< \brief [23:18] \internal Reserved */
    unsigned __sfrbit32 BHALT:1;         /**< \brief [24:24] Boot Halt - BHALT (rw) */
    unsigned __sfrbit32 reserved_25:7;    /**< \brief [31:25] \internal Reserved */
} Ifx_CPU_SYSCON_Bits;

/** \brief CPUx Task Address Space Identifier Register */
typedef struct _Ifx_CPU_TASK_ASI_Bits
{
    unsigned __sfrbit32 ASI:5;           /**< \brief [4:0] Address Space Identifier - ASI (rw) */
    unsigned __sfrbit32 reserved_5:27;    /**< \brief [31:5] \internal Reserved */
} Ifx_CPU_TASK_ASI_Bits;

/** \brief CPUx Temporal Protection System Control Register */
typedef struct _Ifx_CPU_TPS_CON_Bits
{
    unsigned __sfrbit32 TEXP0:1;         /**< \brief [0:0] Timer0 Expired Flag - TEXP0 (rh) */
    unsigned __sfrbit32 TEXP1:1;         /**< \brief [1:1] Timer1 Expired Flag - TEXP1 (rh) */
    unsigned __sfrbit32 TEXP2:1;         /**< \brief [2:2] Timer1 Expired Flag - TEXP2 (rh) */
    unsigned __sfrbit32 reserved_3:13;    /**< \brief [15:3] \internal Reserved */
    unsigned __sfrbit32 TTRAP:1;         /**< \brief [16:16] Temporal Protection Trap - TTRAP (rh) */
    unsigned __sfrbit32 reserved_17:15;    /**< \brief [31:17] \internal Reserved */
} Ifx_CPU_TPS_CON_Bits;

/** \brief CPUx Exception Timer Class Enable Register */
typedef struct _Ifx_CPU_TPS_EXTIM_CLASS_EN_Bits
{
    unsigned __sfrbit32 EXTIM_CLASS_EN:8;    /**< \brief [7:0] Exception Timer Class Enables - EXTIM_CLASS_EN (rw) */
    unsigned __sfrbit32 reserved_8:24;    /**< \brief [31:8] \internal Reserved */
} Ifx_CPU_TPS_EXTIM_CLASS_EN_Bits;

/** \brief CPUx Exception Entry Timer Current Value */
typedef struct _Ifx_CPU_TPS_EXTIM_ENTRY_CVAL_Bits
{
    unsigned __sfrbit32 ENTRY_CVAL:12;    /**< \brief [11:0] Exception Entry Timer Current Value - ENTRY_CVAL (rh) */
    unsigned __sfrbit32 reserved_12:20;    /**< \brief [31:12] \internal Reserved */
} Ifx_CPU_TPS_EXTIM_ENTRY_CVAL_Bits;

/** \brief CPUx Exception Entry Timer Load Value */
typedef struct _Ifx_CPU_TPS_EXTIM_ENTRY_LVAL_Bits
{
    unsigned __sfrbit32 reserved_0:4;    /**< \brief [3:0] \internal Reserved */
    unsigned __sfrbit32 ENTRY_LVAL:8;    /**< \brief [11:4] Exception Entry Timer Load value - ENTRY_LVAL (rw) */
    unsigned __sfrbit32 reserved_12:20;    /**< \brief [31:12] \internal Reserved */
} Ifx_CPU_TPS_EXTIM_ENTRY_LVAL_Bits;

/** \brief CPUx Exception Exit Timer Current Value */
typedef struct _Ifx_CPU_TPS_EXTIM_EXIT_CVAL_Bits
{
    unsigned __sfrbit32 EXIT_CVAL:24;    /**< \brief [23:0] Exception Exit Timer Current Value - EXIT_CVAL (rh) */
    unsigned __sfrbit32 reserved_24:8;    /**< \brief [31:24] \internal Reserved */
} Ifx_CPU_TPS_EXTIM_EXIT_CVAL_Bits;

/** \brief CPUx Exception Exit  Timer Load Value */
typedef struct _Ifx_CPU_TPS_EXTIM_EXIT_LVAL_Bits
{
    unsigned __sfrbit32 reserved_0:4;    /**< \brief [3:0] \internal Reserved */
    unsigned __sfrbit32 EXIT_LVAL:20;    /**< \brief [23:4] Exception Exit Timer Load value - EXIT_LVAL (rw) */
    unsigned __sfrbit32 reserved_24:8;    /**< \brief [31:24] \internal Reserved */
} Ifx_CPU_TPS_EXTIM_EXIT_LVAL_Bits;

/** \brief CPUx Exception Timer FCX Register */
typedef struct _Ifx_CPU_TPS_EXTIM_FCX_Bits
{
    unsigned __sfrbit32 EXIT_FCX:20;     /**< \brief [19:0] Exception Exit Timer FCX - EXIT_FCX (rh) */
    unsigned __sfrbit32 reserved_20:12;    /**< \brief [31:20] \internal Reserved */
} Ifx_CPU_TPS_EXTIM_FCX_Bits;

/** \brief CPUx Exception Timer Status Register */
typedef struct _Ifx_CPU_TPS_EXTIM_STAT_Bits
{
    unsigned __sfrbit32 EXIT_TIN:8;      /**< \brief [7:0] Exception Exit Timer TIN - EXIT_TIN (rwh) */
    unsigned __sfrbit32 EXIT_CLASS:3;    /**< \brief [10:8] Exception Exit Timer Class - EXIT_CLASS (rwh) */
    unsigned __sfrbit32 reserved_11:4;    /**< \brief [14:11] \internal Reserved */
    unsigned __sfrbit32 EXIT_AT:1;       /**< \brief [15:15] Exception Exit Timer Alarm Triggered - EXIT_AT (rh) */
    unsigned __sfrbit32 ENTRY_TIN:8;     /**< \brief [23:16] Exception Entry Timer TIN - ENTRY_TIN (rwh) */
    unsigned __sfrbit32 ENTRY_CLASS:3;    /**< \brief [26:24] Exception Entry Timer Class - ENTRY_CLASS (rwh) */
    unsigned __sfrbit32 reserved_27:4;    /**< \brief [30:27] \internal Reserved */
    unsigned __sfrbit32 ENTRY_AT:1;      /**< \brief [31:31] Exception Entry Timer Alarm Triggered - ENTRY_AT (rh) */
} Ifx_CPU_TPS_EXTIM_STAT_Bits;

/** \brief CPUx Temporal Protection System Timer Register ${y} */
typedef struct _Ifx_CPU_TPS_TIMER_Bits
{
    unsigned __sfrbit32 TIMER:32;        /**< \brief [31:0] Temporal Protection Timer - Timer (rwh) */
} Ifx_CPU_TPS_TIMER_Bits;

/** \brief CPUx TriggerAddressx */
typedef struct _Ifx_CPU_TRIG_ACC_Bits
{
    unsigned __sfrbit32 T0:1;            /**< \brief [0:0] Trigger-0 - T0 (rh) */
    unsigned __sfrbit32 T1:1;            /**< \brief [1:1] Trigger-1 - T1 (rh) */
    unsigned __sfrbit32 T2:1;            /**< \brief [2:2] Trigger-2 - T2 (rh) */
    unsigned __sfrbit32 T3:1;            /**< \brief [3:3] Trigger-3 - T3 (rh) */
    unsigned __sfrbit32 T4:1;            /**< \brief [4:4] Trigger-4 - T4 (rh) */
    unsigned __sfrbit32 T5:1;            /**< \brief [5:5] Trigger-5 - T5 (rh) */
    unsigned __sfrbit32 T6:1;            /**< \brief [6:6] Trigger-6 - T6 (rh) */
    unsigned __sfrbit32 T7:1;            /**< \brief [7:7] Trigger-7 - T7 (rh) */
    unsigned __sfrbit32 reserved_8:24;    /**< \brief [31:8] \internal Reserved */
} Ifx_CPU_TRIG_ACC_Bits;

/** \brief CPUx Trigger Address ${i} */
typedef struct _Ifx_CPU_TR_ADR_Bits
{
    unsigned __sfrbit32 ADDR:32;         /**< \brief [31:0] Comparison Address - ADDR (rw) */
} Ifx_CPU_TR_ADR_Bits;

/** \brief CPUx Trigger Event ${i} */
typedef struct _Ifx_CPU_TR_EVT_Bits
{
    unsigned __sfrbit32 EVTA:3;          /**< \brief [2:0] Event Associated - EVTA (rw) */
    unsigned __sfrbit32 BBM:1;           /**< \brief [3:3] Break Before Make (BBM) or Break After Make (BAM) Selection - BBM (rw) */
    unsigned __sfrbit32 BOD:1;           /**< \brief [4:4] Breakout Disable - BOD (rw) */
    unsigned __sfrbit32 SUSP:1;          /**< \brief [5:5] CDC Suspend-Out Signal State - SUSP (rw) */
    unsigned __sfrbit32 CNT:2;           /**< \brief [7:6] Counter - CNT (rw) */
    unsigned __sfrbit32 reserved_8:4;    /**< \brief [11:8] \internal Reserved */
    unsigned __sfrbit32 TYP:1;           /**< \brief [12:12] Input Selection - TYP (rw) */
    unsigned __sfrbit32 RNG:1;           /**< \brief [13:13] Compare Type - RNG (rw) */
    unsigned __sfrbit32 reserved_14:1;    /**< \brief [14:14] \internal Reserved */
    unsigned __sfrbit32 ASI_EN:1;        /**< \brief [15:15] Enable ASI Comparison - ASI_EN (rw) */
    unsigned __sfrbit32 ASI:5;           /**< \brief [20:16] Address Space Identifier - ASI (rw) */
    unsigned __sfrbit32 reserved_21:6;    /**< \brief [26:21] \internal Reserved */
    unsigned __sfrbit32 AST:1;           /**< \brief [27:27] Address Store - AST (rw) */
    unsigned __sfrbit32 ALD:1;           /**< \brief [28:28] Address Load - ALD (rw) */
    unsigned __sfrbit32 reserved_29:3;    /**< \brief [31:29] \internal Reserved */
} Ifx_CPU_TR_EVT_Bits;

/** \}  */
/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_cpu_Registers_union
 * \{   */
/** \brief CPUx Address General Purpose Register ${y}   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_A_Bits B;                 /**< \brief Bitfield access */
} Ifx_CPU_A;

/** \brief CPUx Base Interrupt Vector Table Pointer   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_BIV_Bits B;               /**< \brief Bitfield access */
} Ifx_CPU_BIV;

/** \brief CPUx Overlay Mask Register ${i}   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_BLK_OMASK_Bits B;         /**< \brief Bitfield access */
} Ifx_CPU_BLK_OMASK;

/** \brief CPUx Overlay Target Address Register ${i}   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_BLK_OTAR_Bits B;          /**< \brief Bitfield access */
} Ifx_CPU_BLK_OTAR;

/** \brief CPUx Redirected Address Base Register ${i}   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_BLK_RABR_Bits B;          /**< \brief Bitfield access */
} Ifx_CPU_BLK_RABR;

/** \brief CPUx Base Trap Vector Table Pointer   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_BTV_Bits B;               /**< \brief Bitfield access */
} Ifx_CPU_BTV;

/** \brief CPUx CPU Clock Cycle Count   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_CCNT_Bits B;              /**< \brief Bitfield access */
} Ifx_CPU_CCNT;

/** \brief CPUx Counter Control   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_CCTRL_Bits B;             /**< \brief Bitfield access */
} Ifx_CPU_CCTRL;

/** \brief CPUx Compatibility Control Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_COMPAT_Bits B;            /**< \brief Bitfield access */
} Ifx_CPU_COMPAT;

/** \brief CPUx Core Identification Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_CORE_ID_Bits B;           /**< \brief Bitfield access */
} Ifx_CPU_CORE_ID;

/** \brief CPUx Code Protection Range ${y} Lower Bound Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_CPR_L_Bits B;             /**< \brief Bitfield access */
} Ifx_CPU_CPR_L;

/** \brief CPUx Code Protection Range ${y} Upper Bound Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_CPR_U_Bits B;             /**< \brief Bitfield access */
} Ifx_CPU_CPR_U;

/** \brief CPUx Identification Register TC1.6.2P   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_CPU_ID_Bits B;            /**< \brief Bitfield access */
} Ifx_CPU_CPU_ID;

/** \brief    */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_CPXE_Bits B;              /**< \brief Bitfield access */
} Ifx_CPU_CPXE;

/** \brief CPUx Core Register Access Event   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_CREVT_Bits B;             /**< \brief Bitfield access */
} Ifx_CPU_CREVT;

/** \brief CPUx Customer ID register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_CUS_ID_Bits B;            /**< \brief Bitfield access */
} Ifx_CPU_CUS_ID;

/** \brief CPUx Data General Purpose Register ${y}   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_D_Bits B;                 /**< \brief Bitfield access */
} Ifx_CPU_D;

/** \brief CPUx Data Asynchronous Trap Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_DATR_Bits B;              /**< \brief Bitfield access */
} Ifx_CPU_DATR;

/** \brief CPUx Debug Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_DBGSR_Bits B;             /**< \brief Bitfield access */
} Ifx_CPU_DBGSR;

/** \brief CPUx Debug Trap Control Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_DBGTCR_Bits B;            /**< \brief Bitfield access */
} Ifx_CPU_DBGTCR;

/** \brief CPUx Data Memory Control Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_DCON0_Bits B;             /**< \brief Bitfield access */
} Ifx_CPU_DCON0;

/** \brief CPUx Data Control Register 2   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_DCON2_Bits B;             /**< \brief Bitfield access */
} Ifx_CPU_DCON2;

/** \brief CPUx Debug Context Save Area Pointer   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_DCX_Bits B;               /**< \brief Bitfield access */
} Ifx_CPU_DCX;

/** \brief CPUx Data Error Address Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_DEADD_Bits B;             /**< \brief Bitfield access */
} Ifx_CPU_DEADD;

/** \brief CPUx Data Integrity Error Address Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_DIEAR_Bits B;             /**< \brief Bitfield access */
} Ifx_CPU_DIEAR;

/** \brief CPUx Data Integrity Error Trap Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_DIETR_Bits B;             /**< \brief Bitfield access */
} Ifx_CPU_DIETR;

/** \brief CPUx Safety Protection Region DLMU Read Access Enable Register A${i}   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits B;    /**< \brief Bitfield access */
} Ifx_CPU_DLMU_SPROT_RGNACCENA_R;

/** \brief CPUx Safety Protection Region DLMU Write Access Enable Register A${i}   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits B;    /**< \brief Bitfield access */
} Ifx_CPU_DLMU_SPROT_RGNACCENA_W;

/** \brief CPUx Safety Protection Region DLMU Read Access Enable Register B${i}   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits B;    /**< \brief Bitfield access */
} Ifx_CPU_DLMU_SPROT_RGNACCENB_R;

/** \brief CPUx Safety Protection Region DLMU Write Access Enable Register B${i}   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits B;    /**< \brief Bitfield access */
} Ifx_CPU_DLMU_SPROT_RGNACCENB_W;

/** \brief CPUx Safety Protection DLMU Region Lower Address Register ${i}   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_DLMU_SPROT_RGNLA_Bits B;    /**< \brief Bitfield access */
} Ifx_CPU_DLMU_SPROT_RGNLA;

/** \brief CPUx Safety protection DLMU Region Upper Address Register ${i}   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_DLMU_SPROT_RGNUA_Bits B;    /**< \brief Bitfield access */
} Ifx_CPU_DLMU_SPROT_RGNUA;

/** \brief CPUx Debug Monitor Start Address   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_DMS_Bits B;               /**< \brief Bitfield access */
} Ifx_CPU_DMS;

/** \brief    */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_DPRE_Bits B;              /**< \brief Bitfield access */
} Ifx_CPU_DPRE;

/** \brief CPUx Data Protection Range ${y}, Lower Bound Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_DPR_L_Bits B;             /**< \brief Bitfield access */
} Ifx_CPU_DPR_L;

/** \brief CPUx Data Protection Range ${y}, Upper Bound Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_DPR_U_Bits B;             /**< \brief Bitfield access */
} Ifx_CPU_DPR_U;

/** \brief    */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_DPWE_Bits B;              /**< \brief Bitfield access */
} Ifx_CPU_DPWE;

/** \brief CPUx Data Synchronous Trap Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_DSTR_Bits B;              /**< \brief Bitfield access */
} Ifx_CPU_DSTR;

/** \brief CPUx External Event Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_EXEVT_Bits B;             /**< \brief Bitfield access */
} Ifx_CPU_EXEVT;

/** \brief CPUx Free CSA List Head Pointer   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_FCX_Bits B;               /**< \brief Bitfield access */
} Ifx_CPU_FCX;

/** \brief CPUx Flash Configuration Register 0   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_FLASHCON0_Bits B;         /**< \brief Bitfield access */
} Ifx_CPU_FLASHCON0;

/** \brief CPUx Flash Configuration Register 1   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_FLASHCON1_Bits B;         /**< \brief Bitfield access */
} Ifx_CPU_FLASHCON1;

/** \brief CPUx Flash Configuration Register 2   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_FLASHCON2_Bits B;         /**< \brief Bitfield access */
} Ifx_CPU_FLASHCON2;

/** \brief CPUx Flash Configuration Register 3   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_FLASHCON3_Bits B;         /**< \brief Bitfield access */
} Ifx_CPU_FLASHCON3;

/** \brief CPUx Flash Configuration Register 4   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_FLASHCON4_Bits B;         /**< \brief Bitfield access */
} Ifx_CPU_FLASHCON4;

/** \brief CPUx Trap Control Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_FPU_TRAP_CON_Bits B;      /**< \brief Bitfield access */
} Ifx_CPU_FPU_TRAP_CON;

/** \brief CPUx Trapping Instruction Opcode Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_FPU_TRAP_OPC_Bits B;      /**< \brief Bitfield access */
} Ifx_CPU_FPU_TRAP_OPC;

/** \brief CPUx Trapping Instruction Program Counter Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_FPU_TRAP_PC_Bits B;       /**< \brief Bitfield access */
} Ifx_CPU_FPU_TRAP_PC;

/** \brief CPUx Trapping Instruction Operand Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_FPU_TRAP_SRC1_Bits B;     /**< \brief Bitfield access */
} Ifx_CPU_FPU_TRAP_SRC1;

/** \brief CPUx Trapping Instruction Operand Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_FPU_TRAP_SRC2_Bits B;     /**< \brief Bitfield access */
} Ifx_CPU_FPU_TRAP_SRC2;

/** \brief CPUx Trapping Instruction Operand Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_FPU_TRAP_SRC3_Bits B;     /**< \brief Bitfield access */
} Ifx_CPU_FPU_TRAP_SRC3;

/** \brief CPUx Instruction Count   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_ICNT_Bits B;              /**< \brief Bitfield access */
} Ifx_CPU_ICNT;

/** \brief CPUx Interrupt Control Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_ICR_Bits B;               /**< \brief Bitfield access */
} Ifx_CPU_ICR;

/** \brief CPUx Interrupt Stack Pointer   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_ISP_Bits B;               /**< \brief Bitfield access */
} Ifx_CPU_ISP;

/** \brief CPUx  Reset Register 0   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_KRST0_Bits B;             /**< \brief Bitfield access */
} Ifx_CPU_KRST0;

/** \brief CPUx  Reset Register 1   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_KRST1_Bits B;             /**< \brief Bitfield access */
} Ifx_CPU_KRST1;

/** \brief CPUx Reset Clear Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_KRSTCLR_Bits B;           /**< \brief Bitfield access */
} Ifx_CPU_KRSTCLR;

/** \brief CPUx Free CSA List Limit Pointer   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_LCX_Bits B;               /**< \brief Bitfield access */
} Ifx_CPU_LCX;

/** \brief CPUx Safety Protection Region LPB Read Access Enable Register A   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_LPB_SPROT_ACCENA_R_Bits B;    /**< \brief Bitfield access */
} Ifx_CPU_LPB_SPROT_ACCENA_R;

/** \brief CPUx Safety Protection Region LPB Read Access Enable Register B   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_LPB_SPROT_ACCENB_R_Bits B;    /**< \brief Bitfield access */
} Ifx_CPU_LPB_SPROT_ACCENB_R;

/** \brief CPUx Multi-Count Register 1   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_M1CNT_Bits B;             /**< \brief Bitfield access */
} Ifx_CPU_M1CNT;

/** \brief CPUx Multi-Count Register 2   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_M2CNT_Bits B;             /**< \brief Bitfield access */
} Ifx_CPU_M2CNT;

/** \brief CPUx Multi-Count Register 3   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_M3CNT_Bits B;             /**< \brief Bitfield access */
} Ifx_CPU_M3CNT;

/** \brief CPUx  Overlay Range Select Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_OSEL_Bits B;              /**< \brief Bitfield access */
} Ifx_CPU_OSEL;

/** \brief CPUx Program Counter   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_PC_Bits B;                /**< \brief Bitfield access */
} Ifx_CPU_PC;

/** \brief CPUx Program Control 0   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_PCON0_Bits B;             /**< \brief Bitfield access */
} Ifx_CPU_PCON0;

/** \brief CPUx Program Control 1   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_PCON1_Bits B;             /**< \brief Bitfield access */
} Ifx_CPU_PCON1;

/** \brief CPUx Program Control 2   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_PCON2_Bits B;             /**< \brief Bitfield access */
} Ifx_CPU_PCON2;

/** \brief CPUx Previous Context Information Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_PCXI_Bits B;              /**< \brief Bitfield access */
} Ifx_CPU_PCXI;

/** \brief CPUx Program Integrity Error Address Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_PIEAR_Bits B;             /**< \brief Bitfield access */
} Ifx_CPU_PIEAR;

/** \brief CPUx Program Integrity Error Trap Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_PIETR_Bits B;             /**< \brief Bitfield access */
} Ifx_CPU_PIETR;

/** \brief CPUx Data Access CacheabilityRegister   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_PMA0_Bits B;              /**< \brief Bitfield access */
} Ifx_CPU_PMA0;

/** \brief CPUx Code Access CacheabilityRegister   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_PMA1_Bits B;              /**< \brief Bitfield access */
} Ifx_CPU_PMA1;

/** \brief CPUx  Peripheral Space Identifier register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_PMA2_Bits B;              /**< \brief Bitfield access */
} Ifx_CPU_PMA2;

/** \brief CPUx Program Synchronous Trap Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_PSTR_Bits B;              /**< \brief Bitfield access */
} Ifx_CPU_PSTR;

/** \brief CPUx Program Status Word   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_PSW_Bits B;               /**< \brief Bitfield access */
} Ifx_CPU_PSW;

/** \brief CPUx Safety Protection SPR Region Write Access Enable Register A${i}   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_RGN_ACCENA_Bits B;        /**< \brief Bitfield access */
} Ifx_CPU_RGN_ACCENA;

/** \brief CPUx Safety Protection SPR Region Write Access Enable Register B${i}   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_RGN_ACCENB_Bits B;        /**< \brief Bitfield access */
} Ifx_CPU_RGN_ACCENB;

/** \brief CPUx Safety Protection SPR Region Lower Address Register ${i}   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_RGN_LA_Bits B;            /**< \brief Bitfield access */
} Ifx_CPU_RGN_LA;

/** \brief CPUx Safety Protection SPR Region Upper Address Register ${i}   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_RGN_UA_Bits B;            /**< \brief Bitfield access */
} Ifx_CPU_RGN_UA;

/** \brief CPUx SRI Error Generation Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_SEGEN_Bits B;             /**< \brief Bitfield access */
} Ifx_CPU_SEGEN;

/** \brief CPUx Safety Protection Register Access Enable Register A   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_SFR_SPROT_ACCENA_W_Bits B;    /**< \brief Bitfield access */
} Ifx_CPU_SFR_SPROT_ACCENA_W;

/** \brief CPUx Safety Protection Region Access Enable Register B   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_SFR_SPROT_ACCENB_W_Bits B;    /**< \brief Bitfield access */
} Ifx_CPU_SFR_SPROT_ACCENB_W;

/** \brief CPUx SIST Mode Access Control Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_SMACON_Bits B;            /**< \brief Bitfield access */
} Ifx_CPU_SMACON;

/** \brief CPUx Safety Protection SPR Region Read Access Enable Register A${i}   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits B;    /**< \brief Bitfield access */
} Ifx_CPU_SPR_SPROT_RGNACCENA_R;

/** \brief CPUx Safety Protection SPR Region Read Access Enable Register B${i}   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits B;    /**< \brief Bitfield access */
} Ifx_CPU_SPR_SPROT_RGNACCENB_R;

/** \brief CPUx Software Debug Event   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_SWEVT_Bits B;             /**< \brief Bitfield access */
} Ifx_CPU_SWEVT;

/** \brief CPUx System Configuration Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_SYSCON_Bits B;            /**< \brief Bitfield access */
} Ifx_CPU_SYSCON;

/** \brief CPUx Task Address Space Identifier Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_TASK_ASI_Bits B;          /**< \brief Bitfield access */
} Ifx_CPU_TASK_ASI;

/** \brief CPUx Temporal Protection System Control Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_TPS_CON_Bits B;           /**< \brief Bitfield access */
} Ifx_CPU_TPS_CON;

/** \brief CPUx Exception Timer Class Enable Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_TPS_EXTIM_CLASS_EN_Bits B;    /**< \brief Bitfield access */
} Ifx_CPU_TPS_EXTIM_CLASS_EN;

/** \brief CPUx Exception Entry Timer Current Value   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_TPS_EXTIM_ENTRY_CVAL_Bits B;    /**< \brief Bitfield access */
} Ifx_CPU_TPS_EXTIM_ENTRY_CVAL;

/** \brief CPUx Exception Entry Timer Load Value   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_TPS_EXTIM_ENTRY_LVAL_Bits B;    /**< \brief Bitfield access */
} Ifx_CPU_TPS_EXTIM_ENTRY_LVAL;

/** \brief CPUx Exception Exit Timer Current Value   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_TPS_EXTIM_EXIT_CVAL_Bits B;    /**< \brief Bitfield access */
} Ifx_CPU_TPS_EXTIM_EXIT_CVAL;

/** \brief CPUx Exception Exit  Timer Load Value   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_TPS_EXTIM_EXIT_LVAL_Bits B;    /**< \brief Bitfield access */
} Ifx_CPU_TPS_EXTIM_EXIT_LVAL;

/** \brief CPUx Exception Timer FCX Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_TPS_EXTIM_FCX_Bits B;     /**< \brief Bitfield access */
} Ifx_CPU_TPS_EXTIM_FCX;

/** \brief CPUx Exception Timer Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_TPS_EXTIM_STAT_Bits B;    /**< \brief Bitfield access */
} Ifx_CPU_TPS_EXTIM_STAT;

/** \brief CPUx Temporal Protection System Timer Register ${y}   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_TPS_TIMER_Bits B;         /**< \brief Bitfield access */
} Ifx_CPU_TPS_TIMER;

/** \brief CPUx TriggerAddressx   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_TRIG_ACC_Bits B;          /**< \brief Bitfield access */
} Ifx_CPU_TRIG_ACC;

/** \brief CPUx Trigger Address ${i}   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_TR_ADR_Bits B;            /**< \brief Bitfield access */
} Ifx_CPU_TR_ADR;

/** \brief CPUx Trigger Event ${i}   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_CPU_TR_EVT_Bits B;            /**< \brief Bitfield access */
} Ifx_CPU_TR_EVT;

/** \}  */

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Cpu_RGN_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief RGN object */
typedef volatile struct _Ifx_CPU_RGN
{
       Ifx_CPU_RGN_LA                      LA;                     /**< \brief 0, CPUx Safety Protection SPR Region Lower Address Register ${i}*/
       Ifx_CPU_RGN_UA                      UA;                     /**< \brief 4, CPUx Safety Protection SPR Region Upper Address Register ${i}*/
       Ifx_CPU_RGN_ACCENA                  ACCENA;                 /**< \brief 8, CPUx Safety Protection SPR Region Write Access Enable Register A${i}*/
       Ifx_CPU_RGN_ACCENB                  ACCENB;                 /**< \brief C, CPUx Safety Protection SPR Region Write Access Enable Register B${i}*/
} Ifx_CPU_RGN;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Cpu_BLK_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief BLK object */
typedef volatile struct _Ifx_CPU_BLK
{
       Ifx_CPU_BLK_RABR                    RABR;                   /**< \brief 0, CPUx Redirected Address Base Register ${i}*/
       Ifx_CPU_BLK_OTAR                    OTAR;                   /**< \brief 4, CPUx Overlay Target Address Register ${i}*/
       Ifx_CPU_BLK_OMASK                   OMASK;                  /**< \brief 8, CPUx Overlay Mask Register ${i}*/
} Ifx_CPU_BLK;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Cpu_FPU_TRAP_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief FPU_TRAP object */
typedef volatile struct _Ifx_CPU_FPU_TRAP
{
       Ifx_CPU_FPU_TRAP_CON                CON;                    /**< \brief 0, CPUx Trap Control Register*/
       Ifx_CPU_FPU_TRAP_PC                 PC;                     /**< \brief 4, CPUx Trapping Instruction Program Counter Register*/
       Ifx_CPU_FPU_TRAP_OPC                OPC;                    /**< \brief 8, CPUx Trapping Instruction Opcode Register*/
       Ifx_UReg_8Bit                       reserved_C[4];          /**< \brief C, \internal Reserved */
       Ifx_CPU_FPU_TRAP_SRC1               SRC1;                   /**< \brief 10, CPUx Trapping Instruction Operand Register*/
       Ifx_CPU_FPU_TRAP_SRC2               SRC2;                   /**< \brief 14, CPUx Trapping Instruction Operand Register*/
       Ifx_CPU_FPU_TRAP_SRC3               SRC3;                   /**< \brief 18, CPUx Trapping Instruction Operand Register*/
} Ifx_CPU_FPU_TRAP;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Cpu_DPR_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief DPR object */
typedef volatile struct _Ifx_CPU_DPR
{
       Ifx_CPU_DPR_L                       L;                      /**< \brief 0, CPUx Data Protection Range ${y}, Lower Bound Register*/
       Ifx_CPU_DPR_U                       U;                      /**< \brief 4, CPUx Data Protection Range ${y}, Upper Bound Register*/
} Ifx_CPU_DPR;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Cpu_CPR_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief CPR object */
typedef volatile struct _Ifx_CPU_CPR
{
       Ifx_CPU_CPR_L                       L;                      /**< \brief 0, CPUx Code Protection Range ${y} Lower Bound Register*/
       Ifx_CPU_CPR_U                       U;                      /**< \brief 4, CPUx Code Protection Range ${y} Upper Bound Register*/
} Ifx_CPU_CPR;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Cpu_TPS_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief TPS object */
typedef volatile struct _Ifx_CPU_TPS
{
       Ifx_CPU_TPS_CON                     CON;                    /**< \brief 0, CPUx Temporal Protection System Control Register*/
       Ifx_CPU_TPS_TIMER                   TIMER[3];               /**< \brief 4, CPUx Temporal Protection System Timer Register ${y}*/
} Ifx_CPU_TPS;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Cpu_TPS_EXTIM_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief TPS_EXTIM object */
typedef volatile struct _Ifx_CPU_TPS_EXTIM
{
       Ifx_CPU_TPS_EXTIM_ENTRY_LVAL        ENTRY_LVAL;             /**< \brief 0, CPUx Exception Entry Timer Load Value*/
       Ifx_CPU_TPS_EXTIM_ENTRY_CVAL        ENTRY_CVAL;             /**< \brief 4, CPUx Exception Entry Timer Current Value*/
       Ifx_CPU_TPS_EXTIM_EXIT_LVAL         EXIT_LVAL;              /**< \brief 8, CPUx Exception Exit  Timer Load Value*/
       Ifx_CPU_TPS_EXTIM_EXIT_CVAL         EXIT_CVAL;              /**< \brief C, CPUx Exception Exit Timer Current Value*/
       Ifx_CPU_TPS_EXTIM_CLASS_EN          CLASS_EN;               /**< \brief 10, CPUx Exception Timer Class Enable Register*/
       Ifx_CPU_TPS_EXTIM_STAT              STAT;                   /**< \brief 14, CPUx Exception Timer Status Register*/
       Ifx_CPU_TPS_EXTIM_FCX               FCX;                    /**< \brief 18, CPUx Exception Timer FCX Register*/
} Ifx_CPU_TPS_EXTIM;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Cpu_TR_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief TR object */
typedef volatile struct _Ifx_CPU_TR
{
       Ifx_CPU_TR_EVT                      EVT;                    /**< \brief 0, CPUx Trigger Event ${i}*/
       Ifx_CPU_TR_ADR                      ADR;                    /**< \brief 4, CPUx Trigger Address ${i}*/
} Ifx_CPU_TR;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/** \addtogroup IfxSfr_Cpu_Registers_struct
 * \{  */
/******************************************************************************/
/** \name Object L0
 * \{  */

/** \brief CPU object */
typedef volatile struct _Ifx_CPU
{
       Ifx_UReg_8Bit                       reserved_0[4352];       /**< \brief 0, \internal Reserved */
       Ifx_CPU_FLASHCON0                   FLASHCON0;              /**< \brief 1100, CPUx Flash Configuration Register 0*/
       Ifx_CPU_FLASHCON1                   FLASHCON1;              /**< \brief 1104, CPUx Flash Configuration Register 1*/
       Ifx_CPU_FLASHCON2                   FLASHCON2;              /**< \brief 1108, CPUx Flash Configuration Register 2*/
       Ifx_CPU_FLASHCON3                   FLASHCON3;              /**< \brief 110C, CPUx Flash Configuration Register 3*/
       Ifx_CPU_FLASHCON4                   FLASHCON4;              /**< \brief 1110, CPUx Flash Configuration Register 4*/
       Ifx_UReg_8Bit                       reserved_1114[48876];    /**< \brief 1114, \internal Reserved */
       Ifx_CPU_KRST0                       KRST0;                  /**< \brief D000, CPUx  Reset Register 0*/
       Ifx_CPU_KRST1                       KRST1;                  /**< \brief D004, CPUx  Reset Register 1*/
       Ifx_CPU_KRSTCLR                     KRSTCLR;                /**< \brief D008, CPUx Reset Clear Register*/
       Ifx_UReg_8Bit                       reserved_D00C[4084];    /**< \brief D00C, \internal Reserved */
       Ifx_CPU_RGN                         RGN[8];                 /**< \brief E000, CPUx Safety Protection SPR Region Write Access Enable Register B${i}*/
       Ifx_UReg_8Bit                       reserved_E080[8];       /**< \brief E080, \internal Reserved */
       Ifx_CPU_SPR_SPROT_RGNACCENA_R       SPR_SPROT_RGNACCENA_R0;    /**< \brief E088, */
       Ifx_CPU_SPR_SPROT_RGNACCENB_R       SPR_SPROT_RGNACCENB_R0;    /**< \brief E08C, */
       Ifx_UReg_8Bit                       reserved_E090[8];       /**< \brief E090, \internal Reserved */
       Ifx_CPU_SPR_SPROT_RGNACCENA_R       SPR_SPROT_RGNACCENA_R1;    /**< \brief E098, */
       Ifx_CPU_SPR_SPROT_RGNACCENB_R       SPR_SPROT_RGNACCENB_R1;    /**< \brief E09C, */
       Ifx_UReg_8Bit                       reserved_E0A0[8];       /**< \brief E0A0, \internal Reserved */
       Ifx_CPU_SPR_SPROT_RGNACCENA_R       SPR_SPROT_RGNACCENA_R2;    /**< \brief E0A8, */
       Ifx_CPU_SPR_SPROT_RGNACCENB_R       SPR_SPROT_RGNACCENB_R2;    /**< \brief E0AC, */
       Ifx_UReg_8Bit                       reserved_E0B0[8];       /**< \brief E0B0, \internal Reserved */
       Ifx_CPU_SPR_SPROT_RGNACCENA_R       SPR_SPROT_RGNACCENA_R3;    /**< \brief E0B8, */
       Ifx_CPU_SPR_SPROT_RGNACCENB_R       SPR_SPROT_RGNACCENB_R3;    /**< \brief E0BC, */
       Ifx_UReg_8Bit                       reserved_E0C0[8];       /**< \brief E0C0, \internal Reserved */
       Ifx_CPU_SPR_SPROT_RGNACCENA_R       SPR_SPROT_RGNACCENA_R4;    /**< \brief E0C8, */
       Ifx_CPU_SPR_SPROT_RGNACCENB_R       SPR_SPROT_RGNACCENB_R4;    /**< \brief E0CC, */
       Ifx_UReg_8Bit                       reserved_E0D0[8];       /**< \brief E0D0, \internal Reserved */
       Ifx_CPU_SPR_SPROT_RGNACCENA_R       SPR_SPROT_RGNACCENA_R5;    /**< \brief E0D8, */
       Ifx_CPU_SPR_SPROT_RGNACCENB_R       SPR_SPROT_RGNACCENB_R5;    /**< \brief E0DC, */
       Ifx_UReg_8Bit                       reserved_E0E0[8];       /**< \brief E0E0, \internal Reserved */
       Ifx_CPU_SPR_SPROT_RGNACCENA_R       SPR_SPROT_RGNACCENA_R6;    /**< \brief E0E8, */
       Ifx_CPU_SPR_SPROT_RGNACCENB_R       SPR_SPROT_RGNACCENB_R6;    /**< \brief E0EC, */
       Ifx_UReg_8Bit                       reserved_E0F0[8];       /**< \brief E0F0, \internal Reserved */
       Ifx_CPU_SPR_SPROT_RGNACCENA_R       SPR_SPROT_RGNACCENA_R7;    /**< \brief E0F8, */
       Ifx_CPU_SPR_SPROT_RGNACCENB_R       SPR_SPROT_RGNACCENB_R7;    /**< \brief E0FC, */
       Ifx_CPU_SFR_SPROT_ACCENA_W          SFR_SPROT_ACCENA_W;     /**< \brief E100, CPUx Safety Protection Register Access Enable Register A*/
       Ifx_CPU_SFR_SPROT_ACCENB_W          SFR_SPROT_ACCENB_W;     /**< \brief E104, CPUx Safety Protection Region Access Enable Register B*/
       Ifx_UReg_8Bit                       reserved_E108[8];       /**< \brief E108, \internal Reserved */
       Ifx_CPU_LPB_SPROT_ACCENA_R          LPB_SPROT_ACCENA_R;     /**< \brief E110, CPUx Safety Protection Region LPB Read Access Enable Register A*/
       Ifx_CPU_LPB_SPROT_ACCENB_R          LPB_SPROT_ACCENB_R;     /**< \brief E114, CPUx Safety Protection Region LPB Read Access Enable Register B*/
       Ifx_UReg_8Bit                       reserved_E118[232];     /**< \brief E118, \internal Reserved */
       Ifx_CPU_DLMU_SPROT_RGNLA            DLMU_SPROT_RGNLA0;      /**< \brief E200, CPUx Safety Protection Region DLMU Write Access Enable Register B${i}*/
       Ifx_CPU_DLMU_SPROT_RGNUA            DLMU_SPROT_RGNUA0;      /**< \brief E204, CPUx Safety Protection Region DLMU Write Access Enable Register B${i}*/
       Ifx_CPU_DLMU_SPROT_RGNACCENA_W      DLMU_SPROT_RGNACCENA_W0;    /**< \brief E208, CPUx Safety Protection Region DLMU Write Access Enable Register B${i}*/
       Ifx_CPU_DLMU_SPROT_RGNACCENB_W      DLMU_SPROT_RGNACCENB_W0;    /**< \brief E20C, CPUx Safety Protection Region DLMU Write Access Enable Register B${i}*/
       Ifx_CPU_DLMU_SPROT_RGNLA            DLMU_SPROT_RGNLA1;      /**< \brief E210, CPUx Safety Protection Region DLMU Write Access Enable Register B${i}*/
       Ifx_CPU_DLMU_SPROT_RGNUA            DLMU_SPROT_RGNUA1;      /**< \brief E214, CPUx Safety Protection Region DLMU Write Access Enable Register B${i}*/
       Ifx_CPU_DLMU_SPROT_RGNACCENA_W      DLMU_SPROT_RGNACCENA_W1;    /**< \brief E218, CPUx Safety Protection Region DLMU Write Access Enable Register B${i}*/
       Ifx_CPU_DLMU_SPROT_RGNACCENB_W      DLMU_SPROT_RGNACCENB_W1;    /**< \brief E21C, CPUx Safety Protection Region DLMU Write Access Enable Register B${i}*/
       Ifx_CPU_DLMU_SPROT_RGNLA            DLMU_SPROT_RGNLA2;      /**< \brief E220, CPUx Safety Protection Region DLMU Write Access Enable Register B${i}*/
       Ifx_CPU_DLMU_SPROT_RGNUA            DLMU_SPROT_RGNUA2;      /**< \brief E224, CPUx Safety Protection Region DLMU Write Access Enable Register B${i}*/
       Ifx_CPU_DLMU_SPROT_RGNACCENA_W      DLMU_SPROT_RGNACCENA_W2;    /**< \brief E228, CPUx Safety Protection Region DLMU Write Access Enable Register B${i}*/
       Ifx_CPU_DLMU_SPROT_RGNACCENB_W      DLMU_SPROT_RGNACCENB_W2;    /**< \brief E22C, CPUx Safety Protection Region DLMU Write Access Enable Register B${i}*/
       Ifx_CPU_DLMU_SPROT_RGNLA            DLMU_SPROT_RGNLA3;      /**< \brief E230, CPUx Safety Protection Region DLMU Write Access Enable Register B${i}*/
       Ifx_CPU_DLMU_SPROT_RGNUA            DLMU_SPROT_RGNUA3;      /**< \brief E234, CPUx Safety Protection Region DLMU Write Access Enable Register B${i}*/
       Ifx_CPU_DLMU_SPROT_RGNACCENA_W      DLMU_SPROT_RGNACCENA_W3;    /**< \brief E238, CPUx Safety Protection Region DLMU Write Access Enable Register B${i}*/
       Ifx_CPU_DLMU_SPROT_RGNACCENB_W      DLMU_SPROT_RGNACCENB_W3;    /**< \brief E23C, CPUx Safety Protection Region DLMU Write Access Enable Register B${i}*/
       Ifx_CPU_DLMU_SPROT_RGNLA            DLMU_SPROT_RGNLA4;      /**< \brief E240, CPUx Safety Protection Region DLMU Write Access Enable Register B${i}*/
       Ifx_CPU_DLMU_SPROT_RGNUA            DLMU_SPROT_RGNUA4;      /**< \brief E244, CPUx Safety Protection Region DLMU Write Access Enable Register B${i}*/
       Ifx_CPU_DLMU_SPROT_RGNACCENA_W      DLMU_SPROT_RGNACCENA_W4;    /**< \brief E248, CPUx Safety Protection Region DLMU Write Access Enable Register B${i}*/
       Ifx_CPU_DLMU_SPROT_RGNACCENB_W      DLMU_SPROT_RGNACCENB_W4;    /**< \brief E24C, CPUx Safety Protection Region DLMU Write Access Enable Register B${i}*/
       Ifx_CPU_DLMU_SPROT_RGNLA            DLMU_SPROT_RGNLA5;      /**< \brief E250, CPUx Safety Protection Region DLMU Write Access Enable Register B${i}*/
       Ifx_CPU_DLMU_SPROT_RGNUA            DLMU_SPROT_RGNUA5;      /**< \brief E254, CPUx Safety Protection Region DLMU Write Access Enable Register B${i}*/
       Ifx_CPU_DLMU_SPROT_RGNACCENA_W      DLMU_SPROT_RGNACCENA_W5;    /**< \brief E258, CPUx Safety Protection Region DLMU Write Access Enable Register B${i}*/
       Ifx_CPU_DLMU_SPROT_RGNACCENB_W      DLMU_SPROT_RGNACCENB_W5;    /**< \brief E25C, CPUx Safety Protection Region DLMU Write Access Enable Register B${i}*/
       Ifx_CPU_DLMU_SPROT_RGNLA            DLMU_SPROT_RGNLA6;      /**< \brief E260, CPUx Safety Protection Region DLMU Write Access Enable Register B${i}*/
       Ifx_CPU_DLMU_SPROT_RGNUA            DLMU_SPROT_RGNUA6;      /**< \brief E264, CPUx Safety Protection Region DLMU Write Access Enable Register B${i}*/
       Ifx_CPU_DLMU_SPROT_RGNACCENA_W      DLMU_SPROT_RGNACCENA_W6;    /**< \brief E268, CPUx Safety Protection Region DLMU Write Access Enable Register B${i}*/
       Ifx_CPU_DLMU_SPROT_RGNACCENB_W      DLMU_SPROT_RGNACCENB_W6;    /**< \brief E26C, CPUx Safety Protection Region DLMU Write Access Enable Register B${i}*/
       Ifx_CPU_DLMU_SPROT_RGNLA            DLMU_SPROT_RGNLA7;      /**< \brief E270, CPUx Safety Protection Region DLMU Write Access Enable Register B${i}*/
       Ifx_CPU_DLMU_SPROT_RGNUA            DLMU_SPROT_RGNUA7;      /**< \brief E274, CPUx Safety Protection Region DLMU Write Access Enable Register B${i}*/
       Ifx_CPU_DLMU_SPROT_RGNACCENA_W      DLMU_SPROT_RGNACCENA_W7;    /**< \brief E278, CPUx Safety Protection Region DLMU Write Access Enable Register B${i}*/
       Ifx_CPU_DLMU_SPROT_RGNACCENB_W      DLMU_SPROT_RGNACCENB_W7;    /**< \brief E27C, CPUx Safety Protection Region DLMU Write Access Enable Register B${i}*/
       Ifx_UReg_8Bit                       reserved_E280[8];       /**< \brief E280, \internal Reserved */
       Ifx_CPU_DLMU_SPROT_RGNACCENA_R      DLMU_SPROT_RGNACCENA_R0;    /**< \brief E288, */
       Ifx_CPU_DLMU_SPROT_RGNACCENB_R      DLMU_SPROT_RGNACCENB_R0;    /**< \brief E28C, */
       Ifx_UReg_8Bit                       reserved_E290[8];       /**< \brief E290, \internal Reserved */
       Ifx_CPU_DLMU_SPROT_RGNACCENA_R      DLMU_SPROT_RGNACCENA_R1;    /**< \brief E298, */
       Ifx_CPU_DLMU_SPROT_RGNACCENB_R      DLMU_SPROT_RGNACCENB_R1;    /**< \brief E29C, */
       Ifx_UReg_8Bit                       reserved_E2A0[8];       /**< \brief E2A0, \internal Reserved */
       Ifx_CPU_DLMU_SPROT_RGNACCENA_R      DLMU_SPROT_RGNACCENA_R2;    /**< \brief E2A8, */
       Ifx_CPU_DLMU_SPROT_RGNACCENB_R      DLMU_SPROT_RGNACCENB_R2;    /**< \brief E2AC, */
       Ifx_UReg_8Bit                       reserved_E2B0[8];       /**< \brief E2B0, \internal Reserved */
       Ifx_CPU_DLMU_SPROT_RGNACCENA_R      DLMU_SPROT_RGNACCENA_R3;    /**< \brief E2B8, */
       Ifx_CPU_DLMU_SPROT_RGNACCENB_R      DLMU_SPROT_RGNACCENB_R3;    /**< \brief E2BC, */
       Ifx_UReg_8Bit                       reserved_E2C0[8];       /**< \brief E2C0, \internal Reserved */
       Ifx_CPU_DLMU_SPROT_RGNACCENA_R      DLMU_SPROT_RGNACCENA_R4;    /**< \brief E2C8, */
       Ifx_CPU_DLMU_SPROT_RGNACCENB_R      DLMU_SPROT_RGNACCENB_R4;    /**< \brief E2CC, */
       Ifx_UReg_8Bit                       reserved_E2D0[8];       /**< \brief E2D0, \internal Reserved */
       Ifx_CPU_DLMU_SPROT_RGNACCENA_R      DLMU_SPROT_RGNACCENA_R5;    /**< \brief E2D8, */
       Ifx_CPU_DLMU_SPROT_RGNACCENB_R      DLMU_SPROT_RGNACCENB_R5;    /**< \brief E2DC, */
       Ifx_UReg_8Bit                       reserved_E2E0[8];       /**< \brief E2E0, \internal Reserved */
       Ifx_CPU_DLMU_SPROT_RGNACCENA_R      DLMU_SPROT_RGNACCENA_R6;    /**< \brief E2E8, */
       Ifx_CPU_DLMU_SPROT_RGNACCENB_R      DLMU_SPROT_RGNACCENB_R6;    /**< \brief E2EC, */
       Ifx_UReg_8Bit                       reserved_E2F0[8];       /**< \brief E2F0, \internal Reserved */
       Ifx_CPU_DLMU_SPROT_RGNACCENA_R      DLMU_SPROT_RGNACCENA_R7;    /**< \brief E2F8, */
       Ifx_CPU_DLMU_SPROT_RGNACCENB_R      DLMU_SPROT_RGNACCENB_R7;    /**< \brief E2FC, */
       Ifx_UReg_8Bit                       reserved_E300[6144];    /**< \brief E300, \internal Reserved */
       Ifx_CPU_OSEL                        OSEL;                   /**< \brief FB00, CPUx  Overlay Range Select Register*/
       Ifx_UReg_8Bit                       reserved_FB04[12];      /**< \brief FB04, \internal Reserved */
       Ifx_CPU_BLK                         BLK[32];                /**< \brief FB10, CPUx Overlay Mask Register ${i}*/
       Ifx_UReg_8Bit                       reserved_FC90[5024];    /**< \brief FC90, \internal Reserved */
       Ifx_CPU_SEGEN                       SEGEN;                  /**< \brief 11030, CPUx SRI Error Generation Register*/
       Ifx_UReg_8Bit                       reserved_11034[28624];    /**< \brief 11034, \internal Reserved */
       Ifx_CPU_TASK_ASI                    TASK_ASI;               /**< \brief 18004, CPUx Task Address Space Identifier Register*/
       Ifx_UReg_8Bit                       reserved_18008[248];    /**< \brief 18008, \internal Reserved */
       Ifx_CPU_PMA0                        PMA0;                   /**< \brief 18100, CPUx Data Access CacheabilityRegister*/
       Ifx_CPU_PMA1                        PMA1;                   /**< \brief 18104, CPUx Code Access CacheabilityRegister*/
       Ifx_CPU_PMA2                        PMA2;                   /**< \brief 18108, CPUx  Peripheral Space Identifier register*/
       Ifx_UReg_8Bit                       reserved_1810C[3828];    /**< \brief 1810C, \internal Reserved */
       Ifx_CPU_DCON2                       DCON2;                  /**< \brief 19000, CPUx Data Control Register 2*/
       Ifx_UReg_8Bit                       reserved_19004[8];      /**< \brief 19004, \internal Reserved */
       Ifx_CPU_SMACON                      SMACON;                 /**< \brief 1900C, CPUx SIST Mode Access Control Register*/
       Ifx_CPU_DSTR                        DSTR;                   /**< \brief 19010, CPUx Data Synchronous Trap Register*/
       Ifx_UReg_8Bit                       reserved_19014[4];      /**< \brief 19014, \internal Reserved */
       Ifx_CPU_DATR                        DATR;                   /**< \brief 19018, CPUx Data Asynchronous Trap Register*/
       Ifx_CPU_DEADD                       DEADD;                  /**< \brief 1901C, CPUx Data Error Address Register*/
       Ifx_CPU_DIEAR                       DIEAR;                  /**< \brief 19020, CPUx Data Integrity Error Address Register*/
       Ifx_CPU_DIETR                       DIETR;                  /**< \brief 19024, CPUx Data Integrity Error Trap Register*/
       Ifx_UReg_8Bit                       reserved_19028[24];     /**< \brief 19028, \internal Reserved */
       Ifx_CPU_DCON0                       DCON0;                  /**< \brief 19040, CPUx Data Memory Control Register*/
       Ifx_UReg_8Bit                       reserved_19044[444];    /**< \brief 19044, \internal Reserved */
       Ifx_CPU_PSTR                        PSTR;                   /**< \brief 19200, CPUx Program Synchronous Trap Register*/
       Ifx_CPU_PCON1                       PCON1;                  /**< \brief 19204, CPUx Program Control 1*/
       Ifx_CPU_PCON2                       PCON2;                  /**< \brief 19208, CPUx Program Control 2*/
       Ifx_CPU_PCON0                       PCON0;                  /**< \brief 1920C, CPUx Program Control 0*/
       Ifx_CPU_PIEAR                       PIEAR;                  /**< \brief 19210, CPUx Program Integrity Error Address Register*/
       Ifx_CPU_PIETR                       PIETR;                  /**< \brief 19214, CPUx Program Integrity Error Trap Register*/
       Ifx_UReg_8Bit                       reserved_19218[488];    /**< \brief 19218, \internal Reserved */
       Ifx_CPU_COMPAT                      COMPAT;                 /**< \brief 19400, CPUx Compatibility Control Register*/
       Ifx_UReg_8Bit                       reserved_19404[3068];    /**< \brief 19404, \internal Reserved */
       Ifx_CPU_FPU_TRAP                    FPU_TRAP;               /**< \brief 1A000, CPUx Trapping Instruction Operand Register*/
       Ifx_UReg_8Bit                       reserved_1A01C[8164];    /**< \brief 1A01C, \internal Reserved */
       Ifx_CPU_DPR                         DPR[18];                /**< \brief 1C000, CPUx Data Protection Range ${y}, Upper Bound Register*/
       Ifx_UReg_8Bit                       reserved_1C090[3952];    /**< \brief 1C090, \internal Reserved */
       Ifx_CPU_CPR                         CPR[10];                /**< \brief 1D000, CPUx Code Protection Range ${y} Upper Bound Register*/
       Ifx_UReg_8Bit                       reserved_1D050[4016];    /**< \brief 1D050, \internal Reserved */
       Ifx_CPU_CPXE                        CPXE_0;                 /**< \brief 1E000, CPUx Code Protection Execute Enable Register Set ${y}*/
       Ifx_CPU_CPXE                        CPXE_1;                 /**< \brief 1E004, CPUx Code Protection Execute Enable Register Set ${y}*/
       Ifx_CPU_CPXE                        CPXE_2;                 /**< \brief 1E008, CPUx Code Protection Execute Enable Register Set ${y}*/
       Ifx_CPU_CPXE                        CPXE_3;                 /**< \brief 1E00C, CPUx Code Protection Execute Enable Register Set ${y}*/
       Ifx_CPU_DPRE                        DPRE_0;                 /**< \brief 1E010, CPUx Data Protection Read Enable Register Set ${y}*/
       Ifx_CPU_DPRE                        DPRE_1;                 /**< \brief 1E014, CPUx Data Protection Read Enable Register Set ${y}*/
       Ifx_CPU_DPRE                        DPRE_2;                 /**< \brief 1E018, CPUx Data Protection Read Enable Register Set ${y}*/
       Ifx_CPU_DPRE                        DPRE_3;                 /**< \brief 1E01C, CPUx Data Protection Read Enable Register Set ${y}*/
       Ifx_CPU_DPWE                        DPWE_0;                 /**< \brief 1E020, CPUx Data Protection Write Enable Register Set ${y}*/
       Ifx_CPU_DPWE                        DPWE_1;                 /**< \brief 1E024, CPUx Data Protection Write Enable Register Set ${y}*/
       Ifx_CPU_DPWE                        DPWE_2;                 /**< \brief 1E028, CPUx Data Protection Write Enable Register Set ${y}*/
       Ifx_CPU_DPWE                        DPWE_3;                 /**< \brief 1E02C, CPUx Data Protection Write Enable Register Set ${y}*/
       Ifx_UReg_8Bit                       reserved_1E030[16];     /**< \brief 1E030, \internal Reserved */
       Ifx_CPU_CPXE                        CPXE_4;                 /**< \brief 1E040, CPUx Code Protection Execute Enable Register Set ${y}*/
       Ifx_CPU_CPXE                        CPXE_5;                 /**< \brief 1E044, CPUx Code Protection Execute Enable Register Set ${y}*/
       Ifx_UReg_8Bit                       reserved_1E048[8];      /**< \brief 1E048, \internal Reserved */
       Ifx_CPU_DPRE                        DPRE_4;                 /**< \brief 1E050, CPUx Data Protection Read Enable Register Set ${y}*/
       Ifx_CPU_DPRE                        DPRE_5;                 /**< \brief 1E054, CPUx Data Protection Read Enable Register Set ${y}*/
       Ifx_UReg_8Bit                       reserved_1E058[8];      /**< \brief 1E058, \internal Reserved */
       Ifx_CPU_DPWE                        DPWE_4;                 /**< \brief 1E060, CPUx Data Protection Write Enable Register Set ${y}*/
       Ifx_CPU_DPWE                        DPWE_5;                 /**< \brief 1E064, CPUx Data Protection Write Enable Register Set ${y}*/
       Ifx_UReg_8Bit                       reserved_1E068[920];    /**< \brief 1E068, \internal Reserved */
       Ifx_CPU_TPS                         TPS;                    /**< \brief 1E400, */
       Ifx_UReg_8Bit                       reserved_1E410[48];     /**< \brief 1E410, \internal Reserved */
       Ifx_CPU_TPS_EXTIM                   TPS_EXTIM;              /**< \brief 1E440, CPUx Exception Timer FCX Register*/
       Ifx_UReg_8Bit                       reserved_1E45C[2980];    /**< \brief 1E45C, \internal Reserved */
       Ifx_CPU_TR                          TR[8];                  /**< \brief 1F000, CPUx Trigger Address ${i}*/
       Ifx_UReg_8Bit                       reserved_1F040[3008];    /**< \brief 1F040, \internal Reserved */
       Ifx_CPU_CCTRL                       CCTRL;                  /**< \brief 1FC00, CPUx Counter Control*/
       Ifx_CPU_CCNT                        CCNT;                   /**< \brief 1FC04, CPUx CPU Clock Cycle Count*/
       Ifx_CPU_ICNT                        ICNT;                   /**< \brief 1FC08, CPUx Instruction Count*/
       Ifx_CPU_M1CNT                       M1CNT;                  /**< \brief 1FC0C, CPUx Multi-Count Register 1*/
       Ifx_CPU_M2CNT                       M2CNT;                  /**< \brief 1FC10, CPUx Multi-Count Register 2*/
       Ifx_CPU_M3CNT                       M3CNT;                  /**< \brief 1FC14, CPUx Multi-Count Register 3*/
       Ifx_UReg_8Bit                       reserved_1FC18[232];    /**< \brief 1FC18, \internal Reserved */
       Ifx_CPU_DBGSR                       DBGSR;                  /**< \brief 1FD00, CPUx Debug Status Register*/
       Ifx_UReg_8Bit                       reserved_1FD04[4];      /**< \brief 1FD04, \internal Reserved */
       Ifx_CPU_EXEVT                       EXEVT;                  /**< \brief 1FD08, CPUx External Event Register*/
       Ifx_CPU_CREVT                       CREVT;                  /**< \brief 1FD0C, CPUx Core Register Access Event*/
       Ifx_CPU_SWEVT                       SWEVT;                  /**< \brief 1FD10, CPUx Software Debug Event*/
       Ifx_UReg_8Bit                       reserved_1FD14[28];     /**< \brief 1FD14, \internal Reserved */
       Ifx_CPU_TRIG_ACC                    TRIG_ACC;               /**< \brief 1FD30, CPUx TriggerAddressx*/
       Ifx_UReg_8Bit                       reserved_1FD34[12];     /**< \brief 1FD34, \internal Reserved */
       Ifx_CPU_DMS                         DMS;                    /**< \brief 1FD40, CPUx Debug Monitor Start Address*/
       Ifx_CPU_DCX                         DCX;                    /**< \brief 1FD44, CPUx Debug Context Save Area Pointer*/
       Ifx_CPU_DBGTCR                      DBGTCR;                 /**< \brief 1FD48, CPUx Debug Trap Control Register*/
       Ifx_UReg_8Bit                       reserved_1FD4C[180];    /**< \brief 1FD4C, \internal Reserved */
       Ifx_CPU_PCXI                        PCXI;                   /**< \brief 1FE00, CPUx Previous Context Information Register*/
       Ifx_CPU_PSW                         PSW;                    /**< \brief 1FE04, CPUx Program Status Word*/
       Ifx_CPU_PC                          PC;                     /**< \brief 1FE08, CPUx Program Counter*/
       Ifx_UReg_8Bit                       reserved_1FE0C[8];      /**< \brief 1FE0C, \internal Reserved */
       Ifx_CPU_SYSCON                      SYSCON;                 /**< \brief 1FE14, CPUx System Configuration Register*/
       Ifx_CPU_CPU_ID                      CPU_ID;                 /**< \brief 1FE18, CPUx Identification Register TC1.6.2P*/
       Ifx_CPU_CORE_ID                     CORE_ID;                /**< \brief 1FE1C, CPUx Core Identification Register*/
       Ifx_CPU_BIV                         BIV;                    /**< \brief 1FE20, CPUx Base Interrupt Vector Table Pointer*/
       Ifx_CPU_BTV                         BTV;                    /**< \brief 1FE24, CPUx Base Trap Vector Table Pointer*/
       Ifx_CPU_ISP                         ISP;                    /**< \brief 1FE28, CPUx Interrupt Stack Pointer*/
       Ifx_CPU_ICR                         ICR;                    /**< \brief 1FE2C, CPUx Interrupt Control Register*/
       Ifx_UReg_8Bit                       reserved_1FE30[8];      /**< \brief 1FE30, \internal Reserved */
       Ifx_CPU_FCX                         FCX;                    /**< \brief 1FE38, CPUx Free CSA List Head Pointer*/
       Ifx_CPU_LCX                         LCX;                    /**< \brief 1FE3C, CPUx Free CSA List Limit Pointer*/
       Ifx_UReg_8Bit                       reserved_1FE40[16];     /**< \brief 1FE40, \internal Reserved */
       Ifx_CPU_CUS_ID                      CUS_ID;                 /**< \brief 1FE50, CPUx Customer ID register*/
       Ifx_UReg_8Bit                       reserved_1FE54[172];    /**< \brief 1FE54, \internal Reserved */
       Ifx_CPU_D                           D[16];                  /**< \brief 1FF00, CPUx Data General Purpose Register ${y}*/
       Ifx_UReg_8Bit                       reserved_1FF40[64];     /**< \brief 1FF40, \internal Reserved */
       Ifx_CPU_A                           A[16];                  /**< \brief 1FF80, CPUx Address General Purpose Register ${y}*/
       Ifx_UReg_8Bit                       reserved_1FFC0[64];     /**< \brief 1FFC0, \internal Reserved */
} Ifx_CPU;

/** \}  */
/******************************************************************************/
/** \}  */


/******************************************************************************/

/******************************************************************************/


#line 66 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\Infra\\Sfr\\TC38A\\_Reg\\IfxCpu_reg.h"
/******************************************************************************/

/******************************************************************************/

/******************************************************************************/

/** \addtogroup IfxSfr_Cpu_Registers_Cfg_BaseAddress
 * \{  */

/** \brief CPU object */




/** \}  */

/** \brief 1030, CPUx SRI Error Generation Register */


/** \brief 8004, CPUx Task Address Space Identifier Register */


/** \brief 8100, CPUx Data Access CacheabilityRegister */


/** \brief 8104, CPUx Code Access CacheabilityRegister */


/** \brief 8108, CPUx  Peripheral Space Identifier register */


/** \brief 9000, CPUx Data Control Register 2 */


/** \brief 900C, CPUx SIST Mode Access Control Register */


/** \brief 9010, CPUx Data Synchronous Trap Register */


/** \brief 9018, CPUx Data Asynchronous Trap Register */


/** \brief 901C, CPUx Data Error Address Register */


/** \brief 9020, CPUx Data Integrity Error Address Register */


/** \brief 9024, CPUx Data Integrity Error Trap Register */


/** \brief 9040, CPUx Data Memory Control Register */


/** \brief 9200, CPUx Program Synchronous Trap Register */


/** \brief 9204, CPUx Program Control 1 */


/** \brief 9208, CPUx Program Control 2 */


/** \brief 920C, CPUx Program Control 0 */


/** \brief 9210, CPUx Program Integrity Error Address Register */


/** \brief 9214, CPUx Program Integrity Error Trap Register */


/** \brief 9400, CPUx Compatibility Control Register */


/** \brief A000, CPUx Trap Control Register */


/** \brief A004, CPUx Trapping Instruction Program Counter Register */


/** \brief A008, CPUx Trapping Instruction Opcode Register */


/** \brief A010, CPUx Trapping Instruction Operand Register */


/** \brief A014, CPUx Trapping Instruction Operand Register */


/** \brief A018, CPUx Trapping Instruction Operand Register */


/** \brief C000, CPUx Data Protection Range 0, Lower Bound Register */


/** \brief C004, CPUx Data Protection Range 0, Upper Bound Register */


/** \brief C008, CPUx Data Protection Range 1, Lower Bound Register */


/** \brief C00C, CPUx Data Protection Range 1, Upper Bound Register */


/** \brief C010, CPUx Data Protection Range 2, Lower Bound Register */


/** \brief C014, CPUx Data Protection Range 2, Upper Bound Register */


/** \brief C018, CPUx Data Protection Range 3, Lower Bound Register */


/** \brief C01C, CPUx Data Protection Range 3, Upper Bound Register */


/** \brief C020, CPUx Data Protection Range 4, Lower Bound Register */


/** \brief C024, CPUx Data Protection Range 4, Upper Bound Register */


/** \brief C028, CPUx Data Protection Range 5, Lower Bound Register */


/** \brief C02C, CPUx Data Protection Range 5, Upper Bound Register */


/** \brief C030, CPUx Data Protection Range 6, Lower Bound Register */


/** \brief C034, CPUx Data Protection Range 6, Upper Bound Register */


/** \brief C038, CPUx Data Protection Range 7, Lower Bound Register */


/** \brief C03C, CPUx Data Protection Range 7, Upper Bound Register */


/** \brief C040, CPUx Data Protection Range 8, Lower Bound Register */


/** \brief C044, CPUx Data Protection Range 8, Upper Bound Register */


/** \brief C048, CPUx Data Protection Range 9, Lower Bound Register */


/** \brief C04C, CPUx Data Protection Range 9, Upper Bound Register */


/** \brief C050, CPUx Data Protection Range 10, Lower Bound Register */


/** \brief C054, CPUx Data Protection Range 10, Upper Bound Register */


/** \brief C058, CPUx Data Protection Range 11, Lower Bound Register */


/** \brief C05C, CPUx Data Protection Range 11, Upper Bound Register */


/** \brief C060, CPUx Data Protection Range 12, Lower Bound Register */


/** \brief C064, CPUx Data Protection Range 12, Upper Bound Register */


/** \brief C068, CPUx Data Protection Range 13, Lower Bound Register */


/** \brief C06C, CPUx Data Protection Range 13, Upper Bound Register */


/** \brief C070, CPUx Data Protection Range 14, Lower Bound Register */


/** \brief C074, CPUx Data Protection Range 14, Upper Bound Register */


/** \brief C078, CPUx Data Protection Range 15, Lower Bound Register */


/** \brief C07C, CPUx Data Protection Range 15, Upper Bound Register */


/** \brief C080, CPUx Data Protection Range 16, Lower Bound Register */


/** \brief C084, CPUx Data Protection Range 16, Upper Bound Register */


/** \brief C088, CPUx Data Protection Range 17, Lower Bound Register */


/** \brief C08C, CPUx Data Protection Range 17, Upper Bound Register */


/** \brief D000, CPUx Code Protection Range 0 Lower Bound Register */


/** \brief D004, CPUx Code Protection Range 0 Upper Bound Register */


/** \brief D008, CPUx Code Protection Range 1 Lower Bound Register */


/** \brief D00C, CPUx Code Protection Range 1 Upper Bound Register */


/** \brief D010, CPUx Code Protection Range 2 Lower Bound Register */


/** \brief D014, CPUx Code Protection Range 2 Upper Bound Register */


/** \brief D018, CPUx Code Protection Range 3 Lower Bound Register */


/** \brief D01C, CPUx Code Protection Range 3 Upper Bound Register */


/** \brief D020, CPUx Code Protection Range 4 Lower Bound Register */


/** \brief D024, CPUx Code Protection Range 4 Upper Bound Register */


/** \brief D028, CPUx Code Protection Range 5 Lower Bound Register */


/** \brief D02C, CPUx Code Protection Range 5 Upper Bound Register */


/** \brief D030, CPUx Code Protection Range 6 Lower Bound Register */


/** \brief D034, CPUx Code Protection Range 6 Upper Bound Register */


/** \brief D038, CPUx Code Protection Range 7 Lower Bound Register */


/** \brief D03C, CPUx Code Protection Range 7 Upper Bound Register */


/** \brief D040, CPUx Code Protection Range 8 Lower Bound Register */


/** \brief D044, CPUx Code Protection Range 8 Upper Bound Register */


/** \brief D048, CPUx Code Protection Range 9 Lower Bound Register */


/** \brief D04C, CPUx Code Protection Range 9 Upper Bound Register */


/** \brief E000, CPUx Code Protection Execute Enable Register Set 0 */


/** \brief E004, CPUx Code Protection Execute Enable Register Set 1 */


/** \brief E008, CPUx Code Protection Execute Enable Register Set 2 */


/** \brief E00C, CPUx Code Protection Execute Enable Register Set 3 */


/** \brief E010, CPUx Data Protection Read Enable Register Set 0 */


/** \brief E014, CPUx Data Protection Read Enable Register Set 1 */


/** \brief E018, CPUx Data Protection Read Enable Register Set 2 */


/** \brief E01C, CPUx Data Protection Read Enable Register Set 3 */


/** \brief E020, CPUx Data Protection Write Enable Register Set 0 */


/** \brief E024, CPUx Data Protection Write Enable Register Set 1 */


/** \brief E028, CPUx Data Protection Write Enable Register Set 2 */


/** \brief E02C, CPUx Data Protection Write Enable Register Set 3 */


/** \brief E040, CPUx Code Protection Execute Enable Register Set 4 */


/** \brief E044, CPUx Code Protection Execute Enable Register Set 5 */


/** \brief E050, CPUx Data Protection Read Enable Register Set 4 */


/** \brief E054, CPUx Data Protection Read Enable Register Set 5 */


/** \brief E060, CPUx Data Protection Write Enable Register Set 4 */


/** \brief E064, CPUx Data Protection Write Enable Register Set 5 */


/** \brief E400, CPUx Temporal Protection System Control Register */


/** \brief E404, CPUx Temporal Protection System Timer Register 0 */


/** \brief E408, CPUx Temporal Protection System Timer Register 1 */


/** \brief E40C, CPUx Temporal Protection System Timer Register 2 */


/** \brief E440, CPUx Exception Entry Timer Load Value */


/** \brief E444, CPUx Exception Entry Timer Current Value */


/** \brief E448, CPUx Exception Exit  Timer Load Value */


/** \brief E44C, CPUx Exception Exit Timer Current Value */


/** \brief E450, CPUx Exception Timer Class Enable Register */


/** \brief E454, CPUx Exception Timer Status Register */


/** \brief E458, CPUx Exception Timer FCX Register */


/** \brief F000, CPUx Trigger Event 0 */

/** Alias (User Manual Name) for CPU_TR0_EVT.
* To use register names with standard convension, please use CPU_TR0_EVT.
*/


/** \brief F004, CPUx Trigger Address 0 */

/** Alias (User Manual Name) for CPU_TR0_ADR.
* To use register names with standard convension, please use CPU_TR0_ADR.
*/


/** \brief F008, CPUx Trigger Event 1 */

/** Alias (User Manual Name) for CPU_TR1_EVT.
* To use register names with standard convension, please use CPU_TR1_EVT.
*/


/** \brief F00C, CPUx Trigger Address 1 */

/** Alias (User Manual Name) for CPU_TR1_ADR.
* To use register names with standard convension, please use CPU_TR1_ADR.
*/


/** \brief F010, CPUx Trigger Event 2 */

/** Alias (User Manual Name) for CPU_TR2_EVT.
* To use register names with standard convension, please use CPU_TR2_EVT.
*/


/** \brief F014, CPUx Trigger Address 2 */

/** Alias (User Manual Name) for CPU_TR2_ADR.
* To use register names with standard convension, please use CPU_TR2_ADR.
*/


/** \brief F018, CPUx Trigger Event 3 */

/** Alias (User Manual Name) for CPU_TR3_EVT.
* To use register names with standard convension, please use CPU_TR3_EVT.
*/


/** \brief F01C, CPUx Trigger Address 3 */

/** Alias (User Manual Name) for CPU_TR3_ADR.
* To use register names with standard convension, please use CPU_TR3_ADR.
*/


/** \brief F020, CPUx Trigger Event 4 */

/** Alias (User Manual Name) for CPU_TR4_EVT.
* To use register names with standard convension, please use CPU_TR4_EVT.
*/


/** \brief F024, CPUx Trigger Address 4 */

/** Alias (User Manual Name) for CPU_TR4_ADR.
* To use register names with standard convension, please use CPU_TR4_ADR.
*/


/** \brief F028, CPUx Trigger Event 5 */

/** Alias (User Manual Name) for CPU_TR5_EVT.
* To use register names with standard convension, please use CPU_TR5_EVT.
*/


/** \brief F02C, CPUx Trigger Address 5 */

/** Alias (User Manual Name) for CPU_TR5_ADR.
* To use register names with standard convension, please use CPU_TR5_ADR.
*/


/** \brief F030, CPUx Trigger Event 6 */

/** Alias (User Manual Name) for CPU_TR6_EVT.
* To use register names with standard convension, please use CPU_TR6_EVT.
*/


/** \brief F034, CPUx Trigger Address 6 */

/** Alias (User Manual Name) for CPU_TR6_ADR.
* To use register names with standard convension, please use CPU_TR6_ADR.
*/


/** \brief F038, CPUx Trigger Event 7 */

/** Alias (User Manual Name) for CPU_TR7_EVT.
* To use register names with standard convension, please use CPU_TR7_EVT.
*/


/** \brief F03C, CPUx Trigger Address 7 */

/** Alias (User Manual Name) for CPU_TR7_ADR.
* To use register names with standard convension, please use CPU_TR7_ADR.
*/


/** \brief FC00, CPUx Counter Control */


/** \brief FC04, CPUx CPU Clock Cycle Count */


/** \brief FC08, CPUx Instruction Count */


/** \brief FC0C, CPUx Multi-Count Register 1 */


/** \brief FC10, CPUx Multi-Count Register 2 */


/** \brief FC14, CPUx Multi-Count Register 3 */


/** \brief FD00, CPUx Debug Status Register */


/** \brief FD08, CPUx External Event Register */


/** \brief FD0C, CPUx Core Register Access Event */


/** \brief FD10, CPUx Software Debug Event */


/** \brief FD30, CPUx TriggerAddressx */


/** \brief FD40, CPUx Debug Monitor Start Address */


/** \brief FD44, CPUx Debug Context Save Area Pointer */


/** \brief FD48, CPUx Debug Trap Control Register */


/** \brief FE00, CPUx Previous Context Information Register */


/** \brief FE04, CPUx Program Status Word */


/** \brief FE08, CPUx Program Counter */


/** \brief FE14, CPUx System Configuration Register */


/** \brief FE18, CPUx Identification Register TC1.6.2P */


/** \brief FE1C, CPUx Core Identification Register */


/** \brief FE20, CPUx Base Interrupt Vector Table Pointer */


/** \brief FE24, CPUx Base Trap Vector Table Pointer */


/** \brief FE28, CPUx Interrupt Stack Pointer */


/** \brief FE2C, CPUx Interrupt Control Register */


/** \brief FE38, CPUx Free CSA List Head Pointer */


/** \brief FE3C, CPUx Free CSA List Limit Pointer */


/** \brief FE50, CPUx Customer ID register */


/** \brief FF00, CPUx Data General Purpose Register 0 */


/** \brief FF04, CPUx Data General Purpose Register 1 */


/** \brief FF08, CPUx Data General Purpose Register 2 */


/** \brief FF0C, CPUx Data General Purpose Register 3 */


/** \brief FF10, CPUx Data General Purpose Register 4 */


/** \brief FF14, CPUx Data General Purpose Register 5 */


/** \brief FF18, CPUx Data General Purpose Register 6 */


/** \brief FF1C, CPUx Data General Purpose Register 7 */


/** \brief FF20, CPUx Data General Purpose Register 8 */


/** \brief FF24, CPUx Data General Purpose Register 9 */


/** \brief FF28, CPUx Data General Purpose Register 10 */


/** \brief FF2C, CPUx Data General Purpose Register 11 */


/** \brief FF30, CPUx Data General Purpose Register 12 */


/** \brief FF34, CPUx Data General Purpose Register 13 */


/** \brief FF38, CPUx Data General Purpose Register 14 */


/** \brief FF3C, CPUx Data General Purpose Register 15 */


/** \brief FF80, CPUx Address General Purpose Register 0 */


/** \brief FF84, CPUx Address General Purpose Register 1 */


/** \brief FF88, CPUx Address General Purpose Register 2 */


/** \brief FF8C, CPUx Address General Purpose Register 3 */


/** \brief FF90, CPUx Address General Purpose Register 4 */


/** \brief FF94, CPUx Address General Purpose Register 5 */


/** \brief FF98, CPUx Address General Purpose Register 6 */


/** \brief FF9C, CPUx Address General Purpose Register 7 */


/** \brief FFA0, CPUx Address General Purpose Register 8 */


/** \brief FFA4, CPUx Address General Purpose Register 9 */


/** \brief FFA8, CPUx Address General Purpose Register 10 */


/** \brief FFAC, CPUx Address General Purpose Register 11 */


/** \brief FFB0, CPUx Address General Purpose Register 12 */


/** \brief FFB4, CPUx Address General Purpose Register 13 */


/** \brief FFB8, CPUx Address General Purpose Register 14 */


/** \brief FFBC, CPUx Address General Purpose Register 15 */



/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Cpu_Registers_Cfg_Cpu0
 * \{  */
/** \brief 1100, CPUx Flash Configuration Register 0 */


/** \brief 1104, CPUx Flash Configuration Register 1 */


/** \brief 1108, CPUx Flash Configuration Register 2 */


/** \brief 110C, CPUx Flash Configuration Register 3 */


/** \brief 1110, CPUx Flash Configuration Register 4 */


/** \brief D000, CPUx  Reset Register 0 */


/** \brief D004, CPUx  Reset Register 1 */


/** \brief D008, CPUx Reset Clear Register */


/** \brief E000, CPUx Safety Protection SPR Region Lower Address Register 0 */

/** Alias (User Manual Name) for CPU0_RGN0_LA.
* To use register names with standard convension, please use CPU0_RGN0_LA.
*/


/** \brief E004, CPUx Safety Protection SPR Region Upper Address Register 0 */

/** Alias (User Manual Name) for CPU0_RGN0_UA.
* To use register names with standard convension, please use CPU0_RGN0_UA.
*/


/** \brief E008, CPUx Safety Protection SPR Region Write Access Enable Register A0 */

/** Alias (User Manual Name) for CPU0_RGN0_ACCENA.
* To use register names with standard convension, please use CPU0_RGN0_ACCENA.
*/


/** \brief E00C, CPUx Safety Protection SPR Region Write Access Enable Register B0 */

/** Alias (User Manual Name) for CPU0_RGN0_ACCENB.
* To use register names with standard convension, please use CPU0_RGN0_ACCENB.
*/


/** \brief E010, CPUx Safety Protection SPR Region Lower Address Register 1 */

/** Alias (User Manual Name) for CPU0_RGN1_LA.
* To use register names with standard convension, please use CPU0_RGN1_LA.
*/


/** \brief E014, CPUx Safety Protection SPR Region Upper Address Register 1 */

/** Alias (User Manual Name) for CPU0_RGN1_UA.
* To use register names with standard convension, please use CPU0_RGN1_UA.
*/


/** \brief E018, CPUx Safety Protection SPR Region Write Access Enable Register A1 */

/** Alias (User Manual Name) for CPU0_RGN1_ACCENA.
* To use register names with standard convension, please use CPU0_RGN1_ACCENA.
*/


/** \brief E01C, CPUx Safety Protection SPR Region Write Access Enable Register B1 */

/** Alias (User Manual Name) for CPU0_RGN1_ACCENB.
* To use register names with standard convension, please use CPU0_RGN1_ACCENB.
*/


/** \brief E020, CPUx Safety Protection SPR Region Lower Address Register 2 */

/** Alias (User Manual Name) for CPU0_RGN2_LA.
* To use register names with standard convension, please use CPU0_RGN2_LA.
*/


/** \brief E024, CPUx Safety Protection SPR Region Upper Address Register 2 */

/** Alias (User Manual Name) for CPU0_RGN2_UA.
* To use register names with standard convension, please use CPU0_RGN2_UA.
*/


/** \brief E028, CPUx Safety Protection SPR Region Write Access Enable Register A2 */

/** Alias (User Manual Name) for CPU0_RGN2_ACCENA.
* To use register names with standard convension, please use CPU0_RGN2_ACCENA.
*/


/** \brief E02C, CPUx Safety Protection SPR Region Write Access Enable Register B2 */

/** Alias (User Manual Name) for CPU0_RGN2_ACCENB.
* To use register names with standard convension, please use CPU0_RGN2_ACCENB.
*/


/** \brief E030, CPUx Safety Protection SPR Region Lower Address Register 3 */

/** Alias (User Manual Name) for CPU0_RGN3_LA.
* To use register names with standard convension, please use CPU0_RGN3_LA.
*/


/** \brief E034, CPUx Safety Protection SPR Region Upper Address Register 3 */

/** Alias (User Manual Name) for CPU0_RGN3_UA.
* To use register names with standard convension, please use CPU0_RGN3_UA.
*/


/** \brief E038, CPUx Safety Protection SPR Region Write Access Enable Register A3 */

/** Alias (User Manual Name) for CPU0_RGN3_ACCENA.
* To use register names with standard convension, please use CPU0_RGN3_ACCENA.
*/


/** \brief E03C, CPUx Safety Protection SPR Region Write Access Enable Register B3 */

/** Alias (User Manual Name) for CPU0_RGN3_ACCENB.
* To use register names with standard convension, please use CPU0_RGN3_ACCENB.
*/


/** \brief E040, CPUx Safety Protection SPR Region Lower Address Register 4 */

/** Alias (User Manual Name) for CPU0_RGN4_LA.
* To use register names with standard convension, please use CPU0_RGN4_LA.
*/


/** \brief E044, CPUx Safety Protection SPR Region Upper Address Register 4 */

/** Alias (User Manual Name) for CPU0_RGN4_UA.
* To use register names with standard convension, please use CPU0_RGN4_UA.
*/


/** \brief E048, CPUx Safety Protection SPR Region Write Access Enable Register A4 */

/** Alias (User Manual Name) for CPU0_RGN4_ACCENA.
* To use register names with standard convension, please use CPU0_RGN4_ACCENA.
*/


/** \brief E04C, CPUx Safety Protection SPR Region Write Access Enable Register B4 */

/** Alias (User Manual Name) for CPU0_RGN4_ACCENB.
* To use register names with standard convension, please use CPU0_RGN4_ACCENB.
*/


/** \brief E050, CPUx Safety Protection SPR Region Lower Address Register 5 */

/** Alias (User Manual Name) for CPU0_RGN5_LA.
* To use register names with standard convension, please use CPU0_RGN5_LA.
*/


/** \brief E054, CPUx Safety Protection SPR Region Upper Address Register 5 */

/** Alias (User Manual Name) for CPU0_RGN5_UA.
* To use register names with standard convension, please use CPU0_RGN5_UA.
*/


/** \brief E058, CPUx Safety Protection SPR Region Write Access Enable Register A5 */

/** Alias (User Manual Name) for CPU0_RGN5_ACCENA.
* To use register names with standard convension, please use CPU0_RGN5_ACCENA.
*/


/** \brief E05C, CPUx Safety Protection SPR Region Write Access Enable Register B5 */

/** Alias (User Manual Name) for CPU0_RGN5_ACCENB.
* To use register names with standard convension, please use CPU0_RGN5_ACCENB.
*/


/** \brief E060, CPUx Safety Protection SPR Region Lower Address Register 6 */

/** Alias (User Manual Name) for CPU0_RGN6_LA.
* To use register names with standard convension, please use CPU0_RGN6_LA.
*/


/** \brief E064, CPUx Safety Protection SPR Region Upper Address Register 6 */

/** Alias (User Manual Name) for CPU0_RGN6_UA.
* To use register names with standard convension, please use CPU0_RGN6_UA.
*/


/** \brief E068, CPUx Safety Protection SPR Region Write Access Enable Register A6 */

/** Alias (User Manual Name) for CPU0_RGN6_ACCENA.
* To use register names with standard convension, please use CPU0_RGN6_ACCENA.
*/


/** \brief E06C, CPUx Safety Protection SPR Region Write Access Enable Register B6 */

/** Alias (User Manual Name) for CPU0_RGN6_ACCENB.
* To use register names with standard convension, please use CPU0_RGN6_ACCENB.
*/


/** \brief E070, CPUx Safety Protection SPR Region Lower Address Register 7 */

/** Alias (User Manual Name) for CPU0_RGN7_LA.
* To use register names with standard convension, please use CPU0_RGN7_LA.
*/


/** \brief E074, CPUx Safety Protection SPR Region Upper Address Register 7 */

/** Alias (User Manual Name) for CPU0_RGN7_UA.
* To use register names with standard convension, please use CPU0_RGN7_UA.
*/


/** \brief E078, CPUx Safety Protection SPR Region Write Access Enable Register A7 */

/** Alias (User Manual Name) for CPU0_RGN7_ACCENA.
* To use register names with standard convension, please use CPU0_RGN7_ACCENA.
*/


/** \brief E07C, CPUx Safety Protection SPR Region Write Access Enable Register B7 */

/** Alias (User Manual Name) for CPU0_RGN7_ACCENB.
* To use register names with standard convension, please use CPU0_RGN7_ACCENB.
*/


/** \brief E088, CPUx Safety Protection SPR Region Read Access Enable Register A0 */

/** Alias (User Manual Name) for CPU0_SPR_SPROT_RGNACCENA_R0.
* To use register names with standard convension, please use CPU0_SPR_SPROT_RGNACCENA_R0.
*/


/** \brief E08C, CPUx Safety Protection SPR Region Read Access Enable Register B0 */

/** Alias (User Manual Name) for CPU0_SPR_SPROT_RGNACCENB_R0.
* To use register names with standard convension, please use CPU0_SPR_SPROT_RGNACCENB_R0.
*/


/** \brief E098, CPUx Safety Protection SPR Region Read Access Enable Register A1 */

/** Alias (User Manual Name) for CPU0_SPR_SPROT_RGNACCENA_R1.
* To use register names with standard convension, please use CPU0_SPR_SPROT_RGNACCENA_R1.
*/


/** \brief E09C, CPUx Safety Protection SPR Region Read Access Enable Register B1 */

/** Alias (User Manual Name) for CPU0_SPR_SPROT_RGNACCENB_R1.
* To use register names with standard convension, please use CPU0_SPR_SPROT_RGNACCENB_R1.
*/


/** \brief E0A8, CPUx Safety Protection SPR Region Read Access Enable Register A2 */

/** Alias (User Manual Name) for CPU0_SPR_SPROT_RGNACCENA_R2.
* To use register names with standard convension, please use CPU0_SPR_SPROT_RGNACCENA_R2.
*/


/** \brief E0AC, CPUx Safety Protection SPR Region Read Access Enable Register B2 */

/** Alias (User Manual Name) for CPU0_SPR_SPROT_RGNACCENB_R2.
* To use register names with standard convension, please use CPU0_SPR_SPROT_RGNACCENB_R2.
*/


/** \brief E0B8, CPUx Safety Protection SPR Region Read Access Enable Register A3 */

/** Alias (User Manual Name) for CPU0_SPR_SPROT_RGNACCENA_R3.
* To use register names with standard convension, please use CPU0_SPR_SPROT_RGNACCENA_R3.
*/


/** \brief E0BC, CPUx Safety Protection SPR Region Read Access Enable Register B3 */

/** Alias (User Manual Name) for CPU0_SPR_SPROT_RGNACCENB_R3.
* To use register names with standard convension, please use CPU0_SPR_SPROT_RGNACCENB_R3.
*/


/** \brief E0C8, CPUx Safety Protection SPR Region Read Access Enable Register A4 */

/** Alias (User Manual Name) for CPU0_SPR_SPROT_RGNACCENA_R4.
* To use register names with standard convension, please use CPU0_SPR_SPROT_RGNACCENA_R4.
*/


/** \brief E0CC, CPUx Safety Protection SPR Region Read Access Enable Register B4 */

/** Alias (User Manual Name) for CPU0_SPR_SPROT_RGNACCENB_R4.
* To use register names with standard convension, please use CPU0_SPR_SPROT_RGNACCENB_R4.
*/


/** \brief E0D8, CPUx Safety Protection SPR Region Read Access Enable Register A5 */

/** Alias (User Manual Name) for CPU0_SPR_SPROT_RGNACCENA_R5.
* To use register names with standard convension, please use CPU0_SPR_SPROT_RGNACCENA_R5.
*/


/** \brief E0DC, CPUx Safety Protection SPR Region Read Access Enable Register B5 */

/** Alias (User Manual Name) for CPU0_SPR_SPROT_RGNACCENB_R5.
* To use register names with standard convension, please use CPU0_SPR_SPROT_RGNACCENB_R5.
*/


/** \brief E0E8, CPUx Safety Protection SPR Region Read Access Enable Register A6 */

/** Alias (User Manual Name) for CPU0_SPR_SPROT_RGNACCENA_R6.
* To use register names with standard convension, please use CPU0_SPR_SPROT_RGNACCENA_R6.
*/


/** \brief E0EC, CPUx Safety Protection SPR Region Read Access Enable Register B6 */

/** Alias (User Manual Name) for CPU0_SPR_SPROT_RGNACCENB_R6.
* To use register names with standard convension, please use CPU0_SPR_SPROT_RGNACCENB_R6.
*/


/** \brief E0F8, CPUx Safety Protection SPR Region Read Access Enable Register A7 */

/** Alias (User Manual Name) for CPU0_SPR_SPROT_RGNACCENA_R7.
* To use register names with standard convension, please use CPU0_SPR_SPROT_RGNACCENA_R7.
*/


/** \brief E0FC, CPUx Safety Protection SPR Region Read Access Enable Register B7 */

/** Alias (User Manual Name) for CPU0_SPR_SPROT_RGNACCENB_R7.
* To use register names with standard convension, please use CPU0_SPR_SPROT_RGNACCENB_R7.
*/


/** \brief E100, CPUx Safety Protection Register Access Enable Register A */


/** \brief E104, CPUx Safety Protection Region Access Enable Register B */


/** \brief E110, CPUx Safety Protection Region LPB Read Access Enable Register A */


/** \brief E114, CPUx Safety Protection Region LPB Read Access Enable Register B */


/** \brief E200, CPUx Safety Protection DLMU Region Lower Address Register 0 */


/** \brief E204, CPUx Safety protection DLMU Region Upper Address Register 0 */


/** \brief E208, CPUx Safety Protection Region DLMU Write Access Enable Register A0 */

/** Alias (User Manual Name) for CPU0_DLMU_SPROT_RGNACCENA_W0.
* To use register names with standard convension, please use CPU0_DLMU_SPROT_RGNACCENA_W0.
*/


/** \brief E20C, CPUx Safety Protection Region DLMU Write Access Enable Register B0 */

/** Alias (User Manual Name) for CPU0_DLMU_SPROT_RGNACCENB_W0.
* To use register names with standard convension, please use CPU0_DLMU_SPROT_RGNACCENB_W0.
*/


/** \brief E210, CPUx Safety Protection DLMU Region Lower Address Register 1 */


/** \brief E214, CPUx Safety protection DLMU Region Upper Address Register 1 */


/** \brief E218, CPUx Safety Protection Region DLMU Write Access Enable Register A1 */

/** Alias (User Manual Name) for CPU0_DLMU_SPROT_RGNACCENA_W1.
* To use register names with standard convension, please use CPU0_DLMU_SPROT_RGNACCENA_W1.
*/


/** \brief E21C, CPUx Safety Protection Region DLMU Write Access Enable Register B1 */

/** Alias (User Manual Name) for CPU0_DLMU_SPROT_RGNACCENB_W1.
* To use register names with standard convension, please use CPU0_DLMU_SPROT_RGNACCENB_W1.
*/


/** \brief E220, CPUx Safety Protection DLMU Region Lower Address Register 2 */


/** \brief E224, CPUx Safety protection DLMU Region Upper Address Register 2 */


/** \brief E228, CPUx Safety Protection Region DLMU Write Access Enable Register A2 */

/** Alias (User Manual Name) for CPU0_DLMU_SPROT_RGNACCENA_W2.
* To use register names with standard convension, please use CPU0_DLMU_SPROT_RGNACCENA_W2.
*/


/** \brief E22C, CPUx Safety Protection Region DLMU Write Access Enable Register B2 */

/** Alias (User Manual Name) for CPU0_DLMU_SPROT_RGNACCENB_W2.
* To use register names with standard convension, please use CPU0_DLMU_SPROT_RGNACCENB_W2.
*/


/** \brief E230, CPUx Safety Protection DLMU Region Lower Address Register 3 */


/** \brief E234, CPUx Safety protection DLMU Region Upper Address Register 3 */


/** \brief E238, CPUx Safety Protection Region DLMU Write Access Enable Register A3 */

/** Alias (User Manual Name) for CPU0_DLMU_SPROT_RGNACCENA_W3.
* To use register names with standard convension, please use CPU0_DLMU_SPROT_RGNACCENA_W3.
*/


/** \brief E23C, CPUx Safety Protection Region DLMU Write Access Enable Register B3 */

/** Alias (User Manual Name) for CPU0_DLMU_SPROT_RGNACCENB_W3.
* To use register names with standard convension, please use CPU0_DLMU_SPROT_RGNACCENB_W3.
*/


/** \brief E240, CPUx Safety Protection DLMU Region Lower Address Register 4 */


/** \brief E244, CPUx Safety protection DLMU Region Upper Address Register 4 */


/** \brief E248, CPUx Safety Protection Region DLMU Write Access Enable Register A4 */

/** Alias (User Manual Name) for CPU0_DLMU_SPROT_RGNACCENA_W4.
* To use register names with standard convension, please use CPU0_DLMU_SPROT_RGNACCENA_W4.
*/


/** \brief E24C, CPUx Safety Protection Region DLMU Write Access Enable Register B4 */

/** Alias (User Manual Name) for CPU0_DLMU_SPROT_RGNACCENB_W4.
* To use register names with standard convension, please use CPU0_DLMU_SPROT_RGNACCENB_W4.
*/


/** \brief E250, CPUx Safety Protection DLMU Region Lower Address Register 5 */


/** \brief E254, CPUx Safety protection DLMU Region Upper Address Register 5 */


/** \brief E258, CPUx Safety Protection Region DLMU Write Access Enable Register A5 */

/** Alias (User Manual Name) for CPU0_DLMU_SPROT_RGNACCENA_W5.
* To use register names with standard convension, please use CPU0_DLMU_SPROT_RGNACCENA_W5.
*/


/** \brief E25C, CPUx Safety Protection Region DLMU Write Access Enable Register B5 */

/** Alias (User Manual Name) for CPU0_DLMU_SPROT_RGNACCENB_W5.
* To use register names with standard convension, please use CPU0_DLMU_SPROT_RGNACCENB_W5.
*/


/** \brief E260, CPUx Safety Protection DLMU Region Lower Address Register 6 */


/** \brief E264, CPUx Safety protection DLMU Region Upper Address Register 6 */


/** \brief E268, CPUx Safety Protection Region DLMU Write Access Enable Register A6 */

/** Alias (User Manual Name) for CPU0_DLMU_SPROT_RGNACCENA_W6.
* To use register names with standard convension, please use CPU0_DLMU_SPROT_RGNACCENA_W6.
*/


/** \brief E26C, CPUx Safety Protection Region DLMU Write Access Enable Register B6 */

/** Alias (User Manual Name) for CPU0_DLMU_SPROT_RGNACCENB_W6.
* To use register names with standard convension, please use CPU0_DLMU_SPROT_RGNACCENB_W6.
*/


/** \brief E270, CPUx Safety Protection DLMU Region Lower Address Register 7 */


/** \brief E274, CPUx Safety protection DLMU Region Upper Address Register 7 */


/** \brief E278, CPUx Safety Protection Region DLMU Write Access Enable Register A7 */

/** Alias (User Manual Name) for CPU0_DLMU_SPROT_RGNACCENA_W7.
* To use register names with standard convension, please use CPU0_DLMU_SPROT_RGNACCENA_W7.
*/


/** \brief E27C, CPUx Safety Protection Region DLMU Write Access Enable Register B7 */

/** Alias (User Manual Name) for CPU0_DLMU_SPROT_RGNACCENB_W7.
* To use register names with standard convension, please use CPU0_DLMU_SPROT_RGNACCENB_W7.
*/


/** \brief E288, CPUx Safety Protection Region DLMU Read Access Enable Register A0 */

/** Alias (User Manual Name) for CPU0_DLMU_SPROT_RGNACCENA_R0.
* To use register names with standard convension, please use CPU0_DLMU_SPROT_RGNACCENA_R0.
*/


/** \brief E28C, CPUx Safety Protection Region DLMU Read Access Enable Register B0 */

/** Alias (User Manual Name) for CPU0_DLMU_SPROT_RGNACCENB_R0.
* To use register names with standard convension, please use CPU0_DLMU_SPROT_RGNACCENB_R0.
*/


/** \brief E298, CPUx Safety Protection Region DLMU Read Access Enable Register A1 */

/** Alias (User Manual Name) for CPU0_DLMU_SPROT_RGNACCENA_R1.
* To use register names with standard convension, please use CPU0_DLMU_SPROT_RGNACCENA_R1.
*/


/** \brief E29C, CPUx Safety Protection Region DLMU Read Access Enable Register B1 */

/** Alias (User Manual Name) for CPU0_DLMU_SPROT_RGNACCENB_R1.
* To use register names with standard convension, please use CPU0_DLMU_SPROT_RGNACCENB_R1.
*/


/** \brief E2A8, CPUx Safety Protection Region DLMU Read Access Enable Register A2 */

/** Alias (User Manual Name) for CPU0_DLMU_SPROT_RGNACCENA_R2.
* To use register names with standard convension, please use CPU0_DLMU_SPROT_RGNACCENA_R2.
*/


/** \brief E2AC, CPUx Safety Protection Region DLMU Read Access Enable Register B2 */

/** Alias (User Manual Name) for CPU0_DLMU_SPROT_RGNACCENB_R2.
* To use register names with standard convension, please use CPU0_DLMU_SPROT_RGNACCENB_R2.
*/


/** \brief E2B8, CPUx Safety Protection Region DLMU Read Access Enable Register A3 */

/** Alias (User Manual Name) for CPU0_DLMU_SPROT_RGNACCENA_R3.
* To use register names with standard convension, please use CPU0_DLMU_SPROT_RGNACCENA_R3.
*/


/** \brief E2BC, CPUx Safety Protection Region DLMU Read Access Enable Register B3 */

/** Alias (User Manual Name) for CPU0_DLMU_SPROT_RGNACCENB_R3.
* To use register names with standard convension, please use CPU0_DLMU_SPROT_RGNACCENB_R3.
*/


/** \brief E2C8, CPUx Safety Protection Region DLMU Read Access Enable Register A4 */

/** Alias (User Manual Name) for CPU0_DLMU_SPROT_RGNACCENA_R4.
* To use register names with standard convension, please use CPU0_DLMU_SPROT_RGNACCENA_R4.
*/


/** \brief E2CC, CPUx Safety Protection Region DLMU Read Access Enable Register B4 */

/** Alias (User Manual Name) for CPU0_DLMU_SPROT_RGNACCENB_R4.
* To use register names with standard convension, please use CPU0_DLMU_SPROT_RGNACCENB_R4.
*/


/** \brief E2D8, CPUx Safety Protection Region DLMU Read Access Enable Register A5 */

/** Alias (User Manual Name) for CPU0_DLMU_SPROT_RGNACCENA_R5.
* To use register names with standard convension, please use CPU0_DLMU_SPROT_RGNACCENA_R5.
*/


/** \brief E2DC, CPUx Safety Protection Region DLMU Read Access Enable Register B5 */

/** Alias (User Manual Name) for CPU0_DLMU_SPROT_RGNACCENB_R5.
* To use register names with standard convension, please use CPU0_DLMU_SPROT_RGNACCENB_R5.
*/


/** \brief E2E8, CPUx Safety Protection Region DLMU Read Access Enable Register A6 */

/** Alias (User Manual Name) for CPU0_DLMU_SPROT_RGNACCENA_R6.
* To use register names with standard convension, please use CPU0_DLMU_SPROT_RGNACCENA_R6.
*/


/** \brief E2EC, CPUx Safety Protection Region DLMU Read Access Enable Register B6 */

/** Alias (User Manual Name) for CPU0_DLMU_SPROT_RGNACCENB_R6.
* To use register names with standard convension, please use CPU0_DLMU_SPROT_RGNACCENB_R6.
*/


/** \brief E2F8, CPUx Safety Protection Region DLMU Read Access Enable Register A7 */

/** Alias (User Manual Name) for CPU0_DLMU_SPROT_RGNACCENA_R7.
* To use register names with standard convension, please use CPU0_DLMU_SPROT_RGNACCENA_R7.
*/


/** \brief E2FC, CPUx Safety Protection Region DLMU Read Access Enable Register B7 */

/** Alias (User Manual Name) for CPU0_DLMU_SPROT_RGNACCENB_R7.
* To use register names with standard convension, please use CPU0_DLMU_SPROT_RGNACCENB_R7.
*/


/** \brief FB00, CPUx  Overlay Range Select Register */


/** \brief FB10, CPUx Redirected Address Base Register 0 */

/** Alias (User Manual Name) for CPU0_BLK0_RABR.
* To use register names with standard convension, please use CPU0_BLK0_RABR.
*/


/** \brief FB14, CPUx Overlay Target Address Register 0 */

/** Alias (User Manual Name) for CPU0_BLK0_OTAR.
* To use register names with standard convension, please use CPU0_BLK0_OTAR.
*/


/** \brief FB18, CPUx Overlay Mask Register 0 */

/** Alias (User Manual Name) for CPU0_BLK0_OMASK.
* To use register names with standard convension, please use CPU0_BLK0_OMASK.
*/


/** \brief FB1C, CPUx Redirected Address Base Register 1 */

/** Alias (User Manual Name) for CPU0_BLK1_RABR.
* To use register names with standard convension, please use CPU0_BLK1_RABR.
*/


/** \brief FB20, CPUx Overlay Target Address Register 1 */

/** Alias (User Manual Name) for CPU0_BLK1_OTAR.
* To use register names with standard convension, please use CPU0_BLK1_OTAR.
*/


/** \brief FB24, CPUx Overlay Mask Register 1 */

/** Alias (User Manual Name) for CPU0_BLK1_OMASK.
* To use register names with standard convension, please use CPU0_BLK1_OMASK.
*/


/** \brief FB28, CPUx Redirected Address Base Register 2 */

/** Alias (User Manual Name) for CPU0_BLK2_RABR.
* To use register names with standard convension, please use CPU0_BLK2_RABR.
*/


/** \brief FB2C, CPUx Overlay Target Address Register 2 */

/** Alias (User Manual Name) for CPU0_BLK2_OTAR.
* To use register names with standard convension, please use CPU0_BLK2_OTAR.
*/


/** \brief FB30, CPUx Overlay Mask Register 2 */

/** Alias (User Manual Name) for CPU0_BLK2_OMASK.
* To use register names with standard convension, please use CPU0_BLK2_OMASK.
*/


/** \brief FB34, CPUx Redirected Address Base Register 3 */

/** Alias (User Manual Name) for CPU0_BLK3_RABR.
* To use register names with standard convension, please use CPU0_BLK3_RABR.
*/


/** \brief FB38, CPUx Overlay Target Address Register 3 */

/** Alias (User Manual Name) for CPU0_BLK3_OTAR.
* To use register names with standard convension, please use CPU0_BLK3_OTAR.
*/


/** \brief FB3C, CPUx Overlay Mask Register 3 */

/** Alias (User Manual Name) for CPU0_BLK3_OMASK.
* To use register names with standard convension, please use CPU0_BLK3_OMASK.
*/


/** \brief FB40, CPUx Redirected Address Base Register 4 */

/** Alias (User Manual Name) for CPU0_BLK4_RABR.
* To use register names with standard convension, please use CPU0_BLK4_RABR.
*/


/** \brief FB44, CPUx Overlay Target Address Register 4 */

/** Alias (User Manual Name) for CPU0_BLK4_OTAR.
* To use register names with standard convension, please use CPU0_BLK4_OTAR.
*/


/** \brief FB48, CPUx Overlay Mask Register 4 */

/** Alias (User Manual Name) for CPU0_BLK4_OMASK.
* To use register names with standard convension, please use CPU0_BLK4_OMASK.
*/


/** \brief FB4C, CPUx Redirected Address Base Register 5 */

/** Alias (User Manual Name) for CPU0_BLK5_RABR.
* To use register names with standard convension, please use CPU0_BLK5_RABR.
*/


/** \brief FB50, CPUx Overlay Target Address Register 5 */

/** Alias (User Manual Name) for CPU0_BLK5_OTAR.
* To use register names with standard convension, please use CPU0_BLK5_OTAR.
*/


/** \brief FB54, CPUx Overlay Mask Register 5 */

/** Alias (User Manual Name) for CPU0_BLK5_OMASK.
* To use register names with standard convension, please use CPU0_BLK5_OMASK.
*/


/** \brief FB58, CPUx Redirected Address Base Register 6 */

/** Alias (User Manual Name) for CPU0_BLK6_RABR.
* To use register names with standard convension, please use CPU0_BLK6_RABR.
*/


/** \brief FB5C, CPUx Overlay Target Address Register 6 */

/** Alias (User Manual Name) for CPU0_BLK6_OTAR.
* To use register names with standard convension, please use CPU0_BLK6_OTAR.
*/


/** \brief FB60, CPUx Overlay Mask Register 6 */

/** Alias (User Manual Name) for CPU0_BLK6_OMASK.
* To use register names with standard convension, please use CPU0_BLK6_OMASK.
*/


/** \brief FB64, CPUx Redirected Address Base Register 7 */

/** Alias (User Manual Name) for CPU0_BLK7_RABR.
* To use register names with standard convension, please use CPU0_BLK7_RABR.
*/


/** \brief FB68, CPUx Overlay Target Address Register 7 */

/** Alias (User Manual Name) for CPU0_BLK7_OTAR.
* To use register names with standard convension, please use CPU0_BLK7_OTAR.
*/


/** \brief FB6C, CPUx Overlay Mask Register 7 */

/** Alias (User Manual Name) for CPU0_BLK7_OMASK.
* To use register names with standard convension, please use CPU0_BLK7_OMASK.
*/


/** \brief FB70, CPUx Redirected Address Base Register 8 */

/** Alias (User Manual Name) for CPU0_BLK8_RABR.
* To use register names with standard convension, please use CPU0_BLK8_RABR.
*/


/** \brief FB74, CPUx Overlay Target Address Register 8 */

/** Alias (User Manual Name) for CPU0_BLK8_OTAR.
* To use register names with standard convension, please use CPU0_BLK8_OTAR.
*/


/** \brief FB78, CPUx Overlay Mask Register 8 */

/** Alias (User Manual Name) for CPU0_BLK8_OMASK.
* To use register names with standard convension, please use CPU0_BLK8_OMASK.
*/


/** \brief FB7C, CPUx Redirected Address Base Register 9 */

/** Alias (User Manual Name) for CPU0_BLK9_RABR.
* To use register names with standard convension, please use CPU0_BLK9_RABR.
*/


/** \brief FB80, CPUx Overlay Target Address Register 9 */

/** Alias (User Manual Name) for CPU0_BLK9_OTAR.
* To use register names with standard convension, please use CPU0_BLK9_OTAR.
*/


/** \brief FB84, CPUx Overlay Mask Register 9 */

/** Alias (User Manual Name) for CPU0_BLK9_OMASK.
* To use register names with standard convension, please use CPU0_BLK9_OMASK.
*/


/** \brief FB88, CPUx Redirected Address Base Register 10 */

/** Alias (User Manual Name) for CPU0_BLK10_RABR.
* To use register names with standard convension, please use CPU0_BLK10_RABR.
*/


/** \brief FB8C, CPUx Overlay Target Address Register 10 */

/** Alias (User Manual Name) for CPU0_BLK10_OTAR.
* To use register names with standard convension, please use CPU0_BLK10_OTAR.
*/


/** \brief FB90, CPUx Overlay Mask Register 10 */

/** Alias (User Manual Name) for CPU0_BLK10_OMASK.
* To use register names with standard convension, please use CPU0_BLK10_OMASK.
*/


/** \brief FB94, CPUx Redirected Address Base Register 11 */

/** Alias (User Manual Name) for CPU0_BLK11_RABR.
* To use register names with standard convension, please use CPU0_BLK11_RABR.
*/


/** \brief FB98, CPUx Overlay Target Address Register 11 */

/** Alias (User Manual Name) for CPU0_BLK11_OTAR.
* To use register names with standard convension, please use CPU0_BLK11_OTAR.
*/


/** \brief FB9C, CPUx Overlay Mask Register 11 */

/** Alias (User Manual Name) for CPU0_BLK11_OMASK.
* To use register names with standard convension, please use CPU0_BLK11_OMASK.
*/


/** \brief FBA0, CPUx Redirected Address Base Register 12 */

/** Alias (User Manual Name) for CPU0_BLK12_RABR.
* To use register names with standard convension, please use CPU0_BLK12_RABR.
*/


/** \brief FBA4, CPUx Overlay Target Address Register 12 */

/** Alias (User Manual Name) for CPU0_BLK12_OTAR.
* To use register names with standard convension, please use CPU0_BLK12_OTAR.
*/


/** \brief FBA8, CPUx Overlay Mask Register 12 */

/** Alias (User Manual Name) for CPU0_BLK12_OMASK.
* To use register names with standard convension, please use CPU0_BLK12_OMASK.
*/


/** \brief FBAC, CPUx Redirected Address Base Register 13 */

/** Alias (User Manual Name) for CPU0_BLK13_RABR.
* To use register names with standard convension, please use CPU0_BLK13_RABR.
*/


/** \brief FBB0, CPUx Overlay Target Address Register 13 */

/** Alias (User Manual Name) for CPU0_BLK13_OTAR.
* To use register names with standard convension, please use CPU0_BLK13_OTAR.
*/


/** \brief FBB4, CPUx Overlay Mask Register 13 */

/** Alias (User Manual Name) for CPU0_BLK13_OMASK.
* To use register names with standard convension, please use CPU0_BLK13_OMASK.
*/


/** \brief FBB8, CPUx Redirected Address Base Register 14 */

/** Alias (User Manual Name) for CPU0_BLK14_RABR.
* To use register names with standard convension, please use CPU0_BLK14_RABR.
*/


/** \brief FBBC, CPUx Overlay Target Address Register 14 */

/** Alias (User Manual Name) for CPU0_BLK14_OTAR.
* To use register names with standard convension, please use CPU0_BLK14_OTAR.
*/


/** \brief FBC0, CPUx Overlay Mask Register 14 */

/** Alias (User Manual Name) for CPU0_BLK14_OMASK.
* To use register names with standard convension, please use CPU0_BLK14_OMASK.
*/


/** \brief FBC4, CPUx Redirected Address Base Register 15 */

/** Alias (User Manual Name) for CPU0_BLK15_RABR.
* To use register names with standard convension, please use CPU0_BLK15_RABR.
*/


/** \brief FBC8, CPUx Overlay Target Address Register 15 */

/** Alias (User Manual Name) for CPU0_BLK15_OTAR.
* To use register names with standard convension, please use CPU0_BLK15_OTAR.
*/


/** \brief FBCC, CPUx Overlay Mask Register 15 */

/** Alias (User Manual Name) for CPU0_BLK15_OMASK.
* To use register names with standard convension, please use CPU0_BLK15_OMASK.
*/


/** \brief FBD0, CPUx Redirected Address Base Register 16 */

/** Alias (User Manual Name) for CPU0_BLK16_RABR.
* To use register names with standard convension, please use CPU0_BLK16_RABR.
*/


/** \brief FBD4, CPUx Overlay Target Address Register 16 */

/** Alias (User Manual Name) for CPU0_BLK16_OTAR.
* To use register names with standard convension, please use CPU0_BLK16_OTAR.
*/


/** \brief FBD8, CPUx Overlay Mask Register 16 */

/** Alias (User Manual Name) for CPU0_BLK16_OMASK.
* To use register names with standard convension, please use CPU0_BLK16_OMASK.
*/


/** \brief FBDC, CPUx Redirected Address Base Register 17 */

/** Alias (User Manual Name) for CPU0_BLK17_RABR.
* To use register names with standard convension, please use CPU0_BLK17_RABR.
*/


/** \brief FBE0, CPUx Overlay Target Address Register 17 */

/** Alias (User Manual Name) for CPU0_BLK17_OTAR.
* To use register names with standard convension, please use CPU0_BLK17_OTAR.
*/


/** \brief FBE4, CPUx Overlay Mask Register 17 */

/** Alias (User Manual Name) for CPU0_BLK17_OMASK.
* To use register names with standard convension, please use CPU0_BLK17_OMASK.
*/


/** \brief FBE8, CPUx Redirected Address Base Register 18 */

/** Alias (User Manual Name) for CPU0_BLK18_RABR.
* To use register names with standard convension, please use CPU0_BLK18_RABR.
*/


/** \brief FBEC, CPUx Overlay Target Address Register 18 */

/** Alias (User Manual Name) for CPU0_BLK18_OTAR.
* To use register names with standard convension, please use CPU0_BLK18_OTAR.
*/


/** \brief FBF0, CPUx Overlay Mask Register 18 */

/** Alias (User Manual Name) for CPU0_BLK18_OMASK.
* To use register names with standard convension, please use CPU0_BLK18_OMASK.
*/


/** \brief FBF4, CPUx Redirected Address Base Register 19 */

/** Alias (User Manual Name) for CPU0_BLK19_RABR.
* To use register names with standard convension, please use CPU0_BLK19_RABR.
*/


/** \brief FBF8, CPUx Overlay Target Address Register 19 */

/** Alias (User Manual Name) for CPU0_BLK19_OTAR.
* To use register names with standard convension, please use CPU0_BLK19_OTAR.
*/


/** \brief FBFC, CPUx Overlay Mask Register 19 */

/** Alias (User Manual Name) for CPU0_BLK19_OMASK.
* To use register names with standard convension, please use CPU0_BLK19_OMASK.
*/


/** \brief FC00, CPUx Redirected Address Base Register 20 */

/** Alias (User Manual Name) for CPU0_BLK20_RABR.
* To use register names with standard convension, please use CPU0_BLK20_RABR.
*/


/** \brief FC04, CPUx Overlay Target Address Register 20 */

/** Alias (User Manual Name) for CPU0_BLK20_OTAR.
* To use register names with standard convension, please use CPU0_BLK20_OTAR.
*/


/** \brief FC08, CPUx Overlay Mask Register 20 */

/** Alias (User Manual Name) for CPU0_BLK20_OMASK.
* To use register names with standard convension, please use CPU0_BLK20_OMASK.
*/


/** \brief FC0C, CPUx Redirected Address Base Register 21 */

/** Alias (User Manual Name) for CPU0_BLK21_RABR.
* To use register names with standard convension, please use CPU0_BLK21_RABR.
*/


/** \brief FC10, CPUx Overlay Target Address Register 21 */

/** Alias (User Manual Name) for CPU0_BLK21_OTAR.
* To use register names with standard convension, please use CPU0_BLK21_OTAR.
*/


/** \brief FC14, CPUx Overlay Mask Register 21 */

/** Alias (User Manual Name) for CPU0_BLK21_OMASK.
* To use register names with standard convension, please use CPU0_BLK21_OMASK.
*/


/** \brief FC18, CPUx Redirected Address Base Register 22 */

/** Alias (User Manual Name) for CPU0_BLK22_RABR.
* To use register names with standard convension, please use CPU0_BLK22_RABR.
*/


/** \brief FC1C, CPUx Overlay Target Address Register 22 */

/** Alias (User Manual Name) for CPU0_BLK22_OTAR.
* To use register names with standard convension, please use CPU0_BLK22_OTAR.
*/


/** \brief FC20, CPUx Overlay Mask Register 22 */

/** Alias (User Manual Name) for CPU0_BLK22_OMASK.
* To use register names with standard convension, please use CPU0_BLK22_OMASK.
*/


/** \brief FC24, CPUx Redirected Address Base Register 23 */

/** Alias (User Manual Name) for CPU0_BLK23_RABR.
* To use register names with standard convension, please use CPU0_BLK23_RABR.
*/


/** \brief FC28, CPUx Overlay Target Address Register 23 */

/** Alias (User Manual Name) for CPU0_BLK23_OTAR.
* To use register names with standard convension, please use CPU0_BLK23_OTAR.
*/


/** \brief FC2C, CPUx Overlay Mask Register 23 */

/** Alias (User Manual Name) for CPU0_BLK23_OMASK.
* To use register names with standard convension, please use CPU0_BLK23_OMASK.
*/


/** \brief FC30, CPUx Redirected Address Base Register 24 */

/** Alias (User Manual Name) for CPU0_BLK24_RABR.
* To use register names with standard convension, please use CPU0_BLK24_RABR.
*/


/** \brief FC34, CPUx Overlay Target Address Register 24 */

/** Alias (User Manual Name) for CPU0_BLK24_OTAR.
* To use register names with standard convension, please use CPU0_BLK24_OTAR.
*/


/** \brief FC38, CPUx Overlay Mask Register 24 */

/** Alias (User Manual Name) for CPU0_BLK24_OMASK.
* To use register names with standard convension, please use CPU0_BLK24_OMASK.
*/


/** \brief FC3C, CPUx Redirected Address Base Register 25 */

/** Alias (User Manual Name) for CPU0_BLK25_RABR.
* To use register names with standard convension, please use CPU0_BLK25_RABR.
*/


/** \brief FC40, CPUx Overlay Target Address Register 25 */

/** Alias (User Manual Name) for CPU0_BLK25_OTAR.
* To use register names with standard convension, please use CPU0_BLK25_OTAR.
*/


/** \brief FC44, CPUx Overlay Mask Register 25 */

/** Alias (User Manual Name) for CPU0_BLK25_OMASK.
* To use register names with standard convension, please use CPU0_BLK25_OMASK.
*/


/** \brief FC48, CPUx Redirected Address Base Register 26 */

/** Alias (User Manual Name) for CPU0_BLK26_RABR.
* To use register names with standard convension, please use CPU0_BLK26_RABR.
*/


/** \brief FC4C, CPUx Overlay Target Address Register 26 */

/** Alias (User Manual Name) for CPU0_BLK26_OTAR.
* To use register names with standard convension, please use CPU0_BLK26_OTAR.
*/


/** \brief FC50, CPUx Overlay Mask Register 26 */

/** Alias (User Manual Name) for CPU0_BLK26_OMASK.
* To use register names with standard convension, please use CPU0_BLK26_OMASK.
*/


/** \brief FC54, CPUx Redirected Address Base Register 27 */

/** Alias (User Manual Name) for CPU0_BLK27_RABR.
* To use register names with standard convension, please use CPU0_BLK27_RABR.
*/


/** \brief FC58, CPUx Overlay Target Address Register 27 */

/** Alias (User Manual Name) for CPU0_BLK27_OTAR.
* To use register names with standard convension, please use CPU0_BLK27_OTAR.
*/


/** \brief FC5C, CPUx Overlay Mask Register 27 */

/** Alias (User Manual Name) for CPU0_BLK27_OMASK.
* To use register names with standard convension, please use CPU0_BLK27_OMASK.
*/


/** \brief FC60, CPUx Redirected Address Base Register 28 */

/** Alias (User Manual Name) for CPU0_BLK28_RABR.
* To use register names with standard convension, please use CPU0_BLK28_RABR.
*/


/** \brief FC64, CPUx Overlay Target Address Register 28 */

/** Alias (User Manual Name) for CPU0_BLK28_OTAR.
* To use register names with standard convension, please use CPU0_BLK28_OTAR.
*/


/** \brief FC68, CPUx Overlay Mask Register 28 */

/** Alias (User Manual Name) for CPU0_BLK28_OMASK.
* To use register names with standard convension, please use CPU0_BLK28_OMASK.
*/


/** \brief FC6C, CPUx Redirected Address Base Register 29 */

/** Alias (User Manual Name) for CPU0_BLK29_RABR.
* To use register names with standard convension, please use CPU0_BLK29_RABR.
*/


/** \brief FC70, CPUx Overlay Target Address Register 29 */

/** Alias (User Manual Name) for CPU0_BLK29_OTAR.
* To use register names with standard convension, please use CPU0_BLK29_OTAR.
*/


/** \brief FC74, CPUx Overlay Mask Register 29 */

/** Alias (User Manual Name) for CPU0_BLK29_OMASK.
* To use register names with standard convension, please use CPU0_BLK29_OMASK.
*/


/** \brief FC78, CPUx Redirected Address Base Register 30 */

/** Alias (User Manual Name) for CPU0_BLK30_RABR.
* To use register names with standard convension, please use CPU0_BLK30_RABR.
*/


/** \brief FC7C, CPUx Overlay Target Address Register 30 */

/** Alias (User Manual Name) for CPU0_BLK30_OTAR.
* To use register names with standard convension, please use CPU0_BLK30_OTAR.
*/


/** \brief FC80, CPUx Overlay Mask Register 30 */

/** Alias (User Manual Name) for CPU0_BLK30_OMASK.
* To use register names with standard convension, please use CPU0_BLK30_OMASK.
*/


/** \brief FC84, CPUx Redirected Address Base Register 31 */

/** Alias (User Manual Name) for CPU0_BLK31_RABR.
* To use register names with standard convension, please use CPU0_BLK31_RABR.
*/


/** \brief FC88, CPUx Overlay Target Address Register 31 */

/** Alias (User Manual Name) for CPU0_BLK31_OTAR.
* To use register names with standard convension, please use CPU0_BLK31_OTAR.
*/


/** \brief FC8C, CPUx Overlay Mask Register 31 */

/** Alias (User Manual Name) for CPU0_BLK31_OMASK.
* To use register names with standard convension, please use CPU0_BLK31_OMASK.
*/


/** \brief 1030, CPUx SRI Error Generation Register */


/** \brief 8004, CPUx Task Address Space Identifier Register */


/** \brief 8100, CPUx Data Access CacheabilityRegister */


/** \brief 8104, CPUx Code Access CacheabilityRegister */


/** \brief 8108, CPUx  Peripheral Space Identifier register */


/** \brief 9000, CPUx Data Control Register 2 */


/** \brief 900C, CPUx SIST Mode Access Control Register */


/** \brief 9010, CPUx Data Synchronous Trap Register */


/** \brief 9018, CPUx Data Asynchronous Trap Register */


/** \brief 901C, CPUx Data Error Address Register */


/** \brief 9020, CPUx Data Integrity Error Address Register */


/** \brief 9024, CPUx Data Integrity Error Trap Register */


/** \brief 9040, CPUx Data Memory Control Register */


/** \brief 9200, CPUx Program Synchronous Trap Register */


/** \brief 9204, CPUx Program Control 1 */


/** \brief 9208, CPUx Program Control 2 */


/** \brief 920C, CPUx Program Control 0 */


/** \brief 9210, CPUx Program Integrity Error Address Register */


/** \brief 9214, CPUx Program Integrity Error Trap Register */


/** \brief 9400, CPUx Compatibility Control Register */


/** \brief A000, CPUx Trap Control Register */


/** \brief A004, CPUx Trapping Instruction Program Counter Register */


/** \brief A008, CPUx Trapping Instruction Opcode Register */


/** \brief A010, CPUx Trapping Instruction Operand Register */


/** \brief A014, CPUx Trapping Instruction Operand Register */


/** \brief A018, CPUx Trapping Instruction Operand Register */


/** \brief C000, CPUx Data Protection Range 0, Lower Bound Register */


/** \brief C004, CPUx Data Protection Range 0, Upper Bound Register */


/** \brief C008, CPUx Data Protection Range 1, Lower Bound Register */


/** \brief C00C, CPUx Data Protection Range 1, Upper Bound Register */


/** \brief C010, CPUx Data Protection Range 2, Lower Bound Register */


/** \brief C014, CPUx Data Protection Range 2, Upper Bound Register */


/** \brief C018, CPUx Data Protection Range 3, Lower Bound Register */


/** \brief C01C, CPUx Data Protection Range 3, Upper Bound Register */


/** \brief C020, CPUx Data Protection Range 4, Lower Bound Register */


/** \brief C024, CPUx Data Protection Range 4, Upper Bound Register */


/** \brief C028, CPUx Data Protection Range 5, Lower Bound Register */


/** \brief C02C, CPUx Data Protection Range 5, Upper Bound Register */


/** \brief C030, CPUx Data Protection Range 6, Lower Bound Register */


/** \brief C034, CPUx Data Protection Range 6, Upper Bound Register */


/** \brief C038, CPUx Data Protection Range 7, Lower Bound Register */


/** \brief C03C, CPUx Data Protection Range 7, Upper Bound Register */


/** \brief C040, CPUx Data Protection Range 8, Lower Bound Register */


/** \brief C044, CPUx Data Protection Range 8, Upper Bound Register */


/** \brief C048, CPUx Data Protection Range 9, Lower Bound Register */


/** \brief C04C, CPUx Data Protection Range 9, Upper Bound Register */


/** \brief C050, CPUx Data Protection Range 10, Lower Bound Register */


/** \brief C054, CPUx Data Protection Range 10, Upper Bound Register */


/** \brief C058, CPUx Data Protection Range 11, Lower Bound Register */


/** \brief C05C, CPUx Data Protection Range 11, Upper Bound Register */


/** \brief C060, CPUx Data Protection Range 12, Lower Bound Register */


/** \brief C064, CPUx Data Protection Range 12, Upper Bound Register */


/** \brief C068, CPUx Data Protection Range 13, Lower Bound Register */


/** \brief C06C, CPUx Data Protection Range 13, Upper Bound Register */


/** \brief C070, CPUx Data Protection Range 14, Lower Bound Register */


/** \brief C074, CPUx Data Protection Range 14, Upper Bound Register */


/** \brief C078, CPUx Data Protection Range 15, Lower Bound Register */


/** \brief C07C, CPUx Data Protection Range 15, Upper Bound Register */


/** \brief C080, CPUx Data Protection Range 16, Lower Bound Register */


/** \brief C084, CPUx Data Protection Range 16, Upper Bound Register */


/** \brief C088, CPUx Data Protection Range 17, Lower Bound Register */


/** \brief C08C, CPUx Data Protection Range 17, Upper Bound Register */


/** \brief D000, CPUx Code Protection Range 0 Lower Bound Register */


/** \brief D004, CPUx Code Protection Range 0 Upper Bound Register */


/** \brief D008, CPUx Code Protection Range 1 Lower Bound Register */


/** \brief D00C, CPUx Code Protection Range 1 Upper Bound Register */


/** \brief D010, CPUx Code Protection Range 2 Lower Bound Register */


/** \brief D014, CPUx Code Protection Range 2 Upper Bound Register */


/** \brief D018, CPUx Code Protection Range 3 Lower Bound Register */


/** \brief D01C, CPUx Code Protection Range 3 Upper Bound Register */


/** \brief D020, CPUx Code Protection Range 4 Lower Bound Register */


/** \brief D024, CPUx Code Protection Range 4 Upper Bound Register */


/** \brief D028, CPUx Code Protection Range 5 Lower Bound Register */


/** \brief D02C, CPUx Code Protection Range 5 Upper Bound Register */


/** \brief D030, CPUx Code Protection Range 6 Lower Bound Register */


/** \brief D034, CPUx Code Protection Range 6 Upper Bound Register */


/** \brief D038, CPUx Code Protection Range 7 Lower Bound Register */


/** \brief D03C, CPUx Code Protection Range 7 Upper Bound Register */


/** \brief D040, CPUx Code Protection Range 8 Lower Bound Register */


/** \brief D044, CPUx Code Protection Range 8 Upper Bound Register */


/** \brief D048, CPUx Code Protection Range 9 Lower Bound Register */


/** \brief D04C, CPUx Code Protection Range 9 Upper Bound Register */


/** \brief E000, CPUx Code Protection Execute Enable Register Set 0 */


/** \brief E004, CPUx Code Protection Execute Enable Register Set 1 */


/** \brief E008, CPUx Code Protection Execute Enable Register Set 2 */


/** \brief E00C, CPUx Code Protection Execute Enable Register Set 3 */


/** \brief E010, CPUx Data Protection Read Enable Register Set 0 */


/** \brief E014, CPUx Data Protection Read Enable Register Set 1 */


/** \brief E018, CPUx Data Protection Read Enable Register Set 2 */


/** \brief E01C, CPUx Data Protection Read Enable Register Set 3 */


/** \brief E020, CPUx Data Protection Write Enable Register Set 0 */


/** \brief E024, CPUx Data Protection Write Enable Register Set 1 */


/** \brief E028, CPUx Data Protection Write Enable Register Set 2 */


/** \brief E02C, CPUx Data Protection Write Enable Register Set 3 */


/** \brief E040, CPUx Code Protection Execute Enable Register Set 4 */


/** \brief E044, CPUx Code Protection Execute Enable Register Set 5 */


/** \brief E050, CPUx Data Protection Read Enable Register Set 4 */


/** \brief E054, CPUx Data Protection Read Enable Register Set 5 */


/** \brief E060, CPUx Data Protection Write Enable Register Set 4 */


/** \brief E064, CPUx Data Protection Write Enable Register Set 5 */


/** \brief E400, CPUx Temporal Protection System Control Register */


/** \brief E404, CPUx Temporal Protection System Timer Register 0 */


/** \brief E408, CPUx Temporal Protection System Timer Register 1 */


/** \brief E40C, CPUx Temporal Protection System Timer Register 2 */


/** \brief E440, CPUx Exception Entry Timer Load Value */


/** \brief E444, CPUx Exception Entry Timer Current Value */


/** \brief E448, CPUx Exception Exit  Timer Load Value */


/** \brief E44C, CPUx Exception Exit Timer Current Value */


/** \brief E450, CPUx Exception Timer Class Enable Register */


/** \brief E454, CPUx Exception Timer Status Register */


/** \brief E458, CPUx Exception Timer FCX Register */


/** \brief F000, CPUx Trigger Event 0 */

/** Alias (User Manual Name) for CPU0_TR0_EVT.
* To use register names with standard convension, please use CPU0_TR0_EVT.
*/


/** \brief F004, CPUx Trigger Address 0 */

/** Alias (User Manual Name) for CPU0_TR0_ADR.
* To use register names with standard convension, please use CPU0_TR0_ADR.
*/


/** \brief F008, CPUx Trigger Event 1 */

/** Alias (User Manual Name) for CPU0_TR1_EVT.
* To use register names with standard convension, please use CPU0_TR1_EVT.
*/


/** \brief F00C, CPUx Trigger Address 1 */

/** Alias (User Manual Name) for CPU0_TR1_ADR.
* To use register names with standard convension, please use CPU0_TR1_ADR.
*/


/** \brief F010, CPUx Trigger Event 2 */

/** Alias (User Manual Name) for CPU0_TR2_EVT.
* To use register names with standard convension, please use CPU0_TR2_EVT.
*/


/** \brief F014, CPUx Trigger Address 2 */

/** Alias (User Manual Name) for CPU0_TR2_ADR.
* To use register names with standard convension, please use CPU0_TR2_ADR.
*/


/** \brief F018, CPUx Trigger Event 3 */

/** Alias (User Manual Name) for CPU0_TR3_EVT.
* To use register names with standard convension, please use CPU0_TR3_EVT.
*/


/** \brief F01C, CPUx Trigger Address 3 */

/** Alias (User Manual Name) for CPU0_TR3_ADR.
* To use register names with standard convension, please use CPU0_TR3_ADR.
*/


/** \brief F020, CPUx Trigger Event 4 */

/** Alias (User Manual Name) for CPU0_TR4_EVT.
* To use register names with standard convension, please use CPU0_TR4_EVT.
*/


/** \brief F024, CPUx Trigger Address 4 */

/** Alias (User Manual Name) for CPU0_TR4_ADR.
* To use register names with standard convension, please use CPU0_TR4_ADR.
*/


/** \brief F028, CPUx Trigger Event 5 */

/** Alias (User Manual Name) for CPU0_TR5_EVT.
* To use register names with standard convension, please use CPU0_TR5_EVT.
*/


/** \brief F02C, CPUx Trigger Address 5 */

/** Alias (User Manual Name) for CPU0_TR5_ADR.
* To use register names with standard convension, please use CPU0_TR5_ADR.
*/


/** \brief F030, CPUx Trigger Event 6 */

/** Alias (User Manual Name) for CPU0_TR6_EVT.
* To use register names with standard convension, please use CPU0_TR6_EVT.
*/


/** \brief F034, CPUx Trigger Address 6 */

/** Alias (User Manual Name) for CPU0_TR6_ADR.
* To use register names with standard convension, please use CPU0_TR6_ADR.
*/


/** \brief F038, CPUx Trigger Event 7 */

/** Alias (User Manual Name) for CPU0_TR7_EVT.
* To use register names with standard convension, please use CPU0_TR7_EVT.
*/


/** \brief F03C, CPUx Trigger Address 7 */

/** Alias (User Manual Name) for CPU0_TR7_ADR.
* To use register names with standard convension, please use CPU0_TR7_ADR.
*/


/** \brief FC00, CPUx Counter Control */


/** \brief FC04, CPUx CPU Clock Cycle Count */


/** \brief FC08, CPUx Instruction Count */


/** \brief FC0C, CPUx Multi-Count Register 1 */


/** \brief FC10, CPUx Multi-Count Register 2 */


/** \brief FC14, CPUx Multi-Count Register 3 */


/** \brief FD00, CPUx Debug Status Register */


/** \brief FD08, CPUx External Event Register */


/** \brief FD0C, CPUx Core Register Access Event */


/** \brief FD10, CPUx Software Debug Event */


/** \brief FD30, CPUx TriggerAddressx */


/** \brief FD40, CPUx Debug Monitor Start Address */


/** \brief FD44, CPUx Debug Context Save Area Pointer */


/** \brief FD48, CPUx Debug Trap Control Register */


/** \brief FE00, CPUx Previous Context Information Register */


/** \brief FE04, CPUx Program Status Word */


/** \brief FE08, CPUx Program Counter */


/** \brief FE14, CPUx System Configuration Register */


/** \brief FE18, CPUx Identification Register TC1.6.2P */


/** \brief FE1C, CPUx Core Identification Register */


/** \brief FE20, CPUx Base Interrupt Vector Table Pointer */


/** \brief FE24, CPUx Base Trap Vector Table Pointer */


/** \brief FE28, CPUx Interrupt Stack Pointer */


/** \brief FE2C, CPUx Interrupt Control Register */


/** \brief FE38, CPUx Free CSA List Head Pointer */


/** \brief FE3C, CPUx Free CSA List Limit Pointer */


/** \brief FE50, CPUx Customer ID register */


/** \brief FF00, CPUx Data General Purpose Register 0 */


/** \brief FF04, CPUx Data General Purpose Register 1 */


/** \brief FF08, CPUx Data General Purpose Register 2 */


/** \brief FF0C, CPUx Data General Purpose Register 3 */


/** \brief FF10, CPUx Data General Purpose Register 4 */


/** \brief FF14, CPUx Data General Purpose Register 5 */


/** \brief FF18, CPUx Data General Purpose Register 6 */


/** \brief FF1C, CPUx Data General Purpose Register 7 */


/** \brief FF20, CPUx Data General Purpose Register 8 */


/** \brief FF24, CPUx Data General Purpose Register 9 */


/** \brief FF28, CPUx Data General Purpose Register 10 */


/** \brief FF2C, CPUx Data General Purpose Register 11 */


/** \brief FF30, CPUx Data General Purpose Register 12 */


/** \brief FF34, CPUx Data General Purpose Register 13 */


/** \brief FF38, CPUx Data General Purpose Register 14 */


/** \brief FF3C, CPUx Data General Purpose Register 15 */


/** \brief FF80, CPUx Address General Purpose Register 0 */


/** \brief FF84, CPUx Address General Purpose Register 1 */


/** \brief FF88, CPUx Address General Purpose Register 2 */


/** \brief FF8C, CPUx Address General Purpose Register 3 */


/** \brief FF90, CPUx Address General Purpose Register 4 */


/** \brief FF94, CPUx Address General Purpose Register 5 */


/** \brief FF98, CPUx Address General Purpose Register 6 */


/** \brief FF9C, CPUx Address General Purpose Register 7 */


/** \brief FFA0, CPUx Address General Purpose Register 8 */


/** \brief FFA4, CPUx Address General Purpose Register 9 */


/** \brief FFA8, CPUx Address General Purpose Register 10 */


/** \brief FFAC, CPUx Address General Purpose Register 11 */


/** \brief FFB0, CPUx Address General Purpose Register 12 */


/** \brief FFB4, CPUx Address General Purpose Register 13 */


/** \brief FFB8, CPUx Address General Purpose Register 14 */


/** \brief FFBC, CPUx Address General Purpose Register 15 */


/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Cpu_Registers_Cfg_Cpu1
 * \{  */
/** \brief 1100, CPUx Flash Configuration Register 0 */


/** \brief 1104, CPUx Flash Configuration Register 1 */


/** \brief 1108, CPUx Flash Configuration Register 2 */


/** \brief 110C, CPUx Flash Configuration Register 3 */


/** \brief 1110, CPUx Flash Configuration Register 4 */


/** \brief D000, CPUx  Reset Register 0 */


/** \brief D004, CPUx  Reset Register 1 */


/** \brief D008, CPUx Reset Clear Register */


/** \brief E000, CPUx Safety Protection SPR Region Lower Address Register 0 */

/** Alias (User Manual Name) for CPU1_RGN0_LA.
* To use register names with standard convension, please use CPU1_RGN0_LA.
*/


/** \brief E004, CPUx Safety Protection SPR Region Upper Address Register 0 */

/** Alias (User Manual Name) for CPU1_RGN0_UA.
* To use register names with standard convension, please use CPU1_RGN0_UA.
*/


/** \brief E008, CPUx Safety Protection SPR Region Write Access Enable Register A0 */

/** Alias (User Manual Name) for CPU1_RGN0_ACCENA.
* To use register names with standard convension, please use CPU1_RGN0_ACCENA.
*/


/** \brief E00C, CPUx Safety Protection SPR Region Write Access Enable Register B0 */

/** Alias (User Manual Name) for CPU1_RGN0_ACCENB.
* To use register names with standard convension, please use CPU1_RGN0_ACCENB.
*/


/** \brief E010, CPUx Safety Protection SPR Region Lower Address Register 1 */

/** Alias (User Manual Name) for CPU1_RGN1_LA.
* To use register names with standard convension, please use CPU1_RGN1_LA.
*/


/** \brief E014, CPUx Safety Protection SPR Region Upper Address Register 1 */

/** Alias (User Manual Name) for CPU1_RGN1_UA.
* To use register names with standard convension, please use CPU1_RGN1_UA.
*/


/** \brief E018, CPUx Safety Protection SPR Region Write Access Enable Register A1 */

/** Alias (User Manual Name) for CPU1_RGN1_ACCENA.
* To use register names with standard convension, please use CPU1_RGN1_ACCENA.
*/


/** \brief E01C, CPUx Safety Protection SPR Region Write Access Enable Register B1 */

/** Alias (User Manual Name) for CPU1_RGN1_ACCENB.
* To use register names with standard convension, please use CPU1_RGN1_ACCENB.
*/


/** \brief E020, CPUx Safety Protection SPR Region Lower Address Register 2 */

/** Alias (User Manual Name) for CPU1_RGN2_LA.
* To use register names with standard convension, please use CPU1_RGN2_LA.
*/


/** \brief E024, CPUx Safety Protection SPR Region Upper Address Register 2 */

/** Alias (User Manual Name) for CPU1_RGN2_UA.
* To use register names with standard convension, please use CPU1_RGN2_UA.
*/


/** \brief E028, CPUx Safety Protection SPR Region Write Access Enable Register A2 */

/** Alias (User Manual Name) for CPU1_RGN2_ACCENA.
* To use register names with standard convension, please use CPU1_RGN2_ACCENA.
*/


/** \brief E02C, CPUx Safety Protection SPR Region Write Access Enable Register B2 */

/** Alias (User Manual Name) for CPU1_RGN2_ACCENB.
* To use register names with standard convension, please use CPU1_RGN2_ACCENB.
*/


/** \brief E030, CPUx Safety Protection SPR Region Lower Address Register 3 */

/** Alias (User Manual Name) for CPU1_RGN3_LA.
* To use register names with standard convension, please use CPU1_RGN3_LA.
*/


/** \brief E034, CPUx Safety Protection SPR Region Upper Address Register 3 */

/** Alias (User Manual Name) for CPU1_RGN3_UA.
* To use register names with standard convension, please use CPU1_RGN3_UA.
*/


/** \brief E038, CPUx Safety Protection SPR Region Write Access Enable Register A3 */

/** Alias (User Manual Name) for CPU1_RGN3_ACCENA.
* To use register names with standard convension, please use CPU1_RGN3_ACCENA.
*/


/** \brief E03C, CPUx Safety Protection SPR Region Write Access Enable Register B3 */

/** Alias (User Manual Name) for CPU1_RGN3_ACCENB.
* To use register names with standard convension, please use CPU1_RGN3_ACCENB.
*/


/** \brief E040, CPUx Safety Protection SPR Region Lower Address Register 4 */

/** Alias (User Manual Name) for CPU1_RGN4_LA.
* To use register names with standard convension, please use CPU1_RGN4_LA.
*/


/** \brief E044, CPUx Safety Protection SPR Region Upper Address Register 4 */

/** Alias (User Manual Name) for CPU1_RGN4_UA.
* To use register names with standard convension, please use CPU1_RGN4_UA.
*/


/** \brief E048, CPUx Safety Protection SPR Region Write Access Enable Register A4 */

/** Alias (User Manual Name) for CPU1_RGN4_ACCENA.
* To use register names with standard convension, please use CPU1_RGN4_ACCENA.
*/


/** \brief E04C, CPUx Safety Protection SPR Region Write Access Enable Register B4 */

/** Alias (User Manual Name) for CPU1_RGN4_ACCENB.
* To use register names with standard convension, please use CPU1_RGN4_ACCENB.
*/


/** \brief E050, CPUx Safety Protection SPR Region Lower Address Register 5 */

/** Alias (User Manual Name) for CPU1_RGN5_LA.
* To use register names with standard convension, please use CPU1_RGN5_LA.
*/


/** \brief E054, CPUx Safety Protection SPR Region Upper Address Register 5 */

/** Alias (User Manual Name) for CPU1_RGN5_UA.
* To use register names with standard convension, please use CPU1_RGN5_UA.
*/


/** \brief E058, CPUx Safety Protection SPR Region Write Access Enable Register A5 */

/** Alias (User Manual Name) for CPU1_RGN5_ACCENA.
* To use register names with standard convension, please use CPU1_RGN5_ACCENA.
*/


/** \brief E05C, CPUx Safety Protection SPR Region Write Access Enable Register B5 */

/** Alias (User Manual Name) for CPU1_RGN5_ACCENB.
* To use register names with standard convension, please use CPU1_RGN5_ACCENB.
*/


/** \brief E060, CPUx Safety Protection SPR Region Lower Address Register 6 */

/** Alias (User Manual Name) for CPU1_RGN6_LA.
* To use register names with standard convension, please use CPU1_RGN6_LA.
*/


/** \brief E064, CPUx Safety Protection SPR Region Upper Address Register 6 */

/** Alias (User Manual Name) for CPU1_RGN6_UA.
* To use register names with standard convension, please use CPU1_RGN6_UA.
*/


/** \brief E068, CPUx Safety Protection SPR Region Write Access Enable Register A6 */

/** Alias (User Manual Name) for CPU1_RGN6_ACCENA.
* To use register names with standard convension, please use CPU1_RGN6_ACCENA.
*/


/** \brief E06C, CPUx Safety Protection SPR Region Write Access Enable Register B6 */

/** Alias (User Manual Name) for CPU1_RGN6_ACCENB.
* To use register names with standard convension, please use CPU1_RGN6_ACCENB.
*/


/** \brief E070, CPUx Safety Protection SPR Region Lower Address Register 7 */

/** Alias (User Manual Name) for CPU1_RGN7_LA.
* To use register names with standard convension, please use CPU1_RGN7_LA.
*/


/** \brief E074, CPUx Safety Protection SPR Region Upper Address Register 7 */

/** Alias (User Manual Name) for CPU1_RGN7_UA.
* To use register names with standard convension, please use CPU1_RGN7_UA.
*/


/** \brief E078, CPUx Safety Protection SPR Region Write Access Enable Register A7 */

/** Alias (User Manual Name) for CPU1_RGN7_ACCENA.
* To use register names with standard convension, please use CPU1_RGN7_ACCENA.
*/


/** \brief E07C, CPUx Safety Protection SPR Region Write Access Enable Register B7 */

/** Alias (User Manual Name) for CPU1_RGN7_ACCENB.
* To use register names with standard convension, please use CPU1_RGN7_ACCENB.
*/


/** \brief E088, CPUx Safety Protection SPR Region Read Access Enable Register A0 */

/** Alias (User Manual Name) for CPU1_SPR_SPROT_RGNACCENA_R0.
* To use register names with standard convension, please use CPU1_SPR_SPROT_RGNACCENA_R0.
*/


/** \brief E08C, CPUx Safety Protection SPR Region Read Access Enable Register B0 */

/** Alias (User Manual Name) for CPU1_SPR_SPROT_RGNACCENB_R0.
* To use register names with standard convension, please use CPU1_SPR_SPROT_RGNACCENB_R0.
*/


/** \brief E098, CPUx Safety Protection SPR Region Read Access Enable Register A1 */

/** Alias (User Manual Name) for CPU1_SPR_SPROT_RGNACCENA_R1.
* To use register names with standard convension, please use CPU1_SPR_SPROT_RGNACCENA_R1.
*/


/** \brief E09C, CPUx Safety Protection SPR Region Read Access Enable Register B1 */

/** Alias (User Manual Name) for CPU1_SPR_SPROT_RGNACCENB_R1.
* To use register names with standard convension, please use CPU1_SPR_SPROT_RGNACCENB_R1.
*/


/** \brief E0A8, CPUx Safety Protection SPR Region Read Access Enable Register A2 */

/** Alias (User Manual Name) for CPU1_SPR_SPROT_RGNACCENA_R2.
* To use register names with standard convension, please use CPU1_SPR_SPROT_RGNACCENA_R2.
*/


/** \brief E0AC, CPUx Safety Protection SPR Region Read Access Enable Register B2 */

/** Alias (User Manual Name) for CPU1_SPR_SPROT_RGNACCENB_R2.
* To use register names with standard convension, please use CPU1_SPR_SPROT_RGNACCENB_R2.
*/


/** \brief E0B8, CPUx Safety Protection SPR Region Read Access Enable Register A3 */

/** Alias (User Manual Name) for CPU1_SPR_SPROT_RGNACCENA_R3.
* To use register names with standard convension, please use CPU1_SPR_SPROT_RGNACCENA_R3.
*/


/** \brief E0BC, CPUx Safety Protection SPR Region Read Access Enable Register B3 */

/** Alias (User Manual Name) for CPU1_SPR_SPROT_RGNACCENB_R3.
* To use register names with standard convension, please use CPU1_SPR_SPROT_RGNACCENB_R3.
*/


/** \brief E0C8, CPUx Safety Protection SPR Region Read Access Enable Register A4 */

/** Alias (User Manual Name) for CPU1_SPR_SPROT_RGNACCENA_R4.
* To use register names with standard convension, please use CPU1_SPR_SPROT_RGNACCENA_R4.
*/


/** \brief E0CC, CPUx Safety Protection SPR Region Read Access Enable Register B4 */

/** Alias (User Manual Name) for CPU1_SPR_SPROT_RGNACCENB_R4.
* To use register names with standard convension, please use CPU1_SPR_SPROT_RGNACCENB_R4.
*/


/** \brief E0D8, CPUx Safety Protection SPR Region Read Access Enable Register A5 */

/** Alias (User Manual Name) for CPU1_SPR_SPROT_RGNACCENA_R5.
* To use register names with standard convension, please use CPU1_SPR_SPROT_RGNACCENA_R5.
*/


/** \brief E0DC, CPUx Safety Protection SPR Region Read Access Enable Register B5 */

/** Alias (User Manual Name) for CPU1_SPR_SPROT_RGNACCENB_R5.
* To use register names with standard convension, please use CPU1_SPR_SPROT_RGNACCENB_R5.
*/


/** \brief E0E8, CPUx Safety Protection SPR Region Read Access Enable Register A6 */

/** Alias (User Manual Name) for CPU1_SPR_SPROT_RGNACCENA_R6.
* To use register names with standard convension, please use CPU1_SPR_SPROT_RGNACCENA_R6.
*/


/** \brief E0EC, CPUx Safety Protection SPR Region Read Access Enable Register B6 */

/** Alias (User Manual Name) for CPU1_SPR_SPROT_RGNACCENB_R6.
* To use register names with standard convension, please use CPU1_SPR_SPROT_RGNACCENB_R6.
*/


/** \brief E0F8, CPUx Safety Protection SPR Region Read Access Enable Register A7 */

/** Alias (User Manual Name) for CPU1_SPR_SPROT_RGNACCENA_R7.
* To use register names with standard convension, please use CPU1_SPR_SPROT_RGNACCENA_R7.
*/


/** \brief E0FC, CPUx Safety Protection SPR Region Read Access Enable Register B7 */

/** Alias (User Manual Name) for CPU1_SPR_SPROT_RGNACCENB_R7.
* To use register names with standard convension, please use CPU1_SPR_SPROT_RGNACCENB_R7.
*/


/** \brief E100, CPUx Safety Protection Register Access Enable Register A */


/** \brief E104, CPUx Safety Protection Region Access Enable Register B */


/** \brief E110, CPUx Safety Protection Region LPB Read Access Enable Register A */


/** \brief E114, CPUx Safety Protection Region LPB Read Access Enable Register B */


/** \brief E200, CPUx Safety Protection DLMU Region Lower Address Register 0 */


/** \brief E204, CPUx Safety protection DLMU Region Upper Address Register 0 */


/** \brief E208, CPUx Safety Protection Region DLMU Write Access Enable Register A0 */

/** Alias (User Manual Name) for CPU1_DLMU_SPROT_RGNACCENA_W0.
* To use register names with standard convension, please use CPU1_DLMU_SPROT_RGNACCENA_W0.
*/


/** \brief E20C, CPUx Safety Protection Region DLMU Write Access Enable Register B0 */

/** Alias (User Manual Name) for CPU1_DLMU_SPROT_RGNACCENB_W0.
* To use register names with standard convension, please use CPU1_DLMU_SPROT_RGNACCENB_W0.
*/


/** \brief E210, CPUx Safety Protection DLMU Region Lower Address Register 1 */


/** \brief E214, CPUx Safety protection DLMU Region Upper Address Register 1 */


/** \brief E218, CPUx Safety Protection Region DLMU Write Access Enable Register A1 */

/** Alias (User Manual Name) for CPU1_DLMU_SPROT_RGNACCENA_W1.
* To use register names with standard convension, please use CPU1_DLMU_SPROT_RGNACCENA_W1.
*/


/** \brief E21C, CPUx Safety Protection Region DLMU Write Access Enable Register B1 */

/** Alias (User Manual Name) for CPU1_DLMU_SPROT_RGNACCENB_W1.
* To use register names with standard convension, please use CPU1_DLMU_SPROT_RGNACCENB_W1.
*/


/** \brief E220, CPUx Safety Protection DLMU Region Lower Address Register 2 */


/** \brief E224, CPUx Safety protection DLMU Region Upper Address Register 2 */


/** \brief E228, CPUx Safety Protection Region DLMU Write Access Enable Register A2 */

/** Alias (User Manual Name) for CPU1_DLMU_SPROT_RGNACCENA_W2.
* To use register names with standard convension, please use CPU1_DLMU_SPROT_RGNACCENA_W2.
*/


/** \brief E22C, CPUx Safety Protection Region DLMU Write Access Enable Register B2 */

/** Alias (User Manual Name) for CPU1_DLMU_SPROT_RGNACCENB_W2.
* To use register names with standard convension, please use CPU1_DLMU_SPROT_RGNACCENB_W2.
*/


/** \brief E230, CPUx Safety Protection DLMU Region Lower Address Register 3 */


/** \brief E234, CPUx Safety protection DLMU Region Upper Address Register 3 */


/** \brief E238, CPUx Safety Protection Region DLMU Write Access Enable Register A3 */

/** Alias (User Manual Name) for CPU1_DLMU_SPROT_RGNACCENA_W3.
* To use register names with standard convension, please use CPU1_DLMU_SPROT_RGNACCENA_W3.
*/


/** \brief E23C, CPUx Safety Protection Region DLMU Write Access Enable Register B3 */

/** Alias (User Manual Name) for CPU1_DLMU_SPROT_RGNACCENB_W3.
* To use register names with standard convension, please use CPU1_DLMU_SPROT_RGNACCENB_W3.
*/


/** \brief E240, CPUx Safety Protection DLMU Region Lower Address Register 4 */


/** \brief E244, CPUx Safety protection DLMU Region Upper Address Register 4 */


/** \brief E248, CPUx Safety Protection Region DLMU Write Access Enable Register A4 */

/** Alias (User Manual Name) for CPU1_DLMU_SPROT_RGNACCENA_W4.
* To use register names with standard convension, please use CPU1_DLMU_SPROT_RGNACCENA_W4.
*/


/** \brief E24C, CPUx Safety Protection Region DLMU Write Access Enable Register B4 */

/** Alias (User Manual Name) for CPU1_DLMU_SPROT_RGNACCENB_W4.
* To use register names with standard convension, please use CPU1_DLMU_SPROT_RGNACCENB_W4.
*/


/** \brief E250, CPUx Safety Protection DLMU Region Lower Address Register 5 */


/** \brief E254, CPUx Safety protection DLMU Region Upper Address Register 5 */


/** \brief E258, CPUx Safety Protection Region DLMU Write Access Enable Register A5 */

/** Alias (User Manual Name) for CPU1_DLMU_SPROT_RGNACCENA_W5.
* To use register names with standard convension, please use CPU1_DLMU_SPROT_RGNACCENA_W5.
*/


/** \brief E25C, CPUx Safety Protection Region DLMU Write Access Enable Register B5 */

/** Alias (User Manual Name) for CPU1_DLMU_SPROT_RGNACCENB_W5.
* To use register names with standard convension, please use CPU1_DLMU_SPROT_RGNACCENB_W5.
*/


/** \brief E260, CPUx Safety Protection DLMU Region Lower Address Register 6 */


/** \brief E264, CPUx Safety protection DLMU Region Upper Address Register 6 */


/** \brief E268, CPUx Safety Protection Region DLMU Write Access Enable Register A6 */

/** Alias (User Manual Name) for CPU1_DLMU_SPROT_RGNACCENA_W6.
* To use register names with standard convension, please use CPU1_DLMU_SPROT_RGNACCENA_W6.
*/


/** \brief E26C, CPUx Safety Protection Region DLMU Write Access Enable Register B6 */

/** Alias (User Manual Name) for CPU1_DLMU_SPROT_RGNACCENB_W6.
* To use register names with standard convension, please use CPU1_DLMU_SPROT_RGNACCENB_W6.
*/


/** \brief E270, CPUx Safety Protection DLMU Region Lower Address Register 7 */


/** \brief E274, CPUx Safety protection DLMU Region Upper Address Register 7 */


/** \brief E278, CPUx Safety Protection Region DLMU Write Access Enable Register A7 */

/** Alias (User Manual Name) for CPU1_DLMU_SPROT_RGNACCENA_W7.
* To use register names with standard convension, please use CPU1_DLMU_SPROT_RGNACCENA_W7.
*/


/** \brief E27C, CPUx Safety Protection Region DLMU Write Access Enable Register B7 */

/** Alias (User Manual Name) for CPU1_DLMU_SPROT_RGNACCENB_W7.
* To use register names with standard convension, please use CPU1_DLMU_SPROT_RGNACCENB_W7.
*/


/** \brief E288, CPUx Safety Protection Region DLMU Read Access Enable Register A0 */

/** Alias (User Manual Name) for CPU1_DLMU_SPROT_RGNACCENA_R0.
* To use register names with standard convension, please use CPU1_DLMU_SPROT_RGNACCENA_R0.
*/


/** \brief E28C, CPUx Safety Protection Region DLMU Read Access Enable Register B0 */

/** Alias (User Manual Name) for CPU1_DLMU_SPROT_RGNACCENB_R0.
* To use register names with standard convension, please use CPU1_DLMU_SPROT_RGNACCENB_R0.
*/


/** \brief E298, CPUx Safety Protection Region DLMU Read Access Enable Register A1 */

/** Alias (User Manual Name) for CPU1_DLMU_SPROT_RGNACCENA_R1.
* To use register names with standard convension, please use CPU1_DLMU_SPROT_RGNACCENA_R1.
*/


/** \brief E29C, CPUx Safety Protection Region DLMU Read Access Enable Register B1 */

/** Alias (User Manual Name) for CPU1_DLMU_SPROT_RGNACCENB_R1.
* To use register names with standard convension, please use CPU1_DLMU_SPROT_RGNACCENB_R1.
*/


/** \brief E2A8, CPUx Safety Protection Region DLMU Read Access Enable Register A2 */

/** Alias (User Manual Name) for CPU1_DLMU_SPROT_RGNACCENA_R2.
* To use register names with standard convension, please use CPU1_DLMU_SPROT_RGNACCENA_R2.
*/


/** \brief E2AC, CPUx Safety Protection Region DLMU Read Access Enable Register B2 */

/** Alias (User Manual Name) for CPU1_DLMU_SPROT_RGNACCENB_R2.
* To use register names with standard convension, please use CPU1_DLMU_SPROT_RGNACCENB_R2.
*/


/** \brief E2B8, CPUx Safety Protection Region DLMU Read Access Enable Register A3 */

/** Alias (User Manual Name) for CPU1_DLMU_SPROT_RGNACCENA_R3.
* To use register names with standard convension, please use CPU1_DLMU_SPROT_RGNACCENA_R3.
*/


/** \brief E2BC, CPUx Safety Protection Region DLMU Read Access Enable Register B3 */

/** Alias (User Manual Name) for CPU1_DLMU_SPROT_RGNACCENB_R3.
* To use register names with standard convension, please use CPU1_DLMU_SPROT_RGNACCENB_R3.
*/


/** \brief E2C8, CPUx Safety Protection Region DLMU Read Access Enable Register A4 */

/** Alias (User Manual Name) for CPU1_DLMU_SPROT_RGNACCENA_R4.
* To use register names with standard convension, please use CPU1_DLMU_SPROT_RGNACCENA_R4.
*/


/** \brief E2CC, CPUx Safety Protection Region DLMU Read Access Enable Register B4 */

/** Alias (User Manual Name) for CPU1_DLMU_SPROT_RGNACCENB_R4.
* To use register names with standard convension, please use CPU1_DLMU_SPROT_RGNACCENB_R4.
*/


/** \brief E2D8, CPUx Safety Protection Region DLMU Read Access Enable Register A5 */

/** Alias (User Manual Name) for CPU1_DLMU_SPROT_RGNACCENA_R5.
* To use register names with standard convension, please use CPU1_DLMU_SPROT_RGNACCENA_R5.
*/


/** \brief E2DC, CPUx Safety Protection Region DLMU Read Access Enable Register B5 */

/** Alias (User Manual Name) for CPU1_DLMU_SPROT_RGNACCENB_R5.
* To use register names with standard convension, please use CPU1_DLMU_SPROT_RGNACCENB_R5.
*/


/** \brief E2E8, CPUx Safety Protection Region DLMU Read Access Enable Register A6 */

/** Alias (User Manual Name) for CPU1_DLMU_SPROT_RGNACCENA_R6.
* To use register names with standard convension, please use CPU1_DLMU_SPROT_RGNACCENA_R6.
*/


/** \brief E2EC, CPUx Safety Protection Region DLMU Read Access Enable Register B6 */

/** Alias (User Manual Name) for CPU1_DLMU_SPROT_RGNACCENB_R6.
* To use register names with standard convension, please use CPU1_DLMU_SPROT_RGNACCENB_R6.
*/


/** \brief E2F8, CPUx Safety Protection Region DLMU Read Access Enable Register A7 */

/** Alias (User Manual Name) for CPU1_DLMU_SPROT_RGNACCENA_R7.
* To use register names with standard convension, please use CPU1_DLMU_SPROT_RGNACCENA_R7.
*/


/** \brief E2FC, CPUx Safety Protection Region DLMU Read Access Enable Register B7 */

/** Alias (User Manual Name) for CPU1_DLMU_SPROT_RGNACCENB_R7.
* To use register names with standard convension, please use CPU1_DLMU_SPROT_RGNACCENB_R7.
*/


/** \brief FB00, CPUx  Overlay Range Select Register */


/** \brief FB10, CPUx Redirected Address Base Register 0 */

/** Alias (User Manual Name) for CPU1_BLK0_RABR.
* To use register names with standard convension, please use CPU1_BLK0_RABR.
*/


/** \brief FB14, CPUx Overlay Target Address Register 0 */

/** Alias (User Manual Name) for CPU1_BLK0_OTAR.
* To use register names with standard convension, please use CPU1_BLK0_OTAR.
*/


/** \brief FB18, CPUx Overlay Mask Register 0 */

/** Alias (User Manual Name) for CPU1_BLK0_OMASK.
* To use register names with standard convension, please use CPU1_BLK0_OMASK.
*/


/** \brief FB1C, CPUx Redirected Address Base Register 1 */

/** Alias (User Manual Name) for CPU1_BLK1_RABR.
* To use register names with standard convension, please use CPU1_BLK1_RABR.
*/


/** \brief FB20, CPUx Overlay Target Address Register 1 */

/** Alias (User Manual Name) for CPU1_BLK1_OTAR.
* To use register names with standard convension, please use CPU1_BLK1_OTAR.
*/


/** \brief FB24, CPUx Overlay Mask Register 1 */

/** Alias (User Manual Name) for CPU1_BLK1_OMASK.
* To use register names with standard convension, please use CPU1_BLK1_OMASK.
*/


/** \brief FB28, CPUx Redirected Address Base Register 2 */

/** Alias (User Manual Name) for CPU1_BLK2_RABR.
* To use register names with standard convension, please use CPU1_BLK2_RABR.
*/


/** \brief FB2C, CPUx Overlay Target Address Register 2 */

/** Alias (User Manual Name) for CPU1_BLK2_OTAR.
* To use register names with standard convension, please use CPU1_BLK2_OTAR.
*/


/** \brief FB30, CPUx Overlay Mask Register 2 */

/** Alias (User Manual Name) for CPU1_BLK2_OMASK.
* To use register names with standard convension, please use CPU1_BLK2_OMASK.
*/


/** \brief FB34, CPUx Redirected Address Base Register 3 */

/** Alias (User Manual Name) for CPU1_BLK3_RABR.
* To use register names with standard convension, please use CPU1_BLK3_RABR.
*/


/** \brief FB38, CPUx Overlay Target Address Register 3 */

/** Alias (User Manual Name) for CPU1_BLK3_OTAR.
* To use register names with standard convension, please use CPU1_BLK3_OTAR.
*/


/** \brief FB3C, CPUx Overlay Mask Register 3 */

/** Alias (User Manual Name) for CPU1_BLK3_OMASK.
* To use register names with standard convension, please use CPU1_BLK3_OMASK.
*/


/** \brief FB40, CPUx Redirected Address Base Register 4 */

/** Alias (User Manual Name) for CPU1_BLK4_RABR.
* To use register names with standard convension, please use CPU1_BLK4_RABR.
*/


/** \brief FB44, CPUx Overlay Target Address Register 4 */

/** Alias (User Manual Name) for CPU1_BLK4_OTAR.
* To use register names with standard convension, please use CPU1_BLK4_OTAR.
*/


/** \brief FB48, CPUx Overlay Mask Register 4 */

/** Alias (User Manual Name) for CPU1_BLK4_OMASK.
* To use register names with standard convension, please use CPU1_BLK4_OMASK.
*/


/** \brief FB4C, CPUx Redirected Address Base Register 5 */

/** Alias (User Manual Name) for CPU1_BLK5_RABR.
* To use register names with standard convension, please use CPU1_BLK5_RABR.
*/


/** \brief FB50, CPUx Overlay Target Address Register 5 */

/** Alias (User Manual Name) for CPU1_BLK5_OTAR.
* To use register names with standard convension, please use CPU1_BLK5_OTAR.
*/


/** \brief FB54, CPUx Overlay Mask Register 5 */

/** Alias (User Manual Name) for CPU1_BLK5_OMASK.
* To use register names with standard convension, please use CPU1_BLK5_OMASK.
*/


/** \brief FB58, CPUx Redirected Address Base Register 6 */

/** Alias (User Manual Name) for CPU1_BLK6_RABR.
* To use register names with standard convension, please use CPU1_BLK6_RABR.
*/


/** \brief FB5C, CPUx Overlay Target Address Register 6 */

/** Alias (User Manual Name) for CPU1_BLK6_OTAR.
* To use register names with standard convension, please use CPU1_BLK6_OTAR.
*/


/** \brief FB60, CPUx Overlay Mask Register 6 */

/** Alias (User Manual Name) for CPU1_BLK6_OMASK.
* To use register names with standard convension, please use CPU1_BLK6_OMASK.
*/


/** \brief FB64, CPUx Redirected Address Base Register 7 */

/** Alias (User Manual Name) for CPU1_BLK7_RABR.
* To use register names with standard convension, please use CPU1_BLK7_RABR.
*/


/** \brief FB68, CPUx Overlay Target Address Register 7 */

/** Alias (User Manual Name) for CPU1_BLK7_OTAR.
* To use register names with standard convension, please use CPU1_BLK7_OTAR.
*/


/** \brief FB6C, CPUx Overlay Mask Register 7 */

/** Alias (User Manual Name) for CPU1_BLK7_OMASK.
* To use register names with standard convension, please use CPU1_BLK7_OMASK.
*/


/** \brief FB70, CPUx Redirected Address Base Register 8 */

/** Alias (User Manual Name) for CPU1_BLK8_RABR.
* To use register names with standard convension, please use CPU1_BLK8_RABR.
*/


/** \brief FB74, CPUx Overlay Target Address Register 8 */

/** Alias (User Manual Name) for CPU1_BLK8_OTAR.
* To use register names with standard convension, please use CPU1_BLK8_OTAR.
*/


/** \brief FB78, CPUx Overlay Mask Register 8 */

/** Alias (User Manual Name) for CPU1_BLK8_OMASK.
* To use register names with standard convension, please use CPU1_BLK8_OMASK.
*/


/** \brief FB7C, CPUx Redirected Address Base Register 9 */

/** Alias (User Manual Name) for CPU1_BLK9_RABR.
* To use register names with standard convension, please use CPU1_BLK9_RABR.
*/


/** \brief FB80, CPUx Overlay Target Address Register 9 */

/** Alias (User Manual Name) for CPU1_BLK9_OTAR.
* To use register names with standard convension, please use CPU1_BLK9_OTAR.
*/


/** \brief FB84, CPUx Overlay Mask Register 9 */

/** Alias (User Manual Name) for CPU1_BLK9_OMASK.
* To use register names with standard convension, please use CPU1_BLK9_OMASK.
*/


/** \brief FB88, CPUx Redirected Address Base Register 10 */

/** Alias (User Manual Name) for CPU1_BLK10_RABR.
* To use register names with standard convension, please use CPU1_BLK10_RABR.
*/


/** \brief FB8C, CPUx Overlay Target Address Register 10 */

/** Alias (User Manual Name) for CPU1_BLK10_OTAR.
* To use register names with standard convension, please use CPU1_BLK10_OTAR.
*/


/** \brief FB90, CPUx Overlay Mask Register 10 */

/** Alias (User Manual Name) for CPU1_BLK10_OMASK.
* To use register names with standard convension, please use CPU1_BLK10_OMASK.
*/


/** \brief FB94, CPUx Redirected Address Base Register 11 */

/** Alias (User Manual Name) for CPU1_BLK11_RABR.
* To use register names with standard convension, please use CPU1_BLK11_RABR.
*/


/** \brief FB98, CPUx Overlay Target Address Register 11 */

/** Alias (User Manual Name) for CPU1_BLK11_OTAR.
* To use register names with standard convension, please use CPU1_BLK11_OTAR.
*/


/** \brief FB9C, CPUx Overlay Mask Register 11 */

/** Alias (User Manual Name) for CPU1_BLK11_OMASK.
* To use register names with standard convension, please use CPU1_BLK11_OMASK.
*/


/** \brief FBA0, CPUx Redirected Address Base Register 12 */

/** Alias (User Manual Name) for CPU1_BLK12_RABR.
* To use register names with standard convension, please use CPU1_BLK12_RABR.
*/


/** \brief FBA4, CPUx Overlay Target Address Register 12 */

/** Alias (User Manual Name) for CPU1_BLK12_OTAR.
* To use register names with standard convension, please use CPU1_BLK12_OTAR.
*/


/** \brief FBA8, CPUx Overlay Mask Register 12 */

/** Alias (User Manual Name) for CPU1_BLK12_OMASK.
* To use register names with standard convension, please use CPU1_BLK12_OMASK.
*/


/** \brief FBAC, CPUx Redirected Address Base Register 13 */

/** Alias (User Manual Name) for CPU1_BLK13_RABR.
* To use register names with standard convension, please use CPU1_BLK13_RABR.
*/


/** \brief FBB0, CPUx Overlay Target Address Register 13 */

/** Alias (User Manual Name) for CPU1_BLK13_OTAR.
* To use register names with standard convension, please use CPU1_BLK13_OTAR.
*/


/** \brief FBB4, CPUx Overlay Mask Register 13 */

/** Alias (User Manual Name) for CPU1_BLK13_OMASK.
* To use register names with standard convension, please use CPU1_BLK13_OMASK.
*/


/** \brief FBB8, CPUx Redirected Address Base Register 14 */

/** Alias (User Manual Name) for CPU1_BLK14_RABR.
* To use register names with standard convension, please use CPU1_BLK14_RABR.
*/


/** \brief FBBC, CPUx Overlay Target Address Register 14 */

/** Alias (User Manual Name) for CPU1_BLK14_OTAR.
* To use register names with standard convension, please use CPU1_BLK14_OTAR.
*/


/** \brief FBC0, CPUx Overlay Mask Register 14 */

/** Alias (User Manual Name) for CPU1_BLK14_OMASK.
* To use register names with standard convension, please use CPU1_BLK14_OMASK.
*/


/** \brief FBC4, CPUx Redirected Address Base Register 15 */

/** Alias (User Manual Name) for CPU1_BLK15_RABR.
* To use register names with standard convension, please use CPU1_BLK15_RABR.
*/


/** \brief FBC8, CPUx Overlay Target Address Register 15 */

/** Alias (User Manual Name) for CPU1_BLK15_OTAR.
* To use register names with standard convension, please use CPU1_BLK15_OTAR.
*/


/** \brief FBCC, CPUx Overlay Mask Register 15 */

/** Alias (User Manual Name) for CPU1_BLK15_OMASK.
* To use register names with standard convension, please use CPU1_BLK15_OMASK.
*/


/** \brief FBD0, CPUx Redirected Address Base Register 16 */

/** Alias (User Manual Name) for CPU1_BLK16_RABR.
* To use register names with standard convension, please use CPU1_BLK16_RABR.
*/


/** \brief FBD4, CPUx Overlay Target Address Register 16 */

/** Alias (User Manual Name) for CPU1_BLK16_OTAR.
* To use register names with standard convension, please use CPU1_BLK16_OTAR.
*/


/** \brief FBD8, CPUx Overlay Mask Register 16 */

/** Alias (User Manual Name) for CPU1_BLK16_OMASK.
* To use register names with standard convension, please use CPU1_BLK16_OMASK.
*/


/** \brief FBDC, CPUx Redirected Address Base Register 17 */

/** Alias (User Manual Name) for CPU1_BLK17_RABR.
* To use register names with standard convension, please use CPU1_BLK17_RABR.
*/


/** \brief FBE0, CPUx Overlay Target Address Register 17 */

/** Alias (User Manual Name) for CPU1_BLK17_OTAR.
* To use register names with standard convension, please use CPU1_BLK17_OTAR.
*/


/** \brief FBE4, CPUx Overlay Mask Register 17 */

/** Alias (User Manual Name) for CPU1_BLK17_OMASK.
* To use register names with standard convension, please use CPU1_BLK17_OMASK.
*/


/** \brief FBE8, CPUx Redirected Address Base Register 18 */

/** Alias (User Manual Name) for CPU1_BLK18_RABR.
* To use register names with standard convension, please use CPU1_BLK18_RABR.
*/


/** \brief FBEC, CPUx Overlay Target Address Register 18 */

/** Alias (User Manual Name) for CPU1_BLK18_OTAR.
* To use register names with standard convension, please use CPU1_BLK18_OTAR.
*/


/** \brief FBF0, CPUx Overlay Mask Register 18 */

/** Alias (User Manual Name) for CPU1_BLK18_OMASK.
* To use register names with standard convension, please use CPU1_BLK18_OMASK.
*/


/** \brief FBF4, CPUx Redirected Address Base Register 19 */

/** Alias (User Manual Name) for CPU1_BLK19_RABR.
* To use register names with standard convension, please use CPU1_BLK19_RABR.
*/


/** \brief FBF8, CPUx Overlay Target Address Register 19 */

/** Alias (User Manual Name) for CPU1_BLK19_OTAR.
* To use register names with standard convension, please use CPU1_BLK19_OTAR.
*/


/** \brief FBFC, CPUx Overlay Mask Register 19 */

/** Alias (User Manual Name) for CPU1_BLK19_OMASK.
* To use register names with standard convension, please use CPU1_BLK19_OMASK.
*/


/** \brief FC00, CPUx Redirected Address Base Register 20 */

/** Alias (User Manual Name) for CPU1_BLK20_RABR.
* To use register names with standard convension, please use CPU1_BLK20_RABR.
*/


/** \brief FC04, CPUx Overlay Target Address Register 20 */

/** Alias (User Manual Name) for CPU1_BLK20_OTAR.
* To use register names with standard convension, please use CPU1_BLK20_OTAR.
*/


/** \brief FC08, CPUx Overlay Mask Register 20 */

/** Alias (User Manual Name) for CPU1_BLK20_OMASK.
* To use register names with standard convension, please use CPU1_BLK20_OMASK.
*/


/** \brief FC0C, CPUx Redirected Address Base Register 21 */

/** Alias (User Manual Name) for CPU1_BLK21_RABR.
* To use register names with standard convension, please use CPU1_BLK21_RABR.
*/


/** \brief FC10, CPUx Overlay Target Address Register 21 */

/** Alias (User Manual Name) for CPU1_BLK21_OTAR.
* To use register names with standard convension, please use CPU1_BLK21_OTAR.
*/


/** \brief FC14, CPUx Overlay Mask Register 21 */

/** Alias (User Manual Name) for CPU1_BLK21_OMASK.
* To use register names with standard convension, please use CPU1_BLK21_OMASK.
*/


/** \brief FC18, CPUx Redirected Address Base Register 22 */

/** Alias (User Manual Name) for CPU1_BLK22_RABR.
* To use register names with standard convension, please use CPU1_BLK22_RABR.
*/


/** \brief FC1C, CPUx Overlay Target Address Register 22 */

/** Alias (User Manual Name) for CPU1_BLK22_OTAR.
* To use register names with standard convension, please use CPU1_BLK22_OTAR.
*/


/** \brief FC20, CPUx Overlay Mask Register 22 */

/** Alias (User Manual Name) for CPU1_BLK22_OMASK.
* To use register names with standard convension, please use CPU1_BLK22_OMASK.
*/


/** \brief FC24, CPUx Redirected Address Base Register 23 */

/** Alias (User Manual Name) for CPU1_BLK23_RABR.
* To use register names with standard convension, please use CPU1_BLK23_RABR.
*/


/** \brief FC28, CPUx Overlay Target Address Register 23 */

/** Alias (User Manual Name) for CPU1_BLK23_OTAR.
* To use register names with standard convension, please use CPU1_BLK23_OTAR.
*/


/** \brief FC2C, CPUx Overlay Mask Register 23 */

/** Alias (User Manual Name) for CPU1_BLK23_OMASK.
* To use register names with standard convension, please use CPU1_BLK23_OMASK.
*/


/** \brief FC30, CPUx Redirected Address Base Register 24 */

/** Alias (User Manual Name) for CPU1_BLK24_RABR.
* To use register names with standard convension, please use CPU1_BLK24_RABR.
*/


/** \brief FC34, CPUx Overlay Target Address Register 24 */

/** Alias (User Manual Name) for CPU1_BLK24_OTAR.
* To use register names with standard convension, please use CPU1_BLK24_OTAR.
*/


/** \brief FC38, CPUx Overlay Mask Register 24 */

/** Alias (User Manual Name) for CPU1_BLK24_OMASK.
* To use register names with standard convension, please use CPU1_BLK24_OMASK.
*/


/** \brief FC3C, CPUx Redirected Address Base Register 25 */

/** Alias (User Manual Name) for CPU1_BLK25_RABR.
* To use register names with standard convension, please use CPU1_BLK25_RABR.
*/


/** \brief FC40, CPUx Overlay Target Address Register 25 */

/** Alias (User Manual Name) for CPU1_BLK25_OTAR.
* To use register names with standard convension, please use CPU1_BLK25_OTAR.
*/


/** \brief FC44, CPUx Overlay Mask Register 25 */

/** Alias (User Manual Name) for CPU1_BLK25_OMASK.
* To use register names with standard convension, please use CPU1_BLK25_OMASK.
*/


/** \brief FC48, CPUx Redirected Address Base Register 26 */

/** Alias (User Manual Name) for CPU1_BLK26_RABR.
* To use register names with standard convension, please use CPU1_BLK26_RABR.
*/


/** \brief FC4C, CPUx Overlay Target Address Register 26 */

/** Alias (User Manual Name) for CPU1_BLK26_OTAR.
* To use register names with standard convension, please use CPU1_BLK26_OTAR.
*/


/** \brief FC50, CPUx Overlay Mask Register 26 */

/** Alias (User Manual Name) for CPU1_BLK26_OMASK.
* To use register names with standard convension, please use CPU1_BLK26_OMASK.
*/


/** \brief FC54, CPUx Redirected Address Base Register 27 */

/** Alias (User Manual Name) for CPU1_BLK27_RABR.
* To use register names with standard convension, please use CPU1_BLK27_RABR.
*/


/** \brief FC58, CPUx Overlay Target Address Register 27 */

/** Alias (User Manual Name) for CPU1_BLK27_OTAR.
* To use register names with standard convension, please use CPU1_BLK27_OTAR.
*/


/** \brief FC5C, CPUx Overlay Mask Register 27 */

/** Alias (User Manual Name) for CPU1_BLK27_OMASK.
* To use register names with standard convension, please use CPU1_BLK27_OMASK.
*/


/** \brief FC60, CPUx Redirected Address Base Register 28 */

/** Alias (User Manual Name) for CPU1_BLK28_RABR.
* To use register names with standard convension, please use CPU1_BLK28_RABR.
*/


/** \brief FC64, CPUx Overlay Target Address Register 28 */

/** Alias (User Manual Name) for CPU1_BLK28_OTAR.
* To use register names with standard convension, please use CPU1_BLK28_OTAR.
*/


/** \brief FC68, CPUx Overlay Mask Register 28 */

/** Alias (User Manual Name) for CPU1_BLK28_OMASK.
* To use register names with standard convension, please use CPU1_BLK28_OMASK.
*/


/** \brief FC6C, CPUx Redirected Address Base Register 29 */

/** Alias (User Manual Name) for CPU1_BLK29_RABR.
* To use register names with standard convension, please use CPU1_BLK29_RABR.
*/


/** \brief FC70, CPUx Overlay Target Address Register 29 */

/** Alias (User Manual Name) for CPU1_BLK29_OTAR.
* To use register names with standard convension, please use CPU1_BLK29_OTAR.
*/


/** \brief FC74, CPUx Overlay Mask Register 29 */

/** Alias (User Manual Name) for CPU1_BLK29_OMASK.
* To use register names with standard convension, please use CPU1_BLK29_OMASK.
*/


/** \brief FC78, CPUx Redirected Address Base Register 30 */

/** Alias (User Manual Name) for CPU1_BLK30_RABR.
* To use register names with standard convension, please use CPU1_BLK30_RABR.
*/


/** \brief FC7C, CPUx Overlay Target Address Register 30 */

/** Alias (User Manual Name) for CPU1_BLK30_OTAR.
* To use register names with standard convension, please use CPU1_BLK30_OTAR.
*/


/** \brief FC80, CPUx Overlay Mask Register 30 */

/** Alias (User Manual Name) for CPU1_BLK30_OMASK.
* To use register names with standard convension, please use CPU1_BLK30_OMASK.
*/


/** \brief FC84, CPUx Redirected Address Base Register 31 */

/** Alias (User Manual Name) for CPU1_BLK31_RABR.
* To use register names with standard convension, please use CPU1_BLK31_RABR.
*/


/** \brief FC88, CPUx Overlay Target Address Register 31 */

/** Alias (User Manual Name) for CPU1_BLK31_OTAR.
* To use register names with standard convension, please use CPU1_BLK31_OTAR.
*/


/** \brief FC8C, CPUx Overlay Mask Register 31 */

/** Alias (User Manual Name) for CPU1_BLK31_OMASK.
* To use register names with standard convension, please use CPU1_BLK31_OMASK.
*/


/** \brief 1030, CPUx SRI Error Generation Register */


/** \brief 8004, CPUx Task Address Space Identifier Register */


/** \brief 8100, CPUx Data Access CacheabilityRegister */


/** \brief 8104, CPUx Code Access CacheabilityRegister */


/** \brief 8108, CPUx  Peripheral Space Identifier register */


/** \brief 9000, CPUx Data Control Register 2 */


/** \brief 900C, CPUx SIST Mode Access Control Register */


/** \brief 9010, CPUx Data Synchronous Trap Register */


/** \brief 9018, CPUx Data Asynchronous Trap Register */


/** \brief 901C, CPUx Data Error Address Register */


/** \brief 9020, CPUx Data Integrity Error Address Register */


/** \brief 9024, CPUx Data Integrity Error Trap Register */


/** \brief 9040, CPUx Data Memory Control Register */


/** \brief 9200, CPUx Program Synchronous Trap Register */


/** \brief 9204, CPUx Program Control 1 */


/** \brief 9208, CPUx Program Control 2 */


/** \brief 920C, CPUx Program Control 0 */


/** \brief 9210, CPUx Program Integrity Error Address Register */


/** \brief 9214, CPUx Program Integrity Error Trap Register */


/** \brief 9400, CPUx Compatibility Control Register */


/** \brief A000, CPUx Trap Control Register */


/** \brief A004, CPUx Trapping Instruction Program Counter Register */


/** \brief A008, CPUx Trapping Instruction Opcode Register */


/** \brief A010, CPUx Trapping Instruction Operand Register */


/** \brief A014, CPUx Trapping Instruction Operand Register */


/** \brief A018, CPUx Trapping Instruction Operand Register */


/** \brief C000, CPUx Data Protection Range 0, Lower Bound Register */


/** \brief C004, CPUx Data Protection Range 0, Upper Bound Register */


/** \brief C008, CPUx Data Protection Range 1, Lower Bound Register */


/** \brief C00C, CPUx Data Protection Range 1, Upper Bound Register */


/** \brief C010, CPUx Data Protection Range 2, Lower Bound Register */


/** \brief C014, CPUx Data Protection Range 2, Upper Bound Register */


/** \brief C018, CPUx Data Protection Range 3, Lower Bound Register */


/** \brief C01C, CPUx Data Protection Range 3, Upper Bound Register */


/** \brief C020, CPUx Data Protection Range 4, Lower Bound Register */


/** \brief C024, CPUx Data Protection Range 4, Upper Bound Register */


/** \brief C028, CPUx Data Protection Range 5, Lower Bound Register */


/** \brief C02C, CPUx Data Protection Range 5, Upper Bound Register */


/** \brief C030, CPUx Data Protection Range 6, Lower Bound Register */


/** \brief C034, CPUx Data Protection Range 6, Upper Bound Register */


/** \brief C038, CPUx Data Protection Range 7, Lower Bound Register */


/** \brief C03C, CPUx Data Protection Range 7, Upper Bound Register */


/** \brief C040, CPUx Data Protection Range 8, Lower Bound Register */


/** \brief C044, CPUx Data Protection Range 8, Upper Bound Register */


/** \brief C048, CPUx Data Protection Range 9, Lower Bound Register */


/** \brief C04C, CPUx Data Protection Range 9, Upper Bound Register */


/** \brief C050, CPUx Data Protection Range 10, Lower Bound Register */


/** \brief C054, CPUx Data Protection Range 10, Upper Bound Register */


/** \brief C058, CPUx Data Protection Range 11, Lower Bound Register */


/** \brief C05C, CPUx Data Protection Range 11, Upper Bound Register */


/** \brief C060, CPUx Data Protection Range 12, Lower Bound Register */


/** \brief C064, CPUx Data Protection Range 12, Upper Bound Register */


/** \brief C068, CPUx Data Protection Range 13, Lower Bound Register */


/** \brief C06C, CPUx Data Protection Range 13, Upper Bound Register */


/** \brief C070, CPUx Data Protection Range 14, Lower Bound Register */


/** \brief C074, CPUx Data Protection Range 14, Upper Bound Register */


/** \brief C078, CPUx Data Protection Range 15, Lower Bound Register */


/** \brief C07C, CPUx Data Protection Range 15, Upper Bound Register */


/** \brief C080, CPUx Data Protection Range 16, Lower Bound Register */


/** \brief C084, CPUx Data Protection Range 16, Upper Bound Register */


/** \brief C088, CPUx Data Protection Range 17, Lower Bound Register */


/** \brief C08C, CPUx Data Protection Range 17, Upper Bound Register */


/** \brief D000, CPUx Code Protection Range 0 Lower Bound Register */


/** \brief D004, CPUx Code Protection Range 0 Upper Bound Register */


/** \brief D008, CPUx Code Protection Range 1 Lower Bound Register */


/** \brief D00C, CPUx Code Protection Range 1 Upper Bound Register */


/** \brief D010, CPUx Code Protection Range 2 Lower Bound Register */


/** \brief D014, CPUx Code Protection Range 2 Upper Bound Register */


/** \brief D018, CPUx Code Protection Range 3 Lower Bound Register */


/** \brief D01C, CPUx Code Protection Range 3 Upper Bound Register */


/** \brief D020, CPUx Code Protection Range 4 Lower Bound Register */


/** \brief D024, CPUx Code Protection Range 4 Upper Bound Register */


/** \brief D028, CPUx Code Protection Range 5 Lower Bound Register */


/** \brief D02C, CPUx Code Protection Range 5 Upper Bound Register */


/** \brief D030, CPUx Code Protection Range 6 Lower Bound Register */


/** \brief D034, CPUx Code Protection Range 6 Upper Bound Register */


/** \brief D038, CPUx Code Protection Range 7 Lower Bound Register */


/** \brief D03C, CPUx Code Protection Range 7 Upper Bound Register */


/** \brief D040, CPUx Code Protection Range 8 Lower Bound Register */


/** \brief D044, CPUx Code Protection Range 8 Upper Bound Register */


/** \brief D048, CPUx Code Protection Range 9 Lower Bound Register */


/** \brief D04C, CPUx Code Protection Range 9 Upper Bound Register */


/** \brief E000, CPUx Code Protection Execute Enable Register Set 0 */


/** \brief E004, CPUx Code Protection Execute Enable Register Set 1 */


/** \brief E008, CPUx Code Protection Execute Enable Register Set 2 */


/** \brief E00C, CPUx Code Protection Execute Enable Register Set 3 */


/** \brief E010, CPUx Data Protection Read Enable Register Set 0 */


/** \brief E014, CPUx Data Protection Read Enable Register Set 1 */


/** \brief E018, CPUx Data Protection Read Enable Register Set 2 */


/** \brief E01C, CPUx Data Protection Read Enable Register Set 3 */


/** \brief E020, CPUx Data Protection Write Enable Register Set 0 */


/** \brief E024, CPUx Data Protection Write Enable Register Set 1 */


/** \brief E028, CPUx Data Protection Write Enable Register Set 2 */


/** \brief E02C, CPUx Data Protection Write Enable Register Set 3 */


/** \brief E040, CPUx Code Protection Execute Enable Register Set 4 */


/** \brief E044, CPUx Code Protection Execute Enable Register Set 5 */


/** \brief E050, CPUx Data Protection Read Enable Register Set 4 */


/** \brief E054, CPUx Data Protection Read Enable Register Set 5 */


/** \brief E060, CPUx Data Protection Write Enable Register Set 4 */


/** \brief E064, CPUx Data Protection Write Enable Register Set 5 */


/** \brief E400, CPUx Temporal Protection System Control Register */


/** \brief E404, CPUx Temporal Protection System Timer Register 0 */


/** \brief E408, CPUx Temporal Protection System Timer Register 1 */


/** \brief E40C, CPUx Temporal Protection System Timer Register 2 */


/** \brief E440, CPUx Exception Entry Timer Load Value */


/** \brief E444, CPUx Exception Entry Timer Current Value */


/** \brief E448, CPUx Exception Exit  Timer Load Value */


/** \brief E44C, CPUx Exception Exit Timer Current Value */


/** \brief E450, CPUx Exception Timer Class Enable Register */


/** \brief E454, CPUx Exception Timer Status Register */


/** \brief E458, CPUx Exception Timer FCX Register */


/** \brief F000, CPUx Trigger Event 0 */

/** Alias (User Manual Name) for CPU1_TR0_EVT.
* To use register names with standard convension, please use CPU1_TR0_EVT.
*/


/** \brief F004, CPUx Trigger Address 0 */

/** Alias (User Manual Name) for CPU1_TR0_ADR.
* To use register names with standard convension, please use CPU1_TR0_ADR.
*/


/** \brief F008, CPUx Trigger Event 1 */

/** Alias (User Manual Name) for CPU1_TR1_EVT.
* To use register names with standard convension, please use CPU1_TR1_EVT.
*/


/** \brief F00C, CPUx Trigger Address 1 */

/** Alias (User Manual Name) for CPU1_TR1_ADR.
* To use register names with standard convension, please use CPU1_TR1_ADR.
*/


/** \brief F010, CPUx Trigger Event 2 */

/** Alias (User Manual Name) for CPU1_TR2_EVT.
* To use register names with standard convension, please use CPU1_TR2_EVT.
*/


/** \brief F014, CPUx Trigger Address 2 */

/** Alias (User Manual Name) for CPU1_TR2_ADR.
* To use register names with standard convension, please use CPU1_TR2_ADR.
*/


/** \brief F018, CPUx Trigger Event 3 */

/** Alias (User Manual Name) for CPU1_TR3_EVT.
* To use register names with standard convension, please use CPU1_TR3_EVT.
*/


/** \brief F01C, CPUx Trigger Address 3 */

/** Alias (User Manual Name) for CPU1_TR3_ADR.
* To use register names with standard convension, please use CPU1_TR3_ADR.
*/


/** \brief F020, CPUx Trigger Event 4 */

/** Alias (User Manual Name) for CPU1_TR4_EVT.
* To use register names with standard convension, please use CPU1_TR4_EVT.
*/


/** \brief F024, CPUx Trigger Address 4 */

/** Alias (User Manual Name) for CPU1_TR4_ADR.
* To use register names with standard convension, please use CPU1_TR4_ADR.
*/


/** \brief F028, CPUx Trigger Event 5 */

/** Alias (User Manual Name) for CPU1_TR5_EVT.
* To use register names with standard convension, please use CPU1_TR5_EVT.
*/


/** \brief F02C, CPUx Trigger Address 5 */

/** Alias (User Manual Name) for CPU1_TR5_ADR.
* To use register names with standard convension, please use CPU1_TR5_ADR.
*/


/** \brief F030, CPUx Trigger Event 6 */

/** Alias (User Manual Name) for CPU1_TR6_EVT.
* To use register names with standard convension, please use CPU1_TR6_EVT.
*/


/** \brief F034, CPUx Trigger Address 6 */

/** Alias (User Manual Name) for CPU1_TR6_ADR.
* To use register names with standard convension, please use CPU1_TR6_ADR.
*/


/** \brief F038, CPUx Trigger Event 7 */

/** Alias (User Manual Name) for CPU1_TR7_EVT.
* To use register names with standard convension, please use CPU1_TR7_EVT.
*/


/** \brief F03C, CPUx Trigger Address 7 */

/** Alias (User Manual Name) for CPU1_TR7_ADR.
* To use register names with standard convension, please use CPU1_TR7_ADR.
*/


/** \brief FC00, CPUx Counter Control */


/** \brief FC04, CPUx CPU Clock Cycle Count */


/** \brief FC08, CPUx Instruction Count */


/** \brief FC0C, CPUx Multi-Count Register 1 */


/** \brief FC10, CPUx Multi-Count Register 2 */


/** \brief FC14, CPUx Multi-Count Register 3 */


/** \brief FD00, CPUx Debug Status Register */


/** \brief FD08, CPUx External Event Register */


/** \brief FD0C, CPUx Core Register Access Event */


/** \brief FD10, CPUx Software Debug Event */


/** \brief FD30, CPUx TriggerAddressx */


/** \brief FD40, CPUx Debug Monitor Start Address */


/** \brief FD44, CPUx Debug Context Save Area Pointer */


/** \brief FD48, CPUx Debug Trap Control Register */


/** \brief FE00, CPUx Previous Context Information Register */


/** \brief FE04, CPUx Program Status Word */


/** \brief FE08, CPUx Program Counter */


/** \brief FE14, CPUx System Configuration Register */


/** \brief FE18, CPUx Identification Register TC1.6.2P */


/** \brief FE1C, CPUx Core Identification Register */


/** \brief FE20, CPUx Base Interrupt Vector Table Pointer */


/** \brief FE24, CPUx Base Trap Vector Table Pointer */


/** \brief FE28, CPUx Interrupt Stack Pointer */


/** \brief FE2C, CPUx Interrupt Control Register */


/** \brief FE38, CPUx Free CSA List Head Pointer */


/** \brief FE3C, CPUx Free CSA List Limit Pointer */


/** \brief FE50, CPUx Customer ID register */


/** \brief FF00, CPUx Data General Purpose Register 0 */


/** \brief FF04, CPUx Data General Purpose Register 1 */


/** \brief FF08, CPUx Data General Purpose Register 2 */


/** \brief FF0C, CPUx Data General Purpose Register 3 */


/** \brief FF10, CPUx Data General Purpose Register 4 */


/** \brief FF14, CPUx Data General Purpose Register 5 */


/** \brief FF18, CPUx Data General Purpose Register 6 */


/** \brief FF1C, CPUx Data General Purpose Register 7 */


/** \brief FF20, CPUx Data General Purpose Register 8 */


/** \brief FF24, CPUx Data General Purpose Register 9 */


/** \brief FF28, CPUx Data General Purpose Register 10 */


/** \brief FF2C, CPUx Data General Purpose Register 11 */


/** \brief FF30, CPUx Data General Purpose Register 12 */


/** \brief FF34, CPUx Data General Purpose Register 13 */


/** \brief FF38, CPUx Data General Purpose Register 14 */


/** \brief FF3C, CPUx Data General Purpose Register 15 */


/** \brief FF80, CPUx Address General Purpose Register 0 */


/** \brief FF84, CPUx Address General Purpose Register 1 */


/** \brief FF88, CPUx Address General Purpose Register 2 */


/** \brief FF8C, CPUx Address General Purpose Register 3 */


/** \brief FF90, CPUx Address General Purpose Register 4 */


/** \brief FF94, CPUx Address General Purpose Register 5 */


/** \brief FF98, CPUx Address General Purpose Register 6 */


/** \brief FF9C, CPUx Address General Purpose Register 7 */


/** \brief FFA0, CPUx Address General Purpose Register 8 */


/** \brief FFA4, CPUx Address General Purpose Register 9 */


/** \brief FFA8, CPUx Address General Purpose Register 10 */


/** \brief FFAC, CPUx Address General Purpose Register 11 */


/** \brief FFB0, CPUx Address General Purpose Register 12 */


/** \brief FFB4, CPUx Address General Purpose Register 13 */


/** \brief FFB8, CPUx Address General Purpose Register 14 */


/** \brief FFBC, CPUx Address General Purpose Register 15 */


/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Cpu_Registers_Cfg_Cpu2
 * \{  */
/** \brief 1100, CPUx Flash Configuration Register 0 */


/** \brief 1104, CPUx Flash Configuration Register 1 */


/** \brief 1108, CPUx Flash Configuration Register 2 */


/** \brief 110C, CPUx Flash Configuration Register 3 */


/** \brief 1110, CPUx Flash Configuration Register 4 */


/** \brief D000, CPUx  Reset Register 0 */


/** \brief D004, CPUx  Reset Register 1 */


/** \brief D008, CPUx Reset Clear Register */


/** \brief E000, CPUx Safety Protection SPR Region Lower Address Register 0 */

/** Alias (User Manual Name) for CPU2_RGN0_LA.
* To use register names with standard convension, please use CPU2_RGN0_LA.
*/


/** \brief E004, CPUx Safety Protection SPR Region Upper Address Register 0 */

/** Alias (User Manual Name) for CPU2_RGN0_UA.
* To use register names with standard convension, please use CPU2_RGN0_UA.
*/


/** \brief E008, CPUx Safety Protection SPR Region Write Access Enable Register A0 */

/** Alias (User Manual Name) for CPU2_RGN0_ACCENA.
* To use register names with standard convension, please use CPU2_RGN0_ACCENA.
*/


/** \brief E00C, CPUx Safety Protection SPR Region Write Access Enable Register B0 */

/** Alias (User Manual Name) for CPU2_RGN0_ACCENB.
* To use register names with standard convension, please use CPU2_RGN0_ACCENB.
*/


/** \brief E010, CPUx Safety Protection SPR Region Lower Address Register 1 */

/** Alias (User Manual Name) for CPU2_RGN1_LA.
* To use register names with standard convension, please use CPU2_RGN1_LA.
*/


/** \brief E014, CPUx Safety Protection SPR Region Upper Address Register 1 */

/** Alias (User Manual Name) for CPU2_RGN1_UA.
* To use register names with standard convension, please use CPU2_RGN1_UA.
*/


/** \brief E018, CPUx Safety Protection SPR Region Write Access Enable Register A1 */

/** Alias (User Manual Name) for CPU2_RGN1_ACCENA.
* To use register names with standard convension, please use CPU2_RGN1_ACCENA.
*/


/** \brief E01C, CPUx Safety Protection SPR Region Write Access Enable Register B1 */

/** Alias (User Manual Name) for CPU2_RGN1_ACCENB.
* To use register names with standard convension, please use CPU2_RGN1_ACCENB.
*/


/** \brief E020, CPUx Safety Protection SPR Region Lower Address Register 2 */

/** Alias (User Manual Name) for CPU2_RGN2_LA.
* To use register names with standard convension, please use CPU2_RGN2_LA.
*/


/** \brief E024, CPUx Safety Protection SPR Region Upper Address Register 2 */

/** Alias (User Manual Name) for CPU2_RGN2_UA.
* To use register names with standard convension, please use CPU2_RGN2_UA.
*/


/** \brief E028, CPUx Safety Protection SPR Region Write Access Enable Register A2 */

/** Alias (User Manual Name) for CPU2_RGN2_ACCENA.
* To use register names with standard convension, please use CPU2_RGN2_ACCENA.
*/


/** \brief E02C, CPUx Safety Protection SPR Region Write Access Enable Register B2 */

/** Alias (User Manual Name) for CPU2_RGN2_ACCENB.
* To use register names with standard convension, please use CPU2_RGN2_ACCENB.
*/


/** \brief E030, CPUx Safety Protection SPR Region Lower Address Register 3 */

/** Alias (User Manual Name) for CPU2_RGN3_LA.
* To use register names with standard convension, please use CPU2_RGN3_LA.
*/


/** \brief E034, CPUx Safety Protection SPR Region Upper Address Register 3 */

/** Alias (User Manual Name) for CPU2_RGN3_UA.
* To use register names with standard convension, please use CPU2_RGN3_UA.
*/


/** \brief E038, CPUx Safety Protection SPR Region Write Access Enable Register A3 */

/** Alias (User Manual Name) for CPU2_RGN3_ACCENA.
* To use register names with standard convension, please use CPU2_RGN3_ACCENA.
*/


/** \brief E03C, CPUx Safety Protection SPR Region Write Access Enable Register B3 */

/** Alias (User Manual Name) for CPU2_RGN3_ACCENB.
* To use register names with standard convension, please use CPU2_RGN3_ACCENB.
*/


/** \brief E040, CPUx Safety Protection SPR Region Lower Address Register 4 */

/** Alias (User Manual Name) for CPU2_RGN4_LA.
* To use register names with standard convension, please use CPU2_RGN4_LA.
*/


/** \brief E044, CPUx Safety Protection SPR Region Upper Address Register 4 */

/** Alias (User Manual Name) for CPU2_RGN4_UA.
* To use register names with standard convension, please use CPU2_RGN4_UA.
*/


/** \brief E048, CPUx Safety Protection SPR Region Write Access Enable Register A4 */

/** Alias (User Manual Name) for CPU2_RGN4_ACCENA.
* To use register names with standard convension, please use CPU2_RGN4_ACCENA.
*/


/** \brief E04C, CPUx Safety Protection SPR Region Write Access Enable Register B4 */

/** Alias (User Manual Name) for CPU2_RGN4_ACCENB.
* To use register names with standard convension, please use CPU2_RGN4_ACCENB.
*/


/** \brief E050, CPUx Safety Protection SPR Region Lower Address Register 5 */

/** Alias (User Manual Name) for CPU2_RGN5_LA.
* To use register names with standard convension, please use CPU2_RGN5_LA.
*/


/** \brief E054, CPUx Safety Protection SPR Region Upper Address Register 5 */

/** Alias (User Manual Name) for CPU2_RGN5_UA.
* To use register names with standard convension, please use CPU2_RGN5_UA.
*/


/** \brief E058, CPUx Safety Protection SPR Region Write Access Enable Register A5 */

/** Alias (User Manual Name) for CPU2_RGN5_ACCENA.
* To use register names with standard convension, please use CPU2_RGN5_ACCENA.
*/


/** \brief E05C, CPUx Safety Protection SPR Region Write Access Enable Register B5 */

/** Alias (User Manual Name) for CPU2_RGN5_ACCENB.
* To use register names with standard convension, please use CPU2_RGN5_ACCENB.
*/


/** \brief E060, CPUx Safety Protection SPR Region Lower Address Register 6 */

/** Alias (User Manual Name) for CPU2_RGN6_LA.
* To use register names with standard convension, please use CPU2_RGN6_LA.
*/


/** \brief E064, CPUx Safety Protection SPR Region Upper Address Register 6 */

/** Alias (User Manual Name) for CPU2_RGN6_UA.
* To use register names with standard convension, please use CPU2_RGN6_UA.
*/


/** \brief E068, CPUx Safety Protection SPR Region Write Access Enable Register A6 */

/** Alias (User Manual Name) for CPU2_RGN6_ACCENA.
* To use register names with standard convension, please use CPU2_RGN6_ACCENA.
*/


/** \brief E06C, CPUx Safety Protection SPR Region Write Access Enable Register B6 */

/** Alias (User Manual Name) for CPU2_RGN6_ACCENB.
* To use register names with standard convension, please use CPU2_RGN6_ACCENB.
*/


/** \brief E070, CPUx Safety Protection SPR Region Lower Address Register 7 */

/** Alias (User Manual Name) for CPU2_RGN7_LA.
* To use register names with standard convension, please use CPU2_RGN7_LA.
*/


/** \brief E074, CPUx Safety Protection SPR Region Upper Address Register 7 */

/** Alias (User Manual Name) for CPU2_RGN7_UA.
* To use register names with standard convension, please use CPU2_RGN7_UA.
*/


/** \brief E078, CPUx Safety Protection SPR Region Write Access Enable Register A7 */

/** Alias (User Manual Name) for CPU2_RGN7_ACCENA.
* To use register names with standard convension, please use CPU2_RGN7_ACCENA.
*/


/** \brief E07C, CPUx Safety Protection SPR Region Write Access Enable Register B7 */

/** Alias (User Manual Name) for CPU2_RGN7_ACCENB.
* To use register names with standard convension, please use CPU2_RGN7_ACCENB.
*/


/** \brief E088, CPUx Safety Protection SPR Region Read Access Enable Register A0 */

/** Alias (User Manual Name) for CPU2_SPR_SPROT_RGNACCENA_R0.
* To use register names with standard convension, please use CPU2_SPR_SPROT_RGNACCENA_R0.
*/


/** \brief E08C, CPUx Safety Protection SPR Region Read Access Enable Register B0 */

/** Alias (User Manual Name) for CPU2_SPR_SPROT_RGNACCENB_R0.
* To use register names with standard convension, please use CPU2_SPR_SPROT_RGNACCENB_R0.
*/


/** \brief E098, CPUx Safety Protection SPR Region Read Access Enable Register A1 */

/** Alias (User Manual Name) for CPU2_SPR_SPROT_RGNACCENA_R1.
* To use register names with standard convension, please use CPU2_SPR_SPROT_RGNACCENA_R1.
*/


/** \brief E09C, CPUx Safety Protection SPR Region Read Access Enable Register B1 */

/** Alias (User Manual Name) for CPU2_SPR_SPROT_RGNACCENB_R1.
* To use register names with standard convension, please use CPU2_SPR_SPROT_RGNACCENB_R1.
*/


/** \brief E0A8, CPUx Safety Protection SPR Region Read Access Enable Register A2 */

/** Alias (User Manual Name) for CPU2_SPR_SPROT_RGNACCENA_R2.
* To use register names with standard convension, please use CPU2_SPR_SPROT_RGNACCENA_R2.
*/


/** \brief E0AC, CPUx Safety Protection SPR Region Read Access Enable Register B2 */

/** Alias (User Manual Name) for CPU2_SPR_SPROT_RGNACCENB_R2.
* To use register names with standard convension, please use CPU2_SPR_SPROT_RGNACCENB_R2.
*/


/** \brief E0B8, CPUx Safety Protection SPR Region Read Access Enable Register A3 */

/** Alias (User Manual Name) for CPU2_SPR_SPROT_RGNACCENA_R3.
* To use register names with standard convension, please use CPU2_SPR_SPROT_RGNACCENA_R3.
*/


/** \brief E0BC, CPUx Safety Protection SPR Region Read Access Enable Register B3 */

/** Alias (User Manual Name) for CPU2_SPR_SPROT_RGNACCENB_R3.
* To use register names with standard convension, please use CPU2_SPR_SPROT_RGNACCENB_R3.
*/


/** \brief E0C8, CPUx Safety Protection SPR Region Read Access Enable Register A4 */

/** Alias (User Manual Name) for CPU2_SPR_SPROT_RGNACCENA_R4.
* To use register names with standard convension, please use CPU2_SPR_SPROT_RGNACCENA_R4.
*/


/** \brief E0CC, CPUx Safety Protection SPR Region Read Access Enable Register B4 */

/** Alias (User Manual Name) for CPU2_SPR_SPROT_RGNACCENB_R4.
* To use register names with standard convension, please use CPU2_SPR_SPROT_RGNACCENB_R4.
*/


/** \brief E0D8, CPUx Safety Protection SPR Region Read Access Enable Register A5 */

/** Alias (User Manual Name) for CPU2_SPR_SPROT_RGNACCENA_R5.
* To use register names with standard convension, please use CPU2_SPR_SPROT_RGNACCENA_R5.
*/


/** \brief E0DC, CPUx Safety Protection SPR Region Read Access Enable Register B5 */

/** Alias (User Manual Name) for CPU2_SPR_SPROT_RGNACCENB_R5.
* To use register names with standard convension, please use CPU2_SPR_SPROT_RGNACCENB_R5.
*/


/** \brief E0E8, CPUx Safety Protection SPR Region Read Access Enable Register A6 */

/** Alias (User Manual Name) for CPU2_SPR_SPROT_RGNACCENA_R6.
* To use register names with standard convension, please use CPU2_SPR_SPROT_RGNACCENA_R6.
*/


/** \brief E0EC, CPUx Safety Protection SPR Region Read Access Enable Register B6 */

/** Alias (User Manual Name) for CPU2_SPR_SPROT_RGNACCENB_R6.
* To use register names with standard convension, please use CPU2_SPR_SPROT_RGNACCENB_R6.
*/


/** \brief E0F8, CPUx Safety Protection SPR Region Read Access Enable Register A7 */

/** Alias (User Manual Name) for CPU2_SPR_SPROT_RGNACCENA_R7.
* To use register names with standard convension, please use CPU2_SPR_SPROT_RGNACCENA_R7.
*/


/** \brief E0FC, CPUx Safety Protection SPR Region Read Access Enable Register B7 */

/** Alias (User Manual Name) for CPU2_SPR_SPROT_RGNACCENB_R7.
* To use register names with standard convension, please use CPU2_SPR_SPROT_RGNACCENB_R7.
*/


/** \brief E100, CPUx Safety Protection Register Access Enable Register A */


/** \brief E104, CPUx Safety Protection Region Access Enable Register B */


/** \brief E110, CPUx Safety Protection Region LPB Read Access Enable Register A */


/** \brief E114, CPUx Safety Protection Region LPB Read Access Enable Register B */


/** \brief E200, CPUx Safety Protection DLMU Region Lower Address Register 0 */


/** \brief E204, CPUx Safety protection DLMU Region Upper Address Register 0 */


/** \brief E208, CPUx Safety Protection Region DLMU Write Access Enable Register A0 */

/** Alias (User Manual Name) for CPU2_DLMU_SPROT_RGNACCENA_W0.
* To use register names with standard convension, please use CPU2_DLMU_SPROT_RGNACCENA_W0.
*/


/** \brief E20C, CPUx Safety Protection Region DLMU Write Access Enable Register B0 */

/** Alias (User Manual Name) for CPU2_DLMU_SPROT_RGNACCENB_W0.
* To use register names with standard convension, please use CPU2_DLMU_SPROT_RGNACCENB_W0.
*/


/** \brief E210, CPUx Safety Protection DLMU Region Lower Address Register 1 */


/** \brief E214, CPUx Safety protection DLMU Region Upper Address Register 1 */


/** \brief E218, CPUx Safety Protection Region DLMU Write Access Enable Register A1 */

/** Alias (User Manual Name) for CPU2_DLMU_SPROT_RGNACCENA_W1.
* To use register names with standard convension, please use CPU2_DLMU_SPROT_RGNACCENA_W1.
*/


/** \brief E21C, CPUx Safety Protection Region DLMU Write Access Enable Register B1 */

/** Alias (User Manual Name) for CPU2_DLMU_SPROT_RGNACCENB_W1.
* To use register names with standard convension, please use CPU2_DLMU_SPROT_RGNACCENB_W1.
*/


/** \brief E220, CPUx Safety Protection DLMU Region Lower Address Register 2 */


/** \brief E224, CPUx Safety protection DLMU Region Upper Address Register 2 */


/** \brief E228, CPUx Safety Protection Region DLMU Write Access Enable Register A2 */

/** Alias (User Manual Name) for CPU2_DLMU_SPROT_RGNACCENA_W2.
* To use register names with standard convension, please use CPU2_DLMU_SPROT_RGNACCENA_W2.
*/


/** \brief E22C, CPUx Safety Protection Region DLMU Write Access Enable Register B2 */

/** Alias (User Manual Name) for CPU2_DLMU_SPROT_RGNACCENB_W2.
* To use register names with standard convension, please use CPU2_DLMU_SPROT_RGNACCENB_W2.
*/


/** \brief E230, CPUx Safety Protection DLMU Region Lower Address Register 3 */


/** \brief E234, CPUx Safety protection DLMU Region Upper Address Register 3 */


/** \brief E238, CPUx Safety Protection Region DLMU Write Access Enable Register A3 */

/** Alias (User Manual Name) for CPU2_DLMU_SPROT_RGNACCENA_W3.
* To use register names with standard convension, please use CPU2_DLMU_SPROT_RGNACCENA_W3.
*/


/** \brief E23C, CPUx Safety Protection Region DLMU Write Access Enable Register B3 */

/** Alias (User Manual Name) for CPU2_DLMU_SPROT_RGNACCENB_W3.
* To use register names with standard convension, please use CPU2_DLMU_SPROT_RGNACCENB_W3.
*/


/** \brief E240, CPUx Safety Protection DLMU Region Lower Address Register 4 */


/** \brief E244, CPUx Safety protection DLMU Region Upper Address Register 4 */


/** \brief E248, CPUx Safety Protection Region DLMU Write Access Enable Register A4 */

/** Alias (User Manual Name) for CPU2_DLMU_SPROT_RGNACCENA_W4.
* To use register names with standard convension, please use CPU2_DLMU_SPROT_RGNACCENA_W4.
*/


/** \brief E24C, CPUx Safety Protection Region DLMU Write Access Enable Register B4 */

/** Alias (User Manual Name) for CPU2_DLMU_SPROT_RGNACCENB_W4.
* To use register names with standard convension, please use CPU2_DLMU_SPROT_RGNACCENB_W4.
*/


/** \brief E250, CPUx Safety Protection DLMU Region Lower Address Register 5 */


/** \brief E254, CPUx Safety protection DLMU Region Upper Address Register 5 */


/** \brief E258, CPUx Safety Protection Region DLMU Write Access Enable Register A5 */

/** Alias (User Manual Name) for CPU2_DLMU_SPROT_RGNACCENA_W5.
* To use register names with standard convension, please use CPU2_DLMU_SPROT_RGNACCENA_W5.
*/


/** \brief E25C, CPUx Safety Protection Region DLMU Write Access Enable Register B5 */

/** Alias (User Manual Name) for CPU2_DLMU_SPROT_RGNACCENB_W5.
* To use register names with standard convension, please use CPU2_DLMU_SPROT_RGNACCENB_W5.
*/


/** \brief E260, CPUx Safety Protection DLMU Region Lower Address Register 6 */


/** \brief E264, CPUx Safety protection DLMU Region Upper Address Register 6 */


/** \brief E268, CPUx Safety Protection Region DLMU Write Access Enable Register A6 */

/** Alias (User Manual Name) for CPU2_DLMU_SPROT_RGNACCENA_W6.
* To use register names with standard convension, please use CPU2_DLMU_SPROT_RGNACCENA_W6.
*/


/** \brief E26C, CPUx Safety Protection Region DLMU Write Access Enable Register B6 */

/** Alias (User Manual Name) for CPU2_DLMU_SPROT_RGNACCENB_W6.
* To use register names with standard convension, please use CPU2_DLMU_SPROT_RGNACCENB_W6.
*/


/** \brief E270, CPUx Safety Protection DLMU Region Lower Address Register 7 */


/** \brief E274, CPUx Safety protection DLMU Region Upper Address Register 7 */


/** \brief E278, CPUx Safety Protection Region DLMU Write Access Enable Register A7 */

/** Alias (User Manual Name) for CPU2_DLMU_SPROT_RGNACCENA_W7.
* To use register names with standard convension, please use CPU2_DLMU_SPROT_RGNACCENA_W7.
*/


/** \brief E27C, CPUx Safety Protection Region DLMU Write Access Enable Register B7 */

/** Alias (User Manual Name) for CPU2_DLMU_SPROT_RGNACCENB_W7.
* To use register names with standard convension, please use CPU2_DLMU_SPROT_RGNACCENB_W7.
*/


/** \brief E288, CPUx Safety Protection Region DLMU Read Access Enable Register A0 */

/** Alias (User Manual Name) for CPU2_DLMU_SPROT_RGNACCENA_R0.
* To use register names with standard convension, please use CPU2_DLMU_SPROT_RGNACCENA_R0.
*/


/** \brief E28C, CPUx Safety Protection Region DLMU Read Access Enable Register B0 */

/** Alias (User Manual Name) for CPU2_DLMU_SPROT_RGNACCENB_R0.
* To use register names with standard convension, please use CPU2_DLMU_SPROT_RGNACCENB_R0.
*/


/** \brief E298, CPUx Safety Protection Region DLMU Read Access Enable Register A1 */

/** Alias (User Manual Name) for CPU2_DLMU_SPROT_RGNACCENA_R1.
* To use register names with standard convension, please use CPU2_DLMU_SPROT_RGNACCENA_R1.
*/


/** \brief E29C, CPUx Safety Protection Region DLMU Read Access Enable Register B1 */

/** Alias (User Manual Name) for CPU2_DLMU_SPROT_RGNACCENB_R1.
* To use register names with standard convension, please use CPU2_DLMU_SPROT_RGNACCENB_R1.
*/


/** \brief E2A8, CPUx Safety Protection Region DLMU Read Access Enable Register A2 */

/** Alias (User Manual Name) for CPU2_DLMU_SPROT_RGNACCENA_R2.
* To use register names with standard convension, please use CPU2_DLMU_SPROT_RGNACCENA_R2.
*/


/** \brief E2AC, CPUx Safety Protection Region DLMU Read Access Enable Register B2 */

/** Alias (User Manual Name) for CPU2_DLMU_SPROT_RGNACCENB_R2.
* To use register names with standard convension, please use CPU2_DLMU_SPROT_RGNACCENB_R2.
*/


/** \brief E2B8, CPUx Safety Protection Region DLMU Read Access Enable Register A3 */

/** Alias (User Manual Name) for CPU2_DLMU_SPROT_RGNACCENA_R3.
* To use register names with standard convension, please use CPU2_DLMU_SPROT_RGNACCENA_R3.
*/


/** \brief E2BC, CPUx Safety Protection Region DLMU Read Access Enable Register B3 */

/** Alias (User Manual Name) for CPU2_DLMU_SPROT_RGNACCENB_R3.
* To use register names with standard convension, please use CPU2_DLMU_SPROT_RGNACCENB_R3.
*/


/** \brief E2C8, CPUx Safety Protection Region DLMU Read Access Enable Register A4 */

/** Alias (User Manual Name) for CPU2_DLMU_SPROT_RGNACCENA_R4.
* To use register names with standard convension, please use CPU2_DLMU_SPROT_RGNACCENA_R4.
*/


/** \brief E2CC, CPUx Safety Protection Region DLMU Read Access Enable Register B4 */

/** Alias (User Manual Name) for CPU2_DLMU_SPROT_RGNACCENB_R4.
* To use register names with standard convension, please use CPU2_DLMU_SPROT_RGNACCENB_R4.
*/


/** \brief E2D8, CPUx Safety Protection Region DLMU Read Access Enable Register A5 */

/** Alias (User Manual Name) for CPU2_DLMU_SPROT_RGNACCENA_R5.
* To use register names with standard convension, please use CPU2_DLMU_SPROT_RGNACCENA_R5.
*/


/** \brief E2DC, CPUx Safety Protection Region DLMU Read Access Enable Register B5 */

/** Alias (User Manual Name) for CPU2_DLMU_SPROT_RGNACCENB_R5.
* To use register names with standard convension, please use CPU2_DLMU_SPROT_RGNACCENB_R5.
*/


/** \brief E2E8, CPUx Safety Protection Region DLMU Read Access Enable Register A6 */

/** Alias (User Manual Name) for CPU2_DLMU_SPROT_RGNACCENA_R6.
* To use register names with standard convension, please use CPU2_DLMU_SPROT_RGNACCENA_R6.
*/


/** \brief E2EC, CPUx Safety Protection Region DLMU Read Access Enable Register B6 */

/** Alias (User Manual Name) for CPU2_DLMU_SPROT_RGNACCENB_R6.
* To use register names with standard convension, please use CPU2_DLMU_SPROT_RGNACCENB_R6.
*/


/** \brief E2F8, CPUx Safety Protection Region DLMU Read Access Enable Register A7 */

/** Alias (User Manual Name) for CPU2_DLMU_SPROT_RGNACCENA_R7.
* To use register names with standard convension, please use CPU2_DLMU_SPROT_RGNACCENA_R7.
*/


/** \brief E2FC, CPUx Safety Protection Region DLMU Read Access Enable Register B7 */

/** Alias (User Manual Name) for CPU2_DLMU_SPROT_RGNACCENB_R7.
* To use register names with standard convension, please use CPU2_DLMU_SPROT_RGNACCENB_R7.
*/


/** \brief FB00, CPUx  Overlay Range Select Register */


/** \brief FB10, CPUx Redirected Address Base Register 0 */

/** Alias (User Manual Name) for CPU2_BLK0_RABR.
* To use register names with standard convension, please use CPU2_BLK0_RABR.
*/


/** \brief FB14, CPUx Overlay Target Address Register 0 */

/** Alias (User Manual Name) for CPU2_BLK0_OTAR.
* To use register names with standard convension, please use CPU2_BLK0_OTAR.
*/


/** \brief FB18, CPUx Overlay Mask Register 0 */

/** Alias (User Manual Name) for CPU2_BLK0_OMASK.
* To use register names with standard convension, please use CPU2_BLK0_OMASK.
*/


/** \brief FB1C, CPUx Redirected Address Base Register 1 */

/** Alias (User Manual Name) for CPU2_BLK1_RABR.
* To use register names with standard convension, please use CPU2_BLK1_RABR.
*/


/** \brief FB20, CPUx Overlay Target Address Register 1 */

/** Alias (User Manual Name) for CPU2_BLK1_OTAR.
* To use register names with standard convension, please use CPU2_BLK1_OTAR.
*/


/** \brief FB24, CPUx Overlay Mask Register 1 */

/** Alias (User Manual Name) for CPU2_BLK1_OMASK.
* To use register names with standard convension, please use CPU2_BLK1_OMASK.
*/


/** \brief FB28, CPUx Redirected Address Base Register 2 */

/** Alias (User Manual Name) for CPU2_BLK2_RABR.
* To use register names with standard convension, please use CPU2_BLK2_RABR.
*/


/** \brief FB2C, CPUx Overlay Target Address Register 2 */

/** Alias (User Manual Name) for CPU2_BLK2_OTAR.
* To use register names with standard convension, please use CPU2_BLK2_OTAR.
*/


/** \brief FB30, CPUx Overlay Mask Register 2 */

/** Alias (User Manual Name) for CPU2_BLK2_OMASK.
* To use register names with standard convension, please use CPU2_BLK2_OMASK.
*/


/** \brief FB34, CPUx Redirected Address Base Register 3 */

/** Alias (User Manual Name) for CPU2_BLK3_RABR.
* To use register names with standard convension, please use CPU2_BLK3_RABR.
*/


/** \brief FB38, CPUx Overlay Target Address Register 3 */

/** Alias (User Manual Name) for CPU2_BLK3_OTAR.
* To use register names with standard convension, please use CPU2_BLK3_OTAR.
*/


/** \brief FB3C, CPUx Overlay Mask Register 3 */

/** Alias (User Manual Name) for CPU2_BLK3_OMASK.
* To use register names with standard convension, please use CPU2_BLK3_OMASK.
*/


/** \brief FB40, CPUx Redirected Address Base Register 4 */

/** Alias (User Manual Name) for CPU2_BLK4_RABR.
* To use register names with standard convension, please use CPU2_BLK4_RABR.
*/


/** \brief FB44, CPUx Overlay Target Address Register 4 */

/** Alias (User Manual Name) for CPU2_BLK4_OTAR.
* To use register names with standard convension, please use CPU2_BLK4_OTAR.
*/


/** \brief FB48, CPUx Overlay Mask Register 4 */

/** Alias (User Manual Name) for CPU2_BLK4_OMASK.
* To use register names with standard convension, please use CPU2_BLK4_OMASK.
*/


/** \brief FB4C, CPUx Redirected Address Base Register 5 */

/** Alias (User Manual Name) for CPU2_BLK5_RABR.
* To use register names with standard convension, please use CPU2_BLK5_RABR.
*/


/** \brief FB50, CPUx Overlay Target Address Register 5 */

/** Alias (User Manual Name) for CPU2_BLK5_OTAR.
* To use register names with standard convension, please use CPU2_BLK5_OTAR.
*/


/** \brief FB54, CPUx Overlay Mask Register 5 */

/** Alias (User Manual Name) for CPU2_BLK5_OMASK.
* To use register names with standard convension, please use CPU2_BLK5_OMASK.
*/


/** \brief FB58, CPUx Redirected Address Base Register 6 */

/** Alias (User Manual Name) for CPU2_BLK6_RABR.
* To use register names with standard convension, please use CPU2_BLK6_RABR.
*/


/** \brief FB5C, CPUx Overlay Target Address Register 6 */

/** Alias (User Manual Name) for CPU2_BLK6_OTAR.
* To use register names with standard convension, please use CPU2_BLK6_OTAR.
*/


/** \brief FB60, CPUx Overlay Mask Register 6 */

/** Alias (User Manual Name) for CPU2_BLK6_OMASK.
* To use register names with standard convension, please use CPU2_BLK6_OMASK.
*/


/** \brief FB64, CPUx Redirected Address Base Register 7 */

/** Alias (User Manual Name) for CPU2_BLK7_RABR.
* To use register names with standard convension, please use CPU2_BLK7_RABR.
*/


/** \brief FB68, CPUx Overlay Target Address Register 7 */

/** Alias (User Manual Name) for CPU2_BLK7_OTAR.
* To use register names with standard convension, please use CPU2_BLK7_OTAR.
*/


/** \brief FB6C, CPUx Overlay Mask Register 7 */

/** Alias (User Manual Name) for CPU2_BLK7_OMASK.
* To use register names with standard convension, please use CPU2_BLK7_OMASK.
*/


/** \brief FB70, CPUx Redirected Address Base Register 8 */

/** Alias (User Manual Name) for CPU2_BLK8_RABR.
* To use register names with standard convension, please use CPU2_BLK8_RABR.
*/


/** \brief FB74, CPUx Overlay Target Address Register 8 */

/** Alias (User Manual Name) for CPU2_BLK8_OTAR.
* To use register names with standard convension, please use CPU2_BLK8_OTAR.
*/


/** \brief FB78, CPUx Overlay Mask Register 8 */

/** Alias (User Manual Name) for CPU2_BLK8_OMASK.
* To use register names with standard convension, please use CPU2_BLK8_OMASK.
*/


/** \brief FB7C, CPUx Redirected Address Base Register 9 */

/** Alias (User Manual Name) for CPU2_BLK9_RABR.
* To use register names with standard convension, please use CPU2_BLK9_RABR.
*/


/** \brief FB80, CPUx Overlay Target Address Register 9 */

/** Alias (User Manual Name) for CPU2_BLK9_OTAR.
* To use register names with standard convension, please use CPU2_BLK9_OTAR.
*/


/** \brief FB84, CPUx Overlay Mask Register 9 */

/** Alias (User Manual Name) for CPU2_BLK9_OMASK.
* To use register names with standard convension, please use CPU2_BLK9_OMASK.
*/


/** \brief FB88, CPUx Redirected Address Base Register 10 */

/** Alias (User Manual Name) for CPU2_BLK10_RABR.
* To use register names with standard convension, please use CPU2_BLK10_RABR.
*/


/** \brief FB8C, CPUx Overlay Target Address Register 10 */

/** Alias (User Manual Name) for CPU2_BLK10_OTAR.
* To use register names with standard convension, please use CPU2_BLK10_OTAR.
*/


/** \brief FB90, CPUx Overlay Mask Register 10 */

/** Alias (User Manual Name) for CPU2_BLK10_OMASK.
* To use register names with standard convension, please use CPU2_BLK10_OMASK.
*/


/** \brief FB94, CPUx Redirected Address Base Register 11 */

/** Alias (User Manual Name) for CPU2_BLK11_RABR.
* To use register names with standard convension, please use CPU2_BLK11_RABR.
*/


/** \brief FB98, CPUx Overlay Target Address Register 11 */

/** Alias (User Manual Name) for CPU2_BLK11_OTAR.
* To use register names with standard convension, please use CPU2_BLK11_OTAR.
*/


/** \brief FB9C, CPUx Overlay Mask Register 11 */

/** Alias (User Manual Name) for CPU2_BLK11_OMASK.
* To use register names with standard convension, please use CPU2_BLK11_OMASK.
*/


/** \brief FBA0, CPUx Redirected Address Base Register 12 */

/** Alias (User Manual Name) for CPU2_BLK12_RABR.
* To use register names with standard convension, please use CPU2_BLK12_RABR.
*/


/** \brief FBA4, CPUx Overlay Target Address Register 12 */

/** Alias (User Manual Name) for CPU2_BLK12_OTAR.
* To use register names with standard convension, please use CPU2_BLK12_OTAR.
*/


/** \brief FBA8, CPUx Overlay Mask Register 12 */

/** Alias (User Manual Name) for CPU2_BLK12_OMASK.
* To use register names with standard convension, please use CPU2_BLK12_OMASK.
*/


/** \brief FBAC, CPUx Redirected Address Base Register 13 */

/** Alias (User Manual Name) for CPU2_BLK13_RABR.
* To use register names with standard convension, please use CPU2_BLK13_RABR.
*/


/** \brief FBB0, CPUx Overlay Target Address Register 13 */

/** Alias (User Manual Name) for CPU2_BLK13_OTAR.
* To use register names with standard convension, please use CPU2_BLK13_OTAR.
*/


/** \brief FBB4, CPUx Overlay Mask Register 13 */

/** Alias (User Manual Name) for CPU2_BLK13_OMASK.
* To use register names with standard convension, please use CPU2_BLK13_OMASK.
*/


/** \brief FBB8, CPUx Redirected Address Base Register 14 */

/** Alias (User Manual Name) for CPU2_BLK14_RABR.
* To use register names with standard convension, please use CPU2_BLK14_RABR.
*/


/** \brief FBBC, CPUx Overlay Target Address Register 14 */

/** Alias (User Manual Name) for CPU2_BLK14_OTAR.
* To use register names with standard convension, please use CPU2_BLK14_OTAR.
*/


/** \brief FBC0, CPUx Overlay Mask Register 14 */

/** Alias (User Manual Name) for CPU2_BLK14_OMASK.
* To use register names with standard convension, please use CPU2_BLK14_OMASK.
*/


/** \brief FBC4, CPUx Redirected Address Base Register 15 */

/** Alias (User Manual Name) for CPU2_BLK15_RABR.
* To use register names with standard convension, please use CPU2_BLK15_RABR.
*/


/** \brief FBC8, CPUx Overlay Target Address Register 15 */

/** Alias (User Manual Name) for CPU2_BLK15_OTAR.
* To use register names with standard convension, please use CPU2_BLK15_OTAR.
*/


/** \brief FBCC, CPUx Overlay Mask Register 15 */

/** Alias (User Manual Name) for CPU2_BLK15_OMASK.
* To use register names with standard convension, please use CPU2_BLK15_OMASK.
*/


/** \brief FBD0, CPUx Redirected Address Base Register 16 */

/** Alias (User Manual Name) for CPU2_BLK16_RABR.
* To use register names with standard convension, please use CPU2_BLK16_RABR.
*/


/** \brief FBD4, CPUx Overlay Target Address Register 16 */

/** Alias (User Manual Name) for CPU2_BLK16_OTAR.
* To use register names with standard convension, please use CPU2_BLK16_OTAR.
*/


/** \brief FBD8, CPUx Overlay Mask Register 16 */

/** Alias (User Manual Name) for CPU2_BLK16_OMASK.
* To use register names with standard convension, please use CPU2_BLK16_OMASK.
*/


/** \brief FBDC, CPUx Redirected Address Base Register 17 */

/** Alias (User Manual Name) for CPU2_BLK17_RABR.
* To use register names with standard convension, please use CPU2_BLK17_RABR.
*/


/** \brief FBE0, CPUx Overlay Target Address Register 17 */

/** Alias (User Manual Name) for CPU2_BLK17_OTAR.
* To use register names with standard convension, please use CPU2_BLK17_OTAR.
*/


/** \brief FBE4, CPUx Overlay Mask Register 17 */

/** Alias (User Manual Name) for CPU2_BLK17_OMASK.
* To use register names with standard convension, please use CPU2_BLK17_OMASK.
*/


/** \brief FBE8, CPUx Redirected Address Base Register 18 */

/** Alias (User Manual Name) for CPU2_BLK18_RABR.
* To use register names with standard convension, please use CPU2_BLK18_RABR.
*/


/** \brief FBEC, CPUx Overlay Target Address Register 18 */

/** Alias (User Manual Name) for CPU2_BLK18_OTAR.
* To use register names with standard convension, please use CPU2_BLK18_OTAR.
*/


/** \brief FBF0, CPUx Overlay Mask Register 18 */

/** Alias (User Manual Name) for CPU2_BLK18_OMASK.
* To use register names with standard convension, please use CPU2_BLK18_OMASK.
*/


/** \brief FBF4, CPUx Redirected Address Base Register 19 */

/** Alias (User Manual Name) for CPU2_BLK19_RABR.
* To use register names with standard convension, please use CPU2_BLK19_RABR.
*/


/** \brief FBF8, CPUx Overlay Target Address Register 19 */

/** Alias (User Manual Name) for CPU2_BLK19_OTAR.
* To use register names with standard convension, please use CPU2_BLK19_OTAR.
*/


/** \brief FBFC, CPUx Overlay Mask Register 19 */

/** Alias (User Manual Name) for CPU2_BLK19_OMASK.
* To use register names with standard convension, please use CPU2_BLK19_OMASK.
*/


/** \brief FC00, CPUx Redirected Address Base Register 20 */

/** Alias (User Manual Name) for CPU2_BLK20_RABR.
* To use register names with standard convension, please use CPU2_BLK20_RABR.
*/


/** \brief FC04, CPUx Overlay Target Address Register 20 */

/** Alias (User Manual Name) for CPU2_BLK20_OTAR.
* To use register names with standard convension, please use CPU2_BLK20_OTAR.
*/


/** \brief FC08, CPUx Overlay Mask Register 20 */

/** Alias (User Manual Name) for CPU2_BLK20_OMASK.
* To use register names with standard convension, please use CPU2_BLK20_OMASK.
*/


/** \brief FC0C, CPUx Redirected Address Base Register 21 */

/** Alias (User Manual Name) for CPU2_BLK21_RABR.
* To use register names with standard convension, please use CPU2_BLK21_RABR.
*/


/** \brief FC10, CPUx Overlay Target Address Register 21 */

/** Alias (User Manual Name) for CPU2_BLK21_OTAR.
* To use register names with standard convension, please use CPU2_BLK21_OTAR.
*/


/** \brief FC14, CPUx Overlay Mask Register 21 */

/** Alias (User Manual Name) for CPU2_BLK21_OMASK.
* To use register names with standard convension, please use CPU2_BLK21_OMASK.
*/


/** \brief FC18, CPUx Redirected Address Base Register 22 */

/** Alias (User Manual Name) for CPU2_BLK22_RABR.
* To use register names with standard convension, please use CPU2_BLK22_RABR.
*/


/** \brief FC1C, CPUx Overlay Target Address Register 22 */

/** Alias (User Manual Name) for CPU2_BLK22_OTAR.
* To use register names with standard convension, please use CPU2_BLK22_OTAR.
*/


/** \brief FC20, CPUx Overlay Mask Register 22 */

/** Alias (User Manual Name) for CPU2_BLK22_OMASK.
* To use register names with standard convension, please use CPU2_BLK22_OMASK.
*/


/** \brief FC24, CPUx Redirected Address Base Register 23 */

/** Alias (User Manual Name) for CPU2_BLK23_RABR.
* To use register names with standard convension, please use CPU2_BLK23_RABR.
*/


/** \brief FC28, CPUx Overlay Target Address Register 23 */

/** Alias (User Manual Name) for CPU2_BLK23_OTAR.
* To use register names with standard convension, please use CPU2_BLK23_OTAR.
*/


/** \brief FC2C, CPUx Overlay Mask Register 23 */

/** Alias (User Manual Name) for CPU2_BLK23_OMASK.
* To use register names with standard convension, please use CPU2_BLK23_OMASK.
*/


/** \brief FC30, CPUx Redirected Address Base Register 24 */

/** Alias (User Manual Name) for CPU2_BLK24_RABR.
* To use register names with standard convension, please use CPU2_BLK24_RABR.
*/


/** \brief FC34, CPUx Overlay Target Address Register 24 */

/** Alias (User Manual Name) for CPU2_BLK24_OTAR.
* To use register names with standard convension, please use CPU2_BLK24_OTAR.
*/


/** \brief FC38, CPUx Overlay Mask Register 24 */

/** Alias (User Manual Name) for CPU2_BLK24_OMASK.
* To use register names with standard convension, please use CPU2_BLK24_OMASK.
*/


/** \brief FC3C, CPUx Redirected Address Base Register 25 */

/** Alias (User Manual Name) for CPU2_BLK25_RABR.
* To use register names with standard convension, please use CPU2_BLK25_RABR.
*/


/** \brief FC40, CPUx Overlay Target Address Register 25 */

/** Alias (User Manual Name) for CPU2_BLK25_OTAR.
* To use register names with standard convension, please use CPU2_BLK25_OTAR.
*/


/** \brief FC44, CPUx Overlay Mask Register 25 */

/** Alias (User Manual Name) for CPU2_BLK25_OMASK.
* To use register names with standard convension, please use CPU2_BLK25_OMASK.
*/


/** \brief FC48, CPUx Redirected Address Base Register 26 */

/** Alias (User Manual Name) for CPU2_BLK26_RABR.
* To use register names with standard convension, please use CPU2_BLK26_RABR.
*/


/** \brief FC4C, CPUx Overlay Target Address Register 26 */

/** Alias (User Manual Name) for CPU2_BLK26_OTAR.
* To use register names with standard convension, please use CPU2_BLK26_OTAR.
*/


/** \brief FC50, CPUx Overlay Mask Register 26 */

/** Alias (User Manual Name) for CPU2_BLK26_OMASK.
* To use register names with standard convension, please use CPU2_BLK26_OMASK.
*/


/** \brief FC54, CPUx Redirected Address Base Register 27 */

/** Alias (User Manual Name) for CPU2_BLK27_RABR.
* To use register names with standard convension, please use CPU2_BLK27_RABR.
*/


/** \brief FC58, CPUx Overlay Target Address Register 27 */

/** Alias (User Manual Name) for CPU2_BLK27_OTAR.
* To use register names with standard convension, please use CPU2_BLK27_OTAR.
*/


/** \brief FC5C, CPUx Overlay Mask Register 27 */

/** Alias (User Manual Name) for CPU2_BLK27_OMASK.
* To use register names with standard convension, please use CPU2_BLK27_OMASK.
*/


/** \brief FC60, CPUx Redirected Address Base Register 28 */

/** Alias (User Manual Name) for CPU2_BLK28_RABR.
* To use register names with standard convension, please use CPU2_BLK28_RABR.
*/


/** \brief FC64, CPUx Overlay Target Address Register 28 */

/** Alias (User Manual Name) for CPU2_BLK28_OTAR.
* To use register names with standard convension, please use CPU2_BLK28_OTAR.
*/


/** \brief FC68, CPUx Overlay Mask Register 28 */

/** Alias (User Manual Name) for CPU2_BLK28_OMASK.
* To use register names with standard convension, please use CPU2_BLK28_OMASK.
*/


/** \brief FC6C, CPUx Redirected Address Base Register 29 */

/** Alias (User Manual Name) for CPU2_BLK29_RABR.
* To use register names with standard convension, please use CPU2_BLK29_RABR.
*/


/** \brief FC70, CPUx Overlay Target Address Register 29 */

/** Alias (User Manual Name) for CPU2_BLK29_OTAR.
* To use register names with standard convension, please use CPU2_BLK29_OTAR.
*/


/** \brief FC74, CPUx Overlay Mask Register 29 */

/** Alias (User Manual Name) for CPU2_BLK29_OMASK.
* To use register names with standard convension, please use CPU2_BLK29_OMASK.
*/


/** \brief FC78, CPUx Redirected Address Base Register 30 */

/** Alias (User Manual Name) for CPU2_BLK30_RABR.
* To use register names with standard convension, please use CPU2_BLK30_RABR.
*/


/** \brief FC7C, CPUx Overlay Target Address Register 30 */

/** Alias (User Manual Name) for CPU2_BLK30_OTAR.
* To use register names with standard convension, please use CPU2_BLK30_OTAR.
*/


/** \brief FC80, CPUx Overlay Mask Register 30 */

/** Alias (User Manual Name) for CPU2_BLK30_OMASK.
* To use register names with standard convension, please use CPU2_BLK30_OMASK.
*/


/** \brief FC84, CPUx Redirected Address Base Register 31 */

/** Alias (User Manual Name) for CPU2_BLK31_RABR.
* To use register names with standard convension, please use CPU2_BLK31_RABR.
*/


/** \brief FC88, CPUx Overlay Target Address Register 31 */

/** Alias (User Manual Name) for CPU2_BLK31_OTAR.
* To use register names with standard convension, please use CPU2_BLK31_OTAR.
*/


/** \brief FC8C, CPUx Overlay Mask Register 31 */

/** Alias (User Manual Name) for CPU2_BLK31_OMASK.
* To use register names with standard convension, please use CPU2_BLK31_OMASK.
*/


/** \brief 1030, CPUx SRI Error Generation Register */


/** \brief 8004, CPUx Task Address Space Identifier Register */


/** \brief 8100, CPUx Data Access CacheabilityRegister */


/** \brief 8104, CPUx Code Access CacheabilityRegister */


/** \brief 8108, CPUx  Peripheral Space Identifier register */


/** \brief 9000, CPUx Data Control Register 2 */


/** \brief 900C, CPUx SIST Mode Access Control Register */


/** \brief 9010, CPUx Data Synchronous Trap Register */


/** \brief 9018, CPUx Data Asynchronous Trap Register */


/** \brief 901C, CPUx Data Error Address Register */


/** \brief 9020, CPUx Data Integrity Error Address Register */


/** \brief 9024, CPUx Data Integrity Error Trap Register */


/** \brief 9040, CPUx Data Memory Control Register */


/** \brief 9200, CPUx Program Synchronous Trap Register */


/** \brief 9204, CPUx Program Control 1 */


/** \brief 9208, CPUx Program Control 2 */


/** \brief 920C, CPUx Program Control 0 */


/** \brief 9210, CPUx Program Integrity Error Address Register */


/** \brief 9214, CPUx Program Integrity Error Trap Register */


/** \brief 9400, CPUx Compatibility Control Register */


/** \brief A000, CPUx Trap Control Register */


/** \brief A004, CPUx Trapping Instruction Program Counter Register */


/** \brief A008, CPUx Trapping Instruction Opcode Register */


/** \brief A010, CPUx Trapping Instruction Operand Register */


/** \brief A014, CPUx Trapping Instruction Operand Register */


/** \brief A018, CPUx Trapping Instruction Operand Register */


/** \brief C000, CPUx Data Protection Range 0, Lower Bound Register */


/** \brief C004, CPUx Data Protection Range 0, Upper Bound Register */


/** \brief C008, CPUx Data Protection Range 1, Lower Bound Register */


/** \brief C00C, CPUx Data Protection Range 1, Upper Bound Register */


/** \brief C010, CPUx Data Protection Range 2, Lower Bound Register */


/** \brief C014, CPUx Data Protection Range 2, Upper Bound Register */


/** \brief C018, CPUx Data Protection Range 3, Lower Bound Register */


/** \brief C01C, CPUx Data Protection Range 3, Upper Bound Register */


/** \brief C020, CPUx Data Protection Range 4, Lower Bound Register */


/** \brief C024, CPUx Data Protection Range 4, Upper Bound Register */


/** \brief C028, CPUx Data Protection Range 5, Lower Bound Register */


/** \brief C02C, CPUx Data Protection Range 5, Upper Bound Register */


/** \brief C030, CPUx Data Protection Range 6, Lower Bound Register */


/** \brief C034, CPUx Data Protection Range 6, Upper Bound Register */


/** \brief C038, CPUx Data Protection Range 7, Lower Bound Register */


/** \brief C03C, CPUx Data Protection Range 7, Upper Bound Register */


/** \brief C040, CPUx Data Protection Range 8, Lower Bound Register */


/** \brief C044, CPUx Data Protection Range 8, Upper Bound Register */


/** \brief C048, CPUx Data Protection Range 9, Lower Bound Register */


/** \brief C04C, CPUx Data Protection Range 9, Upper Bound Register */


/** \brief C050, CPUx Data Protection Range 10, Lower Bound Register */


/** \brief C054, CPUx Data Protection Range 10, Upper Bound Register */


/** \brief C058, CPUx Data Protection Range 11, Lower Bound Register */


/** \brief C05C, CPUx Data Protection Range 11, Upper Bound Register */


/** \brief C060, CPUx Data Protection Range 12, Lower Bound Register */


/** \brief C064, CPUx Data Protection Range 12, Upper Bound Register */


/** \brief C068, CPUx Data Protection Range 13, Lower Bound Register */


/** \brief C06C, CPUx Data Protection Range 13, Upper Bound Register */


/** \brief C070, CPUx Data Protection Range 14, Lower Bound Register */


/** \brief C074, CPUx Data Protection Range 14, Upper Bound Register */


/** \brief C078, CPUx Data Protection Range 15, Lower Bound Register */


/** \brief C07C, CPUx Data Protection Range 15, Upper Bound Register */


/** \brief C080, CPUx Data Protection Range 16, Lower Bound Register */


/** \brief C084, CPUx Data Protection Range 16, Upper Bound Register */


/** \brief C088, CPUx Data Protection Range 17, Lower Bound Register */


/** \brief C08C, CPUx Data Protection Range 17, Upper Bound Register */


/** \brief D000, CPUx Code Protection Range 0 Lower Bound Register */


/** \brief D004, CPUx Code Protection Range 0 Upper Bound Register */


/** \brief D008, CPUx Code Protection Range 1 Lower Bound Register */


/** \brief D00C, CPUx Code Protection Range 1 Upper Bound Register */


/** \brief D010, CPUx Code Protection Range 2 Lower Bound Register */


/** \brief D014, CPUx Code Protection Range 2 Upper Bound Register */


/** \brief D018, CPUx Code Protection Range 3 Lower Bound Register */


/** \brief D01C, CPUx Code Protection Range 3 Upper Bound Register */


/** \brief D020, CPUx Code Protection Range 4 Lower Bound Register */


/** \brief D024, CPUx Code Protection Range 4 Upper Bound Register */


/** \brief D028, CPUx Code Protection Range 5 Lower Bound Register */


/** \brief D02C, CPUx Code Protection Range 5 Upper Bound Register */


/** \brief D030, CPUx Code Protection Range 6 Lower Bound Register */


/** \brief D034, CPUx Code Protection Range 6 Upper Bound Register */


/** \brief D038, CPUx Code Protection Range 7 Lower Bound Register */


/** \brief D03C, CPUx Code Protection Range 7 Upper Bound Register */


/** \brief D040, CPUx Code Protection Range 8 Lower Bound Register */


/** \brief D044, CPUx Code Protection Range 8 Upper Bound Register */


/** \brief D048, CPUx Code Protection Range 9 Lower Bound Register */


/** \brief D04C, CPUx Code Protection Range 9 Upper Bound Register */


/** \brief E000, CPUx Code Protection Execute Enable Register Set 0 */


/** \brief E004, CPUx Code Protection Execute Enable Register Set 1 */


/** \brief E008, CPUx Code Protection Execute Enable Register Set 2 */


/** \brief E00C, CPUx Code Protection Execute Enable Register Set 3 */


/** \brief E010, CPUx Data Protection Read Enable Register Set 0 */


/** \brief E014, CPUx Data Protection Read Enable Register Set 1 */


/** \brief E018, CPUx Data Protection Read Enable Register Set 2 */


/** \brief E01C, CPUx Data Protection Read Enable Register Set 3 */


/** \brief E020, CPUx Data Protection Write Enable Register Set 0 */


/** \brief E024, CPUx Data Protection Write Enable Register Set 1 */


/** \brief E028, CPUx Data Protection Write Enable Register Set 2 */


/** \brief E02C, CPUx Data Protection Write Enable Register Set 3 */


/** \brief E040, CPUx Code Protection Execute Enable Register Set 4 */


/** \brief E044, CPUx Code Protection Execute Enable Register Set 5 */


/** \brief E050, CPUx Data Protection Read Enable Register Set 4 */


/** \brief E054, CPUx Data Protection Read Enable Register Set 5 */


/** \brief E060, CPUx Data Protection Write Enable Register Set 4 */


/** \brief E064, CPUx Data Protection Write Enable Register Set 5 */


/** \brief E400, CPUx Temporal Protection System Control Register */


/** \brief E404, CPUx Temporal Protection System Timer Register 0 */


/** \brief E408, CPUx Temporal Protection System Timer Register 1 */


/** \brief E40C, CPUx Temporal Protection System Timer Register 2 */


/** \brief E440, CPUx Exception Entry Timer Load Value */


/** \brief E444, CPUx Exception Entry Timer Current Value */


/** \brief E448, CPUx Exception Exit  Timer Load Value */


/** \brief E44C, CPUx Exception Exit Timer Current Value */


/** \brief E450, CPUx Exception Timer Class Enable Register */


/** \brief E454, CPUx Exception Timer Status Register */


/** \brief E458, CPUx Exception Timer FCX Register */


/** \brief F000, CPUx Trigger Event 0 */

/** Alias (User Manual Name) for CPU2_TR0_EVT.
* To use register names with standard convension, please use CPU2_TR0_EVT.
*/


/** \brief F004, CPUx Trigger Address 0 */

/** Alias (User Manual Name) for CPU2_TR0_ADR.
* To use register names with standard convension, please use CPU2_TR0_ADR.
*/


/** \brief F008, CPUx Trigger Event 1 */

/** Alias (User Manual Name) for CPU2_TR1_EVT.
* To use register names with standard convension, please use CPU2_TR1_EVT.
*/


/** \brief F00C, CPUx Trigger Address 1 */

/** Alias (User Manual Name) for CPU2_TR1_ADR.
* To use register names with standard convension, please use CPU2_TR1_ADR.
*/


/** \brief F010, CPUx Trigger Event 2 */

/** Alias (User Manual Name) for CPU2_TR2_EVT.
* To use register names with standard convension, please use CPU2_TR2_EVT.
*/


/** \brief F014, CPUx Trigger Address 2 */

/** Alias (User Manual Name) for CPU2_TR2_ADR.
* To use register names with standard convension, please use CPU2_TR2_ADR.
*/


/** \brief F018, CPUx Trigger Event 3 */

/** Alias (User Manual Name) for CPU2_TR3_EVT.
* To use register names with standard convension, please use CPU2_TR3_EVT.
*/


/** \brief F01C, CPUx Trigger Address 3 */

/** Alias (User Manual Name) for CPU2_TR3_ADR.
* To use register names with standard convension, please use CPU2_TR3_ADR.
*/


/** \brief F020, CPUx Trigger Event 4 */

/** Alias (User Manual Name) for CPU2_TR4_EVT.
* To use register names with standard convension, please use CPU2_TR4_EVT.
*/


/** \brief F024, CPUx Trigger Address 4 */

/** Alias (User Manual Name) for CPU2_TR4_ADR.
* To use register names with standard convension, please use CPU2_TR4_ADR.
*/


/** \brief F028, CPUx Trigger Event 5 */

/** Alias (User Manual Name) for CPU2_TR5_EVT.
* To use register names with standard convension, please use CPU2_TR5_EVT.
*/


/** \brief F02C, CPUx Trigger Address 5 */

/** Alias (User Manual Name) for CPU2_TR5_ADR.
* To use register names with standard convension, please use CPU2_TR5_ADR.
*/


/** \brief F030, CPUx Trigger Event 6 */

/** Alias (User Manual Name) for CPU2_TR6_EVT.
* To use register names with standard convension, please use CPU2_TR6_EVT.
*/


/** \brief F034, CPUx Trigger Address 6 */

/** Alias (User Manual Name) for CPU2_TR6_ADR.
* To use register names with standard convension, please use CPU2_TR6_ADR.
*/


/** \brief F038, CPUx Trigger Event 7 */

/** Alias (User Manual Name) for CPU2_TR7_EVT.
* To use register names with standard convension, please use CPU2_TR7_EVT.
*/


/** \brief F03C, CPUx Trigger Address 7 */

/** Alias (User Manual Name) for CPU2_TR7_ADR.
* To use register names with standard convension, please use CPU2_TR7_ADR.
*/


/** \brief FC00, CPUx Counter Control */


/** \brief FC04, CPUx CPU Clock Cycle Count */


/** \brief FC08, CPUx Instruction Count */


/** \brief FC0C, CPUx Multi-Count Register 1 */


/** \brief FC10, CPUx Multi-Count Register 2 */


/** \brief FC14, CPUx Multi-Count Register 3 */


/** \brief FD00, CPUx Debug Status Register */


/** \brief FD08, CPUx External Event Register */


/** \brief FD0C, CPUx Core Register Access Event */


/** \brief FD10, CPUx Software Debug Event */


/** \brief FD30, CPUx TriggerAddressx */


/** \brief FD40, CPUx Debug Monitor Start Address */


/** \brief FD44, CPUx Debug Context Save Area Pointer */


/** \brief FD48, CPUx Debug Trap Control Register */


/** \brief FE00, CPUx Previous Context Information Register */


/** \brief FE04, CPUx Program Status Word */


/** \brief FE08, CPUx Program Counter */


/** \brief FE14, CPUx System Configuration Register */


/** \brief FE18, CPUx Identification Register TC1.6.2P */


/** \brief FE1C, CPUx Core Identification Register */


/** \brief FE20, CPUx Base Interrupt Vector Table Pointer */


/** \brief FE24, CPUx Base Trap Vector Table Pointer */


/** \brief FE28, CPUx Interrupt Stack Pointer */


/** \brief FE2C, CPUx Interrupt Control Register */


/** \brief FE38, CPUx Free CSA List Head Pointer */


/** \brief FE3C, CPUx Free CSA List Limit Pointer */


/** \brief FE50, CPUx Customer ID register */


/** \brief FF00, CPUx Data General Purpose Register 0 */


/** \brief FF04, CPUx Data General Purpose Register 1 */


/** \brief FF08, CPUx Data General Purpose Register 2 */


/** \brief FF0C, CPUx Data General Purpose Register 3 */


/** \brief FF10, CPUx Data General Purpose Register 4 */


/** \brief FF14, CPUx Data General Purpose Register 5 */


/** \brief FF18, CPUx Data General Purpose Register 6 */


/** \brief FF1C, CPUx Data General Purpose Register 7 */


/** \brief FF20, CPUx Data General Purpose Register 8 */


/** \brief FF24, CPUx Data General Purpose Register 9 */


/** \brief FF28, CPUx Data General Purpose Register 10 */


/** \brief FF2C, CPUx Data General Purpose Register 11 */


/** \brief FF30, CPUx Data General Purpose Register 12 */


/** \brief FF34, CPUx Data General Purpose Register 13 */


/** \brief FF38, CPUx Data General Purpose Register 14 */


/** \brief FF3C, CPUx Data General Purpose Register 15 */


/** \brief FF80, CPUx Address General Purpose Register 0 */


/** \brief FF84, CPUx Address General Purpose Register 1 */


/** \brief FF88, CPUx Address General Purpose Register 2 */


/** \brief FF8C, CPUx Address General Purpose Register 3 */


/** \brief FF90, CPUx Address General Purpose Register 4 */


/** \brief FF94, CPUx Address General Purpose Register 5 */


/** \brief FF98, CPUx Address General Purpose Register 6 */


/** \brief FF9C, CPUx Address General Purpose Register 7 */


/** \brief FFA0, CPUx Address General Purpose Register 8 */


/** \brief FFA4, CPUx Address General Purpose Register 9 */


/** \brief FFA8, CPUx Address General Purpose Register 10 */


/** \brief FFAC, CPUx Address General Purpose Register 11 */


/** \brief FFB0, CPUx Address General Purpose Register 12 */


/** \brief FFB4, CPUx Address General Purpose Register 13 */


/** \brief FFB8, CPUx Address General Purpose Register 14 */


/** \brief FFBC, CPUx Address General Purpose Register 15 */


/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Cpu_Registers_Cfg_Cpu3
 * \{  */
/** \brief 1100, CPUx Flash Configuration Register 0 */


/** \brief 1104, CPUx Flash Configuration Register 1 */


/** \brief 1108, CPUx Flash Configuration Register 2 */


/** \brief 110C, CPUx Flash Configuration Register 3 */


/** \brief 1110, CPUx Flash Configuration Register 4 */


/** \brief D000, CPUx  Reset Register 0 */


/** \brief D004, CPUx  Reset Register 1 */


/** \brief D008, CPUx Reset Clear Register */


/** \brief E000, CPUx Safety Protection SPR Region Lower Address Register 0 */

/** Alias (User Manual Name) for CPU3_RGN0_LA.
* To use register names with standard convension, please use CPU3_RGN0_LA.
*/


/** \brief E004, CPUx Safety Protection SPR Region Upper Address Register 0 */

/** Alias (User Manual Name) for CPU3_RGN0_UA.
* To use register names with standard convension, please use CPU3_RGN0_UA.
*/


/** \brief E008, CPUx Safety Protection SPR Region Write Access Enable Register A0 */

/** Alias (User Manual Name) for CPU3_RGN0_ACCENA.
* To use register names with standard convension, please use CPU3_RGN0_ACCENA.
*/


/** \brief E00C, CPUx Safety Protection SPR Region Write Access Enable Register B0 */

/** Alias (User Manual Name) for CPU3_RGN0_ACCENB.
* To use register names with standard convension, please use CPU3_RGN0_ACCENB.
*/


/** \brief E010, CPUx Safety Protection SPR Region Lower Address Register 1 */

/** Alias (User Manual Name) for CPU3_RGN1_LA.
* To use register names with standard convension, please use CPU3_RGN1_LA.
*/


/** \brief E014, CPUx Safety Protection SPR Region Upper Address Register 1 */

/** Alias (User Manual Name) for CPU3_RGN1_UA.
* To use register names with standard convension, please use CPU3_RGN1_UA.
*/


/** \brief E018, CPUx Safety Protection SPR Region Write Access Enable Register A1 */

/** Alias (User Manual Name) for CPU3_RGN1_ACCENA.
* To use register names with standard convension, please use CPU3_RGN1_ACCENA.
*/


/** \brief E01C, CPUx Safety Protection SPR Region Write Access Enable Register B1 */

/** Alias (User Manual Name) for CPU3_RGN1_ACCENB.
* To use register names with standard convension, please use CPU3_RGN1_ACCENB.
*/


/** \brief E020, CPUx Safety Protection SPR Region Lower Address Register 2 */

/** Alias (User Manual Name) for CPU3_RGN2_LA.
* To use register names with standard convension, please use CPU3_RGN2_LA.
*/


/** \brief E024, CPUx Safety Protection SPR Region Upper Address Register 2 */

/** Alias (User Manual Name) for CPU3_RGN2_UA.
* To use register names with standard convension, please use CPU3_RGN2_UA.
*/


/** \brief E028, CPUx Safety Protection SPR Region Write Access Enable Register A2 */

/** Alias (User Manual Name) for CPU3_RGN2_ACCENA.
* To use register names with standard convension, please use CPU3_RGN2_ACCENA.
*/


/** \brief E02C, CPUx Safety Protection SPR Region Write Access Enable Register B2 */

/** Alias (User Manual Name) for CPU3_RGN2_ACCENB.
* To use register names with standard convension, please use CPU3_RGN2_ACCENB.
*/


/** \brief E030, CPUx Safety Protection SPR Region Lower Address Register 3 */

/** Alias (User Manual Name) for CPU3_RGN3_LA.
* To use register names with standard convension, please use CPU3_RGN3_LA.
*/


/** \brief E034, CPUx Safety Protection SPR Region Upper Address Register 3 */

/** Alias (User Manual Name) for CPU3_RGN3_UA.
* To use register names with standard convension, please use CPU3_RGN3_UA.
*/


/** \brief E038, CPUx Safety Protection SPR Region Write Access Enable Register A3 */

/** Alias (User Manual Name) for CPU3_RGN3_ACCENA.
* To use register names with standard convension, please use CPU3_RGN3_ACCENA.
*/


/** \brief E03C, CPUx Safety Protection SPR Region Write Access Enable Register B3 */

/** Alias (User Manual Name) for CPU3_RGN3_ACCENB.
* To use register names with standard convension, please use CPU3_RGN3_ACCENB.
*/


/** \brief E040, CPUx Safety Protection SPR Region Lower Address Register 4 */

/** Alias (User Manual Name) for CPU3_RGN4_LA.
* To use register names with standard convension, please use CPU3_RGN4_LA.
*/


/** \brief E044, CPUx Safety Protection SPR Region Upper Address Register 4 */

/** Alias (User Manual Name) for CPU3_RGN4_UA.
* To use register names with standard convension, please use CPU3_RGN4_UA.
*/


/** \brief E048, CPUx Safety Protection SPR Region Write Access Enable Register A4 */

/** Alias (User Manual Name) for CPU3_RGN4_ACCENA.
* To use register names with standard convension, please use CPU3_RGN4_ACCENA.
*/


/** \brief E04C, CPUx Safety Protection SPR Region Write Access Enable Register B4 */

/** Alias (User Manual Name) for CPU3_RGN4_ACCENB.
* To use register names with standard convension, please use CPU3_RGN4_ACCENB.
*/


/** \brief E050, CPUx Safety Protection SPR Region Lower Address Register 5 */

/** Alias (User Manual Name) for CPU3_RGN5_LA.
* To use register names with standard convension, please use CPU3_RGN5_LA.
*/


/** \brief E054, CPUx Safety Protection SPR Region Upper Address Register 5 */

/** Alias (User Manual Name) for CPU3_RGN5_UA.
* To use register names with standard convension, please use CPU3_RGN5_UA.
*/


/** \brief E058, CPUx Safety Protection SPR Region Write Access Enable Register A5 */

/** Alias (User Manual Name) for CPU3_RGN5_ACCENA.
* To use register names with standard convension, please use CPU3_RGN5_ACCENA.
*/


/** \brief E05C, CPUx Safety Protection SPR Region Write Access Enable Register B5 */

/** Alias (User Manual Name) for CPU3_RGN5_ACCENB.
* To use register names with standard convension, please use CPU3_RGN5_ACCENB.
*/


/** \brief E060, CPUx Safety Protection SPR Region Lower Address Register 6 */

/** Alias (User Manual Name) for CPU3_RGN6_LA.
* To use register names with standard convension, please use CPU3_RGN6_LA.
*/


/** \brief E064, CPUx Safety Protection SPR Region Upper Address Register 6 */

/** Alias (User Manual Name) for CPU3_RGN6_UA.
* To use register names with standard convension, please use CPU3_RGN6_UA.
*/


/** \brief E068, CPUx Safety Protection SPR Region Write Access Enable Register A6 */

/** Alias (User Manual Name) for CPU3_RGN6_ACCENA.
* To use register names with standard convension, please use CPU3_RGN6_ACCENA.
*/


/** \brief E06C, CPUx Safety Protection SPR Region Write Access Enable Register B6 */

/** Alias (User Manual Name) for CPU3_RGN6_ACCENB.
* To use register names with standard convension, please use CPU3_RGN6_ACCENB.
*/


/** \brief E070, CPUx Safety Protection SPR Region Lower Address Register 7 */

/** Alias (User Manual Name) for CPU3_RGN7_LA.
* To use register names with standard convension, please use CPU3_RGN7_LA.
*/


/** \brief E074, CPUx Safety Protection SPR Region Upper Address Register 7 */

/** Alias (User Manual Name) for CPU3_RGN7_UA.
* To use register names with standard convension, please use CPU3_RGN7_UA.
*/


/** \brief E078, CPUx Safety Protection SPR Region Write Access Enable Register A7 */

/** Alias (User Manual Name) for CPU3_RGN7_ACCENA.
* To use register names with standard convension, please use CPU3_RGN7_ACCENA.
*/


/** \brief E07C, CPUx Safety Protection SPR Region Write Access Enable Register B7 */

/** Alias (User Manual Name) for CPU3_RGN7_ACCENB.
* To use register names with standard convension, please use CPU3_RGN7_ACCENB.
*/


/** \brief E088, CPUx Safety Protection SPR Region Read Access Enable Register A0 */

/** Alias (User Manual Name) for CPU3_SPR_SPROT_RGNACCENA_R0.
* To use register names with standard convension, please use CPU3_SPR_SPROT_RGNACCENA_R0.
*/


/** \brief E08C, CPUx Safety Protection SPR Region Read Access Enable Register B0 */

/** Alias (User Manual Name) for CPU3_SPR_SPROT_RGNACCENB_R0.
* To use register names with standard convension, please use CPU3_SPR_SPROT_RGNACCENB_R0.
*/


/** \brief E098, CPUx Safety Protection SPR Region Read Access Enable Register A1 */

/** Alias (User Manual Name) for CPU3_SPR_SPROT_RGNACCENA_R1.
* To use register names with standard convension, please use CPU3_SPR_SPROT_RGNACCENA_R1.
*/


/** \brief E09C, CPUx Safety Protection SPR Region Read Access Enable Register B1 */

/** Alias (User Manual Name) for CPU3_SPR_SPROT_RGNACCENB_R1.
* To use register names with standard convension, please use CPU3_SPR_SPROT_RGNACCENB_R1.
*/


/** \brief E0A8, CPUx Safety Protection SPR Region Read Access Enable Register A2 */

/** Alias (User Manual Name) for CPU3_SPR_SPROT_RGNACCENA_R2.
* To use register names with standard convension, please use CPU3_SPR_SPROT_RGNACCENA_R2.
*/


/** \brief E0AC, CPUx Safety Protection SPR Region Read Access Enable Register B2 */

/** Alias (User Manual Name) for CPU3_SPR_SPROT_RGNACCENB_R2.
* To use register names with standard convension, please use CPU3_SPR_SPROT_RGNACCENB_R2.
*/


/** \brief E0B8, CPUx Safety Protection SPR Region Read Access Enable Register A3 */

/** Alias (User Manual Name) for CPU3_SPR_SPROT_RGNACCENA_R3.
* To use register names with standard convension, please use CPU3_SPR_SPROT_RGNACCENA_R3.
*/


/** \brief E0BC, CPUx Safety Protection SPR Region Read Access Enable Register B3 */

/** Alias (User Manual Name) for CPU3_SPR_SPROT_RGNACCENB_R3.
* To use register names with standard convension, please use CPU3_SPR_SPROT_RGNACCENB_R3.
*/


/** \brief E0C8, CPUx Safety Protection SPR Region Read Access Enable Register A4 */

/** Alias (User Manual Name) for CPU3_SPR_SPROT_RGNACCENA_R4.
* To use register names with standard convension, please use CPU3_SPR_SPROT_RGNACCENA_R4.
*/


/** \brief E0CC, CPUx Safety Protection SPR Region Read Access Enable Register B4 */

/** Alias (User Manual Name) for CPU3_SPR_SPROT_RGNACCENB_R4.
* To use register names with standard convension, please use CPU3_SPR_SPROT_RGNACCENB_R4.
*/


/** \brief E0D8, CPUx Safety Protection SPR Region Read Access Enable Register A5 */

/** Alias (User Manual Name) for CPU3_SPR_SPROT_RGNACCENA_R5.
* To use register names with standard convension, please use CPU3_SPR_SPROT_RGNACCENA_R5.
*/


/** \brief E0DC, CPUx Safety Protection SPR Region Read Access Enable Register B5 */

/** Alias (User Manual Name) for CPU3_SPR_SPROT_RGNACCENB_R5.
* To use register names with standard convension, please use CPU3_SPR_SPROT_RGNACCENB_R5.
*/


/** \brief E0E8, CPUx Safety Protection SPR Region Read Access Enable Register A6 */

/** Alias (User Manual Name) for CPU3_SPR_SPROT_RGNACCENA_R6.
* To use register names with standard convension, please use CPU3_SPR_SPROT_RGNACCENA_R6.
*/


/** \brief E0EC, CPUx Safety Protection SPR Region Read Access Enable Register B6 */

/** Alias (User Manual Name) for CPU3_SPR_SPROT_RGNACCENB_R6.
* To use register names with standard convension, please use CPU3_SPR_SPROT_RGNACCENB_R6.
*/


/** \brief E0F8, CPUx Safety Protection SPR Region Read Access Enable Register A7 */

/** Alias (User Manual Name) for CPU3_SPR_SPROT_RGNACCENA_R7.
* To use register names with standard convension, please use CPU3_SPR_SPROT_RGNACCENA_R7.
*/


/** \brief E0FC, CPUx Safety Protection SPR Region Read Access Enable Register B7 */

/** Alias (User Manual Name) for CPU3_SPR_SPROT_RGNACCENB_R7.
* To use register names with standard convension, please use CPU3_SPR_SPROT_RGNACCENB_R7.
*/


/** \brief E100, CPUx Safety Protection Register Access Enable Register A */


/** \brief E104, CPUx Safety Protection Region Access Enable Register B */


/** \brief E110, CPUx Safety Protection Region LPB Read Access Enable Register A */


/** \brief E114, CPUx Safety Protection Region LPB Read Access Enable Register B */


/** \brief E200, CPUx Safety Protection DLMU Region Lower Address Register 0 */


/** \brief E204, CPUx Safety protection DLMU Region Upper Address Register 0 */


/** \brief E208, CPUx Safety Protection Region DLMU Write Access Enable Register A0 */

/** Alias (User Manual Name) for CPU3_DLMU_SPROT_RGNACCENA_W0.
* To use register names with standard convension, please use CPU3_DLMU_SPROT_RGNACCENA_W0.
*/


/** \brief E20C, CPUx Safety Protection Region DLMU Write Access Enable Register B0 */

/** Alias (User Manual Name) for CPU3_DLMU_SPROT_RGNACCENB_W0.
* To use register names with standard convension, please use CPU3_DLMU_SPROT_RGNACCENB_W0.
*/


/** \brief E210, CPUx Safety Protection DLMU Region Lower Address Register 1 */


/** \brief E214, CPUx Safety protection DLMU Region Upper Address Register 1 */


/** \brief E218, CPUx Safety Protection Region DLMU Write Access Enable Register A1 */

/** Alias (User Manual Name) for CPU3_DLMU_SPROT_RGNACCENA_W1.
* To use register names with standard convension, please use CPU3_DLMU_SPROT_RGNACCENA_W1.
*/


/** \brief E21C, CPUx Safety Protection Region DLMU Write Access Enable Register B1 */

/** Alias (User Manual Name) for CPU3_DLMU_SPROT_RGNACCENB_W1.
* To use register names with standard convension, please use CPU3_DLMU_SPROT_RGNACCENB_W1.
*/


/** \brief E220, CPUx Safety Protection DLMU Region Lower Address Register 2 */


/** \brief E224, CPUx Safety protection DLMU Region Upper Address Register 2 */


/** \brief E228, CPUx Safety Protection Region DLMU Write Access Enable Register A2 */

/** Alias (User Manual Name) for CPU3_DLMU_SPROT_RGNACCENA_W2.
* To use register names with standard convension, please use CPU3_DLMU_SPROT_RGNACCENA_W2.
*/


/** \brief E22C, CPUx Safety Protection Region DLMU Write Access Enable Register B2 */

/** Alias (User Manual Name) for CPU3_DLMU_SPROT_RGNACCENB_W2.
* To use register names with standard convension, please use CPU3_DLMU_SPROT_RGNACCENB_W2.
*/


/** \brief E230, CPUx Safety Protection DLMU Region Lower Address Register 3 */


/** \brief E234, CPUx Safety protection DLMU Region Upper Address Register 3 */


/** \brief E238, CPUx Safety Protection Region DLMU Write Access Enable Register A3 */

/** Alias (User Manual Name) for CPU3_DLMU_SPROT_RGNACCENA_W3.
* To use register names with standard convension, please use CPU3_DLMU_SPROT_RGNACCENA_W3.
*/


/** \brief E23C, CPUx Safety Protection Region DLMU Write Access Enable Register B3 */

/** Alias (User Manual Name) for CPU3_DLMU_SPROT_RGNACCENB_W3.
* To use register names with standard convension, please use CPU3_DLMU_SPROT_RGNACCENB_W3.
*/


/** \brief E240, CPUx Safety Protection DLMU Region Lower Address Register 4 */


/** \brief E244, CPUx Safety protection DLMU Region Upper Address Register 4 */


/** \brief E248, CPUx Safety Protection Region DLMU Write Access Enable Register A4 */

/** Alias (User Manual Name) for CPU3_DLMU_SPROT_RGNACCENA_W4.
* To use register names with standard convension, please use CPU3_DLMU_SPROT_RGNACCENA_W4.
*/


/** \brief E24C, CPUx Safety Protection Region DLMU Write Access Enable Register B4 */

/** Alias (User Manual Name) for CPU3_DLMU_SPROT_RGNACCENB_W4.
* To use register names with standard convension, please use CPU3_DLMU_SPROT_RGNACCENB_W4.
*/


/** \brief E250, CPUx Safety Protection DLMU Region Lower Address Register 5 */


/** \brief E254, CPUx Safety protection DLMU Region Upper Address Register 5 */


/** \brief E258, CPUx Safety Protection Region DLMU Write Access Enable Register A5 */

/** Alias (User Manual Name) for CPU3_DLMU_SPROT_RGNACCENA_W5.
* To use register names with standard convension, please use CPU3_DLMU_SPROT_RGNACCENA_W5.
*/


/** \brief E25C, CPUx Safety Protection Region DLMU Write Access Enable Register B5 */

/** Alias (User Manual Name) for CPU3_DLMU_SPROT_RGNACCENB_W5.
* To use register names with standard convension, please use CPU3_DLMU_SPROT_RGNACCENB_W5.
*/


/** \brief E260, CPUx Safety Protection DLMU Region Lower Address Register 6 */


/** \brief E264, CPUx Safety protection DLMU Region Upper Address Register 6 */


/** \brief E268, CPUx Safety Protection Region DLMU Write Access Enable Register A6 */

/** Alias (User Manual Name) for CPU3_DLMU_SPROT_RGNACCENA_W6.
* To use register names with standard convension, please use CPU3_DLMU_SPROT_RGNACCENA_W6.
*/


/** \brief E26C, CPUx Safety Protection Region DLMU Write Access Enable Register B6 */

/** Alias (User Manual Name) for CPU3_DLMU_SPROT_RGNACCENB_W6.
* To use register names with standard convension, please use CPU3_DLMU_SPROT_RGNACCENB_W6.
*/


/** \brief E270, CPUx Safety Protection DLMU Region Lower Address Register 7 */


/** \brief E274, CPUx Safety protection DLMU Region Upper Address Register 7 */


/** \brief E278, CPUx Safety Protection Region DLMU Write Access Enable Register A7 */

/** Alias (User Manual Name) for CPU3_DLMU_SPROT_RGNACCENA_W7.
* To use register names with standard convension, please use CPU3_DLMU_SPROT_RGNACCENA_W7.
*/


/** \brief E27C, CPUx Safety Protection Region DLMU Write Access Enable Register B7 */

/** Alias (User Manual Name) for CPU3_DLMU_SPROT_RGNACCENB_W7.
* To use register names with standard convension, please use CPU3_DLMU_SPROT_RGNACCENB_W7.
*/


/** \brief E288, CPUx Safety Protection Region DLMU Read Access Enable Register A0 */

/** Alias (User Manual Name) for CPU3_DLMU_SPROT_RGNACCENA_R0.
* To use register names with standard convension, please use CPU3_DLMU_SPROT_RGNACCENA_R0.
*/


/** \brief E28C, CPUx Safety Protection Region DLMU Read Access Enable Register B0 */

/** Alias (User Manual Name) for CPU3_DLMU_SPROT_RGNACCENB_R0.
* To use register names with standard convension, please use CPU3_DLMU_SPROT_RGNACCENB_R0.
*/


/** \brief E298, CPUx Safety Protection Region DLMU Read Access Enable Register A1 */

/** Alias (User Manual Name) for CPU3_DLMU_SPROT_RGNACCENA_R1.
* To use register names with standard convension, please use CPU3_DLMU_SPROT_RGNACCENA_R1.
*/


/** \brief E29C, CPUx Safety Protection Region DLMU Read Access Enable Register B1 */

/** Alias (User Manual Name) for CPU3_DLMU_SPROT_RGNACCENB_R1.
* To use register names with standard convension, please use CPU3_DLMU_SPROT_RGNACCENB_R1.
*/


/** \brief E2A8, CPUx Safety Protection Region DLMU Read Access Enable Register A2 */

/** Alias (User Manual Name) for CPU3_DLMU_SPROT_RGNACCENA_R2.
* To use register names with standard convension, please use CPU3_DLMU_SPROT_RGNACCENA_R2.
*/


/** \brief E2AC, CPUx Safety Protection Region DLMU Read Access Enable Register B2 */

/** Alias (User Manual Name) for CPU3_DLMU_SPROT_RGNACCENB_R2.
* To use register names with standard convension, please use CPU3_DLMU_SPROT_RGNACCENB_R2.
*/


/** \brief E2B8, CPUx Safety Protection Region DLMU Read Access Enable Register A3 */

/** Alias (User Manual Name) for CPU3_DLMU_SPROT_RGNACCENA_R3.
* To use register names with standard convension, please use CPU3_DLMU_SPROT_RGNACCENA_R3.
*/


/** \brief E2BC, CPUx Safety Protection Region DLMU Read Access Enable Register B3 */

/** Alias (User Manual Name) for CPU3_DLMU_SPROT_RGNACCENB_R3.
* To use register names with standard convension, please use CPU3_DLMU_SPROT_RGNACCENB_R3.
*/


/** \brief E2C8, CPUx Safety Protection Region DLMU Read Access Enable Register A4 */

/** Alias (User Manual Name) for CPU3_DLMU_SPROT_RGNACCENA_R4.
* To use register names with standard convension, please use CPU3_DLMU_SPROT_RGNACCENA_R4.
*/


/** \brief E2CC, CPUx Safety Protection Region DLMU Read Access Enable Register B4 */

/** Alias (User Manual Name) for CPU3_DLMU_SPROT_RGNACCENB_R4.
* To use register names with standard convension, please use CPU3_DLMU_SPROT_RGNACCENB_R4.
*/


/** \brief E2D8, CPUx Safety Protection Region DLMU Read Access Enable Register A5 */

/** Alias (User Manual Name) for CPU3_DLMU_SPROT_RGNACCENA_R5.
* To use register names with standard convension, please use CPU3_DLMU_SPROT_RGNACCENA_R5.
*/


/** \brief E2DC, CPUx Safety Protection Region DLMU Read Access Enable Register B5 */

/** Alias (User Manual Name) for CPU3_DLMU_SPROT_RGNACCENB_R5.
* To use register names with standard convension, please use CPU3_DLMU_SPROT_RGNACCENB_R5.
*/


/** \brief E2E8, CPUx Safety Protection Region DLMU Read Access Enable Register A6 */

/** Alias (User Manual Name) for CPU3_DLMU_SPROT_RGNACCENA_R6.
* To use register names with standard convension, please use CPU3_DLMU_SPROT_RGNACCENA_R6.
*/


/** \brief E2EC, CPUx Safety Protection Region DLMU Read Access Enable Register B6 */

/** Alias (User Manual Name) for CPU3_DLMU_SPROT_RGNACCENB_R6.
* To use register names with standard convension, please use CPU3_DLMU_SPROT_RGNACCENB_R6.
*/


/** \brief E2F8, CPUx Safety Protection Region DLMU Read Access Enable Register A7 */

/** Alias (User Manual Name) for CPU3_DLMU_SPROT_RGNACCENA_R7.
* To use register names with standard convension, please use CPU3_DLMU_SPROT_RGNACCENA_R7.
*/


/** \brief E2FC, CPUx Safety Protection Region DLMU Read Access Enable Register B7 */

/** Alias (User Manual Name) for CPU3_DLMU_SPROT_RGNACCENB_R7.
* To use register names with standard convension, please use CPU3_DLMU_SPROT_RGNACCENB_R7.
*/


/** \brief FB00, CPUx  Overlay Range Select Register */


/** \brief FB10, CPUx Redirected Address Base Register 0 */

/** Alias (User Manual Name) for CPU3_BLK0_RABR.
* To use register names with standard convension, please use CPU3_BLK0_RABR.
*/


/** \brief FB14, CPUx Overlay Target Address Register 0 */

/** Alias (User Manual Name) for CPU3_BLK0_OTAR.
* To use register names with standard convension, please use CPU3_BLK0_OTAR.
*/


/** \brief FB18, CPUx Overlay Mask Register 0 */

/** Alias (User Manual Name) for CPU3_BLK0_OMASK.
* To use register names with standard convension, please use CPU3_BLK0_OMASK.
*/


/** \brief FB1C, CPUx Redirected Address Base Register 1 */

/** Alias (User Manual Name) for CPU3_BLK1_RABR.
* To use register names with standard convension, please use CPU3_BLK1_RABR.
*/


/** \brief FB20, CPUx Overlay Target Address Register 1 */

/** Alias (User Manual Name) for CPU3_BLK1_OTAR.
* To use register names with standard convension, please use CPU3_BLK1_OTAR.
*/


/** \brief FB24, CPUx Overlay Mask Register 1 */

/** Alias (User Manual Name) for CPU3_BLK1_OMASK.
* To use register names with standard convension, please use CPU3_BLK1_OMASK.
*/


/** \brief FB28, CPUx Redirected Address Base Register 2 */

/** Alias (User Manual Name) for CPU3_BLK2_RABR.
* To use register names with standard convension, please use CPU3_BLK2_RABR.
*/


/** \brief FB2C, CPUx Overlay Target Address Register 2 */

/** Alias (User Manual Name) for CPU3_BLK2_OTAR.
* To use register names with standard convension, please use CPU3_BLK2_OTAR.
*/


/** \brief FB30, CPUx Overlay Mask Register 2 */

/** Alias (User Manual Name) for CPU3_BLK2_OMASK.
* To use register names with standard convension, please use CPU3_BLK2_OMASK.
*/


/** \brief FB34, CPUx Redirected Address Base Register 3 */

/** Alias (User Manual Name) for CPU3_BLK3_RABR.
* To use register names with standard convension, please use CPU3_BLK3_RABR.
*/


/** \brief FB38, CPUx Overlay Target Address Register 3 */

/** Alias (User Manual Name) for CPU3_BLK3_OTAR.
* To use register names with standard convension, please use CPU3_BLK3_OTAR.
*/


/** \brief FB3C, CPUx Overlay Mask Register 3 */

/** Alias (User Manual Name) for CPU3_BLK3_OMASK.
* To use register names with standard convension, please use CPU3_BLK3_OMASK.
*/


/** \brief FB40, CPUx Redirected Address Base Register 4 */

/** Alias (User Manual Name) for CPU3_BLK4_RABR.
* To use register names with standard convension, please use CPU3_BLK4_RABR.
*/


/** \brief FB44, CPUx Overlay Target Address Register 4 */

/** Alias (User Manual Name) for CPU3_BLK4_OTAR.
* To use register names with standard convension, please use CPU3_BLK4_OTAR.
*/


/** \brief FB48, CPUx Overlay Mask Register 4 */

/** Alias (User Manual Name) for CPU3_BLK4_OMASK.
* To use register names with standard convension, please use CPU3_BLK4_OMASK.
*/


/** \brief FB4C, CPUx Redirected Address Base Register 5 */

/** Alias (User Manual Name) for CPU3_BLK5_RABR.
* To use register names with standard convension, please use CPU3_BLK5_RABR.
*/


/** \brief FB50, CPUx Overlay Target Address Register 5 */

/** Alias (User Manual Name) for CPU3_BLK5_OTAR.
* To use register names with standard convension, please use CPU3_BLK5_OTAR.
*/


/** \brief FB54, CPUx Overlay Mask Register 5 */

/** Alias (User Manual Name) for CPU3_BLK5_OMASK.
* To use register names with standard convension, please use CPU3_BLK5_OMASK.
*/


/** \brief FB58, CPUx Redirected Address Base Register 6 */

/** Alias (User Manual Name) for CPU3_BLK6_RABR.
* To use register names with standard convension, please use CPU3_BLK6_RABR.
*/


/** \brief FB5C, CPUx Overlay Target Address Register 6 */

/** Alias (User Manual Name) for CPU3_BLK6_OTAR.
* To use register names with standard convension, please use CPU3_BLK6_OTAR.
*/


/** \brief FB60, CPUx Overlay Mask Register 6 */

/** Alias (User Manual Name) for CPU3_BLK6_OMASK.
* To use register names with standard convension, please use CPU3_BLK6_OMASK.
*/


/** \brief FB64, CPUx Redirected Address Base Register 7 */

/** Alias (User Manual Name) for CPU3_BLK7_RABR.
* To use register names with standard convension, please use CPU3_BLK7_RABR.
*/


/** \brief FB68, CPUx Overlay Target Address Register 7 */

/** Alias (User Manual Name) for CPU3_BLK7_OTAR.
* To use register names with standard convension, please use CPU3_BLK7_OTAR.
*/


/** \brief FB6C, CPUx Overlay Mask Register 7 */

/** Alias (User Manual Name) for CPU3_BLK7_OMASK.
* To use register names with standard convension, please use CPU3_BLK7_OMASK.
*/


/** \brief FB70, CPUx Redirected Address Base Register 8 */

/** Alias (User Manual Name) for CPU3_BLK8_RABR.
* To use register names with standard convension, please use CPU3_BLK8_RABR.
*/


/** \brief FB74, CPUx Overlay Target Address Register 8 */

/** Alias (User Manual Name) for CPU3_BLK8_OTAR.
* To use register names with standard convension, please use CPU3_BLK8_OTAR.
*/


/** \brief FB78, CPUx Overlay Mask Register 8 */

/** Alias (User Manual Name) for CPU3_BLK8_OMASK.
* To use register names with standard convension, please use CPU3_BLK8_OMASK.
*/


/** \brief FB7C, CPUx Redirected Address Base Register 9 */

/** Alias (User Manual Name) for CPU3_BLK9_RABR.
* To use register names with standard convension, please use CPU3_BLK9_RABR.
*/


/** \brief FB80, CPUx Overlay Target Address Register 9 */

/** Alias (User Manual Name) for CPU3_BLK9_OTAR.
* To use register names with standard convension, please use CPU3_BLK9_OTAR.
*/


/** \brief FB84, CPUx Overlay Mask Register 9 */

/** Alias (User Manual Name) for CPU3_BLK9_OMASK.
* To use register names with standard convension, please use CPU3_BLK9_OMASK.
*/


/** \brief FB88, CPUx Redirected Address Base Register 10 */

/** Alias (User Manual Name) for CPU3_BLK10_RABR.
* To use register names with standard convension, please use CPU3_BLK10_RABR.
*/


/** \brief FB8C, CPUx Overlay Target Address Register 10 */

/** Alias (User Manual Name) for CPU3_BLK10_OTAR.
* To use register names with standard convension, please use CPU3_BLK10_OTAR.
*/


/** \brief FB90, CPUx Overlay Mask Register 10 */

/** Alias (User Manual Name) for CPU3_BLK10_OMASK.
* To use register names with standard convension, please use CPU3_BLK10_OMASK.
*/


/** \brief FB94, CPUx Redirected Address Base Register 11 */

/** Alias (User Manual Name) for CPU3_BLK11_RABR.
* To use register names with standard convension, please use CPU3_BLK11_RABR.
*/


/** \brief FB98, CPUx Overlay Target Address Register 11 */

/** Alias (User Manual Name) for CPU3_BLK11_OTAR.
* To use register names with standard convension, please use CPU3_BLK11_OTAR.
*/


/** \brief FB9C, CPUx Overlay Mask Register 11 */

/** Alias (User Manual Name) for CPU3_BLK11_OMASK.
* To use register names with standard convension, please use CPU3_BLK11_OMASK.
*/


/** \brief FBA0, CPUx Redirected Address Base Register 12 */

/** Alias (User Manual Name) for CPU3_BLK12_RABR.
* To use register names with standard convension, please use CPU3_BLK12_RABR.
*/


/** \brief FBA4, CPUx Overlay Target Address Register 12 */

/** Alias (User Manual Name) for CPU3_BLK12_OTAR.
* To use register names with standard convension, please use CPU3_BLK12_OTAR.
*/


/** \brief FBA8, CPUx Overlay Mask Register 12 */

/** Alias (User Manual Name) for CPU3_BLK12_OMASK.
* To use register names with standard convension, please use CPU3_BLK12_OMASK.
*/


/** \brief FBAC, CPUx Redirected Address Base Register 13 */

/** Alias (User Manual Name) for CPU3_BLK13_RABR.
* To use register names with standard convension, please use CPU3_BLK13_RABR.
*/


/** \brief FBB0, CPUx Overlay Target Address Register 13 */

/** Alias (User Manual Name) for CPU3_BLK13_OTAR.
* To use register names with standard convension, please use CPU3_BLK13_OTAR.
*/


/** \brief FBB4, CPUx Overlay Mask Register 13 */

/** Alias (User Manual Name) for CPU3_BLK13_OMASK.
* To use register names with standard convension, please use CPU3_BLK13_OMASK.
*/


/** \brief FBB8, CPUx Redirected Address Base Register 14 */

/** Alias (User Manual Name) for CPU3_BLK14_RABR.
* To use register names with standard convension, please use CPU3_BLK14_RABR.
*/


/** \brief FBBC, CPUx Overlay Target Address Register 14 */

/** Alias (User Manual Name) for CPU3_BLK14_OTAR.
* To use register names with standard convension, please use CPU3_BLK14_OTAR.
*/


/** \brief FBC0, CPUx Overlay Mask Register 14 */

/** Alias (User Manual Name) for CPU3_BLK14_OMASK.
* To use register names with standard convension, please use CPU3_BLK14_OMASK.
*/


/** \brief FBC4, CPUx Redirected Address Base Register 15 */

/** Alias (User Manual Name) for CPU3_BLK15_RABR.
* To use register names with standard convension, please use CPU3_BLK15_RABR.
*/


/** \brief FBC8, CPUx Overlay Target Address Register 15 */

/** Alias (User Manual Name) for CPU3_BLK15_OTAR.
* To use register names with standard convension, please use CPU3_BLK15_OTAR.
*/


/** \brief FBCC, CPUx Overlay Mask Register 15 */

/** Alias (User Manual Name) for CPU3_BLK15_OMASK.
* To use register names with standard convension, please use CPU3_BLK15_OMASK.
*/


/** \brief FBD0, CPUx Redirected Address Base Register 16 */

/** Alias (User Manual Name) for CPU3_BLK16_RABR.
* To use register names with standard convension, please use CPU3_BLK16_RABR.
*/


/** \brief FBD4, CPUx Overlay Target Address Register 16 */

/** Alias (User Manual Name) for CPU3_BLK16_OTAR.
* To use register names with standard convension, please use CPU3_BLK16_OTAR.
*/


/** \brief FBD8, CPUx Overlay Mask Register 16 */

/** Alias (User Manual Name) for CPU3_BLK16_OMASK.
* To use register names with standard convension, please use CPU3_BLK16_OMASK.
*/


/** \brief FBDC, CPUx Redirected Address Base Register 17 */

/** Alias (User Manual Name) for CPU3_BLK17_RABR.
* To use register names with standard convension, please use CPU3_BLK17_RABR.
*/


/** \brief FBE0, CPUx Overlay Target Address Register 17 */

/** Alias (User Manual Name) for CPU3_BLK17_OTAR.
* To use register names with standard convension, please use CPU3_BLK17_OTAR.
*/


/** \brief FBE4, CPUx Overlay Mask Register 17 */

/** Alias (User Manual Name) for CPU3_BLK17_OMASK.
* To use register names with standard convension, please use CPU3_BLK17_OMASK.
*/


/** \brief FBE8, CPUx Redirected Address Base Register 18 */

/** Alias (User Manual Name) for CPU3_BLK18_RABR.
* To use register names with standard convension, please use CPU3_BLK18_RABR.
*/


/** \brief FBEC, CPUx Overlay Target Address Register 18 */

/** Alias (User Manual Name) for CPU3_BLK18_OTAR.
* To use register names with standard convension, please use CPU3_BLK18_OTAR.
*/


/** \brief FBF0, CPUx Overlay Mask Register 18 */

/** Alias (User Manual Name) for CPU3_BLK18_OMASK.
* To use register names with standard convension, please use CPU3_BLK18_OMASK.
*/


/** \brief FBF4, CPUx Redirected Address Base Register 19 */

/** Alias (User Manual Name) for CPU3_BLK19_RABR.
* To use register names with standard convension, please use CPU3_BLK19_RABR.
*/


/** \brief FBF8, CPUx Overlay Target Address Register 19 */

/** Alias (User Manual Name) for CPU3_BLK19_OTAR.
* To use register names with standard convension, please use CPU3_BLK19_OTAR.
*/


/** \brief FBFC, CPUx Overlay Mask Register 19 */

/** Alias (User Manual Name) for CPU3_BLK19_OMASK.
* To use register names with standard convension, please use CPU3_BLK19_OMASK.
*/


/** \brief FC00, CPUx Redirected Address Base Register 20 */

/** Alias (User Manual Name) for CPU3_BLK20_RABR.
* To use register names with standard convension, please use CPU3_BLK20_RABR.
*/


/** \brief FC04, CPUx Overlay Target Address Register 20 */

/** Alias (User Manual Name) for CPU3_BLK20_OTAR.
* To use register names with standard convension, please use CPU3_BLK20_OTAR.
*/


/** \brief FC08, CPUx Overlay Mask Register 20 */

/** Alias (User Manual Name) for CPU3_BLK20_OMASK.
* To use register names with standard convension, please use CPU3_BLK20_OMASK.
*/


/** \brief FC0C, CPUx Redirected Address Base Register 21 */

/** Alias (User Manual Name) for CPU3_BLK21_RABR.
* To use register names with standard convension, please use CPU3_BLK21_RABR.
*/


/** \brief FC10, CPUx Overlay Target Address Register 21 */

/** Alias (User Manual Name) for CPU3_BLK21_OTAR.
* To use register names with standard convension, please use CPU3_BLK21_OTAR.
*/


/** \brief FC14, CPUx Overlay Mask Register 21 */

/** Alias (User Manual Name) for CPU3_BLK21_OMASK.
* To use register names with standard convension, please use CPU3_BLK21_OMASK.
*/


/** \brief FC18, CPUx Redirected Address Base Register 22 */

/** Alias (User Manual Name) for CPU3_BLK22_RABR.
* To use register names with standard convension, please use CPU3_BLK22_RABR.
*/


/** \brief FC1C, CPUx Overlay Target Address Register 22 */

/** Alias (User Manual Name) for CPU3_BLK22_OTAR.
* To use register names with standard convension, please use CPU3_BLK22_OTAR.
*/


/** \brief FC20, CPUx Overlay Mask Register 22 */

/** Alias (User Manual Name) for CPU3_BLK22_OMASK.
* To use register names with standard convension, please use CPU3_BLK22_OMASK.
*/


/** \brief FC24, CPUx Redirected Address Base Register 23 */

/** Alias (User Manual Name) for CPU3_BLK23_RABR.
* To use register names with standard convension, please use CPU3_BLK23_RABR.
*/


/** \brief FC28, CPUx Overlay Target Address Register 23 */

/** Alias (User Manual Name) for CPU3_BLK23_OTAR.
* To use register names with standard convension, please use CPU3_BLK23_OTAR.
*/


/** \brief FC2C, CPUx Overlay Mask Register 23 */

/** Alias (User Manual Name) for CPU3_BLK23_OMASK.
* To use register names with standard convension, please use CPU3_BLK23_OMASK.
*/


/** \brief FC30, CPUx Redirected Address Base Register 24 */

/** Alias (User Manual Name) for CPU3_BLK24_RABR.
* To use register names with standard convension, please use CPU3_BLK24_RABR.
*/


/** \brief FC34, CPUx Overlay Target Address Register 24 */

/** Alias (User Manual Name) for CPU3_BLK24_OTAR.
* To use register names with standard convension, please use CPU3_BLK24_OTAR.
*/


/** \brief FC38, CPUx Overlay Mask Register 24 */

/** Alias (User Manual Name) for CPU3_BLK24_OMASK.
* To use register names with standard convension, please use CPU3_BLK24_OMASK.
*/


/** \brief FC3C, CPUx Redirected Address Base Register 25 */

/** Alias (User Manual Name) for CPU3_BLK25_RABR.
* To use register names with standard convension, please use CPU3_BLK25_RABR.
*/


/** \brief FC40, CPUx Overlay Target Address Register 25 */

/** Alias (User Manual Name) for CPU3_BLK25_OTAR.
* To use register names with standard convension, please use CPU3_BLK25_OTAR.
*/


/** \brief FC44, CPUx Overlay Mask Register 25 */

/** Alias (User Manual Name) for CPU3_BLK25_OMASK.
* To use register names with standard convension, please use CPU3_BLK25_OMASK.
*/


/** \brief FC48, CPUx Redirected Address Base Register 26 */

/** Alias (User Manual Name) for CPU3_BLK26_RABR.
* To use register names with standard convension, please use CPU3_BLK26_RABR.
*/


/** \brief FC4C, CPUx Overlay Target Address Register 26 */

/** Alias (User Manual Name) for CPU3_BLK26_OTAR.
* To use register names with standard convension, please use CPU3_BLK26_OTAR.
*/


/** \brief FC50, CPUx Overlay Mask Register 26 */

/** Alias (User Manual Name) for CPU3_BLK26_OMASK.
* To use register names with standard convension, please use CPU3_BLK26_OMASK.
*/


/** \brief FC54, CPUx Redirected Address Base Register 27 */

/** Alias (User Manual Name) for CPU3_BLK27_RABR.
* To use register names with standard convension, please use CPU3_BLK27_RABR.
*/


/** \brief FC58, CPUx Overlay Target Address Register 27 */

/** Alias (User Manual Name) for CPU3_BLK27_OTAR.
* To use register names with standard convension, please use CPU3_BLK27_OTAR.
*/


/** \brief FC5C, CPUx Overlay Mask Register 27 */

/** Alias (User Manual Name) for CPU3_BLK27_OMASK.
* To use register names with standard convension, please use CPU3_BLK27_OMASK.
*/


/** \brief FC60, CPUx Redirected Address Base Register 28 */

/** Alias (User Manual Name) for CPU3_BLK28_RABR.
* To use register names with standard convension, please use CPU3_BLK28_RABR.
*/


/** \brief FC64, CPUx Overlay Target Address Register 28 */

/** Alias (User Manual Name) for CPU3_BLK28_OTAR.
* To use register names with standard convension, please use CPU3_BLK28_OTAR.
*/


/** \brief FC68, CPUx Overlay Mask Register 28 */

/** Alias (User Manual Name) for CPU3_BLK28_OMASK.
* To use register names with standard convension, please use CPU3_BLK28_OMASK.
*/


/** \brief FC6C, CPUx Redirected Address Base Register 29 */

/** Alias (User Manual Name) for CPU3_BLK29_RABR.
* To use register names with standard convension, please use CPU3_BLK29_RABR.
*/


/** \brief FC70, CPUx Overlay Target Address Register 29 */

/** Alias (User Manual Name) for CPU3_BLK29_OTAR.
* To use register names with standard convension, please use CPU3_BLK29_OTAR.
*/


/** \brief FC74, CPUx Overlay Mask Register 29 */

/** Alias (User Manual Name) for CPU3_BLK29_OMASK.
* To use register names with standard convension, please use CPU3_BLK29_OMASK.
*/


/** \brief FC78, CPUx Redirected Address Base Register 30 */

/** Alias (User Manual Name) for CPU3_BLK30_RABR.
* To use register names with standard convension, please use CPU3_BLK30_RABR.
*/


/** \brief FC7C, CPUx Overlay Target Address Register 30 */

/** Alias (User Manual Name) for CPU3_BLK30_OTAR.
* To use register names with standard convension, please use CPU3_BLK30_OTAR.
*/


/** \brief FC80, CPUx Overlay Mask Register 30 */

/** Alias (User Manual Name) for CPU3_BLK30_OMASK.
* To use register names with standard convension, please use CPU3_BLK30_OMASK.
*/


/** \brief FC84, CPUx Redirected Address Base Register 31 */

/** Alias (User Manual Name) for CPU3_BLK31_RABR.
* To use register names with standard convension, please use CPU3_BLK31_RABR.
*/


/** \brief FC88, CPUx Overlay Target Address Register 31 */

/** Alias (User Manual Name) for CPU3_BLK31_OTAR.
* To use register names with standard convension, please use CPU3_BLK31_OTAR.
*/


/** \brief FC8C, CPUx Overlay Mask Register 31 */

/** Alias (User Manual Name) for CPU3_BLK31_OMASK.
* To use register names with standard convension, please use CPU3_BLK31_OMASK.
*/


/** \brief 1030, CPUx SRI Error Generation Register */


/** \brief 8004, CPUx Task Address Space Identifier Register */


/** \brief 8100, CPUx Data Access CacheabilityRegister */


/** \brief 8104, CPUx Code Access CacheabilityRegister */


/** \brief 8108, CPUx  Peripheral Space Identifier register */


/** \brief 9000, CPUx Data Control Register 2 */


/** \brief 900C, CPUx SIST Mode Access Control Register */


/** \brief 9010, CPUx Data Synchronous Trap Register */


/** \brief 9018, CPUx Data Asynchronous Trap Register */


/** \brief 901C, CPUx Data Error Address Register */


/** \brief 9020, CPUx Data Integrity Error Address Register */


/** \brief 9024, CPUx Data Integrity Error Trap Register */


/** \brief 9040, CPUx Data Memory Control Register */


/** \brief 9200, CPUx Program Synchronous Trap Register */


/** \brief 9204, CPUx Program Control 1 */


/** \brief 9208, CPUx Program Control 2 */


/** \brief 920C, CPUx Program Control 0 */


/** \brief 9210, CPUx Program Integrity Error Address Register */


/** \brief 9214, CPUx Program Integrity Error Trap Register */


/** \brief 9400, CPUx Compatibility Control Register */


/** \brief A000, CPUx Trap Control Register */


/** \brief A004, CPUx Trapping Instruction Program Counter Register */


/** \brief A008, CPUx Trapping Instruction Opcode Register */


/** \brief A010, CPUx Trapping Instruction Operand Register */


/** \brief A014, CPUx Trapping Instruction Operand Register */


/** \brief A018, CPUx Trapping Instruction Operand Register */


/** \brief C000, CPUx Data Protection Range 0, Lower Bound Register */


/** \brief C004, CPUx Data Protection Range 0, Upper Bound Register */


/** \brief C008, CPUx Data Protection Range 1, Lower Bound Register */


/** \brief C00C, CPUx Data Protection Range 1, Upper Bound Register */


/** \brief C010, CPUx Data Protection Range 2, Lower Bound Register */


/** \brief C014, CPUx Data Protection Range 2, Upper Bound Register */


/** \brief C018, CPUx Data Protection Range 3, Lower Bound Register */


/** \brief C01C, CPUx Data Protection Range 3, Upper Bound Register */


/** \brief C020, CPUx Data Protection Range 4, Lower Bound Register */


/** \brief C024, CPUx Data Protection Range 4, Upper Bound Register */


/** \brief C028, CPUx Data Protection Range 5, Lower Bound Register */


/** \brief C02C, CPUx Data Protection Range 5, Upper Bound Register */


/** \brief C030, CPUx Data Protection Range 6, Lower Bound Register */


/** \brief C034, CPUx Data Protection Range 6, Upper Bound Register */


/** \brief C038, CPUx Data Protection Range 7, Lower Bound Register */


/** \brief C03C, CPUx Data Protection Range 7, Upper Bound Register */


/** \brief C040, CPUx Data Protection Range 8, Lower Bound Register */


/** \brief C044, CPUx Data Protection Range 8, Upper Bound Register */


/** \brief C048, CPUx Data Protection Range 9, Lower Bound Register */


/** \brief C04C, CPUx Data Protection Range 9, Upper Bound Register */


/** \brief C050, CPUx Data Protection Range 10, Lower Bound Register */


/** \brief C054, CPUx Data Protection Range 10, Upper Bound Register */


/** \brief C058, CPUx Data Protection Range 11, Lower Bound Register */


/** \brief C05C, CPUx Data Protection Range 11, Upper Bound Register */


/** \brief C060, CPUx Data Protection Range 12, Lower Bound Register */


/** \brief C064, CPUx Data Protection Range 12, Upper Bound Register */


/** \brief C068, CPUx Data Protection Range 13, Lower Bound Register */


/** \brief C06C, CPUx Data Protection Range 13, Upper Bound Register */


/** \brief C070, CPUx Data Protection Range 14, Lower Bound Register */


/** \brief C074, CPUx Data Protection Range 14, Upper Bound Register */


/** \brief C078, CPUx Data Protection Range 15, Lower Bound Register */


/** \brief C07C, CPUx Data Protection Range 15, Upper Bound Register */


/** \brief C080, CPUx Data Protection Range 16, Lower Bound Register */


/** \brief C084, CPUx Data Protection Range 16, Upper Bound Register */


/** \brief C088, CPUx Data Protection Range 17, Lower Bound Register */


/** \brief C08C, CPUx Data Protection Range 17, Upper Bound Register */


/** \brief D000, CPUx Code Protection Range 0 Lower Bound Register */


/** \brief D004, CPUx Code Protection Range 0 Upper Bound Register */


/** \brief D008, CPUx Code Protection Range 1 Lower Bound Register */


/** \brief D00C, CPUx Code Protection Range 1 Upper Bound Register */


/** \brief D010, CPUx Code Protection Range 2 Lower Bound Register */


/** \brief D014, CPUx Code Protection Range 2 Upper Bound Register */


/** \brief D018, CPUx Code Protection Range 3 Lower Bound Register */


/** \brief D01C, CPUx Code Protection Range 3 Upper Bound Register */


/** \brief D020, CPUx Code Protection Range 4 Lower Bound Register */


/** \brief D024, CPUx Code Protection Range 4 Upper Bound Register */


/** \brief D028, CPUx Code Protection Range 5 Lower Bound Register */


/** \brief D02C, CPUx Code Protection Range 5 Upper Bound Register */


/** \brief D030, CPUx Code Protection Range 6 Lower Bound Register */


/** \brief D034, CPUx Code Protection Range 6 Upper Bound Register */


/** \brief D038, CPUx Code Protection Range 7 Lower Bound Register */


/** \brief D03C, CPUx Code Protection Range 7 Upper Bound Register */


/** \brief D040, CPUx Code Protection Range 8 Lower Bound Register */


/** \brief D044, CPUx Code Protection Range 8 Upper Bound Register */


/** \brief D048, CPUx Code Protection Range 9 Lower Bound Register */


/** \brief D04C, CPUx Code Protection Range 9 Upper Bound Register */


/** \brief E000, CPUx Code Protection Execute Enable Register Set 0 */


/** \brief E004, CPUx Code Protection Execute Enable Register Set 1 */


/** \brief E008, CPUx Code Protection Execute Enable Register Set 2 */


/** \brief E00C, CPUx Code Protection Execute Enable Register Set 3 */


/** \brief E010, CPUx Data Protection Read Enable Register Set 0 */


/** \brief E014, CPUx Data Protection Read Enable Register Set 1 */


/** \brief E018, CPUx Data Protection Read Enable Register Set 2 */


/** \brief E01C, CPUx Data Protection Read Enable Register Set 3 */


/** \brief E020, CPUx Data Protection Write Enable Register Set 0 */


/** \brief E024, CPUx Data Protection Write Enable Register Set 1 */


/** \brief E028, CPUx Data Protection Write Enable Register Set 2 */


/** \brief E02C, CPUx Data Protection Write Enable Register Set 3 */


/** \brief E040, CPUx Code Protection Execute Enable Register Set 4 */


/** \brief E044, CPUx Code Protection Execute Enable Register Set 5 */


/** \brief E050, CPUx Data Protection Read Enable Register Set 4 */


/** \brief E054, CPUx Data Protection Read Enable Register Set 5 */


/** \brief E060, CPUx Data Protection Write Enable Register Set 4 */


/** \brief E064, CPUx Data Protection Write Enable Register Set 5 */


/** \brief E400, CPUx Temporal Protection System Control Register */


/** \brief E404, CPUx Temporal Protection System Timer Register 0 */


/** \brief E408, CPUx Temporal Protection System Timer Register 1 */


/** \brief E40C, CPUx Temporal Protection System Timer Register 2 */


/** \brief E440, CPUx Exception Entry Timer Load Value */


/** \brief E444, CPUx Exception Entry Timer Current Value */


/** \brief E448, CPUx Exception Exit  Timer Load Value */


/** \brief E44C, CPUx Exception Exit Timer Current Value */


/** \brief E450, CPUx Exception Timer Class Enable Register */


/** \brief E454, CPUx Exception Timer Status Register */


/** \brief E458, CPUx Exception Timer FCX Register */


/** \brief F000, CPUx Trigger Event 0 */

/** Alias (User Manual Name) for CPU3_TR0_EVT.
* To use register names with standard convension, please use CPU3_TR0_EVT.
*/


/** \brief F004, CPUx Trigger Address 0 */

/** Alias (User Manual Name) for CPU3_TR0_ADR.
* To use register names with standard convension, please use CPU3_TR0_ADR.
*/


/** \brief F008, CPUx Trigger Event 1 */

/** Alias (User Manual Name) for CPU3_TR1_EVT.
* To use register names with standard convension, please use CPU3_TR1_EVT.
*/


/** \brief F00C, CPUx Trigger Address 1 */

/** Alias (User Manual Name) for CPU3_TR1_ADR.
* To use register names with standard convension, please use CPU3_TR1_ADR.
*/


/** \brief F010, CPUx Trigger Event 2 */

/** Alias (User Manual Name) for CPU3_TR2_EVT.
* To use register names with standard convension, please use CPU3_TR2_EVT.
*/


/** \brief F014, CPUx Trigger Address 2 */

/** Alias (User Manual Name) for CPU3_TR2_ADR.
* To use register names with standard convension, please use CPU3_TR2_ADR.
*/


/** \brief F018, CPUx Trigger Event 3 */

/** Alias (User Manual Name) for CPU3_TR3_EVT.
* To use register names with standard convension, please use CPU3_TR3_EVT.
*/


/** \brief F01C, CPUx Trigger Address 3 */

/** Alias (User Manual Name) for CPU3_TR3_ADR.
* To use register names with standard convension, please use CPU3_TR3_ADR.
*/


/** \brief F020, CPUx Trigger Event 4 */

/** Alias (User Manual Name) for CPU3_TR4_EVT.
* To use register names with standard convension, please use CPU3_TR4_EVT.
*/


/** \brief F024, CPUx Trigger Address 4 */

/** Alias (User Manual Name) for CPU3_TR4_ADR.
* To use register names with standard convension, please use CPU3_TR4_ADR.
*/


/** \brief F028, CPUx Trigger Event 5 */

/** Alias (User Manual Name) for CPU3_TR5_EVT.
* To use register names with standard convension, please use CPU3_TR5_EVT.
*/


/** \brief F02C, CPUx Trigger Address 5 */

/** Alias (User Manual Name) for CPU3_TR5_ADR.
* To use register names with standard convension, please use CPU3_TR5_ADR.
*/


/** \brief F030, CPUx Trigger Event 6 */

/** Alias (User Manual Name) for CPU3_TR6_EVT.
* To use register names with standard convension, please use CPU3_TR6_EVT.
*/


/** \brief F034, CPUx Trigger Address 6 */

/** Alias (User Manual Name) for CPU3_TR6_ADR.
* To use register names with standard convension, please use CPU3_TR6_ADR.
*/


/** \brief F038, CPUx Trigger Event 7 */

/** Alias (User Manual Name) for CPU3_TR7_EVT.
* To use register names with standard convension, please use CPU3_TR7_EVT.
*/


/** \brief F03C, CPUx Trigger Address 7 */

/** Alias (User Manual Name) for CPU3_TR7_ADR.
* To use register names with standard convension, please use CPU3_TR7_ADR.
*/


/** \brief FC00, CPUx Counter Control */


/** \brief FC04, CPUx CPU Clock Cycle Count */


/** \brief FC08, CPUx Instruction Count */


/** \brief FC0C, CPUx Multi-Count Register 1 */


/** \brief FC10, CPUx Multi-Count Register 2 */


/** \brief FC14, CPUx Multi-Count Register 3 */


/** \brief FD00, CPUx Debug Status Register */


/** \brief FD08, CPUx External Event Register */


/** \brief FD0C, CPUx Core Register Access Event */


/** \brief FD10, CPUx Software Debug Event */


/** \brief FD30, CPUx TriggerAddressx */


/** \brief FD40, CPUx Debug Monitor Start Address */


/** \brief FD44, CPUx Debug Context Save Area Pointer */


/** \brief FD48, CPUx Debug Trap Control Register */


/** \brief FE00, CPUx Previous Context Information Register */


/** \brief FE04, CPUx Program Status Word */


/** \brief FE08, CPUx Program Counter */


/** \brief FE14, CPUx System Configuration Register */


/** \brief FE18, CPUx Identification Register TC1.6.2P */


/** \brief FE1C, CPUx Core Identification Register */


/** \brief FE20, CPUx Base Interrupt Vector Table Pointer */


/** \brief FE24, CPUx Base Trap Vector Table Pointer */


/** \brief FE28, CPUx Interrupt Stack Pointer */


/** \brief FE2C, CPUx Interrupt Control Register */


/** \brief FE38, CPUx Free CSA List Head Pointer */


/** \brief FE3C, CPUx Free CSA List Limit Pointer */


/** \brief FE50, CPUx Customer ID register */


/** \brief FF00, CPUx Data General Purpose Register 0 */


/** \brief FF04, CPUx Data General Purpose Register 1 */


/** \brief FF08, CPUx Data General Purpose Register 2 */


/** \brief FF0C, CPUx Data General Purpose Register 3 */


/** \brief FF10, CPUx Data General Purpose Register 4 */


/** \brief FF14, CPUx Data General Purpose Register 5 */


/** \brief FF18, CPUx Data General Purpose Register 6 */


/** \brief FF1C, CPUx Data General Purpose Register 7 */


/** \brief FF20, CPUx Data General Purpose Register 8 */


/** \brief FF24, CPUx Data General Purpose Register 9 */


/** \brief FF28, CPUx Data General Purpose Register 10 */


/** \brief FF2C, CPUx Data General Purpose Register 11 */


/** \brief FF30, CPUx Data General Purpose Register 12 */


/** \brief FF34, CPUx Data General Purpose Register 13 */


/** \brief FF38, CPUx Data General Purpose Register 14 */


/** \brief FF3C, CPUx Data General Purpose Register 15 */


/** \brief FF80, CPUx Address General Purpose Register 0 */


/** \brief FF84, CPUx Address General Purpose Register 1 */


/** \brief FF88, CPUx Address General Purpose Register 2 */


/** \brief FF8C, CPUx Address General Purpose Register 3 */


/** \brief FF90, CPUx Address General Purpose Register 4 */


/** \brief FF94, CPUx Address General Purpose Register 5 */


/** \brief FF98, CPUx Address General Purpose Register 6 */


/** \brief FF9C, CPUx Address General Purpose Register 7 */


/** \brief FFA0, CPUx Address General Purpose Register 8 */


/** \brief FFA4, CPUx Address General Purpose Register 9 */


/** \brief FFA8, CPUx Address General Purpose Register 10 */


/** \brief FFAC, CPUx Address General Purpose Register 11 */


/** \brief FFB0, CPUx Address General Purpose Register 12 */


/** \brief FFB4, CPUx Address General Purpose Register 13 */


/** \brief FFB8, CPUx Address General Purpose Register 14 */


/** \brief FFBC, CPUx Address General Purpose Register 15 */



/** \}  */

/******************************************************************************/

/******************************************************************************/


#line 58 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\_Impl\\IfxCpu_cfg.h"

/******************************************************************************/
/*-----------------------------------Macros-----------------------------------*/
/******************************************************************************/

/** \brief CPU count
 */


/** \brief Segment number of cachable flash region
 */


/** \brief Segment number of cachable LMU region
 */


/** \brief All cores (coreIDs) mask. This macro can be defined by the user according to the number of core being enabled.
 * So that can be used for syncronisation among multiple cores. In case user didn't define this macro, by default this
 * mask will be generated for all the available cores of the device.
 * e.g:
 * 1. Check for synchronisation between core 0 and core 5
 * # define 0x41U
 * 2. Check for synchronisation between core 0 to core 5
 * # define 0x5FU
 *
 * Note:
 * Core id values read from CORE_ID register will be as shown below. The value
 * indicates the position of the bit needs to be set while building the macro.
 * Core 0: 0
 * Core 1: 1
 * Core 2: 2
 * Core 3: 3
 * Core 4: 4
 * Core 5: 6
 */




/** \brief
 */










/******************************************************************************/
/*-------------------------------Enumerations---------------------------------*/
/******************************************************************************/

/** \brief Halt status
 */
typedef enum
{
    IfxCpu_DBGST_HALT_run  = 0,
    IfxCpu_DBGST_HALT_halt = 1
} IfxCpu_DBGST_HALT;

/** \brief List of the available CPU ids
 */
typedef enum
{
    IfxCpu_Id_0 = 0,  /**< \brief CPU 0 */
    IfxCpu_Id_1 = 1,  /**< \brief CPU 1 */
    IfxCpu_Id_2 = 2,  /**< \brief CPU 2 */
    IfxCpu_Id_3 = 3,  /**< \brief CPU 3 */
    IfxCpu_Id_none    /**< \brief None of the CPU */
} IfxCpu_Id;

/** \brief List of the available CPU resources
 */
typedef enum
{
    IfxCpu_Index_0 = 0,  /**< \brief CPU 0 */
    IfxCpu_Index_1 = 1,  /**< \brief CPU 1 */
    IfxCpu_Index_2 = 2,  /**< \brief CPU 2 */
    IfxCpu_Index_3 = 3,  /**< \brief CPU 3 */
    IfxCpu_Index_none    /**< \brief None of the CPU */
} IfxCpu_Index;

/** \brief Power management status
 */
typedef enum
{
    IfxCpu_PMCSR_PMST_normalMode         = 1,
    IfxCpu_PMCSR_PMST_idleModeRequest    = 2,
    IfxCpu_PMCSR_PMST_idleMode           = 3,
    IfxCpu_PMCSR_PMST_sleepModeRequest   = 4,
    IfxCpu_PMCSR_PMST_standbyModeRequest = 6
} IfxCpu_PMCSR_PMST;

/** \brief List of the available CPU resources
 */
typedef enum
{
    IfxCpu_ResourceCpu_0    = IfxCpu_Index_0,    /**< \brief CPU 0 */
    IfxCpu_ResourceCpu_1    = IfxCpu_Index_1,    /**< \brief CPU 1 */
    IfxCpu_ResourceCpu_2    = IfxCpu_Index_2,    /**< \brief CPU 2 */
    IfxCpu_ResourceCpu_3    = IfxCpu_Index_3,    /**< \brief CPU 3 */
    IfxCpu_ResourceCpu_none = IfxCpu_Index_none  /**< \brief None of the CPU */
} IfxCpu_ResourceCpu;

/******************************************************************************/
/*-------------------Global Exported Variables/Constants----------------------*/
/******************************************************************************/

extern const IfxModule_IndexMap IfxCpu_cfg_indexMap[(4)];


#line 70 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\ee\\..\\Libraries\\iLLD\\TC38A\\Tricore\\Cpu\\Std\\IfxCpu.h"

#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\Infra\\Sfr\\TC38A\\_Reg\\IfxSrc_reg.h"
/**
 * \file IfxSrc_reg.h
 * \brief
 * \copyright Copyright (c) 2020 Infineon Technologies AG. All rights reserved.
 *
 *
 * Version: TC38XA_UM_V1.5.0
 * Specification: TC3xx User Manual V1.5.0
 * MAY BE CHANGED BY USER [yes/no]: No
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * \defgroup IfxSfr_Src_Registers_Cfg Src address
 * \ingroup IfxSfr_Src_Registers
 * 
 * \defgroup IfxSfr_Src_Registers_Cfg_BaseAddress Base address
 * \ingroup IfxSfr_Src_Registers_Cfg
 *
 * \defgroup IfxSfr_Src_Registers_Cfg_Src 2-SRC
 * \ingroup IfxSfr_Src_Registers_Cfg
 *
 *
 */


/******************************************************************************/

#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\Infra\\Sfr\\TC38A\\_Reg\\IfxSrc_regdef.h"
/**
 * \file IfxSrc_regdef.h
 * \brief
 * \copyright Copyright (c) 2020 Infineon Technologies AG. All rights reserved.
 *
 *
 * Version: TC38XA_UM_V1.5.0
 * Specification: TC3xx User Manual V1.5.0
 * MAY BE CHANGED BY USER [yes/no]: No
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * \defgroup IfxSfr_Src_Registers Src Registers
 * \ingroup IfxSfr
 * 
 * \defgroup IfxSfr_Src_Registers_Bitfields Bitfields
 * \ingroup IfxSfr_Src_Registers
 * 
 * \defgroup IfxSfr_Src_Registers_union Register unions
 * \ingroup IfxSfr_Src_Registers
 * 
 * \defgroup IfxSfr_Src_Registers_struct Memory map
 * \ingroup IfxSfr_Src_Registers
 */


/******************************************************************************/

/******************************************************************************/

/******************************************************************************/

/******************************************************************************/


/** \addtogroup IfxSfr_Src_Registers_Bitfields
 * \{  */
/** \brief  */
typedef struct _Ifx_SRC_SRCR_Bits
{
    Ifx_UReg_32Bit SRPN:8;            /**< \brief [7:0] Service Request Priority Number (rw) */
    Ifx_UReg_32Bit reserved_8:2;      /**< \brief [9:8] \internal Reserved */
    Ifx_UReg_32Bit SRE:1;             /**< \brief [10:10] Service Request Enable (rw) */
    Ifx_UReg_32Bit TOS:3;             /**< \brief [13:11] Type of Service Control (rw) */
    Ifx_UReg_32Bit reserved_14:2;     /**< \brief [15:14] \internal Reserved */
    Ifx_UReg_32Bit ECC:5;             /**< \brief [20:16] Error Correction Code (rwh) */
    Ifx_UReg_32Bit reserved_21:3;     /**< \brief [23:21] \internal Reserved */
    Ifx_UReg_32Bit SRR:1;             /**< \brief [24:24] Service Request Flag (rh) */
    Ifx_UReg_32Bit CLRR:1;            /**< \brief [25:25] Request Clear Bit (w) */
    Ifx_UReg_32Bit SETR:1;            /**< \brief [26:26] Request Set Bit (w) */
    Ifx_UReg_32Bit IOV:1;             /**< \brief [27:27] Interrupt Trigger Overflow Bit (rh) */
    Ifx_UReg_32Bit IOVCLR:1;          /**< \brief [28:28] Interrupt Trigger Overflow Clear Bit (w) */
    Ifx_UReg_32Bit SWS:1;             /**< \brief [29:29] SW Sticky Bit (rh) */
    Ifx_UReg_32Bit SWSCLR:1;          /**< \brief [30:30] SW Sticky Clear Bit (w) */
    Ifx_UReg_32Bit reserved_31:1;     /**< \brief [31:31] \internal Reserved */
} Ifx_SRC_SRCR_Bits;

/** \}  */
/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_src_Registers_union
 * \{   */
/** \brief    */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SRC_SRCR_Bits B;              /**< \brief Bitfield access */
} Ifx_SRC_SRCR;

/** \}  */

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_CPU_CPU_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief CPU object */
typedef volatile struct _Ifx_SRC_CPU_CPU
{
       Ifx_SRC_SRCR                        SB;                     /**< \brief 0, CPU${x} Software Breakpoint Service Request*/
} Ifx_SRC_CPU_CPU;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_CPU_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief CPU object */
typedef volatile struct _Ifx_SRC_CPU
{
       Ifx_SRC_CPU_CPU                     CPU[4];                 /**< \brief 0, CPU${x} Software Breakpoint Service Request*/
} Ifx_SRC_CPU;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_CERBERUS_CERBERUS_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief CERBERUS object */
typedef volatile struct _Ifx_SRC_CERBERUS_CERBERUS
{
       Ifx_SRC_SRCR                        SR[2];                  /**< \brief 0, Cerberus Service Request ${y}*/
} Ifx_SRC_CERBERUS_CERBERUS;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_CERBERUS_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief CERBERUS object */
typedef volatile struct _Ifx_SRC_CERBERUS
{
       Ifx_SRC_CERBERUS_CERBERUS           CERBERUS;               /**< \brief 0, */
} Ifx_SRC_CERBERUS;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_ASCLIN_ASCLIN_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief ASCLIN object */
typedef volatile struct _Ifx_SRC_ASCLIN_ASCLIN
{
       Ifx_SRC_SRCR                        TX;                     /**< \brief 0, ASCLIN${x} Transmit Service Request*/
       Ifx_SRC_SRCR                        RX;                     /**< \brief 4, ASCLIN${x} Receive Service Request*/
       Ifx_SRC_SRCR                        ERR;                    /**< \brief 8, ASCLIN${x} Error Service Request*/
} Ifx_SRC_ASCLIN_ASCLIN;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_ASCLIN_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief ASCLIN object */
typedef volatile struct _Ifx_SRC_ASCLIN
{
       Ifx_SRC_ASCLIN_ASCLIN               ASCLIN[12];             /**< \brief 0, ASCLIN${x} Error Service Request*/
} Ifx_SRC_ASCLIN;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_QSPI_QSPI_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief QSPI object */
typedef volatile struct _Ifx_SRC_QSPI_QSPI
{
       Ifx_SRC_SRCR                        TX;                     /**< \brief 0, QSPI${x} Transmit Service Request*/
       Ifx_SRC_SRCR                        RX;                     /**< \brief 4, QSPI${x} Receive Service Request*/
       Ifx_SRC_SRCR                        ERR;                    /**< \brief 8, QSPI${x} Error Service Request*/
       Ifx_SRC_SRCR                        PT;                     /**< \brief C, QSPI${x} Phase Transition Service Request*/
       Ifx_SRC_SRCR                        U;                      /**< \brief 10, QSPI${x} User Defined Service Request*/
} Ifx_SRC_QSPI_QSPI;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_QSPI_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief QSPI object */
typedef volatile struct _Ifx_SRC_QSPI
{
       Ifx_SRC_QSPI_QSPI                   QSPI[5];                /**< \brief 0, QSPI${x} User Defined Service Request*/
} Ifx_SRC_QSPI;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_HSCT_HSCT_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief HSCT object */
typedef volatile struct _Ifx_SRC_HSCT_HSCT
{
       Ifx_SRC_SRCR                        SR;                     /**< \brief 0, HSCT0 Service Request*/
} Ifx_SRC_HSCT_HSCT;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_HSCT_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief HSCT object */
typedef volatile struct _Ifx_SRC_HSCT
{
       Ifx_SRC_HSCT_HSCT                   HSCT[1];                /**< \brief 0, HSCT0 Service Request*/
} Ifx_SRC_HSCT;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_HSSL_HSSL_CH_struct
 * \{  */
/******************************************************************************/
/** \name Object L3
 * \{  */
/** \brief CH object */
typedef volatile struct _Ifx_SRC_HSSL_HSSL_CH
{
       Ifx_SRC_SRCR                        COK;                    /**< \brief 0, HSSL0 Channel ${y} OK Service Request*/
       Ifx_SRC_SRCR                        RDI;                    /**< \brief 4, HSSL0 Channel ${y} Read Data Service Request*/
       Ifx_SRC_SRCR                        ERR;                    /**< \brief 8, HSSL0 Channel ${y} Error Service Request*/
       Ifx_SRC_SRCR                        TRG;                    /**< \brief C, HSSL0 Channel ${y} Trigger Interrupt Service Request*/
} Ifx_SRC_HSSL_HSSL_CH;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_HSSL_HSSL_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief HSSL object */
typedef volatile struct _Ifx_SRC_HSSL_HSSL
{
       Ifx_SRC_HSSL_HSSL_CH                CH[4];                  /**< \brief 0, HSSL0 Channel ${y} Trigger Interrupt Service Request*/
       Ifx_SRC_SRCR                        EXI;                    /**< \brief 40, HSSL${x} Exception Service Request*/
} Ifx_SRC_HSSL_HSSL;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_HSSL_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief HSSL object */
typedef volatile struct _Ifx_SRC_HSSL
{
       Ifx_SRC_HSSL_HSSL                   HSSL[1];                /**< \brief 0, HSSL${x} Exception Service Request*/
} Ifx_SRC_HSSL;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_I2C_I2C_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief I2C object */
typedef volatile struct _Ifx_SRC_I2C_I2C
{
       Ifx_SRC_SRCR                        DTR;                    /**< \brief 0, I2C${x} Data Transfer Request*/
       Ifx_SRC_SRCR                        ERR;                    /**< \brief 4, I2C${x} Error Service Request*/
       Ifx_SRC_SRCR                        P;                      /**< \brief 8, I2C${x} Protocol Service Request*/
       Ifx_UReg_8Bit                       reserved_C[4];          /**< \brief C, \internal Reserved */
} Ifx_SRC_I2C_I2C;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_I2C_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief I2C object */
typedef volatile struct _Ifx_SRC_I2C
{
       Ifx_SRC_I2C_I2C                     I2C[2];                 /**< \brief 0, */
} Ifx_SRC_I2C;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_SENT_SENT_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief SENT object */
typedef volatile struct _Ifx_SRC_SENT_SENT
{
       Ifx_SRC_SRCR                        SR;                     /**< \brief 0, SENT TRIG${x} Service Request*/
} Ifx_SRC_SENT_SENT;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_SENT_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief SENT object */
typedef volatile struct _Ifx_SRC_SENT
{
       Ifx_SRC_SENT_SENT                   SENT[10];               /**< \brief 0, SENT TRIG${x} Service Request*/
} Ifx_SRC_SENT;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_MSC_MSC_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief MSC object */
typedef volatile struct _Ifx_SRC_MSC_MSC
{
       Ifx_SRC_SRCR                        SR[5];                  /**< \brief 0, MSC${x} Service Request ${y}*/
} Ifx_SRC_MSC_MSC;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_MSC_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief MSC object */
typedef volatile struct _Ifx_SRC_MSC
{
       Ifx_SRC_MSC_MSC                     MSC[3];                 /**< \brief 0, */
} Ifx_SRC_MSC;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_CCU6_CCU_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief CCU object */
typedef volatile struct _Ifx_SRC_CCU6_CCU
{
       Ifx_SRC_SRCR                        SR[4];                  /**< \brief 0, CCU${x} Service Request ${y}*/
} Ifx_SRC_CCU6_CCU;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_CCU6_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief CCU6 object */
typedef volatile struct _Ifx_SRC_CCU6
{
       Ifx_SRC_CCU6_CCU                    CCU[2];                 /**< \brief 0, */
} Ifx_SRC_CCU6;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_GPT12_GPT12_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief GPT12 object */
typedef volatile struct _Ifx_SRC_GPT12_GPT12
{
       Ifx_SRC_SRCR                        CIRQ;                   /**< \brief 0, GPT120 CAPREL Service Request*/
       Ifx_SRC_SRCR                        T2;                     /**< \brief 4, GPT120 Timer 2 Service Request*/
       Ifx_SRC_SRCR                        T3;                     /**< \brief 8, GPT120 Timer 3 Service Request*/
       Ifx_SRC_SRCR                        T4;                     /**< \brief C, GPT120 Timer 4 Service Request*/
       Ifx_SRC_SRCR                        T5;                     /**< \brief 10, GPT120 Timer 5 Service Request*/
       Ifx_SRC_SRCR                        T6;                     /**< \brief 14, GPT120 Timer 6 Service Request*/
} Ifx_SRC_GPT12_GPT12;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_GPT12_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief GPT12 object */
typedef volatile struct _Ifx_SRC_GPT12
{
       Ifx_SRC_GPT12_GPT12                 GPT12[1];               /**< \brief 0, GPT120 Timer 6 Service Request*/
} Ifx_SRC_GPT12;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_STM_STM_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief STM object */
typedef volatile struct _Ifx_SRC_STM_STM
{
       Ifx_SRC_SRCR                        SR[2];                  /**< \brief 0, System Timer ${x} Service Request ${y}*/
} Ifx_SRC_STM_STM;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_STM_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief STM object */
typedef volatile struct _Ifx_SRC_STM
{
       Ifx_SRC_STM_STM                     STM[4];                 /**< \brief 0, */
} Ifx_SRC_STM;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_FCE_FCE0_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief FCE0 object */
typedef volatile struct _Ifx_SRC_FCE_FCE0
{
       Ifx_SRC_SRCR                        SR;                     /**< \brief 0, FCE0 Error Service Request*/
} Ifx_SRC_FCE_FCE0;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_FCE_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief FCE object */
typedef volatile struct _Ifx_SRC_FCE
{
       Ifx_SRC_FCE_FCE0                    FCE0;                   /**< \brief 0, FCE0 Error Service Request*/
} Ifx_SRC_FCE;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_DMA_DMA_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief DMA object */
typedef volatile struct _Ifx_SRC_DMA_DMA
{
       Ifx_SRC_SRCR                        ERR[4];                 /**< \brief 0, DMA Error Service Request ${y}*/
       Ifx_UReg_8Bit                       reserved_10[32];        /**< \brief 10, \internal Reserved */
       Ifx_SRC_SRCR                        CH[128];                /**< \brief 30, DMA Channel  ${y} Service Request*/
} Ifx_SRC_DMA_DMA;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_DMA_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief DMA object */
typedef volatile struct _Ifx_SRC_DMA
{
       Ifx_SRC_DMA_DMA                     DMA[1];                 /**< \brief 0, */
} Ifx_SRC_DMA;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_GETH_GETH_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief GETH object */
typedef volatile struct _Ifx_SRC_GETH_GETH
{
       Ifx_SRC_SRCR                        SR[10];                 /**< \brief 0, GETH Service Request ${y}*/
} Ifx_SRC_GETH_GETH;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_GETH_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief GETH object */
typedef volatile struct _Ifx_SRC_GETH
{
       Ifx_SRC_GETH_GETH                   GETH[1];                /**< \brief 0, */
} Ifx_SRC_GETH;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_CAN_CAN_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief CAN object */
typedef volatile struct _Ifx_SRC_CAN_CAN
{
       Ifx_SRC_SRCR                        INT[16];                /**< \brief 0, CAN${x} Service Request ${y}*/
} Ifx_SRC_CAN_CAN;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_CAN_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief CAN object */
typedef volatile struct _Ifx_SRC_CAN
{
       Ifx_SRC_CAN_CAN                     CAN[3];                 /**< \brief 0, */
} Ifx_SRC_CAN;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_VADC_G_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief G object */
typedef volatile struct _Ifx_SRC_VADC_G
{
       Ifx_SRC_SRCR                        SR0;                    /**< \brief 0, EVADC Group ${x} Service Request ${y}*/
       Ifx_SRC_SRCR                        SR1;                    /**< \brief 4, EVADC Group ${x} Service Request ${y}*/
       Ifx_SRC_SRCR                        SR2;                    /**< \brief 8, EVADC Group ${x} Service Request ${y}*/
       Ifx_SRC_SRCR                        SR3;                    /**< \brief C, EVADC Group ${x} Service Request ${y}*/
} Ifx_SRC_VADC_G;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_VADC_FC_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief FC object */
typedef volatile struct _Ifx_SRC_VADC_FC
{
       Ifx_SRC_SRCR                        SR0;                    /**< \brief 0, EVADC Fast Compare ${x} Service Request SR0*/
} Ifx_SRC_VADC_FC;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/


/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_VADC_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief VADC object */
typedef volatile struct _Ifx_SRC_VADC
{
       Ifx_SRC_VADC_G                      G[12];                  /**< \brief 0, */
       Ifx_SRC_VADC_FC                     FC[4];                  /**< \brief C0, EVADC Fast Compare ${x} Service Request SR0*/
       Ifx_UReg_8Bit                       reserved_D0[16];        /**< \brief D0, \internal Reserved */
       Ifx_SRC_VADC_G                      CG[2];                  /**< \brief E0, */
} Ifx_SRC_VADC;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_DSADC_DSADC_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief DSADC object */
typedef volatile struct _Ifx_SRC_DSADC_DSADC
{
       Ifx_SRC_SRCR                        SRM;                    /**< \brief 0, DSADC SRM${x} Service Request*/
       Ifx_SRC_SRCR                        SRA;                    /**< \brief 4, DSADC SRA${x} Service Request*/
} Ifx_SRC_DSADC_DSADC;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_DSADC_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief DSADC object */
typedef volatile struct _Ifx_SRC_DSADC
{
       Ifx_SRC_DSADC_DSADC                 DSADC[10];              /**< \brief 0, DSADC SRA${x} Service Request*/
} Ifx_SRC_DSADC;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/



/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_ERAY_ERAY_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief ERAY object */
typedef volatile struct _Ifx_SRC_ERAY_ERAY
{
       Ifx_SRC_SRCR                        INT0;                   /**< \brief 0, E-RAY ${x} Service Request 0*/
       Ifx_SRC_SRCR                        INT1;                   /**< \brief 4, E-RAY ${x} Service Request 1*/
       Ifx_SRC_SRCR                        TINT0;                  /**< \brief 8, E-RAY ${x} Timer Interrupt 0 Service Request*/
       Ifx_SRC_SRCR                        TINT1;                  /**< \brief C, E-RAY ${x} Timer Interrupt 1 Service Request*/
       Ifx_SRC_SRCR                        NDAT0;                  /**< \brief 10, E-RAY ${x} New Data 0 Service Request*/
       Ifx_SRC_SRCR                        NDAT1;                  /**< \brief 14, E-RAY ${x} New Data 1 Service Request*/
       Ifx_SRC_SRCR                        MBSC0;                  /**< \brief 18, E-RAY ${x} Message Buffer Status Changed 0 Service Request*/
       Ifx_SRC_SRCR                        MBSC1;                  /**< \brief 1C, E-RAY ${x} Message Buffer Status Changed 1 Service Request*/
       Ifx_SRC_SRCR                        OBUSY;                  /**< \brief 20, E-RAY ${x} Output Buffer Busy*/
       Ifx_SRC_SRCR                        IBUSY;                  /**< \brief 24, E-RAY ${x} Input Buffer Busy*/
       Ifx_UReg_8Bit                       reserved_28[8];         /**< \brief 28, \internal Reserved */
} Ifx_SRC_ERAY_ERAY;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_ERAY_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief ERAY object */
typedef volatile struct _Ifx_SRC_ERAY
{
       Ifx_SRC_ERAY_ERAY                   ERAY[2];                /**< \brief 0, */
} Ifx_SRC_ERAY;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_HSM_HSM_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief HSM object */
typedef volatile struct _Ifx_SRC_HSM_HSM
{
       Ifx_SRC_SRCR                        HSM[2];                 /**< \brief 0, HSM Service Request ${y}*/
} Ifx_SRC_HSM_HSM;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_HSM_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief HSM object */
typedef volatile struct _Ifx_SRC_HSM
{
       Ifx_SRC_HSM_HSM                     HSM[1];                 /**< \brief 0, */
} Ifx_SRC_HSM;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_SCU_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief SCU object */
typedef volatile struct _Ifx_SRC_SCU
{
       Ifx_SRC_SRCR                        SCUERU[4];              /**< \brief 0, SCU ERU Service Request ${x}*/
} Ifx_SRC_SCU;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_PMS_PMS_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief PMS object */
typedef volatile struct _Ifx_SRC_PMS_PMS
{
       Ifx_SRC_SRCR                        SR;                     /**< \brief 0, Power Management System Service Request ${x}*/
} Ifx_SRC_PMS_PMS;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_PMS_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief PMS object */
typedef volatile struct _Ifx_SRC_PMS
{
       Ifx_SRC_PMS_PMS                     PMS[4];                 /**< \brief 0, Power Management System Service Request ${x}*/
} Ifx_SRC_PMS;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_SMU_SMU_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief SMU object */
typedef volatile struct _Ifx_SRC_SMU_SMU
{
       Ifx_SRC_SRCR                        SR[3];                  /**< \brief 0, SMU Service Request ${y}*/
} Ifx_SRC_SMU_SMU;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_SMU_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief SMU object */
typedef volatile struct _Ifx_SRC_SMU
{
       Ifx_SRC_SMU_SMU                     SMU[1];                 /**< \brief 0, */
} Ifx_SRC_SMU;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_PSI5_PSI5_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief PSI5 object */
typedef volatile struct _Ifx_SRC_PSI5_PSI5
{
       Ifx_SRC_SRCR                        SR[8];                  /**< \brief 0, PSI5 Service Request ${y}*/
} Ifx_SRC_PSI5_PSI5;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_PSI5_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief PSI5 object */
typedef volatile struct _Ifx_SRC_PSI5
{
       Ifx_SRC_PSI5_PSI5                   PSI5[1];                /**< \brief 0, */
} Ifx_SRC_PSI5;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_DAM_DAM_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief DAM object */
typedef volatile struct _Ifx_SRC_DAM_DAM
{
       Ifx_SRC_SRCR                        LI0;                    /**< \brief 0, DAM${x} Limit 0 Service Request*/
       Ifx_SRC_SRCR                        RI0;                    /**< \brief 4, DAM${x} Ready 0 Service Reques*/
       Ifx_SRC_SRCR                        LI1;                    /**< \brief 8, DAM${x} Limit 1 Service Request*/
       Ifx_SRC_SRCR                        RI1;                    /**< \brief C, DAM${x} Ready 1 Service Request*/
       Ifx_SRC_SRCR                        DR;                     /**< \brief 10, DAM${x} DMA Ready Service Request*/
       Ifx_SRC_SRCR                        ERR;                    /**< \brief 14, DAM${x} Error Service Request*/
} Ifx_SRC_DAM_DAM;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_DAM_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief DAM object */
typedef volatile struct _Ifx_SRC_DAM
{
       Ifx_SRC_DAM_DAM                     DAM[1];                 /**< \brief 0, */
} Ifx_SRC_DAM;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_PSI5S_PSI5S_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief PSI5S object */
typedef volatile struct _Ifx_SRC_PSI5S_PSI5S
{
       Ifx_SRC_SRCR                        SR[8];                  /**< \brief 0, PSI5-S Service Request ${y}*/
} Ifx_SRC_PSI5S_PSI5S;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_PSI5S_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief PSI5S object */
typedef volatile struct _Ifx_SRC_PSI5S
{
       Ifx_SRC_PSI5S_PSI5S                 PSI5S[1];               /**< \brief 0, */
} Ifx_SRC_PSI5S;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_GPSR_GPSR_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief GPSR object */
typedef volatile struct _Ifx_SRC_GPSR_GPSR
{
       Ifx_SRC_SRCR                        SR[8];                  /**< \brief 0, General Purpose Group ${x} Service Request ${y}*/
} Ifx_SRC_GPSR_GPSR;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_GPSR_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief GPSR object */
typedef volatile struct _Ifx_SRC_GPSR
{
       Ifx_SRC_GPSR_GPSR                   GPSR[4];                /**< \brief 0, */
} Ifx_SRC_GPSR;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/











/******************************************************************************/
/** \addtogroup IfxSfr_Src_Registers_struct
 * \{  */
/******************************************************************************/
/** \name Object L0
 * \{  */

/** \brief SRC object */
typedef volatile struct _Ifx_SRC
{
       Ifx_SRC_CPU                         CPU;                    /**< \brief 0, */
       Ifx_UReg_8Bit                       reserved_10[16];        /**< \brief 10, \internal Reserved */
       Ifx_SRC_SRCR                        SBCU;                   /**< \brief 20, SBCU Service Request (SPB Bus Control Unit)*/
       Ifx_UReg_8Bit                       reserved_24[12];        /**< \brief 24, \internal Reserved */
       Ifx_SRC_SRCR                        XBAR0;                  /**< \brief 30, SRI Domain 0 Service Request*/
       Ifx_UReg_8Bit                       reserved_34[12];        /**< \brief 34, \internal Reserved */
       Ifx_SRC_CERBERUS                    CERBERUS;               /**< \brief 40, */
       Ifx_UReg_8Bit                       reserved_48[8];         /**< \brief 48, \internal Reserved */
       Ifx_SRC_ASCLIN                      ASCLIN;                 /**< \brief 50, */
       Ifx_UReg_8Bit                       reserved_E0[12];        /**< \brief E0, \internal Reserved */
       Ifx_SRC_SRCR                        MTUDONE;                /**< \brief EC, MTU Done Service Request*/
       Ifx_SRC_QSPI                        QSPI;                   /**< \brief F0, */
       Ifx_UReg_8Bit                       reserved_154[44];       /**< \brief 154, \internal Reserved */
       Ifx_SRC_HSCT                        HSCT;                   /**< \brief 180, */
       Ifx_UReg_8Bit                       reserved_184[12];       /**< \brief 184, \internal Reserved */
       Ifx_SRC_HSSL                        HSSL;                   /**< \brief 190, */
       Ifx_UReg_8Bit                       reserved_1D4[76];       /**< \brief 1D4, \internal Reserved */
       Ifx_SRC_I2C                         I2C;                    /**< \brief 220, */
       Ifx_SRC_SENT                        SENT;                   /**< \brief 240, */
       Ifx_UReg_8Bit                       reserved_268[8];        /**< \brief 268, \internal Reserved */
       Ifx_SRC_MSC                         MSC;                    /**< \brief 270, */
       Ifx_UReg_8Bit                       reserved_2AC[20];       /**< \brief 2AC, \internal Reserved */
       Ifx_SRC_CCU6                        CCU6;                   /**< \brief 2C0, */
       Ifx_SRC_GPT12                       GPT12;                  /**< \brief 2E0, */
       Ifx_UReg_8Bit                       reserved_2F8[8];        /**< \brief 2F8, \internal Reserved */
       Ifx_SRC_STM                         STM;                    /**< \brief 300, */
       Ifx_UReg_8Bit                       reserved_320[16];       /**< \brief 320, \internal Reserved */
       Ifx_SRC_FCE                         FCE;                    /**< \brief 330, */
       Ifx_UReg_8Bit                       reserved_334[12];       /**< \brief 334, \internal Reserved */
       Ifx_SRC_DMA                         DMA;                    /**< \brief 340, */
       Ifx_UReg_8Bit                       reserved_570[16];       /**< \brief 570, \internal Reserved */
       Ifx_SRC_GETH                        GETH;                   /**< \brief 580, */
       Ifx_UReg_8Bit                       reserved_5A8[8];        /**< \brief 5A8, \internal Reserved */
       Ifx_SRC_CAN                         CAN;                    /**< \brief 5B0, */
       Ifx_SRC_VADC                        VADC;                   /**< \brief 670, */
       Ifx_SRC_DSADC                       DSADC;                  /**< \brief 770, */
       Ifx_UReg_8Bit                       reserved_7C0[32];       /**< \brief 7C0, \internal Reserved */
       Ifx_SRC_ASCLIN_ASCLIN               ASCLIN12;               /**< \brief 7E0, ASCLIN12 Error Service Request*/
       Ifx_SRC_ASCLIN_ASCLIN               ASCLIN13;               /**< \brief 7EC, ASCLIN13 Error Service Request*/
       Ifx_UReg_8Bit                       reserved_7F8[8];        /**< \brief 7F8, \internal Reserved */
       Ifx_SRC_ERAY                        ERAY;                   /**< \brief 800, */
       Ifx_SRC_SRCR                        DMUHOST;                /**< \brief 860, DMU Host Service Request*/
       Ifx_SRC_SRCR                        DMUFSI;                 /**< \brief 864, DMU FSI Service Request*/
       Ifx_UReg_8Bit                       reserved_868[8];        /**< \brief 868, \internal Reserved */
       Ifx_SRC_HSM                         HSM;                    /**< \brief 870, */
       Ifx_UReg_8Bit                       reserved_878[8];        /**< \brief 878, \internal Reserved */
       Ifx_SRC_SCU                         SCU;                    /**< \brief 880, */
       Ifx_UReg_8Bit                       reserved_890[28];       /**< \brief 890, \internal Reserved */
       Ifx_SRC_SRCR                        PMSDTS;                 /**< \brief 8AC, PMS DTS Service Request*/
       Ifx_SRC_PMS                         PMS;                    /**< \brief 8B0, */
       Ifx_SRC_SRCR                        SCR;                    /**< \brief 8C0, Stand By Controller Service Request*/
       Ifx_UReg_8Bit                       reserved_8C4[12];       /**< \brief 8C4, \internal Reserved */
       Ifx_SRC_SMU                         SMU;                    /**< \brief 8D0, */
       Ifx_UReg_8Bit                       reserved_8DC[4];        /**< \brief 8DC, \internal Reserved */
       Ifx_SRC_PSI5                        PSI5;                   /**< \brief 8E0, */
       Ifx_UReg_8Bit                       reserved_900[16];       /**< \brief 900, \internal Reserved */
       Ifx_SRC_DAM                         DAM;                    /**< \brief 910, */
       Ifx_UReg_8Bit                       reserved_928[40];       /**< \brief 928, \internal Reserved */
       Ifx_SRC_PSI5S                       PSI5S;                  /**< \brief 950, */
       Ifx_UReg_8Bit                       reserved_970[32];       /**< \brief 970, \internal Reserved */
       Ifx_SRC_GPSR                        GPSR;                   /**< \brief 990, */
       Ifx_UReg_8Bit                       reserved_A10[64];       /**< \brief A10, \internal Reserved */
       Ifx_SRC_ASCLIN_ASCLIN               ASCLIN14;               /**< \brief A50, ASCLIN14 Error Service Request*/
       Ifx_SRC_ASCLIN_ASCLIN               ASCLIN15;               /**< \brief A5C, ASCLIN15 Error Service Request*/
       Ifx_UReg_8Bit                       reserved_A68[8];        /**< \brief A68, \internal Reserved */
       Ifx_SRC_SRCR                        GTM_AEIIRQ;             /**< \brief A70, AEI Shared Service Request*/
       Ifx_SRC_SRCR                        GTM_ARUIRQ[3];          /**< \brief A74, ARU Shared Service Request ${w}*/
       Ifx_SRC_SRCR                        GTM_BRCIRQ;             /**< \brief A80, BRC Shared Service Request*/
       Ifx_SRC_SRCR                        GTM_CMBIRQ;             /**< \brief A84, CMP Shared Service Request*/
       Ifx_SRC_SRCR                        GTM_SPEIRQ[4];          /**< \brief A88, SPE${w} Shared Service Request*/
       Ifx_UReg_8Bit                       reserved_A98[8];        /**< \brief A98, \internal Reserved */
       Ifx_SRC_SRCR                        GTM_PSM[2][8];          /**< \brief AA0, */
       Ifx_UReg_8Bit                       reserved_AE0[32];       /**< \brief AE0, \internal Reserved */
       Ifx_SRC_SRCR                        GTM_DPLL[27];           /**< \brief B00, DPLL Service Request ${w}*/
       Ifx_UReg_8Bit                       reserved_B6C[4];        /**< \brief B6C, \internal Reserved */
       Ifx_SRC_SRCR                        GTM_ERR;                /**< \brief B70, Error Service Request*/
       Ifx_UReg_8Bit                       reserved_B74[28];       /**< \brief B74, \internal Reserved */
       Ifx_SRC_SRCR                        GTM_TIM[7][8];          /**< \brief B90, */
       Ifx_UReg_8Bit                       reserved_C70[32];       /**< \brief C70, \internal Reserved */
       Ifx_SRC_ASCLIN_ASCLIN               ASCLIN16;               /**< \brief C90, ASCLIN16 Error Service Request*/
       Ifx_SRC_ASCLIN_ASCLIN               ASCLIN17;               /**< \brief C9C, ASCLIN17 Error Service Request*/
       Ifx_UReg_8Bit                       reserved_CA8[8];        /**< \brief CA8, \internal Reserved */
       Ifx_SRC_SRCR                        GTM_MCS[7][8];          /**< \brief CB0, */
       Ifx_UReg_8Bit                       reserved_D90[96];       /**< \brief D90, \internal Reserved */
       Ifx_SRC_ASCLIN_ASCLIN               ASCLIN18;               /**< \brief DF0, ASCLIN18 Error Service Request*/
       Ifx_SRC_ASCLIN_ASCLIN               ASCLIN19;               /**< \brief DFC, ASCLIN19 Error Service Request*/
       Ifx_UReg_8Bit                       reserved_E08[8];        /**< \brief E08, \internal Reserved */
       Ifx_SRC_SRCR                        GTM_TOM[5][8];          /**< \brief E10, */
       Ifx_UReg_8Bit                       reserved_EB0[32];       /**< \brief EB0, \internal Reserved */
       Ifx_SRC_ASCLIN_ASCLIN               ASCLIN20;               /**< \brief ED0, ASCLIN20 Error Service Request*/
       Ifx_SRC_ASCLIN_ASCLIN               ASCLIN21;               /**< \brief EDC, ASCLIN21 Error Service Request*/
       Ifx_UReg_8Bit                       reserved_EE8[8];        /**< \brief EE8, \internal Reserved */
       Ifx_SRC_SRCR                        GTM_ATOM[9][4];         /**< \brief EF0, */
       Ifx_UReg_8Bit                       reserved_F80[48];       /**< \brief F80, \internal Reserved */
       Ifx_SRC_ASCLIN_ASCLIN               ASCLIN22;               /**< \brief FB0, ASCLIN22 Error Service Request*/
       Ifx_SRC_ASCLIN_ASCLIN               ASCLIN23;               /**< \brief FBC, ASCLIN23 Error Service Request*/
       Ifx_UReg_8Bit                       reserved_FC8[8];        /**< \brief FC8, \internal Reserved */
       Ifx_SRC_SRCR                        GTM_MCSW[10];           /**< \brief FD0, GTM Multi Channel Sequencer Service Request ${w}*/
       Ifx_UReg_8Bit                       reserved_FF8[4104];     /**< \brief FF8, \internal Reserved */
} Ifx_SRC;

/** \}  */
/******************************************************************************/
/** \}  */


/******************************************************************************/

/******************************************************************************/


#line 57 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\Infra\\Sfr\\TC38A\\_Reg\\IfxSrc_reg.h"
/******************************************************************************/

/******************************************************************************/

/******************************************************************************/

/** \addtogroup IfxSfr_Src_Registers_Cfg_BaseAddress
 * \{  */

/** \brief SRC object */

/** \}  */


/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Src_Registers_Cfg_Src
 * \{  */
/** \brief 0, CPU0 Software Breakpoint Service Request */

/** Alias (User Manual Name) for SRC_CPU_CPU0_SB.
* To use register names with standard convension, please use SRC_CPU_CPU0_SB.
*/


/** \brief 4, CPU1 Software Breakpoint Service Request */

/** Alias (User Manual Name) for SRC_CPU_CPU1_SB.
* To use register names with standard convension, please use SRC_CPU_CPU1_SB.
*/


/** \brief 8, CPU2 Software Breakpoint Service Request */

/** Alias (User Manual Name) for SRC_CPU_CPU2_SB.
* To use register names with standard convension, please use SRC_CPU_CPU2_SB.
*/


/** \brief C, CPU3 Software Breakpoint Service Request */

/** Alias (User Manual Name) for SRC_CPU_CPU3_SB.
* To use register names with standard convension, please use SRC_CPU_CPU3_SB.
*/


/** \brief 20, SBCU Service Request (SPB Bus Control Unit) */

/** Alias (User Manual Name) for SRC_SBCU.
* To use register names with standard convension, please use SRC_SBCU.
*/


/** \brief 30, SRI Domain 0 Service Request */


/** \brief 40, Cerberus Service Request 0 */

/** Alias (User Manual Name) for SRC_CERBERUS_CERBERUS_SR0.
* To use register names with standard convension, please use SRC_CERBERUS_CERBERUS_SR0.
*/


/** \brief 44, Cerberus Service Request 1 */

/** Alias (User Manual Name) for SRC_CERBERUS_CERBERUS_SR1.
* To use register names with standard convension, please use SRC_CERBERUS_CERBERUS_SR1.
*/


/** \brief 50, ASCLIN0 Transmit Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN_ASCLIN0_TX.
* To use register names with standard convension, please use SRC_ASCLIN_ASCLIN0_TX.
*/


/** \brief 54, ASCLIN0 Receive Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN_ASCLIN0_RX.
* To use register names with standard convension, please use SRC_ASCLIN_ASCLIN0_RX.
*/


/** \brief 58, ASCLIN0 Error Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN_ASCLIN0_ERR.
* To use register names with standard convension, please use SRC_ASCLIN_ASCLIN0_ERR.
*/


/** \brief 5C, ASCLIN1 Transmit Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN_ASCLIN1_TX.
* To use register names with standard convension, please use SRC_ASCLIN_ASCLIN1_TX.
*/


/** \brief 60, ASCLIN1 Receive Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN_ASCLIN1_RX.
* To use register names with standard convension, please use SRC_ASCLIN_ASCLIN1_RX.
*/


/** \brief 64, ASCLIN1 Error Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN_ASCLIN1_ERR.
* To use register names with standard convension, please use SRC_ASCLIN_ASCLIN1_ERR.
*/


/** \brief 68, ASCLIN2 Transmit Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN_ASCLIN2_TX.
* To use register names with standard convension, please use SRC_ASCLIN_ASCLIN2_TX.
*/


/** \brief 6C, ASCLIN2 Receive Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN_ASCLIN2_RX.
* To use register names with standard convension, please use SRC_ASCLIN_ASCLIN2_RX.
*/


/** \brief 70, ASCLIN2 Error Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN_ASCLIN2_ERR.
* To use register names with standard convension, please use SRC_ASCLIN_ASCLIN2_ERR.
*/


/** \brief 74, ASCLIN3 Transmit Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN_ASCLIN3_TX.
* To use register names with standard convension, please use SRC_ASCLIN_ASCLIN3_TX.
*/


/** \brief 78, ASCLIN3 Receive Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN_ASCLIN3_RX.
* To use register names with standard convension, please use SRC_ASCLIN_ASCLIN3_RX.
*/


/** \brief 7C, ASCLIN3 Error Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN_ASCLIN3_ERR.
* To use register names with standard convension, please use SRC_ASCLIN_ASCLIN3_ERR.
*/


/** \brief 80, ASCLIN4 Transmit Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN_ASCLIN4_TX.
* To use register names with standard convension, please use SRC_ASCLIN_ASCLIN4_TX.
*/


/** \brief 84, ASCLIN4 Receive Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN_ASCLIN4_RX.
* To use register names with standard convension, please use SRC_ASCLIN_ASCLIN4_RX.
*/


/** \brief 88, ASCLIN4 Error Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN_ASCLIN4_ERR.
* To use register names with standard convension, please use SRC_ASCLIN_ASCLIN4_ERR.
*/


/** \brief 8C, ASCLIN5 Transmit Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN_ASCLIN5_TX.
* To use register names with standard convension, please use SRC_ASCLIN_ASCLIN5_TX.
*/


/** \brief 90, ASCLIN5 Receive Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN_ASCLIN5_RX.
* To use register names with standard convension, please use SRC_ASCLIN_ASCLIN5_RX.
*/


/** \brief 94, ASCLIN5 Error Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN_ASCLIN5_ERR.
* To use register names with standard convension, please use SRC_ASCLIN_ASCLIN5_ERR.
*/


/** \brief 98, ASCLIN6 Transmit Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN_ASCLIN6_TX.
* To use register names with standard convension, please use SRC_ASCLIN_ASCLIN6_TX.
*/


/** \brief 9C, ASCLIN6 Receive Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN_ASCLIN6_RX.
* To use register names with standard convension, please use SRC_ASCLIN_ASCLIN6_RX.
*/


/** \brief A0, ASCLIN6 Error Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN_ASCLIN6_ERR.
* To use register names with standard convension, please use SRC_ASCLIN_ASCLIN6_ERR.
*/


/** \brief A4, ASCLIN7 Transmit Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN_ASCLIN7_TX.
* To use register names with standard convension, please use SRC_ASCLIN_ASCLIN7_TX.
*/


/** \brief A8, ASCLIN7 Receive Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN_ASCLIN7_RX.
* To use register names with standard convension, please use SRC_ASCLIN_ASCLIN7_RX.
*/


/** \brief AC, ASCLIN7 Error Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN_ASCLIN7_ERR.
* To use register names with standard convension, please use SRC_ASCLIN_ASCLIN7_ERR.
*/


/** \brief B0, ASCLIN8 Transmit Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN_ASCLIN8_TX.
* To use register names with standard convension, please use SRC_ASCLIN_ASCLIN8_TX.
*/


/** \brief B4, ASCLIN8 Receive Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN_ASCLIN8_RX.
* To use register names with standard convension, please use SRC_ASCLIN_ASCLIN8_RX.
*/


/** \brief B8, ASCLIN8 Error Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN_ASCLIN8_ERR.
* To use register names with standard convension, please use SRC_ASCLIN_ASCLIN8_ERR.
*/


/** \brief BC, ASCLIN9 Transmit Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN_ASCLIN9_TX.
* To use register names with standard convension, please use SRC_ASCLIN_ASCLIN9_TX.
*/


/** \brief C0, ASCLIN9 Receive Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN_ASCLIN9_RX.
* To use register names with standard convension, please use SRC_ASCLIN_ASCLIN9_RX.
*/


/** \brief C4, ASCLIN9 Error Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN_ASCLIN9_ERR.
* To use register names with standard convension, please use SRC_ASCLIN_ASCLIN9_ERR.
*/


/** \brief C8, ASCLIN10 Transmit Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN_ASCLIN10_TX.
* To use register names with standard convension, please use SRC_ASCLIN_ASCLIN10_TX.
*/


/** \brief CC, ASCLIN10 Receive Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN_ASCLIN10_RX.
* To use register names with standard convension, please use SRC_ASCLIN_ASCLIN10_RX.
*/


/** \brief D0, ASCLIN10 Error Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN_ASCLIN10_ERR.
* To use register names with standard convension, please use SRC_ASCLIN_ASCLIN10_ERR.
*/


/** \brief D4, ASCLIN11 Transmit Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN_ASCLIN11_TX.
* To use register names with standard convension, please use SRC_ASCLIN_ASCLIN11_TX.
*/


/** \brief D8, ASCLIN11 Receive Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN_ASCLIN11_RX.
* To use register names with standard convension, please use SRC_ASCLIN_ASCLIN11_RX.
*/


/** \brief DC, ASCLIN11 Error Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN_ASCLIN11_ERR.
* To use register names with standard convension, please use SRC_ASCLIN_ASCLIN11_ERR.
*/


/** \brief EC, MTU Done Service Request */


/** \brief F0, QSPI0 Transmit Service Request */

/** Alias (User Manual Name) for SRC_QSPI_QSPI0_TX.
* To use register names with standard convension, please use SRC_QSPI_QSPI0_TX.
*/


/** \brief F4, QSPI0 Receive Service Request */

/** Alias (User Manual Name) for SRC_QSPI_QSPI0_RX.
* To use register names with standard convension, please use SRC_QSPI_QSPI0_RX.
*/


/** \brief F8, QSPI0 Error Service Request */

/** Alias (User Manual Name) for SRC_QSPI_QSPI0_ERR.
* To use register names with standard convension, please use SRC_QSPI_QSPI0_ERR.
*/


/** \brief FC, QSPI0 Phase Transition Service Request */

/** Alias (User Manual Name) for SRC_QSPI_QSPI0_PT.
* To use register names with standard convension, please use SRC_QSPI_QSPI0_PT.
*/


/** \brief 100, QSPI0 User Defined Service Request */

/** Alias (User Manual Name) for SRC_QSPI_QSPI0_U.
* To use register names with standard convension, please use SRC_QSPI_QSPI0_U.
*/


/** \brief 104, QSPI1 Transmit Service Request */

/** Alias (User Manual Name) for SRC_QSPI_QSPI1_TX.
* To use register names with standard convension, please use SRC_QSPI_QSPI1_TX.
*/


/** \brief 108, QSPI1 Receive Service Request */

/** Alias (User Manual Name) for SRC_QSPI_QSPI1_RX.
* To use register names with standard convension, please use SRC_QSPI_QSPI1_RX.
*/


/** \brief 10C, QSPI1 Error Service Request */

/** Alias (User Manual Name) for SRC_QSPI_QSPI1_ERR.
* To use register names with standard convension, please use SRC_QSPI_QSPI1_ERR.
*/


/** \brief 110, QSPI1 Phase Transition Service Request */

/** Alias (User Manual Name) for SRC_QSPI_QSPI1_PT.
* To use register names with standard convension, please use SRC_QSPI_QSPI1_PT.
*/


/** \brief 114, QSPI1 User Defined Service Request */

/** Alias (User Manual Name) for SRC_QSPI_QSPI1_U.
* To use register names with standard convension, please use SRC_QSPI_QSPI1_U.
*/


/** \brief 118, QSPI2 Transmit Service Request */

/** Alias (User Manual Name) for SRC_QSPI_QSPI2_TX.
* To use register names with standard convension, please use SRC_QSPI_QSPI2_TX.
*/


/** \brief 11C, QSPI2 Receive Service Request */

/** Alias (User Manual Name) for SRC_QSPI_QSPI2_RX.
* To use register names with standard convension, please use SRC_QSPI_QSPI2_RX.
*/


/** \brief 120, QSPI2 Error Service Request */

/** Alias (User Manual Name) for SRC_QSPI_QSPI2_ERR.
* To use register names with standard convension, please use SRC_QSPI_QSPI2_ERR.
*/


/** \brief 124, QSPI2 Phase Transition Service Request */

/** Alias (User Manual Name) for SRC_QSPI_QSPI2_PT.
* To use register names with standard convension, please use SRC_QSPI_QSPI2_PT.
*/


/** \brief 128, QSPI2 User Defined Service Request */

/** Alias (User Manual Name) for SRC_QSPI_QSPI2_U.
* To use register names with standard convension, please use SRC_QSPI_QSPI2_U.
*/


/** \brief 12C, QSPI3 Transmit Service Request */

/** Alias (User Manual Name) for SRC_QSPI_QSPI3_TX.
* To use register names with standard convension, please use SRC_QSPI_QSPI3_TX.
*/


/** \brief 130, QSPI3 Receive Service Request */

/** Alias (User Manual Name) for SRC_QSPI_QSPI3_RX.
* To use register names with standard convension, please use SRC_QSPI_QSPI3_RX.
*/


/** \brief 134, QSPI3 Error Service Request */

/** Alias (User Manual Name) for SRC_QSPI_QSPI3_ERR.
* To use register names with standard convension, please use SRC_QSPI_QSPI3_ERR.
*/


/** \brief 138, QSPI3 Phase Transition Service Request */

/** Alias (User Manual Name) for SRC_QSPI_QSPI3_PT.
* To use register names with standard convension, please use SRC_QSPI_QSPI3_PT.
*/


/** \brief 13C, QSPI3 User Defined Service Request */

/** Alias (User Manual Name) for SRC_QSPI_QSPI3_U.
* To use register names with standard convension, please use SRC_QSPI_QSPI3_U.
*/


/** \brief 140, QSPI4 Transmit Service Request */

/** Alias (User Manual Name) for SRC_QSPI_QSPI4_TX.
* To use register names with standard convension, please use SRC_QSPI_QSPI4_TX.
*/


/** \brief 144, QSPI4 Receive Service Request */

/** Alias (User Manual Name) for SRC_QSPI_QSPI4_RX.
* To use register names with standard convension, please use SRC_QSPI_QSPI4_RX.
*/


/** \brief 148, QSPI4 Error Service Request */

/** Alias (User Manual Name) for SRC_QSPI_QSPI4_ERR.
* To use register names with standard convension, please use SRC_QSPI_QSPI4_ERR.
*/


/** \brief 14C, QSPI4 Phase Transition Service Request */

/** Alias (User Manual Name) for SRC_QSPI_QSPI4_PT.
* To use register names with standard convension, please use SRC_QSPI_QSPI4_PT.
*/


/** \brief 150, QSPI4 User Defined Service Request */

/** Alias (User Manual Name) for SRC_QSPI_QSPI4_U.
* To use register names with standard convension, please use SRC_QSPI_QSPI4_U.
*/


/** \brief 180, HSCT0 Service Request */

/** Alias (User Manual Name) for SRC_HSCT_HSCT0_SR.
* To use register names with standard convension, please use SRC_HSCT_HSCT0_SR.
*/


/** \brief 190, HSSL0 Channel 0 OK Service Request */

/** Alias (User Manual Name) for SRC_HSSL_HSSL0_CH0_COK.
* To use register names with standard convension, please use SRC_HSSL_HSSL0_CH0_COK.
*/


/** \brief 194, HSSL0 Channel 0 Read Data Service Request */

/** Alias (User Manual Name) for SRC_HSSL_HSSL0_CH0_RDI.
* To use register names with standard convension, please use SRC_HSSL_HSSL0_CH0_RDI.
*/


/** \brief 198, HSSL0 Channel 0 Error Service Request */

/** Alias (User Manual Name) for SRC_HSSL_HSSL0_CH0_ERR.
* To use register names with standard convension, please use SRC_HSSL_HSSL0_CH0_ERR.
*/


/** \brief 19C, HSSL0 Channel 0 Trigger Interrupt Service Request */

/** Alias (User Manual Name) for SRC_HSSL_HSSL0_CH0_TRG.
* To use register names with standard convension, please use SRC_HSSL_HSSL0_CH0_TRG.
*/


/** \brief 1A0, HSSL0 Channel 1 OK Service Request */

/** Alias (User Manual Name) for SRC_HSSL_HSSL0_CH1_COK.
* To use register names with standard convension, please use SRC_HSSL_HSSL0_CH1_COK.
*/


/** \brief 1A4, HSSL0 Channel 1 Read Data Service Request */

/** Alias (User Manual Name) for SRC_HSSL_HSSL0_CH1_RDI.
* To use register names with standard convension, please use SRC_HSSL_HSSL0_CH1_RDI.
*/


/** \brief 1A8, HSSL0 Channel 1 Error Service Request */

/** Alias (User Manual Name) for SRC_HSSL_HSSL0_CH1_ERR.
* To use register names with standard convension, please use SRC_HSSL_HSSL0_CH1_ERR.
*/


/** \brief 1AC, HSSL0 Channel 1 Trigger Interrupt Service Request */

/** Alias (User Manual Name) for SRC_HSSL_HSSL0_CH1_TRG.
* To use register names with standard convension, please use SRC_HSSL_HSSL0_CH1_TRG.
*/


/** \brief 1B0, HSSL0 Channel 2 OK Service Request */

/** Alias (User Manual Name) for SRC_HSSL_HSSL0_CH2_COK.
* To use register names with standard convension, please use SRC_HSSL_HSSL0_CH2_COK.
*/


/** \brief 1B4, HSSL0 Channel 2 Read Data Service Request */

/** Alias (User Manual Name) for SRC_HSSL_HSSL0_CH2_RDI.
* To use register names with standard convension, please use SRC_HSSL_HSSL0_CH2_RDI.
*/


/** \brief 1B8, HSSL0 Channel 2 Error Service Request */

/** Alias (User Manual Name) for SRC_HSSL_HSSL0_CH2_ERR.
* To use register names with standard convension, please use SRC_HSSL_HSSL0_CH2_ERR.
*/


/** \brief 1BC, HSSL0 Channel 2 Trigger Interrupt Service Request */

/** Alias (User Manual Name) for SRC_HSSL_HSSL0_CH2_TRG.
* To use register names with standard convension, please use SRC_HSSL_HSSL0_CH2_TRG.
*/


/** \brief 1C0, HSSL0 Channel 3 OK Service Request */

/** Alias (User Manual Name) for SRC_HSSL_HSSL0_CH3_COK.
* To use register names with standard convension, please use SRC_HSSL_HSSL0_CH3_COK.
*/


/** \brief 1C4, HSSL0 Channel 3 Read Data Service Request */

/** Alias (User Manual Name) for SRC_HSSL_HSSL0_CH3_RDI.
* To use register names with standard convension, please use SRC_HSSL_HSSL0_CH3_RDI.
*/


/** \brief 1C8, HSSL0 Channel 3 Error Service Request */

/** Alias (User Manual Name) for SRC_HSSL_HSSL0_CH3_ERR.
* To use register names with standard convension, please use SRC_HSSL_HSSL0_CH3_ERR.
*/


/** \brief 1CC, HSSL0 Channel 3 Trigger Interrupt Service Request */

/** Alias (User Manual Name) for SRC_HSSL_HSSL0_CH3_TRG.
* To use register names with standard convension, please use SRC_HSSL_HSSL0_CH3_TRG.
*/


/** \brief 1D0, HSSL0 Exception Service Request */

/** Alias (User Manual Name) for SRC_HSSL_HSSL0_EXI.
* To use register names with standard convension, please use SRC_HSSL_HSSL0_EXI.
*/


/** \brief 220, I2C0 Data Transfer Request */

/** Alias (User Manual Name) for SRC_I2C_I2C0_DTR.
* To use register names with standard convension, please use SRC_I2C_I2C0_DTR.
*/


/** \brief 224, I2C0 Error Service Request */

/** Alias (User Manual Name) for SRC_I2C_I2C0_ERR.
* To use register names with standard convension, please use SRC_I2C_I2C0_ERR.
*/


/** \brief 228, I2C0 Protocol Service Request */

/** Alias (User Manual Name) for SRC_I2C_I2C0_P.
* To use register names with standard convension, please use SRC_I2C_I2C0_P.
*/


/** \brief 230, I2C1 Data Transfer Request */

/** Alias (User Manual Name) for SRC_I2C_I2C1_DTR.
* To use register names with standard convension, please use SRC_I2C_I2C1_DTR.
*/


/** \brief 234, I2C1 Error Service Request */

/** Alias (User Manual Name) for SRC_I2C_I2C1_ERR.
* To use register names with standard convension, please use SRC_I2C_I2C1_ERR.
*/


/** \brief 238, I2C1 Protocol Service Request */

/** Alias (User Manual Name) for SRC_I2C_I2C1_P.
* To use register names with standard convension, please use SRC_I2C_I2C1_P.
*/


/** \brief 240, SENT TRIG0 Service Request */

/** Alias (User Manual Name) for SRC_SENT_SENT0_SR.
* To use register names with standard convension, please use SRC_SENT_SENT0_SR.
*/


/** \brief 244, SENT TRIG1 Service Request */

/** Alias (User Manual Name) for SRC_SENT_SENT1_SR.
* To use register names with standard convension, please use SRC_SENT_SENT1_SR.
*/


/** \brief 248, SENT TRIG2 Service Request */

/** Alias (User Manual Name) for SRC_SENT_SENT2_SR.
* To use register names with standard convension, please use SRC_SENT_SENT2_SR.
*/


/** \brief 24C, SENT TRIG3 Service Request */

/** Alias (User Manual Name) for SRC_SENT_SENT3_SR.
* To use register names with standard convension, please use SRC_SENT_SENT3_SR.
*/


/** \brief 250, SENT TRIG4 Service Request */

/** Alias (User Manual Name) for SRC_SENT_SENT4_SR.
* To use register names with standard convension, please use SRC_SENT_SENT4_SR.
*/


/** \brief 254, SENT TRIG5 Service Request */

/** Alias (User Manual Name) for SRC_SENT_SENT5_SR.
* To use register names with standard convension, please use SRC_SENT_SENT5_SR.
*/


/** \brief 258, SENT TRIG6 Service Request */

/** Alias (User Manual Name) for SRC_SENT_SENT6_SR.
* To use register names with standard convension, please use SRC_SENT_SENT6_SR.
*/


/** \brief 25C, SENT TRIG7 Service Request */

/** Alias (User Manual Name) for SRC_SENT_SENT7_SR.
* To use register names with standard convension, please use SRC_SENT_SENT7_SR.
*/


/** \brief 260, SENT TRIG8 Service Request */

/** Alias (User Manual Name) for SRC_SENT_SENT8_SR.
* To use register names with standard convension, please use SRC_SENT_SENT8_SR.
*/


/** \brief 264, SENT TRIG9 Service Request */

/** Alias (User Manual Name) for SRC_SENT_SENT9_SR.
* To use register names with standard convension, please use SRC_SENT_SENT9_SR.
*/


/** \brief 270, MSC0 Service Request 0 */

/** Alias (User Manual Name) for SRC_MSC_MSC0_SR0.
* To use register names with standard convension, please use SRC_MSC_MSC0_SR0.
*/


/** \brief 274, MSC0 Service Request 1 */

/** Alias (User Manual Name) for SRC_MSC_MSC0_SR1.
* To use register names with standard convension, please use SRC_MSC_MSC0_SR1.
*/


/** \brief 278, MSC0 Service Request 2 */

/** Alias (User Manual Name) for SRC_MSC_MSC0_SR2.
* To use register names with standard convension, please use SRC_MSC_MSC0_SR2.
*/


/** \brief 27C, MSC0 Service Request 3 */

/** Alias (User Manual Name) for SRC_MSC_MSC0_SR3.
* To use register names with standard convension, please use SRC_MSC_MSC0_SR3.
*/


/** \brief 280, MSC0 Service Request 4 */

/** Alias (User Manual Name) for SRC_MSC_MSC0_SR4.
* To use register names with standard convension, please use SRC_MSC_MSC0_SR4.
*/


/** \brief 284, MSC1 Service Request 0 */

/** Alias (User Manual Name) for SRC_MSC_MSC1_SR0.
* To use register names with standard convension, please use SRC_MSC_MSC1_SR0.
*/


/** \brief 288, MSC1 Service Request 1 */

/** Alias (User Manual Name) for SRC_MSC_MSC1_SR1.
* To use register names with standard convension, please use SRC_MSC_MSC1_SR1.
*/


/** \brief 28C, MSC1 Service Request 2 */

/** Alias (User Manual Name) for SRC_MSC_MSC1_SR2.
* To use register names with standard convension, please use SRC_MSC_MSC1_SR2.
*/


/** \brief 290, MSC1 Service Request 3 */

/** Alias (User Manual Name) for SRC_MSC_MSC1_SR3.
* To use register names with standard convension, please use SRC_MSC_MSC1_SR3.
*/


/** \brief 294, MSC1 Service Request 4 */

/** Alias (User Manual Name) for SRC_MSC_MSC1_SR4.
* To use register names with standard convension, please use SRC_MSC_MSC1_SR4.
*/


/** \brief 298, MSC2 Service Request 0 */

/** Alias (User Manual Name) for SRC_MSC_MSC2_SR0.
* To use register names with standard convension, please use SRC_MSC_MSC2_SR0.
*/


/** \brief 29C, MSC2 Service Request 1 */

/** Alias (User Manual Name) for SRC_MSC_MSC2_SR1.
* To use register names with standard convension, please use SRC_MSC_MSC2_SR1.
*/


/** \brief 2A0, MSC2 Service Request 2 */

/** Alias (User Manual Name) for SRC_MSC_MSC2_SR2.
* To use register names with standard convension, please use SRC_MSC_MSC2_SR2.
*/


/** \brief 2A4, MSC2 Service Request 3 */

/** Alias (User Manual Name) for SRC_MSC_MSC2_SR3.
* To use register names with standard convension, please use SRC_MSC_MSC2_SR3.
*/


/** \brief 2A8, MSC2 Service Request 4 */

/** Alias (User Manual Name) for SRC_MSC_MSC2_SR4.
* To use register names with standard convension, please use SRC_MSC_MSC2_SR4.
*/


/** \brief 2C0, CCU0 Service Request 0 */

/** Alias (User Manual Name) for SRC_CCU6_CCU0_SR0.
* To use register names with standard convension, please use SRC_CCU6_CCU0_SR0.
*/


/** \brief 2C4, CCU0 Service Request 1 */

/** Alias (User Manual Name) for SRC_CCU6_CCU0_SR1.
* To use register names with standard convension, please use SRC_CCU6_CCU0_SR1.
*/


/** \brief 2C8, CCU0 Service Request 2 */

/** Alias (User Manual Name) for SRC_CCU6_CCU0_SR2.
* To use register names with standard convension, please use SRC_CCU6_CCU0_SR2.
*/


/** \brief 2CC, CCU0 Service Request 3 */

/** Alias (User Manual Name) for SRC_CCU6_CCU0_SR3.
* To use register names with standard convension, please use SRC_CCU6_CCU0_SR3.
*/


/** \brief 2D0, CCU1 Service Request 0 */

/** Alias (User Manual Name) for SRC_CCU6_CCU1_SR0.
* To use register names with standard convension, please use SRC_CCU6_CCU1_SR0.
*/


/** \brief 2D4, CCU1 Service Request 1 */

/** Alias (User Manual Name) for SRC_CCU6_CCU1_SR1.
* To use register names with standard convension, please use SRC_CCU6_CCU1_SR1.
*/


/** \brief 2D8, CCU1 Service Request 2 */

/** Alias (User Manual Name) for SRC_CCU6_CCU1_SR2.
* To use register names with standard convension, please use SRC_CCU6_CCU1_SR2.
*/


/** \brief 2DC, CCU1 Service Request 3 */

/** Alias (User Manual Name) for SRC_CCU6_CCU1_SR3.
* To use register names with standard convension, please use SRC_CCU6_CCU1_SR3.
*/


/** \brief 2E0, GPT120 CAPREL Service Request */

/** Alias (User Manual Name) for SRC_GPT12_GPT120_CIRQ.
* To use register names with standard convension, please use SRC_GPT12_GPT120_CIRQ.
*/


/** \brief 2E4, GPT120 Timer 2 Service Request */

/** Alias (User Manual Name) for SRC_GPT12_GPT120_T2.
* To use register names with standard convension, please use SRC_GPT12_GPT120_T2.
*/


/** \brief 2E8, GPT120 Timer 3 Service Request */

/** Alias (User Manual Name) for SRC_GPT12_GPT120_T3.
* To use register names with standard convension, please use SRC_GPT12_GPT120_T3.
*/


/** \brief 2EC, GPT120 Timer 4 Service Request */

/** Alias (User Manual Name) for SRC_GPT12_GPT120_T4.
* To use register names with standard convension, please use SRC_GPT12_GPT120_T4.
*/


/** \brief 2F0, GPT120 Timer 5 Service Request */

/** Alias (User Manual Name) for SRC_GPT12_GPT120_T5.
* To use register names with standard convension, please use SRC_GPT12_GPT120_T5.
*/


/** \brief 2F4, GPT120 Timer 6 Service Request */

/** Alias (User Manual Name) for SRC_GPT12_GPT120_T6.
* To use register names with standard convension, please use SRC_GPT12_GPT120_T6.
*/


/** \brief 300, System Timer 0 Service Request 0 */

/** Alias (User Manual Name) for SRC_STM_STM0_SR0.
* To use register names with standard convension, please use SRC_STM_STM0_SR0.
*/


/** \brief 304, System Timer 0 Service Request 1 */

/** Alias (User Manual Name) for SRC_STM_STM0_SR1.
* To use register names with standard convension, please use SRC_STM_STM0_SR1.
*/


/** \brief 308, System Timer 1 Service Request 0 */

/** Alias (User Manual Name) for SRC_STM_STM1_SR0.
* To use register names with standard convension, please use SRC_STM_STM1_SR0.
*/


/** \brief 30C, System Timer 1 Service Request 1 */

/** Alias (User Manual Name) for SRC_STM_STM1_SR1.
* To use register names with standard convension, please use SRC_STM_STM1_SR1.
*/


/** \brief 310, System Timer 2 Service Request 0 */

/** Alias (User Manual Name) for SRC_STM_STM2_SR0.
* To use register names with standard convension, please use SRC_STM_STM2_SR0.
*/


/** \brief 314, System Timer 2 Service Request 1 */

/** Alias (User Manual Name) for SRC_STM_STM2_SR1.
* To use register names with standard convension, please use SRC_STM_STM2_SR1.
*/


/** \brief 318, System Timer 3 Service Request 0 */

/** Alias (User Manual Name) for SRC_STM_STM3_SR0.
* To use register names with standard convension, please use SRC_STM_STM3_SR0.
*/


/** \brief 31C, System Timer 3 Service Request 1 */

/** Alias (User Manual Name) for SRC_STM_STM3_SR1.
* To use register names with standard convension, please use SRC_STM_STM3_SR1.
*/


/** \brief 330, FCE0 Error Service Request */

/** Alias (User Manual Name) for SRC_FCE_FCE0_SR.
* To use register names with standard convension, please use SRC_FCE_FCE0_SR.
*/


/** \brief 340, DMA Error Service Request 0 */

/** Alias (User Manual Name) for SRC_DMA_DMA0_ERR0.
* To use register names with standard convension, please use SRC_DMA_DMA0_ERR0.
*/


/** \brief 344, DMA Error Service Request 1 */

/** Alias (User Manual Name) for SRC_DMA_DMA0_ERR1.
* To use register names with standard convension, please use SRC_DMA_DMA0_ERR1.
*/


/** \brief 348, DMA Error Service Request 2 */

/** Alias (User Manual Name) for SRC_DMA_DMA0_ERR2.
* To use register names with standard convension, please use SRC_DMA_DMA0_ERR2.
*/


/** \brief 34C, DMA Error Service Request 3 */

/** Alias (User Manual Name) for SRC_DMA_DMA0_ERR3.
* To use register names with standard convension, please use SRC_DMA_DMA0_ERR3.
*/


/** \brief 370, DMA Channel  0 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH0.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH0.
*/


/** \brief 374, DMA Channel  1 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH1.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH1.
*/


/** \brief 378, DMA Channel  2 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH2.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH2.
*/


/** \brief 37C, DMA Channel  3 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH3.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH3.
*/


/** \brief 380, DMA Channel  4 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH4.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH4.
*/


/** \brief 384, DMA Channel  5 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH5.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH5.
*/


/** \brief 388, DMA Channel  6 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH6.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH6.
*/


/** \brief 38C, DMA Channel  7 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH7.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH7.
*/


/** \brief 390, DMA Channel  8 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH8.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH8.
*/


/** \brief 394, DMA Channel  9 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH9.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH9.
*/


/** \brief 398, DMA Channel  10 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH10.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH10.
*/


/** \brief 39C, DMA Channel  11 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH11.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH11.
*/


/** \brief 3A0, DMA Channel  12 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH12.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH12.
*/


/** \brief 3A4, DMA Channel  13 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH13.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH13.
*/


/** \brief 3A8, DMA Channel  14 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH14.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH14.
*/


/** \brief 3AC, DMA Channel  15 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH15.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH15.
*/


/** \brief 3B0, DMA Channel  16 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH16.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH16.
*/


/** \brief 3B4, DMA Channel  17 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH17.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH17.
*/


/** \brief 3B8, DMA Channel  18 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH18.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH18.
*/


/** \brief 3BC, DMA Channel  19 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH19.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH19.
*/


/** \brief 3C0, DMA Channel  20 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH20.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH20.
*/


/** \brief 3C4, DMA Channel  21 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH21.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH21.
*/


/** \brief 3C8, DMA Channel  22 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH22.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH22.
*/


/** \brief 3CC, DMA Channel  23 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH23.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH23.
*/


/** \brief 3D0, DMA Channel  24 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH24.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH24.
*/


/** \brief 3D4, DMA Channel  25 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH25.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH25.
*/


/** \brief 3D8, DMA Channel  26 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH26.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH26.
*/


/** \brief 3DC, DMA Channel  27 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH27.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH27.
*/


/** \brief 3E0, DMA Channel  28 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH28.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH28.
*/


/** \brief 3E4, DMA Channel  29 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH29.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH29.
*/


/** \brief 3E8, DMA Channel  30 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH30.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH30.
*/


/** \brief 3EC, DMA Channel  31 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH31.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH31.
*/


/** \brief 3F0, DMA Channel  32 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH32.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH32.
*/


/** \brief 3F4, DMA Channel  33 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH33.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH33.
*/


/** \brief 3F8, DMA Channel  34 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH34.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH34.
*/


/** \brief 3FC, DMA Channel  35 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH35.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH35.
*/


/** \brief 400, DMA Channel  36 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH36.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH36.
*/


/** \brief 404, DMA Channel  37 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH37.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH37.
*/


/** \brief 408, DMA Channel  38 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH38.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH38.
*/


/** \brief 40C, DMA Channel  39 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH39.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH39.
*/


/** \brief 410, DMA Channel  40 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH40.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH40.
*/


/** \brief 414, DMA Channel  41 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH41.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH41.
*/


/** \brief 418, DMA Channel  42 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH42.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH42.
*/


/** \brief 41C, DMA Channel  43 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH43.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH43.
*/


/** \brief 420, DMA Channel  44 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH44.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH44.
*/


/** \brief 424, DMA Channel  45 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH45.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH45.
*/


/** \brief 428, DMA Channel  46 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH46.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH46.
*/


/** \brief 42C, DMA Channel  47 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH47.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH47.
*/


/** \brief 430, DMA Channel  48 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH48.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH48.
*/


/** \brief 434, DMA Channel  49 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH49.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH49.
*/


/** \brief 438, DMA Channel  50 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH50.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH50.
*/


/** \brief 43C, DMA Channel  51 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH51.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH51.
*/


/** \brief 440, DMA Channel  52 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH52.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH52.
*/


/** \brief 444, DMA Channel  53 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH53.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH53.
*/


/** \brief 448, DMA Channel  54 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH54.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH54.
*/


/** \brief 44C, DMA Channel  55 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH55.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH55.
*/


/** \brief 450, DMA Channel  56 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH56.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH56.
*/


/** \brief 454, DMA Channel  57 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH57.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH57.
*/


/** \brief 458, DMA Channel  58 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH58.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH58.
*/


/** \brief 45C, DMA Channel  59 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH59.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH59.
*/


/** \brief 460, DMA Channel  60 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH60.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH60.
*/


/** \brief 464, DMA Channel  61 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH61.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH61.
*/


/** \brief 468, DMA Channel  62 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH62.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH62.
*/


/** \brief 46C, DMA Channel  63 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH63.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH63.
*/


/** \brief 470, DMA Channel  64 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH64.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH64.
*/


/** \brief 474, DMA Channel  65 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH65.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH65.
*/


/** \brief 478, DMA Channel  66 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH66.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH66.
*/


/** \brief 47C, DMA Channel  67 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH67.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH67.
*/


/** \brief 480, DMA Channel  68 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH68.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH68.
*/


/** \brief 484, DMA Channel  69 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH69.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH69.
*/


/** \brief 488, DMA Channel  70 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH70.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH70.
*/


/** \brief 48C, DMA Channel  71 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH71.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH71.
*/


/** \brief 490, DMA Channel  72 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH72.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH72.
*/


/** \brief 494, DMA Channel  73 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH73.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH73.
*/


/** \brief 498, DMA Channel  74 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH74.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH74.
*/


/** \brief 49C, DMA Channel  75 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH75.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH75.
*/


/** \brief 4A0, DMA Channel  76 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH76.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH76.
*/


/** \brief 4A4, DMA Channel  77 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH77.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH77.
*/


/** \brief 4A8, DMA Channel  78 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH78.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH78.
*/


/** \brief 4AC, DMA Channel  79 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH79.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH79.
*/


/** \brief 4B0, DMA Channel  80 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH80.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH80.
*/


/** \brief 4B4, DMA Channel  81 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH81.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH81.
*/


/** \brief 4B8, DMA Channel  82 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH82.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH82.
*/


/** \brief 4BC, DMA Channel  83 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH83.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH83.
*/


/** \brief 4C0, DMA Channel  84 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH84.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH84.
*/


/** \brief 4C4, DMA Channel  85 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH85.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH85.
*/


/** \brief 4C8, DMA Channel  86 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH86.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH86.
*/


/** \brief 4CC, DMA Channel  87 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH87.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH87.
*/


/** \brief 4D0, DMA Channel  88 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH88.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH88.
*/


/** \brief 4D4, DMA Channel  89 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH89.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH89.
*/


/** \brief 4D8, DMA Channel  90 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH90.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH90.
*/


/** \brief 4DC, DMA Channel  91 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH91.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH91.
*/


/** \brief 4E0, DMA Channel  92 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH92.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH92.
*/


/** \brief 4E4, DMA Channel  93 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH93.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH93.
*/


/** \brief 4E8, DMA Channel  94 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH94.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH94.
*/


/** \brief 4EC, DMA Channel  95 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH95.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH95.
*/


/** \brief 4F0, DMA Channel  96 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH96.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH96.
*/


/** \brief 4F4, DMA Channel  97 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH97.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH97.
*/


/** \brief 4F8, DMA Channel  98 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH98.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH98.
*/


/** \brief 4FC, DMA Channel  99 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH99.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH99.
*/


/** \brief 500, DMA Channel  100 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH100.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH100.
*/


/** \brief 504, DMA Channel  101 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH101.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH101.
*/


/** \brief 508, DMA Channel  102 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH102.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH102.
*/


/** \brief 50C, DMA Channel  103 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH103.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH103.
*/


/** \brief 510, DMA Channel  104 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH104.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH104.
*/


/** \brief 514, DMA Channel  105 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH105.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH105.
*/


/** \brief 518, DMA Channel  106 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH106.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH106.
*/


/** \brief 51C, DMA Channel  107 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH107.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH107.
*/


/** \brief 520, DMA Channel  108 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH108.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH108.
*/


/** \brief 524, DMA Channel  109 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH109.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH109.
*/


/** \brief 528, DMA Channel  110 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH110.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH110.
*/


/** \brief 52C, DMA Channel  111 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH111.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH111.
*/


/** \brief 530, DMA Channel  112 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH112.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH112.
*/


/** \brief 534, DMA Channel  113 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH113.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH113.
*/


/** \brief 538, DMA Channel  114 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH114.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH114.
*/


/** \brief 53C, DMA Channel  115 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH115.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH115.
*/


/** \brief 540, DMA Channel  116 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH116.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH116.
*/


/** \brief 544, DMA Channel  117 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH117.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH117.
*/


/** \brief 548, DMA Channel  118 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH118.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH118.
*/


/** \brief 54C, DMA Channel  119 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH119.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH119.
*/


/** \brief 550, DMA Channel  120 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH120.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH120.
*/


/** \brief 554, DMA Channel  121 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH121.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH121.
*/


/** \brief 558, DMA Channel  122 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH122.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH122.
*/


/** \brief 55C, DMA Channel  123 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH123.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH123.
*/


/** \brief 560, DMA Channel  124 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH124.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH124.
*/


/** \brief 564, DMA Channel  125 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH125.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH125.
*/


/** \brief 568, DMA Channel  126 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH126.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH126.
*/


/** \brief 56C, DMA Channel  127 Service Request */

/** Alias (User Manual Name) for SRC_DMA_DMA0_CH127.
* To use register names with standard convension, please use SRC_DMA_DMA0_CH127.
*/


/** \brief 580, GETH Service Request 0 */

/** Alias (User Manual Name) for SRC_GETH_GETH0_SR0.
* To use register names with standard convension, please use SRC_GETH_GETH0_SR0.
*/


/** \brief 584, GETH Service Request 1 */

/** Alias (User Manual Name) for SRC_GETH_GETH0_SR1.
* To use register names with standard convension, please use SRC_GETH_GETH0_SR1.
*/


/** \brief 588, GETH Service Request 2 */

/** Alias (User Manual Name) for SRC_GETH_GETH0_SR2.
* To use register names with standard convension, please use SRC_GETH_GETH0_SR2.
*/


/** \brief 58C, GETH Service Request 3 */

/** Alias (User Manual Name) for SRC_GETH_GETH0_SR3.
* To use register names with standard convension, please use SRC_GETH_GETH0_SR3.
*/


/** \brief 590, GETH Service Request 4 */

/** Alias (User Manual Name) for SRC_GETH_GETH0_SR4.
* To use register names with standard convension, please use SRC_GETH_GETH0_SR4.
*/


/** \brief 594, GETH Service Request 5 */

/** Alias (User Manual Name) for SRC_GETH_GETH0_SR5.
* To use register names with standard convension, please use SRC_GETH_GETH0_SR5.
*/


/** \brief 598, GETH Service Request 6 */

/** Alias (User Manual Name) for SRC_GETH_GETH0_SR6.
* To use register names with standard convension, please use SRC_GETH_GETH0_SR6.
*/


/** \brief 59C, GETH Service Request 7 */

/** Alias (User Manual Name) for SRC_GETH_GETH0_SR7.
* To use register names with standard convension, please use SRC_GETH_GETH0_SR7.
*/


/** \brief 5A0, GETH Service Request 8 */

/** Alias (User Manual Name) for SRC_GETH_GETH0_SR8.
* To use register names with standard convension, please use SRC_GETH_GETH0_SR8.
*/


/** \brief 5A4, GETH Service Request 9 */

/** Alias (User Manual Name) for SRC_GETH_GETH0_SR9.
* To use register names with standard convension, please use SRC_GETH_GETH0_SR9.
*/


/** \brief 5B0, CAN0 Service Request 0 */

/** Alias (User Manual Name) for SRC_CAN_CAN0_INT0.
* To use register names with standard convension, please use SRC_CAN_CAN0_INT0.
*/


/** \brief 5B4, CAN0 Service Request 1 */

/** Alias (User Manual Name) for SRC_CAN_CAN0_INT1.
* To use register names with standard convension, please use SRC_CAN_CAN0_INT1.
*/


/** \brief 5B8, CAN0 Service Request 2 */

/** Alias (User Manual Name) for SRC_CAN_CAN0_INT2.
* To use register names with standard convension, please use SRC_CAN_CAN0_INT2.
*/


/** \brief 5BC, CAN0 Service Request 3 */

/** Alias (User Manual Name) for SRC_CAN_CAN0_INT3.
* To use register names with standard convension, please use SRC_CAN_CAN0_INT3.
*/


/** \brief 5C0, CAN0 Service Request 4 */

/** Alias (User Manual Name) for SRC_CAN_CAN0_INT4.
* To use register names with standard convension, please use SRC_CAN_CAN0_INT4.
*/


/** \brief 5C4, CAN0 Service Request 5 */

/** Alias (User Manual Name) for SRC_CAN_CAN0_INT5.
* To use register names with standard convension, please use SRC_CAN_CAN0_INT5.
*/


/** \brief 5C8, CAN0 Service Request 6 */

/** Alias (User Manual Name) for SRC_CAN_CAN0_INT6.
* To use register names with standard convension, please use SRC_CAN_CAN0_INT6.
*/


/** \brief 5CC, CAN0 Service Request 7 */

/** Alias (User Manual Name) for SRC_CAN_CAN0_INT7.
* To use register names with standard convension, please use SRC_CAN_CAN0_INT7.
*/


/** \brief 5D0, CAN0 Service Request 8 */

/** Alias (User Manual Name) for SRC_CAN_CAN0_INT8.
* To use register names with standard convension, please use SRC_CAN_CAN0_INT8.
*/


/** \brief 5D4, CAN0 Service Request 9 */

/** Alias (User Manual Name) for SRC_CAN_CAN0_INT9.
* To use register names with standard convension, please use SRC_CAN_CAN0_INT9.
*/


/** \brief 5D8, CAN0 Service Request 10 */

/** Alias (User Manual Name) for SRC_CAN_CAN0_INT10.
* To use register names with standard convension, please use SRC_CAN_CAN0_INT10.
*/


/** \brief 5DC, CAN0 Service Request 11 */

/** Alias (User Manual Name) for SRC_CAN_CAN0_INT11.
* To use register names with standard convension, please use SRC_CAN_CAN0_INT11.
*/


/** \brief 5E0, CAN0 Service Request 12 */

/** Alias (User Manual Name) for SRC_CAN_CAN0_INT12.
* To use register names with standard convension, please use SRC_CAN_CAN0_INT12.
*/


/** \brief 5E4, CAN0 Service Request 13 */

/** Alias (User Manual Name) for SRC_CAN_CAN0_INT13.
* To use register names with standard convension, please use SRC_CAN_CAN0_INT13.
*/


/** \brief 5E8, CAN0 Service Request 14 */

/** Alias (User Manual Name) for SRC_CAN_CAN0_INT14.
* To use register names with standard convension, please use SRC_CAN_CAN0_INT14.
*/


/** \brief 5EC, CAN0 Service Request 15 */

/** Alias (User Manual Name) for SRC_CAN_CAN0_INT15.
* To use register names with standard convension, please use SRC_CAN_CAN0_INT15.
*/


/** \brief 5F0, CAN1 Service Request 0 */

/** Alias (User Manual Name) for SRC_CAN_CAN1_INT0.
* To use register names with standard convension, please use SRC_CAN_CAN1_INT0.
*/


/** \brief 5F4, CAN1 Service Request 1 */

/** Alias (User Manual Name) for SRC_CAN_CAN1_INT1.
* To use register names with standard convension, please use SRC_CAN_CAN1_INT1.
*/


/** \brief 5F8, CAN1 Service Request 2 */

/** Alias (User Manual Name) for SRC_CAN_CAN1_INT2.
* To use register names with standard convension, please use SRC_CAN_CAN1_INT2.
*/


/** \brief 5FC, CAN1 Service Request 3 */

/** Alias (User Manual Name) for SRC_CAN_CAN1_INT3.
* To use register names with standard convension, please use SRC_CAN_CAN1_INT3.
*/


/** \brief 600, CAN1 Service Request 4 */

/** Alias (User Manual Name) for SRC_CAN_CAN1_INT4.
* To use register names with standard convension, please use SRC_CAN_CAN1_INT4.
*/


/** \brief 604, CAN1 Service Request 5 */

/** Alias (User Manual Name) for SRC_CAN_CAN1_INT5.
* To use register names with standard convension, please use SRC_CAN_CAN1_INT5.
*/


/** \brief 608, CAN1 Service Request 6 */

/** Alias (User Manual Name) for SRC_CAN_CAN1_INT6.
* To use register names with standard convension, please use SRC_CAN_CAN1_INT6.
*/


/** \brief 60C, CAN1 Service Request 7 */

/** Alias (User Manual Name) for SRC_CAN_CAN1_INT7.
* To use register names with standard convension, please use SRC_CAN_CAN1_INT7.
*/


/** \brief 610, CAN1 Service Request 8 */

/** Alias (User Manual Name) for SRC_CAN_CAN1_INT8.
* To use register names with standard convension, please use SRC_CAN_CAN1_INT8.
*/


/** \brief 614, CAN1 Service Request 9 */

/** Alias (User Manual Name) for SRC_CAN_CAN1_INT9.
* To use register names with standard convension, please use SRC_CAN_CAN1_INT9.
*/


/** \brief 618, CAN1 Service Request 10 */

/** Alias (User Manual Name) for SRC_CAN_CAN1_INT10.
* To use register names with standard convension, please use SRC_CAN_CAN1_INT10.
*/


/** \brief 61C, CAN1 Service Request 11 */

/** Alias (User Manual Name) for SRC_CAN_CAN1_INT11.
* To use register names with standard convension, please use SRC_CAN_CAN1_INT11.
*/


/** \brief 620, CAN1 Service Request 12 */

/** Alias (User Manual Name) for SRC_CAN_CAN1_INT12.
* To use register names with standard convension, please use SRC_CAN_CAN1_INT12.
*/


/** \brief 624, CAN1 Service Request 13 */

/** Alias (User Manual Name) for SRC_CAN_CAN1_INT13.
* To use register names with standard convension, please use SRC_CAN_CAN1_INT13.
*/


/** \brief 628, CAN1 Service Request 14 */

/** Alias (User Manual Name) for SRC_CAN_CAN1_INT14.
* To use register names with standard convension, please use SRC_CAN_CAN1_INT14.
*/


/** \brief 62C, CAN1 Service Request 15 */

/** Alias (User Manual Name) for SRC_CAN_CAN1_INT15.
* To use register names with standard convension, please use SRC_CAN_CAN1_INT15.
*/


/** \brief 630, CAN2 Service Request 0 */

/** Alias (User Manual Name) for SRC_CAN_CAN2_INT0.
* To use register names with standard convension, please use SRC_CAN_CAN2_INT0.
*/


/** \brief 634, CAN2 Service Request 1 */

/** Alias (User Manual Name) for SRC_CAN_CAN2_INT1.
* To use register names with standard convension, please use SRC_CAN_CAN2_INT1.
*/


/** \brief 638, CAN2 Service Request 2 */

/** Alias (User Manual Name) for SRC_CAN_CAN2_INT2.
* To use register names with standard convension, please use SRC_CAN_CAN2_INT2.
*/


/** \brief 63C, CAN2 Service Request 3 */

/** Alias (User Manual Name) for SRC_CAN_CAN2_INT3.
* To use register names with standard convension, please use SRC_CAN_CAN2_INT3.
*/


/** \brief 640, CAN2 Service Request 4 */

/** Alias (User Manual Name) for SRC_CAN_CAN2_INT4.
* To use register names with standard convension, please use SRC_CAN_CAN2_INT4.
*/


/** \brief 644, CAN2 Service Request 5 */

/** Alias (User Manual Name) for SRC_CAN_CAN2_INT5.
* To use register names with standard convension, please use SRC_CAN_CAN2_INT5.
*/


/** \brief 648, CAN2 Service Request 6 */

/** Alias (User Manual Name) for SRC_CAN_CAN2_INT6.
* To use register names with standard convension, please use SRC_CAN_CAN2_INT6.
*/


/** \brief 64C, CAN2 Service Request 7 */

/** Alias (User Manual Name) for SRC_CAN_CAN2_INT7.
* To use register names with standard convension, please use SRC_CAN_CAN2_INT7.
*/


/** \brief 650, CAN2 Service Request 8 */

/** Alias (User Manual Name) for SRC_CAN_CAN2_INT8.
* To use register names with standard convension, please use SRC_CAN_CAN2_INT8.
*/


/** \brief 654, CAN2 Service Request 9 */

/** Alias (User Manual Name) for SRC_CAN_CAN2_INT9.
* To use register names with standard convension, please use SRC_CAN_CAN2_INT9.
*/


/** \brief 658, CAN2 Service Request 10 */

/** Alias (User Manual Name) for SRC_CAN_CAN2_INT10.
* To use register names with standard convension, please use SRC_CAN_CAN2_INT10.
*/


/** \brief 65C, CAN2 Service Request 11 */

/** Alias (User Manual Name) for SRC_CAN_CAN2_INT11.
* To use register names with standard convension, please use SRC_CAN_CAN2_INT11.
*/


/** \brief 660, CAN2 Service Request 12 */

/** Alias (User Manual Name) for SRC_CAN_CAN2_INT12.
* To use register names with standard convension, please use SRC_CAN_CAN2_INT12.
*/


/** \brief 664, CAN2 Service Request 13 */

/** Alias (User Manual Name) for SRC_CAN_CAN2_INT13.
* To use register names with standard convension, please use SRC_CAN_CAN2_INT13.
*/


/** \brief 668, CAN2 Service Request 14 */

/** Alias (User Manual Name) for SRC_CAN_CAN2_INT14.
* To use register names with standard convension, please use SRC_CAN_CAN2_INT14.
*/


/** \brief 66C, CAN2 Service Request 15 */

/** Alias (User Manual Name) for SRC_CAN_CAN2_INT15.
* To use register names with standard convension, please use SRC_CAN_CAN2_INT15.
*/


/** \brief 670, EVADC Group 0 Service Request 0 */

/** Alias (User Manual Name) for SRC_VADC_G0_SR0.
* To use register names with standard convension, please use SRC_VADC_G0_SR0.
*/


/** \brief 674, EVADC Group 0 Service Request 1 */

/** Alias (User Manual Name) for SRC_VADC_G0_SR1.
* To use register names with standard convension, please use SRC_VADC_G0_SR1.
*/


/** \brief 678, EVADC Group 0 Service Request 2 */

/** Alias (User Manual Name) for SRC_VADC_G0_SR2.
* To use register names with standard convension, please use SRC_VADC_G0_SR2.
*/


/** \brief 67C, EVADC Group 0 Service Request 3 */

/** Alias (User Manual Name) for SRC_VADC_G0_SR3.
* To use register names with standard convension, please use SRC_VADC_G0_SR3.
*/


/** \brief 680, EVADC Group 1 Service Request 0 */

/** Alias (User Manual Name) for SRC_VADC_G1_SR0.
* To use register names with standard convension, please use SRC_VADC_G1_SR0.
*/


/** \brief 684, EVADC Group 1 Service Request 1 */

/** Alias (User Manual Name) for SRC_VADC_G1_SR1.
* To use register names with standard convension, please use SRC_VADC_G1_SR1.
*/


/** \brief 688, EVADC Group 1 Service Request 2 */

/** Alias (User Manual Name) for SRC_VADC_G1_SR2.
* To use register names with standard convension, please use SRC_VADC_G1_SR2.
*/


/** \brief 68C, EVADC Group 1 Service Request 3 */

/** Alias (User Manual Name) for SRC_VADC_G1_SR3.
* To use register names with standard convension, please use SRC_VADC_G1_SR3.
*/


/** \brief 690, EVADC Group 2 Service Request 0 */

/** Alias (User Manual Name) for SRC_VADC_G2_SR0.
* To use register names with standard convension, please use SRC_VADC_G2_SR0.
*/


/** \brief 694, EVADC Group 2 Service Request 1 */

/** Alias (User Manual Name) for SRC_VADC_G2_SR1.
* To use register names with standard convension, please use SRC_VADC_G2_SR1.
*/


/** \brief 698, EVADC Group 2 Service Request 2 */

/** Alias (User Manual Name) for SRC_VADC_G2_SR2.
* To use register names with standard convension, please use SRC_VADC_G2_SR2.
*/


/** \brief 69C, EVADC Group 2 Service Request 3 */

/** Alias (User Manual Name) for SRC_VADC_G2_SR3.
* To use register names with standard convension, please use SRC_VADC_G2_SR3.
*/


/** \brief 6A0, EVADC Group 3 Service Request 0 */

/** Alias (User Manual Name) for SRC_VADC_G3_SR0.
* To use register names with standard convension, please use SRC_VADC_G3_SR0.
*/


/** \brief 6A4, EVADC Group 3 Service Request 1 */

/** Alias (User Manual Name) for SRC_VADC_G3_SR1.
* To use register names with standard convension, please use SRC_VADC_G3_SR1.
*/


/** \brief 6A8, EVADC Group 3 Service Request 2 */

/** Alias (User Manual Name) for SRC_VADC_G3_SR2.
* To use register names with standard convension, please use SRC_VADC_G3_SR2.
*/


/** \brief 6AC, EVADC Group 3 Service Request 3 */

/** Alias (User Manual Name) for SRC_VADC_G3_SR3.
* To use register names with standard convension, please use SRC_VADC_G3_SR3.
*/


/** \brief 6B0, EVADC Group 4 Service Request 0 */

/** Alias (User Manual Name) for SRC_VADC_G4_SR0.
* To use register names with standard convension, please use SRC_VADC_G4_SR0.
*/


/** \brief 6B4, EVADC Group 4 Service Request 1 */

/** Alias (User Manual Name) for SRC_VADC_G4_SR1.
* To use register names with standard convension, please use SRC_VADC_G4_SR1.
*/


/** \brief 6B8, EVADC Group 4 Service Request 2 */

/** Alias (User Manual Name) for SRC_VADC_G4_SR2.
* To use register names with standard convension, please use SRC_VADC_G4_SR2.
*/


/** \brief 6BC, EVADC Group 4 Service Request 3 */

/** Alias (User Manual Name) for SRC_VADC_G4_SR3.
* To use register names with standard convension, please use SRC_VADC_G4_SR3.
*/


/** \brief 6C0, EVADC Group 5 Service Request 0 */

/** Alias (User Manual Name) for SRC_VADC_G5_SR0.
* To use register names with standard convension, please use SRC_VADC_G5_SR0.
*/


/** \brief 6C4, EVADC Group 5 Service Request 1 */

/** Alias (User Manual Name) for SRC_VADC_G5_SR1.
* To use register names with standard convension, please use SRC_VADC_G5_SR1.
*/


/** \brief 6C8, EVADC Group 5 Service Request 2 */

/** Alias (User Manual Name) for SRC_VADC_G5_SR2.
* To use register names with standard convension, please use SRC_VADC_G5_SR2.
*/


/** \brief 6CC, EVADC Group 5 Service Request 3 */

/** Alias (User Manual Name) for SRC_VADC_G5_SR3.
* To use register names with standard convension, please use SRC_VADC_G5_SR3.
*/


/** \brief 6D0, EVADC Group 6 Service Request 0 */

/** Alias (User Manual Name) for SRC_VADC_G6_SR0.
* To use register names with standard convension, please use SRC_VADC_G6_SR0.
*/


/** \brief 6D4, EVADC Group 6 Service Request 1 */

/** Alias (User Manual Name) for SRC_VADC_G6_SR1.
* To use register names with standard convension, please use SRC_VADC_G6_SR1.
*/


/** \brief 6D8, EVADC Group 6 Service Request 2 */

/** Alias (User Manual Name) for SRC_VADC_G6_SR2.
* To use register names with standard convension, please use SRC_VADC_G6_SR2.
*/


/** \brief 6DC, EVADC Group 6 Service Request 3 */

/** Alias (User Manual Name) for SRC_VADC_G6_SR3.
* To use register names with standard convension, please use SRC_VADC_G6_SR3.
*/


/** \brief 6E0, EVADC Group 7 Service Request 0 */

/** Alias (User Manual Name) for SRC_VADC_G7_SR0.
* To use register names with standard convension, please use SRC_VADC_G7_SR0.
*/


/** \brief 6E4, EVADC Group 7 Service Request 1 */

/** Alias (User Manual Name) for SRC_VADC_G7_SR1.
* To use register names with standard convension, please use SRC_VADC_G7_SR1.
*/


/** \brief 6E8, EVADC Group 7 Service Request 2 */

/** Alias (User Manual Name) for SRC_VADC_G7_SR2.
* To use register names with standard convension, please use SRC_VADC_G7_SR2.
*/


/** \brief 6EC, EVADC Group 7 Service Request 3 */

/** Alias (User Manual Name) for SRC_VADC_G7_SR3.
* To use register names with standard convension, please use SRC_VADC_G7_SR3.
*/


/** \brief 6F0, EVADC Group 8 Service Request 0 */

/** Alias (User Manual Name) for SRC_VADC_G8_SR0.
* To use register names with standard convension, please use SRC_VADC_G8_SR0.
*/


/** \brief 6F4, EVADC Group 8 Service Request 1 */

/** Alias (User Manual Name) for SRC_VADC_G8_SR1.
* To use register names with standard convension, please use SRC_VADC_G8_SR1.
*/


/** \brief 6F8, EVADC Group 8 Service Request 2 */

/** Alias (User Manual Name) for SRC_VADC_G8_SR2.
* To use register names with standard convension, please use SRC_VADC_G8_SR2.
*/


/** \brief 6FC, EVADC Group 8 Service Request 3 */

/** Alias (User Manual Name) for SRC_VADC_G8_SR3.
* To use register names with standard convension, please use SRC_VADC_G8_SR3.
*/


/** \brief 700, EVADC Group 9 Service Request 0 */

/** Alias (User Manual Name) for SRC_VADC_G9_SR0.
* To use register names with standard convension, please use SRC_VADC_G9_SR0.
*/


/** \brief 704, EVADC Group 9 Service Request 1 */

/** Alias (User Manual Name) for SRC_VADC_G9_SR1.
* To use register names with standard convension, please use SRC_VADC_G9_SR1.
*/


/** \brief 708, EVADC Group 9 Service Request 2 */

/** Alias (User Manual Name) for SRC_VADC_G9_SR2.
* To use register names with standard convension, please use SRC_VADC_G9_SR2.
*/


/** \brief 70C, EVADC Group 9 Service Request 3 */

/** Alias (User Manual Name) for SRC_VADC_G9_SR3.
* To use register names with standard convension, please use SRC_VADC_G9_SR3.
*/


/** \brief 710, EVADC Group 10 Service Request 0 */

/** Alias (User Manual Name) for SRC_VADC_G10_SR0.
* To use register names with standard convension, please use SRC_VADC_G10_SR0.
*/


/** \brief 714, EVADC Group 10 Service Request 1 */

/** Alias (User Manual Name) for SRC_VADC_G10_SR1.
* To use register names with standard convension, please use SRC_VADC_G10_SR1.
*/


/** \brief 718, EVADC Group 10 Service Request 2 */

/** Alias (User Manual Name) for SRC_VADC_G10_SR2.
* To use register names with standard convension, please use SRC_VADC_G10_SR2.
*/


/** \brief 71C, EVADC Group 10 Service Request 3 */

/** Alias (User Manual Name) for SRC_VADC_G10_SR3.
* To use register names with standard convension, please use SRC_VADC_G10_SR3.
*/


/** \brief 720, EVADC Group 11 Service Request 0 */

/** Alias (User Manual Name) for SRC_VADC_G11_SR0.
* To use register names with standard convension, please use SRC_VADC_G11_SR0.
*/


/** \brief 724, EVADC Group 11 Service Request 1 */

/** Alias (User Manual Name) for SRC_VADC_G11_SR1.
* To use register names with standard convension, please use SRC_VADC_G11_SR1.
*/


/** \brief 728, EVADC Group 11 Service Request 2 */

/** Alias (User Manual Name) for SRC_VADC_G11_SR2.
* To use register names with standard convension, please use SRC_VADC_G11_SR2.
*/


/** \brief 72C, EVADC Group 11 Service Request 3 */

/** Alias (User Manual Name) for SRC_VADC_G11_SR3.
* To use register names with standard convension, please use SRC_VADC_G11_SR3.
*/


/** \brief 730, EVADC Fast Compare 0 Service Request SR0 */

/** Alias (User Manual Name) for SRC_VADC_FC0_SR0.
* To use register names with standard convension, please use SRC_VADC_FC0_SR0.
*/


/** \brief 734, EVADC Fast Compare 1 Service Request SR0 */

/** Alias (User Manual Name) for SRC_VADC_FC1_SR0.
* To use register names with standard convension, please use SRC_VADC_FC1_SR0.
*/


/** \brief 738, EVADC Fast Compare 2 Service Request SR0 */

/** Alias (User Manual Name) for SRC_VADC_FC2_SR0.
* To use register names with standard convension, please use SRC_VADC_FC2_SR0.
*/


/** \brief 73C, EVADC Fast Compare 3 Service Request SR0 */

/** Alias (User Manual Name) for SRC_VADC_FC3_SR0.
* To use register names with standard convension, please use SRC_VADC_FC3_SR0.
*/


/** \brief 750, EVADC Common Group 0 Service Request 0 */

/** Alias (User Manual Name) for SRC_VADC_CG0_SR0.
* To use register names with standard convension, please use SRC_VADC_CG0_SR0.
*/


/** \brief 754, EVADC Common Group 0 Service Request 1 */

/** Alias (User Manual Name) for SRC_VADC_CG0_SR1.
* To use register names with standard convension, please use SRC_VADC_CG0_SR1.
*/


/** \brief 758, EVADC Common Group 0 Service Request 2 */

/** Alias (User Manual Name) for SRC_VADC_CG0_SR2.
* To use register names with standard convension, please use SRC_VADC_CG0_SR2.
*/


/** \brief 75C, EVADC Common Group 0 Service Request 3 */

/** Alias (User Manual Name) for SRC_VADC_CG0_SR3.
* To use register names with standard convension, please use SRC_VADC_CG0_SR3.
*/


/** \brief 760, EVADC Common Group 1 Service Request 0 */

/** Alias (User Manual Name) for SRC_VADC_CG1_SR0.
* To use register names with standard convension, please use SRC_VADC_CG1_SR0.
*/


/** \brief 764, EVADC Common Group 1 Service Request 1 */

/** Alias (User Manual Name) for SRC_VADC_CG1_SR1.
* To use register names with standard convension, please use SRC_VADC_CG1_SR1.
*/


/** \brief 768, EVADC Common Group 1 Service Request 2 */

/** Alias (User Manual Name) for SRC_VADC_CG1_SR2.
* To use register names with standard convension, please use SRC_VADC_CG1_SR2.
*/


/** \brief 76C, EVADC Common Group 1 Service Request 3 */

/** Alias (User Manual Name) for SRC_VADC_CG1_SR3.
* To use register names with standard convension, please use SRC_VADC_CG1_SR3.
*/


/** \brief 770, DSADC SRM0 Service Request */

/** Alias (User Manual Name) for SRC_DSADC_DSADC0_SRM.
* To use register names with standard convension, please use SRC_DSADC_DSADC0_SRM.
*/


/** \brief 774, DSADC SRA0 Service Request */

/** Alias (User Manual Name) for SRC_DSADC_DSADC0_SRA.
* To use register names with standard convension, please use SRC_DSADC_DSADC0_SRA.
*/


/** \brief 778, DSADC SRM1 Service Request */

/** Alias (User Manual Name) for SRC_DSADC_DSADC1_SRM.
* To use register names with standard convension, please use SRC_DSADC_DSADC1_SRM.
*/


/** \brief 77C, DSADC SRA1 Service Request */

/** Alias (User Manual Name) for SRC_DSADC_DSADC1_SRA.
* To use register names with standard convension, please use SRC_DSADC_DSADC1_SRA.
*/


/** \brief 780, DSADC SRM2 Service Request */

/** Alias (User Manual Name) for SRC_DSADC_DSADC2_SRM.
* To use register names with standard convension, please use SRC_DSADC_DSADC2_SRM.
*/


/** \brief 784, DSADC SRA2 Service Request */

/** Alias (User Manual Name) for SRC_DSADC_DSADC2_SRA.
* To use register names with standard convension, please use SRC_DSADC_DSADC2_SRA.
*/


/** \brief 788, DSADC SRM3 Service Request */

/** Alias (User Manual Name) for SRC_DSADC_DSADC3_SRM.
* To use register names with standard convension, please use SRC_DSADC_DSADC3_SRM.
*/


/** \brief 78C, DSADC SRA3 Service Request */

/** Alias (User Manual Name) for SRC_DSADC_DSADC3_SRA.
* To use register names with standard convension, please use SRC_DSADC_DSADC3_SRA.
*/


/** \brief 790, DSADC SRM4 Service Request */

/** Alias (User Manual Name) for SRC_DSADC_DSADC4_SRM.
* To use register names with standard convension, please use SRC_DSADC_DSADC4_SRM.
*/


/** \brief 794, DSADC SRA4 Service Request */

/** Alias (User Manual Name) for SRC_DSADC_DSADC4_SRA.
* To use register names with standard convension, please use SRC_DSADC_DSADC4_SRA.
*/


/** \brief 798, DSADC SRM5 Service Request */

/** Alias (User Manual Name) for SRC_DSADC_DSADC5_SRM.
* To use register names with standard convension, please use SRC_DSADC_DSADC5_SRM.
*/


/** \brief 79C, DSADC SRA5 Service Request */

/** Alias (User Manual Name) for SRC_DSADC_DSADC5_SRA.
* To use register names with standard convension, please use SRC_DSADC_DSADC5_SRA.
*/


/** \brief 7A0, DSADC SRM6 Service Request */

/** Alias (User Manual Name) for SRC_DSADC_DSADC6_SRM.
* To use register names with standard convension, please use SRC_DSADC_DSADC6_SRM.
*/


/** \brief 7A4, DSADC SRA6 Service Request */

/** Alias (User Manual Name) for SRC_DSADC_DSADC6_SRA.
* To use register names with standard convension, please use SRC_DSADC_DSADC6_SRA.
*/


/** \brief 7A8, DSADC SRM7 Service Request */

/** Alias (User Manual Name) for SRC_DSADC_DSADC7_SRM.
* To use register names with standard convension, please use SRC_DSADC_DSADC7_SRM.
*/


/** \brief 7AC, DSADC SRA7 Service Request */

/** Alias (User Manual Name) for SRC_DSADC_DSADC7_SRA.
* To use register names with standard convension, please use SRC_DSADC_DSADC7_SRA.
*/


/** \brief 7B0, DSADC SRM8 Service Request */

/** Alias (User Manual Name) for SRC_DSADC_DSADC8_SRM.
* To use register names with standard convension, please use SRC_DSADC_DSADC8_SRM.
*/


/** \brief 7B4, DSADC SRA8 Service Request */

/** Alias (User Manual Name) for SRC_DSADC_DSADC8_SRA.
* To use register names with standard convension, please use SRC_DSADC_DSADC8_SRA.
*/


/** \brief 7B8, DSADC SRM9 Service Request */

/** Alias (User Manual Name) for SRC_DSADC_DSADC9_SRM.
* To use register names with standard convension, please use SRC_DSADC_DSADC9_SRM.
*/


/** \brief 7BC, DSADC SRA9 Service Request */

/** Alias (User Manual Name) for SRC_DSADC_DSADC9_SRA.
* To use register names with standard convension, please use SRC_DSADC_DSADC9_SRA.
*/


/** \brief 7E0, ASCLIN12 Transmit Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN12_TX.
* To use register names with standard convension, please use SRC_ASCLIN12_TX.
*/


/** \brief 7E4, ASCLIN12 Receive Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN12_RX.
* To use register names with standard convension, please use SRC_ASCLIN12_RX.
*/


/** \brief 7E8, ASCLIN12 Error Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN12_ERR.
* To use register names with standard convension, please use SRC_ASCLIN12_ERR.
*/


/** \brief 7EC, ASCLIN13 Transmit Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN13_TX.
* To use register names with standard convension, please use SRC_ASCLIN13_TX.
*/


/** \brief 7F0, ASCLIN13 Receive Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN13_RX.
* To use register names with standard convension, please use SRC_ASCLIN13_RX.
*/


/** \brief 7F4, ASCLIN13 Error Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN13_ERR.
* To use register names with standard convension, please use SRC_ASCLIN13_ERR.
*/


/** \brief 800, E-RAY 0 Service Request 0 */

/** Alias (User Manual Name) for SRC_ERAY_ERAY0_INT0.
* To use register names with standard convension, please use SRC_ERAY_ERAY0_INT0.
*/


/** \brief 804, E-RAY 0 Service Request 1 */

/** Alias (User Manual Name) for SRC_ERAY_ERAY0_INT1.
* To use register names with standard convension, please use SRC_ERAY_ERAY0_INT1.
*/


/** \brief 808, E-RAY 0 Timer Interrupt 0 Service Request */

/** Alias (User Manual Name) for SRC_ERAY_ERAY0_TINT0.
* To use register names with standard convension, please use SRC_ERAY_ERAY0_TINT0.
*/


/** \brief 80C, E-RAY 0 Timer Interrupt 1 Service Request */

/** Alias (User Manual Name) for SRC_ERAY_ERAY0_TINT1.
* To use register names with standard convension, please use SRC_ERAY_ERAY0_TINT1.
*/


/** \brief 810, E-RAY 0 New Data 0 Service Request */

/** Alias (User Manual Name) for SRC_ERAY_ERAY0_NDAT0.
* To use register names with standard convension, please use SRC_ERAY_ERAY0_NDAT0.
*/


/** \brief 814, E-RAY 0 New Data 1 Service Request */

/** Alias (User Manual Name) for SRC_ERAY_ERAY0_NDAT1.
* To use register names with standard convension, please use SRC_ERAY_ERAY0_NDAT1.
*/


/** \brief 818, E-RAY 0 Message Buffer Status Changed 0 Service Request */

/** Alias (User Manual Name) for SRC_ERAY_ERAY0_MBSC0.
* To use register names with standard convension, please use SRC_ERAY_ERAY0_MBSC0.
*/


/** \brief 81C, E-RAY 0 Message Buffer Status Changed 1 Service Request */

/** Alias (User Manual Name) for SRC_ERAY_ERAY0_MBSC1.
* To use register names with standard convension, please use SRC_ERAY_ERAY0_MBSC1.
*/


/** \brief 820, E-RAY 0 Output Buffer Busy */

/** Alias (User Manual Name) for SRC_ERAY_ERAY0_OBUSY.
* To use register names with standard convension, please use SRC_ERAY_ERAY0_OBUSY.
*/


/** \brief 824, E-RAY 0 Input Buffer Busy */

/** Alias (User Manual Name) for SRC_ERAY_ERAY0_IBUSY.
* To use register names with standard convension, please use SRC_ERAY_ERAY0_IBUSY.
*/


/** \brief 830, E-RAY 1 Service Request 0 */

/** Alias (User Manual Name) for SRC_ERAY_ERAY1_INT0.
* To use register names with standard convension, please use SRC_ERAY_ERAY1_INT0.
*/


/** \brief 834, E-RAY 1 Service Request 1 */

/** Alias (User Manual Name) for SRC_ERAY_ERAY1_INT1.
* To use register names with standard convension, please use SRC_ERAY_ERAY1_INT1.
*/


/** \brief 838, E-RAY 1 Timer Interrupt 0 Service Request */

/** Alias (User Manual Name) for SRC_ERAY_ERAY1_TINT0.
* To use register names with standard convension, please use SRC_ERAY_ERAY1_TINT0.
*/


/** \brief 83C, E-RAY 1 Timer Interrupt 1 Service Request */

/** Alias (User Manual Name) for SRC_ERAY_ERAY1_TINT1.
* To use register names with standard convension, please use SRC_ERAY_ERAY1_TINT1.
*/


/** \brief 840, E-RAY 1 New Data 0 Service Request */

/** Alias (User Manual Name) for SRC_ERAY_ERAY1_NDAT0.
* To use register names with standard convension, please use SRC_ERAY_ERAY1_NDAT0.
*/


/** \brief 844, E-RAY 1 New Data 1 Service Request */

/** Alias (User Manual Name) for SRC_ERAY_ERAY1_NDAT1.
* To use register names with standard convension, please use SRC_ERAY_ERAY1_NDAT1.
*/


/** \brief 848, E-RAY 1 Message Buffer Status Changed 0 Service Request */

/** Alias (User Manual Name) for SRC_ERAY_ERAY1_MBSC0.
* To use register names with standard convension, please use SRC_ERAY_ERAY1_MBSC0.
*/


/** \brief 84C, E-RAY 1 Message Buffer Status Changed 1 Service Request */

/** Alias (User Manual Name) for SRC_ERAY_ERAY1_MBSC1.
* To use register names with standard convension, please use SRC_ERAY_ERAY1_MBSC1.
*/


/** \brief 850, E-RAY 1 Output Buffer Busy */

/** Alias (User Manual Name) for SRC_ERAY_ERAY1_OBUSY.
* To use register names with standard convension, please use SRC_ERAY_ERAY1_OBUSY.
*/


/** \brief 854, E-RAY 1 Input Buffer Busy */

/** Alias (User Manual Name) for SRC_ERAY_ERAY1_IBUSY.
* To use register names with standard convension, please use SRC_ERAY_ERAY1_IBUSY.
*/


/** \brief 860, DMU Host Service Request */


/** \brief 864, DMU FSI Service Request */


/** \brief 870, HSM Service Request 0 */

/** Alias (User Manual Name) for SRC_HSM_HSM0_HSM0.
* To use register names with standard convension, please use SRC_HSM_HSM0_HSM0.
*/


/** \brief 874, HSM Service Request 1 */

/** Alias (User Manual Name) for SRC_HSM_HSM0_HSM1.
* To use register names with standard convension, please use SRC_HSM_HSM0_HSM1.
*/


/** \brief 880, SCU ERU Service Request 0 */

/** Alias (User Manual Name) for SRC_SCU_SCUERU0.
* To use register names with standard convension, please use SRC_SCU_SCUERU0.
*/


/** \brief 884, SCU ERU Service Request 1 */

/** Alias (User Manual Name) for SRC_SCU_SCUERU1.
* To use register names with standard convension, please use SRC_SCU_SCUERU1.
*/


/** \brief 888, SCU ERU Service Request 2 */

/** Alias (User Manual Name) for SRC_SCU_SCUERU2.
* To use register names with standard convension, please use SRC_SCU_SCUERU2.
*/


/** \brief 88C, SCU ERU Service Request 3 */

/** Alias (User Manual Name) for SRC_SCU_SCUERU3.
* To use register names with standard convension, please use SRC_SCU_SCUERU3.
*/


/** \brief 8AC, PMS DTS Service Request */


/** \brief 8B0, Power Management System Service Request 0 */

/** Alias (User Manual Name) for SRC_PMS_PMS0_SR.
* To use register names with standard convension, please use SRC_PMS_PMS0_SR.
*/


/** \brief 8B4, Power Management System Service Request 1 */

/** Alias (User Manual Name) for SRC_PMS_PMS1_SR.
* To use register names with standard convension, please use SRC_PMS_PMS1_SR.
*/


/** \brief 8B8, Power Management System Service Request 2 */

/** Alias (User Manual Name) for SRC_PMS_PMS2_SR.
* To use register names with standard convension, please use SRC_PMS_PMS2_SR.
*/


/** \brief 8BC, Power Management System Service Request 3 */

/** Alias (User Manual Name) for SRC_PMS_PMS3_SR.
* To use register names with standard convension, please use SRC_PMS_PMS3_SR.
*/


/** \brief 8C0, Stand By Controller Service Request */


/** \brief 8D0, SMU Service Request 0 */

/** Alias (User Manual Name) for SRC_SMU_SMU0_SR0.
* To use register names with standard convension, please use SRC_SMU_SMU0_SR0.
*/


/** \brief 8D4, SMU Service Request 1 */

/** Alias (User Manual Name) for SRC_SMU_SMU0_SR1.
* To use register names with standard convension, please use SRC_SMU_SMU0_SR1.
*/


/** \brief 8D8, SMU Service Request 2 */

/** Alias (User Manual Name) for SRC_SMU_SMU0_SR2.
* To use register names with standard convension, please use SRC_SMU_SMU0_SR2.
*/


/** \brief 8E0, PSI5 Service Request 0 */

/** Alias (User Manual Name) for SRC_PSI5_PSI50_SR0.
* To use register names with standard convension, please use SRC_PSI5_PSI50_SR0.
*/


/** \brief 8E4, PSI5 Service Request 1 */

/** Alias (User Manual Name) for SRC_PSI5_PSI50_SR1.
* To use register names with standard convension, please use SRC_PSI5_PSI50_SR1.
*/


/** \brief 8E8, PSI5 Service Request 2 */

/** Alias (User Manual Name) for SRC_PSI5_PSI50_SR2.
* To use register names with standard convension, please use SRC_PSI5_PSI50_SR2.
*/


/** \brief 8EC, PSI5 Service Request 3 */

/** Alias (User Manual Name) for SRC_PSI5_PSI50_SR3.
* To use register names with standard convension, please use SRC_PSI5_PSI50_SR3.
*/


/** \brief 8F0, PSI5 Service Request 4 */

/** Alias (User Manual Name) for SRC_PSI5_PSI50_SR4.
* To use register names with standard convension, please use SRC_PSI5_PSI50_SR4.
*/


/** \brief 8F4, PSI5 Service Request 5 */

/** Alias (User Manual Name) for SRC_PSI5_PSI50_SR5.
* To use register names with standard convension, please use SRC_PSI5_PSI50_SR5.
*/


/** \brief 8F8, PSI5 Service Request 6 */

/** Alias (User Manual Name) for SRC_PSI5_PSI50_SR6.
* To use register names with standard convension, please use SRC_PSI5_PSI50_SR6.
*/


/** \brief 8FC, PSI5 Service Request 7 */

/** Alias (User Manual Name) for SRC_PSI5_PSI50_SR7.
* To use register names with standard convension, please use SRC_PSI5_PSI50_SR7.
*/


/** \brief 910, DAM0 Limit 0 Service Request */

/** Alias (User Manual Name) for SRC_DAM_DAM0_LI0.
* To use register names with standard convension, please use SRC_DAM_DAM0_LI0.
*/


/** \brief 914, DAM0 Ready 0 Service Reques */

/** Alias (User Manual Name) for SRC_DAM_DAM0_RI0.
* To use register names with standard convension, please use SRC_DAM_DAM0_RI0.
*/


/** \brief 918, DAM0 Limit 1 Service Request */

/** Alias (User Manual Name) for SRC_DAM_DAM0_LI1.
* To use register names with standard convension, please use SRC_DAM_DAM0_LI1.
*/


/** \brief 91C, DAM0 Ready 1 Service Request */

/** Alias (User Manual Name) for SRC_DAM_DAM0_RI1.
* To use register names with standard convension, please use SRC_DAM_DAM0_RI1.
*/


/** \brief 920, DAM0 DMA Ready Service Request */

/** Alias (User Manual Name) for SRC_DAM_DAM0_DR.
* To use register names with standard convension, please use SRC_DAM_DAM0_DR.
*/


/** \brief 924, DAM0 Error Service Request */

/** Alias (User Manual Name) for SRC_DAM_DAM0_ERR.
* To use register names with standard convension, please use SRC_DAM_DAM0_ERR.
*/


/** \brief 950, PSI5-S Service Request 0 */

/** Alias (User Manual Name) for SRC_PSI5S_PSI5S0_SR0.
* To use register names with standard convension, please use SRC_PSI5S_PSI5S0_SR0.
*/


/** \brief 954, PSI5-S Service Request 1 */

/** Alias (User Manual Name) for SRC_PSI5S_PSI5S0_SR1.
* To use register names with standard convension, please use SRC_PSI5S_PSI5S0_SR1.
*/


/** \brief 958, PSI5-S Service Request 2 */

/** Alias (User Manual Name) for SRC_PSI5S_PSI5S0_SR2.
* To use register names with standard convension, please use SRC_PSI5S_PSI5S0_SR2.
*/


/** \brief 95C, PSI5-S Service Request 3 */

/** Alias (User Manual Name) for SRC_PSI5S_PSI5S0_SR3.
* To use register names with standard convension, please use SRC_PSI5S_PSI5S0_SR3.
*/


/** \brief 960, PSI5-S Service Request 4 */

/** Alias (User Manual Name) for SRC_PSI5S_PSI5S0_SR4.
* To use register names with standard convension, please use SRC_PSI5S_PSI5S0_SR4.
*/


/** \brief 964, PSI5-S Service Request 5 */

/** Alias (User Manual Name) for SRC_PSI5S_PSI5S0_SR5.
* To use register names with standard convension, please use SRC_PSI5S_PSI5S0_SR5.
*/


/** \brief 968, PSI5-S Service Request 6 */

/** Alias (User Manual Name) for SRC_PSI5S_PSI5S0_SR6.
* To use register names with standard convension, please use SRC_PSI5S_PSI5S0_SR6.
*/


/** \brief 96C, PSI5-S Service Request 7 */

/** Alias (User Manual Name) for SRC_PSI5S_PSI5S0_SR7.
* To use register names with standard convension, please use SRC_PSI5S_PSI5S0_SR7.
*/


/** \brief 990, General Purpose Group 0 Service Request 0 */

/** Alias (User Manual Name) for SRC_GPSR_GPSR0_SR0.
* To use register names with standard convension, please use SRC_GPSR_GPSR0_SR0.
*/


/** \brief 994, General Purpose Group 0 Service Request 1 */

/** Alias (User Manual Name) for SRC_GPSR_GPSR0_SR1.
* To use register names with standard convension, please use SRC_GPSR_GPSR0_SR1.
*/


/** \brief 998, General Purpose Group 0 Service Request 2 */

/** Alias (User Manual Name) for SRC_GPSR_GPSR0_SR2.
* To use register names with standard convension, please use SRC_GPSR_GPSR0_SR2.
*/


/** \brief 99C, General Purpose Group 0 Service Request 3 */

/** Alias (User Manual Name) for SRC_GPSR_GPSR0_SR3.
* To use register names with standard convension, please use SRC_GPSR_GPSR0_SR3.
*/


/** \brief 9A0, General Purpose Group 0 Service Request 4 */

/** Alias (User Manual Name) for SRC_GPSR_GPSR0_SR4.
* To use register names with standard convension, please use SRC_GPSR_GPSR0_SR4.
*/


/** \brief 9A4, General Purpose Group 0 Service Request 5 */

/** Alias (User Manual Name) for SRC_GPSR_GPSR0_SR5.
* To use register names with standard convension, please use SRC_GPSR_GPSR0_SR5.
*/


/** \brief 9A8, General Purpose Group 0 Service Request 6 */

/** Alias (User Manual Name) for SRC_GPSR_GPSR0_SR6.
* To use register names with standard convension, please use SRC_GPSR_GPSR0_SR6.
*/


/** \brief 9AC, General Purpose Group 0 Service Request 7 */

/** Alias (User Manual Name) for SRC_GPSR_GPSR0_SR7.
* To use register names with standard convension, please use SRC_GPSR_GPSR0_SR7.
*/


/** \brief 9B0, General Purpose Group 1 Service Request 0 */

/** Alias (User Manual Name) for SRC_GPSR_GPSR1_SR0.
* To use register names with standard convension, please use SRC_GPSR_GPSR1_SR0.
*/


/** \brief 9B4, General Purpose Group 1 Service Request 1 */

/** Alias (User Manual Name) for SRC_GPSR_GPSR1_SR1.
* To use register names with standard convension, please use SRC_GPSR_GPSR1_SR1.
*/


/** \brief 9B8, General Purpose Group 1 Service Request 2 */

/** Alias (User Manual Name) for SRC_GPSR_GPSR1_SR2.
* To use register names with standard convension, please use SRC_GPSR_GPSR1_SR2.
*/


/** \brief 9BC, General Purpose Group 1 Service Request 3 */

/** Alias (User Manual Name) for SRC_GPSR_GPSR1_SR3.
* To use register names with standard convension, please use SRC_GPSR_GPSR1_SR3.
*/


/** \brief 9C0, General Purpose Group 1 Service Request 4 */

/** Alias (User Manual Name) for SRC_GPSR_GPSR1_SR4.
* To use register names with standard convension, please use SRC_GPSR_GPSR1_SR4.
*/


/** \brief 9C4, General Purpose Group 1 Service Request 5 */

/** Alias (User Manual Name) for SRC_GPSR_GPSR1_SR5.
* To use register names with standard convension, please use SRC_GPSR_GPSR1_SR5.
*/


/** \brief 9C8, General Purpose Group 1 Service Request 6 */

/** Alias (User Manual Name) for SRC_GPSR_GPSR1_SR6.
* To use register names with standard convension, please use SRC_GPSR_GPSR1_SR6.
*/


/** \brief 9CC, General Purpose Group 1 Service Request 7 */

/** Alias (User Manual Name) for SRC_GPSR_GPSR1_SR7.
* To use register names with standard convension, please use SRC_GPSR_GPSR1_SR7.
*/


/** \brief 9D0, General Purpose Group 2 Service Request 0 */

/** Alias (User Manual Name) for SRC_GPSR_GPSR2_SR0.
* To use register names with standard convension, please use SRC_GPSR_GPSR2_SR0.
*/


/** \brief 9D4, General Purpose Group 2 Service Request 1 */

/** Alias (User Manual Name) for SRC_GPSR_GPSR2_SR1.
* To use register names with standard convension, please use SRC_GPSR_GPSR2_SR1.
*/


/** \brief 9D8, General Purpose Group 2 Service Request 2 */

/** Alias (User Manual Name) for SRC_GPSR_GPSR2_SR2.
* To use register names with standard convension, please use SRC_GPSR_GPSR2_SR2.
*/


/** \brief 9DC, General Purpose Group 2 Service Request 3 */

/** Alias (User Manual Name) for SRC_GPSR_GPSR2_SR3.
* To use register names with standard convension, please use SRC_GPSR_GPSR2_SR3.
*/


/** \brief 9E0, General Purpose Group 2 Service Request 4 */

/** Alias (User Manual Name) for SRC_GPSR_GPSR2_SR4.
* To use register names with standard convension, please use SRC_GPSR_GPSR2_SR4.
*/


/** \brief 9E4, General Purpose Group 2 Service Request 5 */

/** Alias (User Manual Name) for SRC_GPSR_GPSR2_SR5.
* To use register names with standard convension, please use SRC_GPSR_GPSR2_SR5.
*/


/** \brief 9E8, General Purpose Group 2 Service Request 6 */

/** Alias (User Manual Name) for SRC_GPSR_GPSR2_SR6.
* To use register names with standard convension, please use SRC_GPSR_GPSR2_SR6.
*/


/** \brief 9EC, General Purpose Group 2 Service Request 7 */

/** Alias (User Manual Name) for SRC_GPSR_GPSR2_SR7.
* To use register names with standard convension, please use SRC_GPSR_GPSR2_SR7.
*/


/** \brief 9F0, General Purpose Group 3 Service Request 0 */

/** Alias (User Manual Name) for SRC_GPSR_GPSR3_SR0.
* To use register names with standard convension, please use SRC_GPSR_GPSR3_SR0.
*/


/** \brief 9F4, General Purpose Group 3 Service Request 1 */

/** Alias (User Manual Name) for SRC_GPSR_GPSR3_SR1.
* To use register names with standard convension, please use SRC_GPSR_GPSR3_SR1.
*/


/** \brief 9F8, General Purpose Group 3 Service Request 2 */

/** Alias (User Manual Name) for SRC_GPSR_GPSR3_SR2.
* To use register names with standard convension, please use SRC_GPSR_GPSR3_SR2.
*/


/** \brief 9FC, General Purpose Group 3 Service Request 3 */

/** Alias (User Manual Name) for SRC_GPSR_GPSR3_SR3.
* To use register names with standard convension, please use SRC_GPSR_GPSR3_SR3.
*/


/** \brief A00, General Purpose Group 3 Service Request 4 */

/** Alias (User Manual Name) for SRC_GPSR_GPSR3_SR4.
* To use register names with standard convension, please use SRC_GPSR_GPSR3_SR4.
*/


/** \brief A04, General Purpose Group 3 Service Request 5 */

/** Alias (User Manual Name) for SRC_GPSR_GPSR3_SR5.
* To use register names with standard convension, please use SRC_GPSR_GPSR3_SR5.
*/


/** \brief A08, General Purpose Group 3 Service Request 6 */

/** Alias (User Manual Name) for SRC_GPSR_GPSR3_SR6.
* To use register names with standard convension, please use SRC_GPSR_GPSR3_SR6.
*/


/** \brief A0C, General Purpose Group 3 Service Request 7 */

/** Alias (User Manual Name) for SRC_GPSR_GPSR3_SR7.
* To use register names with standard convension, please use SRC_GPSR_GPSR3_SR7.
*/


/** \brief A50, ASCLIN14 Transmit Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN14_TX.
* To use register names with standard convension, please use SRC_ASCLIN14_TX.
*/


/** \brief A54, ASCLIN14 Receive Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN14_RX.
* To use register names with standard convension, please use SRC_ASCLIN14_RX.
*/


/** \brief A58, ASCLIN14 Error Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN14_ERR.
* To use register names with standard convension, please use SRC_ASCLIN14_ERR.
*/


/** \brief A5C, ASCLIN15 Transmit Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN15_TX.
* To use register names with standard convension, please use SRC_ASCLIN15_TX.
*/


/** \brief A60, ASCLIN15 Receive Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN15_RX.
* To use register names with standard convension, please use SRC_ASCLIN15_RX.
*/


/** \brief A64, ASCLIN15 Error Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN15_ERR.
* To use register names with standard convension, please use SRC_ASCLIN15_ERR.
*/


/** \brief A70, AEI Shared Service Request */

/** Alias (User Manual Name) for SRC_GTM_AEIIRQ.
* To use register names with standard convension, please use SRC_GTM_AEIIRQ.
*/


/** \brief A74, ARU Shared Service Request 0 */

/** Alias (User Manual Name) for SRC_GTM_ARUIRQ0.
* To use register names with standard convension, please use SRC_GTM_ARUIRQ0.
*/


/** \brief A78, ARU Shared Service Request 1 */

/** Alias (User Manual Name) for SRC_GTM_ARUIRQ1.
* To use register names with standard convension, please use SRC_GTM_ARUIRQ1.
*/


/** \brief A7C, ARU Shared Service Request 2 */

/** Alias (User Manual Name) for SRC_GTM_ARUIRQ2.
* To use register names with standard convension, please use SRC_GTM_ARUIRQ2.
*/


/** \brief A80, BRC Shared Service Request */

/** Alias (User Manual Name) for SRC_GTM_BRCIRQ.
* To use register names with standard convension, please use SRC_GTM_BRCIRQ.
*/


/** \brief A84, CMP Shared Service Request */

/** Alias (User Manual Name) for SRC_GTM_CMBIRQ.
* To use register names with standard convension, please use SRC_GTM_CMBIRQ.
*/


/** \brief A88, SPE0 Shared Service Request */

/** Alias (User Manual Name) for SRC_GTM_SPEIRQ0.
* To use register names with standard convension, please use SRC_GTM_SPEIRQ0.
*/


/** \brief A8C, SPE1 Shared Service Request */

/** Alias (User Manual Name) for SRC_GTM_SPEIRQ1.
* To use register names with standard convension, please use SRC_GTM_SPEIRQ1.
*/


/** \brief A90, SPE2 Shared Service Request */

/** Alias (User Manual Name) for SRC_GTM_SPEIRQ2.
* To use register names with standard convension, please use SRC_GTM_SPEIRQ2.
*/


/** \brief A94, SPE3 Shared Service Request */

/** Alias (User Manual Name) for SRC_GTM_SPEIRQ3.
* To use register names with standard convension, please use SRC_GTM_SPEIRQ3.
*/


/** \brief AA0, PSM0 Shared Service Request 0 */

/** Alias (User Manual Name) for SRC_GTM_PSM0_0.
* To use register names with standard convension, please use SRC_GTM_PSM0_0.
*/


/** \brief AA4, PSM0 Shared Service Request 1 */

/** Alias (User Manual Name) for SRC_GTM_PSM0_1.
* To use register names with standard convension, please use SRC_GTM_PSM0_1.
*/


/** \brief AA8, PSM0 Shared Service Request 2 */

/** Alias (User Manual Name) for SRC_GTM_PSM0_2.
* To use register names with standard convension, please use SRC_GTM_PSM0_2.
*/


/** \brief AAC, PSM0 Shared Service Request 3 */

/** Alias (User Manual Name) for SRC_GTM_PSM0_3.
* To use register names with standard convension, please use SRC_GTM_PSM0_3.
*/


/** \brief AB0, PSM0 Shared Service Request 4 */

/** Alias (User Manual Name) for SRC_GTM_PSM0_4.
* To use register names with standard convension, please use SRC_GTM_PSM0_4.
*/


/** \brief AB4, PSM0 Shared Service Request 5 */

/** Alias (User Manual Name) for SRC_GTM_PSM0_5.
* To use register names with standard convension, please use SRC_GTM_PSM0_5.
*/


/** \brief AB8, PSM0 Shared Service Request 6 */

/** Alias (User Manual Name) for SRC_GTM_PSM0_6.
* To use register names with standard convension, please use SRC_GTM_PSM0_6.
*/


/** \brief ABC, PSM0 Shared Service Request 7 */

/** Alias (User Manual Name) for SRC_GTM_PSM0_7.
* To use register names with standard convension, please use SRC_GTM_PSM0_7.
*/


/** \brief AC0, PSM1 Shared Service Request 0 */

/** Alias (User Manual Name) for SRC_GTM_PSM1_0.
* To use register names with standard convension, please use SRC_GTM_PSM1_0.
*/


/** \brief AC4, PSM1 Shared Service Request 1 */

/** Alias (User Manual Name) for SRC_GTM_PSM1_1.
* To use register names with standard convension, please use SRC_GTM_PSM1_1.
*/


/** \brief AC8, PSM1 Shared Service Request 2 */

/** Alias (User Manual Name) for SRC_GTM_PSM1_2.
* To use register names with standard convension, please use SRC_GTM_PSM1_2.
*/


/** \brief ACC, PSM1 Shared Service Request 3 */

/** Alias (User Manual Name) for SRC_GTM_PSM1_3.
* To use register names with standard convension, please use SRC_GTM_PSM1_3.
*/


/** \brief AD0, PSM1 Shared Service Request 4 */

/** Alias (User Manual Name) for SRC_GTM_PSM1_4.
* To use register names with standard convension, please use SRC_GTM_PSM1_4.
*/


/** \brief AD4, PSM1 Shared Service Request 5 */

/** Alias (User Manual Name) for SRC_GTM_PSM1_5.
* To use register names with standard convension, please use SRC_GTM_PSM1_5.
*/


/** \brief AD8, PSM1 Shared Service Request 6 */

/** Alias (User Manual Name) for SRC_GTM_PSM1_6.
* To use register names with standard convension, please use SRC_GTM_PSM1_6.
*/


/** \brief ADC, PSM1 Shared Service Request 7 */

/** Alias (User Manual Name) for SRC_GTM_PSM1_7.
* To use register names with standard convension, please use SRC_GTM_PSM1_7.
*/


/** \brief B00, DPLL Service Request 0 */

/** Alias (User Manual Name) for SRC_GTM_DPLL0.
* To use register names with standard convension, please use SRC_GTM_DPLL0.
*/


/** \brief B04, DPLL Service Request 1 */

/** Alias (User Manual Name) for SRC_GTM_DPLL1.
* To use register names with standard convension, please use SRC_GTM_DPLL1.
*/


/** \brief B08, DPLL Service Request 2 */

/** Alias (User Manual Name) for SRC_GTM_DPLL2.
* To use register names with standard convension, please use SRC_GTM_DPLL2.
*/


/** \brief B0C, DPLL Service Request 3 */

/** Alias (User Manual Name) for SRC_GTM_DPLL3.
* To use register names with standard convension, please use SRC_GTM_DPLL3.
*/


/** \brief B10, DPLL Service Request 4 */

/** Alias (User Manual Name) for SRC_GTM_DPLL4.
* To use register names with standard convension, please use SRC_GTM_DPLL4.
*/


/** \brief B14, DPLL Service Request 5 */

/** Alias (User Manual Name) for SRC_GTM_DPLL5.
* To use register names with standard convension, please use SRC_GTM_DPLL5.
*/


/** \brief B18, DPLL Service Request 6 */

/** Alias (User Manual Name) for SRC_GTM_DPLL6.
* To use register names with standard convension, please use SRC_GTM_DPLL6.
*/


/** \brief B1C, DPLL Service Request 7 */

/** Alias (User Manual Name) for SRC_GTM_DPLL7.
* To use register names with standard convension, please use SRC_GTM_DPLL7.
*/


/** \brief B20, DPLL Service Request 8 */

/** Alias (User Manual Name) for SRC_GTM_DPLL8.
* To use register names with standard convension, please use SRC_GTM_DPLL8.
*/


/** \brief B24, DPLL Service Request 9 */

/** Alias (User Manual Name) for SRC_GTM_DPLL9.
* To use register names with standard convension, please use SRC_GTM_DPLL9.
*/


/** \brief B28, DPLL Service Request 10 */

/** Alias (User Manual Name) for SRC_GTM_DPLL10.
* To use register names with standard convension, please use SRC_GTM_DPLL10.
*/


/** \brief B2C, DPLL Service Request 11 */

/** Alias (User Manual Name) for SRC_GTM_DPLL11.
* To use register names with standard convension, please use SRC_GTM_DPLL11.
*/


/** \brief B30, DPLL Service Request 12 */

/** Alias (User Manual Name) for SRC_GTM_DPLL12.
* To use register names with standard convension, please use SRC_GTM_DPLL12.
*/


/** \brief B34, DPLL Service Request 13 */

/** Alias (User Manual Name) for SRC_GTM_DPLL13.
* To use register names with standard convension, please use SRC_GTM_DPLL13.
*/


/** \brief B38, DPLL Service Request 14 */

/** Alias (User Manual Name) for SRC_GTM_DPLL14.
* To use register names with standard convension, please use SRC_GTM_DPLL14.
*/


/** \brief B3C, DPLL Service Request 15 */

/** Alias (User Manual Name) for SRC_GTM_DPLL15.
* To use register names with standard convension, please use SRC_GTM_DPLL15.
*/


/** \brief B40, DPLL Service Request 16 */

/** Alias (User Manual Name) for SRC_GTM_DPLL16.
* To use register names with standard convension, please use SRC_GTM_DPLL16.
*/


/** \brief B44, DPLL Service Request 17 */

/** Alias (User Manual Name) for SRC_GTM_DPLL17.
* To use register names with standard convension, please use SRC_GTM_DPLL17.
*/


/** \brief B48, DPLL Service Request 18 */

/** Alias (User Manual Name) for SRC_GTM_DPLL18.
* To use register names with standard convension, please use SRC_GTM_DPLL18.
*/


/** \brief B4C, DPLL Service Request 19 */

/** Alias (User Manual Name) for SRC_GTM_DPLL19.
* To use register names with standard convension, please use SRC_GTM_DPLL19.
*/


/** \brief B50, DPLL Service Request 20 */

/** Alias (User Manual Name) for SRC_GTM_DPLL20.
* To use register names with standard convension, please use SRC_GTM_DPLL20.
*/


/** \brief B54, DPLL Service Request 21 */

/** Alias (User Manual Name) for SRC_GTM_DPLL21.
* To use register names with standard convension, please use SRC_GTM_DPLL21.
*/


/** \brief B58, DPLL Service Request 22 */

/** Alias (User Manual Name) for SRC_GTM_DPLL22.
* To use register names with standard convension, please use SRC_GTM_DPLL22.
*/


/** \brief B5C, DPLL Service Request 23 */

/** Alias (User Manual Name) for SRC_GTM_DPLL23.
* To use register names with standard convension, please use SRC_GTM_DPLL23.
*/


/** \brief B60, DPLL Service Request 24 */

/** Alias (User Manual Name) for SRC_GTM_DPLL24.
* To use register names with standard convension, please use SRC_GTM_DPLL24.
*/


/** \brief B64, DPLL Service Request 25 */

/** Alias (User Manual Name) for SRC_GTM_DPLL25.
* To use register names with standard convension, please use SRC_GTM_DPLL25.
*/


/** \brief B68, DPLL Service Request 26 */

/** Alias (User Manual Name) for SRC_GTM_DPLL26.
* To use register names with standard convension, please use SRC_GTM_DPLL26.
*/


/** \brief B70, Error Service Request */

/** Alias (User Manual Name) for SRC_GTM_ERR.
* To use register names with standard convension, please use SRC_GTM_ERR.
*/


/** \brief B90, TIM0 Shared Service Request 0 */

/** Alias (User Manual Name) for SRC_GTM_TIM0_0.
* To use register names with standard convension, please use SRC_GTM_TIM0_0.
*/


/** \brief B94, TIM0 Shared Service Request 1 */

/** Alias (User Manual Name) for SRC_GTM_TIM0_1.
* To use register names with standard convension, please use SRC_GTM_TIM0_1.
*/


/** \brief B98, TIM0 Shared Service Request 2 */

/** Alias (User Manual Name) for SRC_GTM_TIM0_2.
* To use register names with standard convension, please use SRC_GTM_TIM0_2.
*/


/** \brief B9C, TIM0 Shared Service Request 3 */

/** Alias (User Manual Name) for SRC_GTM_TIM0_3.
* To use register names with standard convension, please use SRC_GTM_TIM0_3.
*/


/** \brief BA0, TIM0 Shared Service Request 4 */

/** Alias (User Manual Name) for SRC_GTM_TIM0_4.
* To use register names with standard convension, please use SRC_GTM_TIM0_4.
*/


/** \brief BA4, TIM0 Shared Service Request 5 */

/** Alias (User Manual Name) for SRC_GTM_TIM0_5.
* To use register names with standard convension, please use SRC_GTM_TIM0_5.
*/


/** \brief BA8, TIM0 Shared Service Request 6 */

/** Alias (User Manual Name) for SRC_GTM_TIM0_6.
* To use register names with standard convension, please use SRC_GTM_TIM0_6.
*/


/** \brief BAC, TIM0 Shared Service Request 7 */

/** Alias (User Manual Name) for SRC_GTM_TIM0_7.
* To use register names with standard convension, please use SRC_GTM_TIM0_7.
*/


/** \brief BB0, TIM1 Shared Service Request 0 */

/** Alias (User Manual Name) for SRC_GTM_TIM1_0.
* To use register names with standard convension, please use SRC_GTM_TIM1_0.
*/


/** \brief BB4, TIM1 Shared Service Request 1 */

/** Alias (User Manual Name) for SRC_GTM_TIM1_1.
* To use register names with standard convension, please use SRC_GTM_TIM1_1.
*/


/** \brief BB8, TIM1 Shared Service Request 2 */

/** Alias (User Manual Name) for SRC_GTM_TIM1_2.
* To use register names with standard convension, please use SRC_GTM_TIM1_2.
*/


/** \brief BBC, TIM1 Shared Service Request 3 */

/** Alias (User Manual Name) for SRC_GTM_TIM1_3.
* To use register names with standard convension, please use SRC_GTM_TIM1_3.
*/


/** \brief BC0, TIM1 Shared Service Request 4 */

/** Alias (User Manual Name) for SRC_GTM_TIM1_4.
* To use register names with standard convension, please use SRC_GTM_TIM1_4.
*/


/** \brief BC4, TIM1 Shared Service Request 5 */

/** Alias (User Manual Name) for SRC_GTM_TIM1_5.
* To use register names with standard convension, please use SRC_GTM_TIM1_5.
*/


/** \brief BC8, TIM1 Shared Service Request 6 */

/** Alias (User Manual Name) for SRC_GTM_TIM1_6.
* To use register names with standard convension, please use SRC_GTM_TIM1_6.
*/


/** \brief BCC, TIM1 Shared Service Request 7 */

/** Alias (User Manual Name) for SRC_GTM_TIM1_7.
* To use register names with standard convension, please use SRC_GTM_TIM1_7.
*/


/** \brief BD0, TIM2 Shared Service Request 0 */

/** Alias (User Manual Name) for SRC_GTM_TIM2_0.
* To use register names with standard convension, please use SRC_GTM_TIM2_0.
*/


/** \brief BD4, TIM2 Shared Service Request 1 */

/** Alias (User Manual Name) for SRC_GTM_TIM2_1.
* To use register names with standard convension, please use SRC_GTM_TIM2_1.
*/


/** \brief BD8, TIM2 Shared Service Request 2 */

/** Alias (User Manual Name) for SRC_GTM_TIM2_2.
* To use register names with standard convension, please use SRC_GTM_TIM2_2.
*/


/** \brief BDC, TIM2 Shared Service Request 3 */

/** Alias (User Manual Name) for SRC_GTM_TIM2_3.
* To use register names with standard convension, please use SRC_GTM_TIM2_3.
*/


/** \brief BE0, TIM2 Shared Service Request 4 */

/** Alias (User Manual Name) for SRC_GTM_TIM2_4.
* To use register names with standard convension, please use SRC_GTM_TIM2_4.
*/


/** \brief BE4, TIM2 Shared Service Request 5 */

/** Alias (User Manual Name) for SRC_GTM_TIM2_5.
* To use register names with standard convension, please use SRC_GTM_TIM2_5.
*/


/** \brief BE8, TIM2 Shared Service Request 6 */

/** Alias (User Manual Name) for SRC_GTM_TIM2_6.
* To use register names with standard convension, please use SRC_GTM_TIM2_6.
*/


/** \brief BEC, TIM2 Shared Service Request 7 */

/** Alias (User Manual Name) for SRC_GTM_TIM2_7.
* To use register names with standard convension, please use SRC_GTM_TIM2_7.
*/


/** \brief BF0, TIM3 Shared Service Request 0 */

/** Alias (User Manual Name) for SRC_GTM_TIM3_0.
* To use register names with standard convension, please use SRC_GTM_TIM3_0.
*/


/** \brief BF4, TIM3 Shared Service Request 1 */

/** Alias (User Manual Name) for SRC_GTM_TIM3_1.
* To use register names with standard convension, please use SRC_GTM_TIM3_1.
*/


/** \brief BF8, TIM3 Shared Service Request 2 */

/** Alias (User Manual Name) for SRC_GTM_TIM3_2.
* To use register names with standard convension, please use SRC_GTM_TIM3_2.
*/


/** \brief BFC, TIM3 Shared Service Request 3 */

/** Alias (User Manual Name) for SRC_GTM_TIM3_3.
* To use register names with standard convension, please use SRC_GTM_TIM3_3.
*/


/** \brief C00, TIM3 Shared Service Request 4 */

/** Alias (User Manual Name) for SRC_GTM_TIM3_4.
* To use register names with standard convension, please use SRC_GTM_TIM3_4.
*/


/** \brief C04, TIM3 Shared Service Request 5 */

/** Alias (User Manual Name) for SRC_GTM_TIM3_5.
* To use register names with standard convension, please use SRC_GTM_TIM3_5.
*/


/** \brief C08, TIM3 Shared Service Request 6 */

/** Alias (User Manual Name) for SRC_GTM_TIM3_6.
* To use register names with standard convension, please use SRC_GTM_TIM3_6.
*/


/** \brief C0C, TIM3 Shared Service Request 7 */

/** Alias (User Manual Name) for SRC_GTM_TIM3_7.
* To use register names with standard convension, please use SRC_GTM_TIM3_7.
*/


/** \brief C10, TIM4 Shared Service Request 0 */

/** Alias (User Manual Name) for SRC_GTM_TIM4_0.
* To use register names with standard convension, please use SRC_GTM_TIM4_0.
*/


/** \brief C14, TIM4 Shared Service Request 1 */

/** Alias (User Manual Name) for SRC_GTM_TIM4_1.
* To use register names with standard convension, please use SRC_GTM_TIM4_1.
*/


/** \brief C18, TIM4 Shared Service Request 2 */

/** Alias (User Manual Name) for SRC_GTM_TIM4_2.
* To use register names with standard convension, please use SRC_GTM_TIM4_2.
*/


/** \brief C1C, TIM4 Shared Service Request 3 */

/** Alias (User Manual Name) for SRC_GTM_TIM4_3.
* To use register names with standard convension, please use SRC_GTM_TIM4_3.
*/


/** \brief C20, TIM4 Shared Service Request 4 */

/** Alias (User Manual Name) for SRC_GTM_TIM4_4.
* To use register names with standard convension, please use SRC_GTM_TIM4_4.
*/


/** \brief C24, TIM4 Shared Service Request 5 */

/** Alias (User Manual Name) for SRC_GTM_TIM4_5.
* To use register names with standard convension, please use SRC_GTM_TIM4_5.
*/


/** \brief C28, TIM4 Shared Service Request 6 */

/** Alias (User Manual Name) for SRC_GTM_TIM4_6.
* To use register names with standard convension, please use SRC_GTM_TIM4_6.
*/


/** \brief C2C, TIM4 Shared Service Request 7 */

/** Alias (User Manual Name) for SRC_GTM_TIM4_7.
* To use register names with standard convension, please use SRC_GTM_TIM4_7.
*/


/** \brief C30, TIM5 Shared Service Request 0 */

/** Alias (User Manual Name) for SRC_GTM_TIM5_0.
* To use register names with standard convension, please use SRC_GTM_TIM5_0.
*/


/** \brief C34, TIM5 Shared Service Request 1 */

/** Alias (User Manual Name) for SRC_GTM_TIM5_1.
* To use register names with standard convension, please use SRC_GTM_TIM5_1.
*/


/** \brief C38, TIM5 Shared Service Request 2 */

/** Alias (User Manual Name) for SRC_GTM_TIM5_2.
* To use register names with standard convension, please use SRC_GTM_TIM5_2.
*/


/** \brief C3C, TIM5 Shared Service Request 3 */

/** Alias (User Manual Name) for SRC_GTM_TIM5_3.
* To use register names with standard convension, please use SRC_GTM_TIM5_3.
*/


/** \brief C40, TIM5 Shared Service Request 4 */

/** Alias (User Manual Name) for SRC_GTM_TIM5_4.
* To use register names with standard convension, please use SRC_GTM_TIM5_4.
*/


/** \brief C44, TIM5 Shared Service Request 5 */

/** Alias (User Manual Name) for SRC_GTM_TIM5_5.
* To use register names with standard convension, please use SRC_GTM_TIM5_5.
*/


/** \brief C48, TIM5 Shared Service Request 6 */

/** Alias (User Manual Name) for SRC_GTM_TIM5_6.
* To use register names with standard convension, please use SRC_GTM_TIM5_6.
*/


/** \brief C4C, TIM5 Shared Service Request 7 */

/** Alias (User Manual Name) for SRC_GTM_TIM5_7.
* To use register names with standard convension, please use SRC_GTM_TIM5_7.
*/


/** \brief C50, TIM6 Shared Service Request 0 */

/** Alias (User Manual Name) for SRC_GTM_TIM6_0.
* To use register names with standard convension, please use SRC_GTM_TIM6_0.
*/


/** \brief C54, TIM6 Shared Service Request 1 */

/** Alias (User Manual Name) for SRC_GTM_TIM6_1.
* To use register names with standard convension, please use SRC_GTM_TIM6_1.
*/


/** \brief C58, TIM6 Shared Service Request 2 */

/** Alias (User Manual Name) for SRC_GTM_TIM6_2.
* To use register names with standard convension, please use SRC_GTM_TIM6_2.
*/


/** \brief C5C, TIM6 Shared Service Request 3 */

/** Alias (User Manual Name) for SRC_GTM_TIM6_3.
* To use register names with standard convension, please use SRC_GTM_TIM6_3.
*/


/** \brief C60, TIM6 Shared Service Request 4 */

/** Alias (User Manual Name) for SRC_GTM_TIM6_4.
* To use register names with standard convension, please use SRC_GTM_TIM6_4.
*/


/** \brief C64, TIM6 Shared Service Request 5 */

/** Alias (User Manual Name) for SRC_GTM_TIM6_5.
* To use register names with standard convension, please use SRC_GTM_TIM6_5.
*/


/** \brief C68, TIM6 Shared Service Request 6 */

/** Alias (User Manual Name) for SRC_GTM_TIM6_6.
* To use register names with standard convension, please use SRC_GTM_TIM6_6.
*/


/** \brief C6C, TIM6 Shared Service Request 7 */

/** Alias (User Manual Name) for SRC_GTM_TIM6_7.
* To use register names with standard convension, please use SRC_GTM_TIM6_7.
*/


/** \brief C90, ASCLIN16 Transmit Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN16_TX.
* To use register names with standard convension, please use SRC_ASCLIN16_TX.
*/


/** \brief C94, ASCLIN16 Receive Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN16_RX.
* To use register names with standard convension, please use SRC_ASCLIN16_RX.
*/


/** \brief C98, ASCLIN16 Error Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN16_ERR.
* To use register names with standard convension, please use SRC_ASCLIN16_ERR.
*/


/** \brief C9C, ASCLIN17 Transmit Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN17_TX.
* To use register names with standard convension, please use SRC_ASCLIN17_TX.
*/


/** \brief CA0, ASCLIN17 Receive Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN17_RX.
* To use register names with standard convension, please use SRC_ASCLIN17_RX.
*/


/** \brief CA4, ASCLIN17 Error Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN17_ERR.
* To use register names with standard convension, please use SRC_ASCLIN17_ERR.
*/


/** \brief CB0, MCS0 Shared Service Request 0 */

/** Alias (User Manual Name) for SRC_GTM_MCS0_0.
* To use register names with standard convension, please use SRC_GTM_MCS0_0.
*/


/** \brief CB4, MCS0 Shared Service Request 1 */

/** Alias (User Manual Name) for SRC_GTM_MCS0_1.
* To use register names with standard convension, please use SRC_GTM_MCS0_1.
*/


/** \brief CB8, MCS0 Shared Service Request 2 */

/** Alias (User Manual Name) for SRC_GTM_MCS0_2.
* To use register names with standard convension, please use SRC_GTM_MCS0_2.
*/


/** \brief CBC, MCS0 Shared Service Request 3 */

/** Alias (User Manual Name) for SRC_GTM_MCS0_3.
* To use register names with standard convension, please use SRC_GTM_MCS0_3.
*/


/** \brief CC0, MCS0 Shared Service Request 4 */

/** Alias (User Manual Name) for SRC_GTM_MCS0_4.
* To use register names with standard convension, please use SRC_GTM_MCS0_4.
*/


/** \brief CC4, MCS0 Shared Service Request 5 */

/** Alias (User Manual Name) for SRC_GTM_MCS0_5.
* To use register names with standard convension, please use SRC_GTM_MCS0_5.
*/


/** \brief CC8, MCS0 Shared Service Request 6 */

/** Alias (User Manual Name) for SRC_GTM_MCS0_6.
* To use register names with standard convension, please use SRC_GTM_MCS0_6.
*/


/** \brief CCC, MCS0 Shared Service Request 7 */

/** Alias (User Manual Name) for SRC_GTM_MCS0_7.
* To use register names with standard convension, please use SRC_GTM_MCS0_7.
*/


/** \brief CD0, MCS1 Shared Service Request 0 */

/** Alias (User Manual Name) for SRC_GTM_MCS1_0.
* To use register names with standard convension, please use SRC_GTM_MCS1_0.
*/


/** \brief CD4, MCS1 Shared Service Request 1 */

/** Alias (User Manual Name) for SRC_GTM_MCS1_1.
* To use register names with standard convension, please use SRC_GTM_MCS1_1.
*/


/** \brief CD8, MCS1 Shared Service Request 2 */

/** Alias (User Manual Name) for SRC_GTM_MCS1_2.
* To use register names with standard convension, please use SRC_GTM_MCS1_2.
*/


/** \brief CDC, MCS1 Shared Service Request 3 */

/** Alias (User Manual Name) for SRC_GTM_MCS1_3.
* To use register names with standard convension, please use SRC_GTM_MCS1_3.
*/


/** \brief CE0, MCS1 Shared Service Request 4 */

/** Alias (User Manual Name) for SRC_GTM_MCS1_4.
* To use register names with standard convension, please use SRC_GTM_MCS1_4.
*/


/** \brief CE4, MCS1 Shared Service Request 5 */

/** Alias (User Manual Name) for SRC_GTM_MCS1_5.
* To use register names with standard convension, please use SRC_GTM_MCS1_5.
*/


/** \brief CE8, MCS1 Shared Service Request 6 */

/** Alias (User Manual Name) for SRC_GTM_MCS1_6.
* To use register names with standard convension, please use SRC_GTM_MCS1_6.
*/


/** \brief CEC, MCS1 Shared Service Request 7 */

/** Alias (User Manual Name) for SRC_GTM_MCS1_7.
* To use register names with standard convension, please use SRC_GTM_MCS1_7.
*/


/** \brief CF0, MCS2 Shared Service Request 0 */

/** Alias (User Manual Name) for SRC_GTM_MCS2_0.
* To use register names with standard convension, please use SRC_GTM_MCS2_0.
*/


/** \brief CF4, MCS2 Shared Service Request 1 */

/** Alias (User Manual Name) for SRC_GTM_MCS2_1.
* To use register names with standard convension, please use SRC_GTM_MCS2_1.
*/


/** \brief CF8, MCS2 Shared Service Request 2 */

/** Alias (User Manual Name) for SRC_GTM_MCS2_2.
* To use register names with standard convension, please use SRC_GTM_MCS2_2.
*/


/** \brief CFC, MCS2 Shared Service Request 3 */

/** Alias (User Manual Name) for SRC_GTM_MCS2_3.
* To use register names with standard convension, please use SRC_GTM_MCS2_3.
*/


/** \brief D00, MCS2 Shared Service Request 4 */

/** Alias (User Manual Name) for SRC_GTM_MCS2_4.
* To use register names with standard convension, please use SRC_GTM_MCS2_4.
*/


/** \brief D04, MCS2 Shared Service Request 5 */

/** Alias (User Manual Name) for SRC_GTM_MCS2_5.
* To use register names with standard convension, please use SRC_GTM_MCS2_5.
*/


/** \brief D08, MCS2 Shared Service Request 6 */

/** Alias (User Manual Name) for SRC_GTM_MCS2_6.
* To use register names with standard convension, please use SRC_GTM_MCS2_6.
*/


/** \brief D0C, MCS2 Shared Service Request 7 */

/** Alias (User Manual Name) for SRC_GTM_MCS2_7.
* To use register names with standard convension, please use SRC_GTM_MCS2_7.
*/


/** \brief D10, MCS3 Shared Service Request 0 */

/** Alias (User Manual Name) for SRC_GTM_MCS3_0.
* To use register names with standard convension, please use SRC_GTM_MCS3_0.
*/


/** \brief D14, MCS3 Shared Service Request 1 */

/** Alias (User Manual Name) for SRC_GTM_MCS3_1.
* To use register names with standard convension, please use SRC_GTM_MCS3_1.
*/


/** \brief D18, MCS3 Shared Service Request 2 */

/** Alias (User Manual Name) for SRC_GTM_MCS3_2.
* To use register names with standard convension, please use SRC_GTM_MCS3_2.
*/


/** \brief D1C, MCS3 Shared Service Request 3 */

/** Alias (User Manual Name) for SRC_GTM_MCS3_3.
* To use register names with standard convension, please use SRC_GTM_MCS3_3.
*/


/** \brief D20, MCS3 Shared Service Request 4 */

/** Alias (User Manual Name) for SRC_GTM_MCS3_4.
* To use register names with standard convension, please use SRC_GTM_MCS3_4.
*/


/** \brief D24, MCS3 Shared Service Request 5 */

/** Alias (User Manual Name) for SRC_GTM_MCS3_5.
* To use register names with standard convension, please use SRC_GTM_MCS3_5.
*/


/** \brief D28, MCS3 Shared Service Request 6 */

/** Alias (User Manual Name) for SRC_GTM_MCS3_6.
* To use register names with standard convension, please use SRC_GTM_MCS3_6.
*/


/** \brief D2C, MCS3 Shared Service Request 7 */

/** Alias (User Manual Name) for SRC_GTM_MCS3_7.
* To use register names with standard convension, please use SRC_GTM_MCS3_7.
*/


/** \brief D30, MCS4 Shared Service Request 0 */

/** Alias (User Manual Name) for SRC_GTM_MCS4_0.
* To use register names with standard convension, please use SRC_GTM_MCS4_0.
*/


/** \brief D34, MCS4 Shared Service Request 1 */

/** Alias (User Manual Name) for SRC_GTM_MCS4_1.
* To use register names with standard convension, please use SRC_GTM_MCS4_1.
*/


/** \brief D38, MCS4 Shared Service Request 2 */

/** Alias (User Manual Name) for SRC_GTM_MCS4_2.
* To use register names with standard convension, please use SRC_GTM_MCS4_2.
*/


/** \brief D3C, MCS4 Shared Service Request 3 */

/** Alias (User Manual Name) for SRC_GTM_MCS4_3.
* To use register names with standard convension, please use SRC_GTM_MCS4_3.
*/


/** \brief D40, MCS4 Shared Service Request 4 */

/** Alias (User Manual Name) for SRC_GTM_MCS4_4.
* To use register names with standard convension, please use SRC_GTM_MCS4_4.
*/


/** \brief D44, MCS4 Shared Service Request 5 */

/** Alias (User Manual Name) for SRC_GTM_MCS4_5.
* To use register names with standard convension, please use SRC_GTM_MCS4_5.
*/


/** \brief D48, MCS4 Shared Service Request 6 */

/** Alias (User Manual Name) for SRC_GTM_MCS4_6.
* To use register names with standard convension, please use SRC_GTM_MCS4_6.
*/


/** \brief D4C, MCS4 Shared Service Request 7 */

/** Alias (User Manual Name) for SRC_GTM_MCS4_7.
* To use register names with standard convension, please use SRC_GTM_MCS4_7.
*/


/** \brief D50, MCS5 Shared Service Request 0 */

/** Alias (User Manual Name) for SRC_GTM_MCS5_0.
* To use register names with standard convension, please use SRC_GTM_MCS5_0.
*/


/** \brief D54, MCS5 Shared Service Request 1 */

/** Alias (User Manual Name) for SRC_GTM_MCS5_1.
* To use register names with standard convension, please use SRC_GTM_MCS5_1.
*/


/** \brief D58, MCS5 Shared Service Request 2 */

/** Alias (User Manual Name) for SRC_GTM_MCS5_2.
* To use register names with standard convension, please use SRC_GTM_MCS5_2.
*/


/** \brief D5C, MCS5 Shared Service Request 3 */

/** Alias (User Manual Name) for SRC_GTM_MCS5_3.
* To use register names with standard convension, please use SRC_GTM_MCS5_3.
*/


/** \brief D60, MCS5 Shared Service Request 4 */

/** Alias (User Manual Name) for SRC_GTM_MCS5_4.
* To use register names with standard convension, please use SRC_GTM_MCS5_4.
*/


/** \brief D64, MCS5 Shared Service Request 5 */

/** Alias (User Manual Name) for SRC_GTM_MCS5_5.
* To use register names with standard convension, please use SRC_GTM_MCS5_5.
*/


/** \brief D68, MCS5 Shared Service Request 6 */

/** Alias (User Manual Name) for SRC_GTM_MCS5_6.
* To use register names with standard convension, please use SRC_GTM_MCS5_6.
*/


/** \brief D6C, MCS5 Shared Service Request 7 */

/** Alias (User Manual Name) for SRC_GTM_MCS5_7.
* To use register names with standard convension, please use SRC_GTM_MCS5_7.
*/


/** \brief D70, MCS6 Shared Service Request 0 */

/** Alias (User Manual Name) for SRC_GTM_MCS6_0.
* To use register names with standard convension, please use SRC_GTM_MCS6_0.
*/


/** \brief D74, MCS6 Shared Service Request 1 */

/** Alias (User Manual Name) for SRC_GTM_MCS6_1.
* To use register names with standard convension, please use SRC_GTM_MCS6_1.
*/


/** \brief D78, MCS6 Shared Service Request 2 */

/** Alias (User Manual Name) for SRC_GTM_MCS6_2.
* To use register names with standard convension, please use SRC_GTM_MCS6_2.
*/


/** \brief D7C, MCS6 Shared Service Request 3 */

/** Alias (User Manual Name) for SRC_GTM_MCS6_3.
* To use register names with standard convension, please use SRC_GTM_MCS6_3.
*/


/** \brief D80, MCS6 Shared Service Request 4 */

/** Alias (User Manual Name) for SRC_GTM_MCS6_4.
* To use register names with standard convension, please use SRC_GTM_MCS6_4.
*/


/** \brief D84, MCS6 Shared Service Request 5 */

/** Alias (User Manual Name) for SRC_GTM_MCS6_5.
* To use register names with standard convension, please use SRC_GTM_MCS6_5.
*/


/** \brief D88, MCS6 Shared Service Request 6 */

/** Alias (User Manual Name) for SRC_GTM_MCS6_6.
* To use register names with standard convension, please use SRC_GTM_MCS6_6.
*/


/** \brief D8C, MCS6 Shared Service Request 7 */

/** Alias (User Manual Name) for SRC_GTM_MCS6_7.
* To use register names with standard convension, please use SRC_GTM_MCS6_7.
*/


/** \brief DF0, ASCLIN18 Transmit Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN18_TX.
* To use register names with standard convension, please use SRC_ASCLIN18_TX.
*/


/** \brief DF4, ASCLIN18 Receive Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN18_RX.
* To use register names with standard convension, please use SRC_ASCLIN18_RX.
*/


/** \brief DF8, ASCLIN18 Error Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN18_ERR.
* To use register names with standard convension, please use SRC_ASCLIN18_ERR.
*/


/** \brief DFC, ASCLIN19 Transmit Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN19_TX.
* To use register names with standard convension, please use SRC_ASCLIN19_TX.
*/


/** \brief E00, ASCLIN19 Receive Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN19_RX.
* To use register names with standard convension, please use SRC_ASCLIN19_RX.
*/


/** \brief E04, ASCLIN19 Error Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN19_ERR.
* To use register names with standard convension, please use SRC_ASCLIN19_ERR.
*/


/** \brief E10, TOM0 Shared Service Request 0 */

/** Alias (User Manual Name) for SRC_GTM_TOM0_0.
* To use register names with standard convension, please use SRC_GTM_TOM0_0.
*/


/** \brief E14, TOM0 Shared Service Request 1 */

/** Alias (User Manual Name) for SRC_GTM_TOM0_1.
* To use register names with standard convension, please use SRC_GTM_TOM0_1.
*/


/** \brief E18, TOM0 Shared Service Request 2 */

/** Alias (User Manual Name) for SRC_GTM_TOM0_2.
* To use register names with standard convension, please use SRC_GTM_TOM0_2.
*/


/** \brief E1C, TOM0 Shared Service Request 3 */

/** Alias (User Manual Name) for SRC_GTM_TOM0_3.
* To use register names with standard convension, please use SRC_GTM_TOM0_3.
*/


/** \brief E20, TOM0 Shared Service Request 4 */

/** Alias (User Manual Name) for SRC_GTM_TOM0_4.
* To use register names with standard convension, please use SRC_GTM_TOM0_4.
*/


/** \brief E24, TOM0 Shared Service Request 5 */

/** Alias (User Manual Name) for SRC_GTM_TOM0_5.
* To use register names with standard convension, please use SRC_GTM_TOM0_5.
*/


/** \brief E28, TOM0 Shared Service Request 6 */

/** Alias (User Manual Name) for SRC_GTM_TOM0_6.
* To use register names with standard convension, please use SRC_GTM_TOM0_6.
*/


/** \brief E2C, TOM0 Shared Service Request 7 */

/** Alias (User Manual Name) for SRC_GTM_TOM0_7.
* To use register names with standard convension, please use SRC_GTM_TOM0_7.
*/


/** \brief E30, TOM1 Shared Service Request 0 */

/** Alias (User Manual Name) for SRC_GTM_TOM1_0.
* To use register names with standard convension, please use SRC_GTM_TOM1_0.
*/


/** \brief E34, TOM1 Shared Service Request 1 */

/** Alias (User Manual Name) for SRC_GTM_TOM1_1.
* To use register names with standard convension, please use SRC_GTM_TOM1_1.
*/


/** \brief E38, TOM1 Shared Service Request 2 */

/** Alias (User Manual Name) for SRC_GTM_TOM1_2.
* To use register names with standard convension, please use SRC_GTM_TOM1_2.
*/


/** \brief E3C, TOM1 Shared Service Request 3 */

/** Alias (User Manual Name) for SRC_GTM_TOM1_3.
* To use register names with standard convension, please use SRC_GTM_TOM1_3.
*/


/** \brief E40, TOM1 Shared Service Request 4 */

/** Alias (User Manual Name) for SRC_GTM_TOM1_4.
* To use register names with standard convension, please use SRC_GTM_TOM1_4.
*/


/** \brief E44, TOM1 Shared Service Request 5 */

/** Alias (User Manual Name) for SRC_GTM_TOM1_5.
* To use register names with standard convension, please use SRC_GTM_TOM1_5.
*/


/** \brief E48, TOM1 Shared Service Request 6 */

/** Alias (User Manual Name) for SRC_GTM_TOM1_6.
* To use register names with standard convension, please use SRC_GTM_TOM1_6.
*/


/** \brief E4C, TOM1 Shared Service Request 7 */

/** Alias (User Manual Name) for SRC_GTM_TOM1_7.
* To use register names with standard convension, please use SRC_GTM_TOM1_7.
*/


/** \brief E50, TOM2 Shared Service Request 0 */

/** Alias (User Manual Name) for SRC_GTM_TOM2_0.
* To use register names with standard convension, please use SRC_GTM_TOM2_0.
*/


/** \brief E54, TOM2 Shared Service Request 1 */

/** Alias (User Manual Name) for SRC_GTM_TOM2_1.
* To use register names with standard convension, please use SRC_GTM_TOM2_1.
*/


/** \brief E58, TOM2 Shared Service Request 2 */

/** Alias (User Manual Name) for SRC_GTM_TOM2_2.
* To use register names with standard convension, please use SRC_GTM_TOM2_2.
*/


/** \brief E5C, TOM2 Shared Service Request 3 */

/** Alias (User Manual Name) for SRC_GTM_TOM2_3.
* To use register names with standard convension, please use SRC_GTM_TOM2_3.
*/


/** \brief E60, TOM2 Shared Service Request 4 */

/** Alias (User Manual Name) for SRC_GTM_TOM2_4.
* To use register names with standard convension, please use SRC_GTM_TOM2_4.
*/


/** \brief E64, TOM2 Shared Service Request 5 */

/** Alias (User Manual Name) for SRC_GTM_TOM2_5.
* To use register names with standard convension, please use SRC_GTM_TOM2_5.
*/


/** \brief E68, TOM2 Shared Service Request 6 */

/** Alias (User Manual Name) for SRC_GTM_TOM2_6.
* To use register names with standard convension, please use SRC_GTM_TOM2_6.
*/


/** \brief E6C, TOM2 Shared Service Request 7 */

/** Alias (User Manual Name) for SRC_GTM_TOM2_7.
* To use register names with standard convension, please use SRC_GTM_TOM2_7.
*/


/** \brief E70, TOM3 Shared Service Request 0 */

/** Alias (User Manual Name) for SRC_GTM_TOM3_0.
* To use register names with standard convension, please use SRC_GTM_TOM3_0.
*/


/** \brief E74, TOM3 Shared Service Request 1 */

/** Alias (User Manual Name) for SRC_GTM_TOM3_1.
* To use register names with standard convension, please use SRC_GTM_TOM3_1.
*/


/** \brief E78, TOM3 Shared Service Request 2 */

/** Alias (User Manual Name) for SRC_GTM_TOM3_2.
* To use register names with standard convension, please use SRC_GTM_TOM3_2.
*/


/** \brief E7C, TOM3 Shared Service Request 3 */

/** Alias (User Manual Name) for SRC_GTM_TOM3_3.
* To use register names with standard convension, please use SRC_GTM_TOM3_3.
*/


/** \brief E80, TOM3 Shared Service Request 4 */

/** Alias (User Manual Name) for SRC_GTM_TOM3_4.
* To use register names with standard convension, please use SRC_GTM_TOM3_4.
*/


/** \brief E84, TOM3 Shared Service Request 5 */

/** Alias (User Manual Name) for SRC_GTM_TOM3_5.
* To use register names with standard convension, please use SRC_GTM_TOM3_5.
*/


/** \brief E88, TOM3 Shared Service Request 6 */

/** Alias (User Manual Name) for SRC_GTM_TOM3_6.
* To use register names with standard convension, please use SRC_GTM_TOM3_6.
*/


/** \brief E8C, TOM3 Shared Service Request 7 */

/** Alias (User Manual Name) for SRC_GTM_TOM3_7.
* To use register names with standard convension, please use SRC_GTM_TOM3_7.
*/


/** \brief E90, TOM4 Shared Service Request 0 */

/** Alias (User Manual Name) for SRC_GTM_TOM4_0.
* To use register names with standard convension, please use SRC_GTM_TOM4_0.
*/


/** \brief E94, TOM4 Shared Service Request 1 */

/** Alias (User Manual Name) for SRC_GTM_TOM4_1.
* To use register names with standard convension, please use SRC_GTM_TOM4_1.
*/


/** \brief E98, TOM4 Shared Service Request 2 */

/** Alias (User Manual Name) for SRC_GTM_TOM4_2.
* To use register names with standard convension, please use SRC_GTM_TOM4_2.
*/


/** \brief E9C, TOM4 Shared Service Request 3 */

/** Alias (User Manual Name) for SRC_GTM_TOM4_3.
* To use register names with standard convension, please use SRC_GTM_TOM4_3.
*/


/** \brief EA0, TOM4 Shared Service Request 4 */

/** Alias (User Manual Name) for SRC_GTM_TOM4_4.
* To use register names with standard convension, please use SRC_GTM_TOM4_4.
*/


/** \brief EA4, TOM4 Shared Service Request 5 */

/** Alias (User Manual Name) for SRC_GTM_TOM4_5.
* To use register names with standard convension, please use SRC_GTM_TOM4_5.
*/


/** \brief EA8, TOM4 Shared Service Request 6 */

/** Alias (User Manual Name) for SRC_GTM_TOM4_6.
* To use register names with standard convension, please use SRC_GTM_TOM4_6.
*/


/** \brief EAC, TOM4 Shared Service Request 7 */

/** Alias (User Manual Name) for SRC_GTM_TOM4_7.
* To use register names with standard convension, please use SRC_GTM_TOM4_7.
*/


/** \brief ED0, ASCLIN20 Transmit Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN20_TX.
* To use register names with standard convension, please use SRC_ASCLIN20_TX.
*/


/** \brief ED4, ASCLIN20 Receive Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN20_RX.
* To use register names with standard convension, please use SRC_ASCLIN20_RX.
*/


/** \brief ED8, ASCLIN20 Error Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN20_ERR.
* To use register names with standard convension, please use SRC_ASCLIN20_ERR.
*/


/** \brief EDC, ASCLIN21 Transmit Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN21_TX.
* To use register names with standard convension, please use SRC_ASCLIN21_TX.
*/


/** \brief EE0, ASCLIN21 Receive Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN21_RX.
* To use register names with standard convension, please use SRC_ASCLIN21_RX.
*/


/** \brief EE4, ASCLIN21 Error Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN21_ERR.
* To use register names with standard convension, please use SRC_ASCLIN21_ERR.
*/


/** \brief EF0, ATOM0 Shared Service Request 0 */

/** Alias (User Manual Name) for SRC_GTM_ATOM0_0.
* To use register names with standard convension, please use SRC_GTM_ATOM0_0.
*/


/** \brief EF4, ATOM0 Shared Service Request 1 */

/** Alias (User Manual Name) for SRC_GTM_ATOM0_1.
* To use register names with standard convension, please use SRC_GTM_ATOM0_1.
*/


/** \brief EF8, ATOM0 Shared Service Request 2 */

/** Alias (User Manual Name) for SRC_GTM_ATOM0_2.
* To use register names with standard convension, please use SRC_GTM_ATOM0_2.
*/


/** \brief EFC, ATOM0 Shared Service Request 3 */

/** Alias (User Manual Name) for SRC_GTM_ATOM0_3.
* To use register names with standard convension, please use SRC_GTM_ATOM0_3.
*/


/** \brief F00, ATOM1 Shared Service Request 0 */

/** Alias (User Manual Name) for SRC_GTM_ATOM1_0.
* To use register names with standard convension, please use SRC_GTM_ATOM1_0.
*/


/** \brief F04, ATOM1 Shared Service Request 1 */

/** Alias (User Manual Name) for SRC_GTM_ATOM1_1.
* To use register names with standard convension, please use SRC_GTM_ATOM1_1.
*/


/** \brief F08, ATOM1 Shared Service Request 2 */

/** Alias (User Manual Name) for SRC_GTM_ATOM1_2.
* To use register names with standard convension, please use SRC_GTM_ATOM1_2.
*/


/** \brief F0C, ATOM1 Shared Service Request 3 */

/** Alias (User Manual Name) for SRC_GTM_ATOM1_3.
* To use register names with standard convension, please use SRC_GTM_ATOM1_3.
*/


/** \brief F10, ATOM2 Shared Service Request 0 */

/** Alias (User Manual Name) for SRC_GTM_ATOM2_0.
* To use register names with standard convension, please use SRC_GTM_ATOM2_0.
*/


/** \brief F14, ATOM2 Shared Service Request 1 */

/** Alias (User Manual Name) for SRC_GTM_ATOM2_1.
* To use register names with standard convension, please use SRC_GTM_ATOM2_1.
*/


/** \brief F18, ATOM2 Shared Service Request 2 */

/** Alias (User Manual Name) for SRC_GTM_ATOM2_2.
* To use register names with standard convension, please use SRC_GTM_ATOM2_2.
*/


/** \brief F1C, ATOM2 Shared Service Request 3 */

/** Alias (User Manual Name) for SRC_GTM_ATOM2_3.
* To use register names with standard convension, please use SRC_GTM_ATOM2_3.
*/


/** \brief F20, ATOM3 Shared Service Request 0 */

/** Alias (User Manual Name) for SRC_GTM_ATOM3_0.
* To use register names with standard convension, please use SRC_GTM_ATOM3_0.
*/


/** \brief F24, ATOM3 Shared Service Request 1 */

/** Alias (User Manual Name) for SRC_GTM_ATOM3_1.
* To use register names with standard convension, please use SRC_GTM_ATOM3_1.
*/


/** \brief F28, ATOM3 Shared Service Request 2 */

/** Alias (User Manual Name) for SRC_GTM_ATOM3_2.
* To use register names with standard convension, please use SRC_GTM_ATOM3_2.
*/


/** \brief F2C, ATOM3 Shared Service Request 3 */

/** Alias (User Manual Name) for SRC_GTM_ATOM3_3.
* To use register names with standard convension, please use SRC_GTM_ATOM3_3.
*/


/** \brief F30, ATOM4 Shared Service Request 0 */

/** Alias (User Manual Name) for SRC_GTM_ATOM4_0.
* To use register names with standard convension, please use SRC_GTM_ATOM4_0.
*/


/** \brief F34, ATOM4 Shared Service Request 1 */

/** Alias (User Manual Name) for SRC_GTM_ATOM4_1.
* To use register names with standard convension, please use SRC_GTM_ATOM4_1.
*/


/** \brief F38, ATOM4 Shared Service Request 2 */

/** Alias (User Manual Name) for SRC_GTM_ATOM4_2.
* To use register names with standard convension, please use SRC_GTM_ATOM4_2.
*/


/** \brief F3C, ATOM4 Shared Service Request 3 */

/** Alias (User Manual Name) for SRC_GTM_ATOM4_3.
* To use register names with standard convension, please use SRC_GTM_ATOM4_3.
*/


/** \brief F40, ATOM5 Shared Service Request 0 */

/** Alias (User Manual Name) for SRC_GTM_ATOM5_0.
* To use register names with standard convension, please use SRC_GTM_ATOM5_0.
*/


/** \brief F44, ATOM5 Shared Service Request 1 */

/** Alias (User Manual Name) for SRC_GTM_ATOM5_1.
* To use register names with standard convension, please use SRC_GTM_ATOM5_1.
*/


/** \brief F48, ATOM5 Shared Service Request 2 */

/** Alias (User Manual Name) for SRC_GTM_ATOM5_2.
* To use register names with standard convension, please use SRC_GTM_ATOM5_2.
*/


/** \brief F4C, ATOM5 Shared Service Request 3 */

/** Alias (User Manual Name) for SRC_GTM_ATOM5_3.
* To use register names with standard convension, please use SRC_GTM_ATOM5_3.
*/


/** \brief F50, ATOM6 Shared Service Request 0 */

/** Alias (User Manual Name) for SRC_GTM_ATOM6_0.
* To use register names with standard convension, please use SRC_GTM_ATOM6_0.
*/


/** \brief F54, ATOM6 Shared Service Request 1 */

/** Alias (User Manual Name) for SRC_GTM_ATOM6_1.
* To use register names with standard convension, please use SRC_GTM_ATOM6_1.
*/


/** \brief F58, ATOM6 Shared Service Request 2 */

/** Alias (User Manual Name) for SRC_GTM_ATOM6_2.
* To use register names with standard convension, please use SRC_GTM_ATOM6_2.
*/


/** \brief F5C, ATOM6 Shared Service Request 3 */

/** Alias (User Manual Name) for SRC_GTM_ATOM6_3.
* To use register names with standard convension, please use SRC_GTM_ATOM6_3.
*/


/** \brief F60, ATOM7 Shared Service Request 0 */

/** Alias (User Manual Name) for SRC_GTM_ATOM7_0.
* To use register names with standard convension, please use SRC_GTM_ATOM7_0.
*/


/** \brief F64, ATOM7 Shared Service Request 1 */

/** Alias (User Manual Name) for SRC_GTM_ATOM7_1.
* To use register names with standard convension, please use SRC_GTM_ATOM7_1.
*/


/** \brief F68, ATOM7 Shared Service Request 2 */

/** Alias (User Manual Name) for SRC_GTM_ATOM7_2.
* To use register names with standard convension, please use SRC_GTM_ATOM7_2.
*/


/** \brief F6C, ATOM7 Shared Service Request 3 */

/** Alias (User Manual Name) for SRC_GTM_ATOM7_3.
* To use register names with standard convension, please use SRC_GTM_ATOM7_3.
*/


/** \brief F70, ATOM8 Shared Service Request 0 */

/** Alias (User Manual Name) for SRC_GTM_ATOM8_0.
* To use register names with standard convension, please use SRC_GTM_ATOM8_0.
*/


/** \brief F74, ATOM8 Shared Service Request 1 */

/** Alias (User Manual Name) for SRC_GTM_ATOM8_1.
* To use register names with standard convension, please use SRC_GTM_ATOM8_1.
*/


/** \brief F78, ATOM8 Shared Service Request 2 */

/** Alias (User Manual Name) for SRC_GTM_ATOM8_2.
* To use register names with standard convension, please use SRC_GTM_ATOM8_2.
*/


/** \brief F7C, ATOM8 Shared Service Request 3 */

/** Alias (User Manual Name) for SRC_GTM_ATOM8_3.
* To use register names with standard convension, please use SRC_GTM_ATOM8_3.
*/


/** \brief FB0, ASCLIN22 Transmit Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN22_TX.
* To use register names with standard convension, please use SRC_ASCLIN22_TX.
*/


/** \brief FB4, ASCLIN22 Receive Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN22_RX.
* To use register names with standard convension, please use SRC_ASCLIN22_RX.
*/


/** \brief FB8, ASCLIN22 Error Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN22_ERR.
* To use register names with standard convension, please use SRC_ASCLIN22_ERR.
*/


/** \brief FBC, ASCLIN23 Transmit Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN23_TX.
* To use register names with standard convension, please use SRC_ASCLIN23_TX.
*/


/** \brief FC0, ASCLIN23 Receive Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN23_RX.
* To use register names with standard convension, please use SRC_ASCLIN23_RX.
*/


/** \brief FC4, ASCLIN23 Error Service Request */

/** Alias (User Manual Name) for SRC_ASCLIN23_ERR.
* To use register names with standard convension, please use SRC_ASCLIN23_ERR.
*/


/** \brief FD0, GTM Multi Channel Sequencer Service Request 0 */

/** Alias (User Manual Name) for SRC_GTM_MCSW0.
* To use register names with standard convension, please use SRC_GTM_MCSW0.
*/


/** \brief FD4, GTM Multi Channel Sequencer Service Request 1 */

/** Alias (User Manual Name) for SRC_GTM_MCSW1.
* To use register names with standard convension, please use SRC_GTM_MCSW1.
*/


/** \brief FD8, GTM Multi Channel Sequencer Service Request 2 */

/** Alias (User Manual Name) for SRC_GTM_MCSW2.
* To use register names with standard convension, please use SRC_GTM_MCSW2.
*/


/** \brief FDC, GTM Multi Channel Sequencer Service Request 3 */

/** Alias (User Manual Name) for SRC_GTM_MCSW3.
* To use register names with standard convension, please use SRC_GTM_MCSW3.
*/


/** \brief FE0, GTM Multi Channel Sequencer Service Request 4 */

/** Alias (User Manual Name) for SRC_GTM_MCSW4.
* To use register names with standard convension, please use SRC_GTM_MCSW4.
*/


/** \brief FE4, GTM Multi Channel Sequencer Service Request 5 */

/** Alias (User Manual Name) for SRC_GTM_MCSW5.
* To use register names with standard convension, please use SRC_GTM_MCSW5.
*/


/** \brief FE8, GTM Multi Channel Sequencer Service Request 6 */

/** Alias (User Manual Name) for SRC_GTM_MCSW6.
* To use register names with standard convension, please use SRC_GTM_MCSW6.
*/


/** \brief FEC, GTM Multi Channel Sequencer Service Request 7 */

/** Alias (User Manual Name) for SRC_GTM_MCSW7.
* To use register names with standard convension, please use SRC_GTM_MCSW7.
*/


/** \brief FF0, GTM Multi Channel Sequencer Service Request 8 */

/** Alias (User Manual Name) for SRC_GTM_MCSW8.
* To use register names with standard convension, please use SRC_GTM_MCSW8.
*/


/** \brief FF4, GTM Multi Channel Sequencer Service Request 9 */

/** Alias (User Manual Name) for SRC_GTM_MCSW9.
* To use register names with standard convension, please use SRC_GTM_MCSW9.
*/



/** \}  */

/******************************************************************************/

/******************************************************************************/


#line 71 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\ee\\..\\Libraries\\iLLD\\TC38A\\Tricore\\Cpu\\Std\\IfxCpu.h"

#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\Infra\\Sfr\\TC38A\\_Reg\\IfxScu_reg.h"
/**
 * \file IfxScu_reg.h
 * \brief
 * \copyright Copyright (c) 2020 Infineon Technologies AG. All rights reserved.
 *
 *
 * Version: TC38XA_UM_V1.5.0
 * Specification: TC3xx User Manual V1.5.0
 * MAY BE CHANGED BY USER [yes/no]: No
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * \defgroup IfxSfr_Scu_Registers_Cfg Scu address
 * \ingroup IfxSfr_Scu_Registers
 * 
 * \defgroup IfxSfr_Scu_Registers_Cfg_BaseAddress Base address
 * \ingroup IfxSfr_Scu_Registers_Cfg
 *
 * \defgroup IfxSfr_Scu_Registers_Cfg_Scu 2-SCU
 * \ingroup IfxSfr_Scu_Registers_Cfg
 *
 *
 */


/******************************************************************************/

#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\Infra\\Sfr\\TC38A\\_Reg\\IfxScu_regdef.h"
/**
 * \file IfxScu_regdef.h
 * \brief
 * \copyright Copyright (c) 2020 Infineon Technologies AG. All rights reserved.
 *
 *
 * Version: TC38XA_UM_V1.5.0
 * Specification: TC3xx User Manual V1.5.0
 * MAY BE CHANGED BY USER [yes/no]: No
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * \defgroup IfxSfr_Scu_Registers Scu Registers
 * \ingroup IfxSfr
 * 
 * \defgroup IfxSfr_Scu_Registers_Bitfields Bitfields
 * \ingroup IfxSfr_Scu_Registers
 * 
 * \defgroup IfxSfr_Scu_Registers_union Register unions
 * \ingroup IfxSfr_Scu_Registers
 * 
 * \defgroup IfxSfr_Scu_Registers_struct Memory map
 * \ingroup IfxSfr_Scu_Registers
 */


/******************************************************************************/

/******************************************************************************/

/******************************************************************************/

/******************************************************************************/


/** \addtogroup IfxSfr_Scu_Registers_Bitfields
 * \{  */
/** \brief Access Enable Register 00 */
typedef struct _Ifx_SCU_ACCEN00_Bits
{
    Ifx_UReg_32Bit EN0:1;             /**< \brief [0:0] Access Enable for Master TAG ID 0 - EN0 (rw) */
    Ifx_UReg_32Bit EN1:1;             /**< \brief [1:1] Access Enable for Master TAG ID 1 - EN1 (rw) */
    Ifx_UReg_32Bit EN2:1;             /**< \brief [2:2] Access Enable for Master TAG ID 2 - EN2 (rw) */
    Ifx_UReg_32Bit EN3:1;             /**< \brief [3:3] Access Enable for Master TAG ID 3 - EN3 (rw) */
    Ifx_UReg_32Bit EN4:1;             /**< \brief [4:4] Access Enable for Master TAG ID 4 - EN4 (rw) */
    Ifx_UReg_32Bit EN5:1;             /**< \brief [5:5] Access Enable for Master TAG ID 5 - EN5 (rw) */
    Ifx_UReg_32Bit EN6:1;             /**< \brief [6:6] Access Enable for Master TAG ID 6 - EN6 (rw) */
    Ifx_UReg_32Bit EN7:1;             /**< \brief [7:7] Access Enable for Master TAG ID 7 - EN7 (rw) */
    Ifx_UReg_32Bit EN8:1;             /**< \brief [8:8] Access Enable for Master TAG ID 8 - EN8 (rw) */
    Ifx_UReg_32Bit EN9:1;             /**< \brief [9:9] Access Enable for Master TAG ID 9 - EN9 (rw) */
    Ifx_UReg_32Bit EN10:1;            /**< \brief [10:10] Access Enable for Master TAG ID 10 - EN10 (rw) */
    Ifx_UReg_32Bit EN11:1;            /**< \brief [11:11] Access Enable for Master TAG ID 11 - EN11 (rw) */
    Ifx_UReg_32Bit EN12:1;            /**< \brief [12:12] Access Enable for Master TAG ID 12 - EN12 (rw) */
    Ifx_UReg_32Bit EN13:1;            /**< \brief [13:13] Access Enable for Master TAG ID 13 - EN13 (rw) */
    Ifx_UReg_32Bit EN14:1;            /**< \brief [14:14] Access Enable for Master TAG ID 14 - EN14 (rw) */
    Ifx_UReg_32Bit EN15:1;            /**< \brief [15:15] Access Enable for Master TAG ID 15 - EN15 (rw) */
    Ifx_UReg_32Bit EN16:1;            /**< \brief [16:16] Access Enable for Master TAG ID 16 - EN16 (rw) */
    Ifx_UReg_32Bit EN17:1;            /**< \brief [17:17] Access Enable for Master TAG ID 17 - EN17 (rw) */
    Ifx_UReg_32Bit EN18:1;            /**< \brief [18:18] Access Enable for Master TAG ID 18 - EN18 (rw) */
    Ifx_UReg_32Bit EN19:1;            /**< \brief [19:19] Access Enable for Master TAG ID 19 - EN19 (rw) */
    Ifx_UReg_32Bit EN20:1;            /**< \brief [20:20] Access Enable for Master TAG ID 20 - EN20 (rw) */
    Ifx_UReg_32Bit EN21:1;            /**< \brief [21:21] Access Enable for Master TAG ID 21 - EN21 (rw) */
    Ifx_UReg_32Bit EN22:1;            /**< \brief [22:22] Access Enable for Master TAG ID 22 - EN22 (rw) */
    Ifx_UReg_32Bit EN23:1;            /**< \brief [23:23] Access Enable for Master TAG ID 23 - EN23 (rw) */
    Ifx_UReg_32Bit EN24:1;            /**< \brief [24:24] Access Enable for Master TAG ID 24 - EN24 (rw) */
    Ifx_UReg_32Bit EN25:1;            /**< \brief [25:25] Access Enable for Master TAG ID 25 - EN25 (rw) */
    Ifx_UReg_32Bit EN26:1;            /**< \brief [26:26] Access Enable for Master TAG ID 26 - EN26 (rw) */
    Ifx_UReg_32Bit EN27:1;            /**< \brief [27:27] Access Enable for Master TAG ID 27 - EN27 (rw) */
    Ifx_UReg_32Bit EN28:1;            /**< \brief [28:28] Access Enable for Master TAG ID 28 - EN28 (rw) */
    Ifx_UReg_32Bit EN29:1;            /**< \brief [29:29] Access Enable for Master TAG ID 29 - EN29 (rw) */
    Ifx_UReg_32Bit EN30:1;            /**< \brief [30:30] Access Enable for Master TAG ID 30 - EN30 (rw) */
    Ifx_UReg_32Bit EN31:1;            /**< \brief [31:31] Access Enable for Master TAG ID 31 - EN31 (rw) */
} Ifx_SCU_ACCEN00_Bits;

/** \brief Access Enable Register 01 */
typedef struct _Ifx_SCU_ACCEN01_Bits
{
    Ifx_UReg_32Bit reserved_0:32;     /**< \brief [31:0] \internal Reserved */
} Ifx_SCU_ACCEN01_Bits;

/** \brief Access Enable Register 10 */
typedef struct _Ifx_SCU_ACCEN10_Bits
{
    Ifx_UReg_32Bit EN0:1;             /**< \brief [0:0] Access Enable for Master TAG ID 0 - EN0 (rw) */
    Ifx_UReg_32Bit EN1:1;             /**< \brief [1:1] Access Enable for Master TAG ID 1 - EN1 (rw) */
    Ifx_UReg_32Bit EN2:1;             /**< \brief [2:2] Access Enable for Master TAG ID 2 - EN2 (rw) */
    Ifx_UReg_32Bit EN3:1;             /**< \brief [3:3] Access Enable for Master TAG ID 3 - EN3 (rw) */
    Ifx_UReg_32Bit EN4:1;             /**< \brief [4:4] Access Enable for Master TAG ID 4 - EN4 (rw) */
    Ifx_UReg_32Bit EN5:1;             /**< \brief [5:5] Access Enable for Master TAG ID 5 - EN5 (rw) */
    Ifx_UReg_32Bit EN6:1;             /**< \brief [6:6] Access Enable for Master TAG ID 6 - EN6 (rw) */
    Ifx_UReg_32Bit EN7:1;             /**< \brief [7:7] Access Enable for Master TAG ID 7 - EN7 (rw) */
    Ifx_UReg_32Bit EN8:1;             /**< \brief [8:8] Access Enable for Master TAG ID 8 - EN8 (rw) */
    Ifx_UReg_32Bit EN9:1;             /**< \brief [9:9] Access Enable for Master TAG ID 9 - EN9 (rw) */
    Ifx_UReg_32Bit EN10:1;            /**< \brief [10:10] Access Enable for Master TAG ID 10 - EN10 (rw) */
    Ifx_UReg_32Bit EN11:1;            /**< \brief [11:11] Access Enable for Master TAG ID 11 - EN11 (rw) */
    Ifx_UReg_32Bit EN12:1;            /**< \brief [12:12] Access Enable for Master TAG ID 12 - EN12 (rw) */
    Ifx_UReg_32Bit EN13:1;            /**< \brief [13:13] Access Enable for Master TAG ID 13 - EN13 (rw) */
    Ifx_UReg_32Bit EN14:1;            /**< \brief [14:14] Access Enable for Master TAG ID 14 - EN14 (rw) */
    Ifx_UReg_32Bit EN15:1;            /**< \brief [15:15] Access Enable for Master TAG ID 15 - EN15 (rw) */
    Ifx_UReg_32Bit EN16:1;            /**< \brief [16:16] Access Enable for Master TAG ID 16 - EN16 (rw) */
    Ifx_UReg_32Bit EN17:1;            /**< \brief [17:17] Access Enable for Master TAG ID 17 - EN17 (rw) */
    Ifx_UReg_32Bit EN18:1;            /**< \brief [18:18] Access Enable for Master TAG ID 18 - EN18 (rw) */
    Ifx_UReg_32Bit EN19:1;            /**< \brief [19:19] Access Enable for Master TAG ID 19 - EN19 (rw) */
    Ifx_UReg_32Bit EN20:1;            /**< \brief [20:20] Access Enable for Master TAG ID 20 - EN20 (rw) */
    Ifx_UReg_32Bit EN21:1;            /**< \brief [21:21] Access Enable for Master TAG ID 21 - EN21 (rw) */
    Ifx_UReg_32Bit EN22:1;            /**< \brief [22:22] Access Enable for Master TAG ID 22 - EN22 (rw) */
    Ifx_UReg_32Bit EN23:1;            /**< \brief [23:23] Access Enable for Master TAG ID 23 - EN23 (rw) */
    Ifx_UReg_32Bit EN24:1;            /**< \brief [24:24] Access Enable for Master TAG ID 24 - EN24 (rw) */
    Ifx_UReg_32Bit EN25:1;            /**< \brief [25:25] Access Enable for Master TAG ID 25 - EN25 (rw) */
    Ifx_UReg_32Bit EN26:1;            /**< \brief [26:26] Access Enable for Master TAG ID 26 - EN26 (rw) */
    Ifx_UReg_32Bit EN27:1;            /**< \brief [27:27] Access Enable for Master TAG ID 27 - EN27 (rw) */
    Ifx_UReg_32Bit EN28:1;            /**< \brief [28:28] Access Enable for Master TAG ID 28 - EN28 (rw) */
    Ifx_UReg_32Bit EN29:1;            /**< \brief [29:29] Access Enable for Master TAG ID 29 - EN29 (rw) */
    Ifx_UReg_32Bit EN30:1;            /**< \brief [30:30] Access Enable for Master TAG ID 30 - EN30 (rw) */
    Ifx_UReg_32Bit EN31:1;            /**< \brief [31:31] Access Enable for Master TAG ID 31 - EN31 (rw) */
} Ifx_SCU_ACCEN10_Bits;

/** \brief Access Enable Register 11 */
typedef struct _Ifx_SCU_ACCEN11_Bits
{
    Ifx_UReg_32Bit reserved_0:32;     /**< \brief [31:0] \internal Reserved */
} Ifx_SCU_ACCEN11_Bits;

/** \brief Application Reset Disable Register */
typedef struct _Ifx_SCU_ARSTDIS_Bits
{
    Ifx_UReg_32Bit STM0DIS:1;         /**< \brief [0:0] STM0 Disable Reset - STM0DIS (rw) */
    Ifx_UReg_32Bit STM1DIS:1;         /**< \brief [1:1] STM1 Disable Reset - STM1DIS (rw) */
    Ifx_UReg_32Bit STM2DIS:1;         /**< \brief [2:2] STM2 Disable Reset - STM2DIS (rw) */
    Ifx_UReg_32Bit STM3DIS:1;         /**< \brief [3:3] STM3 Disable Reset - STM3DIS (rw) */
    Ifx_UReg_32Bit reserved_4:1;      /**< \brief [4:4] \internal Reserved */
    Ifx_UReg_32Bit reserved_5:1;      /**< \brief [5:5] \internal Reserved */
    Ifx_UReg_32Bit reserved_6:2;      /**< \brief [7:6] \internal Reserved */
    Ifx_UReg_32Bit reserved_8:24;     /**< \brief [31:8] \internal Reserved */
} Ifx_SCU_ARSTDIS_Bits;

/** \brief CCU Clock Control Register 0 */
typedef struct _Ifx_SCU_CCUCON0_Bits
{
    Ifx_UReg_32Bit STMDIV:4;          /**< \brief [3:0] STM Divider Reload Value - STMDIV (rw) */
    Ifx_UReg_32Bit GTMDIV:4;          /**< \brief [7:4] GTM Divider Reload Value - GTMDIV (rw) */
    Ifx_UReg_32Bit SRIDIV:4;          /**< \brief [11:8] SRI Divider Reload Value - SRIDIV (rw) */
    Ifx_UReg_32Bit LPDIV:3;           /**< \brief [14:12] Low Power Divider Reload Value - LPDIV (rw) */
    Ifx_UReg_32Bit reserved_15:1;     /**< \brief [15:15] \internal Reserved */
    Ifx_UReg_32Bit SPBDIV:4;          /**< \brief [19:16] SPB Divider Reload Value - SPBDIV (rw) */
    Ifx_UReg_32Bit BBBDIV:4;          /**< \brief [23:20] BBB Divider Reload Value - BBBDIV (rw) */
    Ifx_UReg_32Bit FSIDIV:2;          /**< \brief [25:24] FSI Divider Reload Value - FSIDIV (rw) */
    Ifx_UReg_32Bit FSI2DIV:2;         /**< \brief [27:26] FSI2 Divider Reload Value - FSI2DIV (rw) */
    Ifx_UReg_32Bit CLKSEL:2;          /**< \brief [29:28] Clock Selection for Source - CLKSEL (rwh) */
    Ifx_UReg_32Bit UP:1;              /**< \brief [30:30] Update Request - UP (w) */
    Ifx_UReg_32Bit LCK:1;             /**< \brief [31:31] Lock Status - LCK (rh) */
} Ifx_SCU_CCUCON0_Bits;

/** \brief CCU Clock Control Register 1 */
typedef struct _Ifx_SCU_CCUCON1_Bits
{
    Ifx_UReg_32Bit MCANDIV:4;         /**< \brief [3:0] MCAN Divider Reload Value - MCANDIV (rw) */
    Ifx_UReg_32Bit CLKSELMCAN:2;      /**< \brief [5:4] Clock Selection for MCAN - CLKSELMCAN (rw) */
    Ifx_UReg_32Bit reserved_6:1;      /**< \brief [6:6] \internal Reserved */
    Ifx_UReg_32Bit PLL1DIVDIS:1;      /**< \brief [7:7] Divider Disable for fPLL1 - PLL1DIVDIS (rw) */
    Ifx_UReg_32Bit I2CDIV:4;          /**< \brief [11:8] I2C Divider Reload Value - I2CDIV (rw) */
    Ifx_UReg_32Bit reserved_12:4;     /**< \brief [15:12] \internal Reserved */
    Ifx_UReg_32Bit MSCDIV:4;          /**< \brief [19:16] MSC Divider Reload Value - MSCDIV (rw) */
    Ifx_UReg_32Bit CLKSELMSC:2;       /**< \brief [21:20] Clock Selection for MSC - CLKSELMSC (rw) */
    Ifx_UReg_32Bit reserved_22:2;     /**< \brief [23:22] \internal Reserved */
    Ifx_UReg_32Bit QSPIDIV:4;         /**< \brief [27:24] QSPI Divider Reload Value - QSPIDIV (rw) */
    Ifx_UReg_32Bit CLKSELQSPI:2;      /**< \brief [29:28] Clock Selection for QSPI - CLKSELQSPI (rw) */
    Ifx_UReg_32Bit reserved_30:1;     /**< \brief [30:30] \internal Reserved */
    Ifx_UReg_32Bit LCK:1;             /**< \brief [31:31] Lock Status - LCK (rh) */
} Ifx_SCU_CCUCON1_Bits;

/** \brief CCU Clock Control Register 2 */
typedef struct _Ifx_SCU_CCUCON2_Bits
{
    Ifx_UReg_32Bit ASCLINFDIV:4;      /**< \brief [3:0] ASCLIN Fast Divider Reload Value - ASCLINFDIV (rw) */
    Ifx_UReg_32Bit reserved_4:4;      /**< \brief [7:4] \internal Reserved */
    Ifx_UReg_32Bit ASCLINSDIV:4;      /**< \brief [11:8] ASCLIN Slow Divider Reload Value - ASCLINSDIV (rw) */
    Ifx_UReg_32Bit CLKSELASCLINS:2;    /**< \brief [13:12] Clock Selection for ASCLINS - CLKSELASCLINS (rw) */
    Ifx_UReg_32Bit reserved_14:10;    /**< \brief [23:14] \internal Reserved */
    Ifx_UReg_32Bit reserved_24:1;     /**< \brief [24:24] \internal Reserved */
    Ifx_UReg_32Bit ERAYPERON:1;       /**< \brief [25:25] Power Safe SwitchOff for ERAY Clock - ERAYPERON (rw) */
    Ifx_UReg_32Bit reserved_26:1;     /**< \brief [26:26] \internal Reserved */
    Ifx_UReg_32Bit reserved_27:4;     /**< \brief [30:27] \internal Reserved */
    Ifx_UReg_32Bit LCK:1;             /**< \brief [31:31] Lock Status - LCK (rh) */
} Ifx_SCU_CCUCON2_Bits;

/** \brief CCU Clock Control Register 3 */
typedef struct _Ifx_SCU_CCUCON3_Bits
{
    Ifx_UReg_32Bit PLL0MONEN:1;       /**< \brief [0:0] PLL0 Clock Monitor Enable - PLL0MONEN (rw) */
    Ifx_UReg_32Bit PLL1MONEN:1;       /**< \brief [1:1] PLL1 Clock Monitor Enable - PLL1MONEN (rw) */
    Ifx_UReg_32Bit PLL2MONEN:1;       /**< \brief [2:2] PLL2 Clock Monitor Enable - PLL2MONEN (rw) */
    Ifx_UReg_32Bit SPBMONEN:1;        /**< \brief [3:3] SPB Clock Monitor Enable - SPBMONEN (rw) */
    Ifx_UReg_32Bit BACKMONEN:1;       /**< \brief [4:4] Backup Clock Monitor Enable - BACKMONEN (rw) */
    Ifx_UReg_32Bit reserved_5:3;      /**< \brief [7:5] \internal Reserved */
    Ifx_UReg_32Bit PLL0MONTST:1;      /**< \brief [8:8] PLL0 Clock Monitor Test - PLL0MONTST (rw) */
    Ifx_UReg_32Bit PLL1MONTST:1;      /**< \brief [9:9] PLL1 Clock Monitor Test - PLL1MONTST (rw) */
    Ifx_UReg_32Bit PLL2MONTST:1;      /**< \brief [10:10] PLL2 Clock Monitor Test - PLL2MONTST (rw) */
    Ifx_UReg_32Bit SPBMONTST:1;       /**< \brief [11:11] SPB Clock Monitor Test - SPBMONTST (rw) */
    Ifx_UReg_32Bit BACKMONTST:1;      /**< \brief [12:12] Backup Clock Monitor Test - BACKMONTST (rw) */
    Ifx_UReg_32Bit reserved_13:11;    /**< \brief [23:13] \internal Reserved */
    Ifx_UReg_32Bit reserved_24:6;     /**< \brief [29:24] \internal Reserved */
    Ifx_UReg_32Bit UP:1;              /**< \brief [30:30] Update Request - UP (w) */
    Ifx_UReg_32Bit LCK:1;             /**< \brief [31:31] Lock Status - LCK (rh) */
} Ifx_SCU_CCUCON3_Bits;

/** \brief CCU Clock Control Register 4 */
typedef struct _Ifx_SCU_CCUCON4_Bits
{
    Ifx_UReg_32Bit LOTHR:12;          /**< \brief [11:0] Backup Clock Monitor Lower Threshold - LOTHR (rw) */
    Ifx_UReg_32Bit UPTHR:12;          /**< \brief [23:12] Backup Clock Monitor Upper Threshold - UPTHR (rw) */
    Ifx_UReg_32Bit MONEN:1;           /**< \brief [24:24] Backup Clock Monitor Enable - MONEN (rw) */
    Ifx_UReg_32Bit MONTST:1;          /**< \brief [25:25] Backup Clock Monitor Test - MONTST (rw) */
    Ifx_UReg_32Bit reserved_26:4;     /**< \brief [29:26] \internal Reserved */
    Ifx_UReg_32Bit UP:1;              /**< \brief [30:30] Update Request - UP (w) */
    Ifx_UReg_32Bit LCK:1;             /**< \brief [31:31] Lock Status - LCK (rh) */
} Ifx_SCU_CCUCON4_Bits;

/** \brief CCU Clock Control Register 5 */
typedef struct _Ifx_SCU_CCUCON5_Bits
{
    Ifx_UReg_32Bit GETHDIV:4;         /**< \brief [3:0] GETH Divider Reload Value - GETHDIV (rw) */
    Ifx_UReg_32Bit MCANHDIV:4;        /**< \brief [7:4] MCANH Divider Reload Value - MCANHDIV (rw) */
    Ifx_UReg_32Bit reserved_8:4;      /**< \brief [11:8] \internal Reserved */
    Ifx_UReg_32Bit reserved_12:18;    /**< \brief [29:12] \internal Reserved */
    Ifx_UReg_32Bit UP:1;              /**< \brief [30:30] Update Request - UP (w) */
    Ifx_UReg_32Bit LCK:1;             /**< \brief [31:31] Lock Status - LCK (rh) */
} Ifx_SCU_CCUCON5_Bits;

/** \brief CCU Clock Control Register 6 */
typedef struct _Ifx_SCU_CCUCON6_Bits
{
    Ifx_UReg_32Bit CPU0DIV:6;         /**< \brief [5:0] CPU0 Divider Reload Value - CPU0DIV (rw) */
    Ifx_UReg_32Bit reserved_6:26;     /**< \brief [31:6] \internal Reserved */
} Ifx_SCU_CCUCON6_Bits;

/** \brief CCU Clock Control Register 7 */
typedef struct _Ifx_SCU_CCUCON7_Bits
{
    Ifx_UReg_32Bit CPU1DIV:6;         /**< \brief [5:0] CPU1 Divider Reload Value - CPU1DIV (rw) */
    Ifx_UReg_32Bit reserved_6:26;     /**< \brief [31:6] \internal Reserved */
} Ifx_SCU_CCUCON7_Bits;

/** \brief CCU Clock Control Register 8 */
typedef struct _Ifx_SCU_CCUCON8_Bits
{
    Ifx_UReg_32Bit CPU2DIV:6;         /**< \brief [5:0] CPU2 Divider Reload Value - CPU2DIV (rw) */
    Ifx_UReg_32Bit reserved_6:26;     /**< \brief [31:6] \internal Reserved */
} Ifx_SCU_CCUCON8_Bits;

/** \brief CCU Clock Control Register 9 */
typedef struct _Ifx_SCU_CCUCON9_Bits
{
    Ifx_UReg_32Bit CPU3DIV:6;         /**< \brief [5:0] CPU3 Divider Reload Value - CPU3DIV (rw) */
    Ifx_UReg_32Bit reserved_6:26;     /**< \brief [31:6] \internal Reserved */
} Ifx_SCU_CCUCON9_Bits;

/** \brief Chip Identification Register */
typedef struct _Ifx_SCU_CHIPID_Bits
{
    Ifx_UReg_32Bit CHREV:6;           /**< \brief [5:0] Chip Revision Number - CHREV (r) */
    Ifx_UReg_32Bit CHTEC:2;           /**< \brief [7:6] Chip Family - CHTEC (r) */
    Ifx_UReg_32Bit CHPK:4;            /**< \brief [11:8] Chip Package - CHPK (rw) */
    Ifx_UReg_32Bit CHID:4;            /**< \brief [15:12] Chip Product - CHID (rw) */
    Ifx_UReg_32Bit EEA:1;             /**< \brief [16:16] Emulation or ADAS Extension Available - EEA (rh) */
    Ifx_UReg_32Bit UCODE:7;           /**< \brief [23:17] \xb5Code Version - UCODE (rw) */
    Ifx_UReg_32Bit FSIZE:4;           /**< \brief [27:24] Program Flash Size - FSIZE (rw) */
    Ifx_UReg_32Bit VART:3;            /**< \brief [30:28] Variant - VART (rw) */
    Ifx_UReg_32Bit SEC:1;             /**< \brief [31:31] Security Device Available - SEC (rw) */
} Ifx_SCU_CHIPID_Bits;

/** \brief Core Die Temperature Sensor Limit Register */
typedef struct _Ifx_SCU_DTSCLIM_Bits
{
    Ifx_UReg_32Bit LOWER:12;          /**< \brief [11:0] DTSC Lower Limit - LOWER (rw) */
    Ifx_UReg_32Bit reserved_12:1;     /**< \brief [12:12] \internal Reserved */
    Ifx_UReg_32Bit BGPOK:1;           /**< \brief [13:13] DTSC Bandgap OK (rh) */
    Ifx_UReg_32Bit EN:1;              /**< \brief [14:14] DTSC Enable (rw) */
    Ifx_UReg_32Bit LLU:1;             /**< \brief [15:15] DTSC Lower Limit Underflow - LLU (rwh) */
    Ifx_UReg_32Bit UPPER:12;          /**< \brief [27:16] DTSC Upper Limit - UPPER (rw) */
    Ifx_UReg_32Bit INTEN:1;           /**< \brief [28:28] DTSC Interrupt Enable (rw) */
    Ifx_UReg_32Bit reserved_29:1;     /**< \brief [29:29] \internal Reserved */
    Ifx_UReg_32Bit INT:1;             /**< \brief [30:30] DTSC Interrupt status flag (rwh) */
    Ifx_UReg_32Bit UOF:1;             /**< \brief [31:31] DTSC Upper Limit Overflow - UOF (rwh) */
} Ifx_SCU_DTSCLIM_Bits;

/** \brief Core Die Temperature Sensor Status Register */
typedef struct _Ifx_SCU_DTSCSTAT_Bits
{
    Ifx_UReg_32Bit RESULT:12;         /**< \brief [11:0] Result of the DTSC Measurement - RESULT (rh) */
    Ifx_UReg_32Bit reserved_12:20;    /**< \brief [31:12] \internal Reserved */
} Ifx_SCU_DTSCSTAT_Bits;

/** \brief ENDINIT Global Control Register 0 */
typedef struct _Ifx_SCU_EICON0_Bits
{
    unsigned __sfrbit32 reserved_0:1;    /**< \brief [0:0] \internal Reserved */
    unsigned __sfrbit32 ENDINIT:1;       /**< \brief [1:1] End-of-Initialization Control Bit - ENDINIT (rwh) */
    unsigned __sfrbit32 EPW:14;          /**< \brief [15:2] User-Definable ENDINIT Password Field - EPW (rwh) */
    unsigned __sfrbit32 REL:16;          /**< \brief [31:16] Reload Value for the ENDINIT Timeout Counter - REL (r) */
} Ifx_SCU_EICON0_Bits;

/** \brief ENDINIT Global Control Register 1 */
typedef struct _Ifx_SCU_EICON1_Bits
{
    Ifx_UReg_32Bit reserved_0:1;      /**< \brief [0:0] \internal Reserved */
    Ifx_UReg_32Bit reserved_1:1;      /**< \brief [1:1] \internal Reserved */
    Ifx_UReg_32Bit IR0:1;             /**< \brief [2:2] Input Frequency Request Control - IR1,IR0 (rw) */
    Ifx_UReg_32Bit DR:1;              /**< \brief [3:3] Disable Request Control Bit - DR (rw) */
    Ifx_UReg_32Bit reserved_4:1;      /**< \brief [4:4] \internal Reserved */
    Ifx_UReg_32Bit IR1:1;             /**< \brief [5:5] Input Frequency Request Control - IR1,IR0 (rw) */
    Ifx_UReg_32Bit reserved_6:26;     /**< \brief [31:6] \internal Reserved */
} Ifx_SCU_EICON1_Bits;

/** \brief External Input Channel Register ${i} */
typedef struct _Ifx_SCU_EICR_Bits
{
    Ifx_UReg_32Bit reserved_0:4;      /**< \brief [3:0] \internal Reserved */
    Ifx_UReg_32Bit EXIS0:3;           /**< \brief [6:4] External Input Selection 0 - EXIS0 (rw) */
    Ifx_UReg_32Bit reserved_7:1;      /**< \brief [7:7] \internal Reserved */
    Ifx_UReg_32Bit FEN0:1;            /**< \brief [8:8] Falling Edge Enable 0 - FEN0 (rw) */
    Ifx_UReg_32Bit REN0:1;            /**< \brief [9:9] Rising Edge Enable 0 - REN0 (rw) */
    Ifx_UReg_32Bit LDEN0:1;           /**< \brief [10:10] Level Detection Enable 0 - LDEN0 (rw) */
    Ifx_UReg_32Bit EIEN0:1;           /**< \brief [11:11] External Input Enable 0 - EIEN0 (rw) */
    Ifx_UReg_32Bit INP0:3;            /**< \brief [14:12] Input Node Pointer - INP0 (rw) */
    Ifx_UReg_32Bit reserved_15:5;     /**< \brief [19:15] \internal Reserved */
    Ifx_UReg_32Bit EXIS1:3;           /**< \brief [22:20] External Input Selection 1 - EXIS1 (rw) */
    Ifx_UReg_32Bit reserved_23:1;     /**< \brief [23:23] \internal Reserved */
    Ifx_UReg_32Bit FEN1:1;            /**< \brief [24:24] Falling Edge Enable 1 - FEN1 (rw) */
    Ifx_UReg_32Bit REN1:1;            /**< \brief [25:25] Rising Edge Enable 1 - REN1 (rw) */
    Ifx_UReg_32Bit LDEN1:1;           /**< \brief [26:26] Level Detection Enable 1 - LDEN1 (rw) */
    Ifx_UReg_32Bit EIEN1:1;           /**< \brief [27:27] External Input Enable 1 - EIEN1 (rw) */
    Ifx_UReg_32Bit INP1:3;            /**< \brief [30:28] Input Node Pointer - INP1 (rw) */
    Ifx_UReg_32Bit reserved_31:1;     /**< \brief [31:31] \internal Reserved */
} Ifx_SCU_EICR_Bits;

/** \brief External Input Filter Register */
typedef struct _Ifx_SCU_EIFILT_Bits
{
    Ifx_UReg_32Bit FILRQ0A:1;         /**< \brief [0:0] Filter Enable for REQ0A - FILRQ0A (rw) */
    Ifx_UReg_32Bit FILRQ5A:1;         /**< \brief [1:1] Filter Enable for REQ5A - FILRQ5A (rw) */
    Ifx_UReg_32Bit FILRQ2A:1;         /**< \brief [2:2] Filter Enable for REQ2A - FILRQ2A (rw) */
    Ifx_UReg_32Bit FILRQ3A:1;         /**< \brief [3:3] Filter Enable for REQ3A - FILRQ3A (rw) */
    Ifx_UReg_32Bit FILRQ0C:1;         /**< \brief [4:4] Filter Enable for REQ0C - FILRQ0C (rw) */
    Ifx_UReg_32Bit FILRQ1C:1;         /**< \brief [5:5] Filter Enable for REQ1C - FILRQ1C (rw) */
    Ifx_UReg_32Bit FILRQ3C:1;         /**< \brief [6:6] Filter Enable for REQ3C - FILRQ3C (rw) */
    Ifx_UReg_32Bit FILRQ2C:1;         /**< \brief [7:7] Filter Enable for REQ2C - FILRQ2C (rw) */
    Ifx_UReg_32Bit FILRQ4A:1;         /**< \brief [8:8] Filter Enable for REQ4A - FILRQ4A (rw) */
    Ifx_UReg_32Bit FILRQ6A:1;         /**< \brief [9:9] Filter Enable for REQ6A - FILRQ6A (rw) */
    Ifx_UReg_32Bit FILRQ1A:1;         /**< \brief [10:10] Filter Enable for REQ1A - FILRQ1A (rw) */
    Ifx_UReg_32Bit FILRQ7A:1;         /**< \brief [11:11] Filter Enable for REQ7A - FILRQ7A (rw) */
    Ifx_UReg_32Bit FILRQ6D:1;         /**< \brief [12:12] Filter Enable for REQ6D - FILRQ6D (rw) */
    Ifx_UReg_32Bit FILRQ4D:1;         /**< \brief [13:13] Filter Enable for REQ4D - FILRQ4D (rw) */
    Ifx_UReg_32Bit FILRQ2B:1;         /**< \brief [14:14] Filter Enable for REQ2B - FILRQ2B (rw) */
    Ifx_UReg_32Bit FILRQ3B:1;         /**< \brief [15:15] Filter Enable for REQ3B - FILRQ3B (rw) */
    Ifx_UReg_32Bit FILRQ7C:1;         /**< \brief [16:16] Filter Enable for REQ7C - FILRQ7C (rw) */
    Ifx_UReg_32Bit reserved_17:7;     /**< \brief [23:17] \internal Reserved */
    Ifx_UReg_32Bit FILTDIV:4;         /**< \brief [27:24] Digital Glitch Filter Clock Predivider - FILTDIV (rw) */
    Ifx_UReg_32Bit DEPTH:4;           /**< \brief [31:28] Digital Glitch Filter Depth - DEPTH (rw) */
} Ifx_SCU_EIFILT_Bits;

/** \brief External Input Flag Register */
typedef struct _Ifx_SCU_EIFR_Bits
{
    Ifx_UReg_32Bit INTF0:1;           /**< \brief [0:0] External Event Flag of Channel 0 - INTF0 (rh) */
    Ifx_UReg_32Bit INTF1:1;           /**< \brief [1:1] External Event Flag of Channel 1 - INTF1 (rh) */
    Ifx_UReg_32Bit INTF2:1;           /**< \brief [2:2] External Event Flag of Channel 2 - INTF2 (rh) */
    Ifx_UReg_32Bit INTF3:1;           /**< \brief [3:3] External Event Flag of Channel 3 - INTF3 (rh) */
    Ifx_UReg_32Bit INTF4:1;           /**< \brief [4:4] External Event Flag of Channel 4 - INTF4 (rh) */
    Ifx_UReg_32Bit INTF5:1;           /**< \brief [5:5] External Event Flag of Channel 5 - INTF5 (rh) */
    Ifx_UReg_32Bit INTF6:1;           /**< \brief [6:6] External Event Flag of Channel 6 - INTF6 (rh) */
    Ifx_UReg_32Bit INTF7:1;           /**< \brief [7:7] External Event Flag of Channel 7 - INTF7 (rh) */
    Ifx_UReg_32Bit reserved_8:24;     /**< \brief [31:8] \internal Reserved */
} Ifx_SCU_EIFR_Bits;

/** \brief ENDINIT Timeout Counter Status Register */
typedef struct _Ifx_SCU_EISR_Bits
{
    Ifx_UReg_32Bit AE:1;              /**< \brief [0:0] EICON0 Access Error Status Flag - AE (rh) */
    Ifx_UReg_32Bit OE:1;              /**< \brief [1:1] EI Timeout Overflow Error Status Flag - OE (rh) */
    Ifx_UReg_32Bit IS0:1;             /**< \brief [2:2] EI Timeout Input Clock Status - IS1,IS0 (rh) */
    Ifx_UReg_32Bit DS:1;              /**< \brief [3:3] EI Timeout Enable/Disable Status Flag - DS (rh) */
    Ifx_UReg_32Bit TO:1;              /**< \brief [4:4] EI Time-Out Mode Flag - TO (rh) */
    Ifx_UReg_32Bit IS1:1;             /**< \brief [5:5] EI Timeout Input Clock Status - IS1,IS0 (rh) */
    Ifx_UReg_32Bit reserved_6:10;     /**< \brief [15:6] \internal Reserved */
    Ifx_UReg_32Bit TIM:16;            /**< \brief [31:16] Timer Value - TIM (rh) */
} Ifx_SCU_EISR_Bits;

/** \brief Emergency Stop Register */
typedef struct _Ifx_SCU_EMSR_Bits
{
    Ifx_UReg_32Bit POL:1;             /**< \brief [0:0] Input Polarity - POL (rw) */
    Ifx_UReg_32Bit MODE:1;            /**< \brief [1:1] Mode Selection - MODE (rw) */
    Ifx_UReg_32Bit ENON:1;            /**< \brief [2:2] Enable ON - ENON (rw) */
    Ifx_UReg_32Bit PSEL:1;            /**< \brief [3:3] PORT Select - PSEL (rw) */
    Ifx_UReg_32Bit reserved_4:12;     /**< \brief [15:4] \internal Reserved */
    Ifx_UReg_32Bit EMSF:1;            /**< \brief [16:16] Emergency Stop Flag - EMSF (rh) */
    Ifx_UReg_32Bit SEMSF:1;           /**< \brief [17:17] SMU Emergency Stop Flag - SEMSF (rh) */
    Ifx_UReg_32Bit reserved_18:14;    /**< \brief [31:18] \internal Reserved */
} Ifx_SCU_EMSR_Bits;

/** \brief Emergency Stop Software set and clear register */
typedef struct _Ifx_SCU_EMSSW_Bits
{
    Ifx_UReg_32Bit reserved_0:24;     /**< \brief [23:0] \internal Reserved */
    Ifx_UReg_32Bit EMSFM:2;           /**< \brief [25:24] Emergency Stop Flag Modification - EMSFM (w) */
    Ifx_UReg_32Bit SEMSFM:2;          /**< \brief [27:26] SMU Emergency Stop Flag Modification - SEMSFM (w) */
    Ifx_UReg_32Bit reserved_28:4;     /**< \brief [31:28] \internal Reserved */
} Ifx_SCU_EMSSW_Bits;

/** \brief ESR${x} Input Configuration Register */
typedef struct _Ifx_SCU_ESRCFGX_ESRCFGX_Bits
{
    Ifx_UReg_32Bit reserved_0:7;      /**< \brief [6:0] \internal Reserved */
    Ifx_UReg_32Bit EDCON:2;           /**< \brief [8:7] Edge Detection Control - EDCON (rw) */
    Ifx_UReg_32Bit reserved_9:23;     /**< \brief [31:9] \internal Reserved */
} Ifx_SCU_ESRCFGX_ESRCFGX_Bits;

/** \brief ESR Output Configuration Register */
typedef struct _Ifx_SCU_ESROCFG_Bits
{
    Ifx_UReg_32Bit ARI:1;             /**< \brief [0:0] Application Reset Indicator - ARI (rh) */
    Ifx_UReg_32Bit ARC:1;             /**< \brief [1:1] Application Reset Indicator Clear - ARC (w) */
    Ifx_UReg_32Bit reserved_2:30;     /**< \brief [31:2] \internal Reserved */
} Ifx_SCU_ESROCFG_Bits;

/** \brief External Clock Control Register */
typedef struct _Ifx_SCU_EXTCON_Bits
{
    Ifx_UReg_32Bit EN0:1;             /**< \brief [0:0] External Clock Enable for EXTCLK0 - EN0 (rwh) */
    Ifx_UReg_32Bit reserved_1:1;      /**< \brief [1:1] \internal Reserved */
    Ifx_UReg_32Bit SEL0:4;            /**< \brief [5:2] External Clock Select for EXTCLK0 - SEL0 (rwh) */
    Ifx_UReg_32Bit reserved_6:10;     /**< \brief [15:6] \internal Reserved */
    Ifx_UReg_32Bit EN1:1;             /**< \brief [16:16] External Clock Enable for EXTCLK1 - EN1 (rwh) */
    Ifx_UReg_32Bit NSEL:1;            /**< \brief [17:17] Negation Selection - NSEL (rwh) */
    Ifx_UReg_32Bit SEL1:4;            /**< \brief [21:18] External Clock Select for EXTCLK1 - SEL1 (rwh) */
    Ifx_UReg_32Bit reserved_22:2;     /**< \brief [23:22] \internal Reserved */
    Ifx_UReg_32Bit DIV1:8;            /**< \brief [31:24] External Clock Divider for EXTCLK1 - DIV1 (rw) */
} Ifx_SCU_EXTCON_Bits;

/** \brief Fractional Divider Register */
typedef struct _Ifx_SCU_FDR_Bits
{
    Ifx_UReg_32Bit STEP:10;           /**< \brief [9:0] Step Value - STEP (rw) */
    Ifx_UReg_32Bit reserved_10:4;     /**< \brief [13:10] \internal Reserved */
    Ifx_UReg_32Bit DM:2;              /**< \brief [15:14] Divider Mode - DM (rw) */
    Ifx_UReg_32Bit RESULT:10;         /**< \brief [25:16] Result Value - RESULT (rh) */
    Ifx_UReg_32Bit reserved_26:5;     /**< \brief [30:26] \internal Reserved */
    Ifx_UReg_32Bit DISCLK:1;          /**< \brief [31:31] Disable Clock - DISCLK (rwh) */
} Ifx_SCU_FDR_Bits;

/** \brief Flag Modification Register */
typedef struct _Ifx_SCU_FMR_Bits
{
    Ifx_UReg_32Bit FS0:1;             /**< \brief [0:0] Set Flag INTFx for Channel 0 - FS0 (w) */
    Ifx_UReg_32Bit FS1:1;             /**< \brief [1:1] Set Flag INTFx for Channel 1 - FS1 (w) */
    Ifx_UReg_32Bit FS2:1;             /**< \brief [2:2] Set Flag INTFx for Channel 2 - FS2 (w) */
    Ifx_UReg_32Bit FS3:1;             /**< \brief [3:3] Set Flag INTFx for Channel 3 - FS3 (w) */
    Ifx_UReg_32Bit FS4:1;             /**< \brief [4:4] Set Flag INTFx for Channel 4 - FS4 (w) */
    Ifx_UReg_32Bit FS5:1;             /**< \brief [5:5] Set Flag INTFx for Channel 5 - FS5 (w) */
    Ifx_UReg_32Bit FS6:1;             /**< \brief [6:6] Set Flag INTFx for Channel 6 - FS6 (w) */
    Ifx_UReg_32Bit FS7:1;             /**< \brief [7:7] Set Flag INTFx for Channel 7 - FS7 (w) */
    Ifx_UReg_32Bit reserved_8:8;      /**< \brief [15:8] \internal Reserved */
    Ifx_UReg_32Bit FC0:1;             /**< \brief [16:16] Clear Flag INTFx for Channel 0 - FC0 (w) */
    Ifx_UReg_32Bit FC1:1;             /**< \brief [17:17] Clear Flag INTFx for Channel 1 - FC1 (w) */
    Ifx_UReg_32Bit FC2:1;             /**< \brief [18:18] Clear Flag INTFx for Channel 2 - FC2 (w) */
    Ifx_UReg_32Bit FC3:1;             /**< \brief [19:19] Clear Flag INTFx for Channel 3 - FC3 (w) */
    Ifx_UReg_32Bit FC4:1;             /**< \brief [20:20] Clear Flag INTFx for Channel 4 - FC4 (w) */
    Ifx_UReg_32Bit FC5:1;             /**< \brief [21:21] Clear Flag INTFx for Channel 5 - FC5 (w) */
    Ifx_UReg_32Bit FC6:1;             /**< \brief [22:22] Clear Flag INTFx for Channel 6 - FC6 (w) */
    Ifx_UReg_32Bit FC7:1;             /**< \brief [23:23] Clear Flag INTFx for Channel 7 - FC7 (w) */
    Ifx_UReg_32Bit reserved_24:8;     /**< \brief [31:24] \internal Reserved */
} Ifx_SCU_FMR_Bits;

/** \brief Identification Register */
typedef struct _Ifx_SCU_ID_Bits
{
    Ifx_UReg_32Bit MODREV:8;          /**< \brief [7:0] Module Revision Number - MODREV (r) */
    Ifx_UReg_32Bit MODTYPE:8;         /**< \brief [15:8] Module Type - MODTYPE (r) */
    Ifx_UReg_32Bit MODNUMBER:16;      /**< \brief [31:16] Module Number - MODNUMBER (r) */
} Ifx_SCU_ID_Bits;

/** \brief Flag Gating Register ${j} */
typedef struct _Ifx_SCU_IGCR_Bits
{
    Ifx_UReg_32Bit IPEN00:1;          /**< \brief [0:0] Flag Pattern Enable for Channel 0 - IPEN00 (rw) */
    Ifx_UReg_32Bit IPEN01:1;          /**< \brief [1:1] Flag Pattern Enable for Channel 0 - IPEN01 (rw) */
    Ifx_UReg_32Bit IPEN02:1;          /**< \brief [2:2] Flag Pattern Enable for Channel 0 - IPEN02 (rw) */
    Ifx_UReg_32Bit IPEN03:1;          /**< \brief [3:3] Flag Pattern Enable for Channel 0 - IPEN03 (rw) */
    Ifx_UReg_32Bit IPEN04:1;          /**< \brief [4:4] Flag Pattern Enable for Channel 0 - IPEN04 (rw) */
    Ifx_UReg_32Bit IPEN05:1;          /**< \brief [5:5] Flag Pattern Enable for Channel 0 - IPEN05 (rw) */
    Ifx_UReg_32Bit IPEN06:1;          /**< \brief [6:6] Flag Pattern Enable for Channel 0 - IPEN06 (rw) */
    Ifx_UReg_32Bit IPEN07:1;          /**< \brief [7:7] Flag Pattern Enable for Channel 0 - IPEN07 (rw) */
    Ifx_UReg_32Bit reserved_8:5;      /**< \brief [12:8] \internal Reserved */
    Ifx_UReg_32Bit GEEN0:1;           /**< \brief [13:13] Generate Event Enable 0 - GEEN0 (rw) */
    Ifx_UReg_32Bit IGP0:2;            /**< \brief [15:14] Interrupt Gating Pattern 0 - IGP0 (rw) */
    Ifx_UReg_32Bit IPEN10:1;          /**< \brief [16:16] Interrupt Pattern Enable for Channel 1 - IPEN10 (rw) */
    Ifx_UReg_32Bit IPEN11:1;          /**< \brief [17:17] Interrupt Pattern Enable for Channel 1 - IPEN11 (rw) */
    Ifx_UReg_32Bit IPEN12:1;          /**< \brief [18:18] Interrupt Pattern Enable for Channel 1 - IPEN12 (rw) */
    Ifx_UReg_32Bit IPEN13:1;          /**< \brief [19:19] Interrupt Pattern Enable for Channel 1 - IPEN13 (rw) */
    Ifx_UReg_32Bit IPEN14:1;          /**< \brief [20:20] Interrupt Pattern Enable for Channel 1 - IPEN14 (rw) */
    Ifx_UReg_32Bit IPEN15:1;          /**< \brief [21:21] Interrupt Pattern Enable for Channel 1 - IPEN15 (rw) */
    Ifx_UReg_32Bit IPEN16:1;          /**< \brief [22:22] Interrupt Pattern Enable for Channel 1 - IPEN16 (rw) */
    Ifx_UReg_32Bit IPEN17:1;          /**< \brief [23:23] Interrupt Pattern Enable for Channel 1 - IPEN17 (rw) */
    Ifx_UReg_32Bit reserved_24:5;     /**< \brief [28:24] \internal Reserved */
    Ifx_UReg_32Bit GEEN1:1;           /**< \brief [29:29] Generate Event Enable 1 - GEEN1 (rw) */
    Ifx_UReg_32Bit IGP1:2;            /**< \brief [31:30] Interrupt Gating Pattern 1 - IGP1 (rw) */
} Ifx_SCU_IGCR_Bits;

/** \brief ESR Input Register */
typedef struct _Ifx_SCU_IN_Bits
{
    Ifx_UReg_32Bit P0:1;              /**< \brief [0:0] Input Bit 0 - P0 (rh) */
    Ifx_UReg_32Bit P1:1;              /**< \brief [1:1] Input Bit 1 - P1 (rh) */
    Ifx_UReg_32Bit reserved_2:30;     /**< \brief [31:2] \internal Reserved */
} Ifx_SCU_IN_Bits;

/** \brief Input/Output Control Register */
typedef struct _Ifx_SCU_IOCR_Bits
{
    Ifx_UReg_32Bit reserved_0:4;      /**< \brief [3:0] \internal Reserved */
    Ifx_UReg_32Bit PC0:4;             /**< \brief [7:4] Control for ESR0 Pin - PC0 (rw) */
    Ifx_UReg_32Bit reserved_8:4;      /**< \brief [11:8] \internal Reserved */
    Ifx_UReg_32Bit PC1:4;             /**< \brief [15:12] Control for ESR1 Pin - PC1 (rw) */
    Ifx_UReg_32Bit reserved_16:16;    /**< \brief [31:16] \internal Reserved */
} Ifx_SCU_IOCR_Bits;

/** \brief Logic BIST Control 0 Register */
typedef struct _Ifx_SCU_LBISTCTRL0_Bits
{
    Ifx_UReg_32Bit LBISTREQ:1;        /**< \brief [0:0] LBIST Request - LBISTREQ (w) */
    Ifx_UReg_32Bit LBISTRES:1;        /**< \brief [1:1] LBIST-Reset- LBISTRES (w) */
    Ifx_UReg_32Bit PATTERNS:18;       /**< \brief [19:2] LBIST Pattern Number - PATTERNS (rw) */
    Ifx_UReg_32Bit reserved_20:8;     /**< \brief [27:20] \internal Reserved */
    Ifx_UReg_32Bit LBISTDONE:1;       /**< \brief [28:28] LBIST Execution Indicator - LBISTDONE (rh) */
    Ifx_UReg_32Bit reserved_29:1;     /**< \brief [29:29] \internal Reserved */
    Ifx_UReg_32Bit LBISTERRINJ:1;     /**< \brief [30:30] LBIST / Test-Mode Alarm Error Injection (rwh) */
    Ifx_UReg_32Bit LBISTREQRED:1;     /**< \brief [31:31] LBIST Request Redundancy (rw) */
} Ifx_SCU_LBISTCTRL0_Bits;

/** \brief Logic BIST Control 1 Register */
typedef struct _Ifx_SCU_LBISTCTRL1_Bits
{
    Ifx_UReg_32Bit SEED:19;           /**< \brief [18:0] LBIST Seed - SEED (rw) */
    Ifx_UReg_32Bit reserved_19:5;     /**< \brief [23:19] \internal Reserved */
    Ifx_UReg_32Bit SPLITSH:3;         /**< \brief [26:24] LBIST Split-Shift Selection - SPLITSH (rw) */
    Ifx_UReg_32Bit BODY:1;            /**< \brief [27:27] Body Application Indicator - BODY (rw) */
    Ifx_UReg_32Bit LBISTFREQU:4;      /**< \brief [31:28] LBIST Frequency Selection - LBISTFREQU (rw) */
} Ifx_SCU_LBISTCTRL1_Bits;

/** \brief Logic BIST Control 2 Register */
typedef struct _Ifx_SCU_LBISTCTRL2_Bits
{
    Ifx_UReg_32Bit LENGTH:12;         /**< \brief [11:0] LBIST Maximum Scan-Chain Length - LENGTH (rwh) */
    Ifx_UReg_32Bit reserved_12:20;    /**< \brief [31:12] \internal Reserved */
} Ifx_SCU_LBISTCTRL2_Bits;

/** \brief Logic BIST Control 3 Register */
typedef struct _Ifx_SCU_LBISTCTRL3_Bits
{
    Ifx_UReg_32Bit SIGNATURE:32;      /**< \brief [31:0] LBIST Signature - SIGNATURE (rh) */
} Ifx_SCU_LBISTCTRL3_Bits;

/** \brief LCL CPU0 and CPU2 Control Register */
typedef struct _Ifx_SCU_LCLCON0_Bits
{
    Ifx_UReg_32Bit reserved_0:1;      /**< \brief [0:0] \internal Reserved */
    Ifx_UReg_32Bit reserved_1:14;     /**< \brief [14:1] \internal Reserved */
    Ifx_UReg_32Bit reserved_15:1;     /**< \brief [15:15] \internal Reserved */
    Ifx_UReg_32Bit LS0:1;             /**< \brief [16:16] Lockstep Mode Status - LS0 (rh) */
    Ifx_UReg_32Bit reserved_17:14;    /**< \brief [30:17] \internal Reserved */
    Ifx_UReg_32Bit LSEN0:1;           /**< \brief [31:31] Lockstep Enable - LSEN0 (rw) */
} Ifx_SCU_LCLCON0_Bits;

/** \brief LCL CPU1 and CPU3 Control Register */
typedef struct _Ifx_SCU_LCLCON1_Bits
{
    Ifx_UReg_32Bit reserved_0:1;      /**< \brief [0:0] \internal Reserved */
    Ifx_UReg_32Bit reserved_1:14;     /**< \brief [14:1] \internal Reserved */
    Ifx_UReg_32Bit reserved_15:1;     /**< \brief [15:15] \internal Reserved */
    Ifx_UReg_32Bit LS1:1;             /**< \brief [16:16] Lockstep Mode Status - LS1 (rh) */
    Ifx_UReg_32Bit reserved_17:14;    /**< \brief [30:17] \internal Reserved */
    Ifx_UReg_32Bit LSEN1:1;           /**< \brief [31:31] Lockstep Enable - LSEN1 (rw) */
} Ifx_SCU_LCLCON1_Bits;

/** \brief LCL Test Register */
typedef struct _Ifx_SCU_LCLTEST_Bits
{
    Ifx_UReg_32Bit LCLT0:1;           /**< \brief [0:0] LCL0 Lockstep Test - LCLT0 (w) */
    Ifx_UReg_32Bit LCLT1:1;           /**< \brief [1:1] LCL1 Lockstep Test - LCLT1 (w) */
    Ifx_UReg_32Bit LCLT2:1;           /**< \brief [2:2] LCL2 Lockstep Test - LCLT2 (w) */
    Ifx_UReg_32Bit LCLT3:1;           /**< \brief [3:3] LCL3 Lockstep Test - LCLT3 (w) */
    Ifx_UReg_32Bit reserved_4:1;      /**< \brief [4:4] \internal Reserved */
    Ifx_UReg_32Bit reserved_5:1;      /**< \brief [5:5] \internal Reserved */
    Ifx_UReg_32Bit reserved_6:10;     /**< \brief [15:6] \internal Reserved */
    Ifx_UReg_32Bit PLCLT0:1;          /**< \brief [16:16] PFI0 Lockstep Test (w) */
    Ifx_UReg_32Bit PLCLT1:1;          /**< \brief [17:17] PFI1 Lockstep Test (w) */
    Ifx_UReg_32Bit PLCLT2:1;          /**< \brief [18:18] PFI2 Lockstep Test (w) */
    Ifx_UReg_32Bit PLCLT3:1;          /**< \brief [19:19] PFI3 Lockstep Test (w) */
    Ifx_UReg_32Bit reserved_20:1;     /**< \brief [20:20] \internal Reserved */
    Ifx_UReg_32Bit reserved_21:1;     /**< \brief [21:21] \internal Reserved */
    Ifx_UReg_32Bit reserved_22:10;    /**< \brief [31:22] \internal Reserved */
} Ifx_SCU_LCLTEST_Bits;

/** \brief Manufacturer Identification Register */
typedef struct _Ifx_SCU_MANID_Bits
{
    Ifx_UReg_32Bit DEPT:5;            /**< \brief [4:0] Department Identification Number - DEPT (r) */
    Ifx_UReg_32Bit MANUF:11;          /**< \brief [15:5] Manufacturer Identification Number - MANUF (r) */
    Ifx_UReg_32Bit reserved_16:16;    /**< \brief [31:16] \internal Reserved */
} Ifx_SCU_MANID_Bits;

/** \brief ESR Output Modification Register */
typedef struct _Ifx_SCU_OMR_Bits
{
    Ifx_UReg_32Bit PS0:1;             /**< \brief [0:0] ESRx Pin Set Bit 0 - PS0 (w) */
    Ifx_UReg_32Bit PS1:1;             /**< \brief [1:1] ESRx Pin Set Bit 1 - PS1 (w) */
    Ifx_UReg_32Bit reserved_2:14;     /**< \brief [15:2] \internal Reserved */
    Ifx_UReg_32Bit PCL0:1;            /**< \brief [16:16] ESRx Pin Clear Bit 0 - PCL0 (w) */
    Ifx_UReg_32Bit PCL1:1;            /**< \brief [17:17] ESRx Pin Clear Bit 1 - PCL1 (w) */
    Ifx_UReg_32Bit reserved_18:14;    /**< \brief [31:18] \internal Reserved */
} Ifx_SCU_OMR_Bits;

/** \brief OSC Control Register */
typedef struct _Ifx_SCU_OSCCON_Bits
{
    Ifx_UReg_32Bit reserved_0:1;      /**< \brief [0:0] \internal Reserved */
    Ifx_UReg_32Bit PLLLV:1;           /**< \brief [1:1] Oscillator for PLL Valid Low Status Bit - PLLLV (rh) */
    Ifx_UReg_32Bit OSCRES:1;          /**< \brief [2:2] Oscillator Watchdog Reset - OSCRES (w) */
    Ifx_UReg_32Bit GAINSEL:2;         /**< \brief [4:3] Oscillator Gain Selection - GAINSEL (rw) */
    Ifx_UReg_32Bit MODE:2;            /**< \brief [6:5] Oscillator Mode - MODE (rw) */
    Ifx_UReg_32Bit SHBY:1;            /**< \brief [7:7] Shaper Bypass - SHBY (rw) */
    Ifx_UReg_32Bit PLLHV:1;           /**< \brief [8:8] Oscillator for PLL Valid High Status Bit - PLLHV (rh) */
    Ifx_UReg_32Bit HYSEN:1;           /**< \brief [9:9] Hysteresis Enable (rw) */
    Ifx_UReg_32Bit HYSCTL:2;          /**< \brief [11:10] Hysteresis Control (rw) */
    Ifx_UReg_32Bit AMPCTL:2;          /**< \brief [13:12] Amplitude Control (rw) */
    Ifx_UReg_32Bit reserved_14:2;     /**< \brief [15:14] \internal Reserved */
    Ifx_UReg_32Bit OSCVAL:5;          /**< \brief [20:16] OSC Frequency Value - OSCVAL (rw) */
    Ifx_UReg_32Bit reserved_21:2;     /**< \brief [22:21] \internal Reserved */
    Ifx_UReg_32Bit APREN:1;           /**< \brief [23:23] Amplitude Regulation Enable - APREN (rw) */
    Ifx_UReg_32Bit CAP0EN:1;          /**< \brief [24:24] Capacitance 0 Enable - CAP0EN (rw) */
    Ifx_UReg_32Bit CAP1EN:1;          /**< \brief [25:25] Capacitance 1 Enable - CAP1EN (rw) */
    Ifx_UReg_32Bit CAP2EN:1;          /**< \brief [26:26] Capacitance 2 Enable - CAP2EN (rw) */
    Ifx_UReg_32Bit CAP3EN:1;          /**< \brief [27:27] Capacitance 3 Enable - CAP3EN (rw) */
    Ifx_UReg_32Bit reserved_28:4;     /**< \brief [31:28] \internal Reserved */
} Ifx_SCU_OSCCON_Bits;

/** \brief ESR Output Register */
typedef struct _Ifx_SCU_OUT_Bits
{
    Ifx_UReg_32Bit P0:1;              /**< \brief [0:0] Output Bit 0 - P0 (rwh) */
    Ifx_UReg_32Bit P1:1;              /**< \brief [1:1] Output Bit 1 - P1 (rwh) */
    Ifx_UReg_32Bit reserved_2:30;     /**< \brief [31:2] \internal Reserved */
} Ifx_SCU_OUT_Bits;

/** \brief Overlay Control Register */
typedef struct _Ifx_SCU_OVCCON_Bits
{
    Ifx_UReg_32Bit CSEL0:1;           /**< \brief [0:0] CPU Select 0 - CSEL0 (w) */
    Ifx_UReg_32Bit CSEL1:1;           /**< \brief [1:1] CPU Select 1 (If product has CPU1) - CSEL1 (w) */
    Ifx_UReg_32Bit CSEL2:1;           /**< \brief [2:2] CPU Select 2 (If product has CPU2) - CSEL2 (w) */
    Ifx_UReg_32Bit CSEL3:1;           /**< \brief [3:3] CPU Select 3 (If product has CPU3) - CSEL3 (w) */
    Ifx_UReg_32Bit reserved_4:1;      /**< \brief [4:4] \internal Reserved */
    Ifx_UReg_32Bit reserved_5:1;      /**< \brief [5:5] \internal Reserved */
    Ifx_UReg_32Bit reserved_6:10;     /**< \brief [15:6] \internal Reserved */
    Ifx_UReg_32Bit OVSTRT:1;          /**< \brief [16:16] Overlay Start - OVSTRT (w) */
    Ifx_UReg_32Bit OVSTP:1;           /**< \brief [17:17] Overlay Stop - OVSTP (w) */
    Ifx_UReg_32Bit DCINVAL:1;         /**< \brief [18:18] Data Cache Invalidate - DCINVAL (w) */
    Ifx_UReg_32Bit reserved_19:5;     /**< \brief [23:19] \internal Reserved */
    Ifx_UReg_32Bit OVCONF:1;          /**< \brief [24:24] Overlay Configured - OVCONF (rw) */
    Ifx_UReg_32Bit POVCONF:1;         /**< \brief [25:25] Write Protection for OVCONF - POVCONF (w) */
    Ifx_UReg_32Bit reserved_26:6;     /**< \brief [31:26] \internal Reserved */
} Ifx_SCU_OVCCON_Bits;

/** \brief Overlay Enable Register */
typedef struct _Ifx_SCU_OVCENABLE_Bits
{
    Ifx_UReg_32Bit OVEN0:1;           /**< \brief [0:0] Overlay Enable 0 - OVEN0 (rw) */
    Ifx_UReg_32Bit OVEN1:1;           /**< \brief [1:1] Overlay Enable 1 (If product has CPU1) - OVEN1 (rw) */
    Ifx_UReg_32Bit OVEN2:1;           /**< \brief [2:2] Overlay Enable 2 (If product has CPU2) - OVEN2 (rw) */
    Ifx_UReg_32Bit OVEN3:1;           /**< \brief [3:3] Overlay Enable 3 (If product has CPU3) - OVEN3 (rw) */
    Ifx_UReg_32Bit reserved_4:1;      /**< \brief [4:4] \internal Reserved */
    Ifx_UReg_32Bit reserved_5:1;      /**< \brief [5:5] \internal Reserved */
    Ifx_UReg_32Bit reserved_6:26;     /**< \brief [31:6] \internal Reserved */
} Ifx_SCU_OVCENABLE_Bits;

/** \brief Pad Disable Control Register */
typedef struct _Ifx_SCU_PDISC_Bits
{
    Ifx_UReg_32Bit PDIS0:1;           /**< \brief [0:0] Pad Disable for ESR Pin 0 - PDIS0 (rw) */
    Ifx_UReg_32Bit PDIS1:1;           /**< \brief [1:1] Pad Disable for ESR Pin 1 - PDIS1 (rw) */
    Ifx_UReg_32Bit reserved_2:30;     /**< \brief [31:2] \internal Reserved */
} Ifx_SCU_PDISC_Bits;

/** \brief ESR Pad Driver Mode Register */
typedef struct _Ifx_SCU_PDR_Bits
{
    Ifx_UReg_32Bit PD0:2;             /**< \brief [1:0] Pad Driver Mode for ESR Pins 0 - PD0 (rw) */
    Ifx_UReg_32Bit PL0:2;             /**< \brief [3:2] Pad Level Selection for ESR Pins 0 - PL0 (rw) */
    Ifx_UReg_32Bit PD1:2;             /**< \brief [5:4] Pad Driver Mode for ESR Pins 1 - PD1 (rw) */
    Ifx_UReg_32Bit PL1:2;             /**< \brief [7:6] Pad Level Selection for ESR Pins 1 - PL1 (rw) */
    Ifx_UReg_32Bit reserved_8:24;     /**< \brief [31:8] \internal Reserved */
} Ifx_SCU_PDR_Bits;

/** \brief Pattern Detection Result Register */
typedef struct _Ifx_SCU_PDRR_Bits
{
    Ifx_UReg_32Bit PDR0:1;            /**< \brief [0:0] Pattern Detection Result of Channel 0 - PDR0 (rh) */
    Ifx_UReg_32Bit PDR1:1;            /**< \brief [1:1] Pattern Detection Result of Channel 1 - PDR1 (rh) */
    Ifx_UReg_32Bit PDR2:1;            /**< \brief [2:2] Pattern Detection Result of Channel 2 - PDR2 (rh) */
    Ifx_UReg_32Bit PDR3:1;            /**< \brief [3:3] Pattern Detection Result of Channel 3 - PDR3 (rh) */
    Ifx_UReg_32Bit PDR4:1;            /**< \brief [4:4] Pattern Detection Result of Channel 4 - PDR4 (rh) */
    Ifx_UReg_32Bit PDR5:1;            /**< \brief [5:5] Pattern Detection Result of Channel 5 - PDR5 (rh) */
    Ifx_UReg_32Bit PDR6:1;            /**< \brief [6:6] Pattern Detection Result of Channel 6 - PDR6 (rh) */
    Ifx_UReg_32Bit PDR7:1;            /**< \brief [7:7] Pattern Detection Result of Channel 7 - PDR7 (rh) */
    Ifx_UReg_32Bit reserved_8:24;     /**< \brief [31:8] \internal Reserved */
} Ifx_SCU_PDRR_Bits;

/** \brief Peripheral PLL Configuration 0 Register */
typedef struct _Ifx_SCU_PERPLLCON0_Bits
{
    Ifx_UReg_32Bit DIVBY:1;           /**< \brief [0:0] Divider Bypass - DIVBY (rw) */
    Ifx_UReg_32Bit reserved_1:8;      /**< \brief [8:1] \internal Reserved */
    Ifx_UReg_32Bit NDIV:7;            /**< \brief [15:9] N-Divider Value - NDIV (rw) */
    Ifx_UReg_32Bit PLLPWD:1;          /**< \brief [16:16] Peripheral PLL Power Saving Mode - PLLPWD (rw) */
    Ifx_UReg_32Bit reserved_17:1;     /**< \brief [17:17] \internal Reserved */
    Ifx_UReg_32Bit RESLD:1;           /**< \brief [18:18] Restart DCO Lock Detection - RESLD (w) */
    Ifx_UReg_32Bit reserved_19:5;     /**< \brief [23:19] \internal Reserved */
    Ifx_UReg_32Bit PDIV:3;            /**< \brief [26:24] P-Divider Value - PDIV (rw) */
    Ifx_UReg_32Bit reserved_27:5;     /**< \brief [31:27] \internal Reserved */
} Ifx_SCU_PERPLLCON0_Bits;

/** \brief Peripheral PLL Configuration 1 Register */
typedef struct _Ifx_SCU_PERPLLCON1_Bits
{
    Ifx_UReg_32Bit K2DIV:3;           /**< \brief [2:0] K2-Divider Value - K2DIV (rw) */
    Ifx_UReg_32Bit reserved_3:5;      /**< \brief [7:3] \internal Reserved */
    Ifx_UReg_32Bit K3DIV:3;           /**< \brief [10:8] K3-Divider Value - K3DIV (rw) */
    Ifx_UReg_32Bit reserved_11:21;    /**< \brief [31:11] \internal Reserved */
} Ifx_SCU_PERPLLCON1_Bits;

/** \brief Peripheral PLL Status Register */
typedef struct _Ifx_SCU_PERPLLSTAT_Bits
{
    Ifx_UReg_32Bit reserved_0:1;      /**< \brief [0:0] \internal Reserved */
    Ifx_UReg_32Bit PWDSTAT:1;         /**< \brief [1:1] Peripheral PLL Power-saving Mode Status - PWDSTAT (rh) */
    Ifx_UReg_32Bit LOCK:1;            /**< \brief [2:2] Peripheral PLL Lock Status - LOCK (rh) */
    Ifx_UReg_32Bit reserved_3:1;      /**< \brief [3:3] \internal Reserved */
    Ifx_UReg_32Bit K3RDY:1;           /**< \brief [4:4] K3 Divider Ready Status - K3RDY (rh) */
    Ifx_UReg_32Bit K2RDY:1;           /**< \brief [5:5] K2 Divider Ready Status - K2RDY (rh) */
    Ifx_UReg_32Bit reserved_6:1;      /**< \brief [6:6] \internal Reserved */
    Ifx_UReg_32Bit reserved_7:25;     /**< \brief [31:7] \internal Reserved */
} Ifx_SCU_PERPLLSTAT_Bits;

/** \brief Power Management Control and Status Register */
typedef struct _Ifx_SCU_PMCSR0_Bits
{
    Ifx_UReg_32Bit REQSLP:2;          /**< \brief [1:0] Idle Mode and Sleep Mode Request - REQSLP (rwh) */
    Ifx_UReg_32Bit reserved_2:6;      /**< \brief [7:2] \internal Reserved */
    Ifx_UReg_32Bit PMST:3;            /**< \brief [10:8] Power management Status - PMST (rh) */
    Ifx_UReg_32Bit reserved_11:21;    /**< \brief [31:11] \internal Reserved */
} Ifx_SCU_PMCSR0_Bits;

/** \brief Power Management Control and Status Register */
typedef struct _Ifx_SCU_PMCSR1_Bits
{
    Ifx_UReg_32Bit REQSLP:2;          /**< \brief [1:0] Idle Mode and Sleep Mode Request - REQSLP (rwh) */
    Ifx_UReg_32Bit reserved_2:6;      /**< \brief [7:2] \internal Reserved */
    Ifx_UReg_32Bit PMST:3;            /**< \brief [10:8] Power management Status - PMST (rh) */
    Ifx_UReg_32Bit reserved_11:21;    /**< \brief [31:11] \internal Reserved */
} Ifx_SCU_PMCSR1_Bits;

/** \brief Power Management Control and Status Register */
typedef struct _Ifx_SCU_PMCSR2_Bits
{
    Ifx_UReg_32Bit REQSLP:2;          /**< \brief [1:0] Idle Mode and Sleep Mode Request - REQSLP (rwh) */
    Ifx_UReg_32Bit reserved_2:6;      /**< \brief [7:2] \internal Reserved */
    Ifx_UReg_32Bit PMST:3;            /**< \brief [10:8] Power management Status - PMST (rh) */
    Ifx_UReg_32Bit reserved_11:21;    /**< \brief [31:11] \internal Reserved */
} Ifx_SCU_PMCSR2_Bits;

/** \brief Power Management Control and Status Register */
typedef struct _Ifx_SCU_PMCSR3_Bits
{
    Ifx_UReg_32Bit REQSLP:2;          /**< \brief [1:0] Idle Mode and Sleep Mode Request - REQSLP (rwh) */
    Ifx_UReg_32Bit reserved_2:6;      /**< \brief [7:2] \internal Reserved */
    Ifx_UReg_32Bit PMST:3;            /**< \brief [10:8] Power management Status - PMST (rh) */
    Ifx_UReg_32Bit reserved_11:21;    /**< \brief [31:11] \internal Reserved */
} Ifx_SCU_PMCSR3_Bits;

/** \brief Power Management Control and Status Register */
typedef struct _Ifx_SCU_PMCSR4_Bits
{
    Ifx_UReg_32Bit REQSLP:2;          /**< \brief [1:0] Idle Mode and Sleep Mode Request - REQSLP (rwh) */
    Ifx_UReg_32Bit reserved_2:6;      /**< \brief [7:2] \internal Reserved */
    Ifx_UReg_32Bit PMST:3;            /**< \brief [10:8] Power management Status - PMST (rh) */
    Ifx_UReg_32Bit reserved_11:21;    /**< \brief [31:11] \internal Reserved */
} Ifx_SCU_PMCSR4_Bits;

/** \brief Power Management Control and Status Register */
typedef struct _Ifx_SCU_PMCSR5_Bits
{
    Ifx_UReg_32Bit REQSLP:2;          /**< \brief [1:0] Idle Mode and Sleep Mode Request - REQSLP (rwh) */
    Ifx_UReg_32Bit reserved_2:6;      /**< \brief [7:2] \internal Reserved */
    Ifx_UReg_32Bit PMST:3;            /**< \brief [10:8] Power management Status - PMST (rh) */
    Ifx_UReg_32Bit reserved_11:21;    /**< \brief [31:11] \internal Reserved */
} Ifx_SCU_PMCSR5_Bits;

/** \brief Power Management Status Register 0 */
typedef struct _Ifx_SCU_PMSTAT0_Bits
{
    Ifx_UReg_32Bit CPU0:1;            /**< \brief [0:0] CPU0 Status - CPU0 (rh) */
    Ifx_UReg_32Bit CPU1:1;            /**< \brief [1:1] CPU1 Status - CPU1 (rh) */
    Ifx_UReg_32Bit CPU2:1;            /**< \brief [2:2] CPU2 Status - CPU2 (rh) */
    Ifx_UReg_32Bit CPU3:1;            /**< \brief [3:3] CPU3 Status - CPU3 (rh) */
    Ifx_UReg_32Bit CPU4:1;            /**< \brief [4:4] CPU4 Status - CPU4 (rh) */
    Ifx_UReg_32Bit CPU5:1;            /**< \brief [5:5] CPU5 Status - CPU5 (rh) */
    Ifx_UReg_32Bit reserved_6:10;     /**< \brief [15:6] \internal Reserved */
    Ifx_UReg_32Bit CPU0LS:1;          /**< \brief [16:16] CPU0LS Status - CPU0LS (rh) */
    Ifx_UReg_32Bit CPU1LS:1;          /**< \brief [17:17] CPU1LS Status - CPU1LS (rh) */
    Ifx_UReg_32Bit CPU2LS:1;          /**< \brief [18:18] CPU2LS Status - CPU2LS (rh) */
    Ifx_UReg_32Bit CPU3LS:1;          /**< \brief [19:19] CPU3LS Status - CPU3LS (rh) */
    Ifx_UReg_32Bit reserved_20:12;    /**< \brief [31:20] \internal Reserved */
} Ifx_SCU_PMSTAT0_Bits;

/** \brief Standby and Wake-up Control Register 1 */
typedef struct _Ifx_SCU_PMSWCR1_Bits
{
    Ifx_UReg_32Bit reserved_0:8;      /**< \brief [7:0] \internal Reserved */
    Ifx_UReg_32Bit CPUIDLSEL:3;       /**< \brief [10:8] CPU selection for Idle mode - CPUIDLSEL (rw) */
    Ifx_UReg_32Bit reserved_11:1;     /**< \brief [11:11] \internal Reserved */
    Ifx_UReg_32Bit IRADIS:1;          /**< \brief [12:12] Idle-Request-Acknowledge Sequence Disable - IRADIS (rw) */
    Ifx_UReg_32Bit reserved_13:11;    /**< \brief [23:13] \internal Reserved */
    Ifx_UReg_32Bit CPUSEL:3;          /**< \brief [26:24] CPU selection for Sleep and Standby mode - CPUSEL (rw) */
    Ifx_UReg_32Bit STBYEVEN:1;        /**< \brief [27:27] Standby Entry Event configuration enable - STBYEVEN (w) */
    Ifx_UReg_32Bit STBYEV:3;          /**< \brief [30:28] Standby Entry Event Configuration - STBYEV (rw) */
    Ifx_UReg_32Bit reserved_31:1;     /**< \brief [31:31] \internal Reserved */
} Ifx_SCU_PMSWCR1_Bits;

/** \brief Power Management Transition Control and Status Register 0 */
typedef struct _Ifx_SCU_PMTRCSR0_Bits
{
    Ifx_UReg_32Bit LJTEN:1;           /**< \brief [0:0] Load Jump Timer Enable - LJTEN (rw) */
    Ifx_UReg_32Bit LJTOVEN:1;         /**< \brief [1:1] Load Jump Timer Overflow Enable - LJTOVEN (rw) */
    Ifx_UReg_32Bit LJTOVIEN:1;        /**< \brief [2:2] Load Jump Timer Overflow Interrupt Enable - LJTOVIEN (rw) */
    Ifx_UReg_32Bit LJTSTRT:1;         /**< \brief [3:3] Load Jump Timer Start - LJTSTRT (rwh) */
    Ifx_UReg_32Bit LJTSTP:1;          /**< \brief [4:4] Load Jump Timer Stop - LJTSTP (rw) */
    Ifx_UReg_32Bit LJTCLR:1;          /**< \brief [5:5] Load Jump Timer Clear - LJTCLR (w) */
    Ifx_UReg_32Bit reserved_6:6;      /**< \brief [11:6] \internal Reserved */
    Ifx_UReg_32Bit SDSTEP:4;          /**< \brief [15:12] Droop Voltage Step(vdroop_step_i) - SDSTEP (rw) */
    Ifx_UReg_32Bit VDTEN:1;           /**< \brief [16:16] Voltage Droop Timer Enable - VDTEN (rw) */
    Ifx_UReg_32Bit VDTOVEN:1;         /**< \brief [17:17] Voltage Droop Timer Overflow Enable - VDTOVEN (rw) */
    Ifx_UReg_32Bit VDTOVIEN:1;        /**< \brief [18:18] Voltage Droop Timer Overflow Interrupt Enable - VDTOVIEN (rw) */
    Ifx_UReg_32Bit VDTSTRT:1;         /**< \brief [19:19] Voltage Droop Timer Start - VDTSTRT (rwh) */
    Ifx_UReg_32Bit VDTSTP:1;          /**< \brief [20:20] Voltage Droop Timer Stop - VDTSTP (rw) */
    Ifx_UReg_32Bit VDTCLR:1;          /**< \brief [21:21] Voltage Droop Timer Clear - VDTCLR (w) */
    Ifx_UReg_32Bit reserved_22:7;     /**< \brief [28:22] \internal Reserved */
    Ifx_UReg_32Bit LPSLPEN:1;         /**< \brief [29:29] EVRC Low Power Mode activation on a Sleep Request - LPSLPEN (rw) */
    Ifx_UReg_32Bit reserved_30:2;     /**< \brief [31:30] \internal Reserved */
} Ifx_SCU_PMTRCSR0_Bits;

/** \brief Power Management Transition Control and Status Register 1 */
typedef struct _Ifx_SCU_PMTRCSR1_Bits
{
    Ifx_UReg_32Bit LJTCV:16;          /**< \brief [15:0] Load Jump Timer Compare Setpoint Value - LJTCV (rw) */
    Ifx_UReg_32Bit VDTCV:10;          /**< \brief [25:16] Voltage Droop Timer Compare Setpoint Value - VDTCV (rw) */
    Ifx_UReg_32Bit reserved_26:6;     /**< \brief [31:26] \internal Reserved */
} Ifx_SCU_PMTRCSR1_Bits;

/** \brief Power Management Transition Control and Status Register 2 */
typedef struct _Ifx_SCU_PMTRCSR2_Bits
{
    Ifx_UReg_32Bit LDJMPREQ:2;        /**< \brief [1:0] Load Jump Request - LDJMPREQ (rwh) */
    Ifx_UReg_32Bit reserved_2:2;      /**< \brief [3:2] \internal Reserved */
    Ifx_UReg_32Bit LJTRUN:2;          /**< \brief [5:4] Load Jump Timer Run Status - LJTRUN (rh) */
    Ifx_UReg_32Bit reserved_6:2;      /**< \brief [7:6] \internal Reserved */
    Ifx_UReg_32Bit LJTOV:1;           /**< \brief [8:8] Load Jump Timer Overflow Status - LJTOV (rh) */
    Ifx_UReg_32Bit reserved_9:3;      /**< \brief [11:9] \internal Reserved */
    Ifx_UReg_32Bit LJTOVCLR:1;        /**< \brief [12:12] Load Jump Timer Overflow Status Clear - LJTOVCLR (w) */
    Ifx_UReg_32Bit reserved_13:3;     /**< \brief [15:13] \internal Reserved */
    Ifx_UReg_32Bit LJTCNT:16;         /**< \brief [31:16] Load Jump Timer Value - LJTCNT (rh) */
} Ifx_SCU_PMTRCSR2_Bits;

/** \brief Power Management Transition Control and Status Register 3 */
typedef struct _Ifx_SCU_PMTRCSR3_Bits
{
    Ifx_UReg_32Bit VDROOPREQ:2;       /**< \brief [1:0] Voltage Droop Request - VDROOPREQ (rwh) */
    Ifx_UReg_32Bit reserved_2:2;      /**< \brief [3:2] \internal Reserved */
    Ifx_UReg_32Bit VDTRUN:2;          /**< \brief [5:4] Voltage Droop Timer Run Status - VDTRUN (rh) */
    Ifx_UReg_32Bit reserved_6:2;      /**< \brief [7:6] \internal Reserved */
    Ifx_UReg_32Bit VDTOV:1;           /**< \brief [8:8] Voltage Droop Timer Overflow Status - VDTOV (rh) */
    Ifx_UReg_32Bit reserved_9:3;      /**< \brief [11:9] \internal Reserved */
    Ifx_UReg_32Bit VDTOVCLR:1;        /**< \brief [12:12] Voltage Droop Timer Overflow Status Clear - VDTOVCLR (w) */
    Ifx_UReg_32Bit reserved_13:3;     /**< \brief [15:13] \internal Reserved */
    Ifx_UReg_32Bit VDTCNT:10;         /**< \brief [25:16] Voltage Droop Timer Value - VDTCNT (rh) */
    Ifx_UReg_32Bit reserved_26:6;     /**< \brief [31:26] \internal Reserved */
} Ifx_SCU_PMTRCSR3_Bits;

/** \brief Reset Configuration Register */
typedef struct _Ifx_SCU_RSTCON_Bits
{
    Ifx_UReg_32Bit ESR0:2;            /**< \brief [1:0] ESR0 Reset Request Trigger Reset Configuration - ESR0 (rw) */
    Ifx_UReg_32Bit ESR1:2;            /**< \brief [3:2] ESR1 Reset Request Trigger Reset Configuration - ESR1 (rw) */
    Ifx_UReg_32Bit reserved_4:2;      /**< \brief [5:4] \internal Reserved */
    Ifx_UReg_32Bit SMU:2;             /**< \brief [7:6] SMU Reset Request Trigger Reset Configuration - SMU (rw) */
    Ifx_UReg_32Bit SW:2;              /**< \brief [9:8] SW Reset Request Trigger Reset Configuration - SW (rw) */
    Ifx_UReg_32Bit STM0:2;            /**< \brief [11:10] STM0 Reset Request Trigger Reset Configuration - STM0 (rw) */
    Ifx_UReg_32Bit STM1:2;            /**< \brief [13:12] STM1 Reset Request Trigger Reset Configuration (If Product has STM1) - STM1 (rw) */
    Ifx_UReg_32Bit STM2:2;            /**< \brief [15:14] STM2 Reset Request Trigger Reset Configuration (If Product has STM2) - STM2 (rw) */
    Ifx_UReg_32Bit STM3:2;            /**< \brief [17:16] STM3 Reset Request Trigger Reset Configuration (If Product has STM3) - STM3 (rw) */
    Ifx_UReg_32Bit reserved_18:2;     /**< \brief [19:18] \internal Reserved */
    Ifx_UReg_32Bit reserved_20:2;     /**< \brief [21:20] \internal Reserved */
    Ifx_UReg_32Bit reserved_22:10;    /**< \brief [31:22] \internal Reserved */
} Ifx_SCU_RSTCON_Bits;

/** \brief Additional Reset Control Register */
typedef struct _Ifx_SCU_RSTCON2_Bits
{
    Ifx_UReg_32Bit FRTO:1;            /**< \brief [0:0] Force Reset Timeout - FRTO (rw) */
    Ifx_UReg_32Bit CLRC:1;            /**< \brief [1:1] Clear Cold Reset Status - CLRC (w) */
    Ifx_UReg_32Bit reserved_2:1;      /**< \brief [2:2] \internal Reserved */
    Ifx_UReg_32Bit reserved_3:1;      /**< \brief [3:3] \internal Reserved */
    Ifx_UReg_32Bit reserved_4:1;      /**< \brief [4:4] \internal Reserved */
    Ifx_UReg_32Bit reserved_5:1;      /**< \brief [5:5] \internal Reserved */
    Ifx_UReg_32Bit reserved_6:1;      /**< \brief [6:6] \internal Reserved */
    Ifx_UReg_32Bit CSSX:6;            /**< \brief [12:7] CPU x Shutdown State Reached - CSSx (rh) */
    Ifx_UReg_32Bit reserved_13:1;     /**< \brief [13:13] \internal Reserved */
    Ifx_UReg_32Bit reserved_14:1;     /**< \brief [14:14] \internal Reserved */
    Ifx_UReg_32Bit reserved_15:1;     /**< \brief [15:15] \internal Reserved */
    Ifx_UReg_32Bit USRINFO:16;        /**< \brief [31:16] User Information - USRINFO (rw) */
} Ifx_SCU_RSTCON2_Bits;

/** \brief Reset Configuration Register 3 */
typedef struct _Ifx_SCU_RSTCON3_Bits
{
    Ifx_UReg_32Bit reserved_0:32;     /**< \brief [31:0] \internal Reserved */
} Ifx_SCU_RSTCON3_Bits;

/** \brief Reset Status Register */
typedef struct _Ifx_SCU_RSTSTAT_Bits
{
    Ifx_UReg_32Bit ESR0:1;            /**< \brief [0:0] Reset Request Trigger Reset Status for ESR0 - ESR0 (rh) */
    Ifx_UReg_32Bit ESR1:1;            /**< \brief [1:1] Reset Request Trigger Reset Status for ESR1 - ESR1 (rh) */
    Ifx_UReg_32Bit reserved_2:1;      /**< \brief [2:2] \internal Reserved */
    Ifx_UReg_32Bit SMU:1;             /**< \brief [3:3] Reset Request Trigger Reset Status for SMU - SMU (rh) */
    Ifx_UReg_32Bit SW:1;              /**< \brief [4:4] Reset Request Trigger Reset Status for SW - SW (rh) */
    Ifx_UReg_32Bit STM0:1;            /**< \brief [5:5] Reset Request Trigger Reset Status for STM0 Compare Match - STM0 (rh) */
    Ifx_UReg_32Bit STM1:1;            /**< \brief [6:6] Reset Request Trigger Reset Status for STM1 Compare Match (If Product has STM1) - STM1 (rh) */
    Ifx_UReg_32Bit STM2:1;            /**< \brief [7:7] Reset Request Trigger Reset Status for STM2 Compare Match (If Product has STM2) - STM2 (rh) */
    Ifx_UReg_32Bit STM3:1;            /**< \brief [8:8] Reset Request Trigger Reset Status for STM3 Compare Match (If Product has STM3) - STM3 (rh) */
    Ifx_UReg_32Bit reserved_9:1;      /**< \brief [9:9] \internal Reserved */
    Ifx_UReg_32Bit reserved_10:1;     /**< \brief [10:10] \internal Reserved */
    Ifx_UReg_32Bit reserved_11:5;     /**< \brief [15:11] \internal Reserved */
    Ifx_UReg_32Bit PORST:1;           /**< \brief [16:16] Reset Request Trigger Reset Status for PORST - PORST (rh) */
    Ifx_UReg_32Bit reserved_17:1;     /**< \brief [17:17] \internal Reserved */
    Ifx_UReg_32Bit CB0:1;             /**< \brief [18:18] Reset Request Trigger Reset Status for Cerberus System Reset - CB0 (rh) */
    Ifx_UReg_32Bit CB1:1;             /**< \brief [19:19] Reset Request Trigger Reset Status for Cerberus Debug Reset - CB1 (rh) */
    Ifx_UReg_32Bit CB3:1;             /**< \brief [20:20] Reset Request Trigger Reset Status for Cerberus Application Reset - CB3 (rh) */
    Ifx_UReg_32Bit reserved_21:1;     /**< \brief [21:21] \internal Reserved */
    Ifx_UReg_32Bit reserved_22:1;     /**< \brief [22:22] \internal Reserved */
    Ifx_UReg_32Bit EVRC:1;            /**< \brief [23:23] Reset Request Trigger Reset Status for EVRC - EVRC (rh) */
    Ifx_UReg_32Bit EVR33:1;           /**< \brief [24:24] Reset Request Trigger Reset Status for EVR33 - EVR33 (rh) */
    Ifx_UReg_32Bit SWD:1;             /**< \brief [25:25] Reset Request Trigger Reset Status for Supply Watchdog (SWD) - SWD (rh) */
    Ifx_UReg_32Bit HSMS:1;            /**< \brief [26:26] Reset Request Trigger Reset Status for HSM System Reset (HSM S) - HSMS (rh) */
    Ifx_UReg_32Bit HSMA:1;            /**< \brief [27:27] Reset Request Trigger Reset Status for HSM Application Reset (HSM A) - HSMA (rh) */
    Ifx_UReg_32Bit STBYR:1;           /**< \brief [28:28] Reset Request Trigger Reset Status for Standby Regulator Watchdog (STBYR) - STBYR (rh) */
    Ifx_UReg_32Bit LBPORST:1;         /**< \brief [29:29] LBIST termination due to PORST (rh) */
    Ifx_UReg_32Bit LBTERM:1;          /**< \brief [30:30] LBIST was properly terminated (rh) */
    Ifx_UReg_32Bit reserved_31:1;     /**< \brief [31:31] \internal Reserved */
} Ifx_SCU_RSTSTAT_Bits;

/** \brief Safety ENDINIT Control Register 0 */
typedef struct _Ifx_SCU_SEICON0_Bits
{
    unsigned __sfrbit32 reserved_0:1;    /**< \brief [0:0] \internal Reserved */
    unsigned __sfrbit32 ENDINIT:1;       /**< \brief [1:1] End-of-Initialization Control Bit - ENDINIT (rwh) */
    unsigned __sfrbit32 EPW:14;          /**< \brief [15:2] User-Definable Safety ENDINIT Password Field - EPW (rwh) */
    unsigned __sfrbit32 REL:16;          /**< \brief [31:16] Reload Value for the Safety  ENDINIT Timeout Counter - REL (r) */
} Ifx_SCU_SEICON0_Bits;

/** \brief Safety ENDINIT Control Register 1 */
typedef struct _Ifx_SCU_SEICON1_Bits
{
    Ifx_UReg_32Bit reserved_0:1;      /**< \brief [0:0] \internal Reserved */
    Ifx_UReg_32Bit reserved_1:1;      /**< \brief [1:1] \internal Reserved */
    Ifx_UReg_32Bit IR0:1;             /**< \brief [2:2] Input Frequency Request Control - IR1,IR0 (rw) */
    Ifx_UReg_32Bit DR:1;              /**< \brief [3:3] Disable Request Control Bit - DR (rw) */
    Ifx_UReg_32Bit reserved_4:1;      /**< \brief [4:4] \internal Reserved */
    Ifx_UReg_32Bit IR1:1;             /**< \brief [5:5] Input Frequency Request Control - IR1,IR0 (rw) */
    Ifx_UReg_32Bit reserved_6:26;     /**< \brief [31:6] \internal Reserved */
} Ifx_SCU_SEICON1_Bits;

/** \brief Safety ENDINIT Timeout Status Register */
typedef struct _Ifx_SCU_SEISR_Bits
{
    Ifx_UReg_32Bit AE:1;              /**< \brief [0:0] SEICON0 Access Error Status Flag - AE (rh) */
    Ifx_UReg_32Bit OE:1;              /**< \brief [1:1] SEI Timeout Overflow Error Status Flag - OE (rh) */
    Ifx_UReg_32Bit IS0:1;             /**< \brief [2:2] SEI Timeout Input Clock Status - IS0, IS1 (rh) */
    Ifx_UReg_32Bit DS:1;              /**< \brief [3:3] SEI Enable/Disable Status Flag - DS (rh) */
    Ifx_UReg_32Bit TO:1;              /**< \brief [4:4] SEI Time-Out Mode Flag - TO (rh) */
    Ifx_UReg_32Bit IS1:1;             /**< \brief [5:5] SEI Timeout Input Clock Status - IS0, IS1 (rh) */
    Ifx_UReg_32Bit reserved_6:10;     /**< \brief [15:6] \internal Reserved */
    Ifx_UReg_32Bit TIM:16;            /**< \brief [31:16] Timer Value - TIM (rh) */
} Ifx_SCU_SEISR_Bits;

/** \brief Start-up Configuration Register */
typedef struct _Ifx_SCU_STCON_Bits
{
    Ifx_UReg_32Bit reserved_0:13;     /**< \brief [12:0] \internal Reserved */
    Ifx_UReg_32Bit SFCBAE:1;          /**< \brief [13:13] Set Flash Config. Sector Access Enable - SFCBAE (w) */
    Ifx_UReg_32Bit CFCBAE:1;          /**< \brief [14:14] Clear Flash Config. Sector Access Enable - CFCBAE (w) */
    Ifx_UReg_32Bit STP:1;             /**< \brief [15:15] Start-up Protection Setting - STP (rwh) */
    Ifx_UReg_32Bit reserved_16:16;    /**< \brief [31:16] \internal Reserved */
} Ifx_SCU_STCON_Bits;

/** \brief Start-up Memory Register 1 */
typedef struct _Ifx_SCU_STMEM1_Bits
{
    Ifx_UReg_32Bit MEM:32;            /**< \brief [31:0] Memory - MEM (rw) */
} Ifx_SCU_STMEM1_Bits;

/** \brief Start-up Memory Register 2 */
typedef struct _Ifx_SCU_STMEM2_Bits
{
    Ifx_UReg_32Bit MEM:32;            /**< \brief [31:0] Memory - MEM (rw) */
} Ifx_SCU_STMEM2_Bits;

/** \brief Start-up Memory Register 3 */
typedef struct _Ifx_SCU_STMEM3_Bits
{
    Ifx_UReg_32Bit MEM:32;            /**< \brief [31:0] Memory - MEM (rw) */
} Ifx_SCU_STMEM3_Bits;

/** \brief Start-up Memory Register 4 */
typedef struct _Ifx_SCU_STMEM4_Bits
{
    Ifx_UReg_32Bit MEM:32;            /**< \brief [31:0] Memory - MEM (rw) */
} Ifx_SCU_STMEM4_Bits;

/** \brief Start-up Memory Register 5 */
typedef struct _Ifx_SCU_STMEM5_Bits
{
    Ifx_UReg_32Bit MEM:32;            /**< \brief [31:0] Memory - MEM (rw) */
} Ifx_SCU_STMEM5_Bits;

/** \brief Start-up Memory Register 6 */
typedef struct _Ifx_SCU_STMEM6_Bits
{
    Ifx_UReg_32Bit MEM:32;            /**< \brief [31:0] Memory - MEM (rw) */
} Ifx_SCU_STMEM6_Bits;

/** \brief Start-up Status Register */
typedef struct _Ifx_SCU_STSTAT_Bits
{
    Ifx_UReg_32Bit HWCFG:8;           /**< \brief [7:0] Hardware Configuration Setting - HWCFG (rh) */
    Ifx_UReg_32Bit FTM:7;             /**< \brief [14:8] Firmware Test Setting - FTM (rh) */
    Ifx_UReg_32Bit MODE:1;            /**< \brief [15:15] MODE - MODE (rh) */
    Ifx_UReg_32Bit FCBAE:1;           /**< \brief [16:16] Flash Config. Sector Access Enable - FCBAE (rh) */
    Ifx_UReg_32Bit LUDIS:1;           /**< \brief [17:17] Latch Update Disable - LUDIS (rh) */
    Ifx_UReg_32Bit reserved_18:1;     /**< \brief [18:18] \internal Reserved */
    Ifx_UReg_32Bit TRSTL:1;           /**< \brief [19:19] TRSTL Status - TRSTL (rh) */
    Ifx_UReg_32Bit SPDEN:1;           /**< \brief [20:20] Single Pin DAP Mode Enable - SPDEN (rh) */
    Ifx_UReg_32Bit reserved_21:1;     /**< \brief [21:21] \internal Reserved */
    Ifx_UReg_32Bit reserved_22:1;     /**< \brief [22:22] \internal Reserved */
    Ifx_UReg_32Bit reserved_23:1;     /**< \brief [23:23] \internal Reserved */
    Ifx_UReg_32Bit RAMINT:1;          /**< \brief [24:24] RAM Content Security Integrity - RAMINT (rh) */
    Ifx_UReg_32Bit reserved_25:3;     /**< \brief [27:25] \internal Reserved */
    Ifx_UReg_32Bit reserved_28:4;     /**< \brief [31:28] \internal Reserved */
} Ifx_SCU_STSTAT_Bits;

/** \brief Address Map Control Register */
typedef struct _Ifx_SCU_SWAPCTRL_Bits
{
    Ifx_UReg_32Bit ADDRCFG:2;         /**< \brief [1:0] Address Configuration (rw) */
    Ifx_UReg_32Bit SPARE:14;          /**< \brief [15:2] Spare address configuration registers (rw) */
    Ifx_UReg_32Bit reserved_16:16;    /**< \brief [31:16] \internal Reserved */
} Ifx_SCU_SWAPCTRL_Bits;

/** \brief Software Reset Configuration Register */
typedef struct _Ifx_SCU_SWRSTCON_Bits
{
    Ifx_UReg_32Bit reserved_0:1;      /**< \brief [0:0] \internal Reserved */
    Ifx_UReg_32Bit SWRSTREQ:1;        /**< \brief [1:1] Software Reset Request - SWRSTREQ (w) */
    Ifx_UReg_32Bit reserved_2:6;      /**< \brief [7:2] \internal Reserved */
    Ifx_UReg_32Bit reserved_8:8;      /**< \brief [15:8] \internal Reserved */
    Ifx_UReg_32Bit reserved_16:16;    /**< \brief [31:16] \internal Reserved */
} Ifx_SCU_SWRSTCON_Bits;

/** \brief System Control Register */
typedef struct _Ifx_SCU_SYSCON_Bits
{
    Ifx_UReg_32Bit CCTRIG0:1;         /**< \brief [0:0] Capture Compare Trigger 0 - CCTRIG0 (rw) */
    Ifx_UReg_32Bit reserved_1:1;      /**< \brief [1:1] \internal Reserved */
    Ifx_UReg_32Bit RAMINTM:2;         /**< \brief [3:2] RAM Integrity Modify - RAMINTM (w) */
    Ifx_UReg_32Bit SETLUDIS:1;        /**< \brief [4:4] Set Latch Update Disable - SETLUDIS (w) */
    Ifx_UReg_32Bit reserved_5:1;      /**< \brief [5:5] \internal Reserved */
    Ifx_UReg_32Bit reserved_6:1;      /**< \brief [6:6] \internal Reserved */
    Ifx_UReg_32Bit reserved_7:1;      /**< \brief [7:7] \internal Reserved */
    Ifx_UReg_32Bit DDC:1;             /**< \brief [8:8] Disable DXCPL - DDC (rw) */
    Ifx_UReg_32Bit reserved_9:7;      /**< \brief [15:9] \internal Reserved */
    Ifx_UReg_32Bit reserved_16:16;    /**< \brief [31:16] \internal Reserved */
} Ifx_SCU_SYSCON_Bits;

/** \brief System PLL Configuration 0 Register */
typedef struct _Ifx_SCU_SYSPLLCON0_Bits
{
    Ifx_UReg_32Bit reserved_0:2;      /**< \brief [1:0] \internal Reserved */
    Ifx_UReg_32Bit MODEN:1;           /**< \brief [2:2] Modulation Enable - MODEN (rw) */
    Ifx_UReg_32Bit reserved_3:6;      /**< \brief [8:3] \internal Reserved */
    Ifx_UReg_32Bit NDIV:7;            /**< \brief [15:9] N-Divider Value - NDIV (rw) */
    Ifx_UReg_32Bit PLLPWD:1;          /**< \brief [16:16] System PLL Power Saving Mode - PLLPWD (rw) */
    Ifx_UReg_32Bit reserved_17:1;     /**< \brief [17:17] \internal Reserved */
    Ifx_UReg_32Bit RESLD:1;           /**< \brief [18:18] Restart DCO Lock Detection - RESLD (w) */
    Ifx_UReg_32Bit reserved_19:5;     /**< \brief [23:19] \internal Reserved */
    Ifx_UReg_32Bit PDIV:3;            /**< \brief [26:24] P-Divider Value - PDIV (rw) */
    Ifx_UReg_32Bit reserved_27:3;     /**< \brief [29:27] \internal Reserved */
    Ifx_UReg_32Bit INSEL:2;           /**< \brief [31:30] Input Selection - INSEL (rw) */
} Ifx_SCU_SYSPLLCON0_Bits;

/** \brief System PLL Configuration 1 Register */
typedef struct _Ifx_SCU_SYSPLLCON1_Bits
{
    Ifx_UReg_32Bit K2DIV:3;           /**< \brief [2:0] K2-Divider Value - K2DIV (rw) */
    Ifx_UReg_32Bit reserved_3:29;     /**< \brief [31:3] \internal Reserved */
} Ifx_SCU_SYSPLLCON1_Bits;

/** \brief System PLL Configuration 2 Register */
typedef struct _Ifx_SCU_SYSPLLCON2_Bits
{
    Ifx_UReg_32Bit MODCFG:16;         /**< \brief [15:0] Modulation Configuration - MODCFG (rw) */
    Ifx_UReg_32Bit reserved_16:16;    /**< \brief [31:16] \internal Reserved */
} Ifx_SCU_SYSPLLCON2_Bits;

/** \brief System PLL Status Register */
typedef struct _Ifx_SCU_SYSPLLSTAT_Bits
{
    Ifx_UReg_32Bit reserved_0:1;      /**< \brief [0:0] \internal Reserved */
    Ifx_UReg_32Bit PWDSTAT:1;         /**< \brief [1:1] System PLL Power-saving Mode Status - PWDSTAT (rh) */
    Ifx_UReg_32Bit LOCK:1;            /**< \brief [2:2] System PLL Lock Status - LOCK (rh) */
    Ifx_UReg_32Bit reserved_3:2;      /**< \brief [4:3] \internal Reserved */
    Ifx_UReg_32Bit K2RDY:1;           /**< \brief [5:5] K2 Divider Ready Status - K2RDY (rh) */
    Ifx_UReg_32Bit reserved_6:1;      /**< \brief [6:6] \internal Reserved */
    Ifx_UReg_32Bit MODRUN:1;          /**< \brief [7:7] Modulation Run - MODRUN (rh) */
    Ifx_UReg_32Bit reserved_8:24;     /**< \brief [31:8] \internal Reserved */
} Ifx_SCU_SYSPLLSTAT_Bits;

/** \brief Trap Clear Register */
typedef struct _Ifx_SCU_TRAPCLR_Bits
{
    Ifx_UReg_32Bit ESR0T:1;           /**< \brief [0:0] Clear Trap Request Flag ESR0T - ESR0T (w) */
    Ifx_UReg_32Bit ESR1T:1;           /**< \brief [1:1] Clear Trap Request Flag ESR1T - ESR1T (w) */
    Ifx_UReg_32Bit TRAP2:1;           /**< \brief [2:2] Clear Trap Request Flag TRAP2 - TRAP2 (w) */
    Ifx_UReg_32Bit SMUT:1;            /**< \brief [3:3] Clear Trap Request Flag SMUT - SMUT (w) */
    Ifx_UReg_32Bit reserved_4:28;     /**< \brief [31:4] \internal Reserved */
} Ifx_SCU_TRAPCLR_Bits;

/** \brief Trap Disable Register 0 */
typedef struct _Ifx_SCU_TRAPDIS0_Bits
{
    Ifx_UReg_32Bit CPU0ESR0T:1;       /**< \brief [0:0] Disable Trap Request ESR0T on CPU0 - CPU0ESR0T (rw) */
    Ifx_UReg_32Bit CPU0ESR1T:1;       /**< \brief [1:1] Disable Trap Request ESR1T on CPU0 - CPU0ESR1T (rw) */
    Ifx_UReg_32Bit CPU0TRAP2T:1;      /**< \brief [2:2] Disable Trap Request TRAP2T on CPU0 - CPU0TRAP2T (rw) */
    Ifx_UReg_32Bit CPU0SMUT:1;        /**< \brief [3:3] Disable Trap Request SMUT on CPU0 - CPU0SMUT (rw) */
    Ifx_UReg_32Bit reserved_4:4;      /**< \brief [7:4] \internal Reserved */
    Ifx_UReg_32Bit CPU1ESR0T:1;       /**< \brief [8:8] Disable Trap Request ESR0T on CPU1 (If product has CPU1) - CPU1ESR0T (rw) */
    Ifx_UReg_32Bit CPU1ESR1T:1;       /**< \brief [9:9] Disable Trap Request ESR1T on CPU1 (If product has CPU1) - CPU1ESR1T (rw) */
    Ifx_UReg_32Bit CPU1TRAP2T:1;      /**< \brief [10:10] Disable Trap Request TRAP2T on CPU1 (If product has CPU1) - CPU1TRAP2T (rw) */
    Ifx_UReg_32Bit CPU1SMUT:1;        /**< \brief [11:11] Disable Trap Request SMUT on CPU1 (If product has CPU1) - CPU1SMUT (rw) */
    Ifx_UReg_32Bit reserved_12:4;     /**< \brief [15:12] \internal Reserved */
    Ifx_UReg_32Bit CPU2ESR0T:1;       /**< \brief [16:16] Disable Trap Request ESR0T on CPU2 (If product has CPU2) - CPU2ESR0T (rw) */
    Ifx_UReg_32Bit CPU2ESR1T:1;       /**< \brief [17:17] Disable Trap Request ESR1T on CPU2 (If product has CPU2) - CPU2ESR1T (rw) */
    Ifx_UReg_32Bit CPU2TRAP2T:1;      /**< \brief [18:18] Disable Trap Request TRAP2T on CPU2 (If product has CPU2) - CPU2TRAP2T (rw) */
    Ifx_UReg_32Bit CPU2SMUT:1;        /**< \brief [19:19] Disable Trap Request SMUT on CPU2 (If product has CPU2) - CPU2SMUT (rw) */
    Ifx_UReg_32Bit reserved_20:4;     /**< \brief [23:20] \internal Reserved */
    Ifx_UReg_32Bit CPU3ESR0T:1;       /**< \brief [24:24] Disable Trap Request ESR0T on CPU3 (If product has CPU3) - CPU3ESR0T (rw) */
    Ifx_UReg_32Bit CPU3ESR1T:1;       /**< \brief [25:25] Disable Trap Request ESR1T on CPU3 (If product has CPU3) - CPU3ESR1T (rw) */
    Ifx_UReg_32Bit CPU3TRAP2T:1;      /**< \brief [26:26] Disable Trap Request TRAP2T on CPU3 (If product has CPU3) - CPU3TRAP2T (rw) */
    Ifx_UReg_32Bit CPU3SMUT:1;        /**< \brief [27:27] Disable Trap Request SMUT on CPU3 (If product has CPU3) - CPU3SMUT (rw) */
    Ifx_UReg_32Bit reserved_28:4;     /**< \brief [31:28] \internal Reserved */
} Ifx_SCU_TRAPDIS0_Bits;

/** \brief Trap Disable Register 1 */
typedef struct _Ifx_SCU_TRAPDIS1_Bits
{
    Ifx_UReg_32Bit reserved_0:4;      /**< \brief [3:0] \internal Reserved */
    Ifx_UReg_32Bit reserved_4:4;      /**< \brief [7:4] \internal Reserved */
    Ifx_UReg_32Bit reserved_8:4;      /**< \brief [11:8] \internal Reserved */
    Ifx_UReg_32Bit reserved_12:4;     /**< \brief [15:12] \internal Reserved */
    Ifx_UReg_32Bit reserved_16:16;    /**< \brief [31:16] \internal Reserved */
} Ifx_SCU_TRAPDIS1_Bits;

/** \brief Trap Set Register */
typedef struct _Ifx_SCU_TRAPSET_Bits
{
    Ifx_UReg_32Bit ESR0T:1;           /**< \brief [0:0] Set Trap Request Flag ESR0T - ESR0T (w) */
    Ifx_UReg_32Bit ESR1T:1;           /**< \brief [1:1] Set Trap Request Flag ESR1T - ESR1T (w) */
    Ifx_UReg_32Bit TRAP2:1;           /**< \brief [2:2] Set Trap Request Flag TRAP2 - TRAP2 (w) */
    Ifx_UReg_32Bit SMUT:1;            /**< \brief [3:3] Set Trap Request Flag SMUT - SMUT (w) */
    Ifx_UReg_32Bit reserved_4:28;     /**< \brief [31:4] \internal Reserved */
} Ifx_SCU_TRAPSET_Bits;

/** \brief Trap Status Register */
typedef struct _Ifx_SCU_TRAPSTAT_Bits
{
    Ifx_UReg_32Bit ESR0T:1;           /**< \brief [0:0] ESR0 Trap Request Flag - ESR0T (rh) */
    Ifx_UReg_32Bit ESR1T:1;           /**< \brief [1:1] ESR1 Trap Request Flag - ESR1T (rh) */
    Ifx_UReg_32Bit TRAP2:1;           /**< \brief [2:2] Trap Bit 2 Request Flag - TRAP2 (rh) */
    Ifx_UReg_32Bit SMUT:1;            /**< \brief [3:3] SMU Alarm Trap Request Flag - SMUT (rh) */
    Ifx_UReg_32Bit reserved_4:28;     /**< \brief [31:4] \internal Reserved */
} Ifx_SCU_TRAPSTAT_Bits;

/** \brief CPU${y} WDT Control Register 0 */
typedef struct _Ifx_SCU_WDTCPU_CON0_Bits
{
    unsigned __sfrbit32 ENDINIT:1;       /**< \brief [0:0] End-of-Initialization Control Bit - ENDINIT (rwh) */
    unsigned __sfrbit32 LCK:1;           /**< \brief [1:1] Lock Bit to Control Access to WDTxCON0 - LCK (rwh) */
    unsigned __sfrbit32 PW:14;           /**< \brief [15:2] User-Definable Password Field for Access to WDTxCON0 - PW (rwh) */
    unsigned __sfrbit32 REL:16;          /**< \brief [31:16] Reload Value for the WDT (also Time Check Value) - REL (rw) */
} Ifx_SCU_WDTCPU_CON0_Bits;

/** \brief CPU${y} WDT Control Register 1 */
typedef struct _Ifx_SCU_WDTCPU_CON1_Bits
{
    Ifx_UReg_32Bit reserved_0:1;      /**< \brief [0:0] \internal Reserved */
    Ifx_UReg_32Bit reserved_1:1;      /**< \brief [1:1] \internal Reserved */
    Ifx_UReg_32Bit IR0:1;             /**< \brief [2:2] Input Frequency Request Control - IR1,IR0 (rw) */
    Ifx_UReg_32Bit DR:1;              /**< \brief [3:3] Disable Request Control Bit - DR (rw) */
    Ifx_UReg_32Bit reserved_4:1;      /**< \brief [4:4] \internal Reserved */
    Ifx_UReg_32Bit IR1:1;             /**< \brief [5:5] Input Frequency Request Control - IR1,IR0 (rw) */
    Ifx_UReg_32Bit UR:1;              /**< \brief [6:6] Unlock Restriction Request Control Bit - UR (rw) */
    Ifx_UReg_32Bit PAR:1;             /**< \brief [7:7] Password Auto-sequence Request Bit - PAR (rw) */
    Ifx_UReg_32Bit TCR:1;             /**< \brief [8:8] Counter Check Request Bit - TCR (rw) */
    Ifx_UReg_32Bit TCTR:7;            /**< \brief [15:9] Timer Check Tolerance Request - TCTR (rw) */
    Ifx_UReg_32Bit reserved_16:16;    /**< \brief [31:16] \internal Reserved */
} Ifx_SCU_WDTCPU_CON1_Bits;

/** \brief CPU${y} WDT Status Register */
typedef struct _Ifx_SCU_WDTCPU_SR_Bits
{
    Ifx_UReg_32Bit AE:1;              /**< \brief [0:0] Watchdog Access Error Status Flag - AE (rh) */
    Ifx_UReg_32Bit OE:1;              /**< \brief [1:1] Watchdog Overflow Error Status Flag - OE (rh) */
    Ifx_UReg_32Bit IS0:1;             /**< \brief [2:2] Watchdog Input Clock Status - IS1,IS0 (rh) */
    Ifx_UReg_32Bit DS:1;              /**< \brief [3:3] Watchdog Enable/Disable Status Flag - DS (rh) */
    Ifx_UReg_32Bit TO:1;              /**< \brief [4:4] Watchdog Time-Out Mode Flag - TO (rh) */
    Ifx_UReg_32Bit IS1:1;             /**< \brief [5:5] Watchdog Input Clock Status - IS1,IS0 (rh) */
    Ifx_UReg_32Bit US:1;              /**< \brief [6:6] SMU Unlock Restriction Status Flag - US (rh) */
    Ifx_UReg_32Bit PAS:1;             /**< \brief [7:7] Password Auto-sequence Status Flag - PAS (rh) */
    Ifx_UReg_32Bit TCS:1;             /**< \brief [8:8] Timer Check Status Flag - TCS (rh) */
    Ifx_UReg_32Bit TCT:7;             /**< \brief [15:9] Timer Check Tolerance - TCT (rh) */
    Ifx_UReg_32Bit TIM:16;            /**< \brief [31:16] Timer Value - TIM (rh) */
} Ifx_SCU_WDTCPU_SR_Bits;

/** \brief Safety WDT Control Register 0 */
typedef struct _Ifx_SCU_WDTS_CON0_Bits
{
    unsigned __sfrbit32 ENDINIT:1;       /**< \brief [0:0] End-of-Initialization Control Bit - ENDINIT (rwh) */
    unsigned __sfrbit32 LCK:1;           /**< \brief [1:1] Lock Bit to Control Access to WDTxCON0 - LCK (rwh) */
    unsigned __sfrbit32 PW:14;           /**< \brief [15:2] User-Definable Password Field for Access to WDTxCON0 - PW (rwh) */
    unsigned __sfrbit32 REL:16;          /**< \brief [31:16] Reload Value for the WDT (also Time Check Value) - REL (rw) */
} Ifx_SCU_WDTS_CON0_Bits;

/** \brief Safety WDT Control Register 1 */
typedef struct _Ifx_SCU_WDTS_CON1_Bits
{
    Ifx_UReg_32Bit CLRIRF:1;          /**< \brief [0:0] Clear Internal Reset Flag - CLRIRF (rwh) */
    Ifx_UReg_32Bit reserved_1:1;      /**< \brief [1:1] \internal Reserved */
    Ifx_UReg_32Bit IR0:1;             /**< \brief [2:2] Input Frequency Request Control - IR1,IR0 (rw) */
    Ifx_UReg_32Bit DR:1;              /**< \brief [3:3] Disable Request Control Bit - DR (rw) */
    Ifx_UReg_32Bit reserved_4:1;      /**< \brief [4:4] \internal Reserved */
    Ifx_UReg_32Bit IR1:1;             /**< \brief [5:5] Input Frequency Request Control - IR1,IR0 (rw) */
    Ifx_UReg_32Bit UR:1;              /**< \brief [6:6] Unlock Restriction Request Control Bit - UR (rw) */
    Ifx_UReg_32Bit PAR:1;             /**< \brief [7:7] Password Auto-sequence Request Bit - PAR (rw) */
    Ifx_UReg_32Bit TCR:1;             /**< \brief [8:8] Counter Check Request Bit - TCR (rw) */
    Ifx_UReg_32Bit TCTR:7;            /**< \brief [15:9] Timer Check Tolerance Request - TCTR (rw) */
    Ifx_UReg_32Bit reserved_16:16;    /**< \brief [31:16] \internal Reserved */
} Ifx_SCU_WDTS_CON1_Bits;

/** \brief Safety WDT Status Register */
typedef struct _Ifx_SCU_WDTS_SR_Bits
{
    Ifx_UReg_32Bit AE:1;              /**< \brief [0:0] Watchdog Access Error Status Flag - AE (rh) */
    Ifx_UReg_32Bit OE:1;              /**< \brief [1:1] Watchdog Overflow Error Status Flag - OE (rh) */
    Ifx_UReg_32Bit IS0:1;             /**< \brief [2:2] Watchdog Input Clock Status - IS1,IS0 (rh) */
    Ifx_UReg_32Bit DS:1;              /**< \brief [3:3] Watchdog Enable/Disable Status Flag - DS (rh) */
    Ifx_UReg_32Bit TO:1;              /**< \brief [4:4] Watchdog Time-Out Mode Flag - TO (rh) */
    Ifx_UReg_32Bit IS1:1;             /**< \brief [5:5] Watchdog Input Clock Status - IS1,IS0 (rh) */
    Ifx_UReg_32Bit US:1;              /**< \brief [6:6] SMU Unlock Restriction Status Flag - US (rh) */
    Ifx_UReg_32Bit PAS:1;             /**< \brief [7:7] Password Auto-sequence Status Flag - PAS (rh) */
    Ifx_UReg_32Bit TCS:1;             /**< \brief [8:8] Timer Check Status Flag - TCS (rh) */
    Ifx_UReg_32Bit TCT:7;             /**< \brief [15:9] Timer Check Tolerance - TCT (rh) */
    Ifx_UReg_32Bit TIM:16;            /**< \brief [31:16] Timer Value - TIM (rh) */
} Ifx_SCU_WDTS_SR_Bits;

/** \}  */
/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_scu_Registers_union
 * \{   */
/** \brief Access Enable Register 00   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_ACCEN00_Bits B;           /**< \brief Bitfield access */
} Ifx_SCU_ACCEN00;

/** \brief Access Enable Register 01   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_ACCEN01_Bits B;           /**< \brief Bitfield access */
} Ifx_SCU_ACCEN01;

/** \brief Access Enable Register 10   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_ACCEN10_Bits B;           /**< \brief Bitfield access */
} Ifx_SCU_ACCEN10;

/** \brief Access Enable Register 11   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_ACCEN11_Bits B;           /**< \brief Bitfield access */
} Ifx_SCU_ACCEN11;

/** \brief Application Reset Disable Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_ARSTDIS_Bits B;           /**< \brief Bitfield access */
} Ifx_SCU_ARSTDIS;

/** \brief CCU Clock Control Register 0   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_CCUCON0_Bits B;           /**< \brief Bitfield access */
} Ifx_SCU_CCUCON0;

/** \brief CCU Clock Control Register 1   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_CCUCON1_Bits B;           /**< \brief Bitfield access */
} Ifx_SCU_CCUCON1;

/** \brief CCU Clock Control Register 2   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_CCUCON2_Bits B;           /**< \brief Bitfield access */
} Ifx_SCU_CCUCON2;

/** \brief CCU Clock Control Register 3   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_CCUCON3_Bits B;           /**< \brief Bitfield access */
} Ifx_SCU_CCUCON3;

/** \brief CCU Clock Control Register 4   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_CCUCON4_Bits B;           /**< \brief Bitfield access */
} Ifx_SCU_CCUCON4;

/** \brief CCU Clock Control Register 5   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_CCUCON5_Bits B;           /**< \brief Bitfield access */
} Ifx_SCU_CCUCON5;

/** \brief CCU Clock Control Register 6   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_CCUCON6_Bits B;           /**< \brief Bitfield access */
} Ifx_SCU_CCUCON6;

/** \brief CCU Clock Control Register 7   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_CCUCON7_Bits B;           /**< \brief Bitfield access */
} Ifx_SCU_CCUCON7;

/** \brief CCU Clock Control Register 8   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_CCUCON8_Bits B;           /**< \brief Bitfield access */
} Ifx_SCU_CCUCON8;

/** \brief CCU Clock Control Register 9   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_CCUCON9_Bits B;           /**< \brief Bitfield access */
} Ifx_SCU_CCUCON9;

/** \brief Chip Identification Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_CHIPID_Bits B;            /**< \brief Bitfield access */
} Ifx_SCU_CHIPID;

/** \brief Core Die Temperature Sensor Limit Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_DTSCLIM_Bits B;           /**< \brief Bitfield access */
} Ifx_SCU_DTSCLIM;

/** \brief Core Die Temperature Sensor Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_DTSCSTAT_Bits B;          /**< \brief Bitfield access */
} Ifx_SCU_DTSCSTAT;

/** \brief ENDINIT Global Control Register 0   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_EICON0_Bits B;            /**< \brief Bitfield access */
} Ifx_SCU_EICON0;

/** \brief ENDINIT Global Control Register 1   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_EICON1_Bits B;            /**< \brief Bitfield access */
} Ifx_SCU_EICON1;

/** \brief External Input Channel Register ${i}   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_EICR_Bits B;              /**< \brief Bitfield access */
} Ifx_SCU_EICR;

/** \brief External Input Filter Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_EIFILT_Bits B;            /**< \brief Bitfield access */
} Ifx_SCU_EIFILT;

/** \brief External Input Flag Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_EIFR_Bits B;              /**< \brief Bitfield access */
} Ifx_SCU_EIFR;

/** \brief ENDINIT Timeout Counter Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_EISR_Bits B;              /**< \brief Bitfield access */
} Ifx_SCU_EISR;

/** \brief Emergency Stop Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_EMSR_Bits B;              /**< \brief Bitfield access */
} Ifx_SCU_EMSR;

/** \brief Emergency Stop Software set and clear register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_EMSSW_Bits B;             /**< \brief Bitfield access */
} Ifx_SCU_EMSSW;

/** \brief ESR${x} Input Configuration Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_ESRCFGX_ESRCFGX_Bits B;    /**< \brief Bitfield access */
} Ifx_SCU_ESRCFGX_ESRCFGX;

/** \brief ESR Output Configuration Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_ESROCFG_Bits B;           /**< \brief Bitfield access */
} Ifx_SCU_ESROCFG;

/** \brief External Clock Control Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_EXTCON_Bits B;            /**< \brief Bitfield access */
} Ifx_SCU_EXTCON;

/** \brief Fractional Divider Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_FDR_Bits B;               /**< \brief Bitfield access */
} Ifx_SCU_FDR;

/** \brief Flag Modification Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_FMR_Bits B;               /**< \brief Bitfield access */
} Ifx_SCU_FMR;

/** \brief Identification Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_ID_Bits B;                /**< \brief Bitfield access */
} Ifx_SCU_ID;

/** \brief Flag Gating Register ${j}   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_IGCR_Bits B;              /**< \brief Bitfield access */
} Ifx_SCU_IGCR;

/** \brief ESR Input Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_IN_Bits B;                /**< \brief Bitfield access */
} Ifx_SCU_IN;

/** \brief Input/Output Control Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_IOCR_Bits B;              /**< \brief Bitfield access */
} Ifx_SCU_IOCR;

/** \brief Logic BIST Control 0 Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_LBISTCTRL0_Bits B;        /**< \brief Bitfield access */
} Ifx_SCU_LBISTCTRL0;

/** \brief Logic BIST Control 1 Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_LBISTCTRL1_Bits B;        /**< \brief Bitfield access */
} Ifx_SCU_LBISTCTRL1;

/** \brief Logic BIST Control 2 Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_LBISTCTRL2_Bits B;        /**< \brief Bitfield access */
} Ifx_SCU_LBISTCTRL2;

/** \brief Logic BIST Control 3 Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_LBISTCTRL3_Bits B;        /**< \brief Bitfield access */
} Ifx_SCU_LBISTCTRL3;

/** \brief LCL CPU0 and CPU2 Control Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_LCLCON0_Bits B;           /**< \brief Bitfield access */
} Ifx_SCU_LCLCON0;

/** \brief LCL CPU1 and CPU3 Control Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_LCLCON1_Bits B;           /**< \brief Bitfield access */
} Ifx_SCU_LCLCON1;

/** \brief LCL Test Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_LCLTEST_Bits B;           /**< \brief Bitfield access */
} Ifx_SCU_LCLTEST;

/** \brief Manufacturer Identification Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_MANID_Bits B;             /**< \brief Bitfield access */
} Ifx_SCU_MANID;

/** \brief ESR Output Modification Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_OMR_Bits B;               /**< \brief Bitfield access */
} Ifx_SCU_OMR;

/** \brief OSC Control Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_OSCCON_Bits B;            /**< \brief Bitfield access */
} Ifx_SCU_OSCCON;

/** \brief ESR Output Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_OUT_Bits B;               /**< \brief Bitfield access */
} Ifx_SCU_OUT;

/** \brief Overlay Control Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_OVCCON_Bits B;            /**< \brief Bitfield access */
} Ifx_SCU_OVCCON;

/** \brief Overlay Enable Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_OVCENABLE_Bits B;         /**< \brief Bitfield access */
} Ifx_SCU_OVCENABLE;

/** \brief Pad Disable Control Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_PDISC_Bits B;             /**< \brief Bitfield access */
} Ifx_SCU_PDISC;

/** \brief ESR Pad Driver Mode Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_PDR_Bits B;               /**< \brief Bitfield access */
} Ifx_SCU_PDR;

/** \brief Pattern Detection Result Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_PDRR_Bits B;              /**< \brief Bitfield access */
} Ifx_SCU_PDRR;

/** \brief Peripheral PLL Configuration 0 Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_PERPLLCON0_Bits B;        /**< \brief Bitfield access */
} Ifx_SCU_PERPLLCON0;

/** \brief Peripheral PLL Configuration 1 Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_PERPLLCON1_Bits B;        /**< \brief Bitfield access */
} Ifx_SCU_PERPLLCON1;

/** \brief Peripheral PLL Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_PERPLLSTAT_Bits B;        /**< \brief Bitfield access */
} Ifx_SCU_PERPLLSTAT;

/** \brief Power Management Control and Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_PMCSR0_Bits B;            /**< \brief Bitfield access */
} Ifx_SCU_PMCSR0;

/** \brief Power Management Control and Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_PMCSR1_Bits B;            /**< \brief Bitfield access */
} Ifx_SCU_PMCSR1;

/** \brief Power Management Control and Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_PMCSR2_Bits B;            /**< \brief Bitfield access */
} Ifx_SCU_PMCSR2;

/** \brief Power Management Control and Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_PMCSR3_Bits B;            /**< \brief Bitfield access */
} Ifx_SCU_PMCSR3;

/** \brief Power Management Control and Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_PMCSR4_Bits B;            /**< \brief Bitfield access */
} Ifx_SCU_PMCSR4;

/** \brief Power Management Control and Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_PMCSR5_Bits B;            /**< \brief Bitfield access */
} Ifx_SCU_PMCSR5;

/** \brief Power Management Status Register 0   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_PMSTAT0_Bits B;           /**< \brief Bitfield access */
} Ifx_SCU_PMSTAT0;

/** \brief Standby and Wake-up Control Register 1   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_PMSWCR1_Bits B;           /**< \brief Bitfield access */
} Ifx_SCU_PMSWCR1;

/** \brief Power Management Transition Control and Status Register 0   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_PMTRCSR0_Bits B;          /**< \brief Bitfield access */
} Ifx_SCU_PMTRCSR0;

/** \brief Power Management Transition Control and Status Register 1   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_PMTRCSR1_Bits B;          /**< \brief Bitfield access */
} Ifx_SCU_PMTRCSR1;

/** \brief Power Management Transition Control and Status Register 2   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_PMTRCSR2_Bits B;          /**< \brief Bitfield access */
} Ifx_SCU_PMTRCSR2;

/** \brief Power Management Transition Control and Status Register 3   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_PMTRCSR3_Bits B;          /**< \brief Bitfield access */
} Ifx_SCU_PMTRCSR3;

/** \brief Reset Configuration Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_RSTCON_Bits B;            /**< \brief Bitfield access */
} Ifx_SCU_RSTCON;

/** \brief Additional Reset Control Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_RSTCON2_Bits B;           /**< \brief Bitfield access */
} Ifx_SCU_RSTCON2;

/** \brief Reset Configuration Register 3   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_RSTCON3_Bits B;           /**< \brief Bitfield access */
} Ifx_SCU_RSTCON3;

/** \brief Reset Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_RSTSTAT_Bits B;           /**< \brief Bitfield access */
} Ifx_SCU_RSTSTAT;

/** \brief Safety ENDINIT Control Register 0   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_SEICON0_Bits B;           /**< \brief Bitfield access */
} Ifx_SCU_SEICON0;

/** \brief Safety ENDINIT Control Register 1   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_SEICON1_Bits B;           /**< \brief Bitfield access */
} Ifx_SCU_SEICON1;

/** \brief Safety ENDINIT Timeout Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_SEISR_Bits B;             /**< \brief Bitfield access */
} Ifx_SCU_SEISR;

/** \brief Start-up Configuration Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_STCON_Bits B;             /**< \brief Bitfield access */
} Ifx_SCU_STCON;

/** \brief Start-up Memory Register 1   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_STMEM1_Bits B;            /**< \brief Bitfield access */
} Ifx_SCU_STMEM1;

/** \brief Start-up Memory Register 2   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_STMEM2_Bits B;            /**< \brief Bitfield access */
} Ifx_SCU_STMEM2;

/** \brief Start-up Memory Register 3   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_STMEM3_Bits B;            /**< \brief Bitfield access */
} Ifx_SCU_STMEM3;

/** \brief Start-up Memory Register 4   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_STMEM4_Bits B;            /**< \brief Bitfield access */
} Ifx_SCU_STMEM4;

/** \brief Start-up Memory Register 5   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_STMEM5_Bits B;            /**< \brief Bitfield access */
} Ifx_SCU_STMEM5;

/** \brief Start-up Memory Register 6   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_STMEM6_Bits B;            /**< \brief Bitfield access */
} Ifx_SCU_STMEM6;

/** \brief Start-up Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_STSTAT_Bits B;            /**< \brief Bitfield access */
} Ifx_SCU_STSTAT;

/** \brief Address Map Control Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_SWAPCTRL_Bits B;          /**< \brief Bitfield access */
} Ifx_SCU_SWAPCTRL;

/** \brief Software Reset Configuration Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_SWRSTCON_Bits B;          /**< \brief Bitfield access */
} Ifx_SCU_SWRSTCON;

/** \brief System Control Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_SYSCON_Bits B;            /**< \brief Bitfield access */
} Ifx_SCU_SYSCON;

/** \brief System PLL Configuration 0 Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_SYSPLLCON0_Bits B;        /**< \brief Bitfield access */
} Ifx_SCU_SYSPLLCON0;

/** \brief System PLL Configuration 1 Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_SYSPLLCON1_Bits B;        /**< \brief Bitfield access */
} Ifx_SCU_SYSPLLCON1;

/** \brief System PLL Configuration 2 Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_SYSPLLCON2_Bits B;        /**< \brief Bitfield access */
} Ifx_SCU_SYSPLLCON2;

/** \brief System PLL Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_SYSPLLSTAT_Bits B;        /**< \brief Bitfield access */
} Ifx_SCU_SYSPLLSTAT;

/** \brief Trap Clear Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_TRAPCLR_Bits B;           /**< \brief Bitfield access */
} Ifx_SCU_TRAPCLR;

/** \brief Trap Disable Register 0   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_TRAPDIS0_Bits B;          /**< \brief Bitfield access */
} Ifx_SCU_TRAPDIS0;

/** \brief Trap Disable Register 1   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_TRAPDIS1_Bits B;          /**< \brief Bitfield access */
} Ifx_SCU_TRAPDIS1;

/** \brief Trap Set Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_TRAPSET_Bits B;           /**< \brief Bitfield access */
} Ifx_SCU_TRAPSET;

/** \brief Trap Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_TRAPSTAT_Bits B;          /**< \brief Bitfield access */
} Ifx_SCU_TRAPSTAT;

/** \brief CPU${y} WDT Control Register 0   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_WDTCPU_CON0_Bits B;       /**< \brief Bitfield access */
} Ifx_SCU_WDTCPU_CON0;

/** \brief CPU${y} WDT Control Register 1   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_WDTCPU_CON1_Bits B;       /**< \brief Bitfield access */
} Ifx_SCU_WDTCPU_CON1;

/** \brief CPU${y} WDT Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_WDTCPU_SR_Bits B;         /**< \brief Bitfield access */
} Ifx_SCU_WDTCPU_SR;

/** \brief Safety WDT Control Register 0   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_WDTS_CON0_Bits B;         /**< \brief Bitfield access */
} Ifx_SCU_WDTS_CON0;

/** \brief Safety WDT Control Register 1   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_WDTS_CON1_Bits B;         /**< \brief Bitfield access */
} Ifx_SCU_WDTS_CON1;

/** \brief Safety WDT Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SCU_WDTS_SR_Bits B;           /**< \brief Bitfield access */
} Ifx_SCU_WDTS_SR;

/** \}  */

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Scu_ESRCFGx_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief ESRCFGX object */
typedef volatile struct _Ifx_SCU_ESRCFGX
{
       Ifx_SCU_ESRCFGX_ESRCFGX             ESRCFGX;                /**< \brief 0, ESR${x} Input Configuration Register*/
} Ifx_SCU_ESRCFGX;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Scu_WDTCPU_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief WDTCPU object */
typedef volatile struct _Ifx_SCU_WDTCPU
{
       Ifx_SCU_WDTCPU_CON0                 CON0;                   /**< \brief 0, */
       Ifx_SCU_WDTCPU_CON1                 CON1;                   /**< \brief 4, */
       Ifx_SCU_WDTCPU_SR                   SR;                     /**< \brief 8, */
} Ifx_SCU_WDTCPU;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Scu_WDTS_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief WDTS object */
typedef volatile struct _Ifx_SCU_WDTS
{
       Ifx_SCU_WDTS_CON0                   CON0;                   /**< \brief 0, Safety WDT Control Register 0*/
       Ifx_SCU_WDTS_CON1                   CON1;                   /**< \brief 4, Safety WDT Control Register 1*/
       Ifx_SCU_WDTS_SR                     SR;                     /**< \brief 8, Safety WDT Status Register*/
} Ifx_SCU_WDTS;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/** \addtogroup IfxSfr_Scu_Registers_struct
 * \{  */
/******************************************************************************/
/** \name Object L0
 * \{  */

/** \brief SCU object */
typedef volatile struct _Ifx_SCU
{
       Ifx_UReg_8Bit                       reserved_0[8];          /**< \brief 0, \internal Reserved */
       Ifx_SCU_ID                          ID;                     /**< \brief 8, Identification Register*/
       Ifx_UReg_8Bit                       reserved_C[4];          /**< \brief C, \internal Reserved */
       Ifx_SCU_OSCCON                      OSCCON;                 /**< \brief 10, OSC Control Register*/
       Ifx_SCU_SYSPLLSTAT                  SYSPLLSTAT;             /**< \brief 14, System PLL Status Register*/
       Ifx_SCU_SYSPLLCON0                  SYSPLLCON0;             /**< \brief 18, System PLL Configuration 0 Register*/
       Ifx_SCU_SYSPLLCON1                  SYSPLLCON1;             /**< \brief 1C, System PLL Configuration 1 Register*/
       Ifx_SCU_SYSPLLCON2                  SYSPLLCON2;             /**< \brief 20, System PLL Configuration 2 Register*/
       Ifx_SCU_PERPLLSTAT                  PERPLLSTAT;             /**< \brief 24, Peripheral PLL Status Register*/
       Ifx_SCU_PERPLLCON0                  PERPLLCON0;             /**< \brief 28, Peripheral PLL Configuration 0 Register*/
       Ifx_SCU_PERPLLCON1                  PERPLLCON1;             /**< \brief 2C, Peripheral PLL Configuration 1 Register*/
       Ifx_SCU_CCUCON0                     CCUCON0;                /**< \brief 30, CCU Clock Control Register 0*/
       Ifx_SCU_CCUCON1                     CCUCON1;                /**< \brief 34, CCU Clock Control Register 1*/
       Ifx_SCU_FDR                         FDR;                    /**< \brief 38, Fractional Divider Register*/
       Ifx_SCU_EXTCON                      EXTCON;                 /**< \brief 3C, External Clock Control Register*/
       Ifx_SCU_CCUCON2                     CCUCON2;                /**< \brief 40, CCU Clock Control Register 2*/
       Ifx_SCU_CCUCON3                     CCUCON3;                /**< \brief 44, CCU Clock Control Register 3*/
       Ifx_SCU_CCUCON4                     CCUCON4;                /**< \brief 48, CCU Clock Control Register 4*/
       Ifx_SCU_CCUCON5                     CCUCON5;                /**< \brief 4C, CCU Clock Control Register 5*/
       Ifx_SCU_RSTSTAT                     RSTSTAT;                /**< \brief 50, */
       Ifx_UReg_8Bit                       reserved_54[4];         /**< \brief 54, \internal Reserved */
       Ifx_SCU_RSTCON                      RSTCON;                 /**< \brief 58, */
       Ifx_SCU_ARSTDIS                     ARSTDIS;                /**< \brief 5C, */
       Ifx_SCU_SWRSTCON                    SWRSTCON;               /**< \brief 60, */
       Ifx_SCU_RSTCON2                     RSTCON2;                /**< \brief 64, */
       Ifx_SCU_RSTCON3                     RSTCON3;                /**< \brief 68, */
       Ifx_UReg_8Bit                       reserved_6C[4];         /**< \brief 6C, \internal Reserved */
       Ifx_SCU_ESRCFGX                     ESRCFGX[2];             /**< \brief 70, ESR${x} Input Configuration Register*/
       Ifx_SCU_ESROCFG                     ESROCFG;                /**< \brief 78, ESR Output Configuration Register*/
       Ifx_SCU_SYSCON                      SYSCON;                 /**< \brief 7C, System Control Register*/
       Ifx_SCU_CCUCON6                     CCUCON6;                /**< \brief 80, CCU Clock Control Register 6*/
       Ifx_SCU_CCUCON7                     CCUCON7;                /**< \brief 84, CCU Clock Control Register 7*/
       Ifx_SCU_CCUCON8                     CCUCON8;                /**< \brief 88, CCU Clock Control Register 8*/
       Ifx_SCU_CCUCON9                     CCUCON9;                /**< \brief 8C, CCU Clock Control Register 9*/
       Ifx_UReg_8Bit                       reserved_90[12];        /**< \brief 90, \internal Reserved */
       Ifx_SCU_PDR                         PDR;                    /**< \brief 9C, ESR Pad Driver Mode Register*/
       Ifx_SCU_IOCR                        IOCR;                   /**< \brief A0, Input/Output Control Register*/
       Ifx_SCU_OUT                         OUT;                    /**< \brief A4, ESR Output Register*/
       Ifx_SCU_OMR                         OMR;                    /**< \brief A8, ESR Output Modification Register*/
       Ifx_SCU_IN                          IN;                     /**< \brief AC, ESR Input Register*/
       Ifx_UReg_8Bit                       reserved_B0[16];        /**< \brief B0, \internal Reserved */
       Ifx_SCU_STSTAT                      STSTAT;                 /**< \brief C0, */
       Ifx_SCU_STCON                       STCON;                  /**< \brief C4, Start-up Configuration Register*/
       Ifx_SCU_PMCSR0                      PMCSR0;                 /**< \brief C8, Power Management Control and Status Register*/
       Ifx_SCU_PMCSR1                      PMCSR1;                 /**< \brief CC, Power Management Control and Status Register*/
       Ifx_SCU_PMCSR2                      PMCSR2;                 /**< \brief D0, Power Management Control and Status Register*/
       Ifx_SCU_PMCSR3                      PMCSR3;                 /**< \brief D4, Power Management Control and Status Register*/
       Ifx_SCU_PMCSR4                      PMCSR4;                 /**< \brief D8, Power Management Control and Status Register*/
       Ifx_SCU_PMCSR5                      PMCSR5;                 /**< \brief DC, Power Management Control and Status Register*/
       Ifx_UReg_8Bit                       reserved_E0[4];         /**< \brief E0, \internal Reserved */
       Ifx_SCU_PMSTAT0                     PMSTAT0;                /**< \brief E4, Power Management Status Register 0*/
       Ifx_SCU_PMSWCR1                     PMSWCR1;                /**< \brief E8, Standby and Wake-up Control Register 1*/
       Ifx_UReg_8Bit                       reserved_EC[16];        /**< \brief EC, \internal Reserved */
       Ifx_SCU_EMSR                        EMSR;                   /**< \brief FC, Emergency Stop Register*/
       Ifx_SCU_EMSSW                       EMSSW;                  /**< \brief 100, Emergency Stop Software set and clear register*/
       Ifx_SCU_DTSCSTAT                    DTSCSTAT;               /**< \brief 104, Core Die Temperature Sensor Status Register*/
       Ifx_SCU_DTSCLIM                     DTSCLIM;                /**< \brief 108, Core Die Temperature Sensor Limit Register*/
       Ifx_UReg_8Bit                       reserved_10C[20];       /**< \brief 10C, \internal Reserved */
       Ifx_SCU_TRAPDIS1                    TRAPDIS1;               /**< \brief 120, Trap Disable Register 1*/
       Ifx_SCU_TRAPSTAT                    TRAPSTAT;               /**< \brief 124, Trap Status Register*/
       Ifx_SCU_TRAPSET                     TRAPSET;                /**< \brief 128, Trap Set Register*/
       Ifx_SCU_TRAPCLR                     TRAPCLR;                /**< \brief 12C, Trap Clear Register*/
       Ifx_SCU_TRAPDIS0                    TRAPDIS0;               /**< \brief 130, Trap Disable Register 0*/
       Ifx_SCU_LCLCON0                     LCLCON0;                /**< \brief 134, LCL CPU0 and CPU2 Control Register*/
       Ifx_SCU_LCLCON1                     LCLCON1;                /**< \brief 138, LCL CPU1 and CPU3 Control Register*/
       Ifx_SCU_LCLTEST                     LCLTEST;                /**< \brief 13C, LCL Test Register*/
       Ifx_SCU_CHIPID                      CHIPID;                 /**< \brief 140, Chip Identification Register*/
       Ifx_SCU_MANID                       MANID;                  /**< \brief 144, Manufacturer Identification Register*/
       Ifx_UReg_8Bit                       reserved_148[4];        /**< \brief 148, \internal Reserved */
       Ifx_SCU_SWAPCTRL                    SWAPCTRL;               /**< \brief 14C, Address Map Control Register*/
       Ifx_UReg_8Bit                       reserved_150[20];       /**< \brief 150, \internal Reserved */
       Ifx_SCU_LBISTCTRL0                  LBISTCTRL0;             /**< \brief 164, Logic BIST Control 0 Register*/
       Ifx_SCU_LBISTCTRL1                  LBISTCTRL1;             /**< \brief 168, Logic BIST Control 1 Register*/
       Ifx_SCU_LBISTCTRL2                  LBISTCTRL2;             /**< \brief 16C, Logic BIST Control 2 Register*/
       Ifx_SCU_LBISTCTRL3                  LBISTCTRL3;             /**< \brief 170, Logic BIST Control 3 Register*/
       Ifx_UReg_8Bit                       reserved_174[16];       /**< \brief 174, \internal Reserved */
       Ifx_SCU_STMEM1                      STMEM1;                 /**< \brief 184, Start-up Memory Register 1*/
       Ifx_SCU_STMEM2                      STMEM2;                 /**< \brief 188, Start-up Memory Register 2*/
       Ifx_SCU_PDISC                       PDISC;                  /**< \brief 18C, Pad Disable Control Register*/
       Ifx_UReg_8Bit                       reserved_190[8];        /**< \brief 190, \internal Reserved */
       Ifx_SCU_PMTRCSR0                    PMTRCSR0;               /**< \brief 198, Power Management Transition Control and Status Register 0*/
       Ifx_SCU_PMTRCSR1                    PMTRCSR1;               /**< \brief 19C, Power Management Transition Control and Status Register 1*/
       Ifx_SCU_PMTRCSR2                    PMTRCSR2;               /**< \brief 1A0, Power Management Transition Control and Status Register 2*/
       Ifx_SCU_PMTRCSR3                    PMTRCSR3;               /**< \brief 1A4, Power Management Transition Control and Status Register 3*/
       Ifx_UReg_8Bit                       reserved_1A8[24];       /**< \brief 1A8, \internal Reserved */
       Ifx_SCU_STMEM3                      STMEM3;                 /**< \brief 1C0, Start-up Memory Register 3*/
       Ifx_SCU_STMEM4                      STMEM4;                 /**< \brief 1C4, Start-up Memory Register 4*/
       Ifx_SCU_STMEM5                      STMEM5;                 /**< \brief 1C8, Start-up Memory Register 5*/
       Ifx_SCU_STMEM6                      STMEM6;                 /**< \brief 1CC, Start-up Memory Register 6*/
       Ifx_UReg_8Bit                       reserved_1D0[16];       /**< \brief 1D0, \internal Reserved */
       Ifx_SCU_OVCENABLE                   OVCENABLE;              /**< \brief 1E0, Overlay Enable Register*/
       Ifx_SCU_OVCCON                      OVCCON;                 /**< \brief 1E4, Overlay Control Register*/
       Ifx_UReg_8Bit                       reserved_1E8[36];       /**< \brief 1E8, \internal Reserved */
       Ifx_SCU_EIFILT                      EIFILT;                 /**< \brief 20C, External Input Filter Register*/
       Ifx_SCU_EICR                        EICR[4];                /**< \brief 210, External Input Channel Register ${i}*/
       Ifx_SCU_EIFR                        EIFR;                   /**< \brief 220, External Input Flag Register*/
       Ifx_SCU_FMR                         FMR;                    /**< \brief 224, Flag Modification Register*/
       Ifx_SCU_PDRR                        PDRR;                   /**< \brief 228, Pattern Detection Result Register*/
       Ifx_SCU_IGCR                        IGCR[4];                /**< \brief 22C, Flag Gating Register ${j}*/
       Ifx_UReg_8Bit                       reserved_23C[16];       /**< \brief 23C, \internal Reserved */
       Ifx_SCU_WDTCPU                      WDTCPU[4];              /**< \brief 24C, */
       Ifx_UReg_8Bit                       reserved_27C[32];       /**< \brief 27C, \internal Reserved */
       Ifx_SCU_EICON0                      EICON0;                 /**< \brief 29C, ENDINIT Global Control Register 0*/
       Ifx_SCU_EICON1                      EICON1;                 /**< \brief 2A0, ENDINIT Global Control Register 1*/
       Ifx_SCU_EISR                        EISR;                   /**< \brief 2A4, ENDINIT Timeout Counter Status Register*/
       Ifx_SCU_WDTS                        WDTS;                   /**< \brief 2A8, Safety WDT Status Register*/
       Ifx_SCU_SEICON0                     SEICON0;                /**< \brief 2B4, Safety ENDINIT Control Register 0*/
       Ifx_SCU_SEICON1                     SEICON1;                /**< \brief 2B8, Safety ENDINIT Control Register 1*/
       Ifx_SCU_SEISR                       SEISR;                  /**< \brief 2BC, Safety ENDINIT Timeout Status Register*/
       Ifx_UReg_8Bit                       reserved_2C0[304];      /**< \brief 2C0, \internal Reserved */
       Ifx_SCU_ACCEN11                     ACCEN11;                /**< \brief 3F0, Access Enable Register 11*/
       Ifx_SCU_ACCEN10                     ACCEN10;                /**< \brief 3F4, Access Enable Register 10*/
       Ifx_SCU_ACCEN01                     ACCEN01;                /**< \brief 3F8, Access Enable Register 01*/
       Ifx_SCU_ACCEN00                     ACCEN00;                /**< \brief 3FC, Access Enable Register 00*/
} Ifx_SCU;

/** \}  */
/******************************************************************************/
/** \}  */


/******************************************************************************/

/******************************************************************************/


#line 57 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\Infra\\Sfr\\TC38A\\_Reg\\IfxScu_reg.h"
/******************************************************************************/

/******************************************************************************/

/******************************************************************************/

/** \addtogroup IfxSfr_Scu_Registers_Cfg_BaseAddress
 * \{  */

/** \brief SCU object */

/** \}  */


/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Scu_Registers_Cfg_Scu
 * \{  */
/** \brief 8, Identification Register */


/** \brief 10, OSC Control Register */


/** \brief 14, System PLL Status Register */


/** \brief 18, System PLL Configuration 0 Register */


/** \brief 1C, System PLL Configuration 1 Register */


/** \brief 20, System PLL Configuration 2 Register */


/** \brief 24, Peripheral PLL Status Register */


/** \brief 28, Peripheral PLL Configuration 0 Register */


/** \brief 2C, Peripheral PLL Configuration 1 Register */


/** \brief 30, CCU Clock Control Register 0 */


/** \brief 34, CCU Clock Control Register 1 */


/** \brief 38, Fractional Divider Register */


/** \brief 3C, External Clock Control Register */


/** \brief 40, CCU Clock Control Register 2 */


/** \brief 44, CCU Clock Control Register 3 */


/** \brief 48, CCU Clock Control Register 4 */


/** \brief 4C, CCU Clock Control Register 5 */


/** \brief 50, Reset Status Register */


/** \brief 58, Reset Configuration Register */


/** \brief 5C, Application Reset Disable Register */


/** \brief 60, Software Reset Configuration Register */


/** \brief 64, Additional Reset Control Register */


/** \brief 68, Reset Configuration Register 3 */


/** \brief 70, ESR0 Input Configuration Register */

/** Alias (User Manual Name) for SCU_ESRCFGX0_ESRCFGX.
* To use register names with standard convension, please use SCU_ESRCFGX0_ESRCFGX.
*/


/** \brief 74, ESR1 Input Configuration Register */

/** Alias (User Manual Name) for SCU_ESRCFGX1_ESRCFGX.
* To use register names with standard convension, please use SCU_ESRCFGX1_ESRCFGX.
*/


/** \brief 78, ESR Output Configuration Register */


/** \brief 7C, System Control Register */


/** \brief 80, CCU Clock Control Register 6 */


/** \brief 84, CCU Clock Control Register 7 */


/** \brief 88, CCU Clock Control Register 8 */


/** \brief 8C, CCU Clock Control Register 9 */


/** \brief 9C, ESR Pad Driver Mode Register */


/** \brief A0, Input/Output Control Register */


/** \brief A4, ESR Output Register */


/** \brief A8, ESR Output Modification Register */


/** \brief AC, ESR Input Register */


/** \brief C0, Start-up Status Register */


/** \brief C4, Start-up Configuration Register */


/** \brief C8, Power Management Control and Status Register */


/** \brief CC, Power Management Control and Status Register */


/** \brief D0, Power Management Control and Status Register */


/** \brief D4, Power Management Control and Status Register */


/** \brief D8, Power Management Control and Status Register */


/** \brief DC, Power Management Control and Status Register */


/** \brief E4, Power Management Status Register 0 */


/** \brief E8, Standby and Wake-up Control Register 1 */


/** \brief FC, Emergency Stop Register */


/** \brief 100, Emergency Stop Software set and clear register */


/** \brief 104, Core Die Temperature Sensor Status Register */


/** \brief 108, Core Die Temperature Sensor Limit Register */


/** \brief 120, Trap Disable Register 1 */


/** \brief 124, Trap Status Register */


/** \brief 128, Trap Set Register */


/** \brief 12C, Trap Clear Register */


/** \brief 130, Trap Disable Register 0 */


/** \brief 134, LCL CPU0 and CPU2 Control Register */


/** \brief 138, LCL CPU1 and CPU3 Control Register */


/** \brief 13C, LCL Test Register */


/** \brief 140, Chip Identification Register */


/** \brief 144, Manufacturer Identification Register */


/** \brief 14C, Address Map Control Register */


/** \brief 164, Logic BIST Control 0 Register */


/** \brief 168, Logic BIST Control 1 Register */


/** \brief 16C, Logic BIST Control 2 Register */


/** \brief 170, Logic BIST Control 3 Register */


/** \brief 184, Start-up Memory Register 1 */


/** \brief 188, Start-up Memory Register 2 */


/** \brief 18C, Pad Disable Control Register */


/** \brief 198, Power Management Transition Control and Status Register 0 */


/** \brief 19C, Power Management Transition Control and Status Register 1 */


/** \brief 1A0, Power Management Transition Control and Status Register 2 */


/** \brief 1A4, Power Management Transition Control and Status Register 3 */


/** \brief 1C0, Start-up Memory Register 3 */


/** \brief 1C4, Start-up Memory Register 4 */


/** \brief 1C8, Start-up Memory Register 5 */


/** \brief 1CC, Start-up Memory Register 6 */


/** \brief 1E0, Overlay Enable Register */


/** \brief 1E4, Overlay Control Register */


/** \brief 20C, External Input Filter Register */


/** \brief 210, External Input Channel Register 0 */


/** \brief 214, External Input Channel Register 1 */


/** \brief 218, External Input Channel Register 2 */


/** \brief 21C, External Input Channel Register 3 */


/** \brief 220, External Input Flag Register */


/** \brief 224, Flag Modification Register */


/** \brief 228, Pattern Detection Result Register */


/** \brief 22C, Flag Gating Register 0 */


/** \brief 230, Flag Gating Register 1 */


/** \brief 234, Flag Gating Register 2 */


/** \brief 238, Flag Gating Register 3 */


/** \brief 24C, CPU0 WDT Control Register 0 */

/** Alias (User Manual Name) for SCU_WDTCPU0_CON0.
* To use register names with standard convension, please use SCU_WDTCPU0_CON0.
*/


/** \brief 250, CPU0 WDT Control Register 1 */

/** Alias (User Manual Name) for SCU_WDTCPU0_CON1.
* To use register names with standard convension, please use SCU_WDTCPU0_CON1.
*/


/** \brief 254, CPU0 WDT Status Register */

/** Alias (User Manual Name) for SCU_WDTCPU0_SR.
* To use register names with standard convension, please use SCU_WDTCPU0_SR.
*/


/** \brief 258, CPU1 WDT Control Register 0 */

/** Alias (User Manual Name) for SCU_WDTCPU1_CON0.
* To use register names with standard convension, please use SCU_WDTCPU1_CON0.
*/


/** \brief 25C, CPU1 WDT Control Register 1 */

/** Alias (User Manual Name) for SCU_WDTCPU1_CON1.
* To use register names with standard convension, please use SCU_WDTCPU1_CON1.
*/


/** \brief 260, CPU1 WDT Status Register */

/** Alias (User Manual Name) for SCU_WDTCPU1_SR.
* To use register names with standard convension, please use SCU_WDTCPU1_SR.
*/


/** \brief 264, CPU2 WDT Control Register 0 */

/** Alias (User Manual Name) for SCU_WDTCPU2_CON0.
* To use register names with standard convension, please use SCU_WDTCPU2_CON0.
*/


/** \brief 268, CPU2 WDT Control Register 1 */

/** Alias (User Manual Name) for SCU_WDTCPU2_CON1.
* To use register names with standard convension, please use SCU_WDTCPU2_CON1.
*/


/** \brief 26C, CPU2 WDT Status Register */

/** Alias (User Manual Name) for SCU_WDTCPU2_SR.
* To use register names with standard convension, please use SCU_WDTCPU2_SR.
*/


/** \brief 270, CPU3 WDT Control Register 0 */

/** Alias (User Manual Name) for SCU_WDTCPU3_CON0.
* To use register names with standard convension, please use SCU_WDTCPU3_CON0.
*/


/** \brief 274, CPU3 WDT Control Register 1 */

/** Alias (User Manual Name) for SCU_WDTCPU3_CON1.
* To use register names with standard convension, please use SCU_WDTCPU3_CON1.
*/


/** \brief 278, CPU3 WDT Status Register */

/** Alias (User Manual Name) for SCU_WDTCPU3_SR.
* To use register names with standard convension, please use SCU_WDTCPU3_SR.
*/


/** \brief 29C, ENDINIT Global Control Register 0 */


/** \brief 2A0, ENDINIT Global Control Register 1 */


/** \brief 2A4, ENDINIT Timeout Counter Status Register */


/** \brief 2A8, Safety WDT Control Register 0 */

/** Alias (User Manual Name) for SCU_WDTS_CON0.
* To use register names with standard convension, please use SCU_WDTS_CON0.
*/


/** \brief 2AC, Safety WDT Control Register 1 */

/** Alias (User Manual Name) for SCU_WDTS_CON1.
* To use register names with standard convension, please use SCU_WDTS_CON1.
*/


/** \brief 2B0, Safety WDT Status Register */

/** Alias (User Manual Name) for SCU_WDTS_SR.
* To use register names with standard convension, please use SCU_WDTS_SR.
*/


/** \brief 2B4, Safety ENDINIT Control Register 0 */


/** \brief 2B8, Safety ENDINIT Control Register 1 */


/** \brief 2BC, Safety ENDINIT Timeout Status Register */


/** \brief 3F0, Access Enable Register 11 */


/** \brief 3F4, Access Enable Register 10 */


/** \brief 3F8, Access Enable Register 01 */


/** \brief 3FC, Access Enable Register 00 */



/** \}  */

/******************************************************************************/

/******************************************************************************/


#line 72 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\ee\\..\\Libraries\\iLLD\\TC38A\\Tricore\\Cpu\\Std\\IfxCpu.h"

#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\Infra\\Sfr\\TC38A\\_Reg\\IfxStm_reg.h"
/**
 * \file IfxStm_reg.h
 * \brief
 * \copyright Copyright (c) 2020 Infineon Technologies AG. All rights reserved.
 *
 *
 * Version: TC38XA_UM_V1.5.0
 * Specification: TC3xx User Manual V1.5.0
 * MAY BE CHANGED BY USER [yes/no]: No
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * \defgroup IfxSfr_Stm_Registers_Cfg Stm address
 * \ingroup IfxSfr_Stm_Registers
 * 
 * \defgroup IfxSfr_Stm_Registers_Cfg_BaseAddress Base address
 * \ingroup IfxSfr_Stm_Registers_Cfg
 *
 * \defgroup IfxSfr_Stm_Registers_Cfg_Stm0 2-STM0
 * \ingroup IfxSfr_Stm_Registers_Cfg
 *
 * \defgroup IfxSfr_Stm_Registers_Cfg_Stm1 2-STM1
 * \ingroup IfxSfr_Stm_Registers_Cfg
 *
 * \defgroup IfxSfr_Stm_Registers_Cfg_Stm2 2-STM2
 * \ingroup IfxSfr_Stm_Registers_Cfg
 *
 * \defgroup IfxSfr_Stm_Registers_Cfg_Stm3 2-STM3
 * \ingroup IfxSfr_Stm_Registers_Cfg
 *
 *
 */


/******************************************************************************/

#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\Infra\\Sfr\\TC38A\\_Reg\\IfxStm_regdef.h"
/**
 * \file IfxStm_regdef.h
 * \brief
 * \copyright Copyright (c) 2020 Infineon Technologies AG. All rights reserved.
 *
 *
 * Version: TC38XA_UM_V1.5.0
 * Specification: TC3xx User Manual V1.5.0
 * MAY BE CHANGED BY USER [yes/no]: No
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * \defgroup IfxSfr_Stm_Registers Stm Registers
 * \ingroup IfxSfr
 * 
 * \defgroup IfxSfr_Stm_Registers_Bitfields Bitfields
 * \ingroup IfxSfr_Stm_Registers
 * 
 * \defgroup IfxSfr_Stm_Registers_union Register unions
 * \ingroup IfxSfr_Stm_Registers
 * 
 * \defgroup IfxSfr_Stm_Registers_struct Memory map
 * \ingroup IfxSfr_Stm_Registers
 */


/******************************************************************************/

/******************************************************************************/

/******************************************************************************/

/******************************************************************************/


/** \addtogroup IfxSfr_Stm_Registers_Bitfields
 * \{  */
/** \brief Access Enable Register 0 */
typedef struct _Ifx_STM_ACCEN0_Bits
{
    Ifx_UReg_32Bit EN0:1;             /**< \brief [0:0] Access Enable for Master TAG ID 0 - EN0 (rw) */
    Ifx_UReg_32Bit EN1:1;             /**< \brief [1:1] Access Enable for Master TAG ID 1 - EN1 (rw) */
    Ifx_UReg_32Bit EN2:1;             /**< \brief [2:2] Access Enable for Master TAG ID 2 - EN2 (rw) */
    Ifx_UReg_32Bit EN3:1;             /**< \brief [3:3] Access Enable for Master TAG ID 3 - EN3 (rw) */
    Ifx_UReg_32Bit EN4:1;             /**< \brief [4:4] Access Enable for Master TAG ID 4 - EN4 (rw) */
    Ifx_UReg_32Bit EN5:1;             /**< \brief [5:5] Access Enable for Master TAG ID 5 - EN5 (rw) */
    Ifx_UReg_32Bit EN6:1;             /**< \brief [6:6] Access Enable for Master TAG ID 6 - EN6 (rw) */
    Ifx_UReg_32Bit EN7:1;             /**< \brief [7:7] Access Enable for Master TAG ID 7 - EN7 (rw) */
    Ifx_UReg_32Bit EN8:1;             /**< \brief [8:8] Access Enable for Master TAG ID 8 - EN8 (rw) */
    Ifx_UReg_32Bit EN9:1;             /**< \brief [9:9] Access Enable for Master TAG ID 9 - EN9 (rw) */
    Ifx_UReg_32Bit EN10:1;            /**< \brief [10:10] Access Enable for Master TAG ID 10 - EN10 (rw) */
    Ifx_UReg_32Bit EN11:1;            /**< \brief [11:11] Access Enable for Master TAG ID 11 - EN11 (rw) */
    Ifx_UReg_32Bit EN12:1;            /**< \brief [12:12] Access Enable for Master TAG ID 12 - EN12 (rw) */
    Ifx_UReg_32Bit EN13:1;            /**< \brief [13:13] Access Enable for Master TAG ID 13 - EN13 (rw) */
    Ifx_UReg_32Bit EN14:1;            /**< \brief [14:14] Access Enable for Master TAG ID 14 - EN14 (rw) */
    Ifx_UReg_32Bit EN15:1;            /**< \brief [15:15] Access Enable for Master TAG ID 15 - EN15 (rw) */
    Ifx_UReg_32Bit EN16:1;            /**< \brief [16:16] Access Enable for Master TAG ID 16 - EN16 (rw) */
    Ifx_UReg_32Bit EN17:1;            /**< \brief [17:17] Access Enable for Master TAG ID 17 - EN17 (rw) */
    Ifx_UReg_32Bit EN18:1;            /**< \brief [18:18] Access Enable for Master TAG ID 18 - EN18 (rw) */
    Ifx_UReg_32Bit EN19:1;            /**< \brief [19:19] Access Enable for Master TAG ID 19 - EN19 (rw) */
    Ifx_UReg_32Bit EN20:1;            /**< \brief [20:20] Access Enable for Master TAG ID 20 - EN20 (rw) */
    Ifx_UReg_32Bit EN21:1;            /**< \brief [21:21] Access Enable for Master TAG ID 21 - EN21 (rw) */
    Ifx_UReg_32Bit EN22:1;            /**< \brief [22:22] Access Enable for Master TAG ID 22 - EN22 (rw) */
    Ifx_UReg_32Bit EN23:1;            /**< \brief [23:23] Access Enable for Master TAG ID 23 - EN23 (rw) */
    Ifx_UReg_32Bit EN24:1;            /**< \brief [24:24] Access Enable for Master TAG ID 24 - EN24 (rw) */
    Ifx_UReg_32Bit EN25:1;            /**< \brief [25:25] Access Enable for Master TAG ID 25 - EN25 (rw) */
    Ifx_UReg_32Bit EN26:1;            /**< \brief [26:26] Access Enable for Master TAG ID 26 - EN26 (rw) */
    Ifx_UReg_32Bit EN27:1;            /**< \brief [27:27] Access Enable for Master TAG ID 27 - EN27 (rw) */
    Ifx_UReg_32Bit EN28:1;            /**< \brief [28:28] Access Enable for Master TAG ID 28 - EN28 (rw) */
    Ifx_UReg_32Bit EN29:1;            /**< \brief [29:29] Access Enable for Master TAG ID 29 - EN29 (rw) */
    Ifx_UReg_32Bit EN30:1;            /**< \brief [30:30] Access Enable for Master TAG ID 30 - EN30 (rw) */
    Ifx_UReg_32Bit EN31:1;            /**< \brief [31:31] Access Enable for Master TAG ID 31 - EN31 (rw) */
} Ifx_STM_ACCEN0_Bits;

/** \brief Access Enable Register 1 */
typedef struct _Ifx_STM_ACCEN1_Bits
{
    Ifx_UReg_32Bit reserved_0:32;     /**< \brief [31:0] \internal Reserved */
} Ifx_STM_ACCEN1_Bits;

/** \brief Timer Capture Register */
typedef struct _Ifx_STM_CAP_Bits
{
    Ifx_UReg_32Bit STMCAP_63_32:32;    /**< \brief [31:0] Captured System Timer Bits [63:32] - STMCAP[63:32] (rh) */
} Ifx_STM_CAP_Bits;

/** \brief Timer Capture Register Second View */
typedef struct _Ifx_STM_CAPSV_Bits
{
    Ifx_UReg_32Bit STMCAP_63_32:32;    /**< \brief [31:0] Captured System Timer Bits [63:32] - STMCAP[63:32] (rh) */
} Ifx_STM_CAPSV_Bits;

/** \brief Clock Control Register */
typedef struct _Ifx_STM_CLC_Bits
{
    Ifx_UReg_32Bit DISR:1;            /**< \brief [0:0] Module Disable Request Bit - DISR (rw) */
    Ifx_UReg_32Bit DISS:1;            /**< \brief [1:1] Module Disable Status Bit - DISS (r) */
    Ifx_UReg_32Bit reserved_2:1;      /**< \brief [2:2] \internal Reserved */
    Ifx_UReg_32Bit EDIS:1;            /**< \brief [3:3] Sleep Mode Enable Control - EDIS (rw) */
    Ifx_UReg_32Bit reserved_4:28;     /**< \brief [31:4] \internal Reserved */
} Ifx_STM_CLC_Bits;

/** \brief Compare Match Control Register */
typedef struct _Ifx_STM_CMCON_Bits
{
    Ifx_UReg_32Bit MSIZE0:5;          /**< \brief [4:0] Compare Register Size for CMP0 - MSIZE0 (rw) */
    Ifx_UReg_32Bit reserved_5:3;      /**< \brief [7:5] \internal Reserved */
    Ifx_UReg_32Bit MSTART0:5;         /**< \brief [12:8] Start Bit Location for CMP0 - MSTART0 (rw) */
    Ifx_UReg_32Bit reserved_13:3;     /**< \brief [15:13] \internal Reserved */
    Ifx_UReg_32Bit MSIZE1:5;          /**< \brief [20:16] Compare Register Size for CMP1 - MSIZE1 (rw) */
    Ifx_UReg_32Bit reserved_21:3;     /**< \brief [23:21] \internal Reserved */
    Ifx_UReg_32Bit MSTART1:5;         /**< \brief [28:24] Start Bit Location for CMP1 - MSTART1 (rw) */
    Ifx_UReg_32Bit reserved_29:3;     /**< \brief [31:29] \internal Reserved */
} Ifx_STM_CMCON_Bits;

/** \brief Compare Register ${x} */
typedef struct _Ifx_STM_CMP_Bits
{
    Ifx_UReg_32Bit CMPVAL:32;         /**< \brief [31:0] Compare Value of Compare Register x - CMPVAL (rw) */
} Ifx_STM_CMP_Bits;

/** \brief Interrupt Control Register */
typedef struct _Ifx_STM_ICR_Bits
{
    Ifx_UReg_32Bit CMP0EN:1;          /**< \brief [0:0] Compare Register CMP0 Interrupt Enable Control - CMP0EN (rw) */
    Ifx_UReg_32Bit CMP0IR:1;          /**< \brief [1:1] Compare Register CMP0 Interrupt Request Flag - CMP0IR (rh) */
    Ifx_UReg_32Bit CMP0OS:1;          /**< \brief [2:2] Compare Register CMP0 Interrupt Output Selection - CMP0OS (rw) */
    Ifx_UReg_32Bit reserved_3:1;      /**< \brief [3:3] \internal Reserved */
    Ifx_UReg_32Bit CMP1EN:1;          /**< \brief [4:4] Compare Register CMP1 Interrupt Enable Control - CMP1EN (rw) */
    Ifx_UReg_32Bit CMP1IR:1;          /**< \brief [5:5] Compare Register CMP1 Interrupt Request Flag - CMP1IR (rh) */
    Ifx_UReg_32Bit CMP1OS:1;          /**< \brief [6:6] Compare Register CMP1 Interrupt Output Selection - CMP1OS (rw) */
    Ifx_UReg_32Bit reserved_7:25;     /**< \brief [31:7] \internal Reserved */
} Ifx_STM_ICR_Bits;

/** \brief Module Identification Register */
typedef struct _Ifx_STM_ID_Bits
{
    Ifx_UReg_32Bit MODREV:8;          /**< \brief [7:0] Module Revision Number - MODREV (r) */
    Ifx_UReg_32Bit MODTYPE:8;         /**< \brief [15:8] Module Type - MODTYPE (r) */
    Ifx_UReg_32Bit MODNUM:16;         /**< \brief [31:16] Module Number Value - MODNUM (r) */
} Ifx_STM_ID_Bits;

/** \brief Interrupt Set/Clear Register */
typedef struct _Ifx_STM_ISCR_Bits
{
    Ifx_UReg_32Bit CMP0IRR:1;         /**< \brief [0:0] Reset Compare Register CMP0 Interrupt Flag - CMP0IRR (w) */
    Ifx_UReg_32Bit CMP0IRS:1;         /**< \brief [1:1] Set Compare Register CMP0 Interrupt Flag - CMP0IRS (w) */
    Ifx_UReg_32Bit CMP1IRR:1;         /**< \brief [2:2] Reset Compare Register CMP1 Interrupt Flag - CMP1IRR (w) */
    Ifx_UReg_32Bit CMP1IRS:1;         /**< \brief [3:3] Set Compare Register CMP1 Interrupt Flag - CMP1IRS (w) */
    Ifx_UReg_32Bit reserved_4:28;     /**< \brief [31:4] \internal Reserved */
} Ifx_STM_ISCR_Bits;

/** \brief Kernel Reset Register 0 */
typedef struct _Ifx_STM_KRST0_Bits
{
    Ifx_UReg_32Bit RST:1;             /**< \brief [0:0] Kernel Reset - RST (rwh) */
    Ifx_UReg_32Bit RSTSTAT:1;         /**< \brief [1:1] Kernel Reset Status - RSTSTAT (rh) */
    Ifx_UReg_32Bit reserved_2:30;     /**< \brief [31:2] \internal Reserved */
} Ifx_STM_KRST0_Bits;

/** \brief Kernel Reset Register 1 */
typedef struct _Ifx_STM_KRST1_Bits
{
    Ifx_UReg_32Bit RST:1;             /**< \brief [0:0] Kernel Reset - RST (rwh) */
    Ifx_UReg_32Bit reserved_1:31;     /**< \brief [31:1] \internal Reserved */
} Ifx_STM_KRST1_Bits;

/** \brief Kernel Reset Status Clear Register */
typedef struct _Ifx_STM_KRSTCLR_Bits
{
    Ifx_UReg_32Bit CLR:1;             /**< \brief [0:0] Kernel Reset Status Clear - CLR (w) */
    Ifx_UReg_32Bit reserved_1:31;     /**< \brief [31:1] \internal Reserved */
} Ifx_STM_KRSTCLR_Bits;

/** \brief OCDS Control and Status Register */
typedef struct _Ifx_STM_OCS_Bits
{
    Ifx_UReg_32Bit reserved_0:3;      /**< \brief [2:0] \internal Reserved */
    Ifx_UReg_32Bit reserved_3:21;     /**< \brief [23:3] \internal Reserved */
    Ifx_UReg_32Bit SUS:4;             /**< \brief [27:24] OCDS Suspend Control - SUS (rw) */
    Ifx_UReg_32Bit SUS_P:1;           /**< \brief [28:28] SUS Write Protection - SUS_P (w) */
    Ifx_UReg_32Bit SUSSTA:1;          /**< \brief [29:29] Suspend State - SUSSTA (rh) */
    Ifx_UReg_32Bit reserved_30:2;     /**< \brief [31:30] \internal Reserved */
} Ifx_STM_OCS_Bits;

/** \brief Timer Register 0 */
typedef struct _Ifx_STM_TIM0_Bits
{
    Ifx_UReg_32Bit STM_31_0:32;       /**< \brief [31:0] System Timer Bits [31:0] - STM[31:0] (r) */
} Ifx_STM_TIM0_Bits;

/** \brief Timer Register 0 Second View */
typedef struct _Ifx_STM_TIM0SV_Bits
{
    Ifx_UReg_32Bit STM_31_0:32;       /**< \brief [31:0] System Timer Bits [31:0] - STM[31:0] (r) */
} Ifx_STM_TIM0SV_Bits;

/** \brief Timer Register 1 */
typedef struct _Ifx_STM_TIM1_Bits
{
    Ifx_UReg_32Bit STM_35_4:32;       /**< \brief [31:0] System Timer Bits [35:4] - STM[35:4] (r) */
} Ifx_STM_TIM1_Bits;

/** \brief Timer Register 2 */
typedef struct _Ifx_STM_TIM2_Bits
{
    Ifx_UReg_32Bit STM_39_8:32;       /**< \brief [31:0] System Timer Bits [39:8] - STM[39:8] (r) */
} Ifx_STM_TIM2_Bits;

/** \brief Timer Register 3 */
typedef struct _Ifx_STM_TIM3_Bits
{
    Ifx_UReg_32Bit STM_43_12:32;      /**< \brief [31:0] System Timer Bits [43:12] - STM[43:12] (r) */
} Ifx_STM_TIM3_Bits;

/** \brief Timer Register 4 */
typedef struct _Ifx_STM_TIM4_Bits
{
    Ifx_UReg_32Bit STM_47_16:32;      /**< \brief [31:0] System Timer Bits [47:16] - STM[47:16] (r) */
} Ifx_STM_TIM4_Bits;

/** \brief Timer Register 5 */
typedef struct _Ifx_STM_TIM5_Bits
{
    Ifx_UReg_32Bit STM_51_20:32;      /**< \brief [31:0] System Timer Bits [51:20] - STM[51:20] (r) */
} Ifx_STM_TIM5_Bits;

/** \brief Timer Register 6 */
typedef struct _Ifx_STM_TIM6_Bits
{
    Ifx_UReg_32Bit STM_63_32:32;      /**< \brief [31:0] System Timer Bits [63:32] - STM[63:32] (r) */
} Ifx_STM_TIM6_Bits;

/** \}  */
/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_stm_Registers_union
 * \{   */
/** \brief Access Enable Register 0   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_STM_ACCEN0_Bits B;            /**< \brief Bitfield access */
} Ifx_STM_ACCEN0;

/** \brief Access Enable Register 1   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_STM_ACCEN1_Bits B;            /**< \brief Bitfield access */
} Ifx_STM_ACCEN1;

/** \brief Timer Capture Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_STM_CAP_Bits B;               /**< \brief Bitfield access */
} Ifx_STM_CAP;

/** \brief Timer Capture Register Second View   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_STM_CAPSV_Bits B;             /**< \brief Bitfield access */
} Ifx_STM_CAPSV;

/** \brief Clock Control Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_STM_CLC_Bits B;               /**< \brief Bitfield access */
} Ifx_STM_CLC;

/** \brief Compare Match Control Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_STM_CMCON_Bits B;             /**< \brief Bitfield access */
} Ifx_STM_CMCON;

/** \brief Compare Register ${x}   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_STM_CMP_Bits B;               /**< \brief Bitfield access */
} Ifx_STM_CMP;

/** \brief Interrupt Control Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_STM_ICR_Bits B;               /**< \brief Bitfield access */
} Ifx_STM_ICR;

/** \brief Module Identification Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_STM_ID_Bits B;                /**< \brief Bitfield access */
} Ifx_STM_ID;

/** \brief Interrupt Set/Clear Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_STM_ISCR_Bits B;              /**< \brief Bitfield access */
} Ifx_STM_ISCR;

/** \brief Kernel Reset Register 0   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_STM_KRST0_Bits B;             /**< \brief Bitfield access */
} Ifx_STM_KRST0;

/** \brief Kernel Reset Register 1   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_STM_KRST1_Bits B;             /**< \brief Bitfield access */
} Ifx_STM_KRST1;

/** \brief Kernel Reset Status Clear Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_STM_KRSTCLR_Bits B;           /**< \brief Bitfield access */
} Ifx_STM_KRSTCLR;

/** \brief OCDS Control and Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_STM_OCS_Bits B;               /**< \brief Bitfield access */
} Ifx_STM_OCS;

/** \brief Timer Register 0   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_STM_TIM0_Bits B;              /**< \brief Bitfield access */
} Ifx_STM_TIM0;

/** \brief Timer Register 0 Second View   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_STM_TIM0SV_Bits B;            /**< \brief Bitfield access */
} Ifx_STM_TIM0SV;

/** \brief Timer Register 1   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_STM_TIM1_Bits B;              /**< \brief Bitfield access */
} Ifx_STM_TIM1;

/** \brief Timer Register 2   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_STM_TIM2_Bits B;              /**< \brief Bitfield access */
} Ifx_STM_TIM2;

/** \brief Timer Register 3   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_STM_TIM3_Bits B;              /**< \brief Bitfield access */
} Ifx_STM_TIM3;

/** \brief Timer Register 4   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_STM_TIM4_Bits B;              /**< \brief Bitfield access */
} Ifx_STM_TIM4;

/** \brief Timer Register 5   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_STM_TIM5_Bits B;              /**< \brief Bitfield access */
} Ifx_STM_TIM5;

/** \brief Timer Register 6   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_STM_TIM6_Bits B;              /**< \brief Bitfield access */
} Ifx_STM_TIM6;

/** \}  */

/******************************************************************************/
/** \addtogroup IfxSfr_Stm_Registers_struct
 * \{  */
/******************************************************************************/
/** \name Object L0
 * \{  */

/** \brief STM object */
typedef volatile struct _Ifx_STM
{
       Ifx_STM_CLC                         CLC;                    /**< \brief 0, Clock Control Register*/
       Ifx_UReg_8Bit                       reserved_4[4];          /**< \brief 4, \internal Reserved */
       Ifx_STM_ID                          ID;                     /**< \brief 8, Module Identification Register*/
       Ifx_UReg_8Bit                       reserved_C[4];          /**< \brief C, \internal Reserved */
       Ifx_STM_TIM0                        TIM0;                   /**< \brief 10, Timer Register 0*/
       Ifx_STM_TIM1                        TIM1;                   /**< \brief 14, Timer Register 1*/
       Ifx_STM_TIM2                        TIM2;                   /**< \brief 18, Timer Register 2*/
       Ifx_STM_TIM3                        TIM3;                   /**< \brief 1C, Timer Register 3*/
       Ifx_STM_TIM4                        TIM4;                   /**< \brief 20, Timer Register 4*/
       Ifx_STM_TIM5                        TIM5;                   /**< \brief 24, Timer Register 5*/
       Ifx_STM_TIM6                        TIM6;                   /**< \brief 28, Timer Register 6*/
       Ifx_STM_CAP                         CAP;                    /**< \brief 2C, Timer Capture Register*/
       Ifx_STM_CMP                         CMP[2];                 /**< \brief 30, Compare Register ${x}*/
       Ifx_STM_CMCON                       CMCON;                  /**< \brief 38, Compare Match Control Register*/
       Ifx_STM_ICR                         ICR;                    /**< \brief 3C, Interrupt Control Register*/
       Ifx_STM_ISCR                        ISCR;                   /**< \brief 40, Interrupt Set/Clear Register*/
       Ifx_UReg_8Bit                       reserved_44[12];        /**< \brief 44, \internal Reserved */
       Ifx_STM_TIM0SV                      TIM0SV;                 /**< \brief 50, Timer Register 0 Second View*/
       Ifx_STM_CAPSV                       CAPSV;                  /**< \brief 54, Timer Capture Register Second View*/
       Ifx_UReg_8Bit                       reserved_58[144];       /**< \brief 58, \internal Reserved */
       Ifx_STM_OCS                         OCS;                    /**< \brief E8, OCDS Control and Status Register*/
       Ifx_STM_KRSTCLR                     KRSTCLR;                /**< \brief EC, Kernel Reset Status Clear Register*/
       Ifx_STM_KRST1                       KRST1;                  /**< \brief F0, Kernel Reset Register 1*/
       Ifx_STM_KRST0                       KRST0;                  /**< \brief F4, Kernel Reset Register 0*/
       Ifx_STM_ACCEN1                      ACCEN1;                 /**< \brief F8, Access Enable Register 1*/
       Ifx_STM_ACCEN0                      ACCEN0;                 /**< \brief FC, Access Enable Register 0*/
} Ifx_STM;

/** \}  */
/******************************************************************************/
/** \}  */


/******************************************************************************/

/******************************************************************************/


#line 66 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\Infra\\Sfr\\TC38A\\_Reg\\IfxStm_reg.h"
/******************************************************************************/

/******************************************************************************/

/******************************************************************************/

/** \addtogroup IfxSfr_Stm_Registers_Cfg_BaseAddress
 * \{  */

/** \brief STM object */




/** \}  */


/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Stm_Registers_Cfg_Stm0
 * \{  */
/** \brief 0, Clock Control Register */


/** \brief 8, Module Identification Register */


/** \brief 10, Timer Register 0 */


/** \brief 14, Timer Register 1 */


/** \brief 18, Timer Register 2 */


/** \brief 1C, Timer Register 3 */


/** \brief 20, Timer Register 4 */


/** \brief 24, Timer Register 5 */


/** \brief 28, Timer Register 6 */


/** \brief 2C, Timer Capture Register */


/** \brief 30, Compare Register 0 */


/** \brief 34, Compare Register 1 */


/** \brief 38, Compare Match Control Register */


/** \brief 3C, Interrupt Control Register */


/** \brief 40, Interrupt Set/Clear Register */


/** \brief 50, Timer Register 0 Second View */


/** \brief 54, Timer Capture Register Second View */


/** \brief E8, OCDS Control and Status Register */


/** \brief EC, Kernel Reset Status Clear Register */


/** \brief F0, Kernel Reset Register 1 */


/** \brief F4, Kernel Reset Register 0 */


/** \brief F8, Access Enable Register 1 */


/** \brief FC, Access Enable Register 0 */


/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Stm_Registers_Cfg_Stm1
 * \{  */
/** \brief 0, Clock Control Register */


/** \brief 8, Module Identification Register */


/** \brief 10, Timer Register 0 */


/** \brief 14, Timer Register 1 */


/** \brief 18, Timer Register 2 */


/** \brief 1C, Timer Register 3 */


/** \brief 20, Timer Register 4 */


/** \brief 24, Timer Register 5 */


/** \brief 28, Timer Register 6 */


/** \brief 2C, Timer Capture Register */


/** \brief 30, Compare Register 0 */


/** \brief 34, Compare Register 1 */


/** \brief 38, Compare Match Control Register */


/** \brief 3C, Interrupt Control Register */


/** \brief 40, Interrupt Set/Clear Register */


/** \brief 50, Timer Register 0 Second View */


/** \brief 54, Timer Capture Register Second View */


/** \brief E8, OCDS Control and Status Register */


/** \brief EC, Kernel Reset Status Clear Register */


/** \brief F0, Kernel Reset Register 1 */


/** \brief F4, Kernel Reset Register 0 */


/** \brief F8, Access Enable Register 1 */


/** \brief FC, Access Enable Register 0 */


/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Stm_Registers_Cfg_Stm2
 * \{  */
/** \brief 0, Clock Control Register */


/** \brief 8, Module Identification Register */


/** \brief 10, Timer Register 0 */


/** \brief 14, Timer Register 1 */


/** \brief 18, Timer Register 2 */


/** \brief 1C, Timer Register 3 */


/** \brief 20, Timer Register 4 */


/** \brief 24, Timer Register 5 */


/** \brief 28, Timer Register 6 */


/** \brief 2C, Timer Capture Register */


/** \brief 30, Compare Register 0 */


/** \brief 34, Compare Register 1 */


/** \brief 38, Compare Match Control Register */


/** \brief 3C, Interrupt Control Register */


/** \brief 40, Interrupt Set/Clear Register */


/** \brief 50, Timer Register 0 Second View */


/** \brief 54, Timer Capture Register Second View */


/** \brief E8, OCDS Control and Status Register */


/** \brief EC, Kernel Reset Status Clear Register */


/** \brief F0, Kernel Reset Register 1 */


/** \brief F4, Kernel Reset Register 0 */


/** \brief F8, Access Enable Register 1 */


/** \brief FC, Access Enable Register 0 */


/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Stm_Registers_Cfg_Stm3
 * \{  */
/** \brief 0, Clock Control Register */


/** \brief 8, Module Identification Register */


/** \brief 10, Timer Register 0 */


/** \brief 14, Timer Register 1 */


/** \brief 18, Timer Register 2 */


/** \brief 1C, Timer Register 3 */


/** \brief 20, Timer Register 4 */


/** \brief 24, Timer Register 5 */


/** \brief 28, Timer Register 6 */


/** \brief 2C, Timer Capture Register */


/** \brief 30, Compare Register 0 */


/** \brief 34, Compare Register 1 */


/** \brief 38, Compare Match Control Register */


/** \brief 3C, Interrupt Control Register */


/** \brief 40, Interrupt Set/Clear Register */


/** \brief 50, Timer Register 0 Second View */


/** \brief 54, Timer Capture Register Second View */


/** \brief E8, OCDS Control and Status Register */


/** \brief EC, Kernel Reset Status Clear Register */


/** \brief F0, Kernel Reset Register 1 */


/** \brief F4, Kernel Reset Register 0 */


/** \brief F8, Access Enable Register 1 */


/** \brief FC, Access Enable Register 0 */



/** \}  */

/******************************************************************************/

/******************************************************************************/


#line 73 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\ee\\..\\Libraries\\iLLD\\TC38A\\Tricore\\Cpu\\Std\\IfxCpu.h"

#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\_Impl\\IfxScu_cfg.h"
/**
 * \file IfxScu_cfg.h
 * \brief SCU on-chip implementation data
 * \ingroup IfxLld_Scu
 *
 * \version iLLD_1_0_1_15_0_1
 * \copyright Copyright (c) 2012 Infineon Technologies AG. All rights reserved.
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * \defgroup IfxLld_Scu SCU
 * \ingroup IfxLld
 * \defgroup IfxLld_Scu_Impl Implementation
 * \ingroup IfxLld_Scu
 * \defgroup IfxLld_Scu_Std Standard Driver
 * \ingroup IfxLld_Scu
 */



/******************************************************************************/


#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\Infra\\Sfr\\TC38A\\_Reg\\IfxScu_bf.h"
/**
 * \file IfxScu_bf.h
 * \brief
 * \copyright Copyright (c) 2020 Infineon Technologies AG. All rights reserved.
 *
 *
 * Version: TC38XA_UM_V1.5.0
 * Specification: TC3xx User Manual V1.5.0
 * MAY BE CHANGED BY USER [yes/no]: No
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * \defgroup IfxSfr_Scu_Registers_BitfieldsMask Bitfields mask and offset
 * \ingroup IfxSfr_Scu_Registers
 * 
 */



/******************************************************************************/

/******************************************************************************/

/** \addtogroup IfxSfr_Scu_Registers_BitfieldsMask
 * \{  */
/** \brief Length for Ifx_SCU_ID_Bits.MODREV */


/** \brief Mask for Ifx_SCU_ID_Bits.MODREV */


/** \brief Offset for Ifx_SCU_ID_Bits.MODREV */


/** \brief Length for Ifx_SCU_ID_Bits.MODTYPE */


/** \brief Mask for Ifx_SCU_ID_Bits.MODTYPE */


/** \brief Offset for Ifx_SCU_ID_Bits.MODTYPE */


/** \brief Length for Ifx_SCU_ID_Bits.MODNUMBER */


/** \brief Mask for Ifx_SCU_ID_Bits.MODNUMBER */


/** \brief Offset for Ifx_SCU_ID_Bits.MODNUMBER */


/** \brief Length for Ifx_SCU_OSCCON_Bits.PLLLV */


/** \brief Mask for Ifx_SCU_OSCCON_Bits.PLLLV */


/** \brief Offset for Ifx_SCU_OSCCON_Bits.PLLLV */


/** \brief Length for Ifx_SCU_OSCCON_Bits.OSCRES */


/** \brief Mask for Ifx_SCU_OSCCON_Bits.OSCRES */


/** \brief Offset for Ifx_SCU_OSCCON_Bits.OSCRES */


/** \brief Length for Ifx_SCU_OSCCON_Bits.GAINSEL */


/** \brief Mask for Ifx_SCU_OSCCON_Bits.GAINSEL */


/** \brief Offset for Ifx_SCU_OSCCON_Bits.GAINSEL */


/** \brief Length for Ifx_SCU_OSCCON_Bits.MODE */


/** \brief Mask for Ifx_SCU_OSCCON_Bits.MODE */


/** \brief Offset for Ifx_SCU_OSCCON_Bits.MODE */


/** \brief Length for Ifx_SCU_OSCCON_Bits.SHBY */


/** \brief Mask for Ifx_SCU_OSCCON_Bits.SHBY */


/** \brief Offset for Ifx_SCU_OSCCON_Bits.SHBY */


/** \brief Length for Ifx_SCU_OSCCON_Bits.PLLHV */


/** \brief Mask for Ifx_SCU_OSCCON_Bits.PLLHV */


/** \brief Offset for Ifx_SCU_OSCCON_Bits.PLLHV */


/** \brief Length for Ifx_SCU_OSCCON_Bits.HYSEN */


/** \brief Mask for Ifx_SCU_OSCCON_Bits.HYSEN */


/** \brief Offset for Ifx_SCU_OSCCON_Bits.HYSEN */


/** \brief Length for Ifx_SCU_OSCCON_Bits.HYSCTL */


/** \brief Mask for Ifx_SCU_OSCCON_Bits.HYSCTL */


/** \brief Offset for Ifx_SCU_OSCCON_Bits.HYSCTL */


/** \brief Length for Ifx_SCU_OSCCON_Bits.AMPCTL */


/** \brief Mask for Ifx_SCU_OSCCON_Bits.AMPCTL */


/** \brief Offset for Ifx_SCU_OSCCON_Bits.AMPCTL */


/** \brief Length for Ifx_SCU_OSCCON_Bits.OSCVAL */


/** \brief Mask for Ifx_SCU_OSCCON_Bits.OSCVAL */


/** \brief Offset for Ifx_SCU_OSCCON_Bits.OSCVAL */


/** \brief Length for Ifx_SCU_OSCCON_Bits.APREN */


/** \brief Mask for Ifx_SCU_OSCCON_Bits.APREN */


/** \brief Offset for Ifx_SCU_OSCCON_Bits.APREN */


/** \brief Length for Ifx_SCU_OSCCON_Bits.CAP0EN */


/** \brief Mask for Ifx_SCU_OSCCON_Bits.CAP0EN */


/** \brief Offset for Ifx_SCU_OSCCON_Bits.CAP0EN */


/** \brief Length for Ifx_SCU_OSCCON_Bits.CAP1EN */


/** \brief Mask for Ifx_SCU_OSCCON_Bits.CAP1EN */


/** \brief Offset for Ifx_SCU_OSCCON_Bits.CAP1EN */


/** \brief Length for Ifx_SCU_OSCCON_Bits.CAP2EN */


/** \brief Mask for Ifx_SCU_OSCCON_Bits.CAP2EN */


/** \brief Offset for Ifx_SCU_OSCCON_Bits.CAP2EN */


/** \brief Length for Ifx_SCU_OSCCON_Bits.CAP3EN */


/** \brief Mask for Ifx_SCU_OSCCON_Bits.CAP3EN */


/** \brief Offset for Ifx_SCU_OSCCON_Bits.CAP3EN */


/** \brief Length for Ifx_SCU_SYSPLLSTAT_Bits.PWDSTAT */


/** \brief Mask for Ifx_SCU_SYSPLLSTAT_Bits.PWDSTAT */


/** \brief Offset for Ifx_SCU_SYSPLLSTAT_Bits.PWDSTAT */


/** \brief Length for Ifx_SCU_SYSPLLSTAT_Bits.LOCK */


/** \brief Mask for Ifx_SCU_SYSPLLSTAT_Bits.LOCK */


/** \brief Offset for Ifx_SCU_SYSPLLSTAT_Bits.LOCK */


/** \brief Length for Ifx_SCU_SYSPLLSTAT_Bits.K2RDY */


/** \brief Mask for Ifx_SCU_SYSPLLSTAT_Bits.K2RDY */


/** \brief Offset for Ifx_SCU_SYSPLLSTAT_Bits.K2RDY */


/** \brief Length for Ifx_SCU_SYSPLLSTAT_Bits.MODRUN */


/** \brief Mask for Ifx_SCU_SYSPLLSTAT_Bits.MODRUN */


/** \brief Offset for Ifx_SCU_SYSPLLSTAT_Bits.MODRUN */


/** \brief Length for Ifx_SCU_SYSPLLCON0_Bits.MODEN */


/** \brief Mask for Ifx_SCU_SYSPLLCON0_Bits.MODEN */


/** \brief Offset for Ifx_SCU_SYSPLLCON0_Bits.MODEN */


/** \brief Length for Ifx_SCU_SYSPLLCON0_Bits.NDIV */


/** \brief Mask for Ifx_SCU_SYSPLLCON0_Bits.NDIV */


/** \brief Offset for Ifx_SCU_SYSPLLCON0_Bits.NDIV */


/** \brief Length for Ifx_SCU_SYSPLLCON0_Bits.PLLPWD */


/** \brief Mask for Ifx_SCU_SYSPLLCON0_Bits.PLLPWD */


/** \brief Offset for Ifx_SCU_SYSPLLCON0_Bits.PLLPWD */


/** \brief Length for Ifx_SCU_SYSPLLCON0_Bits.RESLD */


/** \brief Mask for Ifx_SCU_SYSPLLCON0_Bits.RESLD */


/** \brief Offset for Ifx_SCU_SYSPLLCON0_Bits.RESLD */


/** \brief Length for Ifx_SCU_SYSPLLCON0_Bits.PDIV */


/** \brief Mask for Ifx_SCU_SYSPLLCON0_Bits.PDIV */


/** \brief Offset for Ifx_SCU_SYSPLLCON0_Bits.PDIV */


/** \brief Length for Ifx_SCU_SYSPLLCON0_Bits.INSEL */


/** \brief Mask for Ifx_SCU_SYSPLLCON0_Bits.INSEL */


/** \brief Offset for Ifx_SCU_SYSPLLCON0_Bits.INSEL */


/** \brief Length for Ifx_SCU_SYSPLLCON1_Bits.K2DIV */


/** \brief Mask for Ifx_SCU_SYSPLLCON1_Bits.K2DIV */


/** \brief Offset for Ifx_SCU_SYSPLLCON1_Bits.K2DIV */


/** \brief Length for Ifx_SCU_SYSPLLCON2_Bits.MODCFG */


/** \brief Mask for Ifx_SCU_SYSPLLCON2_Bits.MODCFG */


/** \brief Offset for Ifx_SCU_SYSPLLCON2_Bits.MODCFG */


/** \brief Length for Ifx_SCU_PERPLLSTAT_Bits.PWDSTAT */


/** \brief Mask for Ifx_SCU_PERPLLSTAT_Bits.PWDSTAT */


/** \brief Offset for Ifx_SCU_PERPLLSTAT_Bits.PWDSTAT */


/** \brief Length for Ifx_SCU_PERPLLSTAT_Bits.LOCK */


/** \brief Mask for Ifx_SCU_PERPLLSTAT_Bits.LOCK */


/** \brief Offset for Ifx_SCU_PERPLLSTAT_Bits.LOCK */


/** \brief Length for Ifx_SCU_PERPLLSTAT_Bits.K3RDY */


/** \brief Mask for Ifx_SCU_PERPLLSTAT_Bits.K3RDY */


/** \brief Offset for Ifx_SCU_PERPLLSTAT_Bits.K3RDY */


/** \brief Length for Ifx_SCU_PERPLLSTAT_Bits.K2RDY */


/** \brief Mask for Ifx_SCU_PERPLLSTAT_Bits.K2RDY */


/** \brief Offset for Ifx_SCU_PERPLLSTAT_Bits.K2RDY */


/** \brief Length for Ifx_SCU_PERPLLCON0_Bits.DIVBY */


/** \brief Mask for Ifx_SCU_PERPLLCON0_Bits.DIVBY */


/** \brief Offset for Ifx_SCU_PERPLLCON0_Bits.DIVBY */


/** \brief Length for Ifx_SCU_PERPLLCON0_Bits.NDIV */


/** \brief Mask for Ifx_SCU_PERPLLCON0_Bits.NDIV */


/** \brief Offset for Ifx_SCU_PERPLLCON0_Bits.NDIV */


/** \brief Length for Ifx_SCU_PERPLLCON0_Bits.PLLPWD */


/** \brief Mask for Ifx_SCU_PERPLLCON0_Bits.PLLPWD */


/** \brief Offset for Ifx_SCU_PERPLLCON0_Bits.PLLPWD */


/** \brief Length for Ifx_SCU_PERPLLCON0_Bits.RESLD */


/** \brief Mask for Ifx_SCU_PERPLLCON0_Bits.RESLD */


/** \brief Offset for Ifx_SCU_PERPLLCON0_Bits.RESLD */


/** \brief Length for Ifx_SCU_PERPLLCON0_Bits.PDIV */


/** \brief Mask for Ifx_SCU_PERPLLCON0_Bits.PDIV */


/** \brief Offset for Ifx_SCU_PERPLLCON0_Bits.PDIV */


/** \brief Length for Ifx_SCU_PERPLLCON1_Bits.K2DIV */


/** \brief Mask for Ifx_SCU_PERPLLCON1_Bits.K2DIV */


/** \brief Offset for Ifx_SCU_PERPLLCON1_Bits.K2DIV */


/** \brief Length for Ifx_SCU_PERPLLCON1_Bits.K3DIV */


/** \brief Mask for Ifx_SCU_PERPLLCON1_Bits.K3DIV */


/** \brief Offset for Ifx_SCU_PERPLLCON1_Bits.K3DIV */


/** \brief Length for Ifx_SCU_CCUCON0_Bits.STMDIV */


/** \brief Mask for Ifx_SCU_CCUCON0_Bits.STMDIV */


/** \brief Offset for Ifx_SCU_CCUCON0_Bits.STMDIV */


/** \brief Length for Ifx_SCU_CCUCON0_Bits.GTMDIV */


/** \brief Mask for Ifx_SCU_CCUCON0_Bits.GTMDIV */


/** \brief Offset for Ifx_SCU_CCUCON0_Bits.GTMDIV */


/** \brief Length for Ifx_SCU_CCUCON0_Bits.SRIDIV */


/** \brief Mask for Ifx_SCU_CCUCON0_Bits.SRIDIV */


/** \brief Offset for Ifx_SCU_CCUCON0_Bits.SRIDIV */


/** \brief Length for Ifx_SCU_CCUCON0_Bits.LPDIV */


/** \brief Mask for Ifx_SCU_CCUCON0_Bits.LPDIV */


/** \brief Offset for Ifx_SCU_CCUCON0_Bits.LPDIV */


/** \brief Length for Ifx_SCU_CCUCON0_Bits.SPBDIV */


/** \brief Mask for Ifx_SCU_CCUCON0_Bits.SPBDIV */


/** \brief Offset for Ifx_SCU_CCUCON0_Bits.SPBDIV */


/** \brief Length for Ifx_SCU_CCUCON0_Bits.BBBDIV */


/** \brief Mask for Ifx_SCU_CCUCON0_Bits.BBBDIV */


/** \brief Offset for Ifx_SCU_CCUCON0_Bits.BBBDIV */


/** \brief Length for Ifx_SCU_CCUCON0_Bits.FSIDIV */


/** \brief Mask for Ifx_SCU_CCUCON0_Bits.FSIDIV */


/** \brief Offset for Ifx_SCU_CCUCON0_Bits.FSIDIV */


/** \brief Length for Ifx_SCU_CCUCON0_Bits.FSI2DIV */


/** \brief Mask for Ifx_SCU_CCUCON0_Bits.FSI2DIV */


/** \brief Offset for Ifx_SCU_CCUCON0_Bits.FSI2DIV */


/** \brief Length for Ifx_SCU_CCUCON0_Bits.CLKSEL */


/** \brief Mask for Ifx_SCU_CCUCON0_Bits.CLKSEL */


/** \brief Offset for Ifx_SCU_CCUCON0_Bits.CLKSEL */


/** \brief Length for Ifx_SCU_CCUCON0_Bits.UP */


/** \brief Mask for Ifx_SCU_CCUCON0_Bits.UP */


/** \brief Offset for Ifx_SCU_CCUCON0_Bits.UP */


/** \brief Length for Ifx_SCU_CCUCON0_Bits.LCK */


/** \brief Mask for Ifx_SCU_CCUCON0_Bits.LCK */


/** \brief Offset for Ifx_SCU_CCUCON0_Bits.LCK */


/** \brief Length for Ifx_SCU_CCUCON1_Bits.MCANDIV */


/** \brief Mask for Ifx_SCU_CCUCON1_Bits.MCANDIV */


/** \brief Offset for Ifx_SCU_CCUCON1_Bits.MCANDIV */


/** \brief Length for Ifx_SCU_CCUCON1_Bits.CLKSELMCAN */


/** \brief Mask for Ifx_SCU_CCUCON1_Bits.CLKSELMCAN */


/** \brief Offset for Ifx_SCU_CCUCON1_Bits.CLKSELMCAN */


/** \brief Length for Ifx_SCU_CCUCON1_Bits.PLL1DIVDIS */


/** \brief Mask for Ifx_SCU_CCUCON1_Bits.PLL1DIVDIS */


/** \brief Offset for Ifx_SCU_CCUCON1_Bits.PLL1DIVDIS */


/** \brief Length for Ifx_SCU_CCUCON1_Bits.I2CDIV */


/** \brief Mask for Ifx_SCU_CCUCON1_Bits.I2CDIV */


/** \brief Offset for Ifx_SCU_CCUCON1_Bits.I2CDIV */


/** \brief Length for Ifx_SCU_CCUCON1_Bits.MSCDIV */


/** \brief Mask for Ifx_SCU_CCUCON1_Bits.MSCDIV */


/** \brief Offset for Ifx_SCU_CCUCON1_Bits.MSCDIV */


/** \brief Length for Ifx_SCU_CCUCON1_Bits.CLKSELMSC */


/** \brief Mask for Ifx_SCU_CCUCON1_Bits.CLKSELMSC */


/** \brief Offset for Ifx_SCU_CCUCON1_Bits.CLKSELMSC */


/** \brief Length for Ifx_SCU_CCUCON1_Bits.QSPIDIV */


/** \brief Mask for Ifx_SCU_CCUCON1_Bits.QSPIDIV */


/** \brief Offset for Ifx_SCU_CCUCON1_Bits.QSPIDIV */


/** \brief Length for Ifx_SCU_CCUCON1_Bits.CLKSELQSPI */


/** \brief Mask for Ifx_SCU_CCUCON1_Bits.CLKSELQSPI */


/** \brief Offset for Ifx_SCU_CCUCON1_Bits.CLKSELQSPI */


/** \brief Length for Ifx_SCU_CCUCON1_Bits.LCK */


/** \brief Mask for Ifx_SCU_CCUCON1_Bits.LCK */


/** \brief Offset for Ifx_SCU_CCUCON1_Bits.LCK */


/** \brief Length for Ifx_SCU_FDR_Bits.STEP */


/** \brief Mask for Ifx_SCU_FDR_Bits.STEP */


/** \brief Offset for Ifx_SCU_FDR_Bits.STEP */


/** \brief Length for Ifx_SCU_FDR_Bits.DM */


/** \brief Mask for Ifx_SCU_FDR_Bits.DM */


/** \brief Offset for Ifx_SCU_FDR_Bits.DM */


/** \brief Length for Ifx_SCU_FDR_Bits.RESULT */


/** \brief Mask for Ifx_SCU_FDR_Bits.RESULT */


/** \brief Offset for Ifx_SCU_FDR_Bits.RESULT */


/** \brief Length for Ifx_SCU_FDR_Bits.DISCLK */


/** \brief Mask for Ifx_SCU_FDR_Bits.DISCLK */


/** \brief Offset for Ifx_SCU_FDR_Bits.DISCLK */


/** \brief Length for Ifx_SCU_EXTCON_Bits.EN0 */


/** \brief Mask for Ifx_SCU_EXTCON_Bits.EN0 */


/** \brief Offset for Ifx_SCU_EXTCON_Bits.EN0 */


/** \brief Length for Ifx_SCU_EXTCON_Bits.SEL0 */


/** \brief Mask for Ifx_SCU_EXTCON_Bits.SEL0 */


/** \brief Offset for Ifx_SCU_EXTCON_Bits.SEL0 */


/** \brief Length for Ifx_SCU_EXTCON_Bits.EN1 */


/** \brief Mask for Ifx_SCU_EXTCON_Bits.EN1 */


/** \brief Offset for Ifx_SCU_EXTCON_Bits.EN1 */


/** \brief Length for Ifx_SCU_EXTCON_Bits.NSEL */


/** \brief Mask for Ifx_SCU_EXTCON_Bits.NSEL */


/** \brief Offset for Ifx_SCU_EXTCON_Bits.NSEL */


/** \brief Length for Ifx_SCU_EXTCON_Bits.SEL1 */


/** \brief Mask for Ifx_SCU_EXTCON_Bits.SEL1 */


/** \brief Offset for Ifx_SCU_EXTCON_Bits.SEL1 */


/** \brief Length for Ifx_SCU_EXTCON_Bits.DIV1 */


/** \brief Mask for Ifx_SCU_EXTCON_Bits.DIV1 */


/** \brief Offset for Ifx_SCU_EXTCON_Bits.DIV1 */


/** \brief Length for Ifx_SCU_CCUCON2_Bits.ASCLINFDIV */


/** \brief Mask for Ifx_SCU_CCUCON2_Bits.ASCLINFDIV */


/** \brief Offset for Ifx_SCU_CCUCON2_Bits.ASCLINFDIV */


/** \brief Length for Ifx_SCU_CCUCON2_Bits.ASCLINSDIV */


/** \brief Mask for Ifx_SCU_CCUCON2_Bits.ASCLINSDIV */


/** \brief Offset for Ifx_SCU_CCUCON2_Bits.ASCLINSDIV */


/** \brief Length for Ifx_SCU_CCUCON2_Bits.CLKSELASCLINS */


/** \brief Mask for Ifx_SCU_CCUCON2_Bits.CLKSELASCLINS */


/** \brief Offset for Ifx_SCU_CCUCON2_Bits.CLKSELASCLINS */


/** \brief Length for Ifx_SCU_CCUCON2_Bits.ERAYPERON */


/** \brief Mask for Ifx_SCU_CCUCON2_Bits.ERAYPERON */


/** \brief Offset for Ifx_SCU_CCUCON2_Bits.ERAYPERON */


/** \brief Length for Ifx_SCU_CCUCON2_Bits.LCK */


/** \brief Mask for Ifx_SCU_CCUCON2_Bits.LCK */


/** \brief Offset for Ifx_SCU_CCUCON2_Bits.LCK */


/** \brief Length for Ifx_SCU_CCUCON3_Bits.PLL0MONEN */


/** \brief Mask for Ifx_SCU_CCUCON3_Bits.PLL0MONEN */


/** \brief Offset for Ifx_SCU_CCUCON3_Bits.PLL0MONEN */


/** \brief Length for Ifx_SCU_CCUCON3_Bits.PLL1MONEN */


/** \brief Mask for Ifx_SCU_CCUCON3_Bits.PLL1MONEN */


/** \brief Offset for Ifx_SCU_CCUCON3_Bits.PLL1MONEN */


/** \brief Length for Ifx_SCU_CCUCON3_Bits.PLL2MONEN */


/** \brief Mask for Ifx_SCU_CCUCON3_Bits.PLL2MONEN */


/** \brief Offset for Ifx_SCU_CCUCON3_Bits.PLL2MONEN */


/** \brief Length for Ifx_SCU_CCUCON3_Bits.SPBMONEN */


/** \brief Mask for Ifx_SCU_CCUCON3_Bits.SPBMONEN */


/** \brief Offset for Ifx_SCU_CCUCON3_Bits.SPBMONEN */


/** \brief Length for Ifx_SCU_CCUCON3_Bits.BACKMONEN */


/** \brief Mask for Ifx_SCU_CCUCON3_Bits.BACKMONEN */


/** \brief Offset for Ifx_SCU_CCUCON3_Bits.BACKMONEN */


/** \brief Length for Ifx_SCU_CCUCON3_Bits.PLL0MONTST */


/** \brief Mask for Ifx_SCU_CCUCON3_Bits.PLL0MONTST */


/** \brief Offset for Ifx_SCU_CCUCON3_Bits.PLL0MONTST */


/** \brief Length for Ifx_SCU_CCUCON3_Bits.PLL1MONTST */


/** \brief Mask for Ifx_SCU_CCUCON3_Bits.PLL1MONTST */


/** \brief Offset for Ifx_SCU_CCUCON3_Bits.PLL1MONTST */


/** \brief Length for Ifx_SCU_CCUCON3_Bits.PLL2MONTST */


/** \brief Mask for Ifx_SCU_CCUCON3_Bits.PLL2MONTST */


/** \brief Offset for Ifx_SCU_CCUCON3_Bits.PLL2MONTST */


/** \brief Length for Ifx_SCU_CCUCON3_Bits.SPBMONTST */


/** \brief Mask for Ifx_SCU_CCUCON3_Bits.SPBMONTST */


/** \brief Offset for Ifx_SCU_CCUCON3_Bits.SPBMONTST */


/** \brief Length for Ifx_SCU_CCUCON3_Bits.BACKMONTST */


/** \brief Mask for Ifx_SCU_CCUCON3_Bits.BACKMONTST */


/** \brief Offset for Ifx_SCU_CCUCON3_Bits.BACKMONTST */


/** \brief Length for Ifx_SCU_CCUCON3_Bits.UP */


/** \brief Mask for Ifx_SCU_CCUCON3_Bits.UP */


/** \brief Offset for Ifx_SCU_CCUCON3_Bits.UP */


/** \brief Length for Ifx_SCU_CCUCON3_Bits.LCK */


/** \brief Mask for Ifx_SCU_CCUCON3_Bits.LCK */


/** \brief Offset for Ifx_SCU_CCUCON3_Bits.LCK */


/** \brief Length for Ifx_SCU_CCUCON4_Bits.LOTHR */


/** \brief Mask for Ifx_SCU_CCUCON4_Bits.LOTHR */


/** \brief Offset for Ifx_SCU_CCUCON4_Bits.LOTHR */


/** \brief Length for Ifx_SCU_CCUCON4_Bits.UPTHR */


/** \brief Mask for Ifx_SCU_CCUCON4_Bits.UPTHR */


/** \brief Offset for Ifx_SCU_CCUCON4_Bits.UPTHR */


/** \brief Length for Ifx_SCU_CCUCON4_Bits.MONEN */


/** \brief Mask for Ifx_SCU_CCUCON4_Bits.MONEN */


/** \brief Offset for Ifx_SCU_CCUCON4_Bits.MONEN */


/** \brief Length for Ifx_SCU_CCUCON4_Bits.MONTST */


/** \brief Mask for Ifx_SCU_CCUCON4_Bits.MONTST */


/** \brief Offset for Ifx_SCU_CCUCON4_Bits.MONTST */


/** \brief Length for Ifx_SCU_CCUCON4_Bits.UP */


/** \brief Mask for Ifx_SCU_CCUCON4_Bits.UP */


/** \brief Offset for Ifx_SCU_CCUCON4_Bits.UP */


/** \brief Length for Ifx_SCU_CCUCON4_Bits.LCK */


/** \brief Mask for Ifx_SCU_CCUCON4_Bits.LCK */


/** \brief Offset for Ifx_SCU_CCUCON4_Bits.LCK */


/** \brief Length for Ifx_SCU_CCUCON5_Bits.GETHDIV */


/** \brief Mask for Ifx_SCU_CCUCON5_Bits.GETHDIV */


/** \brief Offset for Ifx_SCU_CCUCON5_Bits.GETHDIV */


/** \brief Length for Ifx_SCU_CCUCON5_Bits.MCANHDIV */


/** \brief Mask for Ifx_SCU_CCUCON5_Bits.MCANHDIV */


/** \brief Offset for Ifx_SCU_CCUCON5_Bits.MCANHDIV */


/** \brief Length for Ifx_SCU_CCUCON5_Bits.UP */


/** \brief Mask for Ifx_SCU_CCUCON5_Bits.UP */


/** \brief Offset for Ifx_SCU_CCUCON5_Bits.UP */


/** \brief Length for Ifx_SCU_CCUCON5_Bits.LCK */


/** \brief Mask for Ifx_SCU_CCUCON5_Bits.LCK */


/** \brief Offset for Ifx_SCU_CCUCON5_Bits.LCK */


/** \brief Length for Ifx_SCU_RSTSTAT_Bits.ESR0 */


/** \brief Mask for Ifx_SCU_RSTSTAT_Bits.ESR0 */


/** \brief Offset for Ifx_SCU_RSTSTAT_Bits.ESR0 */


/** \brief Length for Ifx_SCU_RSTSTAT_Bits.ESR1 */


/** \brief Mask for Ifx_SCU_RSTSTAT_Bits.ESR1 */


/** \brief Offset for Ifx_SCU_RSTSTAT_Bits.ESR1 */


/** \brief Length for Ifx_SCU_RSTSTAT_Bits.SMU */


/** \brief Mask for Ifx_SCU_RSTSTAT_Bits.SMU */


/** \brief Offset for Ifx_SCU_RSTSTAT_Bits.SMU */


/** \brief Length for Ifx_SCU_RSTSTAT_Bits.SW */


/** \brief Mask for Ifx_SCU_RSTSTAT_Bits.SW */


/** \brief Offset for Ifx_SCU_RSTSTAT_Bits.SW */


/** \brief Length for Ifx_SCU_RSTSTAT_Bits.STM0 */


/** \brief Mask for Ifx_SCU_RSTSTAT_Bits.STM0 */


/** \brief Offset for Ifx_SCU_RSTSTAT_Bits.STM0 */


/** \brief Length for Ifx_SCU_RSTSTAT_Bits.STM1 */


/** \brief Mask for Ifx_SCU_RSTSTAT_Bits.STM1 */


/** \brief Offset for Ifx_SCU_RSTSTAT_Bits.STM1 */


/** \brief Length for Ifx_SCU_RSTSTAT_Bits.STM2 */


/** \brief Mask for Ifx_SCU_RSTSTAT_Bits.STM2 */


/** \brief Offset for Ifx_SCU_RSTSTAT_Bits.STM2 */


/** \brief Length for Ifx_SCU_RSTSTAT_Bits.STM3 */


/** \brief Mask for Ifx_SCU_RSTSTAT_Bits.STM3 */


/** \brief Offset for Ifx_SCU_RSTSTAT_Bits.STM3 */


/** \brief Length for Ifx_SCU_RSTSTAT_Bits.PORST */


/** \brief Mask for Ifx_SCU_RSTSTAT_Bits.PORST */


/** \brief Offset for Ifx_SCU_RSTSTAT_Bits.PORST */


/** \brief Length for Ifx_SCU_RSTSTAT_Bits.CB0 */


/** \brief Mask for Ifx_SCU_RSTSTAT_Bits.CB0 */


/** \brief Offset for Ifx_SCU_RSTSTAT_Bits.CB0 */


/** \brief Length for Ifx_SCU_RSTSTAT_Bits.CB1 */


/** \brief Mask for Ifx_SCU_RSTSTAT_Bits.CB1 */


/** \brief Offset for Ifx_SCU_RSTSTAT_Bits.CB1 */


/** \brief Length for Ifx_SCU_RSTSTAT_Bits.CB3 */


/** \brief Mask for Ifx_SCU_RSTSTAT_Bits.CB3 */


/** \brief Offset for Ifx_SCU_RSTSTAT_Bits.CB3 */


/** \brief Length for Ifx_SCU_RSTSTAT_Bits.EVRC */


/** \brief Mask for Ifx_SCU_RSTSTAT_Bits.EVRC */


/** \brief Offset for Ifx_SCU_RSTSTAT_Bits.EVRC */


/** \brief Length for Ifx_SCU_RSTSTAT_Bits.EVR33 */


/** \brief Mask for Ifx_SCU_RSTSTAT_Bits.EVR33 */


/** \brief Offset for Ifx_SCU_RSTSTAT_Bits.EVR33 */


/** \brief Length for Ifx_SCU_RSTSTAT_Bits.SWD */


/** \brief Mask for Ifx_SCU_RSTSTAT_Bits.SWD */


/** \brief Offset for Ifx_SCU_RSTSTAT_Bits.SWD */


/** \brief Length for Ifx_SCU_RSTSTAT_Bits.HSMS */


/** \brief Mask for Ifx_SCU_RSTSTAT_Bits.HSMS */


/** \brief Offset for Ifx_SCU_RSTSTAT_Bits.HSMS */


/** \brief Length for Ifx_SCU_RSTSTAT_Bits.HSMA */


/** \brief Mask for Ifx_SCU_RSTSTAT_Bits.HSMA */


/** \brief Offset for Ifx_SCU_RSTSTAT_Bits.HSMA */


/** \brief Length for Ifx_SCU_RSTSTAT_Bits.STBYR */


/** \brief Mask for Ifx_SCU_RSTSTAT_Bits.STBYR */


/** \brief Offset for Ifx_SCU_RSTSTAT_Bits.STBYR */


/** \brief Length for Ifx_SCU_RSTSTAT_Bits.LBPORST */


/** \brief Mask for Ifx_SCU_RSTSTAT_Bits.LBPORST */


/** \brief Offset for Ifx_SCU_RSTSTAT_Bits.LBPORST */


/** \brief Length for Ifx_SCU_RSTSTAT_Bits.LBTERM */


/** \brief Mask for Ifx_SCU_RSTSTAT_Bits.LBTERM */


/** \brief Offset for Ifx_SCU_RSTSTAT_Bits.LBTERM */


/** \brief Length for Ifx_SCU_RSTCON_Bits.ESR0 */


/** \brief Mask for Ifx_SCU_RSTCON_Bits.ESR0 */


/** \brief Offset for Ifx_SCU_RSTCON_Bits.ESR0 */


/** \brief Length for Ifx_SCU_RSTCON_Bits.ESR1 */


/** \brief Mask for Ifx_SCU_RSTCON_Bits.ESR1 */


/** \brief Offset for Ifx_SCU_RSTCON_Bits.ESR1 */


/** \brief Length for Ifx_SCU_RSTCON_Bits.SMU */


/** \brief Mask for Ifx_SCU_RSTCON_Bits.SMU */


/** \brief Offset for Ifx_SCU_RSTCON_Bits.SMU */


/** \brief Length for Ifx_SCU_RSTCON_Bits.SW */


/** \brief Mask for Ifx_SCU_RSTCON_Bits.SW */


/** \brief Offset for Ifx_SCU_RSTCON_Bits.SW */


/** \brief Length for Ifx_SCU_RSTCON_Bits.STM0 */


/** \brief Mask for Ifx_SCU_RSTCON_Bits.STM0 */


/** \brief Offset for Ifx_SCU_RSTCON_Bits.STM0 */


/** \brief Length for Ifx_SCU_RSTCON_Bits.STM1 */


/** \brief Mask for Ifx_SCU_RSTCON_Bits.STM1 */


/** \brief Offset for Ifx_SCU_RSTCON_Bits.STM1 */


/** \brief Length for Ifx_SCU_RSTCON_Bits.STM2 */


/** \brief Mask for Ifx_SCU_RSTCON_Bits.STM2 */


/** \brief Offset for Ifx_SCU_RSTCON_Bits.STM2 */


/** \brief Length for Ifx_SCU_RSTCON_Bits.STM3 */


/** \brief Mask for Ifx_SCU_RSTCON_Bits.STM3 */


/** \brief Offset for Ifx_SCU_RSTCON_Bits.STM3 */


/** \brief Length for Ifx_SCU_ARSTDIS_Bits.STM0DIS */


/** \brief Mask for Ifx_SCU_ARSTDIS_Bits.STM0DIS */


/** \brief Offset for Ifx_SCU_ARSTDIS_Bits.STM0DIS */


/** \brief Length for Ifx_SCU_ARSTDIS_Bits.STM1DIS */


/** \brief Mask for Ifx_SCU_ARSTDIS_Bits.STM1DIS */


/** \brief Offset for Ifx_SCU_ARSTDIS_Bits.STM1DIS */


/** \brief Length for Ifx_SCU_ARSTDIS_Bits.STM2DIS */


/** \brief Mask for Ifx_SCU_ARSTDIS_Bits.STM2DIS */


/** \brief Offset for Ifx_SCU_ARSTDIS_Bits.STM2DIS */


/** \brief Length for Ifx_SCU_ARSTDIS_Bits.STM3DIS */


/** \brief Mask for Ifx_SCU_ARSTDIS_Bits.STM3DIS */


/** \brief Offset for Ifx_SCU_ARSTDIS_Bits.STM3DIS */


/** \brief Length for Ifx_SCU_SWRSTCON_Bits.SWRSTREQ */


/** \brief Mask for Ifx_SCU_SWRSTCON_Bits.SWRSTREQ */


/** \brief Offset for Ifx_SCU_SWRSTCON_Bits.SWRSTREQ */


/** \brief Length for Ifx_SCU_RSTCON2_Bits.FRTO */


/** \brief Mask for Ifx_SCU_RSTCON2_Bits.FRTO */


/** \brief Offset for Ifx_SCU_RSTCON2_Bits.FRTO */


/** \brief Length for Ifx_SCU_RSTCON2_Bits.CLRC */


/** \brief Mask for Ifx_SCU_RSTCON2_Bits.CLRC */


/** \brief Offset for Ifx_SCU_RSTCON2_Bits.CLRC */


/** \brief Length for Ifx_SCU_RSTCON2_Bits.CSSx */


/** \brief Mask for Ifx_SCU_RSTCON2_Bits.CSSx */


/** \brief Offset for Ifx_SCU_RSTCON2_Bits.CSSx */


/** \brief Length for Ifx_SCU_RSTCON2_Bits.USRINFO */


/** \brief Mask for Ifx_SCU_RSTCON2_Bits.USRINFO */


/** \brief Offset for Ifx_SCU_RSTCON2_Bits.USRINFO */


/** \brief Length for Ifx_SCU_ESRCFGX_ESRCFGX_Bits.EDCON */


/** \brief Mask for Ifx_SCU_ESRCFGX_ESRCFGX_Bits.EDCON */


/** \brief Offset for Ifx_SCU_ESRCFGX_ESRCFGX_Bits.EDCON */


/** \brief Length for Ifx_SCU_ESROCFG_Bits.ARI */


/** \brief Mask for Ifx_SCU_ESROCFG_Bits.ARI */


/** \brief Offset for Ifx_SCU_ESROCFG_Bits.ARI */


/** \brief Length for Ifx_SCU_ESROCFG_Bits.ARC */


/** \brief Mask for Ifx_SCU_ESROCFG_Bits.ARC */


/** \brief Offset for Ifx_SCU_ESROCFG_Bits.ARC */


/** \brief Length for Ifx_SCU_SYSCON_Bits.CCTRIG0 */


/** \brief Mask for Ifx_SCU_SYSCON_Bits.CCTRIG0 */


/** \brief Offset for Ifx_SCU_SYSCON_Bits.CCTRIG0 */


/** \brief Length for Ifx_SCU_SYSCON_Bits.RAMINTM */


/** \brief Mask for Ifx_SCU_SYSCON_Bits.RAMINTM */


/** \brief Offset for Ifx_SCU_SYSCON_Bits.RAMINTM */


/** \brief Length for Ifx_SCU_SYSCON_Bits.SETLUDIS */


/** \brief Mask for Ifx_SCU_SYSCON_Bits.SETLUDIS */


/** \brief Offset for Ifx_SCU_SYSCON_Bits.SETLUDIS */


/** \brief Length for Ifx_SCU_SYSCON_Bits.DDC */


/** \brief Mask for Ifx_SCU_SYSCON_Bits.DDC */


/** \brief Offset for Ifx_SCU_SYSCON_Bits.DDC */


/** \brief Length for Ifx_SCU_CCUCON6_Bits.CPU0DIV */


/** \brief Mask for Ifx_SCU_CCUCON6_Bits.CPU0DIV */


/** \brief Offset for Ifx_SCU_CCUCON6_Bits.CPU0DIV */


/** \brief Length for Ifx_SCU_CCUCON7_Bits.CPU1DIV */


/** \brief Mask for Ifx_SCU_CCUCON7_Bits.CPU1DIV */


/** \brief Offset for Ifx_SCU_CCUCON7_Bits.CPU1DIV */


/** \brief Length for Ifx_SCU_CCUCON8_Bits.CPU2DIV */


/** \brief Mask for Ifx_SCU_CCUCON8_Bits.CPU2DIV */


/** \brief Offset for Ifx_SCU_CCUCON8_Bits.CPU2DIV */


/** \brief Length for Ifx_SCU_CCUCON9_Bits.CPU3DIV */


/** \brief Mask for Ifx_SCU_CCUCON9_Bits.CPU3DIV */


/** \brief Offset for Ifx_SCU_CCUCON9_Bits.CPU3DIV */


/** \brief Length for Ifx_SCU_PDR_Bits.PD0 */


/** \brief Mask for Ifx_SCU_PDR_Bits.PD0 */


/** \brief Offset for Ifx_SCU_PDR_Bits.PD0 */


/** \brief Length for Ifx_SCU_PDR_Bits.PL0 */


/** \brief Mask for Ifx_SCU_PDR_Bits.PL0 */


/** \brief Offset for Ifx_SCU_PDR_Bits.PL0 */


/** \brief Length for Ifx_SCU_PDR_Bits.PD1 */


/** \brief Mask for Ifx_SCU_PDR_Bits.PD1 */


/** \brief Offset for Ifx_SCU_PDR_Bits.PD1 */


/** \brief Length for Ifx_SCU_PDR_Bits.PL1 */


/** \brief Mask for Ifx_SCU_PDR_Bits.PL1 */


/** \brief Offset for Ifx_SCU_PDR_Bits.PL1 */


/** \brief Length for Ifx_SCU_IOCR_Bits.PC0 */


/** \brief Mask for Ifx_SCU_IOCR_Bits.PC0 */


/** \brief Offset for Ifx_SCU_IOCR_Bits.PC0 */


/** \brief Length for Ifx_SCU_IOCR_Bits.PC1 */


/** \brief Mask for Ifx_SCU_IOCR_Bits.PC1 */


/** \brief Offset for Ifx_SCU_IOCR_Bits.PC1 */


/** \brief Length for Ifx_SCU_OUT_Bits.P0 */


/** \brief Mask for Ifx_SCU_OUT_Bits.P0 */


/** \brief Offset for Ifx_SCU_OUT_Bits.P0 */


/** \brief Length for Ifx_SCU_OUT_Bits.P1 */


/** \brief Mask for Ifx_SCU_OUT_Bits.P1 */


/** \brief Offset for Ifx_SCU_OUT_Bits.P1 */


/** \brief Length for Ifx_SCU_OMR_Bits.PS0 */


/** \brief Mask for Ifx_SCU_OMR_Bits.PS0 */


/** \brief Offset for Ifx_SCU_OMR_Bits.PS0 */


/** \brief Length for Ifx_SCU_OMR_Bits.PS1 */


/** \brief Mask for Ifx_SCU_OMR_Bits.PS1 */


/** \brief Offset for Ifx_SCU_OMR_Bits.PS1 */


/** \brief Length for Ifx_SCU_OMR_Bits.PCL0 */


/** \brief Mask for Ifx_SCU_OMR_Bits.PCL0 */


/** \brief Offset for Ifx_SCU_OMR_Bits.PCL0 */


/** \brief Length for Ifx_SCU_OMR_Bits.PCL1 */


/** \brief Mask for Ifx_SCU_OMR_Bits.PCL1 */


/** \brief Offset for Ifx_SCU_OMR_Bits.PCL1 */


/** \brief Length for Ifx_SCU_IN_Bits.P0 */


/** \brief Mask for Ifx_SCU_IN_Bits.P0 */


/** \brief Offset for Ifx_SCU_IN_Bits.P0 */


/** \brief Length for Ifx_SCU_IN_Bits.P1 */


/** \brief Mask for Ifx_SCU_IN_Bits.P1 */


/** \brief Offset for Ifx_SCU_IN_Bits.P1 */


/** \brief Length for Ifx_SCU_STSTAT_Bits.HWCFG */


/** \brief Mask for Ifx_SCU_STSTAT_Bits.HWCFG */


/** \brief Offset for Ifx_SCU_STSTAT_Bits.HWCFG */


/** \brief Length for Ifx_SCU_STSTAT_Bits.FTM */


/** \brief Mask for Ifx_SCU_STSTAT_Bits.FTM */


/** \brief Offset for Ifx_SCU_STSTAT_Bits.FTM */


/** \brief Length for Ifx_SCU_STSTAT_Bits.MODE */


/** \brief Mask for Ifx_SCU_STSTAT_Bits.MODE */


/** \brief Offset for Ifx_SCU_STSTAT_Bits.MODE */


/** \brief Length for Ifx_SCU_STSTAT_Bits.FCBAE */


/** \brief Mask for Ifx_SCU_STSTAT_Bits.FCBAE */


/** \brief Offset for Ifx_SCU_STSTAT_Bits.FCBAE */


/** \brief Length for Ifx_SCU_STSTAT_Bits.LUDIS */


/** \brief Mask for Ifx_SCU_STSTAT_Bits.LUDIS */


/** \brief Offset for Ifx_SCU_STSTAT_Bits.LUDIS */


/** \brief Length for Ifx_SCU_STSTAT_Bits.TRSTL */


/** \brief Mask for Ifx_SCU_STSTAT_Bits.TRSTL */


/** \brief Offset for Ifx_SCU_STSTAT_Bits.TRSTL */


/** \brief Length for Ifx_SCU_STSTAT_Bits.SPDEN */


/** \brief Mask for Ifx_SCU_STSTAT_Bits.SPDEN */


/** \brief Offset for Ifx_SCU_STSTAT_Bits.SPDEN */


/** \brief Length for Ifx_SCU_STSTAT_Bits.RAMINT */


/** \brief Mask for Ifx_SCU_STSTAT_Bits.RAMINT */


/** \brief Offset for Ifx_SCU_STSTAT_Bits.RAMINT */


/** \brief Length for Ifx_SCU_STCON_Bits.SFCBAE */


/** \brief Mask for Ifx_SCU_STCON_Bits.SFCBAE */


/** \brief Offset for Ifx_SCU_STCON_Bits.SFCBAE */


/** \brief Length for Ifx_SCU_STCON_Bits.CFCBAE */


/** \brief Mask for Ifx_SCU_STCON_Bits.CFCBAE */


/** \brief Offset for Ifx_SCU_STCON_Bits.CFCBAE */


/** \brief Length for Ifx_SCU_STCON_Bits.STP */


/** \brief Mask for Ifx_SCU_STCON_Bits.STP */


/** \brief Offset for Ifx_SCU_STCON_Bits.STP */


/** \brief Length for Ifx_SCU_PMCSR0_Bits.REQSLP */


/** \brief Mask for Ifx_SCU_PMCSR0_Bits.REQSLP */


/** \brief Offset for Ifx_SCU_PMCSR0_Bits.REQSLP */


/** \brief Length for Ifx_SCU_PMCSR0_Bits.PMST */


/** \brief Mask for Ifx_SCU_PMCSR0_Bits.PMST */


/** \brief Offset for Ifx_SCU_PMCSR0_Bits.PMST */


/** \brief Length for Ifx_SCU_PMCSR1_Bits.REQSLP */


/** \brief Mask for Ifx_SCU_PMCSR1_Bits.REQSLP */


/** \brief Offset for Ifx_SCU_PMCSR1_Bits.REQSLP */


/** \brief Length for Ifx_SCU_PMCSR1_Bits.PMST */


/** \brief Mask for Ifx_SCU_PMCSR1_Bits.PMST */


/** \brief Offset for Ifx_SCU_PMCSR1_Bits.PMST */


/** \brief Length for Ifx_SCU_PMCSR2_Bits.REQSLP */


/** \brief Mask for Ifx_SCU_PMCSR2_Bits.REQSLP */


/** \brief Offset for Ifx_SCU_PMCSR2_Bits.REQSLP */


/** \brief Length for Ifx_SCU_PMCSR2_Bits.PMST */


/** \brief Mask for Ifx_SCU_PMCSR2_Bits.PMST */


/** \brief Offset for Ifx_SCU_PMCSR2_Bits.PMST */


/** \brief Length for Ifx_SCU_PMCSR3_Bits.REQSLP */


/** \brief Mask for Ifx_SCU_PMCSR3_Bits.REQSLP */


/** \brief Offset for Ifx_SCU_PMCSR3_Bits.REQSLP */


/** \brief Length for Ifx_SCU_PMCSR3_Bits.PMST */


/** \brief Mask for Ifx_SCU_PMCSR3_Bits.PMST */


/** \brief Offset for Ifx_SCU_PMCSR3_Bits.PMST */


/** \brief Length for Ifx_SCU_PMCSR4_Bits.REQSLP */


/** \brief Mask for Ifx_SCU_PMCSR4_Bits.REQSLP */


/** \brief Offset for Ifx_SCU_PMCSR4_Bits.REQSLP */


/** \brief Length for Ifx_SCU_PMCSR4_Bits.PMST */


/** \brief Mask for Ifx_SCU_PMCSR4_Bits.PMST */


/** \brief Offset for Ifx_SCU_PMCSR4_Bits.PMST */


/** \brief Length for Ifx_SCU_PMCSR5_Bits.REQSLP */


/** \brief Mask for Ifx_SCU_PMCSR5_Bits.REQSLP */


/** \brief Offset for Ifx_SCU_PMCSR5_Bits.REQSLP */


/** \brief Length for Ifx_SCU_PMCSR5_Bits.PMST */


/** \brief Mask for Ifx_SCU_PMCSR5_Bits.PMST */


/** \brief Offset for Ifx_SCU_PMCSR5_Bits.PMST */


/** \brief Length for Ifx_SCU_PMSTAT0_Bits.CPU0 */


/** \brief Mask for Ifx_SCU_PMSTAT0_Bits.CPU0 */


/** \brief Offset for Ifx_SCU_PMSTAT0_Bits.CPU0 */


/** \brief Length for Ifx_SCU_PMSTAT0_Bits.CPU1 */


/** \brief Mask for Ifx_SCU_PMSTAT0_Bits.CPU1 */


/** \brief Offset for Ifx_SCU_PMSTAT0_Bits.CPU1 */


/** \brief Length for Ifx_SCU_PMSTAT0_Bits.CPU2 */


/** \brief Mask for Ifx_SCU_PMSTAT0_Bits.CPU2 */


/** \brief Offset for Ifx_SCU_PMSTAT0_Bits.CPU2 */


/** \brief Length for Ifx_SCU_PMSTAT0_Bits.CPU3 */


/** \brief Mask for Ifx_SCU_PMSTAT0_Bits.CPU3 */


/** \brief Offset for Ifx_SCU_PMSTAT0_Bits.CPU3 */


/** \brief Length for Ifx_SCU_PMSTAT0_Bits.CPU4 */


/** \brief Mask for Ifx_SCU_PMSTAT0_Bits.CPU4 */


/** \brief Offset for Ifx_SCU_PMSTAT0_Bits.CPU4 */


/** \brief Length for Ifx_SCU_PMSTAT0_Bits.CPU5 */


/** \brief Mask for Ifx_SCU_PMSTAT0_Bits.CPU5 */


/** \brief Offset for Ifx_SCU_PMSTAT0_Bits.CPU5 */


/** \brief Length for Ifx_SCU_PMSTAT0_Bits.CPU0LS */


/** \brief Mask for Ifx_SCU_PMSTAT0_Bits.CPU0LS */


/** \brief Offset for Ifx_SCU_PMSTAT0_Bits.CPU0LS */


/** \brief Length for Ifx_SCU_PMSTAT0_Bits.CPU1LS */


/** \brief Mask for Ifx_SCU_PMSTAT0_Bits.CPU1LS */


/** \brief Offset for Ifx_SCU_PMSTAT0_Bits.CPU1LS */


/** \brief Length for Ifx_SCU_PMSTAT0_Bits.CPU2LS */


/** \brief Mask for Ifx_SCU_PMSTAT0_Bits.CPU2LS */


/** \brief Offset for Ifx_SCU_PMSTAT0_Bits.CPU2LS */


/** \brief Length for Ifx_SCU_PMSTAT0_Bits.CPU3LS */


/** \brief Mask for Ifx_SCU_PMSTAT0_Bits.CPU3LS */


/** \brief Offset for Ifx_SCU_PMSTAT0_Bits.CPU3LS */


/** \brief Length for Ifx_SCU_PMSWCR1_Bits.CPUIDLSEL */


/** \brief Mask for Ifx_SCU_PMSWCR1_Bits.CPUIDLSEL */


/** \brief Offset for Ifx_SCU_PMSWCR1_Bits.CPUIDLSEL */


/** \brief Length for Ifx_SCU_PMSWCR1_Bits.IRADIS */


/** \brief Mask for Ifx_SCU_PMSWCR1_Bits.IRADIS */


/** \brief Offset for Ifx_SCU_PMSWCR1_Bits.IRADIS */


/** \brief Length for Ifx_SCU_PMSWCR1_Bits.CPUSEL */


/** \brief Mask for Ifx_SCU_PMSWCR1_Bits.CPUSEL */


/** \brief Offset for Ifx_SCU_PMSWCR1_Bits.CPUSEL */


/** \brief Length for Ifx_SCU_PMSWCR1_Bits.STBYEVEN */


/** \brief Mask for Ifx_SCU_PMSWCR1_Bits.STBYEVEN */


/** \brief Offset for Ifx_SCU_PMSWCR1_Bits.STBYEVEN */


/** \brief Length for Ifx_SCU_PMSWCR1_Bits.STBYEV */


/** \brief Mask for Ifx_SCU_PMSWCR1_Bits.STBYEV */


/** \brief Offset for Ifx_SCU_PMSWCR1_Bits.STBYEV */


/** \brief Length for Ifx_SCU_EMSR_Bits.POL */


/** \brief Mask for Ifx_SCU_EMSR_Bits.POL */


/** \brief Offset for Ifx_SCU_EMSR_Bits.POL */


/** \brief Length for Ifx_SCU_EMSR_Bits.MODE */


/** \brief Mask for Ifx_SCU_EMSR_Bits.MODE */


/** \brief Offset for Ifx_SCU_EMSR_Bits.MODE */


/** \brief Length for Ifx_SCU_EMSR_Bits.ENON */


/** \brief Mask for Ifx_SCU_EMSR_Bits.ENON */


/** \brief Offset for Ifx_SCU_EMSR_Bits.ENON */


/** \brief Length for Ifx_SCU_EMSR_Bits.PSEL */


/** \brief Mask for Ifx_SCU_EMSR_Bits.PSEL */


/** \brief Offset for Ifx_SCU_EMSR_Bits.PSEL */


/** \brief Length for Ifx_SCU_EMSR_Bits.EMSF */


/** \brief Mask for Ifx_SCU_EMSR_Bits.EMSF */


/** \brief Offset for Ifx_SCU_EMSR_Bits.EMSF */


/** \brief Length for Ifx_SCU_EMSR_Bits.SEMSF */


/** \brief Mask for Ifx_SCU_EMSR_Bits.SEMSF */


/** \brief Offset for Ifx_SCU_EMSR_Bits.SEMSF */


/** \brief Length for Ifx_SCU_EMSSW_Bits.EMSFM */


/** \brief Mask for Ifx_SCU_EMSSW_Bits.EMSFM */


/** \brief Offset for Ifx_SCU_EMSSW_Bits.EMSFM */


/** \brief Length for Ifx_SCU_EMSSW_Bits.SEMSFM */


/** \brief Mask for Ifx_SCU_EMSSW_Bits.SEMSFM */


/** \brief Offset for Ifx_SCU_EMSSW_Bits.SEMSFM */


/** \brief Length for Ifx_SCU_DTSCSTAT_Bits.RESULT */


/** \brief Mask for Ifx_SCU_DTSCSTAT_Bits.RESULT */


/** \brief Offset for Ifx_SCU_DTSCSTAT_Bits.RESULT */


/** \brief Length for Ifx_SCU_DTSCLIM_Bits.LOWER */


/** \brief Mask for Ifx_SCU_DTSCLIM_Bits.LOWER */


/** \brief Offset for Ifx_SCU_DTSCLIM_Bits.LOWER */


/** \brief Length for Ifx_SCU_DTSCLIM_Bits.BGPOK */


/** \brief Mask for Ifx_SCU_DTSCLIM_Bits.BGPOK */


/** \brief Offset for Ifx_SCU_DTSCLIM_Bits.BGPOK */


/** \brief Length for Ifx_SCU_DTSCLIM_Bits.EN */


/** \brief Mask for Ifx_SCU_DTSCLIM_Bits.EN */


/** \brief Offset for Ifx_SCU_DTSCLIM_Bits.EN */


/** \brief Length for Ifx_SCU_DTSCLIM_Bits.LLU */


/** \brief Mask for Ifx_SCU_DTSCLIM_Bits.LLU */


/** \brief Offset for Ifx_SCU_DTSCLIM_Bits.LLU */


/** \brief Length for Ifx_SCU_DTSCLIM_Bits.UPPER */


/** \brief Mask for Ifx_SCU_DTSCLIM_Bits.UPPER */


/** \brief Offset for Ifx_SCU_DTSCLIM_Bits.UPPER */


/** \brief Length for Ifx_SCU_DTSCLIM_Bits.INTEN */


/** \brief Mask for Ifx_SCU_DTSCLIM_Bits.INTEN */


/** \brief Offset for Ifx_SCU_DTSCLIM_Bits.INTEN */


/** \brief Length for Ifx_SCU_DTSCLIM_Bits.INT */


/** \brief Mask for Ifx_SCU_DTSCLIM_Bits.INT */


/** \brief Offset for Ifx_SCU_DTSCLIM_Bits.INT */


/** \brief Length for Ifx_SCU_DTSCLIM_Bits.UOF */


/** \brief Mask for Ifx_SCU_DTSCLIM_Bits.UOF */


/** \brief Offset for Ifx_SCU_DTSCLIM_Bits.UOF */


/** \brief Length for Ifx_SCU_TRAPSTAT_Bits.ESR0T */


/** \brief Mask for Ifx_SCU_TRAPSTAT_Bits.ESR0T */


/** \brief Offset for Ifx_SCU_TRAPSTAT_Bits.ESR0T */


/** \brief Length for Ifx_SCU_TRAPSTAT_Bits.ESR1T */


/** \brief Mask for Ifx_SCU_TRAPSTAT_Bits.ESR1T */


/** \brief Offset for Ifx_SCU_TRAPSTAT_Bits.ESR1T */


/** \brief Length for Ifx_SCU_TRAPSTAT_Bits.TRAP2 */


/** \brief Mask for Ifx_SCU_TRAPSTAT_Bits.TRAP2 */


/** \brief Offset for Ifx_SCU_TRAPSTAT_Bits.TRAP2 */


/** \brief Length for Ifx_SCU_TRAPSTAT_Bits.SMUT */


/** \brief Mask for Ifx_SCU_TRAPSTAT_Bits.SMUT */


/** \brief Offset for Ifx_SCU_TRAPSTAT_Bits.SMUT */


/** \brief Length for Ifx_SCU_TRAPSET_Bits.ESR0T */


/** \brief Mask for Ifx_SCU_TRAPSET_Bits.ESR0T */


/** \brief Offset for Ifx_SCU_TRAPSET_Bits.ESR0T */


/** \brief Length for Ifx_SCU_TRAPSET_Bits.ESR1T */


/** \brief Mask for Ifx_SCU_TRAPSET_Bits.ESR1T */


/** \brief Offset for Ifx_SCU_TRAPSET_Bits.ESR1T */


/** \brief Length for Ifx_SCU_TRAPSET_Bits.TRAP2 */


/** \brief Mask for Ifx_SCU_TRAPSET_Bits.TRAP2 */


/** \brief Offset for Ifx_SCU_TRAPSET_Bits.TRAP2 */


/** \brief Length for Ifx_SCU_TRAPSET_Bits.SMUT */


/** \brief Mask for Ifx_SCU_TRAPSET_Bits.SMUT */


/** \brief Offset for Ifx_SCU_TRAPSET_Bits.SMUT */


/** \brief Length for Ifx_SCU_TRAPCLR_Bits.ESR0T */


/** \brief Mask for Ifx_SCU_TRAPCLR_Bits.ESR0T */


/** \brief Offset for Ifx_SCU_TRAPCLR_Bits.ESR0T */


/** \brief Length for Ifx_SCU_TRAPCLR_Bits.ESR1T */


/** \brief Mask for Ifx_SCU_TRAPCLR_Bits.ESR1T */


/** \brief Offset for Ifx_SCU_TRAPCLR_Bits.ESR1T */


/** \brief Length for Ifx_SCU_TRAPCLR_Bits.TRAP2 */


/** \brief Mask for Ifx_SCU_TRAPCLR_Bits.TRAP2 */


/** \brief Offset for Ifx_SCU_TRAPCLR_Bits.TRAP2 */


/** \brief Length for Ifx_SCU_TRAPCLR_Bits.SMUT */


/** \brief Mask for Ifx_SCU_TRAPCLR_Bits.SMUT */


/** \brief Offset for Ifx_SCU_TRAPCLR_Bits.SMUT */


/** \brief Length for Ifx_SCU_TRAPDIS0_Bits.CPU0ESR0T */


/** \brief Mask for Ifx_SCU_TRAPDIS0_Bits.CPU0ESR0T */


/** \brief Offset for Ifx_SCU_TRAPDIS0_Bits.CPU0ESR0T */


/** \brief Length for Ifx_SCU_TRAPDIS0_Bits.CPU0ESR1T */


/** \brief Mask for Ifx_SCU_TRAPDIS0_Bits.CPU0ESR1T */


/** \brief Offset for Ifx_SCU_TRAPDIS0_Bits.CPU0ESR1T */


/** \brief Length for Ifx_SCU_TRAPDIS0_Bits.CPU0TRAP2T */


/** \brief Mask for Ifx_SCU_TRAPDIS0_Bits.CPU0TRAP2T */


/** \brief Offset for Ifx_SCU_TRAPDIS0_Bits.CPU0TRAP2T */


/** \brief Length for Ifx_SCU_TRAPDIS0_Bits.CPU0SMUT */


/** \brief Mask for Ifx_SCU_TRAPDIS0_Bits.CPU0SMUT */


/** \brief Offset for Ifx_SCU_TRAPDIS0_Bits.CPU0SMUT */


/** \brief Length for Ifx_SCU_TRAPDIS0_Bits.CPU1ESR0T */


/** \brief Mask for Ifx_SCU_TRAPDIS0_Bits.CPU1ESR0T */


/** \brief Offset for Ifx_SCU_TRAPDIS0_Bits.CPU1ESR0T */


/** \brief Length for Ifx_SCU_TRAPDIS0_Bits.CPU1ESR1T */


/** \brief Mask for Ifx_SCU_TRAPDIS0_Bits.CPU1ESR1T */


/** \brief Offset for Ifx_SCU_TRAPDIS0_Bits.CPU1ESR1T */


/** \brief Length for Ifx_SCU_TRAPDIS0_Bits.CPU1TRAP2T */


/** \brief Mask for Ifx_SCU_TRAPDIS0_Bits.CPU1TRAP2T */


/** \brief Offset for Ifx_SCU_TRAPDIS0_Bits.CPU1TRAP2T */


/** \brief Length for Ifx_SCU_TRAPDIS0_Bits.CPU1SMUT */


/** \brief Mask for Ifx_SCU_TRAPDIS0_Bits.CPU1SMUT */


/** \brief Offset for Ifx_SCU_TRAPDIS0_Bits.CPU1SMUT */


/** \brief Length for Ifx_SCU_TRAPDIS0_Bits.CPU2ESR0T */


/** \brief Mask for Ifx_SCU_TRAPDIS0_Bits.CPU2ESR0T */


/** \brief Offset for Ifx_SCU_TRAPDIS0_Bits.CPU2ESR0T */


/** \brief Length for Ifx_SCU_TRAPDIS0_Bits.CPU2ESR1T */


/** \brief Mask for Ifx_SCU_TRAPDIS0_Bits.CPU2ESR1T */


/** \brief Offset for Ifx_SCU_TRAPDIS0_Bits.CPU2ESR1T */


/** \brief Length for Ifx_SCU_TRAPDIS0_Bits.CPU2TRAP2T */


/** \brief Mask for Ifx_SCU_TRAPDIS0_Bits.CPU2TRAP2T */


/** \brief Offset for Ifx_SCU_TRAPDIS0_Bits.CPU2TRAP2T */


/** \brief Length for Ifx_SCU_TRAPDIS0_Bits.CPU2SMUT */


/** \brief Mask for Ifx_SCU_TRAPDIS0_Bits.CPU2SMUT */


/** \brief Offset for Ifx_SCU_TRAPDIS0_Bits.CPU2SMUT */


/** \brief Length for Ifx_SCU_TRAPDIS0_Bits.CPU3ESR0T */


/** \brief Mask for Ifx_SCU_TRAPDIS0_Bits.CPU3ESR0T */


/** \brief Offset for Ifx_SCU_TRAPDIS0_Bits.CPU3ESR0T */


/** \brief Length for Ifx_SCU_TRAPDIS0_Bits.CPU3ESR1T */


/** \brief Mask for Ifx_SCU_TRAPDIS0_Bits.CPU3ESR1T */


/** \brief Offset for Ifx_SCU_TRAPDIS0_Bits.CPU3ESR1T */


/** \brief Length for Ifx_SCU_TRAPDIS0_Bits.CPU3TRAP2T */


/** \brief Mask for Ifx_SCU_TRAPDIS0_Bits.CPU3TRAP2T */


/** \brief Offset for Ifx_SCU_TRAPDIS0_Bits.CPU3TRAP2T */


/** \brief Length for Ifx_SCU_TRAPDIS0_Bits.CPU3SMUT */


/** \brief Mask for Ifx_SCU_TRAPDIS0_Bits.CPU3SMUT */


/** \brief Offset for Ifx_SCU_TRAPDIS0_Bits.CPU3SMUT */


/** \brief Length for Ifx_SCU_LCLCON0_Bits.LS0 */


/** \brief Mask for Ifx_SCU_LCLCON0_Bits.LS0 */


/** \brief Offset for Ifx_SCU_LCLCON0_Bits.LS0 */


/** \brief Length for Ifx_SCU_LCLCON0_Bits.LSEN0 */


/** \brief Mask for Ifx_SCU_LCLCON0_Bits.LSEN0 */


/** \brief Offset for Ifx_SCU_LCLCON0_Bits.LSEN0 */


/** \brief Length for Ifx_SCU_LCLCON1_Bits.LS1 */


/** \brief Mask for Ifx_SCU_LCLCON1_Bits.LS1 */


/** \brief Offset for Ifx_SCU_LCLCON1_Bits.LS1 */


/** \brief Length for Ifx_SCU_LCLCON1_Bits.LSEN1 */


/** \brief Mask for Ifx_SCU_LCLCON1_Bits.LSEN1 */


/** \brief Offset for Ifx_SCU_LCLCON1_Bits.LSEN1 */


/** \brief Length for Ifx_SCU_LCLTEST_Bits.LCLT0 */


/** \brief Mask for Ifx_SCU_LCLTEST_Bits.LCLT0 */


/** \brief Offset for Ifx_SCU_LCLTEST_Bits.LCLT0 */


/** \brief Length for Ifx_SCU_LCLTEST_Bits.LCLT1 */


/** \brief Mask for Ifx_SCU_LCLTEST_Bits.LCLT1 */


/** \brief Offset for Ifx_SCU_LCLTEST_Bits.LCLT1 */


/** \brief Length for Ifx_SCU_LCLTEST_Bits.LCLT2 */


/** \brief Mask for Ifx_SCU_LCLTEST_Bits.LCLT2 */


/** \brief Offset for Ifx_SCU_LCLTEST_Bits.LCLT2 */


/** \brief Length for Ifx_SCU_LCLTEST_Bits.LCLT3 */


/** \brief Mask for Ifx_SCU_LCLTEST_Bits.LCLT3 */


/** \brief Offset for Ifx_SCU_LCLTEST_Bits.LCLT3 */


/** \brief Length for Ifx_SCU_LCLTEST_Bits.PLCLT0 */


/** \brief Mask for Ifx_SCU_LCLTEST_Bits.PLCLT0 */


/** \brief Offset for Ifx_SCU_LCLTEST_Bits.PLCLT0 */


/** \brief Length for Ifx_SCU_LCLTEST_Bits.PLCLT1 */


/** \brief Mask for Ifx_SCU_LCLTEST_Bits.PLCLT1 */


/** \brief Offset for Ifx_SCU_LCLTEST_Bits.PLCLT1 */


/** \brief Length for Ifx_SCU_LCLTEST_Bits.PLCLT2 */


/** \brief Mask for Ifx_SCU_LCLTEST_Bits.PLCLT2 */


/** \brief Offset for Ifx_SCU_LCLTEST_Bits.PLCLT2 */


/** \brief Length for Ifx_SCU_LCLTEST_Bits.PLCLT3 */


/** \brief Mask for Ifx_SCU_LCLTEST_Bits.PLCLT3 */


/** \brief Offset for Ifx_SCU_LCLTEST_Bits.PLCLT3 */


/** \brief Length for Ifx_SCU_CHIPID_Bits.CHREV */


/** \brief Mask for Ifx_SCU_CHIPID_Bits.CHREV */


/** \brief Offset for Ifx_SCU_CHIPID_Bits.CHREV */


/** \brief Length for Ifx_SCU_CHIPID_Bits.CHTEC */


/** \brief Mask for Ifx_SCU_CHIPID_Bits.CHTEC */


/** \brief Offset for Ifx_SCU_CHIPID_Bits.CHTEC */


/** \brief Length for Ifx_SCU_CHIPID_Bits.CHPK */


/** \brief Mask for Ifx_SCU_CHIPID_Bits.CHPK */


/** \brief Offset for Ifx_SCU_CHIPID_Bits.CHPK */


/** \brief Length for Ifx_SCU_CHIPID_Bits.CHID */


/** \brief Mask for Ifx_SCU_CHIPID_Bits.CHID */


/** \brief Offset for Ifx_SCU_CHIPID_Bits.CHID */


/** \brief Length for Ifx_SCU_CHIPID_Bits.EEA */


/** \brief Mask for Ifx_SCU_CHIPID_Bits.EEA */


/** \brief Offset for Ifx_SCU_CHIPID_Bits.EEA */


/** \brief Length for Ifx_SCU_CHIPID_Bits.UCODE */


/** \brief Mask for Ifx_SCU_CHIPID_Bits.UCODE */


/** \brief Offset for Ifx_SCU_CHIPID_Bits.UCODE */


/** \brief Length for Ifx_SCU_CHIPID_Bits.FSIZE */


/** \brief Mask for Ifx_SCU_CHIPID_Bits.FSIZE */


/** \brief Offset for Ifx_SCU_CHIPID_Bits.FSIZE */


/** \brief Length for Ifx_SCU_CHIPID_Bits.VART */


/** \brief Mask for Ifx_SCU_CHIPID_Bits.VART */


/** \brief Offset for Ifx_SCU_CHIPID_Bits.VART */


/** \brief Length for Ifx_SCU_CHIPID_Bits.SEC */


/** \brief Mask for Ifx_SCU_CHIPID_Bits.SEC */


/** \brief Offset for Ifx_SCU_CHIPID_Bits.SEC */


/** \brief Length for Ifx_SCU_MANID_Bits.DEPT */


/** \brief Mask for Ifx_SCU_MANID_Bits.DEPT */


/** \brief Offset for Ifx_SCU_MANID_Bits.DEPT */


/** \brief Length for Ifx_SCU_MANID_Bits.MANUF */


/** \brief Mask for Ifx_SCU_MANID_Bits.MANUF */


/** \brief Offset for Ifx_SCU_MANID_Bits.MANUF */


/** \brief Length for Ifx_SCU_SWAPCTRL_Bits.ADDRCFG */


/** \brief Mask for Ifx_SCU_SWAPCTRL_Bits.ADDRCFG */


/** \brief Offset for Ifx_SCU_SWAPCTRL_Bits.ADDRCFG */


/** \brief Length for Ifx_SCU_SWAPCTRL_Bits.Spare */


/** \brief Mask for Ifx_SCU_SWAPCTRL_Bits.Spare */


/** \brief Offset for Ifx_SCU_SWAPCTRL_Bits.Spare */


/** \brief Length for Ifx_SCU_LBISTCTRL0_Bits.LBISTREQ */


/** \brief Mask for Ifx_SCU_LBISTCTRL0_Bits.LBISTREQ */


/** \brief Offset for Ifx_SCU_LBISTCTRL0_Bits.LBISTREQ */


/** \brief Length for Ifx_SCU_LBISTCTRL0_Bits.LBISTRES */


/** \brief Mask for Ifx_SCU_LBISTCTRL0_Bits.LBISTRES */


/** \brief Offset for Ifx_SCU_LBISTCTRL0_Bits.LBISTRES */


/** \brief Length for Ifx_SCU_LBISTCTRL0_Bits.PATTERNS */


/** \brief Mask for Ifx_SCU_LBISTCTRL0_Bits.PATTERNS */


/** \brief Offset for Ifx_SCU_LBISTCTRL0_Bits.PATTERNS */


/** \brief Length for Ifx_SCU_LBISTCTRL0_Bits.LBISTDONE */


/** \brief Mask for Ifx_SCU_LBISTCTRL0_Bits.LBISTDONE */


/** \brief Offset for Ifx_SCU_LBISTCTRL0_Bits.LBISTDONE */


/** \brief Length for Ifx_SCU_LBISTCTRL0_Bits.LBISTERRINJ */


/** \brief Mask for Ifx_SCU_LBISTCTRL0_Bits.LBISTERRINJ */


/** \brief Offset for Ifx_SCU_LBISTCTRL0_Bits.LBISTERRINJ */


/** \brief Length for Ifx_SCU_LBISTCTRL0_Bits.LBISTREQRED */


/** \brief Mask for Ifx_SCU_LBISTCTRL0_Bits.LBISTREQRED */


/** \brief Offset for Ifx_SCU_LBISTCTRL0_Bits.LBISTREQRED */


/** \brief Length for Ifx_SCU_LBISTCTRL1_Bits.SEED */


/** \brief Mask for Ifx_SCU_LBISTCTRL1_Bits.SEED */


/** \brief Offset for Ifx_SCU_LBISTCTRL1_Bits.SEED */


/** \brief Length for Ifx_SCU_LBISTCTRL1_Bits.SPLITSH */


/** \brief Mask for Ifx_SCU_LBISTCTRL1_Bits.SPLITSH */


/** \brief Offset for Ifx_SCU_LBISTCTRL1_Bits.SPLITSH */


/** \brief Length for Ifx_SCU_LBISTCTRL1_Bits.BODY */


/** \brief Mask for Ifx_SCU_LBISTCTRL1_Bits.BODY */


/** \brief Offset for Ifx_SCU_LBISTCTRL1_Bits.BODY */


/** \brief Length for Ifx_SCU_LBISTCTRL1_Bits.LBISTFREQU */


/** \brief Mask for Ifx_SCU_LBISTCTRL1_Bits.LBISTFREQU */


/** \brief Offset for Ifx_SCU_LBISTCTRL1_Bits.LBISTFREQU */


/** \brief Length for Ifx_SCU_LBISTCTRL2_Bits.LENGTH */


/** \brief Mask for Ifx_SCU_LBISTCTRL2_Bits.LENGTH */


/** \brief Offset for Ifx_SCU_LBISTCTRL2_Bits.LENGTH */


/** \brief Length for Ifx_SCU_LBISTCTRL3_Bits.SIGNATURE */


/** \brief Mask for Ifx_SCU_LBISTCTRL3_Bits.SIGNATURE */


/** \brief Offset for Ifx_SCU_LBISTCTRL3_Bits.SIGNATURE */


/** \brief Length for Ifx_SCU_STMEM1_Bits.MEM */


/** \brief Mask for Ifx_SCU_STMEM1_Bits.MEM */


/** \brief Offset for Ifx_SCU_STMEM1_Bits.MEM */


/** \brief Length for Ifx_SCU_STMEM2_Bits.MEM */


/** \brief Mask for Ifx_SCU_STMEM2_Bits.MEM */


/** \brief Offset for Ifx_SCU_STMEM2_Bits.MEM */


/** \brief Length for Ifx_SCU_PDISC_Bits.PDIS0 */


/** \brief Mask for Ifx_SCU_PDISC_Bits.PDIS0 */


/** \brief Offset for Ifx_SCU_PDISC_Bits.PDIS0 */


/** \brief Length for Ifx_SCU_PDISC_Bits.PDIS1 */


/** \brief Mask for Ifx_SCU_PDISC_Bits.PDIS1 */


/** \brief Offset for Ifx_SCU_PDISC_Bits.PDIS1 */


/** \brief Length for Ifx_SCU_PMTRCSR0_Bits.LJTEN */


/** \brief Mask for Ifx_SCU_PMTRCSR0_Bits.LJTEN */


/** \brief Offset for Ifx_SCU_PMTRCSR0_Bits.LJTEN */


/** \brief Length for Ifx_SCU_PMTRCSR0_Bits.LJTOVEN */


/** \brief Mask for Ifx_SCU_PMTRCSR0_Bits.LJTOVEN */


/** \brief Offset for Ifx_SCU_PMTRCSR0_Bits.LJTOVEN */


/** \brief Length for Ifx_SCU_PMTRCSR0_Bits.LJTOVIEN */


/** \brief Mask for Ifx_SCU_PMTRCSR0_Bits.LJTOVIEN */


/** \brief Offset for Ifx_SCU_PMTRCSR0_Bits.LJTOVIEN */


/** \brief Length for Ifx_SCU_PMTRCSR0_Bits.LJTSTRT */


/** \brief Mask for Ifx_SCU_PMTRCSR0_Bits.LJTSTRT */


/** \brief Offset for Ifx_SCU_PMTRCSR0_Bits.LJTSTRT */


/** \brief Length for Ifx_SCU_PMTRCSR0_Bits.LJTSTP */


/** \brief Mask for Ifx_SCU_PMTRCSR0_Bits.LJTSTP */


/** \brief Offset for Ifx_SCU_PMTRCSR0_Bits.LJTSTP */


/** \brief Length for Ifx_SCU_PMTRCSR0_Bits.LJTCLR */


/** \brief Mask for Ifx_SCU_PMTRCSR0_Bits.LJTCLR */


/** \brief Offset for Ifx_SCU_PMTRCSR0_Bits.LJTCLR */


/** \brief Length for Ifx_SCU_PMTRCSR0_Bits.SDSTEP */


/** \brief Mask for Ifx_SCU_PMTRCSR0_Bits.SDSTEP */


/** \brief Offset for Ifx_SCU_PMTRCSR0_Bits.SDSTEP */


/** \brief Length for Ifx_SCU_PMTRCSR0_Bits.VDTEN */


/** \brief Mask for Ifx_SCU_PMTRCSR0_Bits.VDTEN */


/** \brief Offset for Ifx_SCU_PMTRCSR0_Bits.VDTEN */


/** \brief Length for Ifx_SCU_PMTRCSR0_Bits.VDTOVEN */


/** \brief Mask for Ifx_SCU_PMTRCSR0_Bits.VDTOVEN */


/** \brief Offset for Ifx_SCU_PMTRCSR0_Bits.VDTOVEN */


/** \brief Length for Ifx_SCU_PMTRCSR0_Bits.VDTOVIEN */


/** \brief Mask for Ifx_SCU_PMTRCSR0_Bits.VDTOVIEN */


/** \brief Offset for Ifx_SCU_PMTRCSR0_Bits.VDTOVIEN */


/** \brief Length for Ifx_SCU_PMTRCSR0_Bits.VDTSTRT */


/** \brief Mask for Ifx_SCU_PMTRCSR0_Bits.VDTSTRT */


/** \brief Offset for Ifx_SCU_PMTRCSR0_Bits.VDTSTRT */


/** \brief Length for Ifx_SCU_PMTRCSR0_Bits.VDTSTP */


/** \brief Mask for Ifx_SCU_PMTRCSR0_Bits.VDTSTP */


/** \brief Offset for Ifx_SCU_PMTRCSR0_Bits.VDTSTP */


/** \brief Length for Ifx_SCU_PMTRCSR0_Bits.VDTCLR */


/** \brief Mask for Ifx_SCU_PMTRCSR0_Bits.VDTCLR */


/** \brief Offset for Ifx_SCU_PMTRCSR0_Bits.VDTCLR */


/** \brief Length for Ifx_SCU_PMTRCSR0_Bits.LPSLPEN */


/** \brief Mask for Ifx_SCU_PMTRCSR0_Bits.LPSLPEN */


/** \brief Offset for Ifx_SCU_PMTRCSR0_Bits.LPSLPEN */


/** \brief Length for Ifx_SCU_PMTRCSR1_Bits.LJTCV */


/** \brief Mask for Ifx_SCU_PMTRCSR1_Bits.LJTCV */


/** \brief Offset for Ifx_SCU_PMTRCSR1_Bits.LJTCV */


/** \brief Length for Ifx_SCU_PMTRCSR1_Bits.VDTCV */


/** \brief Mask for Ifx_SCU_PMTRCSR1_Bits.VDTCV */


/** \brief Offset for Ifx_SCU_PMTRCSR1_Bits.VDTCV */


/** \brief Length for Ifx_SCU_PMTRCSR2_Bits.LDJMPREQ */


/** \brief Mask for Ifx_SCU_PMTRCSR2_Bits.LDJMPREQ */


/** \brief Offset for Ifx_SCU_PMTRCSR2_Bits.LDJMPREQ */


/** \brief Length for Ifx_SCU_PMTRCSR2_Bits.LJTRUN */


/** \brief Mask for Ifx_SCU_PMTRCSR2_Bits.LJTRUN */


/** \brief Offset for Ifx_SCU_PMTRCSR2_Bits.LJTRUN */


/** \brief Length for Ifx_SCU_PMTRCSR2_Bits.LJTOV */


/** \brief Mask for Ifx_SCU_PMTRCSR2_Bits.LJTOV */


/** \brief Offset for Ifx_SCU_PMTRCSR2_Bits.LJTOV */


/** \brief Length for Ifx_SCU_PMTRCSR2_Bits.LJTOVCLR */


/** \brief Mask for Ifx_SCU_PMTRCSR2_Bits.LJTOVCLR */


/** \brief Offset for Ifx_SCU_PMTRCSR2_Bits.LJTOVCLR */


/** \brief Length for Ifx_SCU_PMTRCSR2_Bits.LJTCNT */


/** \brief Mask for Ifx_SCU_PMTRCSR2_Bits.LJTCNT */


/** \brief Offset for Ifx_SCU_PMTRCSR2_Bits.LJTCNT */


/** \brief Length for Ifx_SCU_PMTRCSR3_Bits.VDROOPREQ */


/** \brief Mask for Ifx_SCU_PMTRCSR3_Bits.VDROOPREQ */


/** \brief Offset for Ifx_SCU_PMTRCSR3_Bits.VDROOPREQ */


/** \brief Length for Ifx_SCU_PMTRCSR3_Bits.VDTRUN */


/** \brief Mask for Ifx_SCU_PMTRCSR3_Bits.VDTRUN */


/** \brief Offset for Ifx_SCU_PMTRCSR3_Bits.VDTRUN */


/** \brief Length for Ifx_SCU_PMTRCSR3_Bits.VDTOV */


/** \brief Mask for Ifx_SCU_PMTRCSR3_Bits.VDTOV */


/** \brief Offset for Ifx_SCU_PMTRCSR3_Bits.VDTOV */


/** \brief Length for Ifx_SCU_PMTRCSR3_Bits.VDTOVCLR */


/** \brief Mask for Ifx_SCU_PMTRCSR3_Bits.VDTOVCLR */


/** \brief Offset for Ifx_SCU_PMTRCSR3_Bits.VDTOVCLR */


/** \brief Length for Ifx_SCU_PMTRCSR3_Bits.VDTCNT */


/** \brief Mask for Ifx_SCU_PMTRCSR3_Bits.VDTCNT */


/** \brief Offset for Ifx_SCU_PMTRCSR3_Bits.VDTCNT */


/** \brief Length for Ifx_SCU_STMEM3_Bits.MEM */


/** \brief Mask for Ifx_SCU_STMEM3_Bits.MEM */


/** \brief Offset for Ifx_SCU_STMEM3_Bits.MEM */


/** \brief Length for Ifx_SCU_STMEM4_Bits.MEM */


/** \brief Mask for Ifx_SCU_STMEM4_Bits.MEM */


/** \brief Offset for Ifx_SCU_STMEM4_Bits.MEM */


/** \brief Length for Ifx_SCU_STMEM5_Bits.MEM */


/** \brief Mask for Ifx_SCU_STMEM5_Bits.MEM */


/** \brief Offset for Ifx_SCU_STMEM5_Bits.MEM */


/** \brief Length for Ifx_SCU_STMEM6_Bits.MEM */


/** \brief Mask for Ifx_SCU_STMEM6_Bits.MEM */


/** \brief Offset for Ifx_SCU_STMEM6_Bits.MEM */


/** \brief Length for Ifx_SCU_OVCENABLE_Bits.OVEN0 */


/** \brief Mask for Ifx_SCU_OVCENABLE_Bits.OVEN0 */


/** \brief Offset for Ifx_SCU_OVCENABLE_Bits.OVEN0 */


/** \brief Length for Ifx_SCU_OVCENABLE_Bits.OVEN1 */


/** \brief Mask for Ifx_SCU_OVCENABLE_Bits.OVEN1 */


/** \brief Offset for Ifx_SCU_OVCENABLE_Bits.OVEN1 */


/** \brief Length for Ifx_SCU_OVCENABLE_Bits.OVEN2 */


/** \brief Mask for Ifx_SCU_OVCENABLE_Bits.OVEN2 */


/** \brief Offset for Ifx_SCU_OVCENABLE_Bits.OVEN2 */


/** \brief Length for Ifx_SCU_OVCENABLE_Bits.OVEN3 */


/** \brief Mask for Ifx_SCU_OVCENABLE_Bits.OVEN3 */


/** \brief Offset for Ifx_SCU_OVCENABLE_Bits.OVEN3 */


/** \brief Length for Ifx_SCU_OVCCON_Bits.CSEL0 */


/** \brief Mask for Ifx_SCU_OVCCON_Bits.CSEL0 */


/** \brief Offset for Ifx_SCU_OVCCON_Bits.CSEL0 */


/** \brief Length for Ifx_SCU_OVCCON_Bits.CSEL1 */


/** \brief Mask for Ifx_SCU_OVCCON_Bits.CSEL1 */


/** \brief Offset for Ifx_SCU_OVCCON_Bits.CSEL1 */


/** \brief Length for Ifx_SCU_OVCCON_Bits.CSEL2 */


/** \brief Mask for Ifx_SCU_OVCCON_Bits.CSEL2 */


/** \brief Offset for Ifx_SCU_OVCCON_Bits.CSEL2 */


/** \brief Length for Ifx_SCU_OVCCON_Bits.CSEL3 */


/** \brief Mask for Ifx_SCU_OVCCON_Bits.CSEL3 */


/** \brief Offset for Ifx_SCU_OVCCON_Bits.CSEL3 */


/** \brief Length for Ifx_SCU_OVCCON_Bits.OVSTRT */


/** \brief Mask for Ifx_SCU_OVCCON_Bits.OVSTRT */


/** \brief Offset for Ifx_SCU_OVCCON_Bits.OVSTRT */


/** \brief Length for Ifx_SCU_OVCCON_Bits.OVSTP */


/** \brief Mask for Ifx_SCU_OVCCON_Bits.OVSTP */


/** \brief Offset for Ifx_SCU_OVCCON_Bits.OVSTP */


/** \brief Length for Ifx_SCU_OVCCON_Bits.DCINVAL */


/** \brief Mask for Ifx_SCU_OVCCON_Bits.DCINVAL */


/** \brief Offset for Ifx_SCU_OVCCON_Bits.DCINVAL */


/** \brief Length for Ifx_SCU_OVCCON_Bits.OVCONF */


/** \brief Mask for Ifx_SCU_OVCCON_Bits.OVCONF */


/** \brief Offset for Ifx_SCU_OVCCON_Bits.OVCONF */


/** \brief Length for Ifx_SCU_OVCCON_Bits.POVCONF */


/** \brief Mask for Ifx_SCU_OVCCON_Bits.POVCONF */


/** \brief Offset for Ifx_SCU_OVCCON_Bits.POVCONF */


/** \brief Length for Ifx_SCU_EIFILT_Bits.FILRQ0A */


/** \brief Mask for Ifx_SCU_EIFILT_Bits.FILRQ0A */


/** \brief Offset for Ifx_SCU_EIFILT_Bits.FILRQ0A */


/** \brief Length for Ifx_SCU_EIFILT_Bits.FILRQ5A */


/** \brief Mask for Ifx_SCU_EIFILT_Bits.FILRQ5A */


/** \brief Offset for Ifx_SCU_EIFILT_Bits.FILRQ5A */


/** \brief Length for Ifx_SCU_EIFILT_Bits.FILRQ2A */


/** \brief Mask for Ifx_SCU_EIFILT_Bits.FILRQ2A */


/** \brief Offset for Ifx_SCU_EIFILT_Bits.FILRQ2A */


/** \brief Length for Ifx_SCU_EIFILT_Bits.FILRQ3A */


/** \brief Mask for Ifx_SCU_EIFILT_Bits.FILRQ3A */


/** \brief Offset for Ifx_SCU_EIFILT_Bits.FILRQ3A */


/** \brief Length for Ifx_SCU_EIFILT_Bits.FILRQ0C */


/** \brief Mask for Ifx_SCU_EIFILT_Bits.FILRQ0C */


/** \brief Offset for Ifx_SCU_EIFILT_Bits.FILRQ0C */


/** \brief Length for Ifx_SCU_EIFILT_Bits.FILRQ1C */


/** \brief Mask for Ifx_SCU_EIFILT_Bits.FILRQ1C */


/** \brief Offset for Ifx_SCU_EIFILT_Bits.FILRQ1C */


/** \brief Length for Ifx_SCU_EIFILT_Bits.FILRQ3C */


/** \brief Mask for Ifx_SCU_EIFILT_Bits.FILRQ3C */


/** \brief Offset for Ifx_SCU_EIFILT_Bits.FILRQ3C */


/** \brief Length for Ifx_SCU_EIFILT_Bits.FILRQ2C */


/** \brief Mask for Ifx_SCU_EIFILT_Bits.FILRQ2C */


/** \brief Offset for Ifx_SCU_EIFILT_Bits.FILRQ2C */


/** \brief Length for Ifx_SCU_EIFILT_Bits.FILRQ4A */


/** \brief Mask for Ifx_SCU_EIFILT_Bits.FILRQ4A */


/** \brief Offset for Ifx_SCU_EIFILT_Bits.FILRQ4A */


/** \brief Length for Ifx_SCU_EIFILT_Bits.FILRQ6A */


/** \brief Mask for Ifx_SCU_EIFILT_Bits.FILRQ6A */


/** \brief Offset for Ifx_SCU_EIFILT_Bits.FILRQ6A */


/** \brief Length for Ifx_SCU_EIFILT_Bits.FILRQ1A */


/** \brief Mask for Ifx_SCU_EIFILT_Bits.FILRQ1A */


/** \brief Offset for Ifx_SCU_EIFILT_Bits.FILRQ1A */


/** \brief Length for Ifx_SCU_EIFILT_Bits.FILRQ7A */


/** \brief Mask for Ifx_SCU_EIFILT_Bits.FILRQ7A */


/** \brief Offset for Ifx_SCU_EIFILT_Bits.FILRQ7A */


/** \brief Length for Ifx_SCU_EIFILT_Bits.FILRQ6D */


/** \brief Mask for Ifx_SCU_EIFILT_Bits.FILRQ6D */


/** \brief Offset for Ifx_SCU_EIFILT_Bits.FILRQ6D */


/** \brief Length for Ifx_SCU_EIFILT_Bits.FILRQ4D */


/** \brief Mask for Ifx_SCU_EIFILT_Bits.FILRQ4D */


/** \brief Offset for Ifx_SCU_EIFILT_Bits.FILRQ4D */


/** \brief Length for Ifx_SCU_EIFILT_Bits.FILRQ2B */


/** \brief Mask for Ifx_SCU_EIFILT_Bits.FILRQ2B */


/** \brief Offset for Ifx_SCU_EIFILT_Bits.FILRQ2B */


/** \brief Length for Ifx_SCU_EIFILT_Bits.FILRQ3B */


/** \brief Mask for Ifx_SCU_EIFILT_Bits.FILRQ3B */


/** \brief Offset for Ifx_SCU_EIFILT_Bits.FILRQ3B */


/** \brief Length for Ifx_SCU_EIFILT_Bits.FILRQ7C */


/** \brief Mask for Ifx_SCU_EIFILT_Bits.FILRQ7C */


/** \brief Offset for Ifx_SCU_EIFILT_Bits.FILRQ7C */


/** \brief Length for Ifx_SCU_EIFILT_Bits.FILTDIV */


/** \brief Mask for Ifx_SCU_EIFILT_Bits.FILTDIV */


/** \brief Offset for Ifx_SCU_EIFILT_Bits.FILTDIV */


/** \brief Length for Ifx_SCU_EIFILT_Bits.DEPTH */


/** \brief Mask for Ifx_SCU_EIFILT_Bits.DEPTH */


/** \brief Offset for Ifx_SCU_EIFILT_Bits.DEPTH */


/** \brief Length for Ifx_SCU_EICR_Bits.EXIS0 */


/** \brief Mask for Ifx_SCU_EICR_Bits.EXIS0 */


/** \brief Offset for Ifx_SCU_EICR_Bits.EXIS0 */


/** \brief Length for Ifx_SCU_EICR_Bits.FEN0 */


/** \brief Mask for Ifx_SCU_EICR_Bits.FEN0 */


/** \brief Offset for Ifx_SCU_EICR_Bits.FEN0 */


/** \brief Length for Ifx_SCU_EICR_Bits.REN0 */


/** \brief Mask for Ifx_SCU_EICR_Bits.REN0 */


/** \brief Offset for Ifx_SCU_EICR_Bits.REN0 */


/** \brief Length for Ifx_SCU_EICR_Bits.LDEN0 */


/** \brief Mask for Ifx_SCU_EICR_Bits.LDEN0 */


/** \brief Offset for Ifx_SCU_EICR_Bits.LDEN0 */


/** \brief Length for Ifx_SCU_EICR_Bits.EIEN0 */


/** \brief Mask for Ifx_SCU_EICR_Bits.EIEN0 */


/** \brief Offset for Ifx_SCU_EICR_Bits.EIEN0 */


/** \brief Length for Ifx_SCU_EICR_Bits.INP0 */


/** \brief Mask for Ifx_SCU_EICR_Bits.INP0 */


/** \brief Offset for Ifx_SCU_EICR_Bits.INP0 */


/** \brief Length for Ifx_SCU_EICR_Bits.EXIS1 */


/** \brief Mask for Ifx_SCU_EICR_Bits.EXIS1 */


/** \brief Offset for Ifx_SCU_EICR_Bits.EXIS1 */


/** \brief Length for Ifx_SCU_EICR_Bits.FEN1 */


/** \brief Mask for Ifx_SCU_EICR_Bits.FEN1 */


/** \brief Offset for Ifx_SCU_EICR_Bits.FEN1 */


/** \brief Length for Ifx_SCU_EICR_Bits.REN1 */


/** \brief Mask for Ifx_SCU_EICR_Bits.REN1 */


/** \brief Offset for Ifx_SCU_EICR_Bits.REN1 */


/** \brief Length for Ifx_SCU_EICR_Bits.LDEN1 */


/** \brief Mask for Ifx_SCU_EICR_Bits.LDEN1 */


/** \brief Offset for Ifx_SCU_EICR_Bits.LDEN1 */


/** \brief Length for Ifx_SCU_EICR_Bits.EIEN1 */


/** \brief Mask for Ifx_SCU_EICR_Bits.EIEN1 */


/** \brief Offset for Ifx_SCU_EICR_Bits.EIEN1 */


/** \brief Length for Ifx_SCU_EICR_Bits.INP1 */


/** \brief Mask for Ifx_SCU_EICR_Bits.INP1 */


/** \brief Offset for Ifx_SCU_EICR_Bits.INP1 */


/** \brief Length for Ifx_SCU_EIFR_Bits.INTF0 */


/** \brief Mask for Ifx_SCU_EIFR_Bits.INTF0 */


/** \brief Offset for Ifx_SCU_EIFR_Bits.INTF0 */


/** \brief Length for Ifx_SCU_EIFR_Bits.INTF1 */


/** \brief Mask for Ifx_SCU_EIFR_Bits.INTF1 */


/** \brief Offset for Ifx_SCU_EIFR_Bits.INTF1 */


/** \brief Length for Ifx_SCU_EIFR_Bits.INTF2 */


/** \brief Mask for Ifx_SCU_EIFR_Bits.INTF2 */


/** \brief Offset for Ifx_SCU_EIFR_Bits.INTF2 */


/** \brief Length for Ifx_SCU_EIFR_Bits.INTF3 */


/** \brief Mask for Ifx_SCU_EIFR_Bits.INTF3 */


/** \brief Offset for Ifx_SCU_EIFR_Bits.INTF3 */


/** \brief Length for Ifx_SCU_EIFR_Bits.INTF4 */


/** \brief Mask for Ifx_SCU_EIFR_Bits.INTF4 */


/** \brief Offset for Ifx_SCU_EIFR_Bits.INTF4 */


/** \brief Length for Ifx_SCU_EIFR_Bits.INTF5 */


/** \brief Mask for Ifx_SCU_EIFR_Bits.INTF5 */


/** \brief Offset for Ifx_SCU_EIFR_Bits.INTF5 */


/** \brief Length for Ifx_SCU_EIFR_Bits.INTF6 */


/** \brief Mask for Ifx_SCU_EIFR_Bits.INTF6 */


/** \brief Offset for Ifx_SCU_EIFR_Bits.INTF6 */


/** \brief Length for Ifx_SCU_EIFR_Bits.INTF7 */


/** \brief Mask for Ifx_SCU_EIFR_Bits.INTF7 */


/** \brief Offset for Ifx_SCU_EIFR_Bits.INTF7 */


/** \brief Length for Ifx_SCU_FMR_Bits.FS0 */


/** \brief Mask for Ifx_SCU_FMR_Bits.FS0 */


/** \brief Offset for Ifx_SCU_FMR_Bits.FS0 */


/** \brief Length for Ifx_SCU_FMR_Bits.FS1 */


/** \brief Mask for Ifx_SCU_FMR_Bits.FS1 */


/** \brief Offset for Ifx_SCU_FMR_Bits.FS1 */


/** \brief Length for Ifx_SCU_FMR_Bits.FS2 */


/** \brief Mask for Ifx_SCU_FMR_Bits.FS2 */


/** \brief Offset for Ifx_SCU_FMR_Bits.FS2 */


/** \brief Length for Ifx_SCU_FMR_Bits.FS3 */


/** \brief Mask for Ifx_SCU_FMR_Bits.FS3 */


/** \brief Offset for Ifx_SCU_FMR_Bits.FS3 */


/** \brief Length for Ifx_SCU_FMR_Bits.FS4 */


/** \brief Mask for Ifx_SCU_FMR_Bits.FS4 */


/** \brief Offset for Ifx_SCU_FMR_Bits.FS4 */


/** \brief Length for Ifx_SCU_FMR_Bits.FS5 */


/** \brief Mask for Ifx_SCU_FMR_Bits.FS5 */


/** \brief Offset for Ifx_SCU_FMR_Bits.FS5 */


/** \brief Length for Ifx_SCU_FMR_Bits.FS6 */


/** \brief Mask for Ifx_SCU_FMR_Bits.FS6 */


/** \brief Offset for Ifx_SCU_FMR_Bits.FS6 */


/** \brief Length for Ifx_SCU_FMR_Bits.FS7 */


/** \brief Mask for Ifx_SCU_FMR_Bits.FS7 */


/** \brief Offset for Ifx_SCU_FMR_Bits.FS7 */


/** \brief Length for Ifx_SCU_FMR_Bits.FC0 */


/** \brief Mask for Ifx_SCU_FMR_Bits.FC0 */


/** \brief Offset for Ifx_SCU_FMR_Bits.FC0 */


/** \brief Length for Ifx_SCU_FMR_Bits.FC1 */


/** \brief Mask for Ifx_SCU_FMR_Bits.FC1 */


/** \brief Offset for Ifx_SCU_FMR_Bits.FC1 */


/** \brief Length for Ifx_SCU_FMR_Bits.FC2 */


/** \brief Mask for Ifx_SCU_FMR_Bits.FC2 */


/** \brief Offset for Ifx_SCU_FMR_Bits.FC2 */


/** \brief Length for Ifx_SCU_FMR_Bits.FC3 */


/** \brief Mask for Ifx_SCU_FMR_Bits.FC3 */


/** \brief Offset for Ifx_SCU_FMR_Bits.FC3 */


/** \brief Length for Ifx_SCU_FMR_Bits.FC4 */


/** \brief Mask for Ifx_SCU_FMR_Bits.FC4 */


/** \brief Offset for Ifx_SCU_FMR_Bits.FC4 */


/** \brief Length for Ifx_SCU_FMR_Bits.FC5 */


/** \brief Mask for Ifx_SCU_FMR_Bits.FC5 */


/** \brief Offset for Ifx_SCU_FMR_Bits.FC5 */


/** \brief Length for Ifx_SCU_FMR_Bits.FC6 */


/** \brief Mask for Ifx_SCU_FMR_Bits.FC6 */


/** \brief Offset for Ifx_SCU_FMR_Bits.FC6 */


/** \brief Length for Ifx_SCU_FMR_Bits.FC7 */


/** \brief Mask for Ifx_SCU_FMR_Bits.FC7 */


/** \brief Offset for Ifx_SCU_FMR_Bits.FC7 */


/** \brief Length for Ifx_SCU_PDRR_Bits.PDR0 */


/** \brief Mask for Ifx_SCU_PDRR_Bits.PDR0 */


/** \brief Offset for Ifx_SCU_PDRR_Bits.PDR0 */


/** \brief Length for Ifx_SCU_PDRR_Bits.PDR1 */


/** \brief Mask for Ifx_SCU_PDRR_Bits.PDR1 */


/** \brief Offset for Ifx_SCU_PDRR_Bits.PDR1 */


/** \brief Length for Ifx_SCU_PDRR_Bits.PDR2 */


/** \brief Mask for Ifx_SCU_PDRR_Bits.PDR2 */


/** \brief Offset for Ifx_SCU_PDRR_Bits.PDR2 */


/** \brief Length for Ifx_SCU_PDRR_Bits.PDR3 */


/** \brief Mask for Ifx_SCU_PDRR_Bits.PDR3 */


/** \brief Offset for Ifx_SCU_PDRR_Bits.PDR3 */


/** \brief Length for Ifx_SCU_PDRR_Bits.PDR4 */


/** \brief Mask for Ifx_SCU_PDRR_Bits.PDR4 */


/** \brief Offset for Ifx_SCU_PDRR_Bits.PDR4 */


/** \brief Length for Ifx_SCU_PDRR_Bits.PDR5 */


/** \brief Mask for Ifx_SCU_PDRR_Bits.PDR5 */


/** \brief Offset for Ifx_SCU_PDRR_Bits.PDR5 */


/** \brief Length for Ifx_SCU_PDRR_Bits.PDR6 */


/** \brief Mask for Ifx_SCU_PDRR_Bits.PDR6 */


/** \brief Offset for Ifx_SCU_PDRR_Bits.PDR6 */


/** \brief Length for Ifx_SCU_PDRR_Bits.PDR7 */


/** \brief Mask for Ifx_SCU_PDRR_Bits.PDR7 */


/** \brief Offset for Ifx_SCU_PDRR_Bits.PDR7 */


/** \brief Length for Ifx_SCU_IGCR_Bits.IPEN00 */


/** \brief Mask for Ifx_SCU_IGCR_Bits.IPEN00 */


/** \brief Offset for Ifx_SCU_IGCR_Bits.IPEN00 */


/** \brief Length for Ifx_SCU_IGCR_Bits.IPEN01 */


/** \brief Mask for Ifx_SCU_IGCR_Bits.IPEN01 */


/** \brief Offset for Ifx_SCU_IGCR_Bits.IPEN01 */


/** \brief Length for Ifx_SCU_IGCR_Bits.IPEN02 */


/** \brief Mask for Ifx_SCU_IGCR_Bits.IPEN02 */


/** \brief Offset for Ifx_SCU_IGCR_Bits.IPEN02 */


/** \brief Length for Ifx_SCU_IGCR_Bits.IPEN03 */


/** \brief Mask for Ifx_SCU_IGCR_Bits.IPEN03 */


/** \brief Offset for Ifx_SCU_IGCR_Bits.IPEN03 */


/** \brief Length for Ifx_SCU_IGCR_Bits.IPEN04 */


/** \brief Mask for Ifx_SCU_IGCR_Bits.IPEN04 */


/** \brief Offset for Ifx_SCU_IGCR_Bits.IPEN04 */


/** \brief Length for Ifx_SCU_IGCR_Bits.IPEN05 */


/** \brief Mask for Ifx_SCU_IGCR_Bits.IPEN05 */


/** \brief Offset for Ifx_SCU_IGCR_Bits.IPEN05 */


/** \brief Length for Ifx_SCU_IGCR_Bits.IPEN06 */


/** \brief Mask for Ifx_SCU_IGCR_Bits.IPEN06 */


/** \brief Offset for Ifx_SCU_IGCR_Bits.IPEN06 */


/** \brief Length for Ifx_SCU_IGCR_Bits.IPEN07 */


/** \brief Mask for Ifx_SCU_IGCR_Bits.IPEN07 */


/** \brief Offset for Ifx_SCU_IGCR_Bits.IPEN07 */


/** \brief Length for Ifx_SCU_IGCR_Bits.GEEN0 */


/** \brief Mask for Ifx_SCU_IGCR_Bits.GEEN0 */


/** \brief Offset for Ifx_SCU_IGCR_Bits.GEEN0 */


/** \brief Length for Ifx_SCU_IGCR_Bits.IGP0 */


/** \brief Mask for Ifx_SCU_IGCR_Bits.IGP0 */


/** \brief Offset for Ifx_SCU_IGCR_Bits.IGP0 */


/** \brief Length for Ifx_SCU_IGCR_Bits.IPEN10 */


/** \brief Mask for Ifx_SCU_IGCR_Bits.IPEN10 */


/** \brief Offset for Ifx_SCU_IGCR_Bits.IPEN10 */


/** \brief Length for Ifx_SCU_IGCR_Bits.IPEN11 */


/** \brief Mask for Ifx_SCU_IGCR_Bits.IPEN11 */


/** \brief Offset for Ifx_SCU_IGCR_Bits.IPEN11 */


/** \brief Length for Ifx_SCU_IGCR_Bits.IPEN12 */


/** \brief Mask for Ifx_SCU_IGCR_Bits.IPEN12 */


/** \brief Offset for Ifx_SCU_IGCR_Bits.IPEN12 */


/** \brief Length for Ifx_SCU_IGCR_Bits.IPEN13 */


/** \brief Mask for Ifx_SCU_IGCR_Bits.IPEN13 */


/** \brief Offset for Ifx_SCU_IGCR_Bits.IPEN13 */


/** \brief Length for Ifx_SCU_IGCR_Bits.IPEN14 */


/** \brief Mask for Ifx_SCU_IGCR_Bits.IPEN14 */


/** \brief Offset for Ifx_SCU_IGCR_Bits.IPEN14 */


/** \brief Length for Ifx_SCU_IGCR_Bits.IPEN15 */


/** \brief Mask for Ifx_SCU_IGCR_Bits.IPEN15 */


/** \brief Offset for Ifx_SCU_IGCR_Bits.IPEN15 */


/** \brief Length for Ifx_SCU_IGCR_Bits.IPEN16 */


/** \brief Mask for Ifx_SCU_IGCR_Bits.IPEN16 */


/** \brief Offset for Ifx_SCU_IGCR_Bits.IPEN16 */


/** \brief Length for Ifx_SCU_IGCR_Bits.IPEN17 */


/** \brief Mask for Ifx_SCU_IGCR_Bits.IPEN17 */


/** \brief Offset for Ifx_SCU_IGCR_Bits.IPEN17 */


/** \brief Length for Ifx_SCU_IGCR_Bits.GEEN1 */


/** \brief Mask for Ifx_SCU_IGCR_Bits.GEEN1 */


/** \brief Offset for Ifx_SCU_IGCR_Bits.GEEN1 */


/** \brief Length for Ifx_SCU_IGCR_Bits.IGP1 */


/** \brief Mask for Ifx_SCU_IGCR_Bits.IGP1 */


/** \brief Offset for Ifx_SCU_IGCR_Bits.IGP1 */


/** \brief Length for Ifx_SCU_WDTCPU_CON0_Bits.ENDINIT */


/** \brief Mask for Ifx_SCU_WDTCPU_CON0_Bits.ENDINIT */


/** \brief Offset for Ifx_SCU_WDTCPU_CON0_Bits.ENDINIT */


/** \brief Length for Ifx_SCU_WDTCPU_CON0_Bits.LCK */


/** \brief Mask for Ifx_SCU_WDTCPU_CON0_Bits.LCK */


/** \brief Offset for Ifx_SCU_WDTCPU_CON0_Bits.LCK */


/** \brief Length for Ifx_SCU_WDTCPU_CON0_Bits.PW */


/** \brief Mask for Ifx_SCU_WDTCPU_CON0_Bits.PW */


/** \brief Offset for Ifx_SCU_WDTCPU_CON0_Bits.PW */


/** \brief Length for Ifx_SCU_WDTCPU_CON0_Bits.REL */


/** \brief Mask for Ifx_SCU_WDTCPU_CON0_Bits.REL */


/** \brief Offset for Ifx_SCU_WDTCPU_CON0_Bits.REL */


/** \brief Length for Ifx_SCU_WDTCPU_CON1_Bits.IR0 */


/** \brief Mask for Ifx_SCU_WDTCPU_CON1_Bits.IR0 */


/** \brief Offset for Ifx_SCU_WDTCPU_CON1_Bits.IR0 */


/** \brief Length for Ifx_SCU_WDTCPU_CON1_Bits.DR */


/** \brief Mask for Ifx_SCU_WDTCPU_CON1_Bits.DR */


/** \brief Offset for Ifx_SCU_WDTCPU_CON1_Bits.DR */


/** \brief Length for Ifx_SCU_WDTCPU_CON1_Bits.IR1 */


/** \brief Mask for Ifx_SCU_WDTCPU_CON1_Bits.IR1 */


/** \brief Offset for Ifx_SCU_WDTCPU_CON1_Bits.IR1 */


/** \brief Length for Ifx_SCU_WDTCPU_CON1_Bits.UR */


/** \brief Mask for Ifx_SCU_WDTCPU_CON1_Bits.UR */


/** \brief Offset for Ifx_SCU_WDTCPU_CON1_Bits.UR */


/** \brief Length for Ifx_SCU_WDTCPU_CON1_Bits.PAR */


/** \brief Mask for Ifx_SCU_WDTCPU_CON1_Bits.PAR */


/** \brief Offset for Ifx_SCU_WDTCPU_CON1_Bits.PAR */


/** \brief Length for Ifx_SCU_WDTCPU_CON1_Bits.TCR */


/** \brief Mask for Ifx_SCU_WDTCPU_CON1_Bits.TCR */


/** \brief Offset for Ifx_SCU_WDTCPU_CON1_Bits.TCR */


/** \brief Length for Ifx_SCU_WDTCPU_CON1_Bits.TCTR */


/** \brief Mask for Ifx_SCU_WDTCPU_CON1_Bits.TCTR */


/** \brief Offset for Ifx_SCU_WDTCPU_CON1_Bits.TCTR */


/** \brief Length for Ifx_SCU_WDTCPU_SR_Bits.AE */


/** \brief Mask for Ifx_SCU_WDTCPU_SR_Bits.AE */


/** \brief Offset for Ifx_SCU_WDTCPU_SR_Bits.AE */


/** \brief Length for Ifx_SCU_WDTCPU_SR_Bits.OE */


/** \brief Mask for Ifx_SCU_WDTCPU_SR_Bits.OE */


/** \brief Offset for Ifx_SCU_WDTCPU_SR_Bits.OE */


/** \brief Length for Ifx_SCU_WDTCPU_SR_Bits.IS0 */


/** \brief Mask for Ifx_SCU_WDTCPU_SR_Bits.IS0 */


/** \brief Offset for Ifx_SCU_WDTCPU_SR_Bits.IS0 */


/** \brief Length for Ifx_SCU_WDTCPU_SR_Bits.DS */


/** \brief Mask for Ifx_SCU_WDTCPU_SR_Bits.DS */


/** \brief Offset for Ifx_SCU_WDTCPU_SR_Bits.DS */


/** \brief Length for Ifx_SCU_WDTCPU_SR_Bits.TO */


/** \brief Mask for Ifx_SCU_WDTCPU_SR_Bits.TO */


/** \brief Offset for Ifx_SCU_WDTCPU_SR_Bits.TO */


/** \brief Length for Ifx_SCU_WDTCPU_SR_Bits.IS1 */


/** \brief Mask for Ifx_SCU_WDTCPU_SR_Bits.IS1 */


/** \brief Offset for Ifx_SCU_WDTCPU_SR_Bits.IS1 */


/** \brief Length for Ifx_SCU_WDTCPU_SR_Bits.US */


/** \brief Mask for Ifx_SCU_WDTCPU_SR_Bits.US */


/** \brief Offset for Ifx_SCU_WDTCPU_SR_Bits.US */


/** \brief Length for Ifx_SCU_WDTCPU_SR_Bits.PAS */


/** \brief Mask for Ifx_SCU_WDTCPU_SR_Bits.PAS */


/** \brief Offset for Ifx_SCU_WDTCPU_SR_Bits.PAS */


/** \brief Length for Ifx_SCU_WDTCPU_SR_Bits.TCS */


/** \brief Mask for Ifx_SCU_WDTCPU_SR_Bits.TCS */


/** \brief Offset for Ifx_SCU_WDTCPU_SR_Bits.TCS */


/** \brief Length for Ifx_SCU_WDTCPU_SR_Bits.TCT */


/** \brief Mask for Ifx_SCU_WDTCPU_SR_Bits.TCT */


/** \brief Offset for Ifx_SCU_WDTCPU_SR_Bits.TCT */


/** \brief Length for Ifx_SCU_WDTCPU_SR_Bits.TIM */


/** \brief Mask for Ifx_SCU_WDTCPU_SR_Bits.TIM */


/** \brief Offset for Ifx_SCU_WDTCPU_SR_Bits.TIM */


/** \brief Length for Ifx_SCU_EICON0_Bits.ENDINIT */


/** \brief Mask for Ifx_SCU_EICON0_Bits.ENDINIT */


/** \brief Offset for Ifx_SCU_EICON0_Bits.ENDINIT */


/** \brief Length for Ifx_SCU_EICON0_Bits.EPW */


/** \brief Mask for Ifx_SCU_EICON0_Bits.EPW */


/** \brief Offset for Ifx_SCU_EICON0_Bits.EPW */


/** \brief Length for Ifx_SCU_EICON0_Bits.REL */


/** \brief Mask for Ifx_SCU_EICON0_Bits.REL */


/** \brief Offset for Ifx_SCU_EICON0_Bits.REL */


/** \brief Length for Ifx_SCU_EICON1_Bits.IR0 */


/** \brief Mask for Ifx_SCU_EICON1_Bits.IR0 */


/** \brief Offset for Ifx_SCU_EICON1_Bits.IR0 */


/** \brief Length for Ifx_SCU_EICON1_Bits.DR */


/** \brief Mask for Ifx_SCU_EICON1_Bits.DR */


/** \brief Offset for Ifx_SCU_EICON1_Bits.DR */


/** \brief Length for Ifx_SCU_EICON1_Bits.IR1 */


/** \brief Mask for Ifx_SCU_EICON1_Bits.IR1 */


/** \brief Offset for Ifx_SCU_EICON1_Bits.IR1 */


/** \brief Length for Ifx_SCU_EISR_Bits.AE */


/** \brief Mask for Ifx_SCU_EISR_Bits.AE */


/** \brief Offset for Ifx_SCU_EISR_Bits.AE */


/** \brief Length for Ifx_SCU_EISR_Bits.OE */


/** \brief Mask for Ifx_SCU_EISR_Bits.OE */


/** \brief Offset for Ifx_SCU_EISR_Bits.OE */


/** \brief Length for Ifx_SCU_EISR_Bits.IS0 */


/** \brief Mask for Ifx_SCU_EISR_Bits.IS0 */


/** \brief Offset for Ifx_SCU_EISR_Bits.IS0 */


/** \brief Length for Ifx_SCU_EISR_Bits.DS */


/** \brief Mask for Ifx_SCU_EISR_Bits.DS */


/** \brief Offset for Ifx_SCU_EISR_Bits.DS */


/** \brief Length for Ifx_SCU_EISR_Bits.TO */


/** \brief Mask for Ifx_SCU_EISR_Bits.TO */


/** \brief Offset for Ifx_SCU_EISR_Bits.TO */


/** \brief Length for Ifx_SCU_EISR_Bits.IS1 */


/** \brief Mask for Ifx_SCU_EISR_Bits.IS1 */


/** \brief Offset for Ifx_SCU_EISR_Bits.IS1 */


/** \brief Length for Ifx_SCU_EISR_Bits.TIM */


/** \brief Mask for Ifx_SCU_EISR_Bits.TIM */


/** \brief Offset for Ifx_SCU_EISR_Bits.TIM */


/** \brief Length for Ifx_SCU_WDTS_CON0_Bits.ENDINIT */


/** \brief Mask for Ifx_SCU_WDTS_CON0_Bits.ENDINIT */


/** \brief Offset for Ifx_SCU_WDTS_CON0_Bits.ENDINIT */


/** \brief Length for Ifx_SCU_WDTS_CON0_Bits.LCK */


/** \brief Mask for Ifx_SCU_WDTS_CON0_Bits.LCK */


/** \brief Offset for Ifx_SCU_WDTS_CON0_Bits.LCK */


/** \brief Length for Ifx_SCU_WDTS_CON0_Bits.PW */


/** \brief Mask for Ifx_SCU_WDTS_CON0_Bits.PW */


/** \brief Offset for Ifx_SCU_WDTS_CON0_Bits.PW */


/** \brief Length for Ifx_SCU_WDTS_CON0_Bits.REL */


/** \brief Mask for Ifx_SCU_WDTS_CON0_Bits.REL */


/** \brief Offset for Ifx_SCU_WDTS_CON0_Bits.REL */


/** \brief Length for Ifx_SCU_WDTS_CON1_Bits.CLRIRF */


/** \brief Mask for Ifx_SCU_WDTS_CON1_Bits.CLRIRF */


/** \brief Offset for Ifx_SCU_WDTS_CON1_Bits.CLRIRF */


/** \brief Length for Ifx_SCU_WDTS_CON1_Bits.IR0 */


/** \brief Mask for Ifx_SCU_WDTS_CON1_Bits.IR0 */


/** \brief Offset for Ifx_SCU_WDTS_CON1_Bits.IR0 */


/** \brief Length for Ifx_SCU_WDTS_CON1_Bits.DR */


/** \brief Mask for Ifx_SCU_WDTS_CON1_Bits.DR */


/** \brief Offset for Ifx_SCU_WDTS_CON1_Bits.DR */


/** \brief Length for Ifx_SCU_WDTS_CON1_Bits.IR1 */


/** \brief Mask for Ifx_SCU_WDTS_CON1_Bits.IR1 */


/** \brief Offset for Ifx_SCU_WDTS_CON1_Bits.IR1 */


/** \brief Length for Ifx_SCU_WDTS_CON1_Bits.UR */


/** \brief Mask for Ifx_SCU_WDTS_CON1_Bits.UR */


/** \brief Offset for Ifx_SCU_WDTS_CON1_Bits.UR */


/** \brief Length for Ifx_SCU_WDTS_CON1_Bits.PAR */


/** \brief Mask for Ifx_SCU_WDTS_CON1_Bits.PAR */


/** \brief Offset for Ifx_SCU_WDTS_CON1_Bits.PAR */


/** \brief Length for Ifx_SCU_WDTS_CON1_Bits.TCR */


/** \brief Mask for Ifx_SCU_WDTS_CON1_Bits.TCR */


/** \brief Offset for Ifx_SCU_WDTS_CON1_Bits.TCR */


/** \brief Length for Ifx_SCU_WDTS_CON1_Bits.TCTR */


/** \brief Mask for Ifx_SCU_WDTS_CON1_Bits.TCTR */


/** \brief Offset for Ifx_SCU_WDTS_CON1_Bits.TCTR */


/** \brief Length for Ifx_SCU_WDTS_SR_Bits.AE */


/** \brief Mask for Ifx_SCU_WDTS_SR_Bits.AE */


/** \brief Offset for Ifx_SCU_WDTS_SR_Bits.AE */


/** \brief Length for Ifx_SCU_WDTS_SR_Bits.OE */


/** \brief Mask for Ifx_SCU_WDTS_SR_Bits.OE */


/** \brief Offset for Ifx_SCU_WDTS_SR_Bits.OE */


/** \brief Length for Ifx_SCU_WDTS_SR_Bits.IS0 */


/** \brief Mask for Ifx_SCU_WDTS_SR_Bits.IS0 */


/** \brief Offset for Ifx_SCU_WDTS_SR_Bits.IS0 */


/** \brief Length for Ifx_SCU_WDTS_SR_Bits.DS */


/** \brief Mask for Ifx_SCU_WDTS_SR_Bits.DS */


/** \brief Offset for Ifx_SCU_WDTS_SR_Bits.DS */


/** \brief Length for Ifx_SCU_WDTS_SR_Bits.TO */


/** \brief Mask for Ifx_SCU_WDTS_SR_Bits.TO */


/** \brief Offset for Ifx_SCU_WDTS_SR_Bits.TO */


/** \brief Length for Ifx_SCU_WDTS_SR_Bits.IS1 */


/** \brief Mask for Ifx_SCU_WDTS_SR_Bits.IS1 */


/** \brief Offset for Ifx_SCU_WDTS_SR_Bits.IS1 */


/** \brief Length for Ifx_SCU_WDTS_SR_Bits.US */


/** \brief Mask for Ifx_SCU_WDTS_SR_Bits.US */


/** \brief Offset for Ifx_SCU_WDTS_SR_Bits.US */


/** \brief Length for Ifx_SCU_WDTS_SR_Bits.PAS */


/** \brief Mask for Ifx_SCU_WDTS_SR_Bits.PAS */


/** \brief Offset for Ifx_SCU_WDTS_SR_Bits.PAS */


/** \brief Length for Ifx_SCU_WDTS_SR_Bits.TCS */


/** \brief Mask for Ifx_SCU_WDTS_SR_Bits.TCS */


/** \brief Offset for Ifx_SCU_WDTS_SR_Bits.TCS */


/** \brief Length for Ifx_SCU_WDTS_SR_Bits.TCT */


/** \brief Mask for Ifx_SCU_WDTS_SR_Bits.TCT */


/** \brief Offset for Ifx_SCU_WDTS_SR_Bits.TCT */


/** \brief Length for Ifx_SCU_WDTS_SR_Bits.TIM */


/** \brief Mask for Ifx_SCU_WDTS_SR_Bits.TIM */


/** \brief Offset for Ifx_SCU_WDTS_SR_Bits.TIM */


/** \brief Length for Ifx_SCU_SEICON0_Bits.ENDINIT */


/** \brief Mask for Ifx_SCU_SEICON0_Bits.ENDINIT */


/** \brief Offset for Ifx_SCU_SEICON0_Bits.ENDINIT */


/** \brief Length for Ifx_SCU_SEICON0_Bits.EPW */


/** \brief Mask for Ifx_SCU_SEICON0_Bits.EPW */


/** \brief Offset for Ifx_SCU_SEICON0_Bits.EPW */


/** \brief Length for Ifx_SCU_SEICON0_Bits.REL */


/** \brief Mask for Ifx_SCU_SEICON0_Bits.REL */


/** \brief Offset for Ifx_SCU_SEICON0_Bits.REL */


/** \brief Length for Ifx_SCU_SEICON1_Bits.IR0 */


/** \brief Mask for Ifx_SCU_SEICON1_Bits.IR0 */


/** \brief Offset for Ifx_SCU_SEICON1_Bits.IR0 */


/** \brief Length for Ifx_SCU_SEICON1_Bits.DR */


/** \brief Mask for Ifx_SCU_SEICON1_Bits.DR */


/** \brief Offset for Ifx_SCU_SEICON1_Bits.DR */


/** \brief Length for Ifx_SCU_SEICON1_Bits.IR1 */


/** \brief Mask for Ifx_SCU_SEICON1_Bits.IR1 */


/** \brief Offset for Ifx_SCU_SEICON1_Bits.IR1 */


/** \brief Length for Ifx_SCU_SEISR_Bits.AE */


/** \brief Mask for Ifx_SCU_SEISR_Bits.AE */


/** \brief Offset for Ifx_SCU_SEISR_Bits.AE */


/** \brief Length for Ifx_SCU_SEISR_Bits.OE */


/** \brief Mask for Ifx_SCU_SEISR_Bits.OE */


/** \brief Offset for Ifx_SCU_SEISR_Bits.OE */


/** \brief Length for Ifx_SCU_SEISR_Bits.IS0 */


/** \brief Mask for Ifx_SCU_SEISR_Bits.IS0 */


/** \brief Offset for Ifx_SCU_SEISR_Bits.IS0 */


/** \brief Length for Ifx_SCU_SEISR_Bits.DS */


/** \brief Mask for Ifx_SCU_SEISR_Bits.DS */


/** \brief Offset for Ifx_SCU_SEISR_Bits.DS */


/** \brief Length for Ifx_SCU_SEISR_Bits.TO */


/** \brief Mask for Ifx_SCU_SEISR_Bits.TO */


/** \brief Offset for Ifx_SCU_SEISR_Bits.TO */


/** \brief Length for Ifx_SCU_SEISR_Bits.IS1 */


/** \brief Mask for Ifx_SCU_SEISR_Bits.IS1 */


/** \brief Offset for Ifx_SCU_SEISR_Bits.IS1 */


/** \brief Length for Ifx_SCU_SEISR_Bits.TIM */


/** \brief Mask for Ifx_SCU_SEISR_Bits.TIM */


/** \brief Offset for Ifx_SCU_SEISR_Bits.TIM */


/** \brief Length for Ifx_SCU_ACCEN10_Bits.EN0 */


/** \brief Mask for Ifx_SCU_ACCEN10_Bits.EN0 */


/** \brief Offset for Ifx_SCU_ACCEN10_Bits.EN0 */


/** \brief Length for Ifx_SCU_ACCEN10_Bits.EN1 */


/** \brief Mask for Ifx_SCU_ACCEN10_Bits.EN1 */


/** \brief Offset for Ifx_SCU_ACCEN10_Bits.EN1 */


/** \brief Length for Ifx_SCU_ACCEN10_Bits.EN2 */


/** \brief Mask for Ifx_SCU_ACCEN10_Bits.EN2 */


/** \brief Offset for Ifx_SCU_ACCEN10_Bits.EN2 */


/** \brief Length for Ifx_SCU_ACCEN10_Bits.EN3 */


/** \brief Mask for Ifx_SCU_ACCEN10_Bits.EN3 */


/** \brief Offset for Ifx_SCU_ACCEN10_Bits.EN3 */


/** \brief Length for Ifx_SCU_ACCEN10_Bits.EN4 */


/** \brief Mask for Ifx_SCU_ACCEN10_Bits.EN4 */


/** \brief Offset for Ifx_SCU_ACCEN10_Bits.EN4 */


/** \brief Length for Ifx_SCU_ACCEN10_Bits.EN5 */


/** \brief Mask for Ifx_SCU_ACCEN10_Bits.EN5 */


/** \brief Offset for Ifx_SCU_ACCEN10_Bits.EN5 */


/** \brief Length for Ifx_SCU_ACCEN10_Bits.EN6 */


/** \brief Mask for Ifx_SCU_ACCEN10_Bits.EN6 */


/** \brief Offset for Ifx_SCU_ACCEN10_Bits.EN6 */


/** \brief Length for Ifx_SCU_ACCEN10_Bits.EN7 */


/** \brief Mask for Ifx_SCU_ACCEN10_Bits.EN7 */


/** \brief Offset for Ifx_SCU_ACCEN10_Bits.EN7 */


/** \brief Length for Ifx_SCU_ACCEN10_Bits.EN8 */


/** \brief Mask for Ifx_SCU_ACCEN10_Bits.EN8 */


/** \brief Offset for Ifx_SCU_ACCEN10_Bits.EN8 */


/** \brief Length for Ifx_SCU_ACCEN10_Bits.EN9 */


/** \brief Mask for Ifx_SCU_ACCEN10_Bits.EN9 */


/** \brief Offset for Ifx_SCU_ACCEN10_Bits.EN9 */


/** \brief Length for Ifx_SCU_ACCEN10_Bits.EN10 */


/** \brief Mask for Ifx_SCU_ACCEN10_Bits.EN10 */


/** \brief Offset for Ifx_SCU_ACCEN10_Bits.EN10 */


/** \brief Length for Ifx_SCU_ACCEN10_Bits.EN11 */


/** \brief Mask for Ifx_SCU_ACCEN10_Bits.EN11 */


/** \brief Offset for Ifx_SCU_ACCEN10_Bits.EN11 */


/** \brief Length for Ifx_SCU_ACCEN10_Bits.EN12 */


/** \brief Mask for Ifx_SCU_ACCEN10_Bits.EN12 */


/** \brief Offset for Ifx_SCU_ACCEN10_Bits.EN12 */


/** \brief Length for Ifx_SCU_ACCEN10_Bits.EN13 */


/** \brief Mask for Ifx_SCU_ACCEN10_Bits.EN13 */


/** \brief Offset for Ifx_SCU_ACCEN10_Bits.EN13 */


/** \brief Length for Ifx_SCU_ACCEN10_Bits.EN14 */


/** \brief Mask for Ifx_SCU_ACCEN10_Bits.EN14 */


/** \brief Offset for Ifx_SCU_ACCEN10_Bits.EN14 */


/** \brief Length for Ifx_SCU_ACCEN10_Bits.EN15 */


/** \brief Mask for Ifx_SCU_ACCEN10_Bits.EN15 */


/** \brief Offset for Ifx_SCU_ACCEN10_Bits.EN15 */


/** \brief Length for Ifx_SCU_ACCEN10_Bits.EN16 */


/** \brief Mask for Ifx_SCU_ACCEN10_Bits.EN16 */


/** \brief Offset for Ifx_SCU_ACCEN10_Bits.EN16 */


/** \brief Length for Ifx_SCU_ACCEN10_Bits.EN17 */


/** \brief Mask for Ifx_SCU_ACCEN10_Bits.EN17 */


/** \brief Offset for Ifx_SCU_ACCEN10_Bits.EN17 */


/** \brief Length for Ifx_SCU_ACCEN10_Bits.EN18 */


/** \brief Mask for Ifx_SCU_ACCEN10_Bits.EN18 */


/** \brief Offset for Ifx_SCU_ACCEN10_Bits.EN18 */


/** \brief Length for Ifx_SCU_ACCEN10_Bits.EN19 */


/** \brief Mask for Ifx_SCU_ACCEN10_Bits.EN19 */


/** \brief Offset for Ifx_SCU_ACCEN10_Bits.EN19 */


/** \brief Length for Ifx_SCU_ACCEN10_Bits.EN20 */


/** \brief Mask for Ifx_SCU_ACCEN10_Bits.EN20 */


/** \brief Offset for Ifx_SCU_ACCEN10_Bits.EN20 */


/** \brief Length for Ifx_SCU_ACCEN10_Bits.EN21 */


/** \brief Mask for Ifx_SCU_ACCEN10_Bits.EN21 */


/** \brief Offset for Ifx_SCU_ACCEN10_Bits.EN21 */


/** \brief Length for Ifx_SCU_ACCEN10_Bits.EN22 */


/** \brief Mask for Ifx_SCU_ACCEN10_Bits.EN22 */


/** \brief Offset for Ifx_SCU_ACCEN10_Bits.EN22 */


/** \brief Length for Ifx_SCU_ACCEN10_Bits.EN23 */


/** \brief Mask for Ifx_SCU_ACCEN10_Bits.EN23 */


/** \brief Offset for Ifx_SCU_ACCEN10_Bits.EN23 */


/** \brief Length for Ifx_SCU_ACCEN10_Bits.EN24 */


/** \brief Mask for Ifx_SCU_ACCEN10_Bits.EN24 */


/** \brief Offset for Ifx_SCU_ACCEN10_Bits.EN24 */


/** \brief Length for Ifx_SCU_ACCEN10_Bits.EN25 */


/** \brief Mask for Ifx_SCU_ACCEN10_Bits.EN25 */


/** \brief Offset for Ifx_SCU_ACCEN10_Bits.EN25 */


/** \brief Length for Ifx_SCU_ACCEN10_Bits.EN26 */


/** \brief Mask for Ifx_SCU_ACCEN10_Bits.EN26 */


/** \brief Offset for Ifx_SCU_ACCEN10_Bits.EN26 */


/** \brief Length for Ifx_SCU_ACCEN10_Bits.EN27 */


/** \brief Mask for Ifx_SCU_ACCEN10_Bits.EN27 */


/** \brief Offset for Ifx_SCU_ACCEN10_Bits.EN27 */


/** \brief Length for Ifx_SCU_ACCEN10_Bits.EN28 */


/** \brief Mask for Ifx_SCU_ACCEN10_Bits.EN28 */


/** \brief Offset for Ifx_SCU_ACCEN10_Bits.EN28 */


/** \brief Length for Ifx_SCU_ACCEN10_Bits.EN29 */


/** \brief Mask for Ifx_SCU_ACCEN10_Bits.EN29 */


/** \brief Offset for Ifx_SCU_ACCEN10_Bits.EN29 */


/** \brief Length for Ifx_SCU_ACCEN10_Bits.EN30 */


/** \brief Mask for Ifx_SCU_ACCEN10_Bits.EN30 */


/** \brief Offset for Ifx_SCU_ACCEN10_Bits.EN30 */


/** \brief Length for Ifx_SCU_ACCEN10_Bits.EN31 */


/** \brief Mask for Ifx_SCU_ACCEN10_Bits.EN31 */


/** \brief Offset for Ifx_SCU_ACCEN10_Bits.EN31 */


/** \brief Length for Ifx_SCU_ACCEN00_Bits.EN0 */


/** \brief Mask for Ifx_SCU_ACCEN00_Bits.EN0 */


/** \brief Offset for Ifx_SCU_ACCEN00_Bits.EN0 */


/** \brief Length for Ifx_SCU_ACCEN00_Bits.EN1 */


/** \brief Mask for Ifx_SCU_ACCEN00_Bits.EN1 */


/** \brief Offset for Ifx_SCU_ACCEN00_Bits.EN1 */


/** \brief Length for Ifx_SCU_ACCEN00_Bits.EN2 */


/** \brief Mask for Ifx_SCU_ACCEN00_Bits.EN2 */


/** \brief Offset for Ifx_SCU_ACCEN00_Bits.EN2 */


/** \brief Length for Ifx_SCU_ACCEN00_Bits.EN3 */


/** \brief Mask for Ifx_SCU_ACCEN00_Bits.EN3 */


/** \brief Offset for Ifx_SCU_ACCEN00_Bits.EN3 */


/** \brief Length for Ifx_SCU_ACCEN00_Bits.EN4 */


/** \brief Mask for Ifx_SCU_ACCEN00_Bits.EN4 */


/** \brief Offset for Ifx_SCU_ACCEN00_Bits.EN4 */


/** \brief Length for Ifx_SCU_ACCEN00_Bits.EN5 */


/** \brief Mask for Ifx_SCU_ACCEN00_Bits.EN5 */


/** \brief Offset for Ifx_SCU_ACCEN00_Bits.EN5 */


/** \brief Length for Ifx_SCU_ACCEN00_Bits.EN6 */


/** \brief Mask for Ifx_SCU_ACCEN00_Bits.EN6 */


/** \brief Offset for Ifx_SCU_ACCEN00_Bits.EN6 */


/** \brief Length for Ifx_SCU_ACCEN00_Bits.EN7 */


/** \brief Mask for Ifx_SCU_ACCEN00_Bits.EN7 */


/** \brief Offset for Ifx_SCU_ACCEN00_Bits.EN7 */


/** \brief Length for Ifx_SCU_ACCEN00_Bits.EN8 */


/** \brief Mask for Ifx_SCU_ACCEN00_Bits.EN8 */


/** \brief Offset for Ifx_SCU_ACCEN00_Bits.EN8 */


/** \brief Length for Ifx_SCU_ACCEN00_Bits.EN9 */


/** \brief Mask for Ifx_SCU_ACCEN00_Bits.EN9 */


/** \brief Offset for Ifx_SCU_ACCEN00_Bits.EN9 */


/** \brief Length for Ifx_SCU_ACCEN00_Bits.EN10 */


/** \brief Mask for Ifx_SCU_ACCEN00_Bits.EN10 */


/** \brief Offset for Ifx_SCU_ACCEN00_Bits.EN10 */


/** \brief Length for Ifx_SCU_ACCEN00_Bits.EN11 */


/** \brief Mask for Ifx_SCU_ACCEN00_Bits.EN11 */


/** \brief Offset for Ifx_SCU_ACCEN00_Bits.EN11 */


/** \brief Length for Ifx_SCU_ACCEN00_Bits.EN12 */


/** \brief Mask for Ifx_SCU_ACCEN00_Bits.EN12 */


/** \brief Offset for Ifx_SCU_ACCEN00_Bits.EN12 */


/** \brief Length for Ifx_SCU_ACCEN00_Bits.EN13 */


/** \brief Mask for Ifx_SCU_ACCEN00_Bits.EN13 */


/** \brief Offset for Ifx_SCU_ACCEN00_Bits.EN13 */


/** \brief Length for Ifx_SCU_ACCEN00_Bits.EN14 */


/** \brief Mask for Ifx_SCU_ACCEN00_Bits.EN14 */


/** \brief Offset for Ifx_SCU_ACCEN00_Bits.EN14 */


/** \brief Length for Ifx_SCU_ACCEN00_Bits.EN15 */


/** \brief Mask for Ifx_SCU_ACCEN00_Bits.EN15 */


/** \brief Offset for Ifx_SCU_ACCEN00_Bits.EN15 */


/** \brief Length for Ifx_SCU_ACCEN00_Bits.EN16 */


/** \brief Mask for Ifx_SCU_ACCEN00_Bits.EN16 */


/** \brief Offset for Ifx_SCU_ACCEN00_Bits.EN16 */


/** \brief Length for Ifx_SCU_ACCEN00_Bits.EN17 */


/** \brief Mask for Ifx_SCU_ACCEN00_Bits.EN17 */


/** \brief Offset for Ifx_SCU_ACCEN00_Bits.EN17 */


/** \brief Length for Ifx_SCU_ACCEN00_Bits.EN18 */


/** \brief Mask for Ifx_SCU_ACCEN00_Bits.EN18 */


/** \brief Offset for Ifx_SCU_ACCEN00_Bits.EN18 */


/** \brief Length for Ifx_SCU_ACCEN00_Bits.EN19 */


/** \brief Mask for Ifx_SCU_ACCEN00_Bits.EN19 */


/** \brief Offset for Ifx_SCU_ACCEN00_Bits.EN19 */


/** \brief Length for Ifx_SCU_ACCEN00_Bits.EN20 */


/** \brief Mask for Ifx_SCU_ACCEN00_Bits.EN20 */


/** \brief Offset for Ifx_SCU_ACCEN00_Bits.EN20 */


/** \brief Length for Ifx_SCU_ACCEN00_Bits.EN21 */


/** \brief Mask for Ifx_SCU_ACCEN00_Bits.EN21 */


/** \brief Offset for Ifx_SCU_ACCEN00_Bits.EN21 */


/** \brief Length for Ifx_SCU_ACCEN00_Bits.EN22 */


/** \brief Mask for Ifx_SCU_ACCEN00_Bits.EN22 */


/** \brief Offset for Ifx_SCU_ACCEN00_Bits.EN22 */


/** \brief Length for Ifx_SCU_ACCEN00_Bits.EN23 */


/** \brief Mask for Ifx_SCU_ACCEN00_Bits.EN23 */


/** \brief Offset for Ifx_SCU_ACCEN00_Bits.EN23 */


/** \brief Length for Ifx_SCU_ACCEN00_Bits.EN24 */


/** \brief Mask for Ifx_SCU_ACCEN00_Bits.EN24 */


/** \brief Offset for Ifx_SCU_ACCEN00_Bits.EN24 */


/** \brief Length for Ifx_SCU_ACCEN00_Bits.EN25 */


/** \brief Mask for Ifx_SCU_ACCEN00_Bits.EN25 */


/** \brief Offset for Ifx_SCU_ACCEN00_Bits.EN25 */


/** \brief Length for Ifx_SCU_ACCEN00_Bits.EN26 */


/** \brief Mask for Ifx_SCU_ACCEN00_Bits.EN26 */


/** \brief Offset for Ifx_SCU_ACCEN00_Bits.EN26 */


/** \brief Length for Ifx_SCU_ACCEN00_Bits.EN27 */


/** \brief Mask for Ifx_SCU_ACCEN00_Bits.EN27 */


/** \brief Offset for Ifx_SCU_ACCEN00_Bits.EN27 */


/** \brief Length for Ifx_SCU_ACCEN00_Bits.EN28 */


/** \brief Mask for Ifx_SCU_ACCEN00_Bits.EN28 */


/** \brief Offset for Ifx_SCU_ACCEN00_Bits.EN28 */


/** \brief Length for Ifx_SCU_ACCEN00_Bits.EN29 */


/** \brief Mask for Ifx_SCU_ACCEN00_Bits.EN29 */


/** \brief Offset for Ifx_SCU_ACCEN00_Bits.EN29 */


/** \brief Length for Ifx_SCU_ACCEN00_Bits.EN30 */


/** \brief Mask for Ifx_SCU_ACCEN00_Bits.EN30 */


/** \brief Offset for Ifx_SCU_ACCEN00_Bits.EN30 */


/** \brief Length for Ifx_SCU_ACCEN00_Bits.EN31 */


/** \brief Mask for Ifx_SCU_ACCEN00_Bits.EN31 */


/** \brief Offset for Ifx_SCU_ACCEN00_Bits.EN31 */


/** \}  */

/******************************************************************************/

/******************************************************************************/


#line 54 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\_Impl\\IfxScu_cfg.h"

/******************************************************************************/
/*                           Macro                                            */
/******************************************************************************/

























/*The following frequency is the PLL free running frequency */




/* By Default - external crystal is chosen as input */
/* This can be set to external clock input by user */





/* iLLD Configs from Master CFG file */
/*Utility macros for the configuration structure */





























/******************************************************************************/
/*                           Per PLL Config                                   */
/******************************************************************************/



















/***************************************************************************************************/
/*************************MACROS To Configure SYSPLL Steps******************************************/
/* These Macros are used to Configure different profiles of frequency jump from FOsc to Target Freq*/
/* This is Important for the current jump Control during Clock Throttling                          */
/***************************************************************************************************/



































































/***************************************************************************************************/
/*********************** SYSPLL CONFIGURATIONS *****************************************************/
/***************************************************************************************************/

/*******************************16MHz Oscillator Frequency******************************************/


/************** Target = 80MHz *****************/

 
/**** Macro for Initial Pll step, for profile with 16MHz Crystal and 80MHz target (fDCO= 640)*/










/**** Macro for Pll step for profile with 16MHz Crystal and 80MHz target (fDCO= 640MHz)*/



/************** Target = 133MHz *****************/

 
/**** Macro for Initial Pll step, for profile with 16MHz Crystal and 133MHz target (fDCO= 800)*/










/**** Macro for Pll step for profile with 16MHz Crystal and 133MHz target (fDCO= 800MHz)*/



/************** Target = 240MHz *****************/

 
/**** Macro for Initial Pll step, for profile with 16MHz Crystal and 240MHz target (fDCO= 720)*/










/**** Macro for Pll step for profile with 16MHz Crystal and 240MHz target (fDCO= 720MHz)*/



/************** Target = 300MHz *****************/

 
/**** Macro for Initial Pll step, for profile with 16MHz Crystal and 300MHz target (fDCO= 600)*/










/**** Macro for Pll step for profile with 16MHz Crystal and 300MHz target (fDCO= 600MHz)*/



/*******************************20MHz Oscillator Frequency******************************************/


/************** Target = 200MHz *****************/

 
/**** Macro for Initial Pll step, for profile with 20MHz Crystal and 200MHz target (fDCO= 600)*/










/**** Macro for Pll step for profile with 20MHz Crystal and 200MHz target (fDCO= 600MHz)*/



/************** Target = 240MHz *****************/

 
/**** Macro for Initial Pll step, for profile with 20MHz Crystal and 240MHz target (fDCO= 720)*/










/**** Macro for Pll step for profile with 20MHz Crystal and 240MHz target (fDCO= 720MHz)*/



/************** Target = 300MHz *****************/

 
/**** Macro for Initial Pll step, for profile with 20MHz Crystal and 300MHz target (fDCO= 600)*/










/**** Macro for Pll step for profile with 20MHz Crystal and 300MHz target (fDCO= 600MHz)*/



/*******************************25MHz Oscillator Frequency******************************************/


/************** Target = 200MHz *****************/

 
/**** Macro for Initial Pll step, for profile with 25MHz Crystal and 200MHz target (fDCO= 600)*/










/**** Macro for Pll step for profile with 25MHz Crystal and 200MHz target (fDCO= 600MHz)*/



/************** Target = 300MHz *****************/

 
/**** Macro for Initial Pll step, for profile with 25MHz Crystal and 300MHz target (fDCO= 600)*/










/**** Macro for Pll step for profile with 25MHz Crystal and 300MHz target (fDCO= 600MHz)*/



/*******************************40MHz Oscillator Frequency******************************************/


/************** Target = 200MHz *****************/

 
/**** Macro for Initial Pll step, for profile with 40MHz Crystal and 200MHz target (fDCO= 600)*/










/**** Macro for Pll step for profile with 40MHz Crystal and 200MHz target (fDCO= 600MHz)*/



/************** Target = 240MHz *****************/

 
/**** Macro for Initial Pll step, for profile with 40MHz Crystal and 240MHz target (fDCO= 720)*/










/**** Macro for Pll step for profile with 40MHz Crystal and 240MHz target (fDCO= 720MHz)*/



/************** Target = 300MHz *****************/

 
/**** Macro for Initial Pll step, for profile with 40MHz Crystal and 300MHz target (fDCO= 600)*/










/**** Macro for Pll step for profile with 40MHz Crystal and 300MHz target (fDCO= 600MHz)*/



/***************************************************************************************************/
/*********************** PERPLL CONFIGURATIONS *****************************************************/
/***************************************************************************************************/

/*******************************16MHz Oscillator Frequency******************************************/


/************** Fpll1 = 320MHz, Fpll2 = 200MHz *****************/


/** \brief Macro for Initial Pll step, for profile with 16MHz Crystal and 320/200MHz target (fDCO= 640)*/





/************** Fpll1 = 160MHz, Fpll2 = 200MHz *****************/


/** \brief Macro for Initial Pll step, for profile with 16MHz Crystal and 160/200MHz target (fDCO= 640)*/





/*******************************20MHz Oscillator Frequency******************************************/


/************** Fpll1 = 320MHz, Fpll2 = 200MHz *****************/


/** \brief Macro for Initial Pll step, for profile with 20MHz Crystal and 320/200MHz target (fDCO= 640)*/





/************** Fpll1 = 160MHz, Fpll2 = 200MHz *****************/


/** \brief Macro for Initial Pll step, for profile with 20MHz Crystal and 160/200MHz target (fDCO= 640)*/





/*******************************25MHz Oscillator Frequency******************************************/


/************** Fpll1 = 160MHz, Fpll2 = 200MHz *****************/


/** \brief Macro for Initial Pll step, for profile with 25MHz Crystal and 160/200MHz target (fDCO= 800)*/





/*******************************40MHz Oscillator Frequency******************************************/


/************** Fpll1 = 320MHz, Fpll2 = 200MHz *****************/


/** \brief Macro for Initial Pll step, for profile with 40MHz Crystal and 320/200MHz target (fDCO= 640)*/





/************** Fpll1 = 160MHz, Fpll2 = 200MHz *****************/


/** \brief Macro for Initial Pll step, for profile with 40MHz Crystal and 160/200MHz target (fDCO= 640)*/





/***************************** Final Macro Setting for PLL ****************************************/




/****************** initial step configuration definitions ******************************/
/*macro for sys pll initial step configuration */




/*macro for per pll initial step configuration */




/*macro for wait at initial step configuration */




/*macro for sys pll initial step configuration */











/***************************************************************************************************/
/*********************** DIVIDER CONFIGURATIONS ****************************************************/
/***************************************************************************************************/

/**************** DIVIDERS DEPENDING ON FSource0 (Fpll0) *******************************************/

/**************** Fsource = Fpll0 = 80MHz **********************************************************/

/************** CCUCON0 : STMDIV  (Output : fSTM)**************/
/* Target = 80 MHz AND Source = Fsource0 */




/************** CCUCON0 : GTMDIV  (Output : fGTM)**************/
/* Target = 80 MHz AND Source = Fsource0 */




/************** CCUCON0 : SRIDIV  (Output : fSRI)**************/
/* Target = 80 MHz AND Source = Fsource0 */




/************** CCUCON0 : SPBDIV  (Output : fSPB)**************/
/* Target = 40 MHz AND Source = Fsource0 */




/************** CCUCON0 : BBBDIV  (Output : fBBB)**************/
/* Target = 40 MHz AND Source = Fsource0 */




/************** CCUCON0 : FSIDIV  (Output : fFSI)**************/
/* Target = 80 MHz AND Source = Fsri */




/************** CCUCON0 : FSI2DIV  (Output : fFSI2)**************/
/* Target = 80 MHz AND Source = Fsri */




/************** CCUCON5 : GETHDIV  (Output : fGETH)**************/
/* Target = 80 MHz AND Source = Fsource0 */




/************** CCUCON5 : MCANHDIV  (Output : fMCANH)**************/
/* Target = 40 MHz AND Source = Fsource0 */




/************** CCUCON6 : CPU0DIV  (Output : fCPU0)**************/
/* Target = 80 MHz AND Source = Fsri */




/************** CCUCON7 : CPU1DIV  (Output : fCPU1)**************/
/* Target = 80 MHz AND Source = Fsri */




/************** CCUCON8 : CPU2DIV  (Output : fCPU2)**************/
/* Target = 80 MHz AND Source = Fsri */




/************** CCUCON9 : CPU3DIV  (Output : fCPU3)**************/
/* Target = 80 MHz AND Source = Fsri */




/**************** Fsource = Fpll0 = 133MHz **********************************************************/

/************** CCUCON0 : STMDIV  (Output : fSTM)**************/
/* Target = 66.5 MHz AND Source = Fsource0 */




/************** CCUCON0 : GTMDIV  (Output : fGTM)**************/
/* Target = 133 MHz AND Source = Fsource0 */




/************** CCUCON0 : SRIDIV  (Output : fSRI)**************/
/* Target = 133 MHz AND Source = Fsource0 */




/************** CCUCON0 : SPBDIV  (Output : fSPB)**************/
/* Target = 66.5 MHz AND Source = Fsource0 */




/************** CCUCON0 : BBBDIV  (Output : fBBB)**************/
/* Target = 66.5 MHz AND Source = Fsource0 */




/************** CCUCON0 : FSIDIV  (Output : fFSI)**************/
/* Target = 66.5 MHz AND Source = Fsri */




/************** CCUCON0 : FSI2DIV  (Output : fFSI2)**************/
/* Target = 133 MHz AND Source = Fsri */




/************** CCUCON5 : GETHDIV  (Output : fGETH)**************/
/* Target = 133 MHz AND Source = Fsource0 */




/************** CCUCON5 : MCANHDIV  (Output : fMCANH)**************/
/* Target = 66.5 MHz AND Source = Fsource0 */




/************** CCUCON6 : CPU0DIV  (Output : fCPU0)**************/
/* Target = 133 MHz AND Source = Fsri */




/************** CCUCON7 : CPU1DIV  (Output : fCPU1)**************/
/* Target = 133 MHz AND Source = Fsri */




/************** CCUCON8 : CPU2DIV  (Output : fCPU2)**************/
/* Target = 133 MHz AND Source = Fsri */




/************** CCUCON9 : CPU3DIV  (Output : fCPU3)**************/
/* Target = 133 MHz AND Source = Fsri */




/**************** Fsource = Fpll0 = 200MHz **********************************************************/

/************** CCUCON0 : STMDIV  (Output : fSTM)**************/
/* Target = 100 MHz AND Source = Fsource0 */




/************** CCUCON0 : GTMDIV  (Output : fGTM)**************/
/* Target = 200 MHz AND Source = Fsource0 */




/************** CCUCON0 : SRIDIV  (Output : fSRI)**************/
/* Target = 200 MHz AND Source = Fsource0 */




/************** CCUCON0 : SPBDIV  (Output : fSPB)**************/
/* Target = 100 MHz AND Source = Fsource0 */




/************** CCUCON0 : BBBDIV  (Output : fBBB)**************/
/* Target = 100 MHz AND Source = Fsource0 */




/************** CCUCON0 : FSIDIV  (Output : fFSI)**************/
/* Target = 100 MHz AND Source = Fsri */




/************** CCUCON0 : FSI2DIV  (Output : fFSI2)**************/
/* Target = 200 MHz AND Source = Fsri */




/************** CCUCON5 : GETHDIV  (Output : fGETH)**************/
/* Target = 200 MHz AND Source = Fsource0 */




/************** CCUCON5 : MCANHDIV  (Output : fMCANH)**************/
/* Target = 100 MHz AND Source = Fsource0 */




/************** CCUCON6 : CPU0DIV  (Output : fCPU0)**************/
/* Target = 200 MHz AND Source = Fsri */




/************** CCUCON7 : CPU1DIV  (Output : fCPU1)**************/
/* Target = 200 MHz AND Source = Fsri */




/************** CCUCON8 : CPU2DIV  (Output : fCPU2)**************/
/* Target = 200 MHz AND Source = Fsri */




/************** CCUCON9 : CPU3DIV  (Output : fCPU3)**************/
/* Target = 200 MHz AND Source = Fsri */




/**************** Fsource = Fpll0 = 240MHz **********************************************************/

/************** CCUCON0 : STMDIV  (Output : fSTM)**************/
/* Target = 80 MHz AND Source = Fsource0 */




/************** CCUCON0 : GTMDIV  (Output : fGTM)**************/
/* Target = 200 MHz AND Source = Fsource0 */




/************** CCUCON0 : SRIDIV  (Output : fSRI)**************/
/* Target = 240 MHz AND Source = Fsource0 */




/************** CCUCON0 : SPBDIV  (Output : fSPB)**************/
/* Target = 80 MHz AND Source = Fsource0 */




/************** CCUCON0 : BBBDIV  (Output : fBBB)**************/
/* Target = 120 MHz AND Source = Fsource0 */




/************** CCUCON0 : FSIDIV  (Output : fFSI)**************/
/* Target = 80 MHz AND Source = Fsri */




/************** CCUCON0 : FSI2DIV  (Output : fFSI2)**************/
/* Target = 240 MHz AND Source = Fsri */




/************** CCUCON5 : GETHDIV  (Output : fGETH)**************/
/* Target = 120 MHz AND Source = Fsource0 */




/************** CCUCON5 : MCANHDIV  (Output : fMCANH)**************/
/* Target = 80 MHz AND Source = Fsource0 */




/************** CCUCON6 : CPU0DIV  (Output : fCPU0)**************/
/* Target = 240 MHz AND Source = Fsri */




/************** CCUCON7 : CPU1DIV  (Output : fCPU1)**************/
/* Target = 240 MHz AND Source = Fsri */




/************** CCUCON8 : CPU2DIV  (Output : fCPU2)**************/
/* Target = 240 MHz AND Source = Fsri */




/************** CCUCON9 : CPU3DIV  (Output : fCPU3)**************/
/* Target = 240 MHz AND Source = Fsri */




/**************** Fsource = Fpll0 = 300MHz **********************************************************/

/************** CCUCON0 : STMDIV  (Output : fSTM)**************/
/* Target = 100 MHz AND Source = Fsource0 */




/************** CCUCON0 : GTMDIV  (Output : fGTM)**************/
/* Target = 200 MHz AND Source = Fsource0 */




/************** CCUCON0 : SRIDIV  (Output : fSRI)**************/
/* Target = 300 MHz AND Source = Fsource0 */




/************** CCUCON0 : SPBDIV  (Output : fSPB)**************/
/* Target = 100 MHz AND Source = Fsource0 */




/************** CCUCON0 : BBBDIV  (Output : fBBB)**************/
/* Target = 150 MHz AND Source = Fsource0 */




/************** CCUCON0 : FSIDIV  (Output : fFSI)**************/
/* Target = 100 MHz AND Source = Fsri */




/************** CCUCON0 : FSI2DIV  (Output : fFSI2)**************/
/* Target = 300 MHz AND Source = Fsri */




/************** CCUCON5 : GETHDIV  (Output : fGETH)**************/
/* Target = 150 MHz AND Source = Fsource0 */




/************** CCUCON5 : MCANHDIV  (Output : fMCANH)**************/
/* Target = 100 MHz AND Source = Fsource0 */




/************** CCUCON6 : CPU0DIV  (Output : fCPU0)**************/
/* Target = 300 MHz AND Source = Fsri */




/************** CCUCON7 : CPU1DIV  (Output : fCPU1)**************/
/* Target = 300 MHz AND Source = Fsri */




/************** CCUCON8 : CPU2DIV  (Output : fCPU2)**************/
/* Target = 300 MHz AND Source = Fsri */




/************** CCUCON9 : CPU3DIV  (Output : fCPU3)**************/
/* Target = 300 MHz AND Source = Fsri */




/**************** DIVIDERS DEPENDING ON FSource1,2 (Fpll1_Fpll2) ***********************************/

/**************** Fpll1 = 320MHz, Fpll2 = 200MHz ***************************************************/

/************** CCUCON1 : MCANDIV  (Output : fMCAN)**************/
/* Target = 80 MHz AND Source = Fsource1 */




/************** CCUCON1 : CLKSELMCAN  (Output : fMCANI)**************/
/* Target = Fmcani MHz AND Source = Fmcani/Fosc0 */




/************** CCUCON1 : PLL1DIVDIS  (Output : fsource1)**************/
/* Target = Fpll1by2 MHz AND Source = Fpll1 */




/************** CCUCON1 : I2CDIV  (Output : fI2C)**************/
/* Target = 100 MHz AND Source = Fsource2 */




/************** CCUCON1 : MSCDIV  (Output : fMSC)**************/
/* Target = 160 MHz AND Source = Fsource2 */




/************** CCUCON1 : CLKSELMSC  (Output : fSOURCEMSC)**************/
/* Target = Fsource1 MHz AND Source = Fsource1/Fsource2 */




/************** CCUCON1 : QSPIDIV  (Output : fQSPI)**************/
/* Target = 200 MHz AND Source = Fsource2 */




/************** CCUCON1 : CLKSELQSPI  (Output : fSOURCESPI)**************/
/* Target = Fsource2 MHz AND Source = Fsource1/Fsource2 */




/************** CCUCON2 : ASCLINFDIV  (Output : fASCLINF)**************/
/* Target = 200 MHz AND Source = Fsource2 */




/************** CCUCON2 : ASCLINSDIV  (Output : fASCLINSI)**************/
/* Target = 80 MHz AND Source = Fsource1 */




/************** CCUCON2 : CLKSELASCLINS  (Output : fASCLINS)**************/
/* Target = Fasclinsi MHz AND Source = Fasclinsi/Fosc0 */




/**************** Fpll1 = 160MHz, Fpll2 = 200MHz ***************************************************/

/************** CCUCON1 : MCANDIV  (Output : fMCAN)**************/
/* Target = 80 MHz AND Source = Fsource1 */




/************** CCUCON1 : CLKSELMCAN  (Output : fMCANI)**************/
/* Target = Fmcani MHz AND Source = Fmcani/Fosc0 */




/************** CCUCON1 : PLL1DIVDIS  (Output : fsource1)**************/
/* Target = Fpll1by2 MHz AND Source = Fpll1 */




/************** CCUCON1 : I2CDIV  (Output : fI2C)**************/
/* Target = 100 MHz AND Source = Fsource2 */




/************** CCUCON1 : MSCDIV  (Output : fMSC)**************/
/* Target = 80 MHz AND Source = Fsource2 */




/************** CCUCON1 : CLKSELMSC  (Output : fSOURCEMSC)**************/
/* Target = Fsource1 MHz AND Source = Fsource1/Fsource2 */




/************** CCUCON1 : QSPIDIV  (Output : fQSPI)**************/
/* Target = 200 MHz AND Source = Fsource2 */




/************** CCUCON1 : CLKSELQSPI  (Output : fSOURCESPI)**************/
/* Target = Fsource2 MHz AND Source = Fsource1/Fsource2 */




/************** CCUCON2 : ASCLINFDIV  (Output : fASCLINF)**************/
/* Target = 200 MHz AND Source = Fsource2 */




/************** CCUCON2 : ASCLINSDIV  (Output : fASCLINSI)**************/
/* Target = 80 MHz AND Source = Fsource1 */




/************** CCUCON2 : CLKSELASCLINS  (Output : fASCLINS)**************/
/* Target = Fasclinsi MHz AND Source = Fasclinsi/Fosc0 */




/***************************************************************************************************/
/*********************** REGISTER DEFAULT VALUES ***************************************************/
/***************************************************************************************************/

/************************** CCUCON0 **************************/
























/************************** CCUCON1 **************************/


























/************************** CCUCON2 **************************/
















/************************** CCUCON5 **************************/














/************************** CCUCON6 **************************/












/************************** CCUCON7 **************************/












/************************** CCUCON8 **************************/












/************************** CCUCON9 **************************/












/**************** Final Clock Distribution ******************/














/** \brief Macros to configure FLASH.FCON registers */












/******************************************************************************/
/*---------------------------LBIST Config Macros------------------------------*/
/******************************************************************************/
































/******************************************************************************/
/*                           Enum                                             */
/******************************************************************************/
/** Clock selection  */
typedef enum
{
    IfxScu_CCUCON0_CLKSEL_fBack = 0,
    IfxScu_CCUCON0_CLKSEL_fPll  = 1
} IfxScu_CCUCON0_CLKSEL;

/** Input frequency request control */
typedef enum
{
    IfxScu_WDTCON1_IR_divBy16384 = 0,
    IfxScu_WDTCON1_IR_divBy256   = 1,
    IfxScu_WDTCON1_IR_divBy64    = 2
} IfxScu_WDTCON1_IR;

typedef enum
{
    IfxScu_PMCSR_REQSLP_Run   = 0U, /* 00 Request CPU Run Mode */
    IfxScu_PMCSR_REQSLP_Idle  = 1U, /* 01 Request CPU Idle Mode */
    IfxScu_PMCSR_REQSLP_Sleep = 2U, /* 10 Request CPU System Sleep Mode */
    IfxScu_PMCSR_REQSLP_Stby  = 3U  /* 11 Request System Standby Mode */
} IfxScu_PMCSR_REQSLP;

/******************************************************************************/


#line 74 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\ee\\..\\Libraries\\iLLD\\TC38A\\Tricore\\Cpu\\Std\\IfxCpu.h"

#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\Service\\CpuGeneric\\_Utilities\\Ifx_Assert.h"
/**
 * \file Ifx_Assert.h
 * \brief Assert functions.
 * \ingroup library_srvsw_utilities_assert
 *
 * \copyright Copyright (c) 2013 Infineon Technologies AG. All rights reserved.
 *
 * $Date: 2014-02-28 14:15:42 GMT$
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * \defgroup library_srvsw_utilities_assert Assertion
 * This module implements assertion functions.
 * \ingroup library_srvsw_utilities
 *
 */






#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Cpu\\Std\\Ifx_Types.h"
/**
 * \file Ifx_Types.h
 * \brief This files defines all types used by the IFX HAL and libraries
 *
 * \version iLLD_1_0_1_15_0_1
 * \copyright Copyright (c) 2018 Infineon Technologies AG. All rights reserved.
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */
























































































































































































#line 52 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\Service\\CpuGeneric\\_Utilities\\Ifx_Assert.h"

/** \addtogroup library_srvsw_utilities_assert
 * \{ */








/** \brief Constant to be used to indicate  not implemented feature */

/** \brief Feature is not available on the selected hardware */






















/** \} */


#line 75 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\ee\\..\\Libraries\\iLLD\\TC38A\\Tricore\\Cpu\\Std\\IfxCpu.h"

#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Scu\\Std\\IfxScuWdt.h"
/**
 * \file IfxScuWdt.h
 * \brief SCU  basic functionality
 * \ingroup IfxLld_Scu
 *
 * \version iLLD_1_0_1_15_0_1
 * \copyright Copyright (c) 2019 Infineon Technologies AG. All rights reserved.
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 * This file contains the APIs for SCU Watchdog and Endinit related functions.
 *
 * \defgroup IfxLld_Scu_Std_Wdt Wdt Basic Functionality
 * \ingroup IfxLld_Scu_Std
 * \defgroup IfxLld_Scu_Std_Wdt_Wdt_Configuration Watchdog Configuration functions
 * \ingroup IfxLld_Scu_Std_Wdt
 * \defgroup IfxLld_Scu_Std_Wdt_Wdt_Endinit Watchdog Endinit functions
 * \ingroup IfxLld_Scu_Std_Wdt
 * \defgroup IfxLld_Scu_Std_Wdt_Wdt_Operative Watchdog Operative functions
 * \ingroup IfxLld_Scu_Std_Wdt
 * \defgroup IfxLld_Scu_Std_Wdt_Wdt_Endinit_Usage How to use Endinit APIs?
 * \ingroup IfxLld_Scu_Std_Wdt
 */




/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/



#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Cpu\\Std\\Ifx_Types.h"
/**
 * \file Ifx_Types.h
 * \brief This files defines all types used by the IFX HAL and libraries
 *
 * \version iLLD_1_0_1_15_0_1
 * \copyright Copyright (c) 2018 Infineon Technologies AG. All rights reserved.
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */
























































































































































































#line 65 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Scu\\Std\\IfxScuWdt.h"



#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Scu\\Std\\IfxScuWdt.asm.h"
/**
 * \file IfxScuWdt.asm.h
 * \brief SCU  basic functionality
 * \ingroup IfxLld_Scu
 *
 * \version iLLD_1_0_1_15_0_1
 * \copyright Copyright (c) 2019 Infineon Technologies AG. All rights reserved.
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * \defgroup IfxLld_Scu_Std_Wdt_Operative Wdt Operative Functionality
 * \ingroup IfxLld_Scu_Std_Wdt
 */




#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Cpu\\Std\\Ifx_Types.h"
/**
 * \file Ifx_Types.h
 * \brief This files defines all types used by the IFX HAL and libraries
 *
 * \version iLLD_1_0_1_15_0_1
 * \copyright Copyright (c) 2018 Infineon Technologies AG. All rights reserved.
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */
























































































































































































#line 48 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Scu\\Std\\IfxScuWdt.asm.h"


/** \addtogroup IfxLld_Scu_Std_Wdt_Operative
 * \{ */

/**
 * \brief SCUWDT Inline API utility to Calculte new 14-bit LFSR.
 *
 * This API will Calculte new 14-bit LFSR (Linear Feedback Shift Register) with characteristic polynomial
 * x14+x13+x12+x2+1.
 *
 * \param password Password for which LFSR value to be calculated.
 * \return New LFSR.
 */
static inline uint16 IfxScuWdt_calculateLfsr(uint16 password);
/** \}  */

/**
 * \brief SCUWDT Inline API utility to Calculte new 14-bit LFSR.
 */
















static inline uint16 IfxScuWdt_calculateLfsr(uint16 pwd)
{
    /* *INDENT-OFF* */
    uint32 temp = pwd;
    uint16 res;

    __asm("xor.t  %0,%1,13,%1,12 \n           xor.t  %0,%0,0,%1,11  \n           sh.xor.t %1,%0,0,%1,1  \n           mov d4,#0 \n           mov d5,#14 \n           extr.u %0,%1,e4     \n" : "=&d" (res) : "d" (temp));





    return res;
    /* *INDENT-ON* */
}


































#line 68 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Scu\\Std\\IfxScuWdt.h"


/******************************************************************************/
/*-----------------------------------Macros-----------------------------------*/
/******************************************************************************/

/** \brief Endinit operation Timeout counter
 */


/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/

/** \brief Configuration structure for Scu Watchdog.
 * IfxScuWdt_Config is a type describing configuration structure of CPU and
 * Safety WDT registers defined in IfxScuWdt.h file.
 */
typedef struct
{
    uint16            password;                            /**< \brief password for access to WDTxCON0 reg */
    uint16            reload;                              /**< \brief WDT reload value */
    IfxScu_WDTCON1_IR inputFrequency;                      /**< \brief input frequency of the WDT */
    boolean           disableWatchdog;                     /**< \brief Disable Request Control Bit */
    boolean           enableSmuRestriction;                /**< \brief Unlock Restriction Request Control Bit */
    boolean           enableAutomaticPasswordChange;       /**< \brief Password Auto-sequence Request Bit */
    boolean           enableTimerCheck;                    /**< \brief Counter Check Request Bit */
    boolean           enableTimerCheckTolerance;           /**< \brief Timer Check Tolerance Request */
    boolean           clrInternalResetFlag;                /**< \brief Clear Internal Reset Flag */
    IfxScu_WDTCON1_IR globalEndInitInputFrequency;         /**< \brief input frequency of the global End init WDT */
} IfxScuWdt_Config;

/** \addtogroup IfxLld_Scu_Std_Wdt_Wdt_Configuration
 * \{ */

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief SCUWDT API to initialize WDT configuration structure - Constructor
 *   This API initialize the ScuWdt configuration structure to default values, these default
 *   values are for software specific, not necessarily hardware reset values.
 *   User must use this API call before IfxScuWdt_Init API call
 * \param config ScuWdt configuration structure to be initialized
 * \return None
 */
extern void IfxScuWdt_initConfig(IfxScuWdt_Config *config);

/** \brief SCUWDT API to initialize an instance of WDT Driver which corresponds to CPU WDT Hardware module.
 *
 *   This API initialize the ScuWdt software driver and corresponding CPU WDT hardware module.
 *   User can configure project specific Watchdog password, Watchdog timer period and other settings
 *   with this interface.
 *   API corresponds to one instance of the hardware module.
 *   User must use this API call for each instance of the WDT hardware module used.
 * \param wdt reference to register map of CPU WDT hardware instance
 * \param config ScuWdt configuration structure
 * \return None
 */
extern void IfxScuWdt_initCpuWatchdog(Ifx_SCU_WDTCPU *wdt, const IfxScuWdt_Config *config);

/** \brief SCUWDT API to initialize an instance of WDT Driver which corresponds to Safety WDT Hardware module.
 *
 *   This API initialize the ScuWdt software driver and corresponding safety WDT hardware module.
 *   User can configure project specific Watchdog password, Watchdog timer period and other settings
 *   with this interface.
 *   API corresponds to one instance of the hardware module.
 *   User must use this API call for each instance of the WDT hardware module used.
 * \param wdt reference to register map of Safety WDT hardware instance
 * \param config ScuWdt configuration structure
 * \return None
 */
extern void IfxScuWdt_initSafetyWatchdog(Ifx_SCU_WDTS *wdt, const IfxScuWdt_Config *config);

/** \} */

/** \addtogroup IfxLld_Scu_Std_Wdt_Wdt_Endinit
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief SCUWDT Inline API to Clear ENDINIT bit provided by CPU WDT Hardware module.
 *
 * This Inline API will disable ENDINIT functionality provided by CPU WDT Hardware module.
 * This API is only meant to be used with startup routines where function call is not possible.
 * User need to use this API call before modifying any ENDINIT protected register. User must
 * always set the ENDINIT bit using other API IfxScuWdt_setCpuEndinit. The sequence clear and set
 * ENDINIT shall not be interrupted by another interrupt/call.
 * User need to have the password stored locally in the caller function, (use IfxScuWdt_getCpuWatchdogPassword).
 * \param watchdog pointer to the watchdog register map of CPU WDT hardware instance
 * \param password Existing (Application specific) password for the Watchdog module.
 * \return None
 */
static inline void IfxScuWdt_clearCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password);

/** \brief Clear the Global safety Endinit password (Inline)
 * \param password Existing (Application specific) password for the Watchdog module.
 * \return None
 */
static inline void IfxScuWdt_clearGlobalSafetyEndinitInline(uint16 password);

/** \brief SCUWDT Inline API to Clear ENDINIT bit provided by Safety WDT Hardware module.
 *
 * This API will disable ENDINIT functionality provided by Safety WDT Hardware module.
 * This API is only meant to be used with startup routines where function call is not possible.
 * User need to use this API call before modifying any ENDINIT protected register. User must
 * always set the ENDINIT bit using other API IfxScuWdt_setCpuEndinit. The sequence clear and set
 * ENDINIT shall not be interrupted by another interrupt/call.
 * User need to have the password stored locally in the caller function, (use IfxScuWdt_getSafetyWatchdogPassword).
 * \param password Existing (Application specific) password for the Watchdog module.
 * \return None
 */
static inline void IfxScuWdt_clearSafetyEndinitInline(uint16 password);

/** \brief API to fetch current password of global safety endinit Watchdog module.
 *
 * This API will fetch current global endinit password for Safety WDT Hardware module. password is needed to be passed
 * with most of the WDT APIs. Normally this API can be used to store the password locally in the caller function
 * or store the password globally in a global variable at the application memory.
 * This API is only meant to be used with startup routines where function call is not possible.
 * \return password Existing (Application specific) password for the Watchdog module.
 */
static inline uint16 IfxScuWdt_getGlobalSafetyEndinitPasswordInline(void);

/** \brief SCUWDT Inline API to Set ENDINIT bit provided by CPU WDT Hardware module.
 *
 * This API will enable ENDINIT functionality provided by CPU WDT Hardware module.
 * This API is only meant to be used with startup routines where function call is not possible.
 * User need to use this API call after modifying any ENDINIT protected register.
 * User need to have the password stored locally in the caller function, (use IfxScuWdt_getCpuWatchdogPassword).
 * \param watchdog pointer to the watchdog register map of CPU WDT hardware instance
 * \param password Existing (Application specific) password for the Watchdog module.
 * \return None
 */
static inline void IfxScuWdt_setCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password);

/** \brief Set the Global safety Endinit password (Inline)
 * \param password Existing (Application specific) password for the Watchdog module.
 * \return None
 */
static inline void IfxScuWdt_setGlobalSafetyEndinitInline(uint16 password);

/** \brief SCUWDT Inline API to Set ENDINIT bit provided by Safety WDT Hardware module.
 *
 * This API will enable ENDINIT functionality provided by Safety WDT Hardware module.
 * This API is only meant to be used with startup routines where function call is not possible.
 * User need to use this API call after modifying any ENDINIT protected register.
 * User need to have the password stored locally in the caller function, (use IfxScuWdt_getSafetyWatchdogPassword).
 * \param password Existing (Application specific) password for the Watchdog module.
 * \return None
 */
static inline void IfxScuWdt_setSafetyEndinitInline(uint16 password);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief SCUWDT API to Clear ENDINIT bit provided by CPU WDT Hardware module.
 *
 *   This API will disable ENDINIT functionality provided by CPU WDT Hardware module.
 *   User need to use this API call before modifying any ENDINIT protected register. User must
 *   always set the ENDINIT bit using other API IfxScuWdt_setCpuEndinit. The sequence clear and set
 *   ENDINIT shall not be interrupted by another interrupt/call.
 *   User need to have the password stored locally in the caller function, (use IfxScuWdt_getCpuWatchdogPassword)
 * \param password Existing (Application specific) password for the Watchdog module.
 * \return None
 */
extern void IfxScuWdt_clearCpuEndinit(uint16 password);

/** \brief API to Clear global ENDINIT bit provided by CPU WDT Hardware module.
 *
 * This API will disable ENDINIT functionality provided by CPU WDT Hardware module.
 * This API is only meant to be used with startup routines where function call is not possible.
 * User need to use this API call before modifying any ENDINIT protected register. User must
 * always set the ENDINIT bit using other API IfxScuWdt_setGlobalEndinit. The sequence clear and set
 * ENDINIT shall not be interrupted by another interrupt/call.
 * User need to have the password stored locally in the caller function, (use IfxScuWdt_getGlobalEndinitPassword).
 * \param password Existing (Application specific) password for the Watchdog module.
 * \return None
 */
extern void IfxScuWdt_clearGlobalEndinit(uint16 password);

/** \brief API to Clear global safety ENDINIT bit provided by safety WDT Hardware module.
 *
 * This API will disable ENDINIT functionality provided by Safety WDT Hardware module.
 * This API is only meant to be used with startup routines where function call is not possible.
 * User need to use this API call before modifying any ENDINIT protected register. User must
 * always set the ENDINIT bit using other API IfxScuWdt_setGlobalSafetyEndinit. The sequence clear and set
 * ENDINIT shall not be interrupted by another interrupt/call.
 * User need to have the password stored locally in the caller function, (use IfxScuWdt_getGlobalSafetyEndinitPassword).
 * \param password Existing (Application specific) password for the Watchdog module.
 * \return None
 */
extern void IfxScuWdt_clearGlobalSafetyEndinit(uint16 password);

/** \brief SCUWDT API to Clear ENDINIT bit provided by Safety WDT Hardware module.
 *
 * This API will disable ENDINIT functionality provided by Safety WDT Hardware module.
 * User need to use this API call before modifying any ENDINIT protected register. User must
 * always set the ENDINIT bit using other API IfxScuWdt_setCpuEndinit. The sequence clear and set
 * ENDINIT shall not be interrupted by another interrupt/call.
 * User need to have the password stored locally in the caller function, (use IfxScuWdt_getSafetyWatchdogPassword).
 * \param password Existing (Application specific) password for the Watchdog module.
 * \return None
 */
extern void IfxScuWdt_clearSafetyEndinit(uint16 password);

/** \brief SCUWDT API to set ENDINIT bit provided by CPU WDT Hardware module.
 *
 *   This API will enable ENDINIT functionality provided by CPU WDT Hardware module.
 *   User need to use this API call after modifying any ENDINIT protected register.
 *   User need to have the password stored locally in the caller function, (use IfxScuWdt_getCpuWatchdogPassword)
 * \param password Existing (Application specific) password for the Watchdog module.
 * \return None
 */
extern void IfxScuWdt_setCpuEndinit(uint16 password);

/** \brief API to set global ENDINIT bit provided by CPU WDT Hardware module.
 *
 *   This API will enable ENDINIT functionality provided by CPU WDT Hardware module.
 *   User need to use this API call after modifying any ENDINIT protected register.
 *   User need to have the password stored locally in the caller function, (use IfxScuWdt_getGlobalEndinitPassword)
 * \param password Existing (Application specific) password for the Watchdog module.
 * \return None
 */
extern void IfxScuWdt_setGlobalEndinit(uint16 password);

/** \brief API to set global safety ENDINIT bit provided by safety WDT Hardware module.
 *
 *   This API will enable ENDINIT functionality provided by Safety WDT Hardware module.
 *   User need to use this API call after modifying any ENDINIT protected register.
 *   User need to have the password stored locally in the caller function, (use IfxScuWdt_getGlobalSafetyEndinitPassword)
 * \param password Existing (Application specific) password for the Watchdog module.
 * \return None
 */
extern void IfxScuWdt_setGlobalSafetyEndinit(uint16 password);

/** \brief SCUWDT API to Set ENDINIT bit provided by Safety WDT Hardware module.
 *
 * This API will enable ENDINIT functionality provided by Safety WDT Hardware module.
 * User need to use this API call after modifying any ENDINIT protected register.
 * User need to have the password stored locally in the caller function, (use IfxScuWdt_getSafetyWatchdogPassword).
 * \param password Existing (Application specific) password for the Watchdog module.
 * \return None
 */
extern void IfxScuWdt_setSafetyEndinit(uint16 password);

/** \} */

/** \addtogroup IfxLld_Scu_Std_Wdt_Wdt_Operative
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief SCUWDT Inline API to fetch current password of CPU Watchdog module.
 *
 * This API will fetch current Watchdog password for CPU WDT Hardware module. password is needed to be passed
 * with most of the WDT APIs. Normally this API can be used to store the password locally in the caller function
 * or store the password globally in a global variable at the application memory.
 * This API is only meant to be used with startup routines where function call is not possible.
 * \param watchdog pointer to the watchdog register map of CPU WDT hardware instance
 * \return password Existing (Application specific) password for the Watchdog module.
 */
static inline uint16 IfxScuWdt_getCpuWatchdogPasswordInline(Ifx_SCU_WDTCPU *watchdog);

/** \brief SCUWDT API to fetch current endinit of CPU Watchdog module.
 * \param watchdog pointer to the watchdog register map of CPU WDT hardware instance
 * \return Endinit status for the CPU Watchdog module.
 */
static inline boolean IfxScuWdt_getCpuWatchdogEndInitInline(Ifx_SCU_WDTCPU *watchdog);

/** \brief SCUWDT API to fetch current endinit of Safety/System Watchdog module.
 * \return Endinit status for the Safety Watchdog module.
 */
static inline boolean IfxScuWdt_getSafetyWatchdogEndInit(void);

/** \brief SCUWDT Inline API to fetch current password of Safety Watchdog module.
 *
 * This API will fetch current Watchdog password for Safety WDT Hardware module. password is needed to be passed
 * with most of the WDT APIs. Normally this API can be used to store the password locally in the caller function
 * or store the password globally in a global variable at the application memory.
 * This API is only meant to be used with startup routines where function call is not possible.
 * \return password Existing (Application specific) password for the Watchdog module.
 */
static inline uint16 IfxScuWdt_getSafetyWatchdogPasswordInline(void);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief SCUWDT API to change CPU Watchdog password.
 *
 *   This API will change password to new one for the corresponding to CPU WDT Hardware module.
 *   User need to have the old password stored locally in the caller function, (use IfxScuWdt_getCpuWatchdogPassword).
 * \param password Existing (Application specific) password for the Watchdog module.
 * \param newPassword Application specific new password to be changed for the Watchdog module.
 * \return None
 */
extern void IfxScuWdt_changeCpuWatchdogPassword(uint16 password, uint16 newPassword);

/** \brief SCUWDT API to change CPU Watchdog timer reload value.
 *
 * This API will change Watchdog timer reload value to new one for CPU WDT Hardware module.
 * The Watchdog timers will be reloaded with this value after every serice of Watchdog.
 * User need to have the password stored locally in the caller function, (use IfxScuWdt_getCpuWatchdogPassword).
 * \param password Existing (Application specific) password for the Watchdog module.
 * \param reload Reload value for the timer.
 * \return None
 */
extern void IfxScuWdt_changeCpuWatchdogReload(uint16 password, uint16 reload);

/** \brief API to change global endinit password.
 *
 *   This API will change password to new one for the corresponding to CPU WDT Hardware module.
 *   User need to have the old password stored locally in the caller function, (use IfxScuWdt_getGlobalEndinitPassword).
 * \param password Existing (Application specific) password for the Watchdog module.
 * \param newPassword Application specific new password to be changed for the Watchdog module.
 * \return None
 */
extern void IfxScuWdt_changeGlobalEndinitPassword(uint16 password, uint16 newPassword);

/** \brief API to change global safety endinit password.
 *
 *   This API will change password to new one for the corresponding to Safety WDT Hardware module.
 *   User need to have the old password stored locally in the caller function, (use IfxScuWdt_getGlobalSafetyEndinitPassword).
 * \param password Existing (Application specific) password for the Watchdog module.
 * \param newPassword Application specific new password to be changed for the Watchdog module.
 * \return None
 */
extern void IfxScuWdt_changeGlobalSafetyEndinitPassword(uint16 password, uint16 newPassword);

/** \brief SCUWDT API to change Safety Watchdog password.
 *
 * This API will change password to new one for the corresponding to Safety WDT Hardware module.
 * User need to have the old password stored locally in the caller function, (use IfxScuWdt_getSafetyWatchdogPassword).
 * \param password Existing (Application specific) password for the Watchdog module.
 * \param newPassword Application specific new password to be changed for the Watchdog module.
 * \return None
 */
extern void IfxScuWdt_changeSafetyWatchdogPassword(uint16 password, uint16 newPassword);

/** \brief SCUWDT API to change Safety Watchdog timer reload value.
 *
 * This API will change Watchdog timer reload value to new one for Safety WDT Hardware module.
 * The Watchdog timers will be reloaded with this value after every serice of Watchdog.
 * User need to have the password stored locally in the caller function, (use IfxScuWdt_getSafetyWatchdogPassword).
 * \param password Existing (Application specific) password for the Watchdog module.
 * \param reload Reload value for the timer.
 * \return None
 */
extern void IfxScuWdt_changeSafetyWatchdogReload(uint16 password, uint16 reload);

/** \brief SCUWDT API to disable CPU Watchdog functionality.
 *
 * This API will disable Watchdog functionality of CPU WDT Hardware module. The Watchdog timers will stop counting
 * after this API call.
 * User need to have the password stored locally in the caller function, (use IfxScuWdt_getCpuWatchdogPassword).
 * \param password Existing (Application specific) password for the Watchdog module.
 * \return None
 */
extern void IfxScuWdt_disableCpuWatchdog(uint16 password);

/** \brief SCUWDT API to disable Safety Watchdog functionality.
 *
 * This API will disable Watchdog functionality of Safety WDT Hardware module. The Watchdog timers will stop counting
 * after this API call.
 * User need to have the password stored locally in the caller function, (use IfxScuWdt_getSafetyWatchdogPassword).
 * \param password Existing (Application specific) password for the Watchdog module.
 * \return None
 */
extern void IfxScuWdt_disableSafetyWatchdog(uint16 password);

/** \brief SCUWDT API to enable CPU Watchdog functionality.
 *
 *   This API will enable Watchdog functionality of CPU WDT Hardware module. The Watchdog timers need to be serviced
 *   periodically after this API call.
 *   User need to have the password stored locally in the caller function, (use IfxScuWdt_getCpuWatchdogPassword).
 * \param password Existing (Application specific) password for the Watchdog module.
 * \return None
 */
extern void IfxScuWdt_enableCpuWatchdog(uint16 password);

/** \brief SCUWDT API to enable Safety Watchdog functionality.
 *
 * This API will enable Watchdog functionality of Safety WDT Hardware module. The Watchdog timers need to be serviced
 * periodically after this API call.
 * User need to have the password stored locally in the caller function, (use IfxScuWdt_getSafetyWatchdogPassword).
 * \param password Existing (Application specific) password for the Watchdog module.
 * \return None
 */
extern void IfxScuWdt_enableSafetyWatchdog(uint16 password);

/** \brief SCUWDT API to fetch current password of CPU Watchdog module.
 *
 * This API will fetch current Watchdog password for CPU WDT Hardware module. password is needed to be passed
 * with most of the WDT APIs. Normally this API can be used to store the password locally in the caller function
 * or store the password globally in a global variable at the application memory.
 * \return password Existing (Application specific) password for the Watchdog module.
 */
extern uint16 IfxScuWdt_getCpuWatchdogPassword(void);

/** \brief SCUWDT API to fetch current endinit of CPU Watchdog module.
 * \return Endinit status for the CPU Watchdog module.
 */
extern boolean IfxScuWdt_getCpuWatchdogEndInit(void);

/** \brief API to fetch current password of global endinit Watchdog module.
 *
 * This API will fetch current global endinit password for CPU WDT Hardware module. password is needed to be passed
 * with most of the WDT APIs. Normally this API can be used to store the password locally in the caller function
 * or store the password globally in a global variable at the application memory.
 * This API is only meant to be used with startup routines where function call is not possible.
 * \return password Existing (Application specific) password for the Watchdog module.
 */
extern uint16 IfxScuWdt_getGlobalEndinitPassword(void);

/** \brief API to fetch current password of global safety endinit Watchdog module.
 *
 * This API will fetch current global endinit password for Safety WDT Hardware module. password is needed to be passed
 * with most of the WDT APIs. Normally this API can be used to store the password locally in the caller function
 * or store the password globally in a global variable at the application memory.
 * This API is only meant to be used with startup routines where function call is not possible.
 * \return password Existing (Application specific) password for the Watchdog module.
 */
extern uint16 IfxScuWdt_getGlobalSafetyEndinitPassword(void);

/** \brief SCUWDT API to fetch current password of Safety Watchdog module.
 *
 * This API will fetch current Watchdog password for Safety WDT Hardware module. password is needed to be passed
 * with most of the WDT APIs. Normally this API can be used to store the password locally in the caller function
 * or store the password globally in a global variable at the application memory.
 * \return password Existing (Application specific) password for the Watchdog module.
 */
extern uint16 IfxScuWdt_getSafetyWatchdogPassword(void);

/** \brief SCUWDT API to service CPU Watchdog functionality.
 *
 *   This API will service Watchdog functionality corresponding to CPU WDT Hardware module.
 *   User need to use this API call periodically. This API results in reloading of the Watchdog Timer.
 *   User need to have the password stored locally in the caller function, (use IfxScuWdt_getCpuWatchdogPassword).
 * \param password Existing (Application specific) password for the Watchdog module.
 * \return None
 */
extern void IfxScuWdt_serviceCpuWatchdog(uint16 password);

/** \brief SCUWDT API to service Safety Watchdog functionality.
 *
 * This API will service Watchdog functionality corresponding to Safety WDT Hardware module.
 * User need to use this API call periodically. This API results in reloading of the Watchdog Timer.
 * User need to have the password stored locally in the caller function, (use IfxScuWdt_getSafetyWatchdogPassword).
 * \param password Existing (Application specific) password for the Watchdog module.
 * \return None
 */
extern void IfxScuWdt_serviceSafetyWatchdog(uint16 password);

/** \brief SCUWDT API to fetch current status of CPU Watchdog module.
 * \return status
 */
extern uint8 IfxScuWdt_getCpuWatchdogStatus(void);

/** \} */

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Enables the watchdog functionality with debugger connected,\n
 * debug interface will also be enabled, if not enabled already.
 * \return Status, Success = 0, Failure = 1.
 */
extern boolean IfxScuWdt_enableWatchdogWithDebugger(void);

/******************************************************************************/
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

static inline void IfxScuWdt_clearCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << (0u)) |
                           (0 << (1u)) |
                           (password << (2u)) |
                           (watchdog->CON0.B.REL << (16u));
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (0 << (0u)) |
                       (1 << (1u)) |
                       (password << (2u)) |
                       (watchdog->CON0.B.REL << (16u));

    /* read back ENDINIT and wait until it has been cleared */
    while (watchdog->CON0.B.ENDINIT == 1)
    {}
}


static inline void IfxScuWdt_clearGlobalSafetyEndinitInline(uint16 password)
{
    /* Clear EndInit Watch-dog*/
    ((*(Ifx_SCU*)0xF0036000u)).SEICON0.U = (0xFFFCU << 16U) | (password << (2u));

    while (((*(Ifx_SCU*)0xF0036000u)).SEICON0.B.ENDINIT == 1)
    {}
}


static inline void IfxScuWdt_clearSafetyEndinitInline(uint16 password)
{
    if ((*(volatile Ifx_SCU_WDTS_CON0*)0xF00362A8u).B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        (*(volatile Ifx_SCU_WDTS_CON0*)0xF00362A8u).U = (1 << (0u)) |
                          (0 << (1u)) |
                          (password << (2u)) |
                          ((*(volatile Ifx_SCU_WDTS_CON0*)0xF00362A8u).B.REL << (16u));
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    (*(volatile Ifx_SCU_WDTS_CON0*)0xF00362A8u).U = (0 << (0u)) |
                      (1 << (1u)) |
                      (password << (2u)) |
                      ((*(volatile Ifx_SCU_WDTS_CON0*)0xF00362A8u).B.REL << (16u));

    /* read back ENDINIT and wait until it has been cleared */
    while ((*(volatile Ifx_SCU_WDTS_CON0*)0xF00362A8u).B.ENDINIT == 1)
    {}
}


static inline uint16 IfxScuWdt_getCpuWatchdogPasswordInline(Ifx_SCU_WDTCPU *watchdog)
{
    uint16 password;

    /* Read Password from CON0 register
     * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
     * to toggle them before returning password */
    password  = watchdog->CON0.B.PW;
    password ^= 0x003F;

    return password;
}


static inline boolean IfxScuWdt_getCpuWatchdogEndInitInline(Ifx_SCU_WDTCPU *watchdog)
{
    return (boolean)watchdog->CON0.B.ENDINIT;
}


static inline uint16 IfxScuWdt_getGlobalSafetyEndinitPasswordInline(void)
{
    /* Read Password from CON0 register
     * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
     * to toggle them before returning password */

    uint16 password = ((*(Ifx_SCU*)0xF0036000u)).SEICON0.B.EPW ^ 0x003F;
    return password;
}


static inline boolean IfxScuWdt_getSafetyWatchdogEndInit(void)
{
    return (boolean)((*(Ifx_SCU*)0xF0036000u)).WDTS.CON0.B.ENDINIT;
}


static inline uint16 IfxScuWdt_getSafetyWatchdogPasswordInline(void)
{
    uint16        password;
    Ifx_SCU_WDTS *watchdog = &((*(Ifx_SCU*)0xF0036000u)).WDTS;

    /* Read Password from Safety WDT CON0 register
     * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
     * to toggle them before returning password */
    password  = watchdog->CON0.B.PW;
    password ^= 0x003F;

    return password;
}


static inline void IfxScuWdt_setCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << (0u)) |
                           (0 << (1u)) |
                           (password << (2u)) |
                           (watchdog->CON0.B.REL << (16u));
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << (0u)) |
                       (1 << (1u)) |
                       (password << (2u)) |
                       (watchdog->CON0.B.REL << (16u));

    /* read back ENDINIT and wait until it has been set */
    while (watchdog->CON0.B.ENDINIT == 0)
    {}
}


static inline void IfxScuWdt_setGlobalSafetyEndinitInline(uint16 password)
{
    /* Set EndInit Watch-dog*/
    ((*(Ifx_SCU*)0xF0036000u)).SEICON0.U = (0xFFFCU << 16U) | (password << (2u)) | (1 << (1u));

    while (((*(Ifx_SCU*)0xF0036000u)).SEICON0.B.ENDINIT == 0)
    {}
}


static inline void IfxScuWdt_setSafetyEndinitInline(uint16 password)
{
    if ((*(volatile Ifx_SCU_WDTS_CON0*)0xF00362A8u).B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        (*(volatile Ifx_SCU_WDTS_CON0*)0xF00362A8u).U = (1 << (0u)) |
                          (0 << (1u)) |
                          (password << (2u)) |
                          ((*(volatile Ifx_SCU_WDTS_CON0*)0xF00362A8u).B.REL << (16u));
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    (*(volatile Ifx_SCU_WDTS_CON0*)0xF00362A8u).U = (1 << (0u)) |
                      (1 << (1u)) |
                      (password << (2u)) |
                      ((*(volatile Ifx_SCU_WDTS_CON0*)0xF00362A8u).B.REL << (16u));

    /* read back ENDINIT and wait until it has been cleared */
    while ((*(volatile Ifx_SCU_WDTS_CON0*)0xF00362A8u).B.ENDINIT == 0)
    {}
}



#line 76 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\ee\\..\\Libraries\\iLLD\\TC38A\\Tricore\\Cpu\\Std\\IfxCpu.h"

#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Scu\\Std\\IfxScuCcu.h"
/**
 * \file IfxScuCcu.h
 * \brief SCU  basic functionality
 * \ingroup IfxLld_Scu
 *
 * \version iLLD_1_0_1_15_0_1
 * \copyright Copyright (c) 2019 Infineon Technologies AG. All rights reserved.
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 * \defgroup IfxLld_Scu SCU
 * \addtogroup IfxLld_Scu
 * \{
 * \defgroup IfxLld_ScuCcu How to use the Scu Clock driver?
 * \addtogroup IfxLld_ScuCcu
 * \{
 *
 * The Scu Clock control unit driver provides a default configuration for pll and Clock initialisation and set of peripheral clock configuration functions.
 *
 * In the following sections it will be described, how to integrate the driver into the application framework.
 *
 * \section IfxLld_ScuCcu_Std_Preparation Preparation
 * \subsection IfxLld_ScuCcu_Std_Include Include Files
 *
 * Include following header file into your C code:
 * \code
 * #include <Scu/Std/IfxScuCcu.h>
 * \endcode
 *
 * \subsection IfxLld_ScuCcu_Std_Variables Variables
 *
 * Declare the Clock Configuration variables in your C code:
 *
 * \code
 * // used globally
 *
 * // configuration for the PLL  steps
 * static IfxScuCcu_PllStepsConfig IfxScuCcu_testPllConfigSteps[] = {
 *     IFXSCU_CFG_PLL_STEPS
 * };
 *
 * static const IfxScuCcu_FlashWaitstateConfig IfxScuCcu_defaultFlashWaitstateConfig = IFXSCU_CFG_FLASH_WAITSTATE;
 * // Default configuration for the Clock Configuration
 * IfxScuCcu_Config                      IfxScuCcu_testClockConfig = {
 *     // IfxScuCcu_InitialStepConfig: Configuration of first step which is same as internal osc frequency.
 *     IFXSCU_CFG_PLL_INITIAL_STEP,
 *     //IfxScuCcu_PllThrottleConfig: Configuration of PLL throttling.
 *     {
 *         sizeof(IfxScuCcu_defaultPllConfigSteps) / sizeof(IfxScuCcu_PllStepConfig),
 *         IfxScuCcu_defaultPllConfigSteps
 *     },
 *     IFXSCU_CFG_CLK_DISTRIBUTION,
 *     &IfxScuCcu_defaultFlashWaitstateConfig,
 *     &IfxScuCcu_defaultModConfig
 * };
 *
 * \endcode
 *
 * \subsection IfxLld_ScuCcu_Std_Init Module Initialisation
 *
 * The module initialisation can be done in the same function. Here an example:
 * \code
 *
 *        // standard PLL & clock initialisation
 *         IfxScuCcu_init(&IfxScuCcu_testClockConfig);
 * \endcode
 *
 *    The SYS PLL, PER PLL1 , PLL2 and clocks are now initialised based on the XTAL and PLL values configured in Ifx_Cfg.h and are ready for use now!
 *
 * Alternately the PLL and clocks can be initialised using below method which provides greater control on the configuration.
 *
 * \code
 * static const IfxScuCcu_PllStepConfig IfxScuCcu_defaultPllConfigSteps[] = {
 *     {                   //Step 0 Config: 150MHz
 *         (4 - 1),        //uint8 k2Step;
 *         0.000100,       //float32 waitTime;
 *     },
 *     {                   //Step 1 Config: 200MHz
 *         (3 - 1),       //uint8 k2Step;
 *         0.000100,       //float32 waitTime;
 *     },
 *     {                   //Step 2 Config: 300MHz
 *         (2 - 1),        //uint8 k2Step;
 *         0.000100,       //float32 waitTime;
 *     }
 * };
 *     IfxScuCcu_Config        IfxScuCcu_sampleClockConfig;
 *
 *     IfxScuCcu_initConfig(&IfxScuCcu_sampleClockConfig);
 *
 *
 *
 *     IfxScuCcu_sampleClockConfig.pllInitialStepConfig.pllsParameters.pllInputClockSelection = IfxScuCcu_PllInputClockSelection_fOsc0;
 *
 *     //SYS PLL = 300Mhz, XTAL = 20Mhz
 *     IfxScuCcu_sampleClockConfig.pllInitialStepConfig.pllsParameters.sysPllConfig.k2Divider = IfxScuCcu_K2divider_2;
 *     IfxScuCcu_sampleClockConfig.pllInitialStepConfig.pllsParameters.sysPllConfig.nDivider = IfxScuCcu_Ndivider_60;
 *     IfxScuCcu_sampleClockConfig.pllInitialStepConfig.pllsParameters.sysPllConfig.pDivider = IfxScuCcu_Pdivider_2;
 *     IfxScuCcu_sampleClockConfig.pllInitialStepConfig.waitTime = 0.000200F;  // wait time
 *
 *     IfxScuCcu_sampleClockConfig.sysPllThrottleConfig.numOfSteps = sizeof(IfxScuCcu_defaultPllConfigSteps) / sizeof(IfxScuCcu_PllStepConfig); //  step clock incr
 *     IfxScuCcu_sampleClockConfig.sysPllThrottleConfig.pllSteps = IfxScuCcu_defaultPllConfigSteps;
 *
 *     // PER PLL1 = 240Mhz, PERPLL2 = 50Mhz
 *     IfxScuCcu_sampleClockConfig.pllInitialStepConfig.pllsParameters.perPllConfig.k2Divider = IfxScuCcu_K2divider_2;
 *     IfxScuCcu_sampleClockConfig.pllInitialStepConfig.pllsParameters.perPllConfig.k3Divider = IfxScuCcu_K3divider_6;
 *     IfxScuCcu_sampleClockConfig.pllInitialStepConfig.pllsParameters.perPllConfig.k3DividerBypass = 0;
 *     IfxScuCcu_sampleClockConfig.pllInitialStepConfig.pllsParameters.perPllConfig.nDivider = IfxScuCcu_Ndivider_24;
 *     IfxScuCcu_sampleClockConfig.pllInitialStepConfig.pllsParameters.perPllConfig.pDivider = IfxScuCcu_Pdivider_1;
 *
 *     // update CCUCON Config use mask and value as below
 *     IfxScuCcu_sampleClockConfig.clockDistribution.ccucon0.mask =IFXSCU_CFG_CCUCON0_MASK;
 *     IfxScuCcu_sampleClockConfig.clockDistribution.ccucon0.value = IFXSCU_CFG_CCUCON0;
 *
 *     // standard PLL & clock initialisation
 *     IfxScuCcu_init(&IfxScuCcu_sampleClockConfig);
 *
 * \endcode
 *
 * ** Modulation Configuration **
 * The SCU CCU module also provides an option to Frequency Modulate the clock.
 * The Modulation configuration can be done as follows:
 *
 * \code
 *
 * //define your modulation configuration structure:
 *
 *  IFX_CONST IfxScuCcu_Mod_Config IfxScuCcu_SampleModConfig = {
 *          IfxScuCcu_ModEn_disabled,          // disable is default //enable / disable modulation
 *          IfxScuCcu_ModulationAmplitude_0p5, // default 0 value  // specify the modulation amplitude %
 *
 *  }
 *  // put this as part of the CCU configuration:
 *  IfxScuCcu_sampleClockConfig.modulationConfig = &IfxScuCcu_SampleModConfig;
 *
 *  // now initalize the CCU PLL and clock with the init function
 *  IfxScuCcu_init(&IfxScuCcu_sampleClockConfig)
 * \endcode
 *
 * \}
 * \}
 *
 * \defgroup IfxLld_Scu_Std_Ccu Ccu Basic Functionality
 * \ingroup IfxLld_Scu_Std
 * \defgroup IfxLld_Scu_Std_Ccu_Ccu Clock Control Functions
 * \ingroup IfxLld_Scu_Std_Ccu
 * \defgroup IfxLld_Scu_Std_Ccu_Ccu_Operative Clock Control Operative Functions
 * \ingroup IfxLld_Scu_Std_Ccu
 * \defgroup IfxLld_Scu_Std_Ccu_Ccu_Configuration Clock Control Configuration Functions
 * \ingroup IfxLld_Scu_Std_Ccu
 * \defgroup IfxLld_Scu_Std_Ccu_Enum Enumerations
 * \ingroup IfxLld_Scu_Std_Ccu
 */




/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/



#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Scu\\Std\\IfxScuWdt.h"
/**
 * \file IfxScuWdt.h
 * \brief SCU  basic functionality
 * \ingroup IfxLld_Scu
 *
 * \version iLLD_1_0_1_15_0_1
 * \copyright Copyright (c) 2019 Infineon Technologies AG. All rights reserved.
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 * This file contains the APIs for SCU Watchdog and Endinit related functions.
 *
 * \defgroup IfxLld_Scu_Std_Wdt Wdt Basic Functionality
 * \ingroup IfxLld_Scu_Std
 * \defgroup IfxLld_Scu_Std_Wdt_Wdt_Configuration Watchdog Configuration functions
 * \ingroup IfxLld_Scu_Std_Wdt
 * \defgroup IfxLld_Scu_Std_Wdt_Wdt_Endinit Watchdog Endinit functions
 * \ingroup IfxLld_Scu_Std_Wdt
 * \defgroup IfxLld_Scu_Std_Wdt_Wdt_Operative Watchdog Operative functions
 * \ingroup IfxLld_Scu_Std_Wdt
 * \defgroup IfxLld_Scu_Std_Wdt_Wdt_Endinit_Usage How to use Endinit APIs?
 * \ingroup IfxLld_Scu_Std_Wdt
 */


















































































































































































































































































































































































































































































































































































































































































#line 195 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Scu\\Std\\IfxScuCcu.h"

#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Cpu\\Std\\IfxCpu.h"
/**
 * \file IfxCpu.h
 * \brief CPU  basic functionality
 * \ingroup IfxLld_Cpu
 *
 * \version iLLD_1_0_1_15_0_1
 * \copyright Copyright (c) 2021 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 *
 * \defgroup IfxLld_Cpu_Std_Core Cpu Core Functions
 * \ingroup IfxLld_Cpu_Std
 * \defgroup IfxLld_Cpu_Std_Interrupt Interrupt Utility Functions
 * \ingroup IfxLld_Cpu_Std
 * \defgroup IfxLld_Cpu_Std_Cache Cache Management Functions
 * \ingroup IfxLld_Cpu_Std
 * \defgroup IfxLld_Cpu_Std_PerformanceCounter Performance Counter Functions
 * \ingroup IfxLld_Cpu_Std
 * \defgroup IfxLld_Cpu_Std_Synchronization Synchronization Functions
 * \ingroup IfxLld_Cpu_Std
 * \defgroup IfxLld_Cpu_Std_Utility Cpu Utility Functions
 * \ingroup IfxLld_Cpu_Std
 * \defgroup IfxLld_Cpu_Std_Enum Enumerations
 * \ingroup IfxLld_Cpu_Std
 * \defgroup IfxLld_Cpu_Std_DataStructures Data Structures
 * \ingroup IfxLld_Cpu_Std
 */

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 196 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Scu\\Std\\IfxScuCcu.h"



#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\_PinMap\\IfxScu_PinMap.h"
/**
 * \file IfxScu_PinMap.h
 * \brief SCU I/O map
 * \ingroup IfxLld_Scu
 *
 * \version iLLD_1_0_1_15_0_1
 * \copyright Copyright (c) 2017 Infineon Technologies AG. All rights reserved.
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * \defgroup IfxLld_Scu_pinmap SCU Pin Mapping
 * \ingroup IfxLld_Scu
 */







#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Port\\Std\\IfxPort.h"
/**
 * \file IfxPort.h
 * \brief PORT  basic functionality
 * \ingroup IfxLld_Port
 *
 * \version iLLD_1_0_1_15_0_1
 * \copyright Copyright (c) 2020 Infineon Technologies AG. All rights reserved.
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 *
 * \defgroup IfxLld_Port_Std_Enum Enumerations
 * \ingroup IfxLld_Port_Std
 * \defgroup IfxLld_Port_Std_DataStructures Data structures
 * \ingroup IfxLld_Port_Std
 * \defgroup IfxLld_Port_Std_SinglePin Single Pin Functions
 * \ingroup IfxLld_Port_Std
 * \defgroup IfxLld_Port_Std_PortGroup Group Access Functions
 * \ingroup IfxLld_Port_Std
 */




/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/


#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\_Impl\\IfxPort_cfg.h"
/**
 * \file IfxPort_cfg.h
 * \brief PORT on-chip implementation data
 * \ingroup IfxLld_Port
 *
 * \version iLLD_1_0_1_15_0_1
 * \copyright Copyright (c) 2018 Infineon Technologies AG. All rights reserved.
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 * \defgroup IfxLld_Port PORTS
 * \ingroup IfxLld
 * \defgroup IfxLld_Port_Impl Implementation
 * \ingroup IfxLld_Port
 * \defgroup IfxLld_Port_Std Standard Driver
 * \ingroup IfxLld_Port
 */




/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/



#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\Infra\\Sfr\\TC38A\\_Reg\\IfxPort_reg.h"
/**
 * \file IfxPort_reg.h
 * \brief
 * \copyright Copyright (c) 2020 Infineon Technologies AG. All rights reserved.
 *
 *
 * Version: TC38XA_UM_V1.5.0
 * Specification: TC3xx User Manual V1.5.0
 * MAY BE CHANGED BY USER [yes/no]: No
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * \defgroup IfxSfr_P_Registers_Cfg P address
 * \ingroup IfxSfr_P_Registers
 * 
 * \defgroup IfxSfr_P_Registers_Cfg_BaseAddress Base address
 * \ingroup IfxSfr_P_Registers_Cfg
 *
 * \defgroup IfxSfr_P_Registers_Cfg_P00 2-P00
 * \ingroup IfxSfr_P_Registers_Cfg
 *
 * \defgroup IfxSfr_P_Registers_Cfg_P01 2-P01
 * \ingroup IfxSfr_P_Registers_Cfg
 *
 * \defgroup IfxSfr_P_Registers_Cfg_P02 2-P02
 * \ingroup IfxSfr_P_Registers_Cfg
 *
 * \defgroup IfxSfr_P_Registers_Cfg_P10 2-P10
 * \ingroup IfxSfr_P_Registers_Cfg
 *
 * \defgroup IfxSfr_P_Registers_Cfg_P11 2-P11
 * \ingroup IfxSfr_P_Registers_Cfg
 *
 * \defgroup IfxSfr_P_Registers_Cfg_P12 2-P12
 * \ingroup IfxSfr_P_Registers_Cfg
 *
 * \defgroup IfxSfr_P_Registers_Cfg_P13 2-P13
 * \ingroup IfxSfr_P_Registers_Cfg
 *
 * \defgroup IfxSfr_P_Registers_Cfg_P14 2-P14
 * \ingroup IfxSfr_P_Registers_Cfg
 *
 * \defgroup IfxSfr_P_Registers_Cfg_P15 2-P15
 * \ingroup IfxSfr_P_Registers_Cfg
 *
 * \defgroup IfxSfr_P_Registers_Cfg_P20 2-P20
 * \ingroup IfxSfr_P_Registers_Cfg
 *
 * \defgroup IfxSfr_P_Registers_Cfg_P21 2-P21
 * \ingroup IfxSfr_P_Registers_Cfg
 *
 * \defgroup IfxSfr_P_Registers_Cfg_P22 2-P22
 * \ingroup IfxSfr_P_Registers_Cfg
 *
 * \defgroup IfxSfr_P_Registers_Cfg_P23 2-P23
 * \ingroup IfxSfr_P_Registers_Cfg
 *
 * \defgroup IfxSfr_P_Registers_Cfg_P24 2-P24
 * \ingroup IfxSfr_P_Registers_Cfg
 *
 * \defgroup IfxSfr_P_Registers_Cfg_P25 2-P25
 * \ingroup IfxSfr_P_Registers_Cfg
 *
 * \defgroup IfxSfr_P_Registers_Cfg_P26 2-P26
 * \ingroup IfxSfr_P_Registers_Cfg
 *
 * \defgroup IfxSfr_P_Registers_Cfg_P30 2-P30
 * \ingroup IfxSfr_P_Registers_Cfg
 *
 * \defgroup IfxSfr_P_Registers_Cfg_P31 2-P31
 * \ingroup IfxSfr_P_Registers_Cfg
 *
 * \defgroup IfxSfr_P_Registers_Cfg_P32 2-P32
 * \ingroup IfxSfr_P_Registers_Cfg
 *
 * \defgroup IfxSfr_P_Registers_Cfg_P33 2-P33
 * \ingroup IfxSfr_P_Registers_Cfg
 *
 * \defgroup IfxSfr_P_Registers_Cfg_P34 2-P34
 * \ingroup IfxSfr_P_Registers_Cfg
 *
 * \defgroup IfxSfr_P_Registers_Cfg_P40 2-P40
 * \ingroup IfxSfr_P_Registers_Cfg
 *
 * \defgroup IfxSfr_P_Registers_Cfg_P41 2-P41
 * \ingroup IfxSfr_P_Registers_Cfg
 *
 *
 */


/******************************************************************************/

#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\Infra\\Sfr\\TC38A\\_Reg\\IfxPort_regdef.h"
/**
 * \file IfxPort_regdef.h
 * \brief
 * \copyright Copyright (c) 2020 Infineon Technologies AG. All rights reserved.
 *
 *
 * Version: TC38XA_UM_V1.5.0
 * Specification: TC3xx User Manual V1.5.0
 * MAY BE CHANGED BY USER [yes/no]: No
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * \defgroup IfxSfr_P_Registers P Registers
 * \ingroup IfxSfr
 * 
 * \defgroup IfxSfr_P_Registers_Bitfields Bitfields
 * \ingroup IfxSfr_P_Registers
 * 
 * \defgroup IfxSfr_P_Registers_union Register unions
 * \ingroup IfxSfr_P_Registers
 * 
 * \defgroup IfxSfr_P_Registers_struct Memory map
 * \ingroup IfxSfr_P_Registers
 */


/******************************************************************************/

/******************************************************************************/

/******************************************************************************/

/******************************************************************************/


/** \addtogroup IfxSfr_P_Registers_Bitfields
 * \{  */
/** \brief Port n Access Enable Register 0 */
typedef struct _Ifx_P_ACCEN0_Bits
{
    Ifx_UReg_32Bit EN0:1;             /**< \brief [0:0] Access Enable for Master TAG ID 0 (rw) */
    Ifx_UReg_32Bit EN1:1;             /**< \brief [1:1] Access Enable for Master TAG ID 1 (rw) */
    Ifx_UReg_32Bit EN2:1;             /**< \brief [2:2] Access Enable for Master TAG ID 2 (rw) */
    Ifx_UReg_32Bit EN3:1;             /**< \brief [3:3] Access Enable for Master TAG ID 3 (rw) */
    Ifx_UReg_32Bit EN4:1;             /**< \brief [4:4] Access Enable for Master TAG ID 4 (rw) */
    Ifx_UReg_32Bit EN5:1;             /**< \brief [5:5] Access Enable for Master TAG ID 5 (rw) */
    Ifx_UReg_32Bit EN6:1;             /**< \brief [6:6] Access Enable for Master TAG ID 6 (rw) */
    Ifx_UReg_32Bit EN7:1;             /**< \brief [7:7] Access Enable for Master TAG ID 7 (rw) */
    Ifx_UReg_32Bit EN8:1;             /**< \brief [8:8] Access Enable for Master TAG ID 8 (rw) */
    Ifx_UReg_32Bit EN9:1;             /**< \brief [9:9] Access Enable for Master TAG ID 9 (rw) */
    Ifx_UReg_32Bit EN10:1;            /**< \brief [10:10] Access Enable for Master TAG ID 10 (rw) */
    Ifx_UReg_32Bit EN11:1;            /**< \brief [11:11] Access Enable for Master TAG ID 11 (rw) */
    Ifx_UReg_32Bit EN12:1;            /**< \brief [12:12] Access Enable for Master TAG ID 12 (rw) */
    Ifx_UReg_32Bit EN13:1;            /**< \brief [13:13] Access Enable for Master TAG ID 13 (rw) */
    Ifx_UReg_32Bit EN14:1;            /**< \brief [14:14] Access Enable for Master TAG ID 14 (rw) */
    Ifx_UReg_32Bit EN15:1;            /**< \brief [15:15] Access Enable for Master TAG ID 15 (rw) */
    Ifx_UReg_32Bit EN16:1;            /**< \brief [16:16] Access Enable for Master TAG ID 16 (rw) */
    Ifx_UReg_32Bit EN17:1;            /**< \brief [17:17] Access Enable for Master TAG ID 17 (rw) */
    Ifx_UReg_32Bit EN18:1;            /**< \brief [18:18] Access Enable for Master TAG ID 18 (rw) */
    Ifx_UReg_32Bit EN19:1;            /**< \brief [19:19] Access Enable for Master TAG ID 19 (rw) */
    Ifx_UReg_32Bit EN20:1;            /**< \brief [20:20] Access Enable for Master TAG ID 20 (rw) */
    Ifx_UReg_32Bit EN21:1;            /**< \brief [21:21] Access Enable for Master TAG ID 21 (rw) */
    Ifx_UReg_32Bit EN22:1;            /**< \brief [22:22] Access Enable for Master TAG ID 22 (rw) */
    Ifx_UReg_32Bit EN23:1;            /**< \brief [23:23] Access Enable for Master TAG ID 23 (rw) */
    Ifx_UReg_32Bit EN24:1;            /**< \brief [24:24] Access Enable for Master TAG ID 24 (rw) */
    Ifx_UReg_32Bit EN25:1;            /**< \brief [25:25] Access Enable for Master TAG ID 25 (rw) */
    Ifx_UReg_32Bit EN26:1;            /**< \brief [26:26] Access Enable for Master TAG ID 26 (rw) */
    Ifx_UReg_32Bit EN27:1;            /**< \brief [27:27] Access Enable for Master TAG ID 27 (rw) */
    Ifx_UReg_32Bit EN28:1;            /**< \brief [28:28] Access Enable for Master TAG ID 28 (rw) */
    Ifx_UReg_32Bit EN29:1;            /**< \brief [29:29] Access Enable for Master TAG ID 29 (rw) */
    Ifx_UReg_32Bit EN30:1;            /**< \brief [30:30] Access Enable for Master TAG ID 30 (rw) */
    Ifx_UReg_32Bit EN31:1;            /**< \brief [31:31] Access Enable for Master TAG ID 31 (rw) */
} Ifx_P_ACCEN0_Bits;

/** \brief Port n Access Enable Register 1 */
typedef struct _Ifx_P_ACCEN1_Bits
{
    Ifx_UReg_32Bit reserved_0:32;     /**< \brief [31:0] \internal Reserved */
} Ifx_P_ACCEN1_Bits;

/** \brief Port n Emergency Stop Register */
typedef struct _Ifx_P_ESR_Bits
{
    Ifx_UReg_32Bit EN0:1;             /**< \brief [0:0] Emergency Stop Enable for Pin 0 (rw) */
    Ifx_UReg_32Bit EN1:1;             /**< \brief [1:1] Emergency Stop Enable for Pin 1 (rw) */
    Ifx_UReg_32Bit EN2:1;             /**< \brief [2:2] Emergency Stop Enable for Pin 2 (rw) */
    Ifx_UReg_32Bit EN3:1;             /**< \brief [3:3] Emergency Stop Enable for Pin 3 (rw) */
    Ifx_UReg_32Bit EN4:1;             /**< \brief [4:4] Emergency Stop Enable for Pin 4 (rw) */
    Ifx_UReg_32Bit EN5:1;             /**< \brief [5:5] Emergency Stop Enable for Pin 5 (rw) */
    Ifx_UReg_32Bit EN6:1;             /**< \brief [6:6] Emergency Stop Enable for Pin 6 (rw) */
    Ifx_UReg_32Bit EN7:1;             /**< \brief [7:7] Emergency Stop Enable for Pin 7 (rw) */
    Ifx_UReg_32Bit EN8:1;             /**< \brief [8:8] Emergency Stop Enable for Pin 8 (rw) */
    Ifx_UReg_32Bit EN9:1;             /**< \brief [9:9] Emergency Stop Enable for Pin 9 (rw) */
    Ifx_UReg_32Bit EN10:1;            /**< \brief [10:10] Emergency Stop Enable for Pin 10 (rw) */
    Ifx_UReg_32Bit EN11:1;            /**< \brief [11:11] Emergency Stop Enable for Pin 11 (rw) */
    Ifx_UReg_32Bit EN12:1;            /**< \brief [12:12] Emergency Stop Enable for Pin 12 (rw) */
    Ifx_UReg_32Bit EN13:1;            /**< \brief [13:13] Emergency Stop Enable for Pin 13 (rw) */
    Ifx_UReg_32Bit EN14:1;            /**< \brief [14:14] Emergency Stop Enable for Pin 14 (rw) */
    Ifx_UReg_32Bit EN15:1;            /**< \brief [15:15] Emergency Stop Enable for Pin 15 (rw) */
    Ifx_UReg_32Bit reserved_16:16;    /**< \brief [31:16] \internal Reserved */
} Ifx_P_ESR_Bits;

/** \brief Port n Identification Register */
typedef struct _Ifx_P_ID_Bits
{
    Ifx_UReg_32Bit MODREV:8;          /**< \brief [7:0] Module Revision Number (r) */
    Ifx_UReg_32Bit MODTYPE:8;         /**< \brief [15:8] Module Type (r) */
    Ifx_UReg_32Bit MODNUMBER:16;      /**< \brief [31:16] Module Number (r) */
} Ifx_P_ID_Bits;

/** \brief Port n Input Register */
typedef struct _Ifx_P_IN_Bits
{
    Ifx_UReg_32Bit P0:1;              /**< \brief [0:0] Input Bit 0 (rh) */
    Ifx_UReg_32Bit P1:1;              /**< \brief [1:1] Input Bit 1 (rh) */
    Ifx_UReg_32Bit P2:1;              /**< \brief [2:2] Input Bit 2 (rh) */
    Ifx_UReg_32Bit P3:1;              /**< \brief [3:3] Input Bit 3 (rh) */
    Ifx_UReg_32Bit P4:1;              /**< \brief [4:4] Input Bit 4 (rh) */
    Ifx_UReg_32Bit P5:1;              /**< \brief [5:5] Input Bit 5 (rh) */
    Ifx_UReg_32Bit P6:1;              /**< \brief [6:6] Input Bit 6 (rh) */
    Ifx_UReg_32Bit P7:1;              /**< \brief [7:7] Input Bit 7 (rh) */
    Ifx_UReg_32Bit P8:1;              /**< \brief [8:8] Input Bit 8 (rh) */
    Ifx_UReg_32Bit P9:1;              /**< \brief [9:9] Input Bit 9 (rh) */
    Ifx_UReg_32Bit P10:1;             /**< \brief [10:10] Input Bit 10 (rh) */
    Ifx_UReg_32Bit P11:1;             /**< \brief [11:11] Input Bit 11 (rh) */
    Ifx_UReg_32Bit P12:1;             /**< \brief [12:12] Input Bit 12 (rh) */
    Ifx_UReg_32Bit P13:1;             /**< \brief [13:13] Input Bit 13 (rh) */
    Ifx_UReg_32Bit P14:1;             /**< \brief [14:14] Input Bit 14 (rh) */
    Ifx_UReg_32Bit P15:1;             /**< \brief [15:15] Input Bit 15 (rh) */
    Ifx_UReg_32Bit reserved_16:16;    /**< \brief [31:16] \internal Reserved */
} Ifx_P_IN_Bits;

/** \brief Port n Input/Output Control Register 0 */
typedef struct _Ifx_P_IOCR0_Bits
{
    Ifx_UReg_32Bit reserved_0:3;      /**< \brief [2:0] \internal Reserved */
    Ifx_UReg_32Bit PC0:5;             /**< \brief [7:3] Port Control for Pin 0 (rw) */
    Ifx_UReg_32Bit reserved_8:3;      /**< \brief [10:8] \internal Reserved */
    Ifx_UReg_32Bit PC1:5;             /**< \brief [15:11] Port Control for Pin 1 (rw) */
    Ifx_UReg_32Bit reserved_16:3;     /**< \brief [18:16] \internal Reserved */
    Ifx_UReg_32Bit PC2:5;             /**< \brief [23:19] Port Control for Pin 2 (rw) */
    Ifx_UReg_32Bit reserved_24:3;     /**< \brief [26:24] \internal Reserved */
    Ifx_UReg_32Bit PC3:5;             /**< \brief [31:27] Port Control for Pin 3 (rw) */
} Ifx_P_IOCR0_Bits;

/** \brief Port n Input/Output Control Register 12 */
typedef struct _Ifx_P_IOCR12_Bits
{
    Ifx_UReg_32Bit reserved_0:3;      /**< \brief [2:0] \internal Reserved */
    Ifx_UReg_32Bit PC12:5;            /**< \brief [7:3] Port Control for Port n Pin 12 (rw) */
    Ifx_UReg_32Bit reserved_8:3;      /**< \brief [10:8] \internal Reserved */
    Ifx_UReg_32Bit PC13:5;            /**< \brief [15:11] Port Control for Port n Pin 13 (rw) */
    Ifx_UReg_32Bit reserved_16:3;     /**< \brief [18:16] \internal Reserved */
    Ifx_UReg_32Bit PC14:5;            /**< \brief [23:19] Port Control for Port n Pin 14 (rw) */
    Ifx_UReg_32Bit reserved_24:3;     /**< \brief [26:24] \internal Reserved */
    Ifx_UReg_32Bit PC15:5;            /**< \brief [31:27] Port Control for Port n Pin 15 (rw) */
} Ifx_P_IOCR12_Bits;

/** \brief Port n Input/Output Control Register 4 */
typedef struct _Ifx_P_IOCR4_Bits
{
    Ifx_UReg_32Bit reserved_0:3;      /**< \brief [2:0] \internal Reserved */
    Ifx_UReg_32Bit PC4:5;             /**< \brief [7:3] Port Control for Port n Pin 4 (rw) */
    Ifx_UReg_32Bit reserved_8:3;      /**< \brief [10:8] \internal Reserved */
    Ifx_UReg_32Bit PC5:5;             /**< \brief [15:11] Port Control for Port n Pin 5 (rw) */
    Ifx_UReg_32Bit reserved_16:3;     /**< \brief [18:16] \internal Reserved */
    Ifx_UReg_32Bit PC6:5;             /**< \brief [23:19] Port Control for Port n Pin 6 (rw) */
    Ifx_UReg_32Bit reserved_24:3;     /**< \brief [26:24] \internal Reserved */
    Ifx_UReg_32Bit PC7:5;             /**< \brief [31:27] Port Control for Port n Pin 7 (rw) */
} Ifx_P_IOCR4_Bits;

/** \brief Port n Input/Output Control Register 8 */
typedef struct _Ifx_P_IOCR8_Bits
{
    Ifx_UReg_32Bit reserved_0:3;      /**< \brief [2:0] \internal Reserved */
    Ifx_UReg_32Bit PC8:5;             /**< \brief [7:3] Port Control for Port n Pin 8 (rw) */
    Ifx_UReg_32Bit reserved_8:3;      /**< \brief [10:8] \internal Reserved */
    Ifx_UReg_32Bit PC9:5;             /**< \brief [15:11] Port Control for Port n Pin 9 (rw) */
    Ifx_UReg_32Bit reserved_16:3;     /**< \brief [18:16] \internal Reserved */
    Ifx_UReg_32Bit PC10:5;            /**< \brief [23:19] Port Control for Port n Pin 10 (rw) */
    Ifx_UReg_32Bit reserved_24:3;     /**< \brief [26:24] \internal Reserved */
    Ifx_UReg_32Bit PC11:5;            /**< \brief [31:27] Port Control for Port n Pin 11 (rw) */
} Ifx_P_IOCR8_Bits;

/** \brief Port n LVDS Pad Control Register ${x} */
typedef struct _Ifx_P_LPCR_Bits
{
    Ifx_UReg_32Bit REN_CTRL:1;        /**< \brief [0:0] LVDS RX_EN controller (rw) */
    Ifx_UReg_32Bit RX_EN:1;           /**< \brief [1:1] Enable Receive LVDS (rw) */
    Ifx_UReg_32Bit TERM:1;            /**< \brief [2:2] Select Receiver Termination Mode (rw) */
    Ifx_UReg_32Bit LRXTERM:3;         /**< \brief [5:3] LVDS RX Poly-resistor configuration value (rw) */
    Ifx_UReg_32Bit LVDSM:1;           /**< \brief [6:6] LVDS-M Mode (rw) */
    Ifx_UReg_32Bit PS:1;              /**< \brief [7:7] Pad Supply Selection (rw) */
    Ifx_UReg_32Bit TEN_CTRL:1;        /**< \brief [8:8] LVDS TX_EN controller (rw) */
    Ifx_UReg_32Bit TX_EN:1;           /**< \brief [9:9] Enable Transmit LVDS (rw) */
    Ifx_UReg_32Bit VDIFFADJ:2;        /**< \brief [11:10] LVDS Output Amplitude Tuning (rw) */
    Ifx_UReg_32Bit VOSDYN:1;          /**< \brief [12:12] Tune Bit of VOS Control Loop Static/Dynamic (rw) */
    Ifx_UReg_32Bit VOSEXT:1;          /**< \brief [13:13] Tune Bit of VOS Control Loop Internal/External (rw) */
    Ifx_UReg_32Bit TX_PD:1;           /**< \brief [14:14] LVDS Power Down (rw) */
    Ifx_UReg_32Bit TX_PWDPD:1;        /**< \brief [15:15] Enable TX Power down pull down. (rw) */
    Ifx_UReg_32Bit reserved_16:16;    /**< \brief [31:16] \internal Reserved */
} Ifx_P_LPCR_Bits;

/** \brief Port n Output Modification Clear Register */
typedef struct _Ifx_P_OMCR_Bits
{
    Ifx_UReg_32Bit reserved_0:16;     /**< \brief [15:0] \internal Reserved */
    Ifx_UReg_32Bit PCL0:1;            /**< \brief [16:16] Clear Bit 0 (w) */
    Ifx_UReg_32Bit PCL1:1;            /**< \brief [17:17] Clear Bit 1 (w) */
    Ifx_UReg_32Bit PCL2:1;            /**< \brief [18:18] Clear Bit 2 (w) */
    Ifx_UReg_32Bit PCL3:1;            /**< \brief [19:19] Clear Bit 3 (w) */
    Ifx_UReg_32Bit PCL4:1;            /**< \brief [20:20] Clear Bit 4 (w) */
    Ifx_UReg_32Bit PCL5:1;            /**< \brief [21:21] Clear Bit 5 (w) */
    Ifx_UReg_32Bit PCL6:1;            /**< \brief [22:22] Clear Bit 6 (w) */
    Ifx_UReg_32Bit PCL7:1;            /**< \brief [23:23] Clear Bit 7 (w) */
    Ifx_UReg_32Bit PCL8:1;            /**< \brief [24:24] Clear Bit 8 (w) */
    Ifx_UReg_32Bit PCL9:1;            /**< \brief [25:25] Clear Bit 9 (w) */
    Ifx_UReg_32Bit PCL10:1;           /**< \brief [26:26] Clear Bit 10 (w) */
    Ifx_UReg_32Bit PCL11:1;           /**< \brief [27:27] Clear Bit 11 (w) */
    Ifx_UReg_32Bit PCL12:1;           /**< \brief [28:28] Clear Bit 12 (w) */
    Ifx_UReg_32Bit PCL13:1;           /**< \brief [29:29] Clear Bit 13 (w) */
    Ifx_UReg_32Bit PCL14:1;           /**< \brief [30:30] Clear Bit 14 (w) */
    Ifx_UReg_32Bit PCL15:1;           /**< \brief [31:31] Clear Bit 15 (w) */
} Ifx_P_OMCR_Bits;

/** \brief Port n Output Modification Clear Register 0 */
typedef struct _Ifx_P_OMCR0_Bits
{
    Ifx_UReg_32Bit reserved_0:16;     /**< \brief [15:0] \internal Reserved */
    Ifx_UReg_32Bit PCL0:1;            /**< \brief [16:16] Clear Bit 0 (w) */
    Ifx_UReg_32Bit PCL1:1;            /**< \brief [17:17] Clear Bit 1 (w) */
    Ifx_UReg_32Bit PCL2:1;            /**< \brief [18:18] Clear Bit 2 (w) */
    Ifx_UReg_32Bit PCL3:1;            /**< \brief [19:19] Clear Bit 3 (w) */
    Ifx_UReg_32Bit reserved_20:12;    /**< \brief [31:20] \internal Reserved */
} Ifx_P_OMCR0_Bits;

/** \brief Port n Output Modification Clear Register 12 */
typedef struct _Ifx_P_OMCR12_Bits
{
    Ifx_UReg_32Bit reserved_0:28;     /**< \brief [27:0] \internal Reserved */
    Ifx_UReg_32Bit PCL12:1;           /**< \brief [28:28] Clear Bit 12 (w) */
    Ifx_UReg_32Bit PCL13:1;           /**< \brief [29:29] Clear Bit 13 (w) */
    Ifx_UReg_32Bit PCL14:1;           /**< \brief [30:30] Clear Bit 14 (w) */
    Ifx_UReg_32Bit PCL15:1;           /**< \brief [31:31] Clear Bit 15 (w) */
} Ifx_P_OMCR12_Bits;

/** \brief Port n Output Modification Clear Register 4 */
typedef struct _Ifx_P_OMCR4_Bits
{
    Ifx_UReg_32Bit reserved_0:20;     /**< \brief [19:0] \internal Reserved */
    Ifx_UReg_32Bit PCL4:1;            /**< \brief [20:20] Clear Bit 4 (w) */
    Ifx_UReg_32Bit PCL5:1;            /**< \brief [21:21] Clear Bit 5 (w) */
    Ifx_UReg_32Bit PCL6:1;            /**< \brief [22:22] Clear Bit 6 (w) */
    Ifx_UReg_32Bit PCL7:1;            /**< \brief [23:23] Clear Bit 7 (w) */
    Ifx_UReg_32Bit reserved_24:8;     /**< \brief [31:24] \internal Reserved */
} Ifx_P_OMCR4_Bits;

/** \brief Port n Output Modification Clear Register 8 */
typedef struct _Ifx_P_OMCR8_Bits
{
    Ifx_UReg_32Bit reserved_0:24;     /**< \brief [23:0] \internal Reserved */
    Ifx_UReg_32Bit PCL8:1;            /**< \brief [24:24] Clear Bit 8 (w) */
    Ifx_UReg_32Bit PCL9:1;            /**< \brief [25:25] Clear Bit 9 (w) */
    Ifx_UReg_32Bit PCL10:1;           /**< \brief [26:26] Clear Bit 10 (w) */
    Ifx_UReg_32Bit PCL11:1;           /**< \brief [27:27] Clear Bit 11 (w) */
    Ifx_UReg_32Bit reserved_28:4;     /**< \brief [31:28] \internal Reserved */
} Ifx_P_OMCR8_Bits;

/** \brief Port n Output Modification Register */
typedef struct _Ifx_P_OMR_Bits
{
    Ifx_UReg_32Bit PS0:1;             /**< \brief [0:0] Set Bit 0 (w) */
    Ifx_UReg_32Bit PS1:1;             /**< \brief [1:1] Set Bit 1 (w) */
    Ifx_UReg_32Bit PS2:1;             /**< \brief [2:2] Set Bit 2 (w) */
    Ifx_UReg_32Bit PS3:1;             /**< \brief [3:3] Set Bit 3 (w) */
    Ifx_UReg_32Bit PS4:1;             /**< \brief [4:4] Set Bit 4 (w) */
    Ifx_UReg_32Bit PS5:1;             /**< \brief [5:5] Set Bit 5 (w) */
    Ifx_UReg_32Bit PS6:1;             /**< \brief [6:6] Set Bit 6 (w) */
    Ifx_UReg_32Bit PS7:1;             /**< \brief [7:7] Set Bit 7 (w) */
    Ifx_UReg_32Bit PS8:1;             /**< \brief [8:8] Set Bit 8 (w) */
    Ifx_UReg_32Bit PS9:1;             /**< \brief [9:9] Set Bit 9 (w) */
    Ifx_UReg_32Bit PS10:1;            /**< \brief [10:10] Set Bit 10 (w) */
    Ifx_UReg_32Bit PS11:1;            /**< \brief [11:11] Set Bit 11 (w) */
    Ifx_UReg_32Bit PS12:1;            /**< \brief [12:12] Set Bit 12 (w) */
    Ifx_UReg_32Bit PS13:1;            /**< \brief [13:13] Set Bit 13 (w) */
    Ifx_UReg_32Bit PS14:1;            /**< \brief [14:14] Set Bit 14 (w) */
    Ifx_UReg_32Bit PS15:1;            /**< \brief [15:15] Set Bit 15 (w) */
    Ifx_UReg_32Bit PCL0:1;            /**< \brief [16:16] Clear Bit 0 (w) */
    Ifx_UReg_32Bit PCL1:1;            /**< \brief [17:17] Clear Bit 1 (w) */
    Ifx_UReg_32Bit PCL2:1;            /**< \brief [18:18] Clear Bit 2 (w) */
    Ifx_UReg_32Bit PCL3:1;            /**< \brief [19:19] Clear Bit 3 (w) */
    Ifx_UReg_32Bit PCL4:1;            /**< \brief [20:20] Clear Bit 4 (w) */
    Ifx_UReg_32Bit PCL5:1;            /**< \brief [21:21] Clear Bit 5 (w) */
    Ifx_UReg_32Bit PCL6:1;            /**< \brief [22:22] Clear Bit 6 (w) */
    Ifx_UReg_32Bit PCL7:1;            /**< \brief [23:23] Clear Bit 7 (w) */
    Ifx_UReg_32Bit PCL8:1;            /**< \brief [24:24] Clear Bit 8 (w) */
    Ifx_UReg_32Bit PCL9:1;            /**< \brief [25:25] Clear Bit 9 (w) */
    Ifx_UReg_32Bit PCL10:1;           /**< \brief [26:26] Clear Bit 10 (w) */
    Ifx_UReg_32Bit PCL11:1;           /**< \brief [27:27] Clear Bit 11 (w) */
    Ifx_UReg_32Bit PCL12:1;           /**< \brief [28:28] Clear Bit 12 (w) */
    Ifx_UReg_32Bit PCL13:1;           /**< \brief [29:29] Clear Bit 13 (w) */
    Ifx_UReg_32Bit PCL14:1;           /**< \brief [30:30] Clear Bit 14 (w) */
    Ifx_UReg_32Bit PCL15:1;           /**< \brief [31:31] Clear Bit 15 (w) */
} Ifx_P_OMR_Bits;

/** \brief Port n Output Modification Set Register */
typedef struct _Ifx_P_OMSR_Bits
{
    Ifx_UReg_32Bit PS0:1;             /**< \brief [0:0] Set Bit 0 (w) */
    Ifx_UReg_32Bit PS1:1;             /**< \brief [1:1] Set Bit 1 (w) */
    Ifx_UReg_32Bit PS2:1;             /**< \brief [2:2] Set Bit 2 (w) */
    Ifx_UReg_32Bit PS3:1;             /**< \brief [3:3] Set Bit 3 (w) */
    Ifx_UReg_32Bit PS4:1;             /**< \brief [4:4] Set Bit 4 (w) */
    Ifx_UReg_32Bit PS5:1;             /**< \brief [5:5] Set Bit 5 (w) */
    Ifx_UReg_32Bit PS6:1;             /**< \brief [6:6] Set Bit 6 (w) */
    Ifx_UReg_32Bit PS7:1;             /**< \brief [7:7] Set Bit 7 (w) */
    Ifx_UReg_32Bit PS8:1;             /**< \brief [8:8] Set Bit 8 (w) */
    Ifx_UReg_32Bit PS9:1;             /**< \brief [9:9] Set Bit 9 (w) */
    Ifx_UReg_32Bit PS10:1;            /**< \brief [10:10] Set Bit 10 (w) */
    Ifx_UReg_32Bit PS11:1;            /**< \brief [11:11] Set Bit 11 (w) */
    Ifx_UReg_32Bit PS12:1;            /**< \brief [12:12] Set Bit 12 (w) */
    Ifx_UReg_32Bit PS13:1;            /**< \brief [13:13] Set Bit 13 (w) */
    Ifx_UReg_32Bit PS14:1;            /**< \brief [14:14] Set Bit 14 (w) */
    Ifx_UReg_32Bit PS15:1;            /**< \brief [15:15] Set Bit 15 (w) */
    Ifx_UReg_32Bit reserved_16:16;    /**< \brief [31:16] \internal Reserved */
} Ifx_P_OMSR_Bits;

/** \brief Port n Output Modification Set Register 0 */
typedef struct _Ifx_P_OMSR0_Bits
{
    Ifx_UReg_32Bit PS0:1;             /**< \brief [0:0] Set Bit 0 (w) */
    Ifx_UReg_32Bit PS1:1;             /**< \brief [1:1] Set Bit 1 (w) */
    Ifx_UReg_32Bit PS2:1;             /**< \brief [2:2] Set Bit 2 (w) */
    Ifx_UReg_32Bit PS3:1;             /**< \brief [3:3] Set Bit 3 (w) */
    Ifx_UReg_32Bit reserved_4:28;     /**< \brief [31:4] \internal Reserved */
} Ifx_P_OMSR0_Bits;

/** \brief Port n Output Modification Set Register 12 */
typedef struct _Ifx_P_OMSR12_Bits
{
    Ifx_UReg_32Bit reserved_0:12;     /**< \brief [11:0] \internal Reserved */
    Ifx_UReg_32Bit PS12:1;            /**< \brief [12:12] Set Bit 12 (w) */
    Ifx_UReg_32Bit PS13:1;            /**< \brief [13:13] Set Bit 13 (w) */
    Ifx_UReg_32Bit PS14:1;            /**< \brief [14:14] Set Bit 14 (w) */
    Ifx_UReg_32Bit PS15:1;            /**< \brief [15:15] Set Bit 15 (w) */
    Ifx_UReg_32Bit reserved_16:16;    /**< \brief [31:16] \internal Reserved */
} Ifx_P_OMSR12_Bits;

/** \brief Port n Output Modification Set Register 4 */
typedef struct _Ifx_P_OMSR4_Bits
{
    Ifx_UReg_32Bit reserved_0:4;      /**< \brief [3:0] \internal Reserved */
    Ifx_UReg_32Bit PS4:1;             /**< \brief [4:4] Set Bit 4 (w) */
    Ifx_UReg_32Bit PS5:1;             /**< \brief [5:5] Set Bit 5 (w) */
    Ifx_UReg_32Bit PS6:1;             /**< \brief [6:6] Set Bit 6 (w) */
    Ifx_UReg_32Bit PS7:1;             /**< \brief [7:7] Set Bit 7 (w) */
    Ifx_UReg_32Bit reserved_8:24;     /**< \brief [31:8] \internal Reserved */
} Ifx_P_OMSR4_Bits;

/** \brief Port n Output Modification Set Register 8 */
typedef struct _Ifx_P_OMSR8_Bits
{
    Ifx_UReg_32Bit reserved_0:8;      /**< \brief [7:0] \internal Reserved */
    Ifx_UReg_32Bit PS8:1;             /**< \brief [8:8] Set Bit 8 (w) */
    Ifx_UReg_32Bit PS9:1;             /**< \brief [9:9] Set Bit 9 (w) */
    Ifx_UReg_32Bit PS10:1;            /**< \brief [10:10] Set Bit 10 (w) */
    Ifx_UReg_32Bit PS11:1;            /**< \brief [11:11] Set Bit 11 (w) */
    Ifx_UReg_32Bit reserved_12:20;    /**< \brief [31:12] \internal Reserved */
} Ifx_P_OMSR8_Bits;

/** \brief Port n Output Register */
typedef struct _Ifx_P_OUT_Bits
{
    Ifx_UReg_32Bit P0:1;              /**< \brief [0:0] Output Bit 0 (rwh) */
    Ifx_UReg_32Bit P1:1;              /**< \brief [1:1] Output Bit 1 (rwh) */
    Ifx_UReg_32Bit P2:1;              /**< \brief [2:2] Output Bit 2 (rwh) */
    Ifx_UReg_32Bit P3:1;              /**< \brief [3:3] Output Bit 3 (rwh) */
    Ifx_UReg_32Bit P4:1;              /**< \brief [4:4] Output Bit 4 (rwh) */
    Ifx_UReg_32Bit P5:1;              /**< \brief [5:5] Output Bit 5 (rwh) */
    Ifx_UReg_32Bit P6:1;              /**< \brief [6:6] Output Bit 6 (rwh) */
    Ifx_UReg_32Bit P7:1;              /**< \brief [7:7] Output Bit 7 (rwh) */
    Ifx_UReg_32Bit P8:1;              /**< \brief [8:8] Output Bit 8 (rwh) */
    Ifx_UReg_32Bit P9:1;              /**< \brief [9:9] Output Bit 9 (rwh) */
    Ifx_UReg_32Bit P10:1;             /**< \brief [10:10] Output Bit 10 (rwh) */
    Ifx_UReg_32Bit P11:1;             /**< \brief [11:11] Output Bit 11 (rwh) */
    Ifx_UReg_32Bit P12:1;             /**< \brief [12:12] Output Bit 12 (rwh) */
    Ifx_UReg_32Bit P13:1;             /**< \brief [13:13] Output Bit 13 (rwh) */
    Ifx_UReg_32Bit P14:1;             /**< \brief [14:14] Output Bit 14 (rwh) */
    Ifx_UReg_32Bit P15:1;             /**< \brief [15:15] Output Bit 15 (rwh) */
    Ifx_UReg_32Bit reserved_16:16;    /**< \brief [31:16] \internal Reserved */
} Ifx_P_OUT_Bits;

/** \brief Port n Pin Controller Select Register */
typedef struct _Ifx_P_PCSR_Bits
{
    Ifx_UReg_32Bit SEL0:1;            /**< \brief [0:0] Output Select for Pin 0 (rw) */
    Ifx_UReg_32Bit SEL1:1;            /**< \brief [1:1] Output Select for Pin 1 (rw) */
    Ifx_UReg_32Bit SEL2:1;            /**< \brief [2:2] Output Select for Pin 2 (rw) */
    Ifx_UReg_32Bit SEL3:1;            /**< \brief [3:3] Output Select for Pin 3 (rw) */
    Ifx_UReg_32Bit SEL4:1;            /**< \brief [4:4] Output Select for Pin 4 (rw) */
    Ifx_UReg_32Bit SEL5:1;            /**< \brief [5:5] Output Select for Pin 5 (rw) */
    Ifx_UReg_32Bit SEL6:1;            /**< \brief [6:6] Output Select for Pin 6 (rw) */
    Ifx_UReg_32Bit SEL7:1;            /**< \brief [7:7] Output Select for Pin 7 (rw) */
    Ifx_UReg_32Bit SEL8:1;            /**< \brief [8:8] Output Select for Pin 8 (rw) */
    Ifx_UReg_32Bit SEL9:1;            /**< \brief [9:9] Output Select for Pin 9 (rw) */
    Ifx_UReg_32Bit SEL10:1;           /**< \brief [10:10] Output Select for Pin 10 (rw) */
    Ifx_UReg_32Bit SEL11:1;           /**< \brief [11:11] Output Select for Pin 11 (rw) */
    Ifx_UReg_32Bit SEL12:1;           /**< \brief [12:12] Output Select for Pin 12 (rw) */
    Ifx_UReg_32Bit SEL13:1;           /**< \brief [13:13] Output Select for Pin 13 (rw) */
    Ifx_UReg_32Bit SEL14:1;           /**< \brief [14:14] Output Select for Pin 14 (rw) */
    Ifx_UReg_32Bit SEL15:1;           /**< \brief [15:15] Output Select for Pin 15 (rw) */
    Ifx_UReg_32Bit reserved_16:15;    /**< \brief [30:16] \internal Reserved */
    Ifx_UReg_32Bit LCK:1;             /**< \brief [31:31] Lock Status (rh) */
} Ifx_P_PCSR_Bits;

/** \brief Port n Pin Function Decision Control Register */
typedef struct _Ifx_P_PDISC_Bits
{
    Ifx_UReg_32Bit PDIS0:1;           /**< \brief [0:0] Pin Function Decision Control for Pin 0 (rw) */
    Ifx_UReg_32Bit PDIS1:1;           /**< \brief [1:1] Pin Function Decision Control for Pin 1 (rw) */
    Ifx_UReg_32Bit PDIS2:1;           /**< \brief [2:2] Pin Function Decision Control for Pin 2 (rw) */
    Ifx_UReg_32Bit PDIS3:1;           /**< \brief [3:3] Pin Function Decision Control for Pin 3 (rw) */
    Ifx_UReg_32Bit PDIS4:1;           /**< \brief [4:4] Pin Function Decision Control for Pin 4 (rw) */
    Ifx_UReg_32Bit PDIS5:1;           /**< \brief [5:5] Pin Function Decision Control for Pin 5 (rw) */
    Ifx_UReg_32Bit PDIS6:1;           /**< \brief [6:6] Pin Function Decision Control for Pin 6 (rw) */
    Ifx_UReg_32Bit PDIS7:1;           /**< \brief [7:7] Pin Function Decision Control for Pin 7 (rw) */
    Ifx_UReg_32Bit PDIS8:1;           /**< \brief [8:8] Pin Function Decision Control for Pin 8 (rw) */
    Ifx_UReg_32Bit PDIS9:1;           /**< \brief [9:9] Pin Function Decision Control for Pin 9 (rw) */
    Ifx_UReg_32Bit PDIS10:1;          /**< \brief [10:10] Pin Function Decision Control for Pin 10 (rw) */
    Ifx_UReg_32Bit PDIS11:1;          /**< \brief [11:11] Pin Function Decision Control for Pin 11 (rw) */
    Ifx_UReg_32Bit PDIS12:1;          /**< \brief [12:12] Pin Function Decision Control for Pin 12 (rw) */
    Ifx_UReg_32Bit PDIS13:1;          /**< \brief [13:13] Pin Function Decision Control for Pin 13 (rw) */
    Ifx_UReg_32Bit PDIS14:1;          /**< \brief [14:14] Pin Function Decision Control for Pin 14 (rw) */
    Ifx_UReg_32Bit PDIS15:1;          /**< \brief [15:15] Pin Function Decision Control for Pin 15 (rw) */
    Ifx_UReg_32Bit reserved_16:16;    /**< \brief [31:16] \internal Reserved */
} Ifx_P_PDISC_Bits;

/** \brief Port n Pad Driver Mode Register 0 */
typedef struct _Ifx_P_PDR0_Bits
{
    Ifx_UReg_32Bit PD0:2;             /**< \brief [1:0] Pad Driver Mode for Pin 0 (rw) */
    Ifx_UReg_32Bit PL0:2;             /**< \brief [3:2] Pad Level Selection for Pin 0 (rw) */
    Ifx_UReg_32Bit PD1:2;             /**< \brief [5:4] Pad Driver Mode for Pin 1 (rw) */
    Ifx_UReg_32Bit PL1:2;             /**< \brief [7:6] Pad Level Selection for Pin 1 (rw) */
    Ifx_UReg_32Bit PD2:2;             /**< \brief [9:8] Pad Driver Mode for Pin 2 (rw) */
    Ifx_UReg_32Bit PL2:2;             /**< \brief [11:10] Pad Level Selection for Pin 2 (rw) */
    Ifx_UReg_32Bit PD3:2;             /**< \brief [13:12] Pad Driver Mode for Pin 3 (rw) */
    Ifx_UReg_32Bit PL3:2;             /**< \brief [15:14] Pad Level Selection for Pin 3 (rw) */
    Ifx_UReg_32Bit PD4:2;             /**< \brief [17:16] Pad Driver Mode for Pin 4 (rw) */
    Ifx_UReg_32Bit PL4:2;             /**< \brief [19:18] Pad Level Selection for Pin 4 (rw) */
    Ifx_UReg_32Bit PD5:2;             /**< \brief [21:20] Pad Driver Mode for Pin 5 (rw) */
    Ifx_UReg_32Bit PL5:2;             /**< \brief [23:22] Pad Level Selection for Pin 5 (rw) */
    Ifx_UReg_32Bit PD6:2;             /**< \brief [25:24] Pad Driver Mode for Pin 6 (rw) */
    Ifx_UReg_32Bit PL6:2;             /**< \brief [27:26] Pad Level Selection for Pin 6 (rw) */
    Ifx_UReg_32Bit PD7:2;             /**< \brief [29:28] Pad Driver Mode for Pin 7 (rw) */
    Ifx_UReg_32Bit PL7:2;             /**< \brief [31:30] Pad Level Selection for Pin 7 (rw) */
} Ifx_P_PDR0_Bits;

/** \brief Port n Pad Driver Mode Register 1 */
typedef struct _Ifx_P_PDR1_Bits
{
    Ifx_UReg_32Bit PD8:2;             /**< \brief [1:0] Pad Driver Mode for Pin 8 (rw) */
    Ifx_UReg_32Bit PL8:2;             /**< \brief [3:2] Pad Level Selection for Pin 8 (rw) */
    Ifx_UReg_32Bit PD9:2;             /**< \brief [5:4] Pad Driver Mode for Pin 9 (rw) */
    Ifx_UReg_32Bit PL9:2;             /**< \brief [7:6] Pad Level Selection for Pin 9 (rw) */
    Ifx_UReg_32Bit PD10:2;            /**< \brief [9:8] Pad Driver Mode for Pin 10 (rw) */
    Ifx_UReg_32Bit PL10:2;            /**< \brief [11:10] Pad Level Selection for Pin 10 (rw) */
    Ifx_UReg_32Bit PD11:2;            /**< \brief [13:12] Pad Driver Mode for Pin 11 (rw) */
    Ifx_UReg_32Bit PL11:2;            /**< \brief [15:14] Pad Level Selection for Pin 11 (rw) */
    Ifx_UReg_32Bit PD12:2;            /**< \brief [17:16] Pad Driver Mode for Pin 12 (rw) */
    Ifx_UReg_32Bit PL12:2;            /**< \brief [19:18] Pad Level Selection for Pin 12 (rw) */
    Ifx_UReg_32Bit PD13:2;            /**< \brief [21:20] Pad Driver Mode for Pin 13 (rw) */
    Ifx_UReg_32Bit PL13:2;            /**< \brief [23:22] Pad Level Selection for Pin 13 (rw) */
    Ifx_UReg_32Bit PD14:2;            /**< \brief [25:24] Pad Driver Mode for Pin 14 (rw) */
    Ifx_UReg_32Bit PL14:2;            /**< \brief [27:26] Pad Level Selection for Pin 14 (rw) */
    Ifx_UReg_32Bit PD15:2;            /**< \brief [29:28] Pad Driver Mode for Pin 15 (rw) */
    Ifx_UReg_32Bit PL15:2;            /**< \brief [31:30] Pad Level Selection for Pin 15 (rw) */
} Ifx_P_PDR1_Bits;

/** \}  */
/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_p_Registers_union
 * \{   */
/** \brief Port n Access Enable Register 0   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_P_ACCEN0_Bits B;              /**< \brief Bitfield access */
} Ifx_P_ACCEN0;

/** \brief Port n Access Enable Register 1   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_P_ACCEN1_Bits B;              /**< \brief Bitfield access */
} Ifx_P_ACCEN1;

/** \brief Port n Emergency Stop Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_P_ESR_Bits B;                 /**< \brief Bitfield access */
} Ifx_P_ESR;

/** \brief Port n Identification Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_P_ID_Bits B;                  /**< \brief Bitfield access */
} Ifx_P_ID;

/** \brief Port n Input Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_P_IN_Bits B;                  /**< \brief Bitfield access */
} Ifx_P_IN;

/** \brief Port n Input/Output Control Register 0   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_P_IOCR0_Bits B;               /**< \brief Bitfield access */
} Ifx_P_IOCR0;

/** \brief Port n Input/Output Control Register 12   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_P_IOCR12_Bits B;              /**< \brief Bitfield access */
} Ifx_P_IOCR12;

/** \brief Port n Input/Output Control Register 4   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_P_IOCR4_Bits B;               /**< \brief Bitfield access */
} Ifx_P_IOCR4;

/** \brief Port n Input/Output Control Register 8   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_P_IOCR8_Bits B;               /**< \brief Bitfield access */
} Ifx_P_IOCR8;

/** \brief Port n LVDS Pad Control Register ${x}   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_P_LPCR_Bits B;                /**< \brief Bitfield access */
} Ifx_P_LPCR;

/** \brief Port n Output Modification Clear Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_P_OMCR_Bits B;                /**< \brief Bitfield access */
} Ifx_P_OMCR;

/** \brief Port n Output Modification Clear Register 0   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_P_OMCR0_Bits B;               /**< \brief Bitfield access */
} Ifx_P_OMCR0;

/** \brief Port n Output Modification Clear Register 12   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_P_OMCR12_Bits B;              /**< \brief Bitfield access */
} Ifx_P_OMCR12;

/** \brief Port n Output Modification Clear Register 4   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_P_OMCR4_Bits B;               /**< \brief Bitfield access */
} Ifx_P_OMCR4;

/** \brief Port n Output Modification Clear Register 8   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_P_OMCR8_Bits B;               /**< \brief Bitfield access */
} Ifx_P_OMCR8;

/** \brief Port n Output Modification Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_P_OMR_Bits B;                 /**< \brief Bitfield access */
} Ifx_P_OMR;

/** \brief Port n Output Modification Set Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_P_OMSR_Bits B;                /**< \brief Bitfield access */
} Ifx_P_OMSR;

/** \brief Port n Output Modification Set Register 0   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_P_OMSR0_Bits B;               /**< \brief Bitfield access */
} Ifx_P_OMSR0;

/** \brief Port n Output Modification Set Register 12   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_P_OMSR12_Bits B;              /**< \brief Bitfield access */
} Ifx_P_OMSR12;

/** \brief Port n Output Modification Set Register 4   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_P_OMSR4_Bits B;               /**< \brief Bitfield access */
} Ifx_P_OMSR4;

/** \brief Port n Output Modification Set Register 8   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_P_OMSR8_Bits B;               /**< \brief Bitfield access */
} Ifx_P_OMSR8;

/** \brief Port n Output Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_P_OUT_Bits B;                 /**< \brief Bitfield access */
} Ifx_P_OUT;

/** \brief Port n Pin Controller Select Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_P_PCSR_Bits B;                /**< \brief Bitfield access */
} Ifx_P_PCSR;

/** \brief Port n Pin Function Decision Control Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_P_PDISC_Bits B;               /**< \brief Bitfield access */
} Ifx_P_PDISC;

/** \brief Port n Pad Driver Mode Register 0   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_P_PDR0_Bits B;                /**< \brief Bitfield access */
} Ifx_P_PDR0;

/** \brief Port n Pad Driver Mode Register 1   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_P_PDR1_Bits B;                /**< \brief Bitfield access */
} Ifx_P_PDR1;

/** \}  */

/******************************************************************************/
/** \addtogroup IfxSfr_P_Registers_struct
 * \{  */
/******************************************************************************/
/** \name Object L0
 * \{  */

/** \brief P object */
typedef volatile struct _Ifx_P
{
       Ifx_P_OUT                           OUT;                    /**< \brief 0, Port n Output Register*/
       Ifx_P_OMR                           OMR;                    /**< \brief 4, Port n Output Modification Register*/
       Ifx_P_ID                            ID;                     /**< \brief 8, Port n Identification Register*/
       Ifx_UReg_8Bit                       reserved_C[4];          /**< \brief C, \internal Reserved */
       Ifx_P_IOCR0                         IOCR0;                  /**< \brief 10, Port n Input/Output Control Register 0*/
       Ifx_P_IOCR4                         IOCR4;                  /**< \brief 14, Port n Input/Output Control Register 4*/
       Ifx_P_IOCR8                         IOCR8;                  /**< \brief 18, Port n Input/Output Control Register 8*/
       Ifx_P_IOCR12                        IOCR12;                 /**< \brief 1C, Port n Input/Output Control Register 12*/
       Ifx_UReg_8Bit                       reserved_20[4];         /**< \brief 20, \internal Reserved */
       Ifx_P_IN                            IN;                     /**< \brief 24, Port n Input Register*/
       Ifx_UReg_8Bit                       reserved_28[24];        /**< \brief 28, \internal Reserved */
       Ifx_P_PDR0                          PDR0;                   /**< \brief 40, Port n Pad Driver Mode Register 0*/
       Ifx_P_PDR1                          PDR1;                   /**< \brief 44, Port n Pad Driver Mode Register 1*/
       Ifx_UReg_8Bit                       reserved_48[8];         /**< \brief 48, \internal Reserved */
       Ifx_P_ESR                           ESR;                    /**< \brief 50, Port n Emergency Stop Register*/
       Ifx_UReg_8Bit                       reserved_54[12];        /**< \brief 54, \internal Reserved */
       Ifx_P_PDISC                         PDISC;                  /**< \brief 60, Port n Pin Function Decision Control Register*/
       Ifx_P_PCSR                          PCSR;                   /**< \brief 64, Port n Pin Controller Select Register*/
       Ifx_UReg_8Bit                       reserved_68[8];         /**< \brief 68, \internal Reserved */
       Ifx_P_OMSR0                         OMSR0;                  /**< \brief 70, Port n Output Modification Set Register 0*/
       Ifx_P_OMSR4                         OMSR4;                  /**< \brief 74, Port n Output Modification Set Register 4*/
       Ifx_P_OMSR8                         OMSR8;                  /**< \brief 78, Port n Output Modification Set Register 8*/
       Ifx_P_OMSR12                        OMSR12;                 /**< \brief 7C, Port n Output Modification Set Register 12*/
       Ifx_P_OMCR0                         OMCR0;                  /**< \brief 80, Port n Output Modification Clear Register 0*/
       Ifx_P_OMCR4                         OMCR4;                  /**< \brief 84, Port n Output Modification Clear Register 4*/
       Ifx_P_OMCR8                         OMCR8;                  /**< \brief 88, Port n Output Modification Clear Register 8*/
       Ifx_P_OMCR12                        OMCR12;                 /**< \brief 8C, Port n Output Modification Clear Register 12*/
       Ifx_P_OMSR                          OMSR;                   /**< \brief 90, Port n Output Modification Set Register*/
       Ifx_P_OMCR                          OMCR;                   /**< \brief 94, Port n Output Modification Clear Register*/
       Ifx_UReg_8Bit                       reserved_98[8];         /**< \brief 98, \internal Reserved */
       Ifx_P_LPCR                          LPCR[8];                /**< \brief A0, Port n LVDS Pad Control Register ${x}*/
       Ifx_UReg_8Bit                       reserved_C0[56];        /**< \brief C0, \internal Reserved */
       Ifx_P_ACCEN1                        ACCEN1;                 /**< \brief F8, Port n Access Enable Register 1*/
       Ifx_P_ACCEN0                        ACCEN0;                 /**< \brief FC, Port n Access Enable Register 0*/
} Ifx_P;

/** \}  */
/******************************************************************************/
/** \}  */


/******************************************************************************/

/******************************************************************************/


#line 123 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\Infra\\Sfr\\TC38A\\_Reg\\IfxPort_reg.h"
/******************************************************************************/

/******************************************************************************/

/******************************************************************************/

/** \addtogroup IfxSfr_P_Registers_Cfg_BaseAddress
 * \{  */

/** \brief P object */























/** \}  */


/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_P_Registers_Cfg_P00
 * \{  */
/** \brief 0, Port 00 Output Register */


/** \brief 4, Port 00 Output Modification Register */


/** \brief 8, Port 00 Identification Register */


/** \brief 10, Port 00 Input/Output Control Register 0 */


/** \brief 14, Port 00 Input/Output Control Register 4 */


/** \brief 18, Port 00 Input/Output Control Register 8 */


/** \brief 1C, Port 00 Input/Output Control Register 12 */


/** \brief 24, Port 00 Input Register */


/** \brief 40, Port 00 Pad Driver Mode Register 0 */


/** \brief 44, Port 00 Pad Driver Mode Register 1 */


/** \brief 50, Port 00 Emergency Stop Register */


/** \brief 60, Port 00 Pin Function Decision Control Register */


/** \brief 64, Port 00 Pin Controller Select Register */


/** \brief 70, Port 00 Output Modification Set Register 0 */


/** \brief 74, Port 00 Output Modification Set Register 4 */


/** \brief 78, Port 00 Output Modification Set Register 8 */


/** \brief 7C, Port 00 Output Modification Set Register 12 */


/** \brief 80, Port 00 Output Modification Clear Register 0 */


/** \brief 84, Port 00 Output Modification Clear Register 4 */


/** \brief 88, Port 00 Output Modification Clear Register 8 */


/** \brief 8C, Port 00 Output Modification Clear Register 12 */


/** \brief 90, Port 00 Output Modification Set Register */


/** \brief 94, Port 00 Output Modification Clear Register */


/** \brief F8, Port 00 Access Enable Register 1 */


/** \brief FC, Port 00 Access Enable Register 0 */


/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_P_Registers_Cfg_P01
 * \{  */
/** \brief 0, Port 01 Output Register */


/** \brief 4, Port 01 Output Modification Register */


/** \brief 8, Port 01 Identification Register */


/** \brief 10, Port 01 Input/Output Control Register 0 */


/** \brief 14, Port 01 Input/Output Control Register 4 */


/** \brief 18, Port 01 Input/Output Control Register 8 */


/** \brief 1C, Port 01 Input/Output Control Register 12 */


/** \brief 24, Port 01 Input Register */


/** \brief 40, Port 01 Pad Driver Mode Register 0 */


/** \brief 44, Port 01 Pad Driver Mode Register 1 */


/** \brief 50, Port 01 Emergency Stop Register */


/** \brief 60, Port 01 Pin Function Decision Control Register */


/** \brief 64, Port 01 Pin Controller Select Register */


/** \brief 70, Port 01 Output Modification Set Register 0 */


/** \brief 74, Port 01 Output Modification Set Register 4 */


/** \brief 78, Port 01 Output Modification Set Register 8 */


/** \brief 7C, Port 01 Output Modification Set Register 12 */


/** \brief 80, Port 01 Output Modification Clear Register 0 */


/** \brief 84, Port 01 Output Modification Clear Register 4 */


/** \brief 88, Port 01 Output Modification Clear Register 8 */


/** \brief 8C, Port 01 Output Modification Clear Register 12 */


/** \brief 90, Port 01 Output Modification Set Register */


/** \brief 94, Port 01 Output Modification Clear Register */


/** \brief F8, Port 01 Access Enable Register 1 */


/** \brief FC, Port 01 Access Enable Register 0 */


/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_P_Registers_Cfg_P02
 * \{  */
/** \brief 0, Port 02 Output Register */


/** \brief 4, Port 02 Output Modification Register */


/** \brief 8, Port 02 Identification Register */


/** \brief 10, Port 02 Input/Output Control Register 0 */


/** \brief 14, Port 02 Input/Output Control Register 4 */


/** \brief 18, Port 02 Input/Output Control Register 8 */


/** \brief 1C, Port 02 Input/Output Control Register 12 */


/** \brief 24, Port 02 Input Register */


/** \brief 40, Port 02 Pad Driver Mode Register 0 */


/** \brief 44, Port 02 Pad Driver Mode Register 1 */


/** \brief 50, Port 02 Emergency Stop Register */


/** \brief 60, Port 02 Pin Function Decision Control Register */


/** \brief 64, Port 02 Pin Controller Select Register */


/** \brief 70, Port 02 Output Modification Set Register 0 */


/** \brief 74, Port 02 Output Modification Set Register 4 */


/** \brief 78, Port 02 Output Modification Set Register 8 */


/** \brief 7C, Port 02 Output Modification Set Register 12 */


/** \brief 80, Port 02 Output Modification Clear Register 0 */


/** \brief 84, Port 02 Output Modification Clear Register 4 */


/** \brief 88, Port 02 Output Modification Clear Register 8 */


/** \brief 8C, Port 02 Output Modification Clear Register 12 */


/** \brief 90, Port 02 Output Modification Set Register */


/** \brief 94, Port 02 Output Modification Clear Register */


/** \brief F8, Port 02 Access Enable Register 1 */


/** \brief FC, Port 02 Access Enable Register 0 */


/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_P_Registers_Cfg_P10
 * \{  */
/** \brief 0, Port 10 Output Register */


/** \brief 4, Port 10 Output Modification Register */


/** \brief 8, Port 10 Identification Register */


/** \brief 10, Port 10 Input/Output Control Register 0 */


/** \brief 14, Port 10 Input/Output Control Register 4 */


/** \brief 18, Port 10 Input/Output Control Register 8 */


/** \brief 1C, Port 10 Input/Output Control Register 12 */


/** \brief 24, Port 10 Input Register */


/** \brief 40, Port 10 Pad Driver Mode Register 0 */


/** \brief 44, Port 10 Pad Driver Mode Register 1 */


/** \brief 50, Port 10 Emergency Stop Register */


/** \brief 60, Port 10 Pin Function Decision Control Register */


/** \brief 64, Port 10 Pin Controller Select Register */


/** \brief 70, Port 10 Output Modification Set Register 0 */


/** \brief 74, Port 10 Output Modification Set Register 4 */


/** \brief 78, Port 10 Output Modification Set Register 8 */


/** \brief 7C, Port 10 Output Modification Set Register 12 */


/** \brief 80, Port 10 Output Modification Clear Register 0 */


/** \brief 84, Port 10 Output Modification Clear Register 4 */


/** \brief 88, Port 10 Output Modification Clear Register 8 */


/** \brief 8C, Port 10 Output Modification Clear Register 12 */


/** \brief 90, Port 10 Output Modification Set Register */


/** \brief 94, Port 10 Output Modification Clear Register */


/** \brief F8, Port 10 Access Enable Register 1 */


/** \brief FC, Port 10 Access Enable Register 0 */


/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_P_Registers_Cfg_P11
 * \{  */
/** \brief 0, Port 11 Output Register */


/** \brief 4, Port 11 Output Modification Register */


/** \brief 8, Port 11 Identification Register */


/** \brief 10, Port 11 Input/Output Control Register 0 */


/** \brief 14, Port 11 Input/Output Control Register 4 */


/** \brief 18, Port 11 Input/Output Control Register 8 */


/** \brief 1C, Port 11 Input/Output Control Register 12 */


/** \brief 24, Port 11 Input Register */


/** \brief 40, Port 11 Pad Driver Mode Register 0 */


/** \brief 44, Port 11 Pad Driver Mode Register 1 */


/** \brief 50, Port 11 Emergency Stop Register */


/** \brief 60, Port 11 Pin Function Decision Control Register */


/** \brief 64, Port 11 Pin Controller Select Register */


/** \brief 70, Port 11 Output Modification Set Register 0 */


/** \brief 74, Port 11 Output Modification Set Register 4 */


/** \brief 78, Port 11 Output Modification Set Register 8 */


/** \brief 7C, Port 11 Output Modification Set Register 12 */


/** \brief 80, Port 11 Output Modification Clear Register 0 */


/** \brief 84, Port 11 Output Modification Clear Register 4 */


/** \brief 88, Port 11 Output Modification Clear Register 8 */


/** \brief 8C, Port 11 Output Modification Clear Register 12 */


/** \brief 90, Port 11 Output Modification Set Register */


/** \brief 94, Port 11 Output Modification Clear Register */


/** \brief F8, Port 11 Access Enable Register 1 */


/** \brief FC, Port 11 Access Enable Register 0 */


/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_P_Registers_Cfg_P12
 * \{  */
/** \brief 0, Port 12 Output Register */


/** \brief 4, Port 12 Output Modification Register */


/** \brief 8, Port 12 Identification Register */


/** \brief 10, Port 12 Input/Output Control Register 0 */


/** \brief 24, Port 12 Input Register */


/** \brief 40, Port 12 Pad Driver Mode Register 0 */


/** \brief 50, Port 12 Emergency Stop Register */


/** \brief 60, Port 12 Pin Function Decision Control Register */


/** \brief 64, Port 12 Pin Controller Select Register */


/** \brief 70, Port 12 Output Modification Set Register 0 */


/** \brief 80, Port 12 Output Modification Clear Register 0 */


/** \brief 90, Port 12 Output Modification Set Register */


/** \brief 94, Port 12 Output Modification Clear Register */


/** \brief F8, Port 12 Access Enable Register 1 */


/** \brief FC, Port 12 Access Enable Register 0 */


/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_P_Registers_Cfg_P13
 * \{  */
/** \brief 0, Port 13 Output Register */


/** \brief 4, Port 13 Output Modification Register */


/** \brief 8, Port 13 Identification Register */


/** \brief 10, Port 13 Input/Output Control Register 0 */


/** \brief 14, Port 13 Input/Output Control Register 4 */


/** \brief 18, Port 13 Input/Output Control Register 8 */


/** \brief 1C, Port 13 Input/Output Control Register 12 */


/** \brief 24, Port 13 Input Register */


/** \brief 40, Port 13 Pad Driver Mode Register 0 */


/** \brief 44, Port 13 Pad Driver Mode Register 1 */


/** \brief 50, Port 13 Emergency Stop Register */


/** \brief 60, Port 13 Pin Function Decision Control Register */


/** \brief 64, Port 13 Pin Controller Select Register */


/** \brief 70, Port 13 Output Modification Set Register 0 */


/** \brief 74, Port 13 Output Modification Set Register 4 */


/** \brief 78, Port 13 Output Modification Set Register 8 */


/** \brief 7C, Port 13 Output Modification Set Register 12 */


/** \brief 80, Port 13 Output Modification Clear Register 0 */


/** \brief 84, Port 13 Output Modification Clear Register 4 */


/** \brief 88, Port 13 Output Modification Clear Register 8 */


/** \brief 8C, Port 13 Output Modification Clear Register 12 */


/** \brief 90, Port 13 Output Modification Set Register */


/** \brief 94, Port 13 Output Modification Clear Register */


/** \brief A0, Port 13 LVDS Pad Control Register 0 */


/** \brief A4, Port 13 LVDS Pad Control Register 1 */


/** \brief A8, Port 13 LVDS Pad Control Register 2 */


/** \brief AC, Port 13 LVDS Pad Control Register 3 */


/** \brief F8, Port 13 Access Enable Register 1 */


/** \brief FC, Port 13 Access Enable Register 0 */


/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_P_Registers_Cfg_P14
 * \{  */
/** \brief 0, Port 14 Output Register */


/** \brief 4, Port 14 Output Modification Register */


/** \brief 8, Port 14 Identification Register */


/** \brief 10, Port 14 Input/Output Control Register 0 */


/** \brief 14, Port 14 Input/Output Control Register 4 */


/** \brief 18, Port 14 Input/Output Control Register 8 */


/** \brief 1C, Port 14 Input/Output Control Register 12 */


/** \brief 24, Port 14 Input Register */


/** \brief 40, Port 14 Pad Driver Mode Register 0 */


/** \brief 44, Port 14 Pad Driver Mode Register 1 */


/** \brief 50, Port 14 Emergency Stop Register */


/** \brief 60, Port 14 Pin Function Decision Control Register */


/** \brief 64, Port 14 Pin Controller Select Register */


/** \brief 70, Port 14 Output Modification Set Register 0 */


/** \brief 74, Port 14 Output Modification Set Register 4 */


/** \brief 78, Port 14 Output Modification Set Register 8 */


/** \brief 7C, Port 14 Output Modification Set Register 12 */


/** \brief 80, Port 14 Output Modification Clear Register 0 */


/** \brief 84, Port 14 Output Modification Clear Register 4 */


/** \brief 88, Port 14 Output Modification Clear Register 8 */


/** \brief 8C, Port 14 Output Modification Clear Register 12 */


/** \brief 90, Port 14 Output Modification Set Register */


/** \brief 94, Port 14 Output Modification Clear Register */


/** \brief B4, Port 14 LVDS Pad Control Register 5 */


/** \brief F8, Port 14 Access Enable Register 1 */


/** \brief FC, Port 14 Access Enable Register 0 */


/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_P_Registers_Cfg_P15
 * \{  */
/** \brief 0, Port 15 Output Register */


/** \brief 4, Port 15 Output Modification Register */


/** \brief 8, Port 15 Identification Register */


/** \brief 10, Port 15 Input/Output Control Register 0 */


/** \brief 14, Port 15 Input/Output Control Register 4 */


/** \brief 18, Port 15 Input/Output Control Register 8 */


/** \brief 1C, Port 15 Input/Output Control Register 12 */


/** \brief 24, Port 15 Input Register */


/** \brief 40, Port 15 Pad Driver Mode Register 0 */


/** \brief 44, Port 15 Pad Driver Mode Register 1 */


/** \brief 50, Port 15 Emergency Stop Register */


/** \brief 60, Port 15 Pin Function Decision Control Register */


/** \brief 64, Port 15 Pin Controller Select Register */


/** \brief 70, Port 15 Output Modification Set Register 0 */


/** \brief 74, Port 15 Output Modification Set Register 4 */


/** \brief 78, Port 15 Output Modification Set Register 8 */


/** \brief 7C, Port 15 Output Modification Set Register 12 */


/** \brief 80, Port 15 Output Modification Clear Register 0 */


/** \brief 84, Port 15 Output Modification Clear Register 4 */


/** \brief 88, Port 15 Output Modification Clear Register 8 */


/** \brief 8C, Port 15 Output Modification Clear Register 12 */


/** \brief 90, Port 15 Output Modification Set Register */


/** \brief 94, Port 15 Output Modification Clear Register */


/** \brief F8, Port 15 Access Enable Register 1 */


/** \brief FC, Port 15 Access Enable Register 0 */


/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_P_Registers_Cfg_P20
 * \{  */
/** \brief 0, Port 20 Output Register */


/** \brief 4, Port 20 Output Modification Register */


/** \brief 8, Port 20 Identification Register */


/** \brief 10, Port 20 Input/Output Control Register 0 */


/** \brief 14, Port 20 Input/Output Control Register 4 */


/** \brief 18, Port 20 Input/Output Control Register 8 */


/** \brief 1C, Port 20 Input/Output Control Register 12 */


/** \brief 24, Port 20 Input Register */


/** \brief 40, Port 20 Pad Driver Mode Register 0 */


/** \brief 44, Port 20 Pad Driver Mode Register 1 */


/** \brief 50, Port 20 Emergency Stop Register */


/** \brief 60, Port 20 Pin Function Decision Control Register */


/** \brief 64, Port 20 Pin Controller Select Register */


/** \brief 70, Port 20 Output Modification Set Register 0 */


/** \brief 74, Port 20 Output Modification Set Register 4 */


/** \brief 78, Port 20 Output Modification Set Register 8 */


/** \brief 7C, Port 20 Output Modification Set Register 12 */


/** \brief 80, Port 20 Output Modification Clear Register 0 */


/** \brief 84, Port 20 Output Modification Clear Register 4 */


/** \brief 88, Port 20 Output Modification Clear Register 8 */


/** \brief 8C, Port 20 Output Modification Clear Register 12 */


/** \brief 90, Port 20 Output Modification Set Register */


/** \brief 94, Port 20 Output Modification Clear Register */


/** \brief F8, Port 20 Access Enable Register 1 */


/** \brief FC, Port 20 Access Enable Register 0 */


/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_P_Registers_Cfg_P21
 * \{  */
/** \brief 0, Port 21 Output Register */


/** \brief 4, Port 21 Output Modification Register */


/** \brief 8, Port 21 Identification Register */


/** \brief 10, Port 21 Input/Output Control Register 0 */


/** \brief 14, Port 21 Input/Output Control Register 4 */


/** \brief 24, Port 21 Input Register */


/** \brief 40, Port 21 Pad Driver Mode Register 0 */


/** \brief 50, Port 21 Emergency Stop Register */


/** \brief 60, Port 21 Pin Function Decision Control Register */


/** \brief 64, Port 21 Pin Controller Select Register */


/** \brief 70, Port 21 Output Modification Set Register 0 */


/** \brief 74, Port 21 Output Modification Set Register 4 */


/** \brief 80, Port 21 Output Modification Clear Register 0 */


/** \brief 84, Port 21 Output Modification Clear Register 4 */


/** \brief 90, Port 21 Output Modification Set Register */


/** \brief 94, Port 21 Output Modification Clear Register */


/** \brief A0, Port 21 LVDS Pad Control Register 0 */


/** \brief A4, Port 21 LVDS Pad Control Register 1 */


/** \brief A8, Port 21 LVDS Pad Control Register 2 */


/** \brief F8, Port 21 Access Enable Register 1 */


/** \brief FC, Port 21 Access Enable Register 0 */


/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_P_Registers_Cfg_P22
 * \{  */
/** \brief 0, Port 22 Output Register */


/** \brief 4, Port 22 Output Modification Register */


/** \brief 8, Port 22 Identification Register */


/** \brief 10, Port 22 Input/Output Control Register 0 */


/** \brief 14, Port 22 Input/Output Control Register 4 */


/** \brief 18, Port 22 Input/Output Control Register 8 */


/** \brief 24, Port 22 Input Register */


/** \brief 40, Port 22 Pad Driver Mode Register 0 */


/** \brief 44, Port 22 Pad Driver Mode Register 1 */


/** \brief 50, Port 22 Emergency Stop Register */


/** \brief 60, Port 22 Pin Function Decision Control Register */


/** \brief 64, Port 22 Pin Controller Select Register */


/** \brief 70, Port 22 Output Modification Set Register 0 */


/** \brief 74, Port 22 Output Modification Set Register 4 */


/** \brief 78, Port 22 Output Modification Set Register 8 */


/** \brief 80, Port 22 Output Modification Clear Register 0 */


/** \brief 84, Port 22 Output Modification Clear Register 4 */


/** \brief 88, Port 22 Output Modification Clear Register 8 */


/** \brief 90, Port 22 Output Modification Set Register */


/** \brief 94, Port 22 Output Modification Clear Register */


/** \brief A0, Port 22 LVDS Pad Control Register 0 */


/** \brief A4, Port 22 LVDS Pad Control Register 1 */


/** \brief F8, Port 22 Access Enable Register 1 */


/** \brief FC, Port 22 Access Enable Register 0 */


/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_P_Registers_Cfg_P23
 * \{  */
/** \brief 0, Port 23 Output Register */


/** \brief 4, Port 23 Output Modification Register */


/** \brief 8, Port 23 Identification Register */


/** \brief 10, Port 23 Input/Output Control Register 0 */


/** \brief 14, Port 23 Input/Output Control Register 4 */


/** \brief 24, Port 23 Input Register */


/** \brief 40, Port 23 Pad Driver Mode Register 0 */


/** \brief 50, Port 23 Emergency Stop Register */


/** \brief 60, Port 23 Pin Function Decision Control Register */


/** \brief 64, Port 23 Pin Controller Select Register */


/** \brief 70, Port 23 Output Modification Set Register 0 */


/** \brief 74, Port 23 Output Modification Set Register 4 */


/** \brief 80, Port 23 Output Modification Clear Register 0 */


/** \brief 84, Port 23 Output Modification Clear Register 4 */


/** \brief 90, Port 23 Output Modification Set Register */


/** \brief 94, Port 23 Output Modification Clear Register */


/** \brief F8, Port 23 Access Enable Register 1 */


/** \brief FC, Port 23 Access Enable Register 0 */


/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_P_Registers_Cfg_P24
 * \{  */
/** \brief 0, Port 24 Output Register */


/** \brief 4, Port 24 Output Modification Register */


/** \brief 8, Port 24 Identification Register */


/** \brief 10, Port 24 Input/Output Control Register 0 */


/** \brief 14, Port 24 Input/Output Control Register 4 */


/** \brief 18, Port 24 Input/Output Control Register 8 */


/** \brief 1C, Port 24 Input/Output Control Register 12 */


/** \brief 24, Port 24 Input Register */


/** \brief 40, Port 24 Pad Driver Mode Register 0 */


/** \brief 44, Port 24 Pad Driver Mode Register 1 */


/** \brief 50, Port 24 Emergency Stop Register */


/** \brief 60, Port 24 Pin Function Decision Control Register */


/** \brief 64, Port 24 Pin Controller Select Register */


/** \brief 70, Port 24 Output Modification Set Register 0 */


/** \brief 74, Port 24 Output Modification Set Register 4 */


/** \brief 78, Port 24 Output Modification Set Register 8 */


/** \brief 7C, Port 24 Output Modification Set Register 12 */


/** \brief 80, Port 24 Output Modification Clear Register 0 */


/** \brief 84, Port 24 Output Modification Clear Register 4 */


/** \brief 88, Port 24 Output Modification Clear Register 8 */


/** \brief 8C, Port 24 Output Modification Clear Register 12 */


/** \brief 90, Port 24 Output Modification Set Register */


/** \brief 94, Port 24 Output Modification Clear Register */


/** \brief F8, Port 24 Access Enable Register 1 */


/** \brief FC, Port 24 Access Enable Register 0 */


/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_P_Registers_Cfg_P25
 * \{  */
/** \brief 0, Port 25 Output Register */


/** \brief 4, Port 25 Output Modification Register */


/** \brief 8, Port 25 Identification Register */


/** \brief 10, Port 25 Input/Output Control Register 0 */


/** \brief 14, Port 25 Input/Output Control Register 4 */


/** \brief 18, Port 25 Input/Output Control Register 8 */


/** \brief 1C, Port 25 Input/Output Control Register 12 */


/** \brief 24, Port 25 Input Register */


/** \brief 40, Port 25 Pad Driver Mode Register 0 */


/** \brief 44, Port 25 Pad Driver Mode Register 1 */


/** \brief 50, Port 25 Emergency Stop Register */


/** \brief 60, Port 25 Pin Function Decision Control Register */


/** \brief 64, Port 25 Pin Controller Select Register */


/** \brief 70, Port 25 Output Modification Set Register 0 */


/** \brief 74, Port 25 Output Modification Set Register 4 */


/** \brief 78, Port 25 Output Modification Set Register 8 */


/** \brief 7C, Port 25 Output Modification Set Register 12 */


/** \brief 80, Port 25 Output Modification Clear Register 0 */


/** \brief 84, Port 25 Output Modification Clear Register 4 */


/** \brief 88, Port 25 Output Modification Clear Register 8 */


/** \brief 8C, Port 25 Output Modification Clear Register 12 */


/** \brief 90, Port 25 Output Modification Set Register */


/** \brief 94, Port 25 Output Modification Clear Register */


/** \brief F8, Port 25 Access Enable Register 1 */


/** \brief FC, Port 25 Access Enable Register 0 */


/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_P_Registers_Cfg_P26
 * \{  */
/** \brief 0, Port 26 Output Register */


/** \brief 4, Port 26 Output Modification Register */


/** \brief 8, Port 26 Identification Register */


/** \brief 10, Port 26 Input/Output Control Register 0 */


/** \brief 24, Port 26 Input Register */


/** \brief 40, Port 26 Pad Driver Mode Register 0 */


/** \brief 50, Port 26 Emergency Stop Register */


/** \brief 60, Port 26 Pin Function Decision Control Register */


/** \brief 64, Port 26 Pin Controller Select Register */


/** \brief 70, Port 26 Output Modification Set Register 0 */


/** \brief 80, Port 26 Output Modification Clear Register 0 */


/** \brief 90, Port 26 Output Modification Set Register */


/** \brief 94, Port 26 Output Modification Clear Register */


/** \brief F8, Port 26 Access Enable Register 1 */


/** \brief FC, Port 26 Access Enable Register 0 */


/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_P_Registers_Cfg_P30
 * \{  */
/** \brief 0, Port 30 Output Register */


/** \brief 4, Port 30 Output Modification Register */


/** \brief 8, Port 30 Identification Register */


/** \brief 10, Port 30 Input/Output Control Register 0 */


/** \brief 14, Port 30 Input/Output Control Register 4 */


/** \brief 18, Port 30 Input/Output Control Register 8 */


/** \brief 1C, Port 30 Input/Output Control Register 12 */


/** \brief 24, Port 30 Input Register */


/** \brief 40, Port 30 Pad Driver Mode Register 0 */


/** \brief 44, Port 30 Pad Driver Mode Register 1 */


/** \brief 50, Port 30 Emergency Stop Register */


/** \brief 60, Port 30 Pin Function Decision Control Register */


/** \brief 64, Port 30 Pin Controller Select Register */


/** \brief 70, Port 30 Output Modification Set Register 0 */


/** \brief 74, Port 30 Output Modification Set Register 4 */


/** \brief 78, Port 30 Output Modification Set Register 8 */


/** \brief 7C, Port 30 Output Modification Set Register 12 */


/** \brief 80, Port 30 Output Modification Clear Register 0 */


/** \brief 84, Port 30 Output Modification Clear Register 4 */


/** \brief 88, Port 30 Output Modification Clear Register 8 */


/** \brief 8C, Port 30 Output Modification Clear Register 12 */


/** \brief 90, Port 30 Output Modification Set Register */


/** \brief 94, Port 30 Output Modification Clear Register */


/** \brief F8, Port 30 Access Enable Register 1 */


/** \brief FC, Port 30 Access Enable Register 0 */


/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_P_Registers_Cfg_P31
 * \{  */
/** \brief 0, Port 31 Output Register */


/** \brief 4, Port 31 Output Modification Register */


/** \brief 8, Port 31 Identification Register */


/** \brief 10, Port 31 Input/Output Control Register 0 */


/** \brief 14, Port 31 Input/Output Control Register 4 */


/** \brief 18, Port 31 Input/Output Control Register 8 */


/** \brief 1C, Port 31 Input/Output Control Register 12 */


/** \brief 24, Port 31 Input Register */


/** \brief 40, Port 31 Pad Driver Mode Register 0 */


/** \brief 44, Port 31 Pad Driver Mode Register 1 */


/** \brief 50, Port 31 Emergency Stop Register */


/** \brief 60, Port 31 Pin Function Decision Control Register */


/** \brief 64, Port 31 Pin Controller Select Register */


/** \brief 70, Port 31 Output Modification Set Register 0 */


/** \brief 74, Port 31 Output Modification Set Register 4 */


/** \brief 78, Port 31 Output Modification Set Register 8 */


/** \brief 7C, Port 31 Output Modification Set Register 12 */


/** \brief 80, Port 31 Output Modification Clear Register 0 */


/** \brief 84, Port 31 Output Modification Clear Register 4 */


/** \brief 88, Port 31 Output Modification Clear Register 8 */


/** \brief 8C, Port 31 Output Modification Clear Register 12 */


/** \brief 90, Port 31 Output Modification Set Register */


/** \brief 94, Port 31 Output Modification Clear Register */


/** \brief F8, Port 31 Access Enable Register 1 */


/** \brief FC, Port 31 Access Enable Register 0 */


/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_P_Registers_Cfg_P32
 * \{  */
/** \brief 0, Port 32 Output Register */


/** \brief 4, Port 32 Output Modification Register */


/** \brief 8, Port 32 Identification Register */


/** \brief 10, Port 32 Input/Output Control Register 0 */


/** \brief 14, Port 32 Input/Output Control Register 4 */


/** \brief 24, Port 32 Input Register */


/** \brief 40, Port 32 Pad Driver Mode Register 0 */


/** \brief 50, Port 32 Emergency Stop Register */


/** \brief 60, Port 32 Pin Function Decision Control Register */


/** \brief 64, Port 32 Pin Controller Select Register */


/** \brief 70, Port 32 Output Modification Set Register 0 */


/** \brief 74, Port 32 Output Modification Set Register 4 */


/** \brief 80, Port 32 Output Modification Clear Register 0 */


/** \brief 84, Port 32 Output Modification Clear Register 4 */


/** \brief 90, Port 32 Output Modification Set Register */


/** \brief 94, Port 32 Output Modification Clear Register */


/** \brief F8, Port 32 Access Enable Register 1 */


/** \brief FC, Port 32 Access Enable Register 0 */


/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_P_Registers_Cfg_P33
 * \{  */
/** \brief 0, Port 33 Output Register */


/** \brief 4, Port 33 Output Modification Register */


/** \brief 8, Port 33 Identification Register */


/** \brief 10, Port 33 Input/Output Control Register 0 */


/** \brief 14, Port 33 Input/Output Control Register 4 */


/** \brief 18, Port 33 Input/Output Control Register 8 */


/** \brief 1C, Port 33 Input/Output Control Register 12 */


/** \brief 24, Port 33 Input Register */


/** \brief 40, Port 33 Pad Driver Mode Register 0 */


/** \brief 44, Port 33 Pad Driver Mode Register 1 */


/** \brief 50, Port 33 Emergency Stop Register */


/** \brief 60, Port 33 Pin Function Decision Control Register */


/** \brief 64, Port 33 Pin Controller Select Register */


/** \brief 70, Port 33 Output Modification Set Register 0 */


/** \brief 74, Port 33 Output Modification Set Register 4 */


/** \brief 78, Port 33 Output Modification Set Register 8 */


/** \brief 7C, Port 33 Output Modification Set Register 12 */


/** \brief 80, Port 33 Output Modification Clear Register 0 */


/** \brief 84, Port 33 Output Modification Clear Register 4 */


/** \brief 88, Port 33 Output Modification Clear Register 8 */


/** \brief 8C, Port 33 Output Modification Clear Register 12 */


/** \brief 90, Port 33 Output Modification Set Register */


/** \brief 94, Port 33 Output Modification Clear Register */


/** \brief F8, Port 33 Access Enable Register 1 */


/** \brief FC, Port 33 Access Enable Register 0 */


/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_P_Registers_Cfg_P34
 * \{  */
/** \brief 0, Port 34 Output Register */


/** \brief 4, Port 34 Output Modification Register */


/** \brief 8, Port 34 Identification Register */


/** \brief 10, Port 34 Input/Output Control Register 0 */


/** \brief 14, Port 34 Input/Output Control Register 4 */


/** \brief 24, Port 34 Input Register */


/** \brief 40, Port 34 Pad Driver Mode Register 0 */


/** \brief 50, Port 34 Emergency Stop Register */


/** \brief 60, Port 34 Pin Function Decision Control Register */


/** \brief 64, Port 34 Pin Controller Select Register */


/** \brief 70, Port 34 Output Modification Set Register 0 */


/** \brief 74, Port 34 Output Modification Set Register 4 */


/** \brief 80, Port 34 Output Modification Clear Register 0 */


/** \brief 84, Port 34 Output Modification Clear Register 4 */


/** \brief 90, Port 34 Output Modification Set Register */


/** \brief 94, Port 34 Output Modification Clear Register */


/** \brief F8, Port 34 Access Enable Register 1 */


/** \brief FC, Port 34 Access Enable Register 0 */


/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_P_Registers_Cfg_P40
 * \{  */
/** \brief 0, Port 40 Output Register */


/** \brief 4, Port 40 Output Modification Register */


/** \brief 8, Port 40 Identification Register */


/** \brief 10, Port 40 Input/Output Control Register 0 */


/** \brief 14, Port 40 Input/Output Control Register 4 */


/** \brief 18, Port 40 Input/Output Control Register 8 */


/** \brief 1C, Port 40 Input/Output Control Register 12 */


/** \brief 24, Port 40 Input Register */


/** \brief 40, Port 40 Pad Driver Mode Register 0 */


/** \brief 44, Port 40 Pad Driver Mode Register 1 */


/** \brief 50, Port 40 Emergency Stop Register */


/** \brief 60, Port 40 Pin Function Decision Control Register */


/** \brief 64, Port 40 Pin Controller Select Register */


/** \brief 70, Port 40 Output Modification Set Register 0 */


/** \brief 74, Port 40 Output Modification Set Register 4 */


/** \brief 78, Port 40 Output Modification Set Register 8 */


/** \brief 7C, Port 40 Output Modification Set Register 12 */


/** \brief 80, Port 40 Output Modification Clear Register 0 */


/** \brief 84, Port 40 Output Modification Clear Register 4 */


/** \brief 88, Port 40 Output Modification Clear Register 8 */


/** \brief 8C, Port 40 Output Modification Clear Register 12 */


/** \brief 90, Port 40 Output Modification Set Register */


/** \brief 94, Port 40 Output Modification Clear Register */


/** \brief F8, Port 40 Access Enable Register 1 */


/** \brief FC, Port 40 Access Enable Register 0 */


/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_P_Registers_Cfg_P41
 * \{  */
/** \brief 0, Port 41 Output Register */


/** \brief 4, Port 41 Output Modification Register */


/** \brief 8, Port 41 Identification Register */


/** \brief 10, Port 41 Input/Output Control Register 0 */


/** \brief 14, Port 41 Input/Output Control Register 4 */


/** \brief 18, Port 41 Input/Output Control Register 8 */


/** \brief 24, Port 41 Input Register */


/** \brief 40, Port 41 Pad Driver Mode Register 0 */


/** \brief 44, Port 41 Pad Driver Mode Register 1 */


/** \brief 50, Port 41 Emergency Stop Register */


/** \brief 60, Port 41 Pin Function Decision Control Register */


/** \brief 64, Port 41 Pin Controller Select Register */


/** \brief 70, Port 41 Output Modification Set Register 0 */


/** \brief 74, Port 41 Output Modification Set Register 4 */


/** \brief 78, Port 41 Output Modification Set Register 8 */


/** \brief 80, Port 41 Output Modification Clear Register 0 */


/** \brief 84, Port 41 Output Modification Clear Register 4 */


/** \brief 88, Port 41 Output Modification Clear Register 8 */


/** \brief 90, Port 41 Output Modification Set Register */


/** \brief 94, Port 41 Output Modification Clear Register */


/** \brief F8, Port 41 Access Enable Register 1 */


/** \brief FC, Port 41 Access Enable Register 0 */



/** \}  */

/******************************************************************************/

/******************************************************************************/


#line 59 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\_Impl\\IfxPort_cfg.h"

/******************************************************************************/
/*-----------------------------------Macros-----------------------------------*/
/******************************************************************************/

/** \brief Port count              \ingroup IfxLld_port_cfg
 */




/******************************************************************************/
/*-------------------------------Enumerations---------------------------------*/
/******************************************************************************/

/** \brief List of the available Port resources
 */
typedef enum
{
    IfxPort_Index_00   = 0,  /**< \brief PORT 00 */
    IfxPort_Index_01   = 1,  /**< \brief PORT 01 */
    IfxPort_Index_02   = 2,  /**< \brief PORT 02 */
    IfxPort_Index_10   = 10, /**< \brief PORT 10 */
    IfxPort_Index_11   = 11, /**< \brief PORT 11 */
    IfxPort_Index_12   = 12, /**< \brief PORT 12 */
    IfxPort_Index_13   = 13, /**< \brief PORT 13 */
    IfxPort_Index_14   = 14, /**< \brief PORT 14 */
    IfxPort_Index_15   = 15, /**< \brief PORT 15 */
    IfxPort_Index_20   = 20, /**< \brief PORT 20 */
    IfxPort_Index_21   = 21, /**< \brief PORT 21 */
    IfxPort_Index_22   = 22, /**< \brief PORT 22 */
    IfxPort_Index_23   = 23, /**< \brief PORT 23 */
    IfxPort_Index_24   = 24, /**< \brief PORT 24 */
    IfxPort_Index_25   = 25, /**< \brief PORT 25 */
    IfxPort_Index_26   = 26, /**< \brief PORT 26 */
    IfxPort_Index_30   = 30, /**< \brief PORT 30 */
    IfxPort_Index_31   = 31, /**< \brief PORT 31 */
    IfxPort_Index_32   = 32, /**< \brief PORT 32 */
    IfxPort_Index_33   = 33, /**< \brief PORT 33 */
    IfxPort_Index_34   = 34, /**< \brief PORT 34 */
    IfxPort_Index_40   = 40, /**< \brief PORT 40 */
    IfxPort_Index_41   = 41, /**< \brief PORT 41 */
    IfxPort_Index_none = -1  /**< \brief none */
} IfxPort_Index;

/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/

/** \brief used by IfxPort_Esr_Masks table
 */
typedef struct
{
    Ifx_P *port;
    uint16 masks;
} IfxPort_Esr_Masks;

/******************************************************************************/
/*-------------------Global Exported Variables/Constants----------------------*/
/******************************************************************************/

extern const IfxPort_Esr_Masks  IfxPort_cfg_esrMasks[(23)];

extern const IfxModule_IndexMap IfxPort_cfg_indexMap[(23)];


#line 61 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Port\\Std\\IfxPort.h"

#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Scu\\Std\\IfxScuWdt.h"
/**
 * \file IfxScuWdt.h
 * \brief SCU  basic functionality
 * \ingroup IfxLld_Scu
 *
 * \version iLLD_1_0_1_15_0_1
 * \copyright Copyright (c) 2019 Infineon Technologies AG. All rights reserved.
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 * This file contains the APIs for SCU Watchdog and Endinit related functions.
 *
 * \defgroup IfxLld_Scu_Std_Wdt Wdt Basic Functionality
 * \ingroup IfxLld_Scu_Std
 * \defgroup IfxLld_Scu_Std_Wdt_Wdt_Configuration Watchdog Configuration functions
 * \ingroup IfxLld_Scu_Std_Wdt
 * \defgroup IfxLld_Scu_Std_Wdt_Wdt_Endinit Watchdog Endinit functions
 * \ingroup IfxLld_Scu_Std_Wdt
 * \defgroup IfxLld_Scu_Std_Wdt_Wdt_Operative Watchdog Operative functions
 * \ingroup IfxLld_Scu_Std_Wdt
 * \defgroup IfxLld_Scu_Std_Wdt_Wdt_Endinit_Usage How to use Endinit APIs?
 * \ingroup IfxLld_Scu_Std_Wdt
 */


















































































































































































































































































































































































































































































































































































































































































#line 62 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Port\\Std\\IfxPort.h"

#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\Service\\CpuGeneric\\_Utilities\\Ifx_Assert.h"
/**
 * \file Ifx_Assert.h
 * \brief Assert functions.
 * \ingroup library_srvsw_utilities_assert
 *
 * \copyright Copyright (c) 2013 Infineon Technologies AG. All rights reserved.
 *
 * $Date: 2014-02-28 14:15:42 GMT$
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * \defgroup library_srvsw_utilities_assert Assertion
 * This module implements assertion functions.
 * \ingroup library_srvsw_utilities
 *
 */













































#line 63 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Port\\Std\\IfxPort.h"

/******************************************************************************/
/*--------------------------------Enumerations--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Port_Std_Enum
 * \{ */
/** \brief The LVDS RX_DIS control function can be selected from the Port (default) or
 * HSCT module.declared in MODULE_PORTx.LPCRx
 */
typedef enum
{
    IfxPort_ControlledBy_port = 0,  /**< \brief port controlled by PORT Module */
    IfxPort_ControlledBy_hsct = 1   /**< \brief Port controlled by HSCT Module */
} IfxPort_ControlledBy;

/** \brief Ifx_P output modification modes definition.
 */
typedef enum
{
    IfxPort_InputMode_undefined    = -1,
    IfxPort_InputMode_noPullDevice = 0 << 3,
        IfxPort_InputMode_pullDown = 1U << 3,
        IfxPort_InputMode_pullUp   = 2U << 3  /**< \brief  */
} IfxPort_InputMode;

/** \brief specifies LVDS-M or LVDS-H mode as declare in Register MODULE_PORT.LPCRx.LVDSM
 */
typedef enum
{
    IfxPort_LvdsMode_high   = 0, /**< \brief LVDS-H Mode */
    IfxPort_LvdsMode_medium = 1  /**< \brief LVDS-M Mode */
} IfxPort_LvdsMode;

/** \brief Ifx_P input / output mode definition.
 *
 * \see Ifx_P.IOCR, IfxPort_setPinMode()
 */
typedef enum
{
    IfxPort_Mode_inputNoPullDevice      = 0,      /**< \brief Input, No pull device connected. */
    IfxPort_Mode_inputPullDown          = 8U,     /**< \brief Input, pull-down device connected. */
    IfxPort_Mode_inputPullUp            = 0x10U,  /**< \brief Input, pull-up device connected. */
    IfxPort_Mode_outputPushPullGeneral  = 0x80U,  /**< \brief Push-pull, General-purpose output */
    IfxPort_Mode_outputPushPullAlt1     = 0x88U,  /**< \brief Push-pull, Alternate output function 1. */
    IfxPort_Mode_outputPushPullAlt2     = 0x90U,  /**< \brief Push-pull, Alternate output function 2. */
    IfxPort_Mode_outputPushPullAlt3     = 0x98U,  /**< \brief Push-pull, Alternate output function 3. */
    IfxPort_Mode_outputPushPullAlt4     = 0xA0U,  /**< \brief Push-pull, Alternate output function 4. */
    IfxPort_Mode_outputPushPullAlt5     = 0xA8U,  /**< \brief Push-pull, Alternate output function 5. */
    IfxPort_Mode_outputPushPullAlt6     = 0xB0U,  /**< \brief Push-pull, Alternate output function 6. */
    IfxPort_Mode_outputPushPullAlt7     = 0xB8U,  /**< \brief Push-pull, Alternate output function 7. */
    IfxPort_Mode_outputOpenDrainGeneral = 0xC0U,  /**< \brief Open-drain, General-purpose output. */
    IfxPort_Mode_outputOpenDrainAlt1    = 0xC8U,  /**< \brief Open-drain, Alternate output function 1. */
    IfxPort_Mode_outputOpenDrainAlt2    = 0xD0U,  /**< \brief Open-drain, Alternate output function 2. */
    IfxPort_Mode_outputOpenDrainAlt3    = 0xD8U,  /**< \brief Open-drain, Alternate output function 3. */
    IfxPort_Mode_outputOpenDrainAlt4    = 0xE0U,  /**< \brief Open-drain, Alternate output function 4. */
    IfxPort_Mode_outputOpenDrainAlt5    = 0xE8U,  /**< \brief Open-drain, Alternate output function 5. */
    IfxPort_Mode_outputOpenDrainAlt6    = 0xF0U,  /**< \brief Open-drain, Alternate output function 6. */
    IfxPort_Mode_outputOpenDrainAlt7    = 0xF8U   /**< \brief Open-drain, Alternate output function 7. */
} IfxPort_Mode;

/** \brief Pin output alternate index
 */
typedef enum
{
    IfxPort_OutputIdx_general  = 0x10U << 3,
        IfxPort_OutputIdx_alt1 = 0x11U << 3,
        IfxPort_OutputIdx_alt2 = 0x12U << 3,
        IfxPort_OutputIdx_alt3 = 0x13U << 3,
        IfxPort_OutputIdx_alt4 = 0x14U << 3,
        IfxPort_OutputIdx_alt5 = 0x15U << 3,
        IfxPort_OutputIdx_alt6 = 0x16U << 3,
        IfxPort_OutputIdx_alt7 = 0x17U << 3
} IfxPort_OutputIdx;

/** \brief Pin output mode definition
 */
typedef enum
{
    IfxPort_OutputMode_pushPull      = 0x10U << 3,
        IfxPort_OutputMode_openDrain = 0x18U << 3,
        IfxPort_OutputMode_none      = 0
} IfxPort_OutputMode;

/** \brief Pad driver mode definition (strength and slew rate).
 *
 * \see Ifx_P.PDR, IfxPort_setPinPadDriver()
 */
typedef enum
{
    IfxPort_PadDriver_cmosAutomotiveSpeed1 = 0,  /**< \brief Speed grade 1. */
    IfxPort_PadDriver_cmosAutomotiveSpeed2 = 1,  /**< \brief Speed grade 2. */
    IfxPort_PadDriver_cmosAutomotiveSpeed3 = 2,  /**< \brief Speed grade 3. */
    IfxPort_PadDriver_cmosAutomotiveSpeed4 = 3,  /**< \brief Speed grade 4. */
    IfxPort_PadDriver_ttlSpeed1            = 8,  /**< \brief Speed grade 1. */
    IfxPort_PadDriver_ttlSpeed2            = 9,  /**< \brief Speed grade 2. */
    IfxPort_PadDriver_ttlSpeed3            = 10, /**< \brief Speed grade 3. */
    IfxPort_PadDriver_ttlSpeed4            = 11, /**< \brief Speed grade 4. */
    IfxPort_PadDriver_ttl3v3Speed1         = 12, /**< \brief 3.3v Pad supply speed1 */
    IfxPort_PadDriver_ttl3v3Speed2         = 13, /**< \brief 3.3v Pad supply speed2 */
    IfxPort_PadDriver_ttl3v3Speed3         = 14, /**< \brief 3.3v Pad supply speed3 */
    IfxPort_PadDriver_ttl3v3Speed4         = 15  /**< \brief 3.3v Pad supply speed4 */
} IfxPort_PadDriver;

/** \brief MODULE_PORTx.LPCRx.B.PS1.Selects between 5v and 3.3v on Vext supply for the LVDSM pair
 */
typedef enum
{
    IfxPort_PadSupply_3v = 0,  /**< \brief select,3.3v */
    IfxPort_PadSupply_5v = 1   /**< \brief select,5V */
} IfxPort_PadSupply;

/** \brief enable analog/digital mode for port pin, as Defined in MODULE_PORTx.PDISC
 */
typedef enum
{
    IfxPort_PinFunctionMode_digital = 0,  /**< \brief Pad Pn.x is enabled and can be selected for digital function */
    IfxPort_PinFunctionMode_analog  = 1   /**< \brief Pad Pn.x is enabled and can be selected for analog function */
} IfxPort_PinFunctionMode;

/** \brief Ifx_P output modification modes definition.
 *
 * \see Ifx_P.OMR, IfxPort_setPinState()
 */
typedef enum
{
    IfxPort_State_notChanged = (0 << 16) | (0 << 0),  /**< \brief Ifx_P pin is left unchanged. */
    IfxPort_State_high       = (0 << 16) | (1U << 0), /**< \brief Ifx_P pin is set to high. */
    IfxPort_State_low        = (1U << 16) | (0 << 0), /**< \brief Ifx_P pin is set to low. */
    IfxPort_State_toggled    = (1U << 16) | (1U << 0) /**< \brief Ifx_P pin is toggled. */
} IfxPort_State;

/** \} */

/** \brief Enable/DIsable LVDS direction TX or RX
 */
typedef enum
{
    IfxPort_LvdsDirection_rx = 0,  /**< \brief LVDS direction RX */
    IfxPort_LvdsDirection_tx = 1   /**< \brief LVDS direction TX */
} IfxPort_LvdsDirection;

/** \brief Enable/DIsable LVDS Path.declared in MODULE_PORTx.LPCRx.TX_EN and MODULE_PORTx.LPCRx.RX_EN
 */
typedef enum
{
    IfxPort_LvdsPath_enable  = 0, /**< \brief LVDS enabled */
    IfxPort_LvdsPath_disable = 1  /**< \brief LVDS disabled */
} IfxPort_LvdsPath;

/** \brief Specifies whether LVDS pull down resistor must be enabled/disabled as declared in Register MODULE_PORT.LPCRx.PWDPD
 */
typedef enum
{
    IfxPort_LvdsPullDown_disable = 0,  /**< \brief Disable Pull Down resistor */
    IfxPort_LvdsPullDown_enable  = 1   /**< \brief Enable Pull Down resistor */
} IfxPort_LvdsPullDown;

/** \brief Specifies LVDS-Termination mode as declare in Register MODULE_PORT.LPCRx.TERM
 */
typedef enum
{
    IfxPort_LvdsTerminationMode_external = 0,  /**< \brief Termination Mode External */
    IfxPort_LvdsTerminationMode_internal = 1   /**< \brief Termination Mode Internal */
} IfxPort_LvdsTerminationMode;

/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Port_Std_DataStructures
 * \{ */
/** \brief To Configure LVDS mode
 */
typedef struct
{
    IfxPort_LvdsMode     lvdsMode;                   /**< \brief specifies LVDS-M or LVDS-H mode */
    IfxPort_ControlledBy enablePortControlled;       /**< \brief specifies whether LVDS is controlled by PORT or HSCT */
    IfxPort_PadSupply    padSupply;                  /**< \brief specify supply voltage */
} IfxPort_LvdsConfig;

/** \brief Defines a pin
 */
typedef struct
{
    Ifx_P *port;
    uint8  pinIndex;
} IfxPort_Pin;

/** \brief To configure pins
 */
typedef struct
{
    Ifx_P            *port;
    uint8             pinIndex;
    IfxPort_OutputIdx mode;
    IfxPort_PadDriver padDriver;
} IfxPort_Pin_Config;

/** \} */

/** \addtogroup IfxLld_Port_Std_SinglePin
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Return the port state.
 * \param port Pointer to the port which should be accessed.
 * \param pinIndex Specifies the pin for which the state should be returned.
 * \return Returns TRUE the pin is high; FALSE the pin is low
 *
 * Coding example:
 * \code
 *    if( IfxPort_getPinState(&MODULE_P33, 0) ) {
 *      // ...
 *    }
 * \endcode
 *
 */
static inline boolean IfxPort_getPinState(Ifx_P *port, uint8 pinIndex);

/** \brief set analog/digital mode for pin
 * \param port Pointer to Port register space
 * \param pinIndex specifies the pin index
 * \param mode set analog/digital mode
 * \return None
 */
static inline void IfxPort_setPinFunctionMode(Ifx_P *port, uint8 pinIndex, IfxPort_PinFunctionMode mode);

/** \brief Set the port output.
 * \param port Pointer to the port which should be accessed.
 * \param pinIndex Specifies the pin to be set.
 * \return None
 *
 * Coding example:
 * \code
 * IfxPort_setPinHigh(&MODULE_P33, 0);
 * \endcode
 *
 * \see IfxPort_setPinState(), IfxPort_setPinLow(), IfxPort_togglePin()
 *
 */
static inline void IfxPort_setPinHigh(Ifx_P *port, uint8 pinIndex);

/** \brief Reset the port output.
 * \param port Pointer to the port which should be accessed.
 * \param pinIndex Specifies the pin to be reset.
 * \return None
 *
 * Coding example:
 * \code
 * IfxPort_setPinLow(&MODULE_P33, 0);
 * \endcode
 *
 * \see IfxPort_setPinState(), IfxPort_setPinHigh(), IfxPort_togglePin()
 *
 */
static inline void IfxPort_setPinLow(Ifx_P *port, uint8 pinIndex);

/** \brief Configure the port input / output mode.
 * \param port Pointer to the port which should be accessed.
 * \param pinIndex Specifies the pin to be configured.
 * \param mode Specifies the port pin mode.
 * \return None
 *
 * Coding example:
 * \code
 *     IfxPort_setPinModeInput(&MODULE_P33, 0, IfxPort_InputMode_pullUp);
 * \endcode
 *
 */
static inline void IfxPort_setPinModeInput(Ifx_P *port, uint8 pinIndex, IfxPort_InputMode mode);

/** \brief Configure the port input / output mode.
 * \param port Pointer to the port which should be accessed.
 * \param pinIndex Specifies the pin to be configured.
 * \param mode Specifies the port pin mode.
 * \param index Specifies the alternate (or general purpose) output channel.
 * \return None
 *
 * Coding example:
 * \code
 *     IfxPort_setPinModeOutput(&MODULE_P33, 0, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
 * \endcode
 *
 */
static inline void IfxPort_setPinModeOutput(Ifx_P *port, uint8 pinIndex, IfxPort_OutputMode mode, IfxPort_OutputIdx index);

/** \brief Set / Resets / Toggle the port output.
 * \param port Pointer to the port which should be accessed.
 * \param pinIndex Specifies the pin to modify.
 * \param action Specifies the action: set, reset, toggle.
 * \return None
 *
 * Coding example:
 * \code
 * IfxPort_setPinState(&MODULE_P33, 0, IfxPort_State_toggled);
 * IfxPort_setPinState(&MODULE_P33, 0, IfxPort_State_toggled);
 * IfxPort_setPinState(&MODULE_P33, 0, IfxPort_State_toggled);
 * \endcode
 *
 */
static inline void IfxPort_setPinState(Ifx_P *port, uint8 pinIndex, IfxPort_State action);

/** \brief Toggle the port output.
 * \param port Pointer to the port which should be accessed.
 * \param pinIndex Specifies the pin to be toggled.
 * \return None
 *
 * Coding example:
 * \code
 * IfxPort_togglePin(&MODULE_P33, 0);
 * \endcode
 *
 * \see IfxPort_setPinState(), IfxPort_setPinLow(), IfxPort_setPinHigh()
 *
 */
static inline void IfxPort_togglePin(Ifx_P *port, uint8 pinIndex);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Disable the emergency stop function.
 * This function disables the emergency stop function. A check is done on port functionality.
 * \param port Pointer to the port which should be accessed.
 * \param pinIndex Specifies the pin for which the emergency stop function should be disabled.
 * \return Returns TRUE if the emergency stop function has been disabled; FALSE if the emergency stop function could not be disabled
 *
 * Coding example:
 * /code
 *     if( !IfxPort_disableEmergencyStop(&MODULE_P33, 0) )
 *     {
 *         // failed to disable emergency stop for P33.0
 *     }
 * /endcode
 *
 * \see IfxPort_disableEmergencyStop(), IfxPort_resetESR()
 *
 */
extern boolean IfxPort_disableEmergencyStop(Ifx_P *port, uint8 pinIndex);

/** \brief Enable the emergency stop function.
 * This function enables the emergency stop function. A check is done on port functionality.
 * \param port Pointer to the port which should be accessed.
 * \param pinIndex Specifies the pin for which the emergency stop function should be enabled.
 * \return Returns TRUE if the emergency stop function has been enabled; FALSE if the emergency stop function could not be enabled
 *
 * Coding example:
 * \code
 *     if( !IfxPort_enableEmergencyStop(&MODULE_P33, 0) ) {
 *       // failed to enable emergency stop for P33.0
 *     }
 * \endcode
 *
 * \see IfxPort_disableEmergencyStop(), IfxPort_setESR()
 *
 */
extern boolean IfxPort_enableEmergencyStop(Ifx_P *port, uint8 pinIndex);

/** \brief Configure the port input / output mode.
 * Also Configures the P40/P41 Port for digital functionality
 * which bydefault support analog functionality.
 * \param port Pointer to the port which should be accessed.
 * \param pinIndex Specifies the pin to be configured.
 * \param mode Specifies the port pin mode.
 * \return None
 *
 * Coding example:
 * \code
 *     IfxPort_setPinMode(&MODULE_P33, 0, IfxPort_Mode_outputPushPullGeneral);
 * \endcode
 *
 */
extern void IfxPort_setPinMode(Ifx_P *port, uint8 pinIndex, IfxPort_Mode mode);

/** \brief set lvds mode
 * \param port pointer to Port Register space
 * \param pinIndex specifies pin index
 * \param pinMode specifes the mode of pin
 * \param lvds config LVDS
 * \return None
 */
extern void IfxPort_setPinModeLVDS(Ifx_P *port, uint8 pinIndex, IfxPort_Mode pinMode, IfxPort_LvdsConfig *lvds);

/** \brief Configure the pad driver mode.
 * \param port Pointer to the port which should be accessed.
 * \param pinIndex Specifies the pin for which the mode will be set.
 * \param padDriver Specifies the driver mode.
 * \return None
 *
 * Coding example:
 * \code
 * // enable strong 3.3V driver
 * IfxPort_setPinPadDriver(&MODULE_P33, 0, IfxPort_PadDriver_cmosAutomotiveSpeed1);
 * \endcode
 *
 */
extern void IfxPort_setPinPadDriver(Ifx_P *port, uint8 pinIndex, IfxPort_PadDriver padDriver);

/** \brief Enable the Pin Controller Selection.
 * \param port Pointer to the port which should be accessed.
 * \param pinIndex Specifies the pin for which the mode has to be set.
 * \return None
 */
extern void IfxPort_setPinControllerSelection(Ifx_P *port, uint8 pinIndex);

/** \brief Disable the Pin Controller Selection.
 * \param port Pointer to the port which should be accessed.
 * \param pinIndex Specifies the pin for which the mode has to be cleared.
 * \return None
 */
extern void IfxPort_resetPinControllerSelection(Ifx_P *port, uint8 pinIndex);

/** \} */

/** \addtogroup IfxLld_Port_Std_PortGroup
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Return the port group state
 * \param port Pointer to the port which should be accessed.
 * \param pinIndex start at the given pin
 * \param mask selects the pins which should be read (starting from pinIndex)
 * \return Returns the selected pin values
 *
 * Coding example:
 * \code
 * // read the current value of P33[7:0]
 * uint16 value = IfxPort_getGroupState(&MODULE_P33, 0, 0xff);
 * \endcode
 *
 */
static inline uint32 IfxPort_getGroupState(Ifx_P *port, uint8 pinIndex, uint16 mask);

/** \brief Set the port group state.
 * \param port Pointer to the port which should be accessed.
 * \param pinIndex start at the given pin
 * \param mask selects the pins which should be modified (starting from pinIndex)
 * \param data specifies the value which should be set
 * \return None
 *
 * Coding example:
 * \code
 * // configure P33.[7:0] as GPIO outputs
 * IfxPort_setGroupModeOutput(&MODULE_P33, 0, 0xff, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
 *
 * // set initial value
 * IfxPort_setGroupState(&MODULE_P33, 0, 0xff, 0x42);
 * \endcode
 *
 */
static inline void IfxPort_setGroupState(Ifx_P *port, uint8 pinIndex, uint16 mask, uint16 data);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Returns the module address of the selected Port module
 * \param port Pointer to PORT module registers
 * \return PORT module register address
 */
extern Ifx_P *IfxPort_getAddress(IfxPort_Index port);

/** \brief Return port index within IfxModule_IndexMap (defined in IfxPort_cfg.c)
 * \param port Pointer to the port for which the index number in IfxModule_IndexMap should be retrieved.
 * \return port index of IfxModule_IndexMap. return -1 in case of unknown port index.
 */
extern IfxPort_Index IfxPort_getIndex(Ifx_P *port);

/** \brief Set pin modes to input at the pin location specified by '1' by the mask
 * \param port Pointer to the port which should be accessed.
 * \param pinIndex start at the given pin
 * \param mask selects the pins which should be modified (starting from pinIndex)
 * \param mode Specifies the port pin mode.
 * \return None
 *
 * Coding example:
 * \code
 * // configure P33.[7:0] as GPIO inputs with Pull-Down enabled
 * IfxPort_setGroupModeInput(&MODULE_P33, 0, 0xff, IfxPort_InputMode_pullDown);
 *  \endcode
 *
 */
extern void IfxPort_setGroupModeInput(Ifx_P *port, uint8 pinIndex, uint16 mask, IfxPort_InputMode mode);

/** \brief Set pin modes to output at the pin location specified by '1' by the mask starting at pinIndex
 * \param port Pointer to the port which should be accessed.
 * \param pinIndex start at the given pin
 * \param mask selects the pins which should be modified (starting from pinIndex)
 * \param mode Specifies the port pin mode.
 * \param index Specifies the alternate (or general purpose) output channel.
 * \return None
 *
 * Coding example:
 * \code
 * // configure P33.[7:0] as GPIO outputs
 * IfxPort_setGroupModeOutput(&MODULE_P33, 0, 0xff, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
 * \endcode
 *
 */
extern void IfxPort_setGroupModeOutput(Ifx_P *port, uint8 pinIndex, uint16 mask, IfxPort_OutputMode mode, IfxPort_OutputIdx index);

/** \brief Set pad driver strength at the pin location specified by '1' by the mask
 * \param port Pointer to the port which should be accessed.
 * \param pinIndex start at the given pin
 * \param mask selects the pins which should be modified (starting from pinIndex)
 * \param padDriver Specifies the pad driver strength.
 * \return None
 *
 * Coding example:
 * \code
 * // configure P33.[7:0] to use CMOS pad driver with speed 1
 * IfxPort_setGroupPadDriver(&MODULE_P33, 0, 0xff, IfxPort_PadDriver_cmosAutomotiveSpeed1);
 * \endcode
 *
 */
extern void IfxPort_setGroupPadDriver(Ifx_P *port, uint8 pinIndex, uint16 mask, IfxPort_PadDriver padDriver);

/** \} */

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Disable the emergency stop function.
 * This function disables the emergency stop function. No check is done on port functionality.
 * \param port Pointer to the port which should be accessed.
 * \param pinIndex Specifies the pin for which the emergency stop function should be disabled.
 * \return None
 *
 * \see IfxPort_disableEmergencyStop()
 *
 */
extern void IfxPort_resetESR(Ifx_P *port, uint8 pinIndex);

/** \brief Enable the emergency stop function.
 * This function enables the emergency stop function. No check is done on port functionality.
 * \param port Pointer to the port which should be accessed.
 * \param pinIndex Specifies the pin for which the emergency stop function should be enabled.
 * \return None
 *
 * \see IfxPort_enableEmergencyStop()
 *
 */
extern void IfxPort_setESR(Ifx_P *port, uint8 pinIndex);

/**
 * \param port Pointer to the port which should be accessed.
 * \param pinIndex Specifies the pin for which the mode has to be set.
 * \param mode Selects the controller for the port pin(Tricore,EVADC,GETH,SCR etc)
 * 0-> normal function
 * 1-> Alternate functionality(SCR pin,EVADC PDD,GETH RGMII/MII etc)
 * \return None
 */
extern void IfxPort_modifyPinControllerSelection(Ifx_P *port, uint8 pinIndex, boolean mode);

/******************************************************************************/
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

static inline uint32 IfxPort_getGroupState(Ifx_P *port, uint8 pinIndex, uint16 mask)
{
    return (uint32)((port->IN.U) >> (pinIndex)) & mask;
}


static inline boolean IfxPort_getPinState(Ifx_P *port, uint8 pinIndex)
{
    return (__getbit(&port->IN.U, pinIndex) != 0) ? (1u) : (0u);
}


static inline void IfxPort_setGroupState(Ifx_P *port, uint8 pinIndex, uint16 mask, uint16 data)
{
    port->OUT.U = (port->OUT.U & ~((uint32)(mask)) << pinIndex) | (data << pinIndex);
}


static inline void IfxPort_setPinFunctionMode(Ifx_P *port, uint8 pinIndex, IfxPort_PinFunctionMode mode)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();

    IfxScuWdt_clearCpuEndinit(passwd);
    port->PDISC.U |= (mode << pinIndex);
    IfxScuWdt_setCpuEndinit(passwd);
}


static inline void IfxPort_setPinHigh(Ifx_P *port, uint8 pinIndex)
{
    IfxPort_setPinState(port, pinIndex, IfxPort_State_high);
}


static inline void IfxPort_setPinLow(Ifx_P *port, uint8 pinIndex)
{
    IfxPort_setPinState(port, pinIndex, IfxPort_State_low);
}


static inline void IfxPort_setPinModeInput(Ifx_P *port, uint8 pinIndex, IfxPort_InputMode mode)
{
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)mode);
}


static inline void IfxPort_setPinModeOutput(Ifx_P *port, uint8 pinIndex, IfxPort_OutputMode mode, IfxPort_OutputIdx index)
{
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)(index | mode));
}


static inline void IfxPort_setPinState(Ifx_P *port, uint8 pinIndex, IfxPort_State action)
{
    port->OMR.U = action << pinIndex;
}


static inline void IfxPort_togglePin(Ifx_P *port, uint8 pinIndex)
{
    IfxPort_setPinState(port, pinIndex, IfxPort_State_toggled);
}



#line 51 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\_PinMap\\IfxScu_PinMap.h"

/** \addtogroup IfxLld_Scu_pinmap
 * \{ */

/** \brief EVR Wakeup pin mapping structure */
typedef const struct
{
    Ifx_SCU*          module;    /**< \brief Base address */
    IfxPort_Pin       pin;       /**< \brief Port pin */
    Ifx_RxSel         select;    /**< \brief Input multiplexer value */
} IfxScu_Evrwup_In;

/** \brief External Request pin mapping structure */
typedef const struct
{
    Ifx_SCU*          module;    /**< \brief Base address */
    uint8             channelId; /**< \brief ERU Channel ID */
    IfxPort_Pin       pin;       /**< \brief Port pin */
    Ifx_RxSel         select;    /**< \brief Input multiplexer value */
} IfxScu_Req_In;

/** \brief DCDC Sync pin mapping structure */
typedef const struct
{
    Ifx_SCU*          module;    /**< \brief Base address */
    IfxPort_Pin       pin;       /**< \brief Port pin */
    IfxPort_OutputIdx select;    /**< \brief Port control code */
} IfxScu_Dcdcsync_Out;

/** \brief Emergency Stop pin mapping structure */
typedef const struct
{
    Ifx_SCU*          module;    /**< \brief Base address */
    IfxPort_Pin       pin;       /**< \brief Port pin */
    Ifx_RxSel         select;    /**< \brief Input multiplexer value */
} IfxScu_Emgstop_In;

/** \brief Watchdog Timer Lock pin mapping structure */
typedef const struct
{
    Ifx_SCU*          module;    /**< \brief Base address */
    IfxPort_Pin       pin;       /**< \brief Port pin */
    IfxPort_OutputIdx select;    /**< \brief Port control code */
} IfxScu_Wdtlck_Out;

/** \brief External Clock pin mapping structure */
typedef const struct
{
    Ifx_SCU*          module;    /**< \brief Base address */
    IfxPort_Pin       pin;       /**< \brief Port pin */
    IfxPort_OutputIdx select;    /**< \brief Port control code */
} IfxScu_Extclk_Out;

extern IfxScu_Emgstop_In IfxScu_EMGSTOPA_P33_8_IN;  /**< \brief Emergency stop Port Pin A input request */
extern IfxScu_Emgstop_In IfxScu_EMGSTOPB_P21_2_IN;  /**< \brief Emergency stop Port Pin B input request */
extern IfxScu_Extclk_Out IfxScu_EXTCLK0_P00_15_OUT;  /**< \brief External Clock 0 */
extern IfxScu_Extclk_Out IfxScu_EXTCLK0_P23_1_OUT;  /**< \brief External Clock 0 */
extern IfxScu_Extclk_Out IfxScu_EXTCLK1_P00_13_OUT;  /**< \brief External Clock 1 */
extern IfxScu_Extclk_Out IfxScu_EXTCLK1_P11_12_OUT;  /**< \brief External Clock 1 */
extern IfxScu_Extclk_Out IfxScu_EXTCLK1_P32_4_OUT;  /**< \brief External Clock 1 */
extern IfxScu_Req_In IfxScu_REQ0A_P15_4_IN;  /**< \brief ERU Channel 0 inputs 0 to 5 (0 is the LSB and 5 is the MSB) */
extern IfxScu_Req_In IfxScu_REQ0C_P10_7_IN;  /**< \brief ERU Channel 0 inputs 0 to 5 (0 is the LSB and 5 is the MSB) */
extern IfxScu_Req_In IfxScu_REQ1A_P14_3_IN;  /**< \brief ERU Channel 1 inputs 0 to 5 (0 is the LSB and 5 is the MSB) */
extern IfxScu_Req_In IfxScu_REQ1C_P10_8_IN;  /**< \brief ERU Channel 1 inputs 0 to 5 (0 is the LSB and 5 is the MSB) */
extern IfxScu_Req_In IfxScu_REQ2A_P10_2_IN;  /**< \brief ERU Channel 2 inputs 0 to 5 (0 is the LSB and 5 is the MSB) */
extern IfxScu_Req_In IfxScu_REQ2B_P02_1_IN;  /**< \brief ERU Channel 2 inputs 0 to 5 (0 is the LSB and 5 is the MSB) */
extern IfxScu_Req_In IfxScu_REQ2C_P00_4_IN;  /**< \brief ERU Channel 2 inputs 0 to 5 (0 is the LSB and 5 is the MSB) */
extern IfxScu_Req_In IfxScu_REQ3A_P10_3_IN;  /**< \brief ERU Channel 3 inputs 0 to 5 (0 is the LSB and 5 is the MSB) */
extern IfxScu_Req_In IfxScu_REQ3B_P14_1_IN;  /**< \brief ERU Channel 3 inputs 0 to 5 (0 is the LSB and 5 is the MSB) */
extern IfxScu_Req_In IfxScu_REQ3C_P02_0_IN;  /**< \brief ERU Channel 3 inputs 0 to 5 (0 is the LSB and 5 is the MSB) */
extern IfxScu_Req_In IfxScu_REQ4A_P33_7_IN;  /**< \brief ERU Channel 4 inputs 0 to 5 (0 is the LSB and 5 is the MSB) */
extern IfxScu_Req_In IfxScu_REQ4D_P15_5_IN;  /**< \brief ERU Channel 4 inputs 0 to 5 (0 is the LSB and 5 is the MSB) */
extern IfxScu_Req_In IfxScu_REQ5A_P15_8_IN;  /**< \brief ERU Channel 5 inputs 0 to 5 (0 is the LSB and 5 is the MSB) */
extern IfxScu_Req_In IfxScu_REQ6A_P20_0_IN;  /**< \brief ERU Channel 6 inputs 0 to 5 (0 is the LSB and 5 is the MSB) */
extern IfxScu_Req_In IfxScu_REQ6D_P11_10_IN;  /**< \brief ERU Channel 6 inputs 0 to 5 (0 is the LSB and 5 is the MSB) */
extern IfxScu_Req_In IfxScu_REQ7A_P20_9_IN;  /**< \brief ERU Channel 7 inputs 0 to 5 (0 is the LSB and 5 is the MSB) */
extern IfxScu_Req_In IfxScu_REQ7C_P15_1_IN;  /**< \brief ERU Channel 7 inputs 0 to 5 (0 is the LSB and 5 is the MSB) */

/** \brief Table dimensions */







/** \brief IfxScu_Emgstop_In table */
extern const IfxScu_Emgstop_In *IfxScu_Emgstop_In_pinTable[1][2];

/** \brief IfxScu_Extclk_Out table */
extern const IfxScu_Extclk_Out *IfxScu_Extclk_Out_pinTable[1][5];

/** \brief IfxScu_Req_In table */
extern const IfxScu_Req_In *IfxScu_Req_In_pinTable[1][8][4];

/** \} */


#line 199 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Scu\\Std\\IfxScuCcu.h"

#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\Infra\\Sfr\\TC38A\\_Reg\\IfxSmu_reg.h"
/**
 * \file IfxSmu_reg.h
 * \brief
 * \copyright Copyright (c) 2020 Infineon Technologies AG. All rights reserved.
 *
 *
 * Version: TC38XA_UM_V1.5.0
 * Specification: TC3xx User Manual V1.5.0
 * MAY BE CHANGED BY USER [yes/no]: No
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * \defgroup IfxSfr_Smu_Registers_Cfg Smu address
 * \ingroup IfxSfr_Smu_Registers
 * 
 * \defgroup IfxSfr_Smu_Registers_Cfg_BaseAddress Base address
 * \ingroup IfxSfr_Smu_Registers_Cfg
 *
 * \defgroup IfxSfr_Smu_Registers_Cfg_Smu 2-SMU
 * \ingroup IfxSfr_Smu_Registers_Cfg
 *
 *
 */


/******************************************************************************/

#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\Infra\\Sfr\\TC38A\\_Reg\\IfxSmu_regdef.h"
/**
 * \file IfxSmu_regdef.h
 * \brief
 * \copyright Copyright (c) 2020 Infineon Technologies AG. All rights reserved.
 *
 *
 * Version: TC38XA_UM_V1.5.0
 * Specification: TC3xx User Manual V1.5.0
 * MAY BE CHANGED BY USER [yes/no]: No
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * \defgroup IfxSfr_Smu_Registers Smu Registers
 * \ingroup IfxSfr
 * 
 * \defgroup IfxSfr_Smu_Registers_Bitfields Bitfields
 * \ingroup IfxSfr_Smu_Registers
 * 
 * \defgroup IfxSfr_Smu_Registers_union Register unions
 * \ingroup IfxSfr_Smu_Registers
 * 
 * \defgroup IfxSfr_Smu_Registers_struct Memory map
 * \ingroup IfxSfr_Smu_Registers
 */


/******************************************************************************/

/******************************************************************************/

/******************************************************************************/

/******************************************************************************/


/** \addtogroup IfxSfr_Smu_Registers_Bitfields
 * \{  */
/** \brief SMU_core Access Enable Register 0 */
typedef struct _Ifx_SMU_ACCEN0_Bits
{
    Ifx_UReg_32Bit EN0:1;             /**< \brief [0:0] Access Enable for Master TAG ID 0 - EN0 (rw) */
    Ifx_UReg_32Bit EN1:1;             /**< \brief [1:1] Access Enable for Master TAG ID 1 - EN1 (rw) */
    Ifx_UReg_32Bit EN2:1;             /**< \brief [2:2] Access Enable for Master TAG ID 2 - EN2 (rw) */
    Ifx_UReg_32Bit EN3:1;             /**< \brief [3:3] Access Enable for Master TAG ID 3 - EN3 (rw) */
    Ifx_UReg_32Bit EN4:1;             /**< \brief [4:4] Access Enable for Master TAG ID 4 - EN4 (rw) */
    Ifx_UReg_32Bit EN5:1;             /**< \brief [5:5] Access Enable for Master TAG ID 5 - EN5 (rw) */
    Ifx_UReg_32Bit EN6:1;             /**< \brief [6:6] Access Enable for Master TAG ID 6 - EN6 (rw) */
    Ifx_UReg_32Bit EN7:1;             /**< \brief [7:7] Access Enable for Master TAG ID 7 - EN7 (rw) */
    Ifx_UReg_32Bit EN8:1;             /**< \brief [8:8] Access Enable for Master TAG ID 8 - EN8 (rw) */
    Ifx_UReg_32Bit EN9:1;             /**< \brief [9:9] Access Enable for Master TAG ID 9 - EN9 (rw) */
    Ifx_UReg_32Bit EN10:1;            /**< \brief [10:10] Access Enable for Master TAG ID 10 - EN10 (rw) */
    Ifx_UReg_32Bit EN11:1;            /**< \brief [11:11] Access Enable for Master TAG ID 11 - EN11 (rw) */
    Ifx_UReg_32Bit EN12:1;            /**< \brief [12:12] Access Enable for Master TAG ID 12 - EN12 (rw) */
    Ifx_UReg_32Bit EN13:1;            /**< \brief [13:13] Access Enable for Master TAG ID 13 - EN13 (rw) */
    Ifx_UReg_32Bit EN14:1;            /**< \brief [14:14] Access Enable for Master TAG ID 14 - EN14 (rw) */
    Ifx_UReg_32Bit EN15:1;            /**< \brief [15:15] Access Enable for Master TAG ID 15 - EN15 (rw) */
    Ifx_UReg_32Bit EN16:1;            /**< \brief [16:16] Access Enable for Master TAG ID 16 - EN16 (rw) */
    Ifx_UReg_32Bit EN17:1;            /**< \brief [17:17] Access Enable for Master TAG ID 17 - EN17 (rw) */
    Ifx_UReg_32Bit EN18:1;            /**< \brief [18:18] Access Enable for Master TAG ID 18 - EN18 (rw) */
    Ifx_UReg_32Bit EN19:1;            /**< \brief [19:19] Access Enable for Master TAG ID 19 - EN19 (rw) */
    Ifx_UReg_32Bit EN20:1;            /**< \brief [20:20] Access Enable for Master TAG ID 20 - EN20 (rw) */
    Ifx_UReg_32Bit EN21:1;            /**< \brief [21:21] Access Enable for Master TAG ID 21 - EN21 (rw) */
    Ifx_UReg_32Bit EN22:1;            /**< \brief [22:22] Access Enable for Master TAG ID 22 - EN22 (rw) */
    Ifx_UReg_32Bit EN23:1;            /**< \brief [23:23] Access Enable for Master TAG ID 23 - EN23 (rw) */
    Ifx_UReg_32Bit EN24:1;            /**< \brief [24:24] Access Enable for Master TAG ID 24 - EN24 (rw) */
    Ifx_UReg_32Bit EN25:1;            /**< \brief [25:25] Access Enable for Master TAG ID 25 - EN25 (rw) */
    Ifx_UReg_32Bit EN26:1;            /**< \brief [26:26] Access Enable for Master TAG ID 26 - EN26 (rw) */
    Ifx_UReg_32Bit EN27:1;            /**< \brief [27:27] Access Enable for Master TAG ID 27 - EN27 (rw) */
    Ifx_UReg_32Bit EN28:1;            /**< \brief [28:28] Access Enable for Master TAG ID 28 - EN28 (rw) */
    Ifx_UReg_32Bit EN29:1;            /**< \brief [29:29] Access Enable for Master TAG ID 29 - EN29 (rw) */
    Ifx_UReg_32Bit EN30:1;            /**< \brief [30:30] Access Enable for Master TAG ID 30 - EN30 (rw) */
    Ifx_UReg_32Bit EN31:1;            /**< \brief [31:31] Access Enable for Master TAG ID 31 - EN31 (rw) */
} Ifx_SMU_ACCEN0_Bits;

/** \brief SMU_core Access Enable Register 1 */
typedef struct _Ifx_SMU_ACCEN1_Bits
{
    Ifx_UReg_32Bit reserved_0:32;     /**< \brief [31:0] \internal Reserved */
} Ifx_SMU_ACCEN1_Bits;

/** \brief Alarm Debug Register */
typedef struct _Ifx_SMU_AD_Bits
{
    Ifx_UReg_32Bit DF0:1;             /**< \brief [0:0] Diagnosis flag for alarm 0 belonging to alarm group i. - DF0 (rh) */
    Ifx_UReg_32Bit DF1:1;             /**< \brief [1:1] Diagnosis flag for alarm 1 belonging to alarm group i. - DF1 (rh) */
    Ifx_UReg_32Bit DF2:1;             /**< \brief [2:2] Diagnosis flag for alarm 2 belonging to alarm group i. - DF2 (rh) */
    Ifx_UReg_32Bit DF3:1;             /**< \brief [3:3] Diagnosis flag for alarm 3 belonging to alarm group i. - DF3 (rh) */
    Ifx_UReg_32Bit DF4:1;             /**< \brief [4:4] Diagnosis flag for alarm 4 belonging to alarm group i. - DF4 (rh) */
    Ifx_UReg_32Bit DF5:1;             /**< \brief [5:5] Diagnosis flag for alarm 5 belonging to alarm group i. - DF5 (rh) */
    Ifx_UReg_32Bit DF6:1;             /**< \brief [6:6] Diagnosis flag for alarm 6 belonging to alarm group i. - DF6 (rh) */
    Ifx_UReg_32Bit DF7:1;             /**< \brief [7:7] Diagnosis flag for alarm 7 belonging to alarm group i. - DF7 (rh) */
    Ifx_UReg_32Bit DF8:1;             /**< \brief [8:8] Diagnosis flag for alarm 8 belonging to alarm group i. - DF8 (rh) */
    Ifx_UReg_32Bit DF9:1;             /**< \brief [9:9] Diagnosis flag for alarm 9 belonging to alarm group i. - DF9 (rh) */
    Ifx_UReg_32Bit DF10:1;            /**< \brief [10:10] Diagnosis flag for alarm 10 belonging to alarm group i. - DF10 (rh) */
    Ifx_UReg_32Bit DF11:1;            /**< \brief [11:11] Diagnosis flag for alarm 11 belonging to alarm group i. - DF11 (rh) */
    Ifx_UReg_32Bit DF12:1;            /**< \brief [12:12] Diagnosis flag for alarm 12 belonging to alarm group i. - DF12 (rh) */
    Ifx_UReg_32Bit DF13:1;            /**< \brief [13:13] Diagnosis flag for alarm 13 belonging to alarm group i. - DF13 (rh) */
    Ifx_UReg_32Bit DF14:1;            /**< \brief [14:14] Diagnosis flag for alarm 14 belonging to alarm group i. - DF14 (rh) */
    Ifx_UReg_32Bit DF15:1;            /**< \brief [15:15] Diagnosis flag for alarm 15 belonging to alarm group i. - DF15 (rh) */
    Ifx_UReg_32Bit DF16:1;            /**< \brief [16:16] Diagnosis flag for alarm 16 belonging to alarm group i. - DF16 (rh) */
    Ifx_UReg_32Bit DF17:1;            /**< \brief [17:17] Diagnosis flag for alarm 17 belonging to alarm group i. - DF17 (rh) */
    Ifx_UReg_32Bit DF18:1;            /**< \brief [18:18] Diagnosis flag for alarm 18 belonging to alarm group i. - DF18 (rh) */
    Ifx_UReg_32Bit DF19:1;            /**< \brief [19:19] Diagnosis flag for alarm 19 belonging to alarm group i. - DF19 (rh) */
    Ifx_UReg_32Bit DF20:1;            /**< \brief [20:20] Diagnosis flag for alarm 20 belonging to alarm group i. - DF20 (rh) */
    Ifx_UReg_32Bit DF21:1;            /**< \brief [21:21] Diagnosis flag for alarm 21 belonging to alarm group i. - DF21 (rh) */
    Ifx_UReg_32Bit DF22:1;            /**< \brief [22:22] Diagnosis flag for alarm 22 belonging to alarm group i. - DF22 (rh) */
    Ifx_UReg_32Bit DF23:1;            /**< \brief [23:23] Diagnosis flag for alarm 23 belonging to alarm group i. - DF23 (rh) */
    Ifx_UReg_32Bit DF24:1;            /**< \brief [24:24] Diagnosis flag for alarm 24 belonging to alarm group i. - DF24 (rh) */
    Ifx_UReg_32Bit DF25:1;            /**< \brief [25:25] Diagnosis flag for alarm 25 belonging to alarm group i. - DF25 (rh) */
    Ifx_UReg_32Bit DF26:1;            /**< \brief [26:26] Diagnosis flag for alarm 26 belonging to alarm group i. - DF26 (rh) */
    Ifx_UReg_32Bit DF27:1;            /**< \brief [27:27] Diagnosis flag for alarm 27 belonging to alarm group i. - DF27 (rh) */
    Ifx_UReg_32Bit DF28:1;            /**< \brief [28:28] Diagnosis flag for alarm 28 belonging to alarm group i. - DF28 (rh) */
    Ifx_UReg_32Bit DF29:1;            /**< \brief [29:29] Diagnosis flag for alarm 29 belonging to alarm group i. - DF29 (rh) */
    Ifx_UReg_32Bit DF30:1;            /**< \brief [30:30] Diagnosis flag for alarm 30 belonging to alarm group i. - DF30 (rh) */
    Ifx_UReg_32Bit DF31:1;            /**< \brief [31:31] Diagnosis flag for alarm 31 belonging to alarm group i. - DF31 (rh) */
} Ifx_SMU_AD_Bits;

/** \brief Alarm Executed Status Register */
typedef struct _Ifx_SMU_AEX_Bits
{
    Ifx_UReg_32Bit IRQ0STS:1;         /**< \brief [0:0] IRQ0 Request Status - IRQ0STS (rh) */
    Ifx_UReg_32Bit IRQ1STS:1;         /**< \brief [1:1] IRQ1 Request Status - IRQ1STS (rh) */
    Ifx_UReg_32Bit IRQ2STS:1;         /**< \brief [2:2] IRQ2 Request Status - IRQ2STS (rh) */
    Ifx_UReg_32Bit RST0STS:1;         /**< \brief [3:3] RST0 Request Status - RST0STS (rh) */
    Ifx_UReg_32Bit RST1STS:1;         /**< \brief [4:4] RST1 Request Status - RST1STS (rh) */
    Ifx_UReg_32Bit RST2STS:1;         /**< \brief [5:5] RST2 Request Status - RST2STS (rh) */
    Ifx_UReg_32Bit RST3STS:1;         /**< \brief [6:6] RST3 Request Status - RST3STS (rh) */
    Ifx_UReg_32Bit RST4STS:1;         /**< \brief [7:7] RST4 Request Status - RST4STS (rh) */
    Ifx_UReg_32Bit RST5STS:1;         /**< \brief [8:8] RST5 Request Status - RST5STS (rh) */
    Ifx_UReg_32Bit NMISTS:1;          /**< \brief [9:9] NMI Request Status - NMISTS (rh) */
    Ifx_UReg_32Bit reserved_10:1;     /**< \brief [10:10] \internal Reserved */
    Ifx_UReg_32Bit EMSSTS:1;          /**< \brief [11:11] EMS Request Status - EMSSTS (rh) */
    Ifx_UReg_32Bit reserved_12:4;     /**< \brief [15:12] \internal Reserved */
    Ifx_UReg_32Bit IRQ0AEM:1;         /**< \brief [16:16] IRQ0 AEM - IRQ0AEM (rh) */
    Ifx_UReg_32Bit IRQ1AEM:1;         /**< \brief [17:17] IRQ1 AEM - IRQ1AEM (rh) */
    Ifx_UReg_32Bit IRQ2AEM:1;         /**< \brief [18:18] IRQ2 AEM - IRQ2AEM (rh) */
    Ifx_UReg_32Bit RST0AEM:1;         /**< \brief [19:19] RST0 AEM - RST0AEM (rh) */
    Ifx_UReg_32Bit RST1AEM:1;         /**< \brief [20:20] RST1 AEM - RST1AEM (rh) */
    Ifx_UReg_32Bit RST2AEM:1;         /**< \brief [21:21] RST2 AEM - RST2AEM (rh) */
    Ifx_UReg_32Bit RST3AEM:1;         /**< \brief [22:22] RST3 AEM - RST3AEM (rh) */
    Ifx_UReg_32Bit RST4AEM:1;         /**< \brief [23:23] RST4 AEM - RST4AEM (rh) */
    Ifx_UReg_32Bit RST5AEM:1;         /**< \brief [24:24] RST5 AEM - RST5AEM (rh) */
    Ifx_UReg_32Bit NMIAEM:1;          /**< \brief [25:25] NMI AEM - NMIAEM (rh) */
    Ifx_UReg_32Bit reserved_26:1;     /**< \brief [26:26] \internal Reserved */
    Ifx_UReg_32Bit EMSAEM:1;          /**< \brief [27:27] EMS AEM - EMSAEM (rh) */
    Ifx_UReg_32Bit reserved_28:4;     /**< \brief [31:28] \internal Reserved */
} Ifx_SMU_AEX_Bits;

/** \brief Alarm Executed Status Clear Register */
typedef struct _Ifx_SMU_AEXCLR_Bits
{
    unsigned __sfrbit32 IRQ0CLR:1;       /**< \brief [0:0] IRQ0 Request Status Clear - IRQ0CLR (w) */
    unsigned __sfrbit32 IRQ1CLR:1;       /**< \brief [1:1] IRQ1 Request Status Clear - IRQ1CLR (w) */
    unsigned __sfrbit32 IRQ2CLR:1;       /**< \brief [2:2] IRQ2 Request Status Clear - IRQ2CLR (w) */
    unsigned __sfrbit32 RST0CLR:1;       /**< \brief [3:3] RST0 Request Status Clear - RST0CLR (w) */
    unsigned __sfrbit32 RST1CLR:1;       /**< \brief [4:4] RST1 Request Status Clear - RST1CLR (w) */
    unsigned __sfrbit32 RST2CLR:1;       /**< \brief [5:5] RST2 Request Status Clear - RST2CLR (w) */
    unsigned __sfrbit32 RST3CLR:1;       /**< \brief [6:6] RST3 Request Status Clear - RST3CLR (w) */
    unsigned __sfrbit32 RST4CLR:1;       /**< \brief [7:7] RST4 Request Status Clear - RST4CLR (w) */
    unsigned __sfrbit32 RST5CLR:1;       /**< \brief [8:8] RST5 Request Status Clear - RST5CLR (w) */
    unsigned __sfrbit32 NMICLR:1;        /**< \brief [9:9] NMI Request Status Clear - NMICLR (w) */
    unsigned __sfrbit32 reserved_10:1;    /**< \brief [10:10] \internal Reserved */
    unsigned __sfrbit32 EMSCLR:1;        /**< \brief [11:11] EMS Request Status Clear - EMSCLR (w) */
    unsigned __sfrbit32 reserved_12:4;    /**< \brief [15:12] \internal Reserved */
    unsigned __sfrbit32 IRQ0AEMCLR:1;    /**< \brief [16:16] IRQ0 AEM Status Clear - IRQ0AEMCLR (w) */
    unsigned __sfrbit32 IRQ1AEMCLR:1;    /**< \brief [17:17] IRQ1 AEM Status Clear - IRQ1AEMCLR (w) */
    unsigned __sfrbit32 IRQ2AEMCLR:1;    /**< \brief [18:18] IRQ2 AEM Status Clear - IRQ2AEMCLR (w) */
    unsigned __sfrbit32 RST0AEMCLR:1;    /**< \brief [19:19] RST0 AEM Status Clear - RST0AEMCLR (w) */
    unsigned __sfrbit32 RST1AEMCLR:1;    /**< \brief [20:20] RST1 AEM Status Clear - RST1AEMCLR (w) */
    unsigned __sfrbit32 RST2AEMCLR:1;    /**< \brief [21:21] RST2 AEM Status Clear - RST2AEMCLR (w) */
    unsigned __sfrbit32 RST3AEMCLR:1;    /**< \brief [22:22] RST3 AEM Status Clear - RST3AEMCLR (w) */
    unsigned __sfrbit32 RST4AEMCLR:1;    /**< \brief [23:23] RST4 AEM Status Clear - RST4AEMCLR (w) */
    unsigned __sfrbit32 RST5AEMCLR:1;    /**< \brief [24:24] RST5 AEM Status Clear - RST5AEMCLR (w) */
    unsigned __sfrbit32 NMIAEMCLR:1;     /**< \brief [25:25] NMI AEM Status Clear - NMIAEMCLR (w) */
    unsigned __sfrbit32 reserved_26:1;    /**< \brief [26:26] \internal Reserved */
    unsigned __sfrbit32 EMSAEMCLR:1;     /**< \brief [27:27] EMS AEM Status Clear - EMSAEMCLR (w) */
    unsigned __sfrbit32 reserved_28:4;    /**< \brief [31:28] \internal Reserved */
} Ifx_SMU_AEXCLR_Bits;

/** \brief Alarm and Fault Counter */
typedef struct _Ifx_SMU_AFCNT_Bits
{
    Ifx_UReg_32Bit FCNT:4;            /**< \brief [3:0] Fault Counter. - FCNT (rh) */
    Ifx_UReg_32Bit ACNT:12;           /**< \brief [15:4] Alarm Counter. - ACNT (rh) */
    Ifx_UReg_32Bit reserved_16:14;    /**< \brief [29:16] \internal Reserved */
    Ifx_UReg_32Bit FCO:1;             /**< \brief [30:30] Fault Counter Overflow. - FCO (rh) */
    Ifx_UReg_32Bit ACO:1;             /**< \brief [31:31] Alarm Counter Overflow. - ACO (rh) */
} Ifx_SMU_AFCNT_Bits;

/** \brief Alarm Status Register */
typedef struct _Ifx_SMU_AG_Bits
{
    unsigned __sfrbit32 SF0:1;           /**< \brief [0:0] Status flag for alarm 0 belonging to alarm group i. - SF0 (rwh) */
    unsigned __sfrbit32 SF1:1;           /**< \brief [1:1] Status flag for alarm 1 belonging to alarm group i. - SF1 (rwh) */
    unsigned __sfrbit32 SF2:1;           /**< \brief [2:2] Status flag for alarm 2 belonging to alarm group i. - SF2 (rwh) */
    unsigned __sfrbit32 SF3:1;           /**< \brief [3:3] Status flag for alarm 3 belonging to alarm group i. - SF3 (rwh) */
    unsigned __sfrbit32 SF4:1;           /**< \brief [4:4] Status flag for alarm 4 belonging to alarm group i. - SF4 (rwh) */
    unsigned __sfrbit32 SF5:1;           /**< \brief [5:5] Status flag for alarm 5 belonging to alarm group i. - SF5 (rwh) */
    unsigned __sfrbit32 SF6:1;           /**< \brief [6:6] Status flag for alarm 6 belonging to alarm group i. - SF6 (rwh) */
    unsigned __sfrbit32 SF7:1;           /**< \brief [7:7] Status flag for alarm 7 belonging to alarm group i. - SF7 (rwh) */
    unsigned __sfrbit32 SF8:1;           /**< \brief [8:8] Status flag for alarm 8 belonging to alarm group i. - SF8 (rwh) */
    unsigned __sfrbit32 SF9:1;           /**< \brief [9:9] Status flag for alarm 9 belonging to alarm group i. - SF9 (rwh) */
    unsigned __sfrbit32 SF10:1;          /**< \brief [10:10] Status flag for alarm 10 belonging to alarm group i. - SF10 (rwh) */
    unsigned __sfrbit32 SF11:1;          /**< \brief [11:11] Status flag for alarm 11 belonging to alarm group i. - SF11 (rwh) */
    unsigned __sfrbit32 SF12:1;          /**< \brief [12:12] Status flag for alarm 12 belonging to alarm group i. - SF12 (rwh) */
    unsigned __sfrbit32 SF13:1;          /**< \brief [13:13] Status flag for alarm 13 belonging to alarm group i. - SF13 (rwh) */
    unsigned __sfrbit32 SF14:1;          /**< \brief [14:14] Status flag for alarm 14 belonging to alarm group i. - SF14 (rwh) */
    unsigned __sfrbit32 SF15:1;          /**< \brief [15:15] Status flag for alarm 15 belonging to alarm group i. - SF15 (rwh) */
    unsigned __sfrbit32 SF16:1;          /**< \brief [16:16] Status flag for alarm 16 belonging to alarm group i. - SF16 (rwh) */
    unsigned __sfrbit32 SF17:1;          /**< \brief [17:17] Status flag for alarm 17 belonging to alarm group i. - SF17 (rwh) */
    unsigned __sfrbit32 SF18:1;          /**< \brief [18:18] Status flag for alarm 18 belonging to alarm group i. - SF18 (rwh) */
    unsigned __sfrbit32 SF19:1;          /**< \brief [19:19] Status flag for alarm 19 belonging to alarm group i. - SF19 (rwh) */
    unsigned __sfrbit32 SF20:1;          /**< \brief [20:20] Status flag for alarm 20 belonging to alarm group i. - SF20 (rwh) */
    unsigned __sfrbit32 SF21:1;          /**< \brief [21:21] Status flag for alarm 21 belonging to alarm group i. - SF21 (rwh) */
    unsigned __sfrbit32 SF22:1;          /**< \brief [22:22] Status flag for alarm 22 belonging to alarm group i. - SF22 (rwh) */
    unsigned __sfrbit32 SF23:1;          /**< \brief [23:23] Status flag for alarm 23 belonging to alarm group i. - SF23 (rwh) */
    unsigned __sfrbit32 SF24:1;          /**< \brief [24:24] Status flag for alarm 24 belonging to alarm group i. - SF24 (rwh) */
    unsigned __sfrbit32 SF25:1;          /**< \brief [25:25] Status flag for alarm 25 belonging to alarm group i. - SF25 (rwh) */
    unsigned __sfrbit32 SF26:1;          /**< \brief [26:26] Status flag for alarm 26 belonging to alarm group i. - SF26 (rwh) */
    unsigned __sfrbit32 SF27:1;          /**< \brief [27:27] Status flag for alarm 27 belonging to alarm group i. - SF27 (rwh) */
    unsigned __sfrbit32 SF28:1;          /**< \brief [28:28] Status flag for alarm 28 belonging to alarm group i. - SF28 (rwh) */
    unsigned __sfrbit32 SF29:1;          /**< \brief [29:29] Status flag for alarm 29 belonging to alarm group i. - SF29 (rwh) */
    unsigned __sfrbit32 SF30:1;          /**< \brief [30:30] Status flag for alarm 30 belonging to alarm group i. - SF30 (rwh) */
    unsigned __sfrbit32 SF31:1;          /**< \brief [31:31] Status flag for alarm 31 belonging to alarm group i. - SF31 (rwh) */
} Ifx_SMU_AG_Bits;

/** \brief Alarm Global Configuration */
typedef struct _Ifx_SMU_AGC_Bits
{
    unsigned __sfrbit32 IGCS0:3;         /**< \brief [2:0] Interrupt Generation Configuration Set 0 - IGCS0 (rw) */
    unsigned __sfrbit32 reserved_3:1;    /**< \brief [3:3] \internal Reserved */
    unsigned __sfrbit32 IGCS1:3;         /**< \brief [6:4] Interrupt Generation Configuration Set 1 - IGCS1 (rw) */
    unsigned __sfrbit32 reserved_7:1;    /**< \brief [7:7] \internal Reserved */
    unsigned __sfrbit32 IGCS2:3;         /**< \brief [10:8] Interrupt Generation Configuration Set 2 - IGCS2 (rw) */
    unsigned __sfrbit32 reserved_11:5;    /**< \brief [15:11] \internal Reserved */
    unsigned __sfrbit32 RCS:6;           /**< \brief [21:16] CPU Reset Configuration Set - RCS (rw) */
    unsigned __sfrbit32 reserved_22:2;    /**< \brief [23:22] \internal Reserved */
    unsigned __sfrbit32 PES:5;           /**< \brief [28:24] Port Emergency Stop - PES (rw) */
    unsigned __sfrbit32 EFRST:1;         /**< \brief [29:29] Enable FAULT to RUN State Transition - EFRST (rw) */
    unsigned __sfrbit32 reserved_30:2;    /**< \brief [31:30] \internal Reserved */
} Ifx_SMU_AGC_Bits;

/** \brief Alarm Configuration Register */
typedef struct _Ifx_SMU_AGCF_Bits
{
    unsigned __sfrbit32 CF0:1;           /**< \brief [0:0] Configuration flag x (x=0-2) for alarm 0 belonging to alarm group i. - CF0 (rw) */
    unsigned __sfrbit32 CF1:1;           /**< \brief [1:1] Configuration flag x (x=0-2) for alarm 1 belonging to alarm group i. - CF1 (rw) */
    unsigned __sfrbit32 CF2:1;           /**< \brief [2:2] Configuration flag x (x=0-2) for alarm 2 belonging to alarm group i. - CF2 (rw) */
    unsigned __sfrbit32 CF3:1;           /**< \brief [3:3] Configuration flag x (x=0-2) for alarm 3 belonging to alarm group i. - CF3 (rw) */
    unsigned __sfrbit32 CF4:1;           /**< \brief [4:4] Configuration flag x (x=0-2) for alarm 4 belonging to alarm group i. - CF4 (rw) */
    unsigned __sfrbit32 CF5:1;           /**< \brief [5:5] Configuration flag x (x=0-2) for alarm 5 belonging to alarm group i. - CF5 (rw) */
    unsigned __sfrbit32 CF6:1;           /**< \brief [6:6] Configuration flag x (x=0-2) for alarm 6 belonging to alarm group i. - CF6 (rw) */
    unsigned __sfrbit32 CF7:1;           /**< \brief [7:7] Configuration flag x (x=0-2) for alarm 7 belonging to alarm group i. - CF7 (rw) */
    unsigned __sfrbit32 CF8:1;           /**< \brief [8:8] Configuration flag x (x=0-2) for alarm 8 belonging to alarm group i. - CF8 (rw) */
    unsigned __sfrbit32 CF9:1;           /**< \brief [9:9] Configuration flag x (x=0-2) for alarm 9 belonging to alarm group i. - CF9 (rw) */
    unsigned __sfrbit32 CF10:1;          /**< \brief [10:10] Configuration flag x (x=0-2) for alarm 10 belonging to alarm group i. - CF10 (rw) */
    unsigned __sfrbit32 CF11:1;          /**< \brief [11:11] Configuration flag x (x=0-2) for alarm 11 belonging to alarm group i. - CF11 (rw) */
    unsigned __sfrbit32 CF12:1;          /**< \brief [12:12] Configuration flag x (x=0-2) for alarm 12 belonging to alarm group i. - CF12 (rw) */
    unsigned __sfrbit32 CF13:1;          /**< \brief [13:13] Configuration flag x (x=0-2) for alarm 13 belonging to alarm group i. - CF13 (rw) */
    unsigned __sfrbit32 CF14:1;          /**< \brief [14:14] Configuration flag x (x=0-2) for alarm 14 belonging to alarm group i. - CF14 (rw) */
    unsigned __sfrbit32 CF15:1;          /**< \brief [15:15] Configuration flag x (x=0-2) for alarm 15 belonging to alarm group i. - CF15 (rw) */
    unsigned __sfrbit32 CF16:1;          /**< \brief [16:16] Configuration flag x (x=0-2) for alarm 16 belonging to alarm group i. - CF16 (rw) */
    unsigned __sfrbit32 CF17:1;          /**< \brief [17:17] Configuration flag x (x=0-2) for alarm 17 belonging to alarm group i. - CF17 (rw) */
    unsigned __sfrbit32 CF18:1;          /**< \brief [18:18] Configuration flag x (x=0-2) for alarm 18 belonging to alarm group i. - CF18 (rw) */
    unsigned __sfrbit32 CF19:1;          /**< \brief [19:19] Configuration flag x (x=0-2) for alarm 19 belonging to alarm group i. - CF19 (rw) */
    unsigned __sfrbit32 CF20:1;          /**< \brief [20:20] Configuration flag x (x=0-2) for alarm 20 belonging to alarm group i. - CF20 (rw) */
    unsigned __sfrbit32 CF21:1;          /**< \brief [21:21] Configuration flag x (x=0-2) for alarm 21 belonging to alarm group i. - CF21 (rw) */
    unsigned __sfrbit32 CF22:1;          /**< \brief [22:22] Configuration flag x (x=0-2) for alarm 22 belonging to alarm group i. - CF22 (rw) */
    unsigned __sfrbit32 CF23:1;          /**< \brief [23:23] Configuration flag x (x=0-2) for alarm 23 belonging to alarm group i. - CF23 (rw) */
    unsigned __sfrbit32 CF24:1;          /**< \brief [24:24] Configuration flag x (x=0-2) for alarm 24 belonging to alarm group i. - CF24 (rw) */
    unsigned __sfrbit32 CF25:1;          /**< \brief [25:25] Configuration flag x (x=0-2) for alarm 25 belonging to alarm group i. - CF25 (rw) */
    unsigned __sfrbit32 CF26:1;          /**< \brief [26:26] Configuration flag x (x=0-2) for alarm 26 belonging to alarm group i. - CF26 (rw) */
    unsigned __sfrbit32 CF27:1;          /**< \brief [27:27] Configuration flag x (x=0-2) for alarm 27 belonging to alarm group i. - CF27 (rw) */
    unsigned __sfrbit32 CF28:1;          /**< \brief [28:28] Configuration flag x (x=0-2) for alarm 28 belonging to alarm group i. - CF28 (rw) */
    unsigned __sfrbit32 CF29:1;          /**< \brief [29:29] Configuration flag x (x=0-2) for alarm 29 belonging to alarm group i. - CF29 (rw) */
    unsigned __sfrbit32 CF30:1;          /**< \brief [30:30] Configuration flag x (x=0-2) for alarm 30 belonging to alarm group i. - CF30 (rw) */
    unsigned __sfrbit32 CF31:1;          /**< \brief [31:31] Configuration flag x (x=0-2) for alarm 31 belonging to alarm group i. - CF31 (rw) */
} Ifx_SMU_AGCF_Bits;

/** \brief SMU_core FSP Configuration Register */
typedef struct _Ifx_SMU_AGFSP_Bits
{
    unsigned __sfrbit32 FE0:1;           /**< \brief [0:0] Fault signaling configuration flag for alarm 0 belonging to alarm group i. - FE0 (rw) */
    unsigned __sfrbit32 FE1:1;           /**< \brief [1:1] Fault signaling configuration flag for alarm 1 belonging to alarm group i. - FE1 (rw) */
    unsigned __sfrbit32 FE2:1;           /**< \brief [2:2] Fault signaling configuration flag for alarm 2 belonging to alarm group i. - FE2 (rw) */
    unsigned __sfrbit32 FE3:1;           /**< \brief [3:3] Fault signaling configuration flag for alarm 3 belonging to alarm group i. - FE3 (rw) */
    unsigned __sfrbit32 FE4:1;           /**< \brief [4:4] Fault signaling configuration flag for alarm 4 belonging to alarm group i. - FE4 (rw) */
    unsigned __sfrbit32 FE5:1;           /**< \brief [5:5] Fault signaling configuration flag for alarm 5 belonging to alarm group i. - FE5 (rw) */
    unsigned __sfrbit32 FE6:1;           /**< \brief [6:6] Fault signaling configuration flag for alarm 6 belonging to alarm group i. - FE6 (rw) */
    unsigned __sfrbit32 FE7:1;           /**< \brief [7:7] Fault signaling configuration flag for alarm 7 belonging to alarm group i. - FE7 (rw) */
    unsigned __sfrbit32 FE8:1;           /**< \brief [8:8] Fault signaling configuration flag for alarm 8 belonging to alarm group i. - FE8 (rw) */
    unsigned __sfrbit32 FE9:1;           /**< \brief [9:9] Fault signaling configuration flag for alarm 9 belonging to alarm group i. - FE9 (rw) */
    unsigned __sfrbit32 FE10:1;          /**< \brief [10:10] Fault signaling configuration flag for alarm 10 belonging to alarm group i. - FE10 (rw) */
    unsigned __sfrbit32 FE11:1;          /**< \brief [11:11] Fault signaling configuration flag for alarm 11 belonging to alarm group i. - FE11 (rw) */
    unsigned __sfrbit32 FE12:1;          /**< \brief [12:12] Fault signaling configuration flag for alarm 12 belonging to alarm group i. - FE12 (rw) */
    unsigned __sfrbit32 FE13:1;          /**< \brief [13:13] Fault signaling configuration flag for alarm 13 belonging to alarm group i. - FE13 (rw) */
    unsigned __sfrbit32 FE14:1;          /**< \brief [14:14] Fault signaling configuration flag for alarm 14 belonging to alarm group i. - FE14 (rw) */
    unsigned __sfrbit32 FE15:1;          /**< \brief [15:15] Fault signaling configuration flag for alarm 15 belonging to alarm group i. - FE15 (rw) */
    unsigned __sfrbit32 FE16:1;          /**< \brief [16:16] Fault signaling configuration flag for alarm 16 belonging to alarm group i. - FE16 (rw) */
    unsigned __sfrbit32 FE17:1;          /**< \brief [17:17] Fault signaling configuration flag for alarm 17 belonging to alarm group i. - FE17 (rw) */
    unsigned __sfrbit32 FE18:1;          /**< \brief [18:18] Fault signaling configuration flag for alarm 18 belonging to alarm group i. - FE18 (rw) */
    unsigned __sfrbit32 FE19:1;          /**< \brief [19:19] Fault signaling configuration flag for alarm 19 belonging to alarm group i. - FE19 (rw) */
    unsigned __sfrbit32 FE20:1;          /**< \brief [20:20] Fault signaling configuration flag for alarm 20 belonging to alarm group i. - FE20 (rw) */
    unsigned __sfrbit32 FE21:1;          /**< \brief [21:21] Fault signaling configuration flag for alarm 21 belonging to alarm group i. - FE21 (rw) */
    unsigned __sfrbit32 FE22:1;          /**< \brief [22:22] Fault signaling configuration flag for alarm 22 belonging to alarm group i. - FE22 (rw) */
    unsigned __sfrbit32 FE23:1;          /**< \brief [23:23] Fault signaling configuration flag for alarm 23 belonging to alarm group i. - FE23 (rw) */
    unsigned __sfrbit32 FE24:1;          /**< \brief [24:24] Fault signaling configuration flag for alarm 24 belonging to alarm group i. - FE24 (rw) */
    unsigned __sfrbit32 FE25:1;          /**< \brief [25:25] Fault signaling configuration flag for alarm 25 belonging to alarm group i. - FE25 (rw) */
    unsigned __sfrbit32 FE26:1;          /**< \brief [26:26] Fault signaling configuration flag for alarm 26 belonging to alarm group i. - FE26 (rw) */
    unsigned __sfrbit32 FE27:1;          /**< \brief [27:27] Fault signaling configuration flag for alarm 27 belonging to alarm group i. - FE27 (rw) */
    unsigned __sfrbit32 FE28:1;          /**< \brief [28:28] Fault signaling configuration flag for alarm 28 belonging to alarm group i. - FE28 (rw) */
    unsigned __sfrbit32 FE29:1;          /**< \brief [29:29] Fault signaling configuration flag for alarm 29 belonging to alarm group i. - FE29 (rw) */
    unsigned __sfrbit32 FE30:1;          /**< \brief [30:30] Fault signaling configuration flag for alarm 30 belonging to alarm group i. - FE30 (rw) */
    unsigned __sfrbit32 FE31:1;          /**< \brief [31:31] Fault signaling configuration flag for alarm 31 belonging to alarm group i. - FE31 (rw) */
} Ifx_SMU_AGFSP_Bits;

/** \brief Clock Control Register */
typedef struct _Ifx_SMU_CLC_Bits
{
    Ifx_UReg_32Bit DISR:1;            /**< \brief [0:0] Module Disable Request Bit - DISR (rw) */
    Ifx_UReg_32Bit DISS:1;            /**< \brief [1:1] Module Disable Status Bit - DISS (rh) */
    Ifx_UReg_32Bit reserved_2:1;      /**< \brief [2:2] \internal Reserved */
    Ifx_UReg_32Bit EDIS:1;            /**< \brief [3:3] Sleep Mode Enable Control - EDIS (rw) */
    Ifx_UReg_32Bit reserved_4:28;     /**< \brief [31:4] \internal Reserved */
} Ifx_SMU_CLC_Bits;

/** \brief Command Register */
typedef struct _Ifx_SMU_CMD_Bits
{
    unsigned __sfrbit32 CMD:4;           /**< \brief [3:0] Implements the SMU_core Command Interface. - CMD (w) */
    unsigned __sfrbit32 ARG:4;           /**< \brief [7:4] Implements the SMU_core Command Interface. - ARG (w) */
    unsigned __sfrbit32 reserved_8:24;    /**< \brief [31:8] \internal Reserved */
} Ifx_SMU_CMD_Bits;

/** \brief Debug Register */
typedef struct _Ifx_SMU_DBG_Bits
{
    Ifx_UReg_32Bit SSM:2;             /**< \brief [1:0] Running state of the SMU_core State Machine - SSM (rh) */
    Ifx_UReg_32Bit reserved_2:30;     /**< \brief [31:2] \internal Reserved */
} Ifx_SMU_DBG_Bits;

/** \brief Fault Signaling Protocol */
typedef struct _Ifx_SMU_FSP_Bits
{
    unsigned __sfrbit32 PRE1:3;          /**< \brief [2:0] Prescaler1 - PRE1 (rw) */
    unsigned __sfrbit32 PRE2:2;          /**< \brief [4:3] Prescaler2 - PRE2 (rw) */
    unsigned __sfrbit32 MODE:2;          /**< \brief [6:5] Fault Signaling Protocol configuration - MODE (rw) */
    unsigned __sfrbit32 PES:1;           /**< \brief [7:7] Port Emergency Stop (PES) - PES (rw) */
    unsigned __sfrbit32 TFSP_LOW:14;     /**< \brief [21:8] Specifies the FSP fault state duration - TFSP_LOW (r) */
    unsigned __sfrbit32 TFSP_HIGH:10;    /**< \brief [31:22] Specifies the FSP fault state duration - TFSP_HIGH (rw) */
} Ifx_SMU_FSP_Bits;

/** \brief Module Identification Register */
typedef struct _Ifx_SMU_ID_Bits
{
    Ifx_UReg_32Bit MOD_REV:8;         /**< \brief [7:0] Module Revision Number - MOD_REV (r) */
    Ifx_UReg_32Bit MOD_TYPE:8;        /**< \brief [15:8] Module Type - MOD_TYPE (r) */
    Ifx_UReg_32Bit MOD_NUMBER:16;     /**< \brief [31:16] Module Number Value - MOD_NUMBER (r) */
} Ifx_SMU_ID_Bits;

/** \brief Key Register */
typedef struct _Ifx_SMU_KEYS_Bits
{
    unsigned __sfrbit32 CFGLCK:8;        /**< \brief [7:0] Configuration Lock - CFGLCK (rw) */
    unsigned __sfrbit32 PERLCK:8;        /**< \brief [15:8] Permanent Lock - PERLCK (rw) */
    unsigned __sfrbit32 reserved_16:16;    /**< \brief [31:16] \internal Reserved */
} Ifx_SMU_KEYS_Bits;

/** \brief OCDS Control and Status */
typedef struct _Ifx_SMU_OCS_Bits
{
    Ifx_UReg_32Bit TGS:2;             /**< \brief [1:0] Trigger Set for OTGB0/1 - TGS (rw) */
    Ifx_UReg_32Bit TGB:1;             /**< \brief [2:2] OTGB0/1 Bus Select - TGB (rw) */
    Ifx_UReg_32Bit TG_P:1;            /**< \brief [3:3] TGS, TGB Write Protection - TG_P (w) */
    Ifx_UReg_32Bit reserved_4:20;     /**< \brief [23:4] \internal Reserved */
    Ifx_UReg_32Bit SUS:4;             /**< \brief [27:24] OCDS Suspend Control - SUS (rw) */
    Ifx_UReg_32Bit SUS_P:1;           /**< \brief [28:28] SUS Write Protection - SUS_P (w) */
    Ifx_UReg_32Bit SUSSTA:1;          /**< \brief [29:29] Suspend State - SUSSTA (rh) */
    Ifx_UReg_32Bit reserved_30:2;     /**< \brief [31:30] \internal Reserved */
} Ifx_SMU_OCS_Bits;

/** \brief Port Control */
typedef struct _Ifx_SMU_PCTL_Bits
{
    unsigned __sfrbit32 HWDIR:2;         /**< \brief [1:0] Port Direction. - HWDIR (rw) */
    unsigned __sfrbit32 HWEN:2;          /**< \brief [3:2] Port Enable - HWEN (rw) */
    unsigned __sfrbit32 GFSCU_EN:1;      /**< \brief [4:4] Glitch Filter for ErrorPin SMU_FSP0 to SCU enable - GFSCU_EN (rw) */
    unsigned __sfrbit32 GFSTS_EN:1;      /**< \brief [5:5] Glitch Filter for ErrorPin SMU_FSP0 to register SMU_STS enable - GFSTS_EN (rw) */
    unsigned __sfrbit32 reserved_6:1;    /**< \brief [6:6] \internal Reserved */
    unsigned __sfrbit32 PCS:1;           /**< \brief [7:7] PAD Configuration Select - PCS (rw) */
    unsigned __sfrbit32 reserved_8:6;    /**< \brief [13:8] \internal Reserved */
    unsigned __sfrbit32 reserved_14:9;    /**< \brief [22:14] \internal Reserved */
    unsigned __sfrbit32 reserved_23:9;    /**< \brief [31:23] \internal Reserved */
} Ifx_SMU_PCTL_Bits;

/** \brief Register Monitor Control */
typedef struct _Ifx_SMU_RMCTL_Bits
{
    unsigned __sfrbit32 TE0:1;           /**< \brief [0:0] Test Enable. - TE0 (rw) */
    unsigned __sfrbit32 TE1:1;           /**< \brief [1:1] Test Enable. - TE1 (rw) */
    unsigned __sfrbit32 TE2:1;           /**< \brief [2:2] Test Enable. - TE2 (rw) */
    unsigned __sfrbit32 TE3:1;           /**< \brief [3:3] Test Enable. - TE3 (rw) */
    unsigned __sfrbit32 TE4:1;           /**< \brief [4:4] Test Enable. - TE4 (rw) */
    unsigned __sfrbit32 TE5:1;           /**< \brief [5:5] Test Enable. - TE5 (rw) */
    unsigned __sfrbit32 TE6:1;           /**< \brief [6:6] Test Enable. - TE6 (rw) */
    unsigned __sfrbit32 TE7:1;           /**< \brief [7:7] Test Enable. - TE7 (rw) */
    unsigned __sfrbit32 TE8:1;           /**< \brief [8:8] Test Enable. - TE8 (rw) */
    unsigned __sfrbit32 TE9:1;           /**< \brief [9:9] Test Enable. - TE9 (rw) */
    unsigned __sfrbit32 TE10:1;          /**< \brief [10:10] Test Enable. - TE10 (rw) */
    unsigned __sfrbit32 reserved_11:1;    /**< \brief [11:11] \internal Reserved */
    unsigned __sfrbit32 reserved_12:1;    /**< \brief [12:12] \internal Reserved */
    unsigned __sfrbit32 reserved_13:1;    /**< \brief [13:13] \internal Reserved */
    unsigned __sfrbit32 reserved_14:1;    /**< \brief [14:14] \internal Reserved */
    unsigned __sfrbit32 reserved_15:1;    /**< \brief [15:15] \internal Reserved */
    unsigned __sfrbit32 reserved_16:1;    /**< \brief [16:16] \internal Reserved */
    unsigned __sfrbit32 reserved_17:1;    /**< \brief [17:17] \internal Reserved */
    unsigned __sfrbit32 reserved_18:1;    /**< \brief [18:18] \internal Reserved */
    unsigned __sfrbit32 reserved_19:1;    /**< \brief [19:19] \internal Reserved */
    unsigned __sfrbit32 reserved_20:1;    /**< \brief [20:20] \internal Reserved */
    unsigned __sfrbit32 reserved_21:1;    /**< \brief [21:21] \internal Reserved */
    unsigned __sfrbit32 reserved_22:1;    /**< \brief [22:22] \internal Reserved */
    unsigned __sfrbit32 reserved_23:1;    /**< \brief [23:23] \internal Reserved */
    unsigned __sfrbit32 reserved_24:1;    /**< \brief [24:24] \internal Reserved */
    unsigned __sfrbit32 reserved_25:1;    /**< \brief [25:25] \internal Reserved */
    unsigned __sfrbit32 reserved_26:1;    /**< \brief [26:26] \internal Reserved */
    unsigned __sfrbit32 reserved_27:1;    /**< \brief [27:27] \internal Reserved */
    unsigned __sfrbit32 reserved_28:1;    /**< \brief [28:28] \internal Reserved */
    unsigned __sfrbit32 reserved_29:1;    /**< \brief [29:29] \internal Reserved */
    unsigned __sfrbit32 reserved_30:1;    /**< \brief [30:30] \internal Reserved */
    unsigned __sfrbit32 reserved_31:1;    /**< \brief [31:31] \internal Reserved */
} Ifx_SMU_RMCTL_Bits;

/** \brief Register Monitor Error Flags */
typedef struct _Ifx_SMU_RMEF_Bits
{
    unsigned __sfrbit32 EF0:1;           /**< \brief [0:0] Status flag related to the different instances of the register monitor safety mechanism. - EF0 (rwh) */
    unsigned __sfrbit32 EF1:1;           /**< \brief [1:1] Status flag related to the different instances of the register monitor safety mechanism. - EF1 (rwh) */
    unsigned __sfrbit32 EF2:1;           /**< \brief [2:2] Status flag related to the different instances of the register monitor safety mechanism. - EF2 (rwh) */
    unsigned __sfrbit32 EF3:1;           /**< \brief [3:3] Status flag related to the different instances of the register monitor safety mechanism. - EF3 (rwh) */
    unsigned __sfrbit32 EF4:1;           /**< \brief [4:4] Status flag related to the different instances of the register monitor safety mechanism. - EF4 (rwh) */
    unsigned __sfrbit32 EF5:1;           /**< \brief [5:5] Status flag related to the different instances of the register monitor safety mechanism. - EF5 (rwh) */
    unsigned __sfrbit32 EF6:1;           /**< \brief [6:6] Status flag related to the different instances of the register monitor safety mechanism. - EF6 (rwh) */
    unsigned __sfrbit32 EF7:1;           /**< \brief [7:7] Status flag related to the different instances of the register monitor safety mechanism. - EF7 (rwh) */
    unsigned __sfrbit32 EF8:1;           /**< \brief [8:8] Status flag related to the different instances of the register monitor safety mechanism. - EF8 (rwh) */
    unsigned __sfrbit32 EF9:1;           /**< \brief [9:9] Status flag related to the different instances of the register monitor safety mechanism. - EF9 (rwh) */
    unsigned __sfrbit32 EF10:1;          /**< \brief [10:10] Status flag related to the different instances of the register monitor safety mechanism. - EF10 (rwh) */
    unsigned __sfrbit32 reserved_11:1;    /**< \brief [11:11] \internal Reserved */
    unsigned __sfrbit32 reserved_12:1;    /**< \brief [12:12] \internal Reserved */
    unsigned __sfrbit32 reserved_13:1;    /**< \brief [13:13] \internal Reserved */
    unsigned __sfrbit32 reserved_14:1;    /**< \brief [14:14] \internal Reserved */
    unsigned __sfrbit32 reserved_15:1;    /**< \brief [15:15] \internal Reserved */
    unsigned __sfrbit32 reserved_16:1;    /**< \brief [16:16] \internal Reserved */
    unsigned __sfrbit32 reserved_17:1;    /**< \brief [17:17] \internal Reserved */
    unsigned __sfrbit32 reserved_18:1;    /**< \brief [18:18] \internal Reserved */
    unsigned __sfrbit32 reserved_19:1;    /**< \brief [19:19] \internal Reserved */
    unsigned __sfrbit32 reserved_20:1;    /**< \brief [20:20] \internal Reserved */
    unsigned __sfrbit32 reserved_21:1;    /**< \brief [21:21] \internal Reserved */
    unsigned __sfrbit32 reserved_22:1;    /**< \brief [22:22] \internal Reserved */
    unsigned __sfrbit32 reserved_23:1;    /**< \brief [23:23] \internal Reserved */
    unsigned __sfrbit32 reserved_24:1;    /**< \brief [24:24] \internal Reserved */
    unsigned __sfrbit32 reserved_25:1;    /**< \brief [25:25] \internal Reserved */
    unsigned __sfrbit32 reserved_26:1;    /**< \brief [26:26] \internal Reserved */
    unsigned __sfrbit32 reserved_27:1;    /**< \brief [27:27] \internal Reserved */
    unsigned __sfrbit32 reserved_28:1;    /**< \brief [28:28] \internal Reserved */
    unsigned __sfrbit32 reserved_29:1;    /**< \brief [29:29] \internal Reserved */
    unsigned __sfrbit32 reserved_30:1;    /**< \brief [30:30] \internal Reserved */
    unsigned __sfrbit32 reserved_31:1;    /**< \brief [31:31] \internal Reserved */
} Ifx_SMU_RMEF_Bits;

/** \brief Register Monitor Self Test Status */
typedef struct _Ifx_SMU_RMSTS_Bits
{
    unsigned __sfrbit32 STS0:1;          /**< \brief [0:0] Ready flag related to the different instances of the register monitor safety mechanism. - STS0 (rwh) */
    unsigned __sfrbit32 STS1:1;          /**< \brief [1:1] Ready flag related to the different instances of the register monitor safety mechanism. - STS1 (rwh) */
    unsigned __sfrbit32 STS2:1;          /**< \brief [2:2] Ready flag related to the different instances of the register monitor safety mechanism. - STS2 (rwh) */
    unsigned __sfrbit32 STS3:1;          /**< \brief [3:3] Ready flag related to the different instances of the register monitor safety mechanism. - STS3 (rwh) */
    unsigned __sfrbit32 STS4:1;          /**< \brief [4:4] Ready flag related to the different instances of the register monitor safety mechanism. - STS4 (rwh) */
    unsigned __sfrbit32 STS5:1;          /**< \brief [5:5] Ready flag related to the different instances of the register monitor safety mechanism. - STS5 (rwh) */
    unsigned __sfrbit32 STS6:1;          /**< \brief [6:6] Ready flag related to the different instances of the register monitor safety mechanism. - STS6 (rwh) */
    unsigned __sfrbit32 STS7:1;          /**< \brief [7:7] Ready flag related to the different instances of the register monitor safety mechanism. - STS7 (rwh) */
    unsigned __sfrbit32 STS8:1;          /**< \brief [8:8] Ready flag related to the different instances of the register monitor safety mechanism. - STS8 (rwh) */
    unsigned __sfrbit32 STS9:1;          /**< \brief [9:9] Ready flag related to the different instances of the register monitor safety mechanism. - STS9 (rwh) */
    unsigned __sfrbit32 STS10:1;         /**< \brief [10:10] Ready flag related to the different instances of the register monitor safety mechanism. - STS10 (rwh) */
    unsigned __sfrbit32 reserved_11:1;    /**< \brief [11:11] \internal Reserved */
    unsigned __sfrbit32 reserved_12:1;    /**< \brief [12:12] \internal Reserved */
    unsigned __sfrbit32 reserved_13:1;    /**< \brief [13:13] \internal Reserved */
    unsigned __sfrbit32 reserved_14:1;    /**< \brief [14:14] \internal Reserved */
    unsigned __sfrbit32 reserved_15:1;    /**< \brief [15:15] \internal Reserved */
    unsigned __sfrbit32 reserved_16:1;    /**< \brief [16:16] \internal Reserved */
    unsigned __sfrbit32 reserved_17:1;    /**< \brief [17:17] \internal Reserved */
    unsigned __sfrbit32 reserved_18:1;    /**< \brief [18:18] \internal Reserved */
    unsigned __sfrbit32 reserved_19:1;    /**< \brief [19:19] \internal Reserved */
    unsigned __sfrbit32 reserved_20:1;    /**< \brief [20:20] \internal Reserved */
    unsigned __sfrbit32 reserved_21:1;    /**< \brief [21:21] \internal Reserved */
    unsigned __sfrbit32 reserved_22:1;    /**< \brief [22:22] \internal Reserved */
    unsigned __sfrbit32 reserved_23:1;    /**< \brief [23:23] \internal Reserved */
    unsigned __sfrbit32 reserved_24:1;    /**< \brief [24:24] \internal Reserved */
    unsigned __sfrbit32 reserved_25:1;    /**< \brief [25:25] \internal Reserved */
    unsigned __sfrbit32 reserved_26:1;    /**< \brief [26:26] \internal Reserved */
    unsigned __sfrbit32 reserved_27:1;    /**< \brief [27:27] \internal Reserved */
    unsigned __sfrbit32 reserved_28:1;    /**< \brief [28:28] \internal Reserved */
    unsigned __sfrbit32 reserved_29:1;    /**< \brief [29:29] \internal Reserved */
    unsigned __sfrbit32 reserved_30:1;    /**< \brief [30:30] \internal Reserved */
    unsigned __sfrbit32 reserved_31:1;    /**< \brief [31:31] \internal Reserved */
} Ifx_SMU_RMSTS_Bits;

/** \brief Recovery Timer 0 Alarm Configuration 0 */
typedef struct _Ifx_SMU_RTAC00_Bits
{
    unsigned __sfrbit32 GID0:4;          /**< \brief [3:0] Group Index 0. - GID0 (rw) */
    unsigned __sfrbit32 ALID0:5;         /**< \brief [8:4] Alarm Identifier 0. - ALID0 (rw) */
    unsigned __sfrbit32 reserved_9:7;    /**< \brief [15:9] \internal Reserved */
    unsigned __sfrbit32 GID1:4;          /**< \brief [19:16] Group Index 1. - GID1 (rw) */
    unsigned __sfrbit32 ALID1:5;         /**< \brief [24:20] Alarm Identifier 1. - ALID1 (rw) */
    unsigned __sfrbit32 reserved_25:7;    /**< \brief [31:25] \internal Reserved */
} Ifx_SMU_RTAC00_Bits;

/** \brief Recovery Timer 0 Alarm Configuration 1 */
typedef struct _Ifx_SMU_RTAC01_Bits
{
    unsigned __sfrbit32 GID2:4;          /**< \brief [3:0] Group Index 2. - GID2 (rw) */
    unsigned __sfrbit32 ALID2:5;         /**< \brief [8:4] Alarm Identifier 0. - ALID2 (rw) */
    unsigned __sfrbit32 reserved_9:7;    /**< \brief [15:9] \internal Reserved */
    unsigned __sfrbit32 GID3:4;          /**< \brief [19:16] Group Index 3. - GID3 (rw) */
    unsigned __sfrbit32 ALID3:5;         /**< \brief [24:20] Alarm Identifier 1. - ALID3 (rw) */
    unsigned __sfrbit32 reserved_25:7;    /**< \brief [31:25] \internal Reserved */
} Ifx_SMU_RTAC01_Bits;

/** \brief Recovery Timer 1 Alarm Configuration 0 */
typedef struct _Ifx_SMU_RTAC10_Bits
{
    unsigned __sfrbit32 GID0:4;          /**< \brief [3:0] Group Index 0. - GID0 (rw) */
    unsigned __sfrbit32 ALID0:5;         /**< \brief [8:4] Alarm Identifier 0. - ALID0 (rw) */
    unsigned __sfrbit32 reserved_9:7;    /**< \brief [15:9] \internal Reserved */
    unsigned __sfrbit32 GID1:4;          /**< \brief [19:16] Group Index 1. - GID1 (rw) */
    unsigned __sfrbit32 ALID1:5;         /**< \brief [24:20] Alarm Identifier 1. - ALID1 (rw) */
    unsigned __sfrbit32 reserved_25:7;    /**< \brief [31:25] \internal Reserved */
} Ifx_SMU_RTAC10_Bits;

/** \brief Recovery Timer 1 Alarm Configuration 1 */
typedef struct _Ifx_SMU_RTAC11_Bits
{
    unsigned __sfrbit32 GID2:4;          /**< \brief [3:0] Group Index 2. - GID2 (rw) */
    unsigned __sfrbit32 ALID2:5;         /**< \brief [8:4] Alarm Identifier 2. - ALID2 (rw) */
    unsigned __sfrbit32 reserved_9:7;    /**< \brief [15:9] \internal Reserved */
    unsigned __sfrbit32 GID3:4;          /**< \brief [19:16] Group Index 3. - GID3 (rw) */
    unsigned __sfrbit32 ALID3:5;         /**< \brief [24:20] Alarm Identifier 3. - ALID3 (rw) */
    unsigned __sfrbit32 reserved_25:7;    /**< \brief [31:25] \internal Reserved */
} Ifx_SMU_RTAC11_Bits;

/** \brief Recovery Timer Configuration */
typedef struct _Ifx_SMU_RTC_Bits
{
    unsigned __sfrbit32 RT0E:1;          /**< \brief [0:0] RT0 Enable Bit - RT0E (rw) */
    unsigned __sfrbit32 RT1E:1;          /**< \brief [1:1] RT1 Enable Bit - RT1E (rw) */
    unsigned __sfrbit32 reserved_2:6;    /**< \brief [7:2] \internal Reserved */
    unsigned __sfrbit32 RTD:24;          /**< \brief [31:8] Recovery Timer Duration - RTD (rw) */
} Ifx_SMU_RTC_Bits;

/** \brief Status Register */
typedef struct _Ifx_SMU_STS_Bits
{
    unsigned __sfrbit32 CMD:4;           /**< \brief [3:0] Last command received - CMD (rwh) */
    unsigned __sfrbit32 ARG:4;           /**< \brief [7:4] Last command argument received - ARG (rwh) */
    unsigned __sfrbit32 RES:1;           /**< \brief [8:8] Result of last received command - RES (rwh) */
    unsigned __sfrbit32 ASCE:1;          /**< \brief [9:9] Alarm Status Clear Enable - ASCE (rwh) */
    unsigned __sfrbit32 FSP:2;           /**< \brief [11:10] Fault Signaling Protocol status - FSP (rh) */
    unsigned __sfrbit32 FSTS:1;          /**< \brief [12:12] Fault State Timing Status - FSTS (rwh) */
    unsigned __sfrbit32 reserved_13:3;    /**< \brief [15:13] \internal Reserved */
    unsigned __sfrbit32 RTS0:1;          /**< \brief [16:16] Recovery Timer 0 Status - RTS0 (rwh) */
    unsigned __sfrbit32 RTME0:1;         /**< \brief [17:17] Recovery Timer 0 Missed Event - RTME0 (rwh) */
    unsigned __sfrbit32 RTS1:1;          /**< \brief [18:18] Recovery Timer 1 Status - RTS1 (rwh) */
    unsigned __sfrbit32 RTME1:1;         /**< \brief [19:19] Recovery Timer 1 Missed Event - RTME1 (rwh) */
    unsigned __sfrbit32 reserved_20:12;    /**< \brief [31:20] \internal Reserved */
} Ifx_SMU_STS_Bits;

/** \}  */
/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_smu_Registers_union
 * \{   */
/** \brief SMU_core Access Enable Register 0   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SMU_ACCEN0_Bits B;            /**< \brief Bitfield access */
} Ifx_SMU_ACCEN0;

/** \brief SMU_core Access Enable Register 1   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SMU_ACCEN1_Bits B;            /**< \brief Bitfield access */
} Ifx_SMU_ACCEN1;

/** \brief Alarm Debug Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SMU_AD_Bits B;                /**< \brief Bitfield access */
} Ifx_SMU_AD;

/** \brief Alarm Executed Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SMU_AEX_Bits B;               /**< \brief Bitfield access */
} Ifx_SMU_AEX;

/** \brief Alarm Executed Status Clear Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SMU_AEXCLR_Bits B;            /**< \brief Bitfield access */
} Ifx_SMU_AEXCLR;

/** \brief Alarm and Fault Counter   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SMU_AFCNT_Bits B;             /**< \brief Bitfield access */
} Ifx_SMU_AFCNT;

/** \brief Alarm Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SMU_AG_Bits B;                /**< \brief Bitfield access */
} Ifx_SMU_AG;

/** \brief Alarm Global Configuration   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SMU_AGC_Bits B;               /**< \brief Bitfield access */
} Ifx_SMU_AGC;

/** \brief Alarm Configuration Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SMU_AGCF_Bits B;              /**< \brief Bitfield access */
} Ifx_SMU_AGCF;

/** \brief SMU_core FSP Configuration Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SMU_AGFSP_Bits B;             /**< \brief Bitfield access */
} Ifx_SMU_AGFSP;

/** \brief Clock Control Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SMU_CLC_Bits B;               /**< \brief Bitfield access */
} Ifx_SMU_CLC;

/** \brief Command Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SMU_CMD_Bits B;               /**< \brief Bitfield access */
} Ifx_SMU_CMD;

/** \brief Debug Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SMU_DBG_Bits B;               /**< \brief Bitfield access */
} Ifx_SMU_DBG;

/** \brief Fault Signaling Protocol   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SMU_FSP_Bits B;               /**< \brief Bitfield access */
} Ifx_SMU_FSP;

/** \brief Module Identification Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SMU_ID_Bits B;                /**< \brief Bitfield access */
} Ifx_SMU_ID;

/** \brief Key Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SMU_KEYS_Bits B;              /**< \brief Bitfield access */
} Ifx_SMU_KEYS;

/** \brief OCDS Control and Status   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SMU_OCS_Bits B;               /**< \brief Bitfield access */
} Ifx_SMU_OCS;

/** \brief Port Control   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SMU_PCTL_Bits B;              /**< \brief Bitfield access */
} Ifx_SMU_PCTL;

/** \brief Register Monitor Control   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SMU_RMCTL_Bits B;             /**< \brief Bitfield access */
} Ifx_SMU_RMCTL;

/** \brief Register Monitor Error Flags   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SMU_RMEF_Bits B;              /**< \brief Bitfield access */
} Ifx_SMU_RMEF;

/** \brief Register Monitor Self Test Status   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SMU_RMSTS_Bits B;             /**< \brief Bitfield access */
} Ifx_SMU_RMSTS;

/** \brief Recovery Timer 0 Alarm Configuration 0   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SMU_RTAC00_Bits B;            /**< \brief Bitfield access */
} Ifx_SMU_RTAC00;

/** \brief Recovery Timer 0 Alarm Configuration 1   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SMU_RTAC01_Bits B;            /**< \brief Bitfield access */
} Ifx_SMU_RTAC01;

/** \brief Recovery Timer 1 Alarm Configuration 0   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SMU_RTAC10_Bits B;            /**< \brief Bitfield access */
} Ifx_SMU_RTAC10;

/** \brief Recovery Timer 1 Alarm Configuration 1   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SMU_RTAC11_Bits B;            /**< \brief Bitfield access */
} Ifx_SMU_RTAC11;

/** \brief Recovery Timer Configuration   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SMU_RTC_Bits B;               /**< \brief Bitfield access */
} Ifx_SMU_RTC;

/** \brief Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_SMU_STS_Bits B;               /**< \brief Bitfield access */
} Ifx_SMU_STS;

/** \}  */

/******************************************************************************/
/** \addtogroup IfxSfr_Smu_Registers_struct
 * \{  */
/******************************************************************************/
/** \name Object L0
 * \{  */

/** \brief SMU object */
typedef volatile struct _Ifx_SMU
{
       Ifx_SMU_CLC                         CLC;                    /**< \brief 0, Clock Control Register*/
       Ifx_UReg_8Bit                       reserved_4[4];          /**< \brief 4, \internal Reserved */
       Ifx_SMU_ID                          ID;                     /**< \brief 8, Module Identification Register*/
       Ifx_UReg_8Bit                       reserved_C[20];         /**< \brief C, \internal Reserved */
       Ifx_SMU_CMD                         CMD;                    /**< \brief 20, Command Register*/
       Ifx_SMU_STS                         STS;                    /**< \brief 24, Status Register*/
       Ifx_SMU_FSP                         FSP;                    /**< \brief 28, Fault Signaling Protocol*/
       Ifx_SMU_AGC                         AGC;                    /**< \brief 2C, Alarm Global Configuration*/
       Ifx_SMU_RTC                         RTC;                    /**< \brief 30, Recovery Timer Configuration*/
       Ifx_SMU_KEYS                        KEYS;                   /**< \brief 34, Key Register*/
       Ifx_SMU_DBG                         DBG;                    /**< \brief 38, Debug Register*/
       Ifx_SMU_PCTL                        PCTL;                   /**< \brief 3C, Port Control*/
       Ifx_SMU_AFCNT                       AFCNT;                  /**< \brief 40, Alarm and Fault Counter*/
       Ifx_UReg_8Bit                       reserved_44[28];        /**< \brief 44, \internal Reserved */
       Ifx_SMU_RTAC00                      RTAC00;                 /**< \brief 60, Recovery Timer 0 Alarm Configuration 0*/
       Ifx_SMU_RTAC01                      RTAC01;                 /**< \brief 64, Recovery Timer 0 Alarm Configuration 1*/
       Ifx_SMU_RTAC10                      RTAC10;                 /**< \brief 68, Recovery Timer 1 Alarm Configuration 0*/
       Ifx_SMU_RTAC11                      RTAC11;                 /**< \brief 6C, Recovery Timer 1 Alarm Configuration 1*/
       Ifx_SMU_AEX                         AEX;                    /**< \brief 70, Alarm Executed Status Register*/
       Ifx_SMU_AEXCLR                      AEXCLR;                 /**< \brief 74, Alarm Executed Status Clear Register*/
       Ifx_UReg_8Bit                       reserved_78[136];       /**< \brief 78, \internal Reserved */
       Ifx_SMU_AGCF                        AGCF[12][3];            /**< \brief 100, */
       Ifx_SMU_AGFSP                       AGFSP[12];              /**< \brief 190, SMU_core FSP Configuration Register*/
       Ifx_SMU_AG                          AG[12];                 /**< \brief 1C0, Alarm Status Register*/
       Ifx_UReg_8Bit                       reserved_1F0[16];       /**< \brief 1F0, \internal Reserved */
       Ifx_SMU_AD                          AD[12];                 /**< \brief 200, Alarm Debug Register*/
       Ifx_UReg_8Bit                       reserved_230[208];      /**< \brief 230, \internal Reserved */
       Ifx_SMU_RMCTL                       RMCTL;                  /**< \brief 300, Register Monitor Control*/
       Ifx_SMU_RMEF                        RMEF;                   /**< \brief 304, Register Monitor Error Flags*/
       Ifx_SMU_RMSTS                       RMSTS;                  /**< \brief 308, Register Monitor Self Test Status*/
       Ifx_UReg_8Bit                       reserved_30C[1244];     /**< \brief 30C, \internal Reserved */
       Ifx_SMU_OCS                         OCS;                    /**< \brief 7E8, OCDS Control and Status*/
       Ifx_UReg_8Bit                       reserved_7EC[12];       /**< \brief 7EC, \internal Reserved */
       Ifx_SMU_ACCEN1                      ACCEN1;                 /**< \brief 7F8, SMU_core Access Enable Register 1*/
       Ifx_SMU_ACCEN0                      ACCEN0;                 /**< \brief 7FC, SMU_core Access Enable Register 0*/
} Ifx_SMU;

/** \}  */
/******************************************************************************/
/** \}  */


/******************************************************************************/

/******************************************************************************/


#line 57 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\Infra\\Sfr\\TC38A\\_Reg\\IfxSmu_reg.h"
/******************************************************************************/

/******************************************************************************/

/******************************************************************************/

/** \addtogroup IfxSfr_Smu_Registers_Cfg_BaseAddress
 * \{  */

/** \brief SMU object */

/** \}  */


/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Smu_Registers_Cfg_Smu
 * \{  */
/** \brief 0, Clock Control Register */


/** \brief 8, Module Identification Register */


/** \brief 20, Command Register */


/** \brief 24, Status Register */


/** \brief 28, Fault Signaling Protocol */


/** \brief 2C, Alarm Global Configuration */


/** \brief 30, Recovery Timer Configuration */


/** \brief 34, Key Register */


/** \brief 38, Debug Register */


/** \brief 3C, Port Control */


/** \brief 40, Alarm and Fault Counter */


/** \brief 60, Recovery Timer 0 Alarm Configuration 0 */


/** \brief 64, Recovery Timer 0 Alarm Configuration 1 */


/** \brief 68, Recovery Timer 1 Alarm Configuration 0 */


/** \brief 6C, Recovery Timer 1 Alarm Configuration 1 */


/** \brief 70, Alarm Executed Status Register */


/** \brief 74, Alarm Executed Status Clear Register */


/** \brief 100, Alarm Configuration Register */

/** Alias (User Manual Name) for SMU_AGCF0_0.
* To use register names with standard convension, please use SMU_AGCF0_0.
*/


/** \brief 104, Alarm Configuration Register */

/** Alias (User Manual Name) for SMU_AGCF0_1.
* To use register names with standard convension, please use SMU_AGCF0_1.
*/


/** \brief 108, Alarm Configuration Register */

/** Alias (User Manual Name) for SMU_AGCF0_2.
* To use register names with standard convension, please use SMU_AGCF0_2.
*/


/** \brief 10C, Alarm Configuration Register */

/** Alias (User Manual Name) for SMU_AGCF1_0.
* To use register names with standard convension, please use SMU_AGCF1_0.
*/


/** \brief 110, Alarm Configuration Register */

/** Alias (User Manual Name) for SMU_AGCF1_1.
* To use register names with standard convension, please use SMU_AGCF1_1.
*/


/** \brief 114, Alarm Configuration Register */

/** Alias (User Manual Name) for SMU_AGCF1_2.
* To use register names with standard convension, please use SMU_AGCF1_2.
*/


/** \brief 118, Alarm Configuration Register */

/** Alias (User Manual Name) for SMU_AGCF2_0.
* To use register names with standard convension, please use SMU_AGCF2_0.
*/


/** \brief 11C, Alarm Configuration Register */

/** Alias (User Manual Name) for SMU_AGCF2_1.
* To use register names with standard convension, please use SMU_AGCF2_1.
*/


/** \brief 120, Alarm Configuration Register */

/** Alias (User Manual Name) for SMU_AGCF2_2.
* To use register names with standard convension, please use SMU_AGCF2_2.
*/


/** \brief 124, Alarm Configuration Register */

/** Alias (User Manual Name) for SMU_AGCF3_0.
* To use register names with standard convension, please use SMU_AGCF3_0.
*/


/** \brief 128, Alarm Configuration Register */

/** Alias (User Manual Name) for SMU_AGCF3_1.
* To use register names with standard convension, please use SMU_AGCF3_1.
*/


/** \brief 12C, Alarm Configuration Register */

/** Alias (User Manual Name) for SMU_AGCF3_2.
* To use register names with standard convension, please use SMU_AGCF3_2.
*/


/** \brief 130, Alarm Configuration Register */

/** Alias (User Manual Name) for SMU_AGCF4_0.
* To use register names with standard convension, please use SMU_AGCF4_0.
*/


/** \brief 134, Alarm Configuration Register */

/** Alias (User Manual Name) for SMU_AGCF4_1.
* To use register names with standard convension, please use SMU_AGCF4_1.
*/


/** \brief 138, Alarm Configuration Register */

/** Alias (User Manual Name) for SMU_AGCF4_2.
* To use register names with standard convension, please use SMU_AGCF4_2.
*/


/** \brief 13C, Alarm Configuration Register */

/** Alias (User Manual Name) for SMU_AGCF5_0.
* To use register names with standard convension, please use SMU_AGCF5_0.
*/


/** \brief 140, Alarm Configuration Register */

/** Alias (User Manual Name) for SMU_AGCF5_1.
* To use register names with standard convension, please use SMU_AGCF5_1.
*/


/** \brief 144, Alarm Configuration Register */

/** Alias (User Manual Name) for SMU_AGCF5_2.
* To use register names with standard convension, please use SMU_AGCF5_2.
*/


/** \brief 148, Alarm Configuration Register */

/** Alias (User Manual Name) for SMU_AGCF6_0.
* To use register names with standard convension, please use SMU_AGCF6_0.
*/


/** \brief 14C, Alarm Configuration Register */

/** Alias (User Manual Name) for SMU_AGCF6_1.
* To use register names with standard convension, please use SMU_AGCF6_1.
*/


/** \brief 150, Alarm Configuration Register */

/** Alias (User Manual Name) for SMU_AGCF6_2.
* To use register names with standard convension, please use SMU_AGCF6_2.
*/


/** \brief 154, Alarm Configuration Register */

/** Alias (User Manual Name) for SMU_AGCF7_0.
* To use register names with standard convension, please use SMU_AGCF7_0.
*/


/** \brief 158, Alarm Configuration Register */

/** Alias (User Manual Name) for SMU_AGCF7_1.
* To use register names with standard convension, please use SMU_AGCF7_1.
*/


/** \brief 15C, Alarm Configuration Register */

/** Alias (User Manual Name) for SMU_AGCF7_2.
* To use register names with standard convension, please use SMU_AGCF7_2.
*/


/** \brief 160, Alarm Configuration Register */

/** Alias (User Manual Name) for SMU_AGCF8_0.
* To use register names with standard convension, please use SMU_AGCF8_0.
*/


/** \brief 164, Alarm Configuration Register */

/** Alias (User Manual Name) for SMU_AGCF8_1.
* To use register names with standard convension, please use SMU_AGCF8_1.
*/


/** \brief 168, Alarm Configuration Register */

/** Alias (User Manual Name) for SMU_AGCF8_2.
* To use register names with standard convension, please use SMU_AGCF8_2.
*/


/** \brief 16C, Alarm Configuration Register */

/** Alias (User Manual Name) for SMU_AGCF9_0.
* To use register names with standard convension, please use SMU_AGCF9_0.
*/


/** \brief 170, Alarm Configuration Register */

/** Alias (User Manual Name) for SMU_AGCF9_1.
* To use register names with standard convension, please use SMU_AGCF9_1.
*/


/** \brief 174, Alarm Configuration Register */

/** Alias (User Manual Name) for SMU_AGCF9_2.
* To use register names with standard convension, please use SMU_AGCF9_2.
*/


/** \brief 178, Alarm Configuration Register */

/** Alias (User Manual Name) for SMU_AGCF10_0.
* To use register names with standard convension, please use SMU_AGCF10_0.
*/


/** \brief 17C, Alarm Configuration Register */

/** Alias (User Manual Name) for SMU_AGCF10_1.
* To use register names with standard convension, please use SMU_AGCF10_1.
*/


/** \brief 180, Alarm Configuration Register */

/** Alias (User Manual Name) for SMU_AGCF10_2.
* To use register names with standard convension, please use SMU_AGCF10_2.
*/


/** \brief 184, Alarm Configuration Register */

/** Alias (User Manual Name) for SMU_AGCF11_0.
* To use register names with standard convension, please use SMU_AGCF11_0.
*/


/** \brief 188, Alarm Configuration Register */

/** Alias (User Manual Name) for SMU_AGCF11_1.
* To use register names with standard convension, please use SMU_AGCF11_1.
*/


/** \brief 18C, Alarm Configuration Register */

/** Alias (User Manual Name) for SMU_AGCF11_2.
* To use register names with standard convension, please use SMU_AGCF11_2.
*/


/** \brief 190, SMU_core FSP Configuration Register */

/** Alias (User Manual Name) for SMU_AGFSP0.
* To use register names with standard convension, please use SMU_AGFSP0.
*/


/** \brief 194, SMU_core FSP Configuration Register */

/** Alias (User Manual Name) for SMU_AGFSP1.
* To use register names with standard convension, please use SMU_AGFSP1.
*/


/** \brief 198, SMU_core FSP Configuration Register */

/** Alias (User Manual Name) for SMU_AGFSP2.
* To use register names with standard convension, please use SMU_AGFSP2.
*/


/** \brief 19C, SMU_core FSP Configuration Register */

/** Alias (User Manual Name) for SMU_AGFSP3.
* To use register names with standard convension, please use SMU_AGFSP3.
*/


/** \brief 1A0, SMU_core FSP Configuration Register */

/** Alias (User Manual Name) for SMU_AGFSP4.
* To use register names with standard convension, please use SMU_AGFSP4.
*/


/** \brief 1A4, SMU_core FSP Configuration Register */

/** Alias (User Manual Name) for SMU_AGFSP5.
* To use register names with standard convension, please use SMU_AGFSP5.
*/


/** \brief 1A8, SMU_core FSP Configuration Register */

/** Alias (User Manual Name) for SMU_AGFSP6.
* To use register names with standard convension, please use SMU_AGFSP6.
*/


/** \brief 1AC, SMU_core FSP Configuration Register */

/** Alias (User Manual Name) for SMU_AGFSP7.
* To use register names with standard convension, please use SMU_AGFSP7.
*/


/** \brief 1B0, SMU_core FSP Configuration Register */

/** Alias (User Manual Name) for SMU_AGFSP8.
* To use register names with standard convension, please use SMU_AGFSP8.
*/


/** \brief 1B4, SMU_core FSP Configuration Register */

/** Alias (User Manual Name) for SMU_AGFSP9.
* To use register names with standard convension, please use SMU_AGFSP9.
*/


/** \brief 1B8, SMU_core FSP Configuration Register */

/** Alias (User Manual Name) for SMU_AGFSP10.
* To use register names with standard convension, please use SMU_AGFSP10.
*/


/** \brief 1BC, SMU_core FSP Configuration Register */

/** Alias (User Manual Name) for SMU_AGFSP11.
* To use register names with standard convension, please use SMU_AGFSP11.
*/


/** \brief 1C0, Alarm Status Register */


/** \brief 1C4, Alarm Status Register */


/** \brief 1C8, Alarm Status Register */


/** \brief 1CC, Alarm Status Register */


/** \brief 1D0, Alarm Status Register */


/** \brief 1D4, Alarm Status Register */


/** \brief 1D8, Alarm Status Register */


/** \brief 1DC, Alarm Status Register */


/** \brief 1E0, Alarm Status Register */


/** \brief 1E4, Alarm Status Register */


/** \brief 1E8, Alarm Status Register */


/** \brief 1EC, Alarm Status Register */


/** \brief 200, Alarm Debug Register */


/** \brief 204, Alarm Debug Register */


/** \brief 208, Alarm Debug Register */


/** \brief 20C, Alarm Debug Register */


/** \brief 210, Alarm Debug Register */


/** \brief 214, Alarm Debug Register */


/** \brief 218, Alarm Debug Register */


/** \brief 21C, Alarm Debug Register */


/** \brief 220, Alarm Debug Register */


/** \brief 224, Alarm Debug Register */


/** \brief 228, Alarm Debug Register */


/** \brief 22C, Alarm Debug Register */


/** \brief 300, Register Monitor Control */


/** \brief 304, Register Monitor Error Flags */


/** \brief 308, Register Monitor Self Test Status */


/** \brief 7E8, OCDS Control and Status */


/** \brief 7F8, SMU_core Access Enable Register 1 */


/** \brief 7FC, SMU_core Access Enable Register 0 */



/** \}  */

/******************************************************************************/

/******************************************************************************/


#line 200 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Scu\\Std\\IfxScuCcu.h"

/******************************************************************************/
/*-----------------------------------Macros-----------------------------------*/
/******************************************************************************/

/** \brief Oscillator stability check timeout count
 */




/** \brief
 */


/** \brief ~40uS max wait time
 */




/** \brief ~122uS max wait time for PLL locking
 */


/** \brief ~122uS max wait time for PLL power down/up state update
 */


/** \brief ~244uS max wait time
 */


/** \brief 3mS max wait time for PLL power down/up state update
 */














/** \brief Modulation frequency
 */


/** \brief MODCFG shift value for SYSPLLCON2
 */


/** \brief MODCFG default value - for SYSPLLCON2[15:10]
 */


/** \brief get Rgain from MA and FDco
 */


/** \brief Get RGAin HEX from RGain Nominal value
 */


/** \brief Get MODCFG from RGAIN_HEX
 */


/** \brief Define to include the flash wait state check in ScuCcu_init()
 */


/** \brief 10 microsecond wait time between steps to jump back to normal mode.
 */




/******************************************************************************/
/*------------------------------Type Definitions------------------------------*/
/******************************************************************************/

/** \brief Function pointer type for the hooks
 * \return None
 */
typedef void (*IfxScuCcu_PllStepsFunctionHook)(void);

/******************************************************************************/
/*--------------------------------Enumerations--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Scu_Std_Ccu_Enum
 * \{ */
/** \brief clock source selection
 */
typedef enum
{
    IfxScuCcu_Fsource_0 = 0,      /**< \brief fSource0  */
    IfxScuCcu_Fsource_1,          /**< \brief fSource1  */
    IfxScuCcu_Fsource_2           /**< \brief fSource2  */
} IfxScuCcu_Fsource;

/** \brief MODULE_SCU.PLLCON1.B.K2DIV, specifies the K2-Divider
 */
typedef enum
{
    IfxScuCcu_K2divider_1 = 0,      /**< \brief K2-Divider 1  */
    IfxScuCcu_K2divider_2,          /**< \brief K2-Divider 2  */
    IfxScuCcu_K2divider_3,          /**< \brief K2-Divider 3  */
    IfxScuCcu_K2divider_4,          /**< \brief K2-Divider 4  */
    IfxScuCcu_K2divider_5,          /**< \brief K2-Divider 5  */
    IfxScuCcu_K2divider_6,          /**< \brief K2-Divider 6  */
    IfxScuCcu_K2divider_7,          /**< \brief K2-Divider 7  */
    IfxScuCcu_K2divider_8           /**< \brief K2-Divider 8  */
} IfxScuCcu_K2divider;

/** \brief MODULE_SCU.PLLCON1.B.K3DIV, specifies the K3-Divider
 */
typedef enum
{
    IfxScuCcu_K3divider_1 = 0,      /**< \brief K3-Divider 1  */
    IfxScuCcu_K3divider_2,          /**< \brief K3-Divider 2  */
    IfxScuCcu_K3divider_3,          /**< \brief K3-Divider 3  */
    IfxScuCcu_K3divider_4,          /**< \brief K3-Divider 4  */
    IfxScuCcu_K3divider_5,          /**< \brief K3-Divider 5  */
    IfxScuCcu_K3divider_6,          /**< \brief K3-Divider 6  */
    IfxScuCcu_K3divider_7,          /**< \brief K3-Divider 7  */
    IfxScuCcu_K3divider_8           /**< \brief K3-Divider 8  */
} IfxScuCcu_K3divider;

/** \brief Low Power Division Ratios.
 * Corresponds to values of LPDIV in CCUCON0.
 */
typedef enum
{
    IfxScuCcu_LowPowerDivRatio_divBy30 = 1,  /**< \brief Divide by 30 */
    IfxScuCcu_LowPowerDivRatio_divBy60,      /**< \brief Divide by 60 */
    IfxScuCcu_LowPowerDivRatio_divBy120,     /**< \brief Divide by 120 */
    IfxScuCcu_LowPowerDivRatio_divBy240      /**< \brief Divide by 240 */
} IfxScuCcu_LowPowerDivRatio;

/** \brief ENUM for MA (%) values
 */
typedef enum
{
    IfxScuCcu_ModulationAmplitude_0p5 = 0,      /**< \brief 0.5%  */
    IfxScuCcu_ModulationAmplitude_1p0,          /**< \brief 1.0%  */
    IfxScuCcu_ModulationAmplitude_1p25,         /**< \brief 1.25%  */
    IfxScuCcu_ModulationAmplitude_1p5,          /**< \brief 1.5%  */
    IfxScuCcu_ModulationAmplitude_2p0,          /**< \brief 2%  */
    IfxScuCcu_ModulationAmplitude_2p5,          /**< \brief 2.5%  */
    IfxScuCcu_ModulationAmplitude_count,        /**< \brief range  */
} IfxScuCcu_ModulationAmplitude;

/** \brief MODULE_SCU.PLLCON0.B.NDIV, specifies the N-Divider
 */
typedef enum
{
    IfxScuCcu_Ndivider_1 = 0,      /**< \brief  N-divider 1  */
    IfxScuCcu_Ndivider_2,          /**< \brief  N-divider 2  */
    IfxScuCcu_Ndivider_3,          /**< \brief  N-divider 3  */
    IfxScuCcu_Ndivider_4,          /**< \brief  N-divider 4  */
    IfxScuCcu_Ndivider_5,          /**< \brief  N-divider 5  */
    IfxScuCcu_Ndivider_6,          /**< \brief  N-divider 6  */
    IfxScuCcu_Ndivider_7,          /**< \brief  N-divider 7  */
    IfxScuCcu_Ndivider_8,          /**< \brief  N-divider 8  */
    IfxScuCcu_Ndivider_9,          /**< \brief  N-divider 9  */
    IfxScuCcu_Ndivider_10,         /**< \brief  N-divider 10  */
    IfxScuCcu_Ndivider_11,         /**< \brief  N-divider 11  */
    IfxScuCcu_Ndivider_12,         /**< \brief  N-divider 12  */
    IfxScuCcu_Ndivider_13,         /**< \brief  N-divider 13  */
    IfxScuCcu_Ndivider_14,         /**< \brief  N-divider 14  */
    IfxScuCcu_Ndivider_15,         /**< \brief  N-divider 15  */
    IfxScuCcu_Ndivider_16,         /**< \brief  N-divider 16  */
    IfxScuCcu_Ndivider_17,         /**< \brief  N-divider 17  */
    IfxScuCcu_Ndivider_18,         /**< \brief  N-divider 18  */
    IfxScuCcu_Ndivider_19,         /**< \brief  N-divider 19  */
    IfxScuCcu_Ndivider_20,         /**< \brief  N-divider 20  */
    IfxScuCcu_Ndivider_21,         /**< \brief  N-divider 21  */
    IfxScuCcu_Ndivider_22,         /**< \brief  N-divider 22  */
    IfxScuCcu_Ndivider_23,         /**< \brief  N-divider 23  */
    IfxScuCcu_Ndivider_24,         /**< \brief  N-divider 24  */
    IfxScuCcu_Ndivider_25,         /**< \brief  N-divider 25  */
    IfxScuCcu_Ndivider_26,         /**< \brief  N-divider 26  */
    IfxScuCcu_Ndivider_27,         /**< \brief  N-divider 27  */
    IfxScuCcu_Ndivider_28,         /**< \brief  N-divider 28  */
    IfxScuCcu_Ndivider_29,         /**< \brief  N-divider 29  */
    IfxScuCcu_Ndivider_30,         /**< \brief  N-divider 30  */
    IfxScuCcu_Ndivider_31,         /**< \brief  N-divider 31  */
    IfxScuCcu_Ndivider_32,         /**< \brief  N-divider 32  */
    IfxScuCcu_Ndivider_33,         /**< \brief  N-divider 33  */
    IfxScuCcu_Ndivider_34,         /**< \brief  N-divider 34  */
    IfxScuCcu_Ndivider_35,         /**< \brief  N-divider 35  */
    IfxScuCcu_Ndivider_36,         /**< \brief  N-divider 36  */
    IfxScuCcu_Ndivider_37,         /**< \brief  N-divider 37  */
    IfxScuCcu_Ndivider_38,         /**< \brief  N-divider 38  */
    IfxScuCcu_Ndivider_39,         /**< \brief  N-divider 39  */
    IfxScuCcu_Ndivider_40,         /**< \brief  N-divider 40  */
    IfxScuCcu_Ndivider_41,         /**< \brief  N-divider 41  */
    IfxScuCcu_Ndivider_42,         /**< \brief  N-divider 42  */
    IfxScuCcu_Ndivider_43,         /**< \brief  N-divider 43  */
    IfxScuCcu_Ndivider_44,         /**< \brief  N-divider 44  */
    IfxScuCcu_Ndivider_45,         /**< \brief  N-divider 45  */
    IfxScuCcu_Ndivider_46,         /**< \brief  N-divider 46  */
    IfxScuCcu_Ndivider_47,         /**< \brief  N-divider 47  */
    IfxScuCcu_Ndivider_48,         /**< \brief  N-divider 48  */
    IfxScuCcu_Ndivider_49,         /**< \brief  N-divider 49  */
    IfxScuCcu_Ndivider_50,         /**< \brief  N-divider 50  */
    IfxScuCcu_Ndivider_51,         /**< \brief  N-divider 51  */
    IfxScuCcu_Ndivider_52,         /**< \brief  N-divider 52  */
    IfxScuCcu_Ndivider_53,         /**< \brief  N-divider 53  */
    IfxScuCcu_Ndivider_54,         /**< \brief  N-divider 54  */
    IfxScuCcu_Ndivider_55,         /**< \brief  N-divider 55  */
    IfxScuCcu_Ndivider_56,         /**< \brief  N-divider 56  */
    IfxScuCcu_Ndivider_57,         /**< \brief  N-divider 57  */
    IfxScuCcu_Ndivider_58,         /**< \brief  N-divider 58  */
    IfxScuCcu_Ndivider_59,         /**< \brief  N-divider 59  */
    IfxScuCcu_Ndivider_60,         /**< \brief  N-divider 60  */
    IfxScuCcu_Ndivider_61,         /**< \brief  N-divider 61  */
    IfxScuCcu_Ndivider_62,         /**< \brief  N-divider 62  */
    IfxScuCcu_Ndivider_63,         /**< \brief  N-divider 63  */
    IfxScuCcu_Ndivider_64,         /**< \brief  N-divider 64  */
    IfxScuCcu_Ndivider_65,         /**< \brief  N-divider 65  */
    IfxScuCcu_Ndivider_66,         /**< \brief  N-divider 66  */
    IfxScuCcu_Ndivider_67,         /**< \brief  N-divider 67  */
    IfxScuCcu_Ndivider_68,         /**< \brief  N-divider 68  */
    IfxScuCcu_Ndivider_69,         /**< \brief  N-divider 69  */
    IfxScuCcu_Ndivider_70,         /**< \brief  N-divider 70  */
    IfxScuCcu_Ndivider_71,         /**< \brief  N-divider 71  */
    IfxScuCcu_Ndivider_72,         /**< \brief  N-divider 72  */
    IfxScuCcu_Ndivider_73,         /**< \brief  N-divider 73  */
    IfxScuCcu_Ndivider_74,         /**< \brief  N-divider 74  */
    IfxScuCcu_Ndivider_75,         /**< \brief  N-divider 75  */
    IfxScuCcu_Ndivider_76,         /**< \brief  N-divider 76  */
    IfxScuCcu_Ndivider_77,         /**< \brief  N-divider 77  */
    IfxScuCcu_Ndivider_78,         /**< \brief  N-divider 78  */
    IfxScuCcu_Ndivider_79,         /**< \brief  N-divider 79  */
    IfxScuCcu_Ndivider_80,         /**< \brief  N-divider 80  */
    IfxScuCcu_Ndivider_81,         /**< \brief  N-divider 81  */
    IfxScuCcu_Ndivider_82,         /**< \brief  N-divider 82  */
    IfxScuCcu_Ndivider_83,         /**< \brief  N-divider 83  */
    IfxScuCcu_Ndivider_84,         /**< \brief  N-divider 84  */
    IfxScuCcu_Ndivider_85,         /**< \brief  N-divider 85  */
    IfxScuCcu_Ndivider_86,         /**< \brief  N-divider 86  */
    IfxScuCcu_Ndivider_87,         /**< \brief  N-divider 87  */
    IfxScuCcu_Ndivider_88,         /**< \brief  N-divider 88  */
    IfxScuCcu_Ndivider_89,         /**< \brief  N-divider 89  */
    IfxScuCcu_Ndivider_90,         /**< \brief  N-divider 90  */
    IfxScuCcu_Ndivider_91,         /**< \brief  N-divider 91  */
    IfxScuCcu_Ndivider_92,         /**< \brief  N-divider 92  */
    IfxScuCcu_Ndivider_93,         /**< \brief  N-divider 93  */
    IfxScuCcu_Ndivider_94,         /**< \brief  N-divider 94  */
    IfxScuCcu_Ndivider_95,         /**< \brief  N-divider 95  */
    IfxScuCcu_Ndivider_96,         /**< \brief  N-divider 96  */
    IfxScuCcu_Ndivider_97,         /**< \brief  N-divider 97  */
    IfxScuCcu_Ndivider_98,         /**< \brief  N-divider 98  */
    IfxScuCcu_Ndivider_99,         /**< \brief  N-divider 99  */
    IfxScuCcu_Ndivider_100,        /**< \brief  N-divider 100  */
    IfxScuCcu_Ndivider_101,        /**< \brief  N-divider 101  */
    IfxScuCcu_Ndivider_102,        /**< \brief  N-divider 102  */
    IfxScuCcu_Ndivider_103,        /**< \brief  N-divider 103  */
    IfxScuCcu_Ndivider_104,        /**< \brief  N-divider 104  */
    IfxScuCcu_Ndivider_105,        /**< \brief  N-divider 105  */
    IfxScuCcu_Ndivider_106,        /**< \brief  N-divider 106  */
    IfxScuCcu_Ndivider_107,        /**< \brief  N-divider 107  */
    IfxScuCcu_Ndivider_108,        /**< \brief  N-divider 108  */
    IfxScuCcu_Ndivider_109,        /**< \brief  N-divider 109  */
    IfxScuCcu_Ndivider_110,        /**< \brief  N-divider 110  */
    IfxScuCcu_Ndivider_111,        /**< \brief  N-divider 111  */
    IfxScuCcu_Ndivider_112,        /**< \brief  N-divider 112  */
    IfxScuCcu_Ndivider_113,        /**< \brief  N-divider 113  */
    IfxScuCcu_Ndivider_114,        /**< \brief  N-divider 114  */
    IfxScuCcu_Ndivider_115,        /**< \brief  N-divider 115  */
    IfxScuCcu_Ndivider_116,        /**< \brief  N-divider 116  */
    IfxScuCcu_Ndivider_117,        /**< \brief  N-divider 117  */
    IfxScuCcu_Ndivider_118,        /**< \brief  N-divider 118  */
    IfxScuCcu_Ndivider_119,        /**< \brief  N-divider 119  */
    IfxScuCcu_Ndivider_120,        /**< \brief  N-divider 120  */
    IfxScuCcu_Ndivider_121,        /**< \brief  N-divider 121  */
    IfxScuCcu_Ndivider_122,        /**< \brief  N-divider 122  */
    IfxScuCcu_Ndivider_123,        /**< \brief  N-divider 123  */
    IfxScuCcu_Ndivider_124,        /**< \brief  N-divider 124  */
    IfxScuCcu_Ndivider_125,        /**< \brief  N-divider 125  */
    IfxScuCcu_Ndivider_126,        /**< \brief  N-divider 126  */
    IfxScuCcu_Ndivider_127,        /**< \brief  N-divider 127  */
    IfxScuCcu_Ndivider_128         /**< \brief  N-divider 128  */
} IfxScuCcu_Ndivider;

/** \brief MODULE_SCU.PLLCON0.B.PDIV, specifies the P-Divider
 */
typedef enum
{
    IfxScuCcu_Pdivider_1 = 0,      /**< \brief  P-divider 1  */
    IfxScuCcu_Pdivider_2,          /**< \brief  P-divider 2  */
    IfxScuCcu_Pdivider_3,          /**< \brief  P-divider 3  */
    IfxScuCcu_Pdivider_4,          /**< \brief  P-divider 4  */
    IfxScuCcu_Pdivider_5,          /**< \brief  P-divider 5  */
    IfxScuCcu_Pdivider_6,          /**< \brief  P-divider 6  */
    IfxScuCcu_Pdivider_7,          /**< \brief  P-divider 7  */
    IfxScuCcu_Pdivider_8           /**< \brief  P-divider 8  */
} IfxScuCcu_Pdivider;

/** \brief SysPll & Per Pll input clock selection.
 * SYSPLLCON0.B.INSEL
 */
typedef enum
{
    IfxScuCcu_PllInputClockSelection_fOsc1   = 0, /**< \brief Backup clock select */
    IfxScuCcu_PllInputClockSelection_fOsc0   = 1, /**< \brief fOsc0 or XTAL clock select */
    IfxScuCcu_PllInputClockSelection_fSysclk = 2  /**< \brief fOsc1 */
} IfxScuCcu_PllInputClockSelection;

/** \brief trap request type
 */
typedef enum
{
    IfxScuCcu_Traprequest_esr0 = 0,  /**< \brief external service request 0 */
    IfxScuCcu_Traprequest_esr1,      /**< \brief external service request 1 */
    IfxScuCcu_Traprequest_trap2,     /**< \brief trap2 */
    IfxScuCcu_Traprequest_smu        /**< \brief safety management unit */
} IfxScuCcu_Traprequest;

/** \} */

/** \brief modulation enable
 */
typedef enum
{
    IfxScuCcu_ModEn_disabled = 0,  /**< \brief disable modulation */
    IfxScuCcu_ModEn_enabled  = 1   /**< \brief enable modulation */
} IfxScuCcu_ModEn;

/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Scu_Std_Ccu_Ccu_Configuration
 * \{ */
/** \brief Configuration structure type for the Per Pll step.
 * This structure must be used to configure the P, N and K2, K3 dividers .
 */
typedef struct
{
    uint8 pDivider;              /**< \brief P divider value for basic (initial) step */
    uint8 nDivider;              /**< \brief N divider value for basic (initial) step */
    uint8 k2Divider;             /**< \brief K2 divider value */
    uint8 k3Divider;             /**< \brief K3 divider value */
    uint8 k3DividerBypass;       /**< \brief Divider Bypass
                                  * 0 - The divide by block in front of the K3-Divider is not bypassed.
                                  * 1-  The divide by block in front of the K3-Divider is bypassed. */
} IfxScuCcu_PerPllConfig;

/** \brief Configuration structure type for the Pll initial step.
 * This structure must be used to configure the P, N and K2 dividers for initial step.
 */
typedef struct
{
    uint8 pDivider;        /**< \brief P divider value */
    uint8 nDivider;        /**< \brief N divider value */
    uint8 k2Divider;       /**< \brief K2 divider value */
} IfxScuCcu_SysPllConfig;

/** \} */

/** \addtogroup IfxLld_Scu_Std_Ccu_Ccu_Configuration
 * \{ */
/** \brief Configuration structure type for CCUCON registers.
 */
typedef struct
{
    uint32 value;       /**< \brief CCUCON Register value to be updated. */
    uint32 mask;        /**< \brief CCUCON Mask to select the bit fields to be updated. */
} IfxScuCcu_CcuconRegConfig;

/** \brief Configuration structure type for the Pll Steps for current jump control.
 */
typedef struct
{
    uint8   k2Step;         /**< \brief K2 divider value for this step. */
    float32 waitTime;       /**< \brief Wait time for for this step. */
} IfxScuCcu_PllStepConfig;

/** \brief Configuration structure type for the Pll Parameters.
 */
typedef struct
{
    uint32                           xtalFrequency;                /**< \brief Xtal frequency */
    IfxScuCcu_PllInputClockSelection pllInputClockSelection;       /**< \brief Pll input clock selection */
    IfxScuCcu_SysPllConfig           sysPllConfig;                 /**< \brief System PLL Configurations */
    IfxScuCcu_PerPllConfig           perPllConfig;                 /**< \brief Peripheral PLL Configurations */
} IfxScuCcu_pllsParameterConfig;

/** \} */

/** \addtogroup IfxLld_Scu_Std_Ccu_Ccu
 * \{ */
/** \brief Configuration structure type for the Flash waitstate configuration.
 */
typedef struct
{
    uint32 value;       /**< \brief FLASH.FCON Register value to be updated. */
    uint32 mask;        /**< \brief FLASH.FCON Mask to select the bit fields to be updated. */
} IfxScuCcu_FlashWaitstateConfig;

/** \} */

/** \addtogroup IfxLld_Scu_Std_Ccu_Ccu_Configuration
 * \{ */
/** \brief Configuration structure type for all the CCUCON registers to configure clock distribution.
 */
typedef struct
{
    IfxScuCcu_CcuconRegConfig ccucon0;       /**< \brief CCUCON0 Register configuration */
    IfxScuCcu_CcuconRegConfig ccucon1;       /**< \brief CCUCON1 Register configuration */
    IfxScuCcu_CcuconRegConfig ccucon2;       /**< \brief CCUCON2 Register configuration */
    IfxScuCcu_CcuconRegConfig ccucon5;       /**< \brief CCUCON5 Register configuration */
    IfxScuCcu_CcuconRegConfig ccucon6;       /**< \brief CCUCON6 Register configuration */
    IfxScuCcu_CcuconRegConfig ccucon7;       /**< \brief CCUCON7 Register configuration */
    IfxScuCcu_CcuconRegConfig ccucon8;       /**< \brief CCUCON8 Register configuration */
    IfxScuCcu_CcuconRegConfig ccucon9;       /**< \brief CCUCON9 Register configuration */
} IfxScuCcu_ClockDistributionConfig;

/** \brief Configuration structure type for the Pll Initial Step Configuration.
 */
typedef struct
{
    IfxScuCcu_pllsParameterConfig pllsParameters;       /**< \brief Configuration Parameters for both PLLs */
    float32                       waitTime;             /**< \brief Wait time for for basic (initial) step */
} IfxScuCcu_InitialStepConfig;

/** \brief
 */
typedef struct
{
    uint8                              numOfSteps;       /**< \brief Number of PLL divider steps during clock throttling */
    const IfxScuCcu_PllStepConfig *pllSteps;         /**< \brief Pointer to the array of Pll divider step configuration. */
} IfxScuCcu_PllThrottleConfig;

/** \} */

/** \brief modulation config
 */
typedef struct
{
    IfxScuCcu_ModEn               Mod_Enable;       /**< \brief modulation enable */
    IfxScuCcu_ModulationAmplitude Mod_Amp;          /**< \brief modulation amplitude */
} IfxScuCcu_Mod_Config;

/** \addtogroup IfxLld_Scu_Std_Ccu_Ccu_Configuration
 * \{ */
/** \brief Configuration structure SCU module
 */
typedef struct
{
    IfxScuCcu_InitialStepConfig               pllInitialStepConfig;           /**< \brief Configuration of first step which is same as internal osc frequency. */
    IfxScuCcu_PllThrottleConfig               sysPllThrottleConfig;           /**< \brief Configuration of PLL throttling. */
    IfxScuCcu_ClockDistributionConfig         clockDistribution;              /**< \brief Configuration of of bus clocks and other module clock distribution. */
    const IfxScuCcu_FlashWaitstateConfig *flashFconWaitStateConfig;       /**< \brief Configuration of flash waitstate */
    const IfxScuCcu_Mod_Config           *modulationConfig;               /**< \brief modulation configuration */
} IfxScuCcu_Config;

/** \} */

/** \brief structure holding the RGain parameters for modulation
 */
typedef struct
{
    float32 RGainNom;       /**< \brief RGain Nominal value */
    uint16  RGainHex;       /**< \brief RGain Hex value */
} IfxScuCcu_RGain_Values;

/** \addtogroup IfxLld_Scu_Std_Ccu_Ccu
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief API to wait for requested duration.
 * Note: IfxScuCcu_wait shall not use STM in future, because we can guarantee that STM is enabled after reset but  If PLL init is called for changing the frequency during runtime, there is no guarantee that STM is enabled
 * \return None
 */
static inline void IfxScuCcu_wait(float32 timeSec);

/** \brief API to wait for requested duration along with watchdog service to avoid any reset case during startup of the chip.
 * Note: IfxScuCcu_wait shall not use STM in future, because we can guarantee that STM is enabled after reset but  If PLL init is called for changing the frequency during runtime, there is no guarantee that STM is enabled
 * \return None
 */
static inline void IfxScuCcu_waitWithWdtService(float32 timeSec);

/** \brief API to configure the LPDIV value to enter into Low Power mode.
 *
 * Caution:
 * write to LPDIV with non-zero division ratio will cause system to enter low power mode.
 * Low power mode will affect different SPBDIV and SRIDIV ratios.
 *
 * The original CCUCON0 ratios should be preserved by user prior to calling this function.
 * The "normal" CCUCON0 ratios have to be passed to API: "IfxScuCcu_switchToNormalMode" to go back to the original division ratios.
 * \param lpDiv Low Power Division Ratio
 * \return None
 */
static inline void IfxScuCcu_switchToLowPowerMode(IfxScuCcu_LowPowerDivRatio lpDiv);

/** \brief API to switch back to normal mode from low power mode.
 *
 * Caution:
 * The original CCUCON0 setting has to be saved by user prior to entering Low Power mode.
 * Pass the original CCUCON0 register as a whole word to this function to restore the normal settings.
 *
 * Ramp back to normal mode is done in steps to avoid sudden jump in frequency and power usage.
 * \param ccucon0 CCUCON0 values at normal mode
 * \return None
 *
 * Switch to low power mode and back using iLLD functions as below
 * \code
 *     uint32 ccucon0 = SCU_CCUCON0.U;
 *     IfxScuCcu_LowPowerDivRatio lpDiv = IfxScuCcu_LowPowerDivRatio_divBy30;
 *     IfxScuCcu_switchToLowPowerMode(lpDiv);
 * \endcode
 *
 * Switch back to normal mode  with the saved ccucon0 value
 * \code
 *     IfxScuCcu_switchToNormalMode(ccucon0);
 * \endcode
 *
 */
static inline void IfxScuCcu_switchToNormalMode(const uint32 ccucon0);

/** \} */

/** \addtogroup IfxLld_Scu_Std_Ccu_Ccu_Operative
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief API to get Adc (EVADC, EDSADC)  frequency.
 * This API returns the based on the divider value in CCUCON register and fSOURCE.
 * \return Adc frequency (fADC) in Hz
 */
static inline float32 IfxScuCcu_getAdcFrequency(void);

/** \brief API to get ASCLINF divider frequency.
 * This API returns the based on the divider value in CCUCON register and fSOURCE.
 * \return AsclinF frequency (fASCLINF) in Hz
 */
static inline float32 IfxScuCcu_getAsclinFFrequency(void);

/** \brief API to get EVR Oscillator frequency.
 * This API returns the constant which is specific to the ScuCcu of the controller.
 * \return EVR Oscillator frequency (fBACK or fEVR) in Hz.
 */
static inline float32 IfxScuCcu_getEvrFrequency(void);

/** \brief API to get GETH divider frequency.
 * This API returns the based on the divider value in CCUCON register and fSOURCE.
 * \return GETH frequency (fGETH) in Hz
 */
static inline float32 IfxScuCcu_getGethFrequency(void);

/** \brief API to get GTMdivider frequency
 * This API returns the based on the divider value in CCUCON register and fSOURCE.
 * return GTM frequency (fGTM) in Hz
 * \return Gtm Frequency
 */
static inline float32 IfxScuCcu_getGtmFrequency(void);

/** \brief API to get I2C frequency.
 * This API returns the based on the divider value in CCUCON register and fSOURCE.
 * \return I2C frequency (fI2C) in Hz
 */
static inline float32 IfxScuCcu_getI2cFrequency(void);

/** \brief API to get MCANH divider frequency.
 * This API returns the based on the divider value in CCUCON register and fSOURCE.
 * \return MCANH frequency (fMCANH) in Hz
 */
static inline float32 IfxScuCcu_getMcanhFrequency(void);

/** \brief API to get Oscillator 0 frequency.
 * This API returns the fOsc0 frequency based on the divider value in CCUCON register and the input oscillator.
 * \return Osc0 frequency (fOSC0) in Hz.
 */
static inline float32 IfxScuCcu_getOsc0Frequency(void);

/** \brief API to get Oscillator 0 frequency.
 * This API returns the fOsc0 frequency based on the divider value in CCUCON register and the input oscillator.
 * \return Osc frequency (fOSC) in Hz.
 */
static inline float32 IfxScuCcu_getOscFrequency(void);

/** \brief Returns the clock source selection
 * \return Clock source selection
 */
static inline IfxScuCcu_PllInputClockSelection IfxScuCcu_getSourceSelection(void);

/** \brief API to get STM divider frequency.
 * This API returns the based on the divider value in CCUCON register and fSOURCE.
 * \return STM frequency (fSTM) in Hz
 */
static inline float32 IfxScuCcu_getStmFrequency(void);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief API to get ASCLINS divider frequency.
 * This API returns the ASCLINS frequency  based on the divider value in CCUCON register and fSOURCE.
 * \return AsclinS frequency (fASCLINS) in Hz
 */
extern float32 IfxScuCcu_getAsclinSFrequency(void);

/** \brief API to get BBB divider frequency.
 * This API returns the BBBDivider frequency based on the divider value in CCUCON register and the input oscillator.
 * \return BBB frequency (fBBB) in Hz
 */
extern float32 IfxScuCcu_getBbbFrequency(void);

/** \brief This API returns the Cpu frequency based on the divider value in CCUCON register and fSource frequency
 * \param cpu CPU number for which effective fCPU is sought
 * \return Cpu[x] frequency in Hz, where x is cpu number passed as parameter
 */
extern float32 IfxScuCcu_getCpuFrequency(const IfxCpu_ResourceCpu cpu);

/** \brief API to get FSI2 divider frequency in Hz.
 * This API returns the fFSI2 frequency based on the divider value in CCUCON register and the input oscillator.
 * \return FSI2 frequency (fFSI2) in Hz.
 */
extern float32 IfxScuCcu_getFsi2Frequency(void);

/** \brief API to get FSI divider frequency in Hz.
 * This API returns the fFSI based on the divider value in CCUCON register and the input oscillator.
 * \return FSI frequency (fFSI) in Hz.
 */
extern float32 IfxScuCcu_getFsiFrequency(void);

/** \brief API to get MCAN divider frequency.
 * This API returns the based on the divider value in CCUCON register and fSOURCE.
 * \return Mcan frequency (fMCAN) in Hz
 */
extern float32 IfxScuCcu_getMcanFrequency(void);

/** \brief get source frequency fSOURCE.
 * This API returns the source frequency based on the configurations with CCUCON register configuration.
 * \return Module frequency in Hz
 */
extern float32 IfxScuCcu_getModuleFrequency(void);

/** \brief API to get MSC divider frequency.
 * This API returns the based on the divider value in CCUCON register and fSOURCE.
 * \return Msc frequency (fMSC) in Hz
 */
extern float32 IfxScuCcu_getMscFrequency(void);

/** \brief API to get actual PER PLL1  frequency
 * This API returns the PER PLL1 frequency based on the K2 divider value in PLLCON and the VCO frequency.
 * Fpll1= (Fosc*N)/(P*K2)
 * \return PER PLL1 (K2 Divider) frequency in Hz
 */
extern float32 IfxScuCcu_getPerPllFrequency1(void);

/** \brief API to get actual PER PLL2 (K3 Divider) frequency
 * This API returns the PER PLL2 frequency based on the K3 divider value in PLLCON and the VCO frequency.
 * Fpll2= (Fosc*N)/(P*K3*1.6)  // DIVBY = 0,
 * Fpll2= (Fosc*N)/(P*K3*2)  // DIVBY = 1
 * \return PER PLL2 (K3 Divider ) frequency in Hz
 */
extern float32 IfxScuCcu_getPerPllFrequency2(void);

/** \brief API to get actual Sys PLL output frequency.
 * This API returns the based on the divider values in CCUCON, PLLCON registers and the input oscillator.
 * \return System Pll (fSysPLL) frequency in Hz
 */
extern float32 IfxScuCcu_getPllFrequency(void);

/** \brief API to get Qspi divider frequency.
 * This API returns the based on the divider value in CCUCON register and fSOURCE.
 * \return Qspi frequency (fQspi) in Hz
 */
extern float32 IfxScuCcu_getQspiFrequency(void);

/** \brief get source frequency fSOURCE.
 * This API returns the source frequency based on the configurations with CCUCON register configuration.
 * \param fsource fsource selection
 * \return Effective fSOURCE in Hz
 */
extern float32 IfxScuCcu_getSourceFrequency(IfxScuCcu_Fsource fsource);

/** \brief API to get SPB divider frequency.
 * This API returns the based on fSOURCE and also on Low power divider mode and/or SPBDIV divider value in CCUCON registers.
 * \return SPB frequency (fSPB) in Hz
 */
extern float32 IfxScuCcu_getSpbFrequency(void);

/** \brief API to get SRI divider frequency.
 * This API returns the Sri frequency based on the divider values in CCUCON registers and fSOURCE.
 * \return Sri frequency (fSRI) in Hz
 */
extern float32 IfxScuCcu_getSriFrequency(void);

/** \brief API to set ASCLINF frequency (with ASCLINF divider)
 * This API configure ASCLINF divider values in CCUCON registers. The actual frequency always depends on the feasibility with the divider value
 * \param asclinFFreq AsclinF frequency (fASCLINF) in Hz
 * \return Actual AsclinF frequency (fASCLINF) in Hz
 */
extern float32 IfxScuCcu_setAsclinFFrequency(float32 asclinFFreq);

/** \brief API to set ASCLINS frequency (with ASCLINS divider)
 * This API configure ASCLINS divider values in CCUCON registers. The actual frequency always depends on the feasibility with the divider value
 * \param asclinSFreq Desired AscLinS frequency in Hz
 * \return Actual AsclinS frequency (fASCLINS) in Hz
 */
extern float32 IfxScuCcu_setAsclinSFrequency(float32 asclinSFreq);

/** \brief API to set BBB frequency (with Bbb divider)
 * This API configure Bbb divider values in CCUCON registers. The actual frequency always depends on the feasibility with the divider value
 * \param bbbFreq Bbb frequency (fBBB) in Hz
 * \return Actual Bbb frequency (fBBB) in Hz
 */
extern float32 IfxScuCcu_setBbbFrequency(float32 bbbFreq);

/** \brief API to set CPU frequency (with CPU divider)
 * This API configure CPU divider values in CCUCON registers. The actual frequency is always depends on the feasibility with the divider value
 * \param cpu CPU number for which fCPU to be configured
 * \param cpuFreq Desired CPU frequency in Hz
 * \return Actual CPU[x] frequency in Hz, where x is the cpu number passed as parameter
 */
extern float32 IfxScuCcu_setCpuFrequency(IfxCpu_ResourceCpu cpu, float32 cpuFreq);

/** \brief API to set FSI2 frequency (with FSI2 divider)
 * This API configure Fsi2 divider values in CCUCON registers. The actual frequency always depends on the feasibility with the divider value
 * \param fsi2Freq FSI2 frequency (fFSI) in Hz
 * \return Actual Fsi2 frequency (fFSI2) in Hz
 */
extern float32 IfxScuCcu_setFsi2Frequency(float32 fsi2Freq);

/** \brief API to set FSI frequency (with FSI divider)
 * This API configure Fsi divider values in CCUCON registers. The actual frequency always depends on the feasibility with the divider value
 * \param fsiFreq FSI frequency (fFSI) in Hz
 * \return Actual Fsi frequency (fFSI) in Hz
 */
extern float32 IfxScuCcu_setFsiFrequency(float32 fsiFreq);

/** \brief API to set GETH frequency (with GETH divider)
 * This API configure geth divider values in CCUCON registers. The actual frequency always depends on the feasibility with the divider value
 * \param gethFreq GETH frequency (fGETH) in Hz
 * \return Actual Geth frequency (fGETH) in Hz
 */
extern float32 IfxScuCcu_setGethFrequency(float32 gethFreq);

/** \brief API to set GTM frequency (with GTM divider)
 * This API configure GTM divider values in CCUCON registers. The actual frequency always depends on the feasibility with the divider value
 * \param gtmFreq Desired GTM frequency in Hz
 * \return Actual GTM frequency in HZ
 */
extern float32 IfxScuCcu_setGtmFrequency(float32 gtmFreq);

/** \brief API to set I2C frequency (with I2C divider)
 * This API configure adas divider values in CCUCON registers. The actual frequency always depends on the feasibility with the divider value
 * \param i2cFreq I2C frequency (fI2C) in Hz
 * \return Actual I2C frequency (fI2C) in Hz
 */
extern float32 IfxScuCcu_setI2cFrequency(float32 i2cFreq);

/** \brief API to set MCAN frequency (with MCAN divider)
 * This API configure MCAN divider values in CCUCON registers. The actual frequency always depends on the feasibility with the divider value
 * \param mcanFreq Desired MSC frequency in Hz
 * \return Actual Mcan frequency (fMCAN) in Hz
 */
extern float32 IfxScuCcu_setMcanFrequency(float32 mcanFreq);

/** \brief API to set MCANH frequency (with MCANH divider)
 * This API configure mcanh divider values in CCUCON registers. The actual frequency always depends on the feasibility with the divider value
 * \param mcanhFreq MCANH frequency (fMCANH) in Hz
 * \return Actual MCanh frequency (fMCANH) in Hz
 */
extern float32 IfxScuCcu_setMcanhFrequency(float32 mcanhFreq);

/** \brief API to set MSC frequency (with MSC divider)
 * This API configure MSC divider values in CCUCON registers. The actual frequency always depends on the feasibility with the divider value
 * \param mscFreq Desired MSC frequency in Hz
 * \return Actual Msc frequency (fMSC) in Hz
 */
extern float32 IfxScuCcu_setMscFrequency(float32 mscFreq);

/** \brief API to set QSPI frequency (with QSPI divider)
 * This API configure Qspi divider values in CCUCON registers. The actual frequency always depends on the feasibility with the divider value
 * \param qspiFreq Desired QSPI frequency in Hz
 * \return Actual Qspi frequency (fQspi) in Hz
 */
extern float32 IfxScuCcu_setQspiFrequency(float32 qspiFreq);

/** \brief API to set SPB frequency (with SPB divider)
 * This API configure SPB divider values in CCUCON registers. The actual frequency always depends on the feasibility with the divider value
 * \param spbFreq Desired SPB frequency in Hz
 * \return Actual SPB frequency in Hz
 */
extern float32 IfxScuCcu_setSpbFrequency(float32 spbFreq);

/** \brief API to set SRI frequency (with SRI divider)
 * This API configure Sri divider values in CCUCON registers. The actual frequency always depends on the feasibility with the divider value
 * \param sriFreq Sri frequency (fSRI) in Hz
 * \return Actual Sri frequency (fSRI) in Hz
 */
extern float32 IfxScuCcu_setSriFrequency(float32 sriFreq);

/** \brief API to set STM frequency (with STM divider)
 * This API configure Stm divider values in CCUCON registers. The actual frequency always depends on the feasibility with the divider value
 * \param stmFreq Stm frequency (fASCLINF) in Hz
 * \return Actual Stm frequency (fSTM) in Hz
 */
extern float32 IfxScuCcu_setStmFrequency(float32 stmFreq);

/** \} */

/** \addtogroup IfxLld_Scu_Std_Ccu_Ccu_Configuration
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief This inline function configures the Ccu SYS PLLs initial step and PER PLL.
 */
static inline boolean IfxScuCcu_configureCcuInitialStep(const IfxScuCcu_InitialStepConfig *pllInitStepCfg);

/** \brief Inlined API for clock distribution
 * For each CCUCON register update the configured value with the mask.
 * \param clockDistributionConfig pointer to clock distribution structure
 * \return TRUE: Operation successful, FALSE: Operation Failure
 */
static inline boolean IfxScuCcu_distributeClockInline(const IfxScuCcu_ClockDistributionConfig *clockDistributionConfig);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief API for clock distribution.
 * \return None
 */
extern void IfxScuCcu_distributeClock(IfxScuCcu_ClockDistributionConfig *clockDistributionConfig);

/** \brief API to initialize the SCU Clock Control Unit.
 * This API initialize the Sys PLL with ramp steps, BUS dividers and Per PLL for the configuration provided by the configuration structure.
 * FSyspll = (Fosc * Nsys)/(Psys * K2sys);
 * Fpll1= (Fosc * Nper)/(Pper * K2per);
 * Fpll2= (Fosc * Nper)/(Pper * K3per * 1.6); // if DIVBY = 0, else Fpll2= (Fosc * Nper)/(Pper * K3per * 2) // if DIVBY = 1
 *
 * Note: Following SMU alarms are disabled before the PLL configuration and Enabled at the end of PLL lock in the function.
 * PLL0,1,2 clock out of range frequency
 * PLL0,1 VCO loss of lock event
 * System PLL Oscillator Watchdog, input clock out of range
 * The application should store/restore these alarm configurations if required.
 * \param config Pointer to the configuration structure of the ScuCcu
 * \return Error status of the ScuCcu initialization process.
 * \retval TRUE: If an error occurred during initialization.
 * \retval FALSE: If initialization was successful.
 */
extern boolean IfxScuCcu_init(const IfxScuCcu_Config *config);

/** \brief Initializes the clock configuration with default values
 * \param cfg Pointer to the configuration structure of the ScuCcu
 * \return None
 */
extern void IfxScuCcu_initConfig(IfxScuCcu_Config *cfg);

/** \brief API to switch to Backup clock from the current PLL frequency.
 * \param cfg Pointer to the configuration structure of the ScuCcu
 * \return None
 */
extern void IfxScuCcu_switchToBackupClock(const IfxScuCcu_Config *cfg);

/** \} */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Clear the trap status flag.
 * \param request Trap request type.
 * \return None
 */
static inline void IfxScuCcu_clearTrapStatusFlag(IfxScuCcu_Traprequest request);

/** \brief Get trap disable flag.
 * \param cpuIndex Cpu index
 * \param request Trap request type.
 * \return Trap request can be generated or not.
 */
static inline boolean IfxScuCcu_getTrapDisableFlag(IfxCpu_ResourceCpu cpuIndex, IfxScuCcu_Traprequest request);

/** \brief Get the trap status.
 * \param request Trap request type.
 * \return Trap was requested or not.
 */
static inline boolean IfxScuCcu_getTrapStatusFlag(IfxScuCcu_Traprequest request);

/** \brief Set the trap disable flag
 * \param cpuIndex Cpu index.
 * \param request Trap request type.
 * \return None
 */
static inline void IfxScuCcu_setTrapDisableFlag(IfxCpu_ResourceCpu cpuIndex, IfxScuCcu_Traprequest request);

/** \brief Set the trap status flag.
 * \param request Trap request type.
 * \return None
 */
static inline void IfxScuCcu_setTrapStatusFlag(IfxScuCcu_Traprequest request);

/**
 */
static inline boolean IfxScuCcu_throttleSysPllClockInline(const IfxScuCcu_PllThrottleConfig *pllThrottleConfig);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/**
 * \param modamp modulation amplitude
 * \param RGain_P RGain values
 * \return None
 */
extern void IfxScuCcu_calRGainParameters(IfxScuCcu_ModulationAmplitude modamp, IfxScuCcu_RGain_Values *RGain_P);

/** \brief initialize modulation parameters
 * \param Mod_Cfg modulation configuration
 * \return None
 */
extern void IfxScuCcu_modulation_init(const IfxScuCcu_Mod_Config *Mod_Cfg);

/**
 * \return None
 */
extern void IfxScuCcu_throttleSysPllClock(IfxScuCcu_PllThrottleConfig *pllThrottleConfig);

/******************************************************************************/
/*-------------------Global Exported Variables/Constants----------------------*/
/******************************************************************************/

/** \brief maps to the IfxScuCcu_ModulationAmplitude enum
 */
extern const float32 IfxScuCcu_MA_percent[IfxScuCcu_ModulationAmplitude_count];

/** \brief Configuration structure for SCU CCU driver.
 * The values of this structure are defined as # defined macros in the implementation of Scu
 */
extern const IfxScuCcu_Config     IfxScuCcu_defaultClockConfig;

/** \brief default modulation config
 */
extern const IfxScuCcu_Mod_Config IfxScuCcu_defaultModConfig;

extern uint32                         IfxScuCcu_xtalFrequency;

/******************************************************************************/
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

static inline void IfxScuCcu_clearTrapStatusFlag(IfxScuCcu_Traprequest request)
{
    uint32 trapclear = 1;
    (*(volatile Ifx_SCU_TRAPCLR*)0xF003612Cu).U |= (trapclear << request);
}


static inline boolean IfxScuCcu_configureCcuInitialStep(const IfxScuCcu_InitialStepConfig *pllInitStepCfg)
{
    uint8                                initError = 0;
    uint16                               endinitSfty_pw;

    uint32                               timeoutCycleCount;
    const IfxScuCcu_pllsParameterConfig *pllsParamCfg;
    pllsParamCfg   = &pllInitStepCfg->pllsParameters;
    /*get the watch-dog passwords for usage with this function*/
    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPasswordInline();

    /* Reset Safety ENDINIT, SCU_CCUCON registers are protected*/
    IfxScuWdt_clearSafetyEndinitInline(endinitSfty_pw);

    timeoutCycleCount = (0x1000U);

    while ((*(volatile Ifx_SCU_CCUCON0*)0xF0036030u).B.LCK != 0U)
    {
        {                                                    if (((sint32)--timeoutCycleCount) <= 0)                       {                                                    initError = (uint8)1;                                 break;                                       }                                                else                                             {                                                }                                            };
    }

    {
        Ifx_SCU_CCUCON0 scuCcucon0;
        scuCcucon0.U        = (*(volatile Ifx_SCU_CCUCON0*)0xF0036030u).U;
        scuCcucon0.B.CLKSEL = 0; /*Select the EVR as fsource0/1/2 for the clock distribution */
        scuCcucon0.B.UP     = 1; /*Update the ccucon0 register */
        (*(volatile Ifx_SCU_CCUCON0*)0xF0036030u).U       = scuCcucon0.U;
    }

    timeoutCycleCount = (0x1000U);

    while ((*(volatile Ifx_SCU_CCUCON0*)0xF0036030u).B.LCK != 0U)
    {
        {                                                    if (((sint32)--timeoutCycleCount) <= 0)                       {                                                    initError = (uint8)1;                                 break;                                       }                                                else                                             {                                                }                                            };
    }

    /*Disable SMU Alarms */
    {
        (*(volatile Ifx_SMU_KEYS*)0xF0036834u).U    = (uint32)0xBCU;        /* Enable access to SMU registers */
        ((*(volatile Ifx_SMU_AGCF*)0xF0036960u)).U &= ~(0x1DU);
        ((*(volatile Ifx_SMU_AGCF*)0xF0036964u)).U &= ~(0x1DU);
        ((*(volatile Ifx_SMU_AGCF*)0xF0036968u)).U &= ~(0x1DU);
        (*(volatile Ifx_SMU_KEYS*)0xF0036834u).U    = (uint32)0U;
    }

    /* Power down the both the PLLs before configuring registers*/
    /* Both the PLLs are powered down to be sure for asynchronous PLL registers update cause no glitches */
    (*(volatile Ifx_SCU_SYSPLLCON0*)0xF0036018u).B.PLLPWD = 0;
    (*(volatile Ifx_SCU_PERPLLCON0*)0xF0036028u).B.PLLPWD = 0;

    timeoutCycleCount       = (0x3000U);

    while (((*(volatile Ifx_SCU_SYSPLLSTAT*)0xF0036014u).B.PWDSTAT == 0) || ((*(volatile Ifx_SCU_PERPLLSTAT*)0xF0036024u).B.PWDSTAT == 0))
    {
        {                                                    if (((sint32)--timeoutCycleCount) <= 0)                       {                                                    initError = (uint8)1;                                 break;                                       }                                                else                                             {                                                }                                            };
    }

    /* Now configure the oscillator, required oscillator mode is external crystal */

    if ((pllsParamCfg->pllInputClockSelection == IfxScuCcu_PllInputClockSelection_fOsc0) || (pllsParamCfg->pllInputClockSelection == IfxScuCcu_PllInputClockSelection_fSysclk))

    {
        Ifx_SCU_OSCCON scuOsccon;
        scuOsccon.U      = (*(volatile Ifx_SCU_OSCCON*)0xF0036010u).U;



        scuOsccon.B.MODE = 0U;


        scuOsccon.B.OSCVAL = (uint32)(pllsParamCfg->xtalFrequency / 1000000U) - 15; /*XTAL range 16MHz to 40MHz*/
        /*Note: Oscillator Watchdog Reset (OSCRES) is not required when the PLLs are powered down*/
        (*(volatile Ifx_SCU_OSCCON*)0xF0036010u).U       = scuOsccon.U;
    }

    /* Configure the initial steps for the system PLL*/
    {
        Ifx_SCU_SYSPLLCON0 sysPllCon0;
        sysPllCon0.U       = (*(volatile Ifx_SCU_SYSPLLCON0*)0xF0036018u).U;
        sysPllCon0.B.PDIV  = pllsParamCfg->sysPllConfig.pDivider;
        sysPllCon0.B.NDIV  = pllsParamCfg->sysPllConfig.nDivider;
        sysPllCon0.B.INSEL = pllsParamCfg->pllInputClockSelection;
        (*(volatile Ifx_SCU_SYSPLLCON0*)0xF0036018u).U   = sysPllCon0.U;
    }

    /* Configure the initial steps for the peripheral PLL*/
    {
        Ifx_SCU_PERPLLCON0 scuPerPllCon0;
        scuPerPllCon0.U       = (*(volatile Ifx_SCU_PERPLLCON0*)0xF0036028u).U;
        scuPerPllCon0.B.DIVBY = pllsParamCfg->perPllConfig.k3DividerBypass;
        scuPerPllCon0.B.PDIV  = pllsParamCfg->perPllConfig.pDivider;
        scuPerPllCon0.B.NDIV  = pllsParamCfg->perPllConfig.nDivider;
        (*(volatile Ifx_SCU_PERPLLCON0*)0xF0036028u).U      = scuPerPllCon0.U;
    }

    /* Power up the both the PLLs before configuring registers*/
    (*(volatile Ifx_SCU_SYSPLLCON0*)0xF0036018u).B.PLLPWD = 1;
    (*(volatile Ifx_SCU_PERPLLCON0*)0xF0036028u).B.PLLPWD = 1;

    timeoutCycleCount       = (0x3000U);

    while (((*(volatile Ifx_SCU_SYSPLLSTAT*)0xF0036014u).B.PWDSTAT == 1) || ((*(volatile Ifx_SCU_PERPLLSTAT*)0xF0036024u).B.PWDSTAT == 1))
    {
        {                                                    if (((sint32)--timeoutCycleCount) <= 0)                       {                                                    initError = (uint8)1;                                 break;                                       }                                                else                                             {                                                }                                            };
    }

    timeoutCycleCount = (0x6000U);

    while (((*(volatile Ifx_SCU_SYSPLLSTAT*)0xF0036014u).B.K2RDY == 0U) ||
           ((*(volatile Ifx_SCU_PERPLLSTAT*)0xF0036024u).B.K2RDY == 0U) ||
           ((*(volatile Ifx_SCU_PERPLLSTAT*)0xF0036024u).B.K3RDY == 0U))
    {
        {                                                    if (((sint32)--timeoutCycleCount) <= 0)                       {                                                    initError = (uint8)1;                                 break;                                       }                                                else                                             {                                                }                                            };
    }

    (*(volatile Ifx_SCU_SYSPLLCON1*)0xF003601Cu).B.K2DIV = pllsParamCfg->sysPllConfig.k2Divider;
    {
        Ifx_SCU_PERPLLCON1 scuPerPllCon1;
        scuPerPllCon1.U       = (*(volatile Ifx_SCU_PERPLLCON1*)0xF003602Cu).U;
        scuPerPllCon1.B.K2DIV = pllsParamCfg->perPllConfig.k2Divider;
        scuPerPllCon1.B.K3DIV = pllsParamCfg->perPllConfig.k3Divider;
        (*(volatile Ifx_SCU_PERPLLCON1*)0xF003602Cu).U      = scuPerPllCon1.U;
    }

    timeoutCycleCount = (0x6000U);

    while (((*(volatile Ifx_SCU_SYSPLLSTAT*)0xF0036014u).B.K2RDY == 0U) ||
           ((*(volatile Ifx_SCU_PERPLLSTAT*)0xF0036024u).B.K2RDY == 0U) ||
           ((*(volatile Ifx_SCU_PERPLLSTAT*)0xF0036024u).B.K3RDY == 0U))
    {
        {                                                    if (((sint32)--timeoutCycleCount) <= 0)                       {                                                    initError = (uint8)1;                                 break;                                       }                                                else                                             {                                                }                                            };
    }

    /*Check if the OSC frequencies are in the limit*/
    timeoutCycleCount = (0x493E0U);

    while (((*(volatile Ifx_SCU_OSCCON*)0xF0036010u).B.PLLLV == 0) && ((*(volatile Ifx_SCU_OSCCON*)0xF0036010u).B.PLLHV == 0))
    {
        {                                                    if (((sint32)--timeoutCycleCount) <= 0)                       {                                                    initError = (uint8)1;                                 break;                                       }                                                else                                             {                                                }                                            };
    }

    /* Now start PLL locking for latest set values*/
    {
        (*(volatile Ifx_SCU_SYSPLLCON0*)0xF0036018u).B.RESLD = 1;             /* Restart Sys PLL lock detection */
        (*(volatile Ifx_SCU_PERPLLCON0*)0xF0036028u).B.RESLD = 1;             /* Restart Per PLL lock detection */

        timeoutCycleCount      = (0x3000U);

        while (((*(volatile Ifx_SCU_SYSPLLSTAT*)0xF0036014u).B.LOCK == 0) || ((*(volatile Ifx_SCU_PERPLLSTAT*)0xF0036024u).B.LOCK == 0))
        {
            {                                                    if (((sint32)--timeoutCycleCount) <= 0)                       {                                                    initError = (uint8)1;                                 break;                                       }                                                else                                             {                                                }                                            };
        }
    }
    /*Enable SMU Alarms */
    {
        (*(volatile Ifx_SMU_KEYS*)0xF0036834u).U = (uint32)0xBCU;           /* Enable access to SMU registers */
        (*(volatile Ifx_SMU_CMD*)0xF0036820u).U  = (uint32)0x00000005;
        (*(volatile Ifx_SMU_AG*)0xF00369E0u).U  = (0x1DU); /* Clear SMU Alarms*/
        (*(volatile Ifx_SMU_KEYS*)0xF0036834u).U = (uint32)0U;
    }
    {
        Ifx_SCU_CCUCON0 scu_ccucon0;
        scu_ccucon0.U        = (*(volatile Ifx_SCU_CCUCON0*)0xF0036030u).U;
        scu_ccucon0.B.CLKSEL = 1; /*Select the PLLs for fsource0/1/2 */
        scu_ccucon0.B.UP     = 1; /*Update the ccucon0 register */

        timeoutCycleCount    = (0x1000U);

        while ((*(volatile Ifx_SCU_CCUCON0*)0xF0036030u).B.LCK != 0U)
        {
            {                                                    if (((sint32)--timeoutCycleCount) <= 0)                       {                                                    initError = (uint8)1;                                 break;                                       }                                                else                                             {                                                }                                            };
        }

        (*(volatile Ifx_SCU_CCUCON0*)0xF0036030u).U     = scu_ccucon0.U;

        timeoutCycleCount = (0x1000U);

        while ((*(volatile Ifx_SCU_CCUCON0*)0xF0036030u).B.LCK != 0U)
        {
            {                                                    if (((sint32)--timeoutCycleCount) <= 0)                       {                                                    initError = (uint8)1;                                 break;                                       }                                                else                                             {                                                }                                            };
        }
    }

    IfxScuWdt_setSafetyEndinitInline(endinitSfty_pw);
    return (boolean)initError;
}


static inline boolean IfxScuCcu_distributeClockInline(const IfxScuCcu_ClockDistributionConfig *clockDistributionConfig)
{
    uint16 endinitSfty_pw;
    uint32 timeoutCycleCount;
    uint32 initError = 0;

    /*get the watch-dog passwords for usage with this function*/
    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPasswordInline();

    /* Reset Safety ENDINIT, SCU_CCUCON registers are protected*/
    IfxScuWdt_clearSafetyEndinitInline(endinitSfty_pw);

    /*Configure the clock distribution */
    {                                                    /*Write CCUCON0 configuration */
        Ifx_SCU_CCUCON0 ccucon0;
        ccucon0.U         = (*(volatile Ifx_SCU_CCUCON0*)0xF0036030u).U & ~clockDistributionConfig->ccucon0.mask;
        /*update with configured value */
        ccucon0.U        |= (clockDistributionConfig->ccucon0.mask & clockDistributionConfig->ccucon0.value);
        timeoutCycleCount = (0x1000U);

        while ((*(volatile Ifx_SCU_CCUCON0*)0xF0036030u).B.LCK != 0U)
        {
            {                                                    if (((sint32)--timeoutCycleCount) <= 0)                       {                                                    initError = (uint8)1;                                 break;                                       }                                                else                                             {                                                }                                            };
        }

        (*(volatile Ifx_SCU_CCUCON0*)0xF0036030u).U     = ccucon0.U;      /*Set update bit explicitly to make above configurations effective */
        timeoutCycleCount = (0x1000U);

        while ((*(volatile Ifx_SCU_CCUCON0*)0xF0036030u).B.LCK != 0U)
        {
            {                                                    if (((sint32)--timeoutCycleCount) <= 0)                       {                                                    initError = (uint8)1;                                 break;                                       }                                                else                                             {                                                }                                            };
        }
    }
    {
        /*Write CCUCON1 configuration */
        Ifx_SCU_CCUCON1 ccucon1;
        ccucon1.U = (*(volatile Ifx_SCU_CCUCON1*)0xF0036034u).U;

        if (ccucon1.B.CLKSELMCAN
            || ccucon1.B.CLKSELMSC
            || ccucon1.B.CLKSELQSPI)
        {
            /* Non Zero ClockSel exists - set to Zero */
            /* CAUTION: this would briefly reset and set all clocks in CCUCON1! */
            ccucon1.U  = (*(volatile Ifx_SCU_CCUCON1*)0xF0036034u).U & ~clockDistributionConfig->ccucon1.mask;
            /*update with configured value */
            ccucon1.U |= (clockDistributionConfig->ccucon1.mask & clockDistributionConfig->ccucon1.value);

            /* set Clock selects to 0 */
            ccucon1.B.CLKSELMCAN = (uint32)0;
            ccucon1.B.CLKSELMSC  = (uint32)0;
            ccucon1.B.CLKSELQSPI = (uint32)0;

            timeoutCycleCount    = (0x1000U);

            while ((*(volatile Ifx_SCU_CCUCON1*)0xF0036034u).B.LCK != 0U)
            {
                {                                                    if (((sint32)--timeoutCycleCount) <= 0)                       {                                                    initError = (uint8)1;                                 break;                                       }                                                else                                             {                                                }                                            };
            }

            (*(volatile Ifx_SCU_CCUCON1*)0xF0036034u).U     = ccucon1.U;

            timeoutCycleCount = (0x1000U);

            while ((*(volatile Ifx_SCU_CCUCON1*)0xF0036034u).B.LCK != 0U)
            {
                {                                                    if (((sint32)--timeoutCycleCount) <= 0)                       {                                                    initError = (uint8)1;                                 break;                                       }                                                else                                             {                                                }                                            };
            }
        }

        ccucon1.U         = (*(volatile Ifx_SCU_CCUCON1*)0xF0036034u).U & ~clockDistributionConfig->ccucon1.mask;
        /*update with configured value */
        ccucon1.U        |= (clockDistributionConfig->ccucon1.mask & clockDistributionConfig->ccucon1.value);

        timeoutCycleCount = (0x1000U);

        while ((*(volatile Ifx_SCU_CCUCON1*)0xF0036034u).B.LCK != 0U)
        {
            {                                                    if (((sint32)--timeoutCycleCount) <= 0)                       {                                                    initError = (uint8)1;                                 break;                                       }                                                else                                             {                                                }                                            };
        }

        (*(volatile Ifx_SCU_CCUCON1*)0xF0036034u).U     = ccucon1.U;

        timeoutCycleCount = (0x1000U);

        while ((*(volatile Ifx_SCU_CCUCON1*)0xF0036034u).B.LCK != 0U)
        {
            {                                                    if (((sint32)--timeoutCycleCount) <= 0)                       {                                                    initError = (uint8)1;                                 break;                                       }                                                else                                             {                                                }                                            };
        }
    }

    {
        /*Write CCUCON2 configuration */
        Ifx_SCU_CCUCON2 ccucon2;
        ccucon2.U = (*(volatile Ifx_SCU_CCUCON2*)0xF0036040u).U;

        if (ccucon2.B.CLKSELASCLINS)
        {
            /* Non Zero ClockSel exists - set to Zero */
            /* CAUTION: this would briefly reset and set ASCLINS clock in CCUCON2! */
            ccucon2.U               = (*(volatile Ifx_SCU_CCUCON2*)0xF0036040u).U & ~clockDistributionConfig->ccucon2.mask;
            /*update with configured value */
            ccucon2.U              |= (clockDistributionConfig->ccucon2.mask & clockDistributionConfig->ccucon2.value);

            ccucon2.B.CLKSELASCLINS = (uint32)0;

            timeoutCycleCount       = (0x1000U);

            while ((*(volatile Ifx_SCU_CCUCON2*)0xF0036040u).B.LCK != 0U)
            {
                {                                                    if (((sint32)--timeoutCycleCount) <= 0)                       {                                                    initError = (uint8)1;                                 break;                                       }                                                else                                             {                                                }                                            };
            }

            (*(volatile Ifx_SCU_CCUCON2*)0xF0036040u).U     = ccucon2.U;

            timeoutCycleCount = (0x1000U);

            while ((*(volatile Ifx_SCU_CCUCON2*)0xF0036040u).B.LCK != 0U)
            {
                {                                                    if (((sint32)--timeoutCycleCount) <= 0)                       {                                                    initError = (uint8)1;                                 break;                                       }                                                else                                             {                                                }                                            };
            }
        }

        ccucon2.U         = (*(volatile Ifx_SCU_CCUCON2*)0xF0036040u).U & ~clockDistributionConfig->ccucon2.mask;
        /*update with configured value */
        ccucon2.U        |= (clockDistributionConfig->ccucon2.mask & clockDistributionConfig->ccucon2.value);

        timeoutCycleCount = (0x1000U);

        while ((*(volatile Ifx_SCU_CCUCON2*)0xF0036040u).B.LCK != 0U)
        {
            {                                                    if (((sint32)--timeoutCycleCount) <= 0)                       {                                                    initError = (uint8)1;                                 break;                                       }                                                else                                             {                                                }                                            };
        }

        (*(volatile Ifx_SCU_CCUCON2*)0xF0036040u).U     = ccucon2.U;

        timeoutCycleCount = (0x1000U);

        while ((*(volatile Ifx_SCU_CCUCON2*)0xF0036040u).B.LCK != 0U)
        {
            {                                                    if (((sint32)--timeoutCycleCount) <= 0)                       {                                                    initError = (uint8)1;                                 break;                                       }                                                else                                             {                                                }                                            };
        }
    }
    {
        /*Write CCUCON5 configuration */
        Ifx_SCU_CCUCON5 ccucon5;
        ccucon5.U         = (*(volatile Ifx_SCU_CCUCON5*)0xF003604Cu).U & ~clockDistributionConfig->ccucon5.mask;
        /*update with configured value */
        ccucon5.U        |= (clockDistributionConfig->ccucon5.mask & clockDistributionConfig->ccucon5.value);
        ccucon5.B.UP      = 1;
        timeoutCycleCount = (0x1000U);

        while ((*(volatile Ifx_SCU_CCUCON5*)0xF003604Cu).B.LCK != 0U)
        {
            {                                                    if (((sint32)--timeoutCycleCount) <= 0)                       {                                                    initError = (uint8)1;                                 break;                                       }                                                else                                             {                                                }                                            };
        }

        (*(volatile Ifx_SCU_CCUCON5*)0xF003604Cu).U     = ccucon5.U;
        timeoutCycleCount = (0x1000U);

        while ((*(volatile Ifx_SCU_CCUCON5*)0xF003604Cu).B.LCK != 0U)
        {
            {                                                    if (((sint32)--timeoutCycleCount) <= 0)                       {                                                    initError = (uint8)1;                                 break;                                       }                                                else                                             {                                                }                                            };
        }
    }
    {
        /*Write CCUCON6 configuration */
        Ifx_SCU_CCUCON6 ccucon6;
        ccucon6.U     = (*(volatile Ifx_SCU_CCUCON6*)0xF0036080u).U & ~clockDistributionConfig->ccucon6.mask;
        /*update with configured value */
        ccucon6.U    |= (clockDistributionConfig->ccucon6.mask & clockDistributionConfig->ccucon6.value);
        (*(volatile Ifx_SCU_CCUCON6*)0xF0036080u).U = ccucon6.U;
    }

    {
        /*Write CCUCON7 configuration */
        Ifx_SCU_CCUCON7 ccucon7;
        ccucon7.U     = (*(volatile Ifx_SCU_CCUCON7*)0xF0036084u).U & ~clockDistributionConfig->ccucon7.mask;
        /*update with configured value */
        ccucon7.U    |= (clockDistributionConfig->ccucon7.mask & clockDistributionConfig->ccucon7.value);
        (*(volatile Ifx_SCU_CCUCON7*)0xF0036084u).U = ccucon7.U;
    }

    {
        /*Write CCUCON8 configuration */
        Ifx_SCU_CCUCON8 ccucon8;
        ccucon8.U     = (*(volatile Ifx_SCU_CCUCON8*)0xF0036088u).U & ~clockDistributionConfig->ccucon8.mask;
        /*update with configured value */
        ccucon8.U    |= (clockDistributionConfig->ccucon8.mask & clockDistributionConfig->ccucon8.value);
        (*(volatile Ifx_SCU_CCUCON8*)0xF0036088u).U = ccucon8.U;
    }
    {
        /*Write CCUCON9 configuration */
        Ifx_SCU_CCUCON9 ccucon9;
        ccucon9.U     = (*(volatile Ifx_SCU_CCUCON9*)0xF003608Cu).U & ~clockDistributionConfig->ccucon9.mask;
        /*update with configured value */
        ccucon9.U    |= (clockDistributionConfig->ccucon9.mask & clockDistributionConfig->ccucon9.value);
        (*(volatile Ifx_SCU_CCUCON9*)0xF003608Cu).U = ccucon9.U;
    }
    IfxScuWdt_setSafetyEndinitInline(endinitSfty_pw);
    return (boolean)initError;
}


static inline float32 IfxScuCcu_getAdcFrequency(void)
{
    return IfxScuCcu_getSourceFrequency(IfxScuCcu_Fsource_1);
}


static inline float32 IfxScuCcu_getAsclinFFrequency(void)
{
    float32 freq          = 0;

    uint8   asclindiv[16] = {1, 1, 2, 3, 4, 5, 6, 6, 8, 8, 10, 10, 12, 12, 12, 15};

    if ((*(volatile Ifx_SCU_CCUCON2*)0xF0036040u).B.ASCLINFDIV)
    {
        freq = IfxScuCcu_getSourceFrequency(IfxScuCcu_Fsource_2) / asclindiv[(*(volatile Ifx_SCU_CCUCON2*)0xF0036040u).B.ASCLINFDIV];
    }

    return freq;
}


static inline float32 IfxScuCcu_getEvrFrequency(void)
{
    return (100000000.0);
}


static inline float32 IfxScuCcu_getGethFrequency(void)
{
    return IfxScuCcu_getSourceFrequency(IfxScuCcu_Fsource_0) / (*(volatile Ifx_SCU_CCUCON5*)0xF003604Cu).B.GETHDIV;
}


static inline float32 IfxScuCcu_getGtmFrequency(void)
{
    /* fGTM = fSOURCEGTM / GTMDIV ;
     * fSOURCEGTM = fSPB *2
     */
    uint8   gtmDiv  = (*(volatile Ifx_SCU_CCUCON0*)0xF0036030u).B.GTMDIV;
    float32 gtmFreq = 0;

    if (gtmDiv == 0u)
    {
        gtmFreq = 0.0;
    }
    else if (gtmDiv == 1U)
    {
        gtmFreq = IfxScuCcu_getSpbFrequency() * 2;
    }
    else

    {
        gtmFreq = IfxScuCcu_getSourceFrequency(IfxScuCcu_Fsource_0) / gtmDiv;
    }

    return gtmFreq;
}


static inline float32 IfxScuCcu_getI2cFrequency(void)
{
    return IfxScuCcu_getSourceFrequency(IfxScuCcu_Fsource_2) / (*(volatile Ifx_SCU_CCUCON1*)0xF0036034u).B.I2CDIV;
}


static inline float32 IfxScuCcu_getMcanhFrequency(void)
{
    return IfxScuCcu_getSourceFrequency(IfxScuCcu_Fsource_0) / (*(volatile Ifx_SCU_CCUCON5*)0xF003604Cu).B.MCANHDIV;
}


static inline float32 IfxScuCcu_getOsc0Frequency(void)
{
    return (float32)(20000000);
}


static inline float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if ((*(volatile Ifx_SCU_SYSPLLCON0*)0xF0036018u).B.INSEL == IfxScuCcu_PllInputClockSelection_fOsc1)
    {
        freq = (100000000.0);
    }
    else if ((*(volatile Ifx_SCU_SYSPLLCON0*)0xF0036018u).B.INSEL == IfxScuCcu_PllInputClockSelection_fOsc0)
    {
        freq = (float32)(20000000);
    }
    else if ((*(volatile Ifx_SCU_SYSPLLCON0*)0xF0036018u).B.INSEL == IfxScuCcu_PllInputClockSelection_fSysclk)
    {
        freq = 20000000;
    }
    else
    {
        /* Reserved values, this */
        freq = 0.0;
    }

    return freq;
}


static inline IfxScuCcu_PllInputClockSelection IfxScuCcu_getSourceSelection(void)
{
    return (IfxScuCcu_PllInputClockSelection)(*(volatile Ifx_SCU_CCUCON0*)0xF0036030u).B.CLKSEL;
}


static inline float32 IfxScuCcu_getStmFrequency(void)
{
    return IfxScuCcu_getSourceFrequency(IfxScuCcu_Fsource_0) / (*(volatile Ifx_SCU_CCUCON0*)0xF0036030u).B.STMDIV;
}


static inline boolean IfxScuCcu_getTrapDisableFlag(IfxCpu_ResourceCpu cpuIndex, IfxScuCcu_Traprequest request)
{
    boolean trapdisable = 0;

    trapdisable = (((*(volatile Ifx_SCU_TRAPDIS0*)0xF0036130u).U >> ((cpuIndex << 3) + request)) & 0x1);
    return trapdisable;
}


static inline boolean IfxScuCcu_getTrapStatusFlag(IfxScuCcu_Traprequest request)
{
    boolean trapstatus = 0;

    trapstatus = ((((*(volatile Ifx_SCU_TRAPSTAT*)0xF0036124u).U) >> request) & (0x1));

    return trapstatus;
}


static inline void IfxScuCcu_setTrapDisableFlag(IfxCpu_ResourceCpu cpuIndex, IfxScuCcu_Traprequest request)
{
    uint32 trapdis = 1;
    trapdis         = (trapdis << (cpuIndex << 3));
    (*(volatile Ifx_SCU_TRAPDIS0*)0xF0036130u).U |= (trapdis << request);
}


static inline void IfxScuCcu_setTrapStatusFlag(IfxScuCcu_Traprequest request)
{
    uint32 trapset = 1;
    (*(volatile Ifx_SCU_TRAPSET*)0xF0036128u).U |= (trapset << request);
}


static inline boolean IfxScuCcu_throttleSysPllClockInline(const IfxScuCcu_PllThrottleConfig *pllThrottleConfig)
{
    uint8  initError = 0;
    uint8  pllStepsCount;
    uint16 endinitSfty_pw;
    uint32 timeoutCycleCount;

    /*get the watch-dog passwords for usage with this function*/
    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPasswordInline();

    /*Start Pll ramp up sequence */
    for (pllStepsCount = 0; pllStepsCount < pllThrottleConfig->numOfSteps; pllStepsCount++)
    {                       /*iterate through number of pll steps */
        {
            IfxScuWdt_clearSafetyEndinitInline(endinitSfty_pw);

            /*Configure K2 divider */
            timeoutCycleCount = (0x6000U);

            while ((*(volatile Ifx_SCU_SYSPLLSTAT*)0xF0036014u).B.K2RDY == 0U)
            {
                {                                                    if (((sint32)--timeoutCycleCount) <= 0)                       {                                                    initError = (uint8)1;                                 break;                                       }                                                else                                             {                                                }                                            };
            }

            /*Now set the K2 divider value for the step corresponding to step count */
            (*(volatile Ifx_SCU_SYSPLLCON1*)0xF003601Cu).B.K2DIV = pllThrottleConfig->pllSteps[pllStepsCount].k2Step;
            IfxScuWdt_setSafetyEndinitInline(endinitSfty_pw);
        }

        /*Wait for waitCounter corresponding to the pll step */
        IfxScuCcu_wait(pllThrottleConfig->pllSteps[pllStepsCount].waitTime);
    }

    return (boolean)initError;
}


static inline void IfxScuCcu_wait(float32 timeSec)
{
    uint32 stmCount      = (uint32)(IfxScuCcu_getStmFrequency() * timeSec);
    uint32 stmCountBegin = (*(volatile Ifx_STM_TIM0*)0xF0001010u).U;

    while ((uint32)((*(volatile Ifx_STM_TIM0*)0xF0001010u).U - stmCountBegin) < stmCount)
    {
        /* There is no need to check overflow of the STM timer.
         * When counter after overflow subtracted with counter before overflow,
         * the subtraction result will be as expected, as long as both are unsigned 32 bits
         * eg: stmCountBegin= 0xFFFFFFFE (before overflow)
         *     stmCountNow = 0x00000002 (before overflow)
         *     diff= stmCountNow - stmCountBegin = 4 as expected.*/
    }
}


static inline void IfxScuCcu_waitWithWdtService(float32 timeSec)
{
    uint32 stmCount          = (uint32)(IfxScuCcu_getStmFrequency() * timeSec);
    uint32 stmCountBegin     = (*(volatile Ifx_STM_TIM0*)0xF0001010u).U;
    uint16 cpuWdtPassword    = IfxScuWdt_getCpuWatchdogPassword();
    uint16 safetyWdtPassword = IfxScuWdt_getSafetyWatchdogPassword();

    while ((uint32)((*(volatile Ifx_STM_TIM0*)0xF0001010u).U - stmCountBegin) < stmCount)
    {
        /* There is no need to check overflow of the STM timer.
         * When counter after overflow subtracted with counter before overflow,
         * the subtraction result will be as expected, as long as both are unsigned 32 bits
         * eg: stmCountBegin= 0xFFFFFFFE (before overflow)
         *     stmCountNow = 0x00000002 (before overflow)
         *     diff= stmCountNow - stmCountBegin = 4 as expected.*/
        IfxScuWdt_serviceCpuWatchdog(cpuWdtPassword);
        IfxScuWdt_serviceSafetyWatchdog(safetyWdtPassword);
    }
}


static inline void IfxScuCcu_switchToLowPowerMode(IfxScuCcu_LowPowerDivRatio lpDiv)
{
    uint16 endinitSfty_pw;

    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();

    /* clear safety ENDINIT prior to write to SCU_CCUCON0 */
    IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);

    /* wait for unlock status - safety watchdog ensures timeout */
    while ((*(volatile Ifx_SCU_CCUCON0*)0xF0036030u).B.LCK != 0U)
    {} /*Wait till ccucon0 lock is set, No "timeout" required, ENDINIT watch-dog is active! */

    Ifx_SCU_CCUCON0 scu_ccucon0;
    scu_ccucon0.U       = (*(volatile Ifx_SCU_CCUCON0*)0xF0036030u).U;  /* read ccucon0*/
    scu_ccucon0.B.LPDIV = lpDiv;                /* write Div ratio to LPDIV */
    scu_ccucon0.B.UP    = 1;                    /*Update the ccucon0 register */
    (*(volatile Ifx_SCU_CCUCON0*)0xF0036030u).U       = scu_ccucon0.U;        /* write back */

    IfxScuWdt_setSafetyEndinit(endinitSfty_pw); /* set Safety ENDINIT */
}


static inline void IfxScuCcu_switchToNormalMode(const uint32 ccucon0)
{
    uint16 endinitSfty_pw;

    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();

    /* clear safety ENDINIT prior to write to SCU_CCUCON0 */
    IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);

    /* wait for unlock status - safety watchdog ensures timeout */
    while ((*(volatile Ifx_SCU_CCUCON0*)0xF0036030u).B.LCK != 0U)
    {} /*Wait till ccucon0 lock is set, No "timeout" required, ENDINIT watch-dog is active! */

    /* Intermediate step : SPBDIV = 12 and SRIDIV = 3
     *  NOTE: This intermediate step in division ratio is done to avoid a sudden jump in clock frequency
     *  while jumping back from Low Power to Normal mode. The division ratios used in this step is hard
     *  coded into this function after proving on HW.
     */
    Ifx_SCU_CCUCON0 scu_ccucon0;
    scu_ccucon0.U        = (*(volatile Ifx_SCU_CCUCON0*)0xF0036030u).U;          /* read ccucon0*/
    scu_ccucon0.B.SRIDIV = 3;                      /* SRIDIV = 1:3*/
    scu_ccucon0.B.SPBDIV = 12;                     /* SPBDIV = 1:12 */
    scu_ccucon0.B.LPDIV  = 0;                      /* Exit Low Power Mode */
    scu_ccucon0.B.UP     = 1;
    (*(volatile Ifx_SCU_CCUCON0*)0xF0036030u).U        = scu_ccucon0.U;          /* write back */
    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);    /* set Safety ENDINIT */

    /* wait  */
    IfxScuCcu_wait((0.00001f)); /* wait */

    /* Now back to original settings for normal mode */
    /* clear safety ENDINIT prior to write to SCU_CCUCON0 */
    IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);

    /* wait for unlock status - safety watchdog ensures timeout */
    while ((*(volatile Ifx_SCU_CCUCON0*)0xF0036030u).B.LCK != 0U)
    {} /*Wait till ccucon0 lock is set, No "timeout" required, ENDINIT watch-dog is active! */

    scu_ccucon0.U    = (*(volatile Ifx_SCU_CCUCON0*)0xF0036030u).U;     /* read ccucon0*/
    scu_ccucon0.U    = ccucon0;      /* original setting */
    scu_ccucon0.B.UP = 1;                       /* update */
    (*(volatile Ifx_SCU_CCUCON0*)0xF0036030u).U    = scu_ccucon0.U;           /* write back */
    IfxScuWdt_setSafetyEndinit(endinitSfty_pw); /* set Safety ENDINIT */
}



#line 77 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\ee\\..\\Libraries\\iLLD\\TC38A\\Tricore\\Cpu\\Std\\IfxCpu.h"

/******************************************************************************/
/*-----------------------------------Macros-----------------------------------*/
/******************************************************************************/

/** \brief Convert local DSPR address to global DSPR address which can be accessed from the SRI bus.
 * Use this macro to convert a local DSPR address (in segment 0xd00.....) to
 * a global DSPR address (in segment 0x700....., 0x600....., 0x500..... downwards) depending on
 * the CPU number.
 * Example usage:
 *  \code
 *     dmaChConfig.sourceAddress      = IFXCPU_GLB_ADDR_DSPR(IfxCpu_getCoreId(), &sourceBuffer[i][0]);
 *     dmaChConfig.destinationAddress = IFXCPU_GLB_ADDR_DSPR(IfxCpu_getCoreId(), &destinationBuffer[i][0]);
 *  \endcode
 */


/** \brief Convert local PSPR address to global PSPR address which can be accessed from the SRI bus.
 * Use this macro to convert a local PSPR address (in segment 0xc......) to
 * a global PSPR address (in segment 0x701....., 0x601....., 0x501..... downwards) depending on
 * the CPU number.
 *
 *   Example usage:
 *   \code
 *     dmaChConfig.sourceAddress      = IFXCPU_GLB_ADDR_PSPR(IfxCpu_getCoreId(), &sourceBufferInPsprMemory);
 *     dmaChConfig.destinationAddress = IFXCPU_GLB_ADDR_PSPR(IfxCpu_getCoreId(), &destinationBufferInPsprMemory);
 *   \endcode
 */


/******************************************************************************/
/*------------------------------Type Definitions------------------------------*/
/******************************************************************************/

/** \brief Lock type Spin lock
 */
typedef unsigned int IfxCpu_spinLock;

/** \brief Lock type Mutex lock
 */
typedef unsigned int IfxCpu_mutexLock;

/** \brief Event used for synchronisation.
 */
typedef unsigned int IfxCpu_syncEvent;

/******************************************************************************/
/*--------------------------------Enumerations--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Cpu_Std_Enum
 * \{ */
/** \brief Enumeration for the Cpu mode
 */
typedef enum
{
    IfxCpu_CoreMode_halt,
    IfxCpu_CoreMode_run,
    IfxCpu_CoreMode_idle,
    IfxCpu_CoreMode_sleep,
    IfxCpu_CoreMode_stby,
    IfxCpu_CoreMode_unknown
} IfxCpu_CoreMode;

/** \brief Performance conunter modes
 */
typedef enum
{
    IfxCpu_CounterMode_normal = 0,  /**< \brief Normal counter mode:the counter increments on their respective triggers */
    IfxCpu_CounterMode_task   = 1   /**< \brief Normal counter mode:additional gating control from the debug unit which allows the data gathered in the performance counters to be filtered by some specific criteria */
} IfxCpu_CounterMode;

/** \brief Overlay Address Mask: determines the overlay block size and the bits used for address comparison and translation
 */
typedef enum
{
    IfxCpu_OverlayAddressMask_32byte  = 0xFFF,  /**< \brief 32 byte block size Mask */
    IfxCpu_OverlayAddressMask_64byte  = 0xFFE,  /**< \brief 64 byte block size Mask */
    IfxCpu_OverlayAddressMask_128byte = 0xFFC,  /**< \brief 128 byte block size Mask */
    IfxCpu_OverlayAddressMask_256byte = 0xFF8,  /**< \brief 256 byte block size Mask */
    IfxCpu_OverlayAddressMask_512byte = 0xFF0,  /**< \brief 512 byte block size Mask */
    IfxCpu_OverlayAddressMask_1KB     = 0xFE0,  /**< \brief 1K byte block size Mask */
    IfxCpu_OverlayAddressMask_2KB     = 0xFC0,  /**< \brief 2K byte block size Mask */
    IfxCpu_OverlayAddressMask_4KB     = 0xF80,  /**< \brief 4K byte block size Mask */
    IfxCpu_OverlayAddressMask_8KB     = 0xF00,  /**< \brief 8K byte block size Mask */
    IfxCpu_OverlayAddressMask_16KB    = 0xE00,  /**< \brief 16K byte block size Mask */
    IfxCpu_OverlayAddressMask_32KB    = 0xC00,  /**< \brief 32K byte block size Mask */
    IfxCpu_OverlayAddressMask_64KB    = 0x800,  /**< \brief 64K byte block size Mask */
    IfxCpu_OverlayAddressMask_128KB   = 0x0     /**< \brief 128K byte block size Mask */
} IfxCpu_OverlayAddressMask;

/** \brief Selects overlay memory used for redirection
 */
typedef enum
{
    IfxCpu_OverlayMemorySelect_core0DsprPspr = 0,  /**< \brief Redirection to Core 0 DSPR/PSPR memory */
    IfxCpu_OverlayMemorySelect_core1DsprPspr = 1,  /**< \brief Redirection to Core 1 DSPR/PSPR memory */
    IfxCpu_OverlayMemorySelect_core2DsprPspr = 2,  /**< \brief Redirection to Core 2 DSPR/PSPR memory */
    IfxCpu_OverlayMemorySelect_core3DsprPspr = 3,  /**< \brief Redirection to Core 3 DSPR/PSPR memory */
    IfxCpu_OverlayMemorySelect_lmu           = 8   /**< \brief Redirection to LMU memory */
} IfxCpu_OverlayMemorySelect;

typedef enum
{
    IfxCpu_ResetStatus_notCpuReset   = 0,  /**< \brief No Kernel Reset was executed */
    IfxCpu_ResetStatus_cpuResetBySmu = 1,  /**< \brief Kernel reset was requested by hardware since last clear (SMU) */
    IfxCpu_ResetStatus_cpuResetBySw  = 2   /**< \brief Kernel reset was requested by software since last clear (by writing KRST0.RST=1 and KRST1.RST=1) */
} IfxCpu_ResetStatus;

/** \} */

/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Cpu_Std_DataStructures
 * \{ */
/** \brief counter
 */
typedef struct
{
    uint32  counter;        /**< \brief Counter value */
    boolean overlfow;       /**< \brief sticky overlfow */
} IfxCpu_Counter;

/** \} */

/** \addtogroup IfxLld_Cpu_Std_DataStructures
 * \{ */
/** \brief Performance counter result
 */
typedef struct
{
    IfxCpu_Counter instruction;       /**< \brief Instruction counter */
    IfxCpu_Counter clock;             /**< \brief CPU clock counter */
    IfxCpu_Counter counter1;          /**< \brief Multi counter 1 */
    IfxCpu_Counter counter2;          /**< \brief Multi counter 2 */
    IfxCpu_Counter counter3;          /**< \brief Multi counter 3 */
} IfxCpu_Perf;

/** \} */

/** \addtogroup IfxLld_Cpu_Std_Core
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief API to get the address for CPU HW module register memory map
 * \param cpu Resource index of the CPU
 * \return CPU module register address
 */
static inline Ifx_CPU *IfxCpu_getAddress(IfxCpu_ResourceCpu cpu);

/** \brief API to get core id of the CPU of the caller.
 * Caution: Core id of the cpu's may not be continguous and shouldn't be used to index cpu.
 * Use IfxCpu_getCoreIndex() to get cpu no.
 * \return Resource index of the CPU.
 */
static inline IfxCpu_Id IfxCpu_getCoreId(void);

/** \brief API to get cpu index of the caller CPU.
 * Note: This api can be used whereever cpu no/index is needed.
 * \return Resource index of the CPU.
 */
static inline IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void);

/** \brief API to initialize the context save area of the CPU where this is called.
 *
 * This API can initialize the CSA of the host CPU where this API is called. This API
 * shall not be used to initialize the CSA of another CPU
 * \param csaBegin Pointer to start of context save area, shall not be NULL pointer
 * \param csaEnd Pointer to end of context save area, shall be higher address than csaBegin
 * \return None
 */
static inline void IfxCpu_initCSA(uint32 *csaBegin, uint32 *csaEnd);

/** \brief Set/Clear safety task identifier (PSW.S) on current CPU
 * \return None
 */
static inline void IfxCpu_setSafetyTaskIdentifier(boolean safetyId);

/** \brief Triggers Software Reset
 * \return None
 */
static inline void IfxCpu_triggerSwReset(void);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief API to get current mode of CPU
 * \param cpu Pointer to the CPU HW module (register memory map)
 * \return Current mode of the CPU
 */
extern IfxCpu_CoreMode IfxCpu_getCoreMode(Ifx_CPU *cpu);

/** \brief API to get current mode of CPU
 * \param cpu Pointer to the CPU HW module (register memory map)
 * \return Resource index of the CPU
 */
extern IfxCpu_ResourceCpu IfxCpu_getIndex(Ifx_CPU *cpu);

/** \brief API to set mode of the CPU
 * \param cpu Pointer to the CPU HW module (register memory map)
 * \param mode CPU mode to be set by this API
 * \return Success status of the activity (setting the core mode).
 * \retval TRUE: If the activity successfully be performed.
 * \retval FALSE: If the activity can't be performed.
 */
extern boolean IfxCpu_setCoreMode(Ifx_CPU *cpu, IfxCpu_CoreMode mode);

/** \brief API to set the program counter for the CPU specified.
 * \param cpu Pointer to the CPU HW module (register memory map)
 * \param programCounter Program counter value to be set
 * \return success status of the activity (setting program counter value).
 * \retval TRUE: If the activity successfully be performed.
 * \retval FALSE: If the activity can't be performed
 */
extern boolean IfxCpu_setProgramCounter(Ifx_CPU *cpu, uint32 programCounter);

/** \brief API to set the program counter for the CPU specified and start the CPU
 * \param cpu Pointer to the CPU HW module (register memory map)
 * \param programCounter Program counter value to start the CPU
 * \return success status of the activity (setting program counter value).
 * \retval TRUE: If the activity successfully be performed.
 * \retval FALSE: If the activity can't be performed
 */
extern boolean IfxCpu_startCore(Ifx_CPU *cpu, uint32 programCounter);

/** \brief To request reset of a particular core, given by coreId
 * \return None
 */
extern void IfxCpu_triggerCpuReset(IfxCpu_ResourceCpu coreIndex);

/** \brief Retrieve the cause of reset(no reset, hardware(SMU) or software) since last clear by reading KRST0.RSTSTAT and clear it.
 */
extern IfxCpu_ResetStatus IfxCpu_getCpuResetStatus(IfxCpu_ResourceCpu coreIndex);

/** \} */

/** \addtogroup IfxLld_Cpu_Std_Interrupt
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief API to get the status of global interrupt enable (ICR.IE) for the CPU which calls this API
 * This API provides the status of CPU where this API is called
 * \return Status of global interrupt enable bit.
 * \retval TRUE: Global interrupts enabled.
 * \retval FALSE: Global interrupts disabled
 */
static inline boolean IfxCpu_areInterruptsEnabled(void);

/** \brief API to disable global interrupt and return the previous status.
 *
 * This API can be used only to disable the global interrupts of caller CPU. It cannot be
 * used for this activity towards other CPUs
 * \return Previous status of global interrupt enable bit.
 * \retval TRUE: Previously, global interrupts enabled.
 * \retval FALSE: Previously, global interrupts disabled
 */
static inline boolean IfxCpu_disableInterrupts(void);

/** \brief API to enable global interrupt.
 * This API simply enables the global interrupt.
 * \return None
 */
static inline void IfxCpu_enableInterrupts(void);

/** \brief Disable the Global Interrupt
 * \return None
 */
static inline void IfxCpu_forceDisableInterrupts(void);

/** \brief API to restore global interrupt with that of the passed parameter.
 *
 * This API can be used only to disable the global interrupts of caller CPU. It cannot be
 * used for this activity towards other CPUs
 * \param enabled Previous status of the global interrupt enable bit
 * \return None
 */
static inline void IfxCpu_restoreInterrupts(boolean enabled);

/** \} */

/** \addtogroup IfxLld_Cpu_Std_Cache
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief API to enable/ disable the data cacheability for selected segments
 * With this API cacheability for one or more segment can be enabled/disabled for the CPU core where this API is called.
 * \Note This API is to be called only if the PCACHE or DCACHE are not enabled before
 * \param segmentNumberMask Mask where bitfield 0 represents segment 0 and bitfield 16 represent segment F.
 * \param enable TRUE: to enable the cacheability for selected segment, FALSE: to disable.
 * \return None
 */
static inline void IfxCpu_enableSegmentSpecificDataAccessCacheability(uint16 segmentNumberMask, boolean enable);

/** \brief API to enable/ disable the instruction cacheability for selected segments
 * With this API cacheability for one or more segment can be enabled/disabled for the CPU core where this API is called.
 * \Note This API is to be called only if the PCACHE or DCACHE are not enabled before
 * \param segmentNumberMask Mask where bitfield 0 represents segment 0 and bitfield 16 represent segment F.
 * \param enable TRUE: to enable the cacheability for selected segment, FALSE: to disable.
 * \return None
 */
static inline void IfxCpu_enableSegmentSpecificInstructionAccessCacheability(uint16 segmentNumberMask, boolean enable);

/** \brief API to invalidate the program cache
 * \return None
 */
static inline void IfxCpu_invalidateProgramCache(void);

/** \brief API to determine if an address is in a cachable or non-cachable Flash/LMU section
 * \param address Address
 * \return Status TRUE/FALSE
 */
static inline boolean IfxCpu_isAddressCachable(void *address);

/** \brief API to enable or bypass the data cache for the CPU which calls this API.
 *
 * This API can be used only to enable or bypass the data cache of caller CPU. It cannot be
 * used for this activity towards other CPUs
 * \param enable Command to enable or bypass the data cache
 * TRUE: Enable the data cache.
 * FALSE: Bypass the data cache.
 * \return None
 */
static inline void IfxCpu_setDataCache(boolean enable);

/** \brief API to enable or bypass the program cache for the CPU which calls this API.
 *
 * This API can be used only to enable or bypass the program cache of caller CPU. It cannot be
 * used for this activity towards other CPUs
 * \param enable Command to enable or bypass the program cache.
 * TRUE: Enable the program cache.
 * FALSE: Bypass the program cache
 * \return None
 */
static inline void IfxCpu_setProgramCache(boolean enable);

/** \} */

/** \addtogroup IfxLld_Cpu_Std_PerformanceCounter
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief API to read the clock counter for the CPU which calls this API.
 *
 * This API can be used to read clock counter of only the caller CPU. It cannot be
 * used for this activity towards other CPUs.
 * \return Counter value. 0 to 0x7FFFFFFF.
 */
static inline uint32 IfxCpu_getClockCounter(void);

/** \brief API to get sticky overflow bit of clock counter for the CPU, which calls this API.
 *
 * This API can be used to get sticky overflow bit of clock counter of only the caller CPU.
 * It cannot be used for this activity towards other CPUs.
 * This API also clears the sticky overflow after the read. While reading the sticky bit this API disables
 * the counter for short time. (otherwise sticky bit cannot be cleared). This API shall be used after
 * reading the counter
 * \return Status of sticky overflow bit.
 * \retval TRUE: Sticky overflow bit is set.
 * \retval FALSE: Sticky overflow bit is reset
 */
static inline boolean IfxCpu_getClockCounterStickyOverflow(void);

/** \brief API to read the instruction counter for the CPU which calls this API.
 *
 * This API can be used to read instruction counter of only the caller CPU. It cannot be
 * used for this activity towards other CPUs
 * \return Counter value. 0 to 0x7FFFFFFF.
 */
static inline uint32 IfxCpu_getInstructionCounter(void);

/** \brief API to get sticky overflow bit of Instruction counter for the CPU, which calls this API.
 *
 * This API can be used to get sticky overflow bit of Instruction counter of only the caller CPU.
 * It cannot be used for this activity towards other CPUs.
 * This API also clears the sticky overflow after the read. While reading the sticky bit this API disables
 * the counter for short time. (otherwise sticky bit cannot be cleared). This API shall be used after
 * reading the counter
 * \return Status of sticky overflow bit.
 * \retval TRUE: Sticky overflow bit is set.
 * \retval FALSE: Sticky overflow bit is reset
 */
static inline boolean IfxCpu_getInstructionCounterStickyOverflow(void);

/** \brief API to read the performance counter for the CPU which calls this API.
 * \param address Address
 * \return counter value
 */
static inline uint32 IfxCpu_getPerformanceCounter(uint16 address);

/** \brief API to get sticky overflow bit of performance counter for the CPU, which calls this API.
 * This is generic function to get sticky overflow bit of any performance counters
 * \param address Address
 * \return Status
 */
static inline boolean IfxCpu_getPerformanceCounterStickyOverflow(uint16 address);

/** \brief Reset and start instruction, clock and multi counters
 *
 * Reset and start CCNT, ICNT, M1CNT, M2CNT, M3CNT. the overflow bits are cleared.
 * \param mode Counter mode
 * \return None
 */
static inline void IfxCpu_resetAndStartCounters(IfxCpu_CounterMode mode);

/** \brief API to enable or disable performance counter for the CPU which calls this API.
 *
 * This API can be used to enable or disable performance counter of only the caller CPU. It cannot be
 * used for this activity towards other CPUs.
 * \param enable enable Command to enable or disable the performance counter.
 * TRUE: Enable the performance counter.
 * FALSE: Disable the performance counter
 * \return None
 */
static inline void IfxCpu_setPerformanceCountersEnableBit(uint32 enable);


/** \brief Stop instruction and clock counters, return their values
 *
 * Stop CCNT, ICNT, M1CNT, M2CNT, M3CNT and return their values;
 *  \Note The CCTRL is reset to 0, for more accurate measurements and has to be initialized again before strating the next performance measurement.
 * \return Performance counter result
 */
static inline IfxCpu_Perf IfxCpu_stopCounters(void);


/** \brief API to update clock counter for the CPU which calls this API.
 *
 * This API can be used to update clock counter of only the caller CPU. It cannot be
 * used for this activity towards other CPUs.
 * \param count Counter value to be updated. 0 to 0x7FFFFFFF
 * \return None
 */
static inline void IfxCpu_updateClockCounter(uint32 count);

/** \brief API to update Instruction counter for the CPU which calls this API.
 *
 * This API can be used to update Instruction counter of only the caller CPU. It cannot be
 * used for this activity towards other CPUs.
 * \param count Counter value to be updated. 0 to 0x7FFFFFFF
 * \return None
 */
static inline void IfxCpu_updateInstructionCounter(uint32 count);

/** \brief API to update performance counter for the CPU which calls this API.
 * This is generic function to update any of the performance counters
 * \param address Address
 * \param count Count
 * \return None
 */
static inline void IfxCpu_updatePerformanceCounter(uint32 address, uint32 count);

/** \} */

/** \addtogroup IfxLld_Cpu_Std_Synchronization
 * \{ */

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief API to acquire the mutex (binary semaphore).
 *
 * This API can be used to acquire/get the mutex.
 * \param lock lock pointer
 * \return TRUE : lock acquired successfully. FALSE: Failed to acquire the lock
 *
 * \code
 *    IfxCpu_mutexLock resourceLock;
 *    boolean flag = IfxCpu_acquireMutex(&resourceLock);
 *    if (flag){
 *      // critical section
 *      IfxCpu_releaseMutex(&resourceLock);
 *    }
 * \endcode
 *
 */
extern boolean IfxCpu_acquireMutex(IfxCpu_mutexLock *lock);

/** \brief API to unlock the mutex .
 *
 * This API can be used to unlock the previously acquired mutex
 * \param lock lock pointer
 * \return None
 *
 * \code
 *    IfxCpu_mutexLock resourceLock;
 *    boolean flag = IfxCpu_acquireMutex(&resourceLock);
 *    if (flag){
 *      // critical section
 *      IfxCpu_releaseMutex(&resourceLock);
 *    }
 * \endcode
 *
 */
extern void IfxCpu_releaseMutex(IfxCpu_mutexLock *lock);

/** \brief API to unlock the resource .
 *
 * This API can be used to unlock the previously acquired lock
 * \param lock lock pointer
 * \return None
 */
extern void IfxCpu_resetSpinLock(IfxCpu_spinLock *lock);

/** \brief API to lock the resource in spin mode with the given timeout.
 *
 * This API can be used to spin lock for the lock for the given timeout period.
 * \param lock lock pointer
 * \param timeoutCount loop counter value used for timeout to acquire lock
 * \return TRUE : lock acquired successfully. FALSE: Failed to acquire the lock
 *
 * \code
 *    IfxCpu_spinLock resourceLock;
 *    boolean flag = IfxCpu_setSpinLock(&resourceLock, 0xFFFF);
 *    if (flag){
 *      // critical section
 *      IfxCpu_resetSpinLock(&resourceLock);
 *    }
 * \endcode
 *
 */
extern boolean IfxCpu_setSpinLock(IfxCpu_spinLock *lock, uint32 timeoutCount);

/** \} */

/** \addtogroup IfxLld_Cpu_Std_Utility
 * \{ */

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief This function disables the overlay memory.
 * \param cpu Core no
 * \param overlayBlock Overlay Block
 * \return None
 */
extern void IfxCpu_disableOverlayBlock(IfxCpu_ResourceCpu cpu, uint16 overlayBlock);

/** \brief This function configures and enables the overlay memory.
 * Note:
 * The data overlay provides the capability to redirect selected data accesses to the Overlay memory. Data accesses made by the TriCore to Program Flash, Online Data Acquisition space, or EBU space can be redirected. Overlay memory may be located in the Local Memory (if present), in the Emulation Memory (Emulation Device only), or in the EBU space,or in the DPSR/PSPR memory.
 *
 * How the overlay Memory works?
 * Any data access to segment 8 or segment A is checked against all the activated overlay blocks. For each activated overlay block, address bits 27..5 are compared with the target base address , and this bit-wise comparison is qualified by the content of address mask. Address bits participate in the comparison if the corresponding mask bits are set to one. The access is redirected, if all the address bits selected by mask equal to the corresponding bits in target address.
 * The address for redirection is constructed as follows:
 * 1. Address bits 31..22 are set according to the overlay memory selection and the cache-ability of the original address.
 * 2. For address bits 21..5:
 * - If the corresponding address mask bit is set, the address bit value is taken from overlay base address .
 * - If the corresponding address mask bit is cleared, the address bit value is taken from the original address.
 * 3. Address bits 4..0 are always taken directly from the original address.
 * If there is no redirection, the original address is used to perform the access.
 * Target address ranges for activated overlay blocks should not overlap or an exception may occur.
 * \param cpu Core no
 * \param overlayBlock Overlay Block
 * \param overlayMemorySelect Overlay Memory Select
 * \param overlayAddressMask overlay Address Mask
 * \param targetBaseAddress Target Base address (i.e Source address to be re-directed)
 * \param overlayBaseAddress Overlay or Re-directed Base address (Bits 21..5 of the base address the overlay memory block in the overlay memory)
 * \return None
 */
extern void IfxCpu_enableOverlayBlock(IfxCpu_ResourceCpu cpu, uint16 overlayBlock, IfxCpu_OverlayMemorySelect overlayMemorySelect, IfxCpu_OverlayAddressMask overlayAddressMask, uint32 targetBaseAddress, uint32 overlayBaseAddress);

/** \brief API to get random value
 * \param seed Pointer to seed value
 * \return random value
 */
extern uint32 IfxCpu_getRandomValue(uint32 *seed);

/** \brief API to get random value with in the range
 * \param seed Pointer to seed value
 * \param min minimum range value
 * \param max maximum range value
 * \return random value
 */
extern uint32 IfxCpu_getRandomValueWithinRange(uint32 *seed, uint32 min, uint32 max);

/** \brief This function waits till all the cores have set their corresponding bits in the event. This function along with
 * IfxCpu_emitEvent() are used to achieve the synchronisation between the configured cores. By default
 * "IFXCPU_CFG_ALLCORE_DONE" macro defined for all the cores. In case the user wants to check for
 * synchronisation among the required cores, the macro can be redefined with the value accroing to the
 * CORE_ID register.
 * The IfxCpu_emitEvent() is to be used in the Main functions of the Cores where the user wants to check for synchronisation.
 *
 * e.g:
 * 1. Check for synchronisation between core 0 and core 5
 * # define 0x41U
 * 2. Check for synchronisation between core 0 to core 5
 * # define 0x5FU
 *
 * Note:
 * Core id values read from CORE_ID register will be as shown below. The value indicates the position of the bit needs to be set while building the macro.
 * Core 0: 0
 * Core 1: 1
 * Core 2: 2
 * Core 3: 3
 * Core 4: 4
 * Core 5: 6
 * \param event Synchronous Event
 * \param timeoutMilliSec timeout in millisec
 * \return Error condition
 *
 * The functions IfxCpu_waitEvent and IfxCpu_emitEvent are used to achieve synchronisation between all cores (i.e individual cores wait till all cores have reached the synchronisation point). The IfxCpu_waitEvent returns 1 incase a timeout occurs.
 *
 * \code
 * // Global variable. preferably located in  shared memory.
 * IfxCpu_syncEvent event;
 * boolean errorVal;
 *
 * // Below code should be repeated in Each core
 *
 * // Upon reaching Synchonisation point
 * IfxCpu_emitEvent(&event);
 * errorVal = IfxCpu_waitEvent(&event, timeoutMilliSec); // timeoutMilliSec is timeout value to wait
 *
 * \endcode
 *
 */
extern boolean IfxCpu_waitEvent(IfxCpu_syncEvent *event, uint32 timeoutMilliSec);

/** \brief This function sets a bit corresponding to the core in the event.
 * \param event Synchronous Event
 * \return None
 *
 * A coding example can be found in \ref IfxCpu_waitEvent
 *
 */
extern void IfxCpu_emitEvent(IfxCpu_syncEvent *event);

/** \} */

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Sets all CPUs to Idle mode except the Master CPU,index of which is given as the parameter
 * \param masterCpu Master CPU Index- All except this will be set to Idle Mode
 * \return None
 */
extern void IfxCpu_setAllIdleExceptMasterCpu(IfxCpu_ResourceCpu masterCpu);

/** \brief Disables interrupts for all CPUs except the Master CPU,index of which is given as the parameter
 * \param masterCpu Master CPU Index- All except this will have their interrupts disabled
 * \return None
 */
extern void IfxCpu_disableInterruptsAllExceptMaster(IfxCpu_ResourceCpu masterCpu);

/******************************************************************************/
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

static inline boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(0xFE2C);
    return reg.B.IE != 0;
}


static inline boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
    __nop();
    return enabled;
}


static inline void IfxCpu_enableInterrupts(void)
{
    __enable();
}


static inline void IfxCpu_enableSegmentSpecificDataAccessCacheability(uint16 segmentNumberMask, boolean enable)
{
    uint32 cpu_pmaVal;
    uint16 checkRestrictionMask;
    uint32 coreIndex   = IfxCpu_getCoreIndex();
    uint16 wdtPassword = IfxScuWdt_getCpuWatchdogPasswordInline(&((*(Ifx_SCU*)0xF0036000u)).WDTCPU[coreIndex]);

    /*resolve the restrictions*/
    /*In PMA0 Segment-C and Segment[7-CoreID] must have the same value */
    checkRestrictionMask = ((uint16)1 << (7 - coreIndex)) | ((uint16)1 << 0xC);

    if ((segmentNumberMask & checkRestrictionMask) != 0)
    {
        segmentNumberMask |= checkRestrictionMask;
    }

    cpu_pmaVal = __mfcr(0x8100);                                                              /* Read the CPU_PMA0 */

    cpu_pmaVal = enable ? (cpu_pmaVal | segmentNumberMask) : (cpu_pmaVal & ~segmentNumberMask); /* enable or disable the corresponding bitfield */

    /*The CPU_PMA registers are ENDINIT protected*/
    IfxScuWdt_clearCpuEndinitInline(&((*(Ifx_SCU*)0xF0036000u)).WDTCPU[coreIndex], wdtPassword);
    /*When changing the value of the CPU_PMAx registers both the instruction and data caches should be invalidated*/
    /*Write to PMA0 register for selecting the cacheability for data cache*/
    __dsync();      /* DSYNC instruction should be executed immediately prior to the MTCR*/
    __mtcr(0x8100, cpu_pmaVal);
    __isync();      /* ISYNC instruction executed immediately following MTCR */
    IfxScuWdt_setCpuEndinitInline(&((*(Ifx_SCU*)0xF0036000u)).WDTCPU[coreIndex], wdtPassword);
}


static inline void IfxCpu_enableSegmentSpecificInstructionAccessCacheability(uint16 segmentNumberMask, boolean enable)
{
    uint32 cpu_pmaVal;
    uint16 checkRestrictionMask;
    uint32 coreIndex   = IfxCpu_getCoreIndex();
    uint16 wdtPassword = IfxScuWdt_getCpuWatchdogPasswordInline(&((*(Ifx_SCU*)0xF0036000u)).WDTCPU[coreIndex]);

    /*resolve the restrictions*/
    /*In PMA1 Segment-D and Segment[7-CoreID] must have the same value */
    checkRestrictionMask = ((uint16)1 << (7 - coreIndex)) | ((uint16)1 << 0xD);

    if ((segmentNumberMask & checkRestrictionMask) != 0)
    {
        segmentNumberMask |= checkRestrictionMask;
    }

    cpu_pmaVal = __mfcr(0x8104);                                                              /* Read the CPU_PMA1 */

    cpu_pmaVal = enable ? (cpu_pmaVal | segmentNumberMask) : (cpu_pmaVal & ~segmentNumberMask); /* enable or disable the corresponding bitfield */

    /*The CPU_PMA registers are ENDINIT protected*/
    IfxScuWdt_clearCpuEndinitInline(&((*(Ifx_SCU*)0xF0036000u)).WDTCPU[coreIndex], wdtPassword);
    /*When changing the value of the CPU_PMAx registers both the instruction and data caches should be invalidated*/
    /*Write to PMA1 register for selecting the cacheability for data cache*/
    __dsync();      /* DSYNC instruction should be executed immediately prior to the MTCR */
    __mtcr(0x8104, cpu_pmaVal);
    __isync();      /* ISYNC instruction executed immediately following MTCR */
    IfxScuWdt_setCpuEndinitInline(&((*(Ifx_SCU*)0xF0036000u)).WDTCPU[coreIndex], wdtPassword);
}


static inline void IfxCpu_forceDisableInterrupts(void)
{
    __disable();
    __nop();
}


static inline Ifx_CPU *IfxCpu_getAddress(IfxCpu_ResourceCpu cpu)
{
    Ifx_CPU *module;

    if (cpu < IfxCpu_ResourceCpu_none)
    {
        module = (Ifx_CPU *)IfxCpu_cfg_indexMap[cpu].module;
    }
    else
    {
        module = ((void *)0);
    }

    return module;
}


static inline uint32 IfxCpu_getClockCounter(void)
{
    return IfxCpu_getPerformanceCounter(0xFC04);
}


static inline boolean IfxCpu_getClockCounterStickyOverflow(void)
{
    return IfxCpu_getPerformanceCounterStickyOverflow(0xFC04);
}


static inline IfxCpu_Id IfxCpu_getCoreId(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(0xFE1C);
    return (IfxCpu_Id)reg.B.CORE_ID;
}


static inline IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(0xFE1C);
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
}


static inline uint32 IfxCpu_getInstructionCounter(void)
{
    return IfxCpu_getPerformanceCounter(0xFC08);
}


static inline boolean IfxCpu_getInstructionCounterStickyOverflow(void)
{
    return IfxCpu_getPerformanceCounterStickyOverflow(0xFC08);
}


static inline uint32 IfxCpu_getPerformanceCounter(uint16 address)
{
    Ifx_CPU_CCNT ccnt;

    if (address == 0xFC04)
    {
        ccnt.U = __mfcr(0xFC04);
    }
    else if (address == 0xFC08)
    {
        ccnt.U = __mfcr(0xFC08);
    }
    else if (address == 0xFC0C)
    {
        ccnt.U = __mfcr(0xFC0C);
    }
    else if (address == 0xFC10)
    {
        ccnt.U = __mfcr(0xFC10);
    }
    else if (address == 0xFC14)
    {
        ccnt.U = __mfcr(0xFC14);
    }

    return ccnt.B.COUNTVALUE;
}


static inline boolean IfxCpu_getPerformanceCounterStickyOverflow(uint16 address)
{
    Ifx_CPU_CCNT ccnt;

    if (address == 0xFC04)
    {
        ccnt.U = __mfcr(0xFC04);
    }
    else if (address == 0xFC08)
    {
        ccnt.U = __mfcr(0xFC08);
    }
    else if (address == 0xFC0C)
    {
        ccnt.U = __mfcr(0xFC0C);
    }
    else if (address == 0xFC10)
    {
        ccnt.U = __mfcr(0xFC10);
    }
    else if (address == 0xFC14)
    {
        ccnt.U = __mfcr(0xFC14);
    }

    return ccnt.B.SOVF;
}


static inline void IfxCpu_initCSA(uint32 *csaBegin, uint32 *csaEnd)
{
    uint32  k;
    uint32  nxt_cxi_val = 0U;
    uint32 *prvCsa      = csaBegin;
    uint32 *nxtCsa      = csaBegin;
    uint32  numOfCsa    = (((uint32)csaEnd - (uint32)csaBegin) / 64U);

    for (k = 0U; k < numOfCsa; k++)
    {
        nxt_cxi_val = ((uint32)nxtCsa & (0XFU << 28U)) >> 12U | ((uint32)nxtCsa & (0XFFFFU << 6U)) >> 6U;

        if (k == 0U)
        {
            __mtcr(0xFE38, nxt_cxi_val);   /* store the new pcxi value to LCX */
        }
        else
        {
            *prvCsa = nxt_cxi_val;  /* Store null pointer in last CSA (= very first time!) */
        }

        if (k == (numOfCsa - 3U))
        {
            __mtcr(0xFE3C, nxt_cxi_val);   /* Last but 2 context save area is pointed in LCX to know if there is CSA depletion */
        }

        prvCsa  = (uint32 *)nxtCsa;
        nxtCsa += 16U;           /* next CSA */
    }

    *prvCsa = 0U;
}


static inline void IfxCpu_invalidateProgramCache(void)
{
    uint16 cpuWdtPassword = IfxScuWdt_getCpuWatchdogPassword();
    {
        IfxScuWdt_clearCpuEndinit(cpuWdtPassword);
        Ifx_CPU_PCON1 pcon1;
        pcon1.U       = __mfcr(0x9204);
        pcon1.B.PCINV = 1;
        __mtcr(0x9204, pcon1.U);
        IfxScuWdt_setCpuEndinit(cpuWdtPassword);
    }
}


static inline boolean IfxCpu_isAddressCachable(void *address)
{
    uint8 segment = (uint32)address >> 24;
    return ((segment == (8)) || (segment == (9))) ? (1u) : (0u);
}


static inline void IfxCpu_resetAndStartCounters(IfxCpu_CounterMode mode)
{
    Ifx_CPU_CCTRL cctrl;
    cctrl.U    = __mfcr(0xFC00);
    /*Disable the counters */
    cctrl.B.CE = 0;
    __mtcr(0xFC00, cctrl.U);

    /* reset the counters */
    __mtcr(0xFC04, 0);
    __mtcr(0xFC08, 0);
    __mtcr(0xFC0C, 0);
    __mtcr(0xFC10, 0);
    __mtcr(0xFC14, 0);

    /*Enable the counters, set the counter mode */
    cctrl.B.CE = 1;
    cctrl.B.CM = mode;
    __mtcr(0xFC00, cctrl.U);
}


static inline void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != (0u))
    {
        __enable();
    }
}


static inline void IfxCpu_setDataCache(boolean enable)
{
    uint32 coreIndex   = IfxCpu_getCoreIndex();
    uint16 wdtPassword = IfxScuWdt_getCpuWatchdogPasswordInline(&((*(Ifx_SCU*)0xF0036000u)).WDTCPU[coreIndex]);
    /*PCACHE enable steps */
    {                           /* Step 1: Set PCBYP to 0 if cache is enabled */
        IfxScuWdt_clearCpuEndinitInline(&((*(Ifx_SCU*)0xF0036000u)).WDTCPU[coreIndex], wdtPassword);
        Ifx_CPU_DCON0 dcon0;
        dcon0.U       = 0;
        dcon0.B.DCBYP = enable ? 0 : 1; /*depending on the enable bypas bit is reset/set */
        __mtcr(0x9040, dcon0.U);
        IfxScuWdt_setCpuEndinitInline(&((*(Ifx_SCU*)0xF0036000u)).WDTCPU[coreIndex], wdtPassword);
    }
    /* Step 2: Call Isync */
    __isync();
}


static inline void IfxCpu_setPerformanceCountersEnableBit(uint32 enable)
{
    Ifx_CPU_CCTRL cctrl;
    cctrl.U    = __mfcr(0xFC00);
    cctrl.B.CE = enable;
    __mtcr(0xFC00, cctrl.U);
}


static inline void IfxCpu_setProgramCache(boolean enable)
{
    if (enable)
    {                           /* Step 3: Initiate invalidation of current cache contents if any */
        Ifx_CPU_PCON1 pcon1;
        pcon1.U       = 0;
        pcon1.B.PCINV = 1;
        __mtcr(0x9204, pcon1.U);
    }

    uint32 coreIndex   = IfxCpu_getCoreIndex();
    uint16 wdtPassword = IfxScuWdt_getCpuWatchdogPasswordInline(&((*(Ifx_SCU*)0xF0036000u)).WDTCPU[coreIndex]);
    /*PCACHE enable steps */
    {                           /* Step 1: Set PCBYP to 0 if cache is enabled */
        IfxScuWdt_clearCpuEndinitInline(&((*(Ifx_SCU*)0xF0036000u)).WDTCPU[coreIndex], wdtPassword);
        Ifx_CPU_PCON0 pcon0;
        pcon0.U       = 0;
        pcon0.B.PCBYP = enable ? 0 : 1; /*depending on the enable bypass bit is reset/set */
        __mtcr(0x920C, pcon0.U);
        IfxScuWdt_setCpuEndinitInline(&((*(Ifx_SCU*)0xF0036000u)).WDTCPU[coreIndex], wdtPassword);
    }
    /* Step 2: Call Isync */
    __isync();
}


static inline void IfxCpu_setSafetyTaskIdentifier(boolean safetyId)
{
    Ifx_CPU_PSW psw;
    ((void)0);
    psw.U   = __mfcr(0xFE04);
    psw.B.S = safetyId;
    __mtcr(0xFE04, (uint32)psw.U);
}



static inline IfxCpu_Perf IfxCpu_stopCounters(void)
{
    IfxCpu_Perf result;
    /*Disable the counters, reset the control reg */
    /* Use inline assembly to ensure constant implementation, and execution of the measurement routines */
    Ifx__stopPerfCounters();

    Ifx_CPU_CCNT ccnt;
    ccnt.U                = __mfcr(0xFC04);
    result.clock.counter  = ccnt.B.COUNTVALUE;
    result.clock.overlfow = ccnt.B.SOVF;

    Ifx_CPU_ICNT icnt;
    icnt.U                      = __mfcr(0xFC08);
    result.instruction.counter  = icnt.B.COUNTVALUE;
    result.instruction.overlfow = icnt.B.SOVF;

    Ifx_CPU_M1CNT m1cnt;
    m1cnt.U                  = __mfcr(0xFC0C);
    result.counter1.counter  = m1cnt.B.COUNTVALUE;
    result.counter1.overlfow = m1cnt.B.SOVF;

    Ifx_CPU_M2CNT m2cnt;
    m2cnt.U                  = __mfcr(0xFC10);
    result.counter2.counter  = m2cnt.B.COUNTVALUE;
    result.counter2.overlfow = m2cnt.B.SOVF;

    Ifx_CPU_M3CNT m3cnt;
    m3cnt.U                  = __mfcr(0xFC14);
    result.counter3.counter  = m3cnt.B.COUNTVALUE;
    result.counter3.overlfow = m3cnt.B.SOVF;

    return result;
}



static inline void IfxCpu_triggerSwReset(void)
{
    ((*(Ifx_SCU*)0xF0036000u)).SWRSTCON.B.SWRSTREQ = 1;

    /* Wait till reset */
    while (1)
    {}
}


static inline void IfxCpu_updateClockCounter(uint32 count)
{
    IfxCpu_updatePerformanceCounter(0xFC04, count);
}


static inline void IfxCpu_updateInstructionCounter(uint32 count)
{
    IfxCpu_updatePerformanceCounter(0xFC08, count);
}


static inline void IfxCpu_updatePerformanceCounter(uint32 address, uint32 count)
{
    if(address){};
    Ifx_CPU_CCTRL cctrl;
    boolean       enableBit;
    /*Disable the counters */
    cctrl.U    = __mfcr(0xFC00);
    enableBit  = cctrl.B.CE;
    cctrl.B.CE = 0;
    __mtcr(0xFC00, cctrl.U);

    /*Update the counter value */
    count &= ~(1U << 31);       /*clear sticky overflow bit if set */
    __mtcr(address, count);

    /*restore the enable bit */
    cctrl.B.CE = enableBit;
    __mtcr(0xFC00, cctrl.U);
}



#line 48 "D:/RTOS_PROJEKT/erica/aurix_workspace/can_erika/ee/../Libraries/iLLD/TC38A/Tricore/Cpu/Std/IfxCpu.c"

#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Pms\\Std\\IfxPmsPm.h"
/**
 * \file IfxPmsPm.h
 * \brief PMS  basic functionality
 * \ingroup IfxLld_Pms
 *
 * \version iLLD_1_0_1_15_0_1
 * \copyright Copyright (c) 2019 Infineon Technologies AG. All rights reserved.
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 *
 * \defgroup IfxLld_Pms_Std_Pm PM
 * \ingroup IfxLld_Pms_Std
 * \defgroup IfxLld_Pms_Std_Pm_Enumerations Enumerations
 * \ingroup IfxLld_Pms_Std_Pm
 * \defgroup IfxLld_Pms_Std_Pm_DataStructures Data Structures
 * \ingroup IfxLld_Pms_Std_Pm
 * \defgroup IfxLld_Pms_Std_Pm_SystemModes System Modes
 * \ingroup IfxLld_Pms_Std_Pm
 * \defgroup IfxLld_Pms_Std_Pm_CpuModes Cpu Modes
 * \ingroup IfxLld_Pms_Std_Pm
 * \defgroup IfxLld_Pms_Std_Pm_WakeupModes WakeupModes
 * \ingroup IfxLld_Pms_Std_Pm
 */




/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/


#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\_Impl\\IfxPms_cfg.h"
/**
 * \file IfxPms_cfg.h
 * \brief PMS on-chip implementation data
 * \ingroup IfxLld_Pms
 *
 * \version iLLD_1_0_1_15_0_1
 * \copyright Copyright (c) 2019 Infineon Technologies AG. All rights reserved.
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * \defgroup IfxLld_Pms PMS
 * \ingroup IfxLld
 * \defgroup IfxLld_Pms_Impl Implementation
 * \ingroup IfxLld_Pms
 * \defgroup IfxLld_Pms_Std Pm and Evr Drivers
 * \ingroup IfxLld_Pms
 */




/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/



/******************************************************************************/
/*-----------------------------------Macros-----------------------------------*/
/******************************************************************************/









/** \brief This macro is intended to be defined in Ifx_Cfg.h and is meant to cut off the clock supply to desired modules by writing to their respective CLC.B.DISR or CLC.B.EDIS
 * It is used in IfxPmsPm_startSleepSequenceinFlash().
 * This macro is empty by default.For example:
 *
 *
 * Example usage:
 * #define IFXPMS_DISABLE_MODULES_DURING_SLEEP           * {                                                       *     uint16 passwd = IfxScuWdt_getCpuWatchdogPassword(); *     IfxScuWdt_clearCpuEndinit(passwd);                  *     MODULE_ASCLIN.CLC.B.DISR = 1;                       *          MODULE_EVADC.CLC.B.DISR = 1;                         *          MODULE_EDSADC.CLC.B.DISR = 1;                        *     IfxScuWdt_setCpuEndinit(passwd);                    * }
 */












/** \brief This macro is intended to be defined in Ifx_Cfg.h and is meant to cut off the clock supply to desired modules by writing to their respective CLC.B.DISR or CLC.B.EDIS.
 * It is used in IfxPmsPm_startStandbySequenceInFlash().
 *
 * This macro is empty by default.For example:
 *
 *
 * Example usage:
 * #define IFXPMS_DISABLE_ALL_MODULES_STANDBY           * {                                                       *     uint16 passwd = IfxScuWdt_getCpuWatchdogPassword(); *     IfxScuWdt_clearCpuEndinit(passwd);                  *     MODULE_ASCLIN.CLC.B.DISR = 1;                       *          MODULE_EVADC.CLC.B.DISR = 1;                         *          MODULE_EDSADC.CLC.B.DISR = 1;                        *     IfxScuWdt_setCpuEndinit(passwd);                    * }
 */












/** \brief This macro is intended to be defined in Ifx_Cfg.h and is meant to restore the clock supply to desired modules by writing to their respective CLC.B.DISR.
 * This is used in IfxPmsPm_initiateWakeup()
 * This macro is empty by default.For example:
 *
 *
 * Example usage:
 * #define IFXPMS_WAKEUP_MODULES          * {                                                       *     uint16 passwd = IfxScuWdt_getCpuWatchdogPassword(); *     IfxScuWdt_clearCpuEndinit(passwd);                  *     MODULE_ASCLIN.CLC.B.DISR = 0;                       *          MODULE_EVADC.CLC.B.DISR = 0;                         *          MODULE_EDSADC.CLC.B.DISR = 0;                        *     IfxScuWdt_setCpuEndinit(passwd);                    * }
 */












/** \brief This macro is intended to be defined in Ifx_Cfg.h and is meant to contain any activity the application might need to do after wakeup.
 * This can be done here in this macro or after the control returns from IfxPmsPm_initiateWakeup()
 * This macro is empty by default.
 */




/** \brief Number of cycles to wait after switching to backup clock is triggered before shutting down the oscillator.
 * This is given as a configurable macro because the value required has been seen to vary and so the application may define it in Ifx_Cfg.h.
 */





#line 65 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Pms\\Std\\IfxPmsPm.h"

#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Scu\\Std\\IfxScuWdt.h"
/**
 * \file IfxScuWdt.h
 * \brief SCU  basic functionality
 * \ingroup IfxLld_Scu
 *
 * \version iLLD_1_0_1_15_0_1
 * \copyright Copyright (c) 2019 Infineon Technologies AG. All rights reserved.
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 * This file contains the APIs for SCU Watchdog and Endinit related functions.
 *
 * \defgroup IfxLld_Scu_Std_Wdt Wdt Basic Functionality
 * \ingroup IfxLld_Scu_Std
 * \defgroup IfxLld_Scu_Std_Wdt_Wdt_Configuration Watchdog Configuration functions
 * \ingroup IfxLld_Scu_Std_Wdt
 * \defgroup IfxLld_Scu_Std_Wdt_Wdt_Endinit Watchdog Endinit functions
 * \ingroup IfxLld_Scu_Std_Wdt
 * \defgroup IfxLld_Scu_Std_Wdt_Wdt_Operative Watchdog Operative functions
 * \ingroup IfxLld_Scu_Std_Wdt
 * \defgroup IfxLld_Scu_Std_Wdt_Wdt_Endinit_Usage How to use Endinit APIs?
 * \ingroup IfxLld_Scu_Std_Wdt
 */


















































































































































































































































































































































































































































































































































































































































































#line 66 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Pms\\Std\\IfxPmsPm.h"

#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Pms\\Std\\IfxPmsEvr.h"
/**
 * \file IfxPmsEvr.h
 * \brief PMS  basic functionality
 * \ingroup IfxLld_Pms
 *
 * \version iLLD_1_0_1_15_0_1
 * \copyright Copyright (c) 2019 Infineon Technologies AG. All rights reserved.
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * \defgroup IfxLld_Pms_Std_Evr EVR
 * \ingroup IfxLld_Pms_Std
 * \defgroup IfxLld_Pms_Std_Evr_Enum Enumerations
 * \ingroup IfxLld_Pms_Std_Evr
 * \defgroup IfxLld_Pms_Std_Evr_Over-Voltage Over Voltage Functions
 * \ingroup IfxLld_Pms_Std_Evr
 * \defgroup IfxLld_Pms_Std_Evr_Module Module Functions
 * \ingroup IfxLld_Pms_Std_Evr
 * \defgroup IfxLld_Pms_Std_Evr_Under-Voltage Under Voltage Functions
 * \ingroup IfxLld_Pms_Std_Evr
 * \defgroup IfxLld_Pms_Std_Evr_EVRC EVRC Functions
 * \ingroup IfxLld_Pms_Std_Evr
 * \defgroup IfxLld_Pms_Std_Evr_EVR33 EVR33 Functions
 * \ingroup IfxLld_Pms_Std_Evr
 * \defgroup IfxLld_Pms_Std_Evr_SWD SWD Functions
 * \ingroup IfxLld_Pms_Std_Evr
 */




/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/





#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\Infra\\Sfr\\TC38A\\_Reg\\IfxPms_bf.h"
/**
 * \file IfxPms_bf.h
 * \brief
 * \copyright Copyright (c) 2020 Infineon Technologies AG. All rights reserved.
 *
 *
 * Version: TC38XA_UM_V1.5.0
 * Specification: TC3xx User Manual V1.5.0
 * MAY BE CHANGED BY USER [yes/no]: No
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * \defgroup IfxSfr_Pms_Registers_BitfieldsMask Bitfields mask and offset
 * \ingroup IfxSfr_Pms_Registers
 * 
 */



/******************************************************************************/

/******************************************************************************/

/** \addtogroup IfxSfr_Pms_Registers_BitfieldsMask
 * \{  */
/** \brief Length for Ifx_PMS_ID_Bits.MODREV */


/** \brief Mask for Ifx_PMS_ID_Bits.MODREV */


/** \brief Offset for Ifx_PMS_ID_Bits.MODREV */


/** \brief Length for Ifx_PMS_ID_Bits.MODTYPE */


/** \brief Mask for Ifx_PMS_ID_Bits.MODTYPE */


/** \brief Offset for Ifx_PMS_ID_Bits.MODTYPE */


/** \brief Length for Ifx_PMS_ID_Bits.MODNUMBER */


/** \brief Mask for Ifx_PMS_ID_Bits.MODNUMBER */


/** \brief Offset for Ifx_PMS_ID_Bits.MODNUMBER */


/** \brief Length for Ifx_PMS_EVRSTAT_Bits.EVRC */


/** \brief Mask for Ifx_PMS_EVRSTAT_Bits.EVRC */


/** \brief Offset for Ifx_PMS_EVRSTAT_Bits.EVRC */


/** \brief Length for Ifx_PMS_EVRSTAT_Bits.OVC */


/** \brief Mask for Ifx_PMS_EVRSTAT_Bits.OVC */


/** \brief Offset for Ifx_PMS_EVRSTAT_Bits.OVC */


/** \brief Length for Ifx_PMS_EVRSTAT_Bits.EVR33 */


/** \brief Mask for Ifx_PMS_EVRSTAT_Bits.EVR33 */


/** \brief Offset for Ifx_PMS_EVRSTAT_Bits.EVR33 */


/** \brief Length for Ifx_PMS_EVRSTAT_Bits.OV33 */


/** \brief Mask for Ifx_PMS_EVRSTAT_Bits.OV33 */


/** \brief Offset for Ifx_PMS_EVRSTAT_Bits.OV33 */


/** \brief Length for Ifx_PMS_EVRSTAT_Bits.OVSWD */


/** \brief Mask for Ifx_PMS_EVRSTAT_Bits.OVSWD */


/** \brief Offset for Ifx_PMS_EVRSTAT_Bits.OVSWD */


/** \brief Length for Ifx_PMS_EVRSTAT_Bits.UVC */


/** \brief Mask for Ifx_PMS_EVRSTAT_Bits.UVC */


/** \brief Offset for Ifx_PMS_EVRSTAT_Bits.UVC */


/** \brief Length for Ifx_PMS_EVRSTAT_Bits.UV33 */


/** \brief Mask for Ifx_PMS_EVRSTAT_Bits.UV33 */


/** \brief Offset for Ifx_PMS_EVRSTAT_Bits.UV33 */


/** \brief Length for Ifx_PMS_EVRSTAT_Bits.UVSWD */


/** \brief Mask for Ifx_PMS_EVRSTAT_Bits.UVSWD */


/** \brief Offset for Ifx_PMS_EVRSTAT_Bits.UVSWD */


/** \brief Length for Ifx_PMS_EVRSTAT_Bits.SYNCLCK */


/** \brief Mask for Ifx_PMS_EVRSTAT_Bits.SYNCLCK */


/** \brief Offset for Ifx_PMS_EVRSTAT_Bits.SYNCLCK */


/** \brief Length for Ifx_PMS_EVRSTAT_Bits.EVR33VOK */


/** \brief Mask for Ifx_PMS_EVRSTAT_Bits.EVR33VOK */


/** \brief Offset for Ifx_PMS_EVRSTAT_Bits.EVR33VOK */


/** \brief Length for Ifx_PMS_EVRSTAT_Bits.RSTC */


/** \brief Mask for Ifx_PMS_EVRSTAT_Bits.RSTC */


/** \brief Offset for Ifx_PMS_EVRSTAT_Bits.RSTC */


/** \brief Length for Ifx_PMS_EVRSTAT_Bits.RST33 */


/** \brief Mask for Ifx_PMS_EVRSTAT_Bits.RST33 */


/** \brief Offset for Ifx_PMS_EVRSTAT_Bits.RST33 */


/** \brief Length for Ifx_PMS_EVRSTAT_Bits.RSTSWD */


/** \brief Mask for Ifx_PMS_EVRSTAT_Bits.RSTSWD */


/** \brief Offset for Ifx_PMS_EVRSTAT_Bits.RSTSWD */


/** \brief Length for Ifx_PMS_EVRSTAT_Bits.EVRCSHLV */


/** \brief Mask for Ifx_PMS_EVRSTAT_Bits.EVRCSHLV */


/** \brief Offset for Ifx_PMS_EVRSTAT_Bits.EVRCSHLV */


/** \brief Length for Ifx_PMS_EVRSTAT_Bits.EVRCSHHV */


/** \brief Mask for Ifx_PMS_EVRSTAT_Bits.EVRCSHHV */


/** \brief Offset for Ifx_PMS_EVRSTAT_Bits.EVRCSHHV */


/** \brief Length for Ifx_PMS_EVRSTAT_Bits.EVR33SHLV */


/** \brief Mask for Ifx_PMS_EVRSTAT_Bits.EVR33SHLV */


/** \brief Offset for Ifx_PMS_EVRSTAT_Bits.EVR33SHLV */


/** \brief Length for Ifx_PMS_EVRSTAT_Bits.EVR33SHHV */


/** \brief Mask for Ifx_PMS_EVRSTAT_Bits.EVR33SHHV */


/** \brief Offset for Ifx_PMS_EVRSTAT_Bits.EVR33SHHV */


/** \brief Length for Ifx_PMS_EVRSTAT_Bits.SWDLVL */


/** \brief Mask for Ifx_PMS_EVRSTAT_Bits.SWDLVL */


/** \brief Offset for Ifx_PMS_EVRSTAT_Bits.SWDLVL */


/** \brief Length for Ifx_PMS_EVRSTAT_Bits.SDVOK */


/** \brief Mask for Ifx_PMS_EVRSTAT_Bits.SDVOK */


/** \brief Offset for Ifx_PMS_EVRSTAT_Bits.SDVOK */


/** \brief Length for Ifx_PMS_EVRSTAT_Bits.EVRCMOD */


/** \brief Mask for Ifx_PMS_EVRSTAT_Bits.EVRCMOD */


/** \brief Offset for Ifx_PMS_EVRSTAT_Bits.EVRCMOD */


/** \brief Length for Ifx_PMS_EVRSTAT_Bits.OVPRE */


/** \brief Mask for Ifx_PMS_EVRSTAT_Bits.OVPRE */


/** \brief Offset for Ifx_PMS_EVRSTAT_Bits.OVPRE */


/** \brief Length for Ifx_PMS_EVRSTAT_Bits.OVSB */


/** \brief Mask for Ifx_PMS_EVRSTAT_Bits.OVSB */


/** \brief Offset for Ifx_PMS_EVRSTAT_Bits.OVSB */


/** \brief Length for Ifx_PMS_EVRSTAT_Bits.OVDDM */


/** \brief Mask for Ifx_PMS_EVRSTAT_Bits.OVDDM */


/** \brief Offset for Ifx_PMS_EVRSTAT_Bits.OVDDM */


/** \brief Length for Ifx_PMS_EVRSTAT_Bits.UVPRE */


/** \brief Mask for Ifx_PMS_EVRSTAT_Bits.UVPRE */


/** \brief Offset for Ifx_PMS_EVRSTAT_Bits.UVPRE */


/** \brief Length for Ifx_PMS_EVRSTAT_Bits.UVSB */


/** \brief Mask for Ifx_PMS_EVRSTAT_Bits.UVSB */


/** \brief Offset for Ifx_PMS_EVRSTAT_Bits.UVSB */


/** \brief Length for Ifx_PMS_EVRSTAT_Bits.UVDDM */


/** \brief Mask for Ifx_PMS_EVRSTAT_Bits.UVDDM */


/** \brief Offset for Ifx_PMS_EVRSTAT_Bits.UVDDM */


/** \brief Length for Ifx_PMS_EVRADCSTAT_Bits.ADCCV */


/** \brief Mask for Ifx_PMS_EVRADCSTAT_Bits.ADCCV */


/** \brief Offset for Ifx_PMS_EVRADCSTAT_Bits.ADCCV */


/** \brief Length for Ifx_PMS_EVRADCSTAT_Bits.ADC33V */


/** \brief Mask for Ifx_PMS_EVRADCSTAT_Bits.ADC33V */


/** \brief Offset for Ifx_PMS_EVRADCSTAT_Bits.ADC33V */


/** \brief Length for Ifx_PMS_EVRADCSTAT_Bits.ADCSWDV */


/** \brief Mask for Ifx_PMS_EVRADCSTAT_Bits.ADCSWDV */


/** \brief Offset for Ifx_PMS_EVRADCSTAT_Bits.ADCSWDV */


/** \brief Length for Ifx_PMS_EVRADCSTAT_Bits.OVC */


/** \brief Mask for Ifx_PMS_EVRADCSTAT_Bits.OVC */


/** \brief Offset for Ifx_PMS_EVRADCSTAT_Bits.OVC */


/** \brief Length for Ifx_PMS_EVRADCSTAT_Bits.OV33 */


/** \brief Mask for Ifx_PMS_EVRADCSTAT_Bits.OV33 */


/** \brief Offset for Ifx_PMS_EVRADCSTAT_Bits.OV33 */


/** \brief Length for Ifx_PMS_EVRADCSTAT_Bits.OVSWD */


/** \brief Mask for Ifx_PMS_EVRADCSTAT_Bits.OVSWD */


/** \brief Offset for Ifx_PMS_EVRADCSTAT_Bits.OVSWD */


/** \brief Length for Ifx_PMS_EVRADCSTAT_Bits.UVC */


/** \brief Mask for Ifx_PMS_EVRADCSTAT_Bits.UVC */


/** \brief Offset for Ifx_PMS_EVRADCSTAT_Bits.UVC */


/** \brief Length for Ifx_PMS_EVRADCSTAT_Bits.UV33 */


/** \brief Mask for Ifx_PMS_EVRADCSTAT_Bits.UV33 */


/** \brief Offset for Ifx_PMS_EVRADCSTAT_Bits.UV33 */


/** \brief Length for Ifx_PMS_EVRADCSTAT_Bits.UVSWD */


/** \brief Mask for Ifx_PMS_EVRADCSTAT_Bits.UVSWD */


/** \brief Offset for Ifx_PMS_EVRADCSTAT_Bits.UVSWD */


/** \brief Length for Ifx_PMS_EVRRSTCON_Bits.RSTCTRIM */


/** \brief Mask for Ifx_PMS_EVRRSTCON_Bits.RSTCTRIM */


/** \brief Offset for Ifx_PMS_EVRRSTCON_Bits.RSTCTRIM */


/** \brief Length for Ifx_PMS_EVRRSTCON_Bits.RST33TRIM */


/** \brief Mask for Ifx_PMS_EVRRSTCON_Bits.RST33TRIM */


/** \brief Offset for Ifx_PMS_EVRRSTCON_Bits.RST33TRIM */


/** \brief Length for Ifx_PMS_EVRRSTCON_Bits.RSTSWDTRIM */


/** \brief Mask for Ifx_PMS_EVRRSTCON_Bits.RSTSWDTRIM */


/** \brief Offset for Ifx_PMS_EVRRSTCON_Bits.RSTSWDTRIM */


/** \brief Length for Ifx_PMS_EVRRSTCON_Bits.RSTCOFF */


/** \brief Mask for Ifx_PMS_EVRRSTCON_Bits.RSTCOFF */


/** \brief Offset for Ifx_PMS_EVRRSTCON_Bits.RSTCOFF */


/** \brief Length for Ifx_PMS_EVRRSTCON_Bits.BPRSTCOFF */


/** \brief Mask for Ifx_PMS_EVRRSTCON_Bits.BPRSTCOFF */


/** \brief Offset for Ifx_PMS_EVRRSTCON_Bits.BPRSTCOFF */


/** \brief Length for Ifx_PMS_EVRRSTCON_Bits.RST33OFF */


/** \brief Mask for Ifx_PMS_EVRRSTCON_Bits.RST33OFF */


/** \brief Offset for Ifx_PMS_EVRRSTCON_Bits.RST33OFF */


/** \brief Length for Ifx_PMS_EVRRSTCON_Bits.BPRST33OFF */


/** \brief Mask for Ifx_PMS_EVRRSTCON_Bits.BPRST33OFF */


/** \brief Offset for Ifx_PMS_EVRRSTCON_Bits.BPRST33OFF */


/** \brief Length for Ifx_PMS_EVRRSTCON_Bits.RSTSWDOFF */


/** \brief Mask for Ifx_PMS_EVRRSTCON_Bits.RSTSWDOFF */


/** \brief Offset for Ifx_PMS_EVRRSTCON_Bits.RSTSWDOFF */


/** \brief Length for Ifx_PMS_EVRRSTCON_Bits.BPRSTSWDOFF */


/** \brief Mask for Ifx_PMS_EVRRSTCON_Bits.BPRSTSWDOFF */


/** \brief Offset for Ifx_PMS_EVRRSTCON_Bits.BPRSTSWDOFF */


/** \brief Length for Ifx_PMS_EVRRSTCON_Bits.SLCK */


/** \brief Mask for Ifx_PMS_EVRRSTCON_Bits.SLCK */


/** \brief Offset for Ifx_PMS_EVRRSTCON_Bits.SLCK */


/** \brief Length for Ifx_PMS_EVRRSTSTAT_Bits.RSTC */


/** \brief Mask for Ifx_PMS_EVRRSTSTAT_Bits.RSTC */


/** \brief Offset for Ifx_PMS_EVRRSTSTAT_Bits.RSTC */


/** \brief Length for Ifx_PMS_EVRRSTSTAT_Bits.RST33 */


/** \brief Mask for Ifx_PMS_EVRRSTSTAT_Bits.RST33 */


/** \brief Offset for Ifx_PMS_EVRRSTSTAT_Bits.RST33 */


/** \brief Length for Ifx_PMS_EVRRSTSTAT_Bits.RSTSWD */


/** \brief Mask for Ifx_PMS_EVRRSTSTAT_Bits.RSTSWD */


/** \brief Offset for Ifx_PMS_EVRRSTSTAT_Bits.RSTSWD */


/** \brief Length for Ifx_PMS_EVRRSTSTAT_Bits.RSTCOFF */


/** \brief Mask for Ifx_PMS_EVRRSTSTAT_Bits.RSTCOFF */


/** \brief Offset for Ifx_PMS_EVRRSTSTAT_Bits.RSTCOFF */


/** \brief Length for Ifx_PMS_EVRRSTSTAT_Bits.RST33OFF */


/** \brief Mask for Ifx_PMS_EVRRSTSTAT_Bits.RST33OFF */


/** \brief Offset for Ifx_PMS_EVRRSTSTAT_Bits.RST33OFF */


/** \brief Length for Ifx_PMS_EVRRSTSTAT_Bits.RSTSWDOFF */


/** \brief Mask for Ifx_PMS_EVRRSTSTAT_Bits.RSTSWDOFF */


/** \brief Offset for Ifx_PMS_EVRRSTSTAT_Bits.RSTSWDOFF */


/** \brief Length for Ifx_PMS_EVRTRIM_Bits.EVR33VOUTSEL */


/** \brief Mask for Ifx_PMS_EVRTRIM_Bits.EVR33VOUTSEL */


/** \brief Offset for Ifx_PMS_EVRTRIM_Bits.EVR33VOUTSEL */


/** \brief Length for Ifx_PMS_EVRTRIM_Bits.SDVOUTSEL */


/** \brief Mask for Ifx_PMS_EVRTRIM_Bits.SDVOUTSEL */


/** \brief Offset for Ifx_PMS_EVRTRIM_Bits.SDVOUTSEL */


/** \brief Length for Ifx_PMS_EVRTRIM_Bits.EVR33VOUTTRIM */


/** \brief Mask for Ifx_PMS_EVRTRIM_Bits.EVR33VOUTTRIM */


/** \brief Offset for Ifx_PMS_EVRTRIM_Bits.EVR33VOUTTRIM */


/** \brief Length for Ifx_PMS_EVRTRIM_Bits.SDVOUTTRIM */


/** \brief Mask for Ifx_PMS_EVRTRIM_Bits.SDVOUTTRIM */


/** \brief Offset for Ifx_PMS_EVRTRIM_Bits.SDVOUTTRIM */


/** \brief Length for Ifx_PMS_EVRTRIM_Bits.SLCK */


/** \brief Mask for Ifx_PMS_EVRTRIM_Bits.SLCK */


/** \brief Offset for Ifx_PMS_EVRTRIM_Bits.SLCK */


/** \brief Length for Ifx_PMS_EVRTRIM_Bits.LCK */


/** \brief Mask for Ifx_PMS_EVRTRIM_Bits.LCK */


/** \brief Offset for Ifx_PMS_EVRTRIM_Bits.LCK */


/** \brief Length for Ifx_PMS_EVRTRIMSTAT_Bits.EVR33VOUTSEL */


/** \brief Mask for Ifx_PMS_EVRTRIMSTAT_Bits.EVR33VOUTSEL */


/** \brief Offset for Ifx_PMS_EVRTRIMSTAT_Bits.EVR33VOUTSEL */


/** \brief Length for Ifx_PMS_EVRTRIMSTAT_Bits.SDVOUTSEL */


/** \brief Mask for Ifx_PMS_EVRTRIMSTAT_Bits.SDVOUTSEL */


/** \brief Offset for Ifx_PMS_EVRTRIMSTAT_Bits.SDVOUTSEL */


/** \brief Length for Ifx_PMS_EVRTRIMSTAT_Bits.EVR33VOUTTRIM */


/** \brief Mask for Ifx_PMS_EVRTRIMSTAT_Bits.EVR33VOUTTRIM */


/** \brief Offset for Ifx_PMS_EVRTRIMSTAT_Bits.EVR33VOUTTRIM */


/** \brief Length for Ifx_PMS_EVRTRIMSTAT_Bits.SDVOUTTRIM */


/** \brief Mask for Ifx_PMS_EVRTRIMSTAT_Bits.SDVOUTTRIM */


/** \brief Offset for Ifx_PMS_EVRTRIMSTAT_Bits.SDVOUTTRIM */


/** \brief Length for Ifx_PMS_MONSTAT1_Bits.ADCCV */


/** \brief Mask for Ifx_PMS_MONSTAT1_Bits.ADCCV */


/** \brief Offset for Ifx_PMS_MONSTAT1_Bits.ADCCV */


/** \brief Length for Ifx_PMS_MONSTAT1_Bits.ADC33V */


/** \brief Mask for Ifx_PMS_MONSTAT1_Bits.ADC33V */


/** \brief Offset for Ifx_PMS_MONSTAT1_Bits.ADC33V */


/** \brief Length for Ifx_PMS_MONSTAT1_Bits.ADCSWDV */


/** \brief Mask for Ifx_PMS_MONSTAT1_Bits.ADCSWDV */


/** \brief Offset for Ifx_PMS_MONSTAT1_Bits.ADCSWDV */


/** \brief Length for Ifx_PMS_MONSTAT1_Bits.ACTVCNT */


/** \brief Mask for Ifx_PMS_MONSTAT1_Bits.ACTVCNT */


/** \brief Offset for Ifx_PMS_MONSTAT1_Bits.ACTVCNT */


/** \brief Length for Ifx_PMS_MONSTAT2_Bits.ADCPRE */


/** \brief Mask for Ifx_PMS_MONSTAT2_Bits.ADCPRE */


/** \brief Offset for Ifx_PMS_MONSTAT2_Bits.ADCPRE */


/** \brief Length for Ifx_PMS_MONSTAT2_Bits.ADCSB */


/** \brief Mask for Ifx_PMS_MONSTAT2_Bits.ADCSB */


/** \brief Offset for Ifx_PMS_MONSTAT2_Bits.ADCSB */


/** \brief Length for Ifx_PMS_MONSTAT2_Bits.ADCVDDM */


/** \brief Mask for Ifx_PMS_MONSTAT2_Bits.ADCVDDM */


/** \brief Offset for Ifx_PMS_MONSTAT2_Bits.ADCVDDM */


/** \brief Length for Ifx_PMS_MONCTRL_Bits.EVRCOVMOD */


/** \brief Mask for Ifx_PMS_MONCTRL_Bits.EVRCOVMOD */


/** \brief Offset for Ifx_PMS_MONCTRL_Bits.EVRCOVMOD */


/** \brief Length for Ifx_PMS_MONCTRL_Bits.PREOVMOD */


/** \brief Mask for Ifx_PMS_MONCTRL_Bits.PREOVMOD */


/** \brief Offset for Ifx_PMS_MONCTRL_Bits.PREOVMOD */


/** \brief Length for Ifx_PMS_MONCTRL_Bits.EVRCUVMOD */


/** \brief Mask for Ifx_PMS_MONCTRL_Bits.EVRCUVMOD */


/** \brief Offset for Ifx_PMS_MONCTRL_Bits.EVRCUVMOD */


/** \brief Length for Ifx_PMS_MONCTRL_Bits.PREUVMOD */


/** \brief Mask for Ifx_PMS_MONCTRL_Bits.PREUVMOD */


/** \brief Offset for Ifx_PMS_MONCTRL_Bits.PREUVMOD */


/** \brief Length for Ifx_PMS_MONCTRL_Bits.EVR33OVMOD */


/** \brief Mask for Ifx_PMS_MONCTRL_Bits.EVR33OVMOD */


/** \brief Offset for Ifx_PMS_MONCTRL_Bits.EVR33OVMOD */


/** \brief Length for Ifx_PMS_MONCTRL_Bits.VDDMOVMOD */


/** \brief Mask for Ifx_PMS_MONCTRL_Bits.VDDMOVMOD */


/** \brief Offset for Ifx_PMS_MONCTRL_Bits.VDDMOVMOD */


/** \brief Length for Ifx_PMS_MONCTRL_Bits.EVR33UVMOD */


/** \brief Mask for Ifx_PMS_MONCTRL_Bits.EVR33UVMOD */


/** \brief Offset for Ifx_PMS_MONCTRL_Bits.EVR33UVMOD */


/** \brief Length for Ifx_PMS_MONCTRL_Bits.VDDMUVMOD */


/** \brief Mask for Ifx_PMS_MONCTRL_Bits.VDDMUVMOD */


/** \brief Offset for Ifx_PMS_MONCTRL_Bits.VDDMUVMOD */


/** \brief Length for Ifx_PMS_MONCTRL_Bits.SWDOVMOD */


/** \brief Mask for Ifx_PMS_MONCTRL_Bits.SWDOVMOD */


/** \brief Offset for Ifx_PMS_MONCTRL_Bits.SWDOVMOD */


/** \brief Length for Ifx_PMS_MONCTRL_Bits.SBOVMOD */


/** \brief Mask for Ifx_PMS_MONCTRL_Bits.SBOVMOD */


/** \brief Offset for Ifx_PMS_MONCTRL_Bits.SBOVMOD */


/** \brief Length for Ifx_PMS_MONCTRL_Bits.SWDUVMOD */


/** \brief Mask for Ifx_PMS_MONCTRL_Bits.SWDUVMOD */


/** \brief Offset for Ifx_PMS_MONCTRL_Bits.SWDUVMOD */


/** \brief Length for Ifx_PMS_MONCTRL_Bits.SBUVMOD */


/** \brief Mask for Ifx_PMS_MONCTRL_Bits.SBUVMOD */


/** \brief Offset for Ifx_PMS_MONCTRL_Bits.SBUVMOD */


/** \brief Length for Ifx_PMS_MONCTRL_Bits.SLCK */


/** \brief Mask for Ifx_PMS_MONCTRL_Bits.SLCK */


/** \brief Offset for Ifx_PMS_MONCTRL_Bits.SLCK */


/** \brief Length for Ifx_PMS_MONFILT_Bits.EVRCFIL */


/** \brief Mask for Ifx_PMS_MONFILT_Bits.EVRCFIL */


/** \brief Offset for Ifx_PMS_MONFILT_Bits.EVRCFIL */


/** \brief Length for Ifx_PMS_MONFILT_Bits.PREFIL */


/** \brief Mask for Ifx_PMS_MONFILT_Bits.PREFIL */


/** \brief Offset for Ifx_PMS_MONFILT_Bits.PREFIL */


/** \brief Length for Ifx_PMS_MONFILT_Bits.EVR33FIL */


/** \brief Mask for Ifx_PMS_MONFILT_Bits.EVR33FIL */


/** \brief Offset for Ifx_PMS_MONFILT_Bits.EVR33FIL */


/** \brief Length for Ifx_PMS_MONFILT_Bits.VDDMFIL */


/** \brief Mask for Ifx_PMS_MONFILT_Bits.VDDMFIL */


/** \brief Offset for Ifx_PMS_MONFILT_Bits.VDDMFIL */


/** \brief Length for Ifx_PMS_MONFILT_Bits.SWDFIL */


/** \brief Mask for Ifx_PMS_MONFILT_Bits.SWDFIL */


/** \brief Offset for Ifx_PMS_MONFILT_Bits.SWDFIL */


/** \brief Length for Ifx_PMS_MONFILT_Bits.SBFIL */


/** \brief Mask for Ifx_PMS_MONFILT_Bits.SBFIL */


/** \brief Offset for Ifx_PMS_MONFILT_Bits.SBFIL */


/** \brief Length for Ifx_PMS_MONFILT_Bits.CLRFIL */


/** \brief Mask for Ifx_PMS_MONFILT_Bits.CLRFIL */


/** \brief Offset for Ifx_PMS_MONFILT_Bits.CLRFIL */


/** \brief Length for Ifx_PMS_MONFILT_Bits.SLCK */


/** \brief Mask for Ifx_PMS_MONFILT_Bits.SLCK */


/** \brief Offset for Ifx_PMS_MONFILT_Bits.SLCK */


/** \brief Length for Ifx_PMS_PMSIEN_Bits.OVSWD */


/** \brief Mask for Ifx_PMS_PMSIEN_Bits.OVSWD */


/** \brief Offset for Ifx_PMS_PMSIEN_Bits.OVSWD */


/** \brief Length for Ifx_PMS_PMSIEN_Bits.UVSWD */


/** \brief Mask for Ifx_PMS_PMSIEN_Bits.UVSWD */


/** \brief Offset for Ifx_PMS_PMSIEN_Bits.UVSWD */


/** \brief Length for Ifx_PMS_PMSIEN_Bits.OV33 */


/** \brief Mask for Ifx_PMS_PMSIEN_Bits.OV33 */


/** \brief Offset for Ifx_PMS_PMSIEN_Bits.OV33 */


/** \brief Length for Ifx_PMS_PMSIEN_Bits.UV33 */


/** \brief Mask for Ifx_PMS_PMSIEN_Bits.UV33 */


/** \brief Offset for Ifx_PMS_PMSIEN_Bits.UV33 */


/** \brief Length for Ifx_PMS_PMSIEN_Bits.OVC */


/** \brief Mask for Ifx_PMS_PMSIEN_Bits.OVC */


/** \brief Offset for Ifx_PMS_PMSIEN_Bits.OVC */


/** \brief Length for Ifx_PMS_PMSIEN_Bits.UVC */


/** \brief Mask for Ifx_PMS_PMSIEN_Bits.UVC */


/** \brief Offset for Ifx_PMS_PMSIEN_Bits.UVC */


/** \brief Length for Ifx_PMS_PMSIEN_Bits.OVPRE */


/** \brief Mask for Ifx_PMS_PMSIEN_Bits.OVPRE */


/** \brief Offset for Ifx_PMS_PMSIEN_Bits.OVPRE */


/** \brief Length for Ifx_PMS_PMSIEN_Bits.UVPRE */


/** \brief Mask for Ifx_PMS_PMSIEN_Bits.UVPRE */


/** \brief Offset for Ifx_PMS_PMSIEN_Bits.UVPRE */


/** \brief Length for Ifx_PMS_PMSIEN_Bits.OVDDM */


/** \brief Mask for Ifx_PMS_PMSIEN_Bits.OVDDM */


/** \brief Offset for Ifx_PMS_PMSIEN_Bits.OVDDM */


/** \brief Length for Ifx_PMS_PMSIEN_Bits.UVDDM */


/** \brief Mask for Ifx_PMS_PMSIEN_Bits.UVDDM */


/** \brief Offset for Ifx_PMS_PMSIEN_Bits.UVDDM */


/** \brief Length for Ifx_PMS_PMSIEN_Bits.OVSB */


/** \brief Mask for Ifx_PMS_PMSIEN_Bits.OVSB */


/** \brief Offset for Ifx_PMS_PMSIEN_Bits.OVSB */


/** \brief Length for Ifx_PMS_PMSIEN_Bits.UVSB */


/** \brief Mask for Ifx_PMS_PMSIEN_Bits.UVSB */


/** \brief Offset for Ifx_PMS_PMSIEN_Bits.UVSB */


/** \brief Length for Ifx_PMS_PMSIEN_Bits.EVRCMOD */


/** \brief Mask for Ifx_PMS_PMSIEN_Bits.EVRCMOD */


/** \brief Offset for Ifx_PMS_PMSIEN_Bits.EVRCMOD */


/** \brief Length for Ifx_PMS_PMSIEN_Bits.SDVOK */


/** \brief Mask for Ifx_PMS_PMSIEN_Bits.SDVOK */


/** \brief Offset for Ifx_PMS_PMSIEN_Bits.SDVOK */


/** \brief Length for Ifx_PMS_PMSIEN_Bits.SYNCLCK */


/** \brief Mask for Ifx_PMS_PMSIEN_Bits.SYNCLCK */


/** \brief Offset for Ifx_PMS_PMSIEN_Bits.SYNCLCK */


/** \brief Length for Ifx_PMS_PMSIEN_Bits.SWDLVL */


/** \brief Mask for Ifx_PMS_PMSIEN_Bits.SWDLVL */


/** \brief Offset for Ifx_PMS_PMSIEN_Bits.SWDLVL */


/** \brief Length for Ifx_PMS_PMSIEN_Bits.WUTWKP */


/** \brief Mask for Ifx_PMS_PMSIEN_Bits.WUTWKP */


/** \brief Offset for Ifx_PMS_PMSIEN_Bits.WUTWKP */


/** \brief Length for Ifx_PMS_PMSIEN_Bits.ESR0WKP */


/** \brief Mask for Ifx_PMS_PMSIEN_Bits.ESR0WKP */


/** \brief Offset for Ifx_PMS_PMSIEN_Bits.ESR0WKP */


/** \brief Length for Ifx_PMS_PMSIEN_Bits.ESR1WKP */


/** \brief Mask for Ifx_PMS_PMSIEN_Bits.ESR1WKP */


/** \brief Offset for Ifx_PMS_PMSIEN_Bits.ESR1WKP */


/** \brief Length for Ifx_PMS_PMSIEN_Bits.PINAWKP */


/** \brief Mask for Ifx_PMS_PMSIEN_Bits.PINAWKP */


/** \brief Offset for Ifx_PMS_PMSIEN_Bits.PINAWKP */


/** \brief Length for Ifx_PMS_PMSIEN_Bits.PINBWKP */


/** \brief Mask for Ifx_PMS_PMSIEN_Bits.PINBWKP */


/** \brief Offset for Ifx_PMS_PMSIEN_Bits.PINBWKP */


/** \brief Length for Ifx_PMS_PMSIEN_Bits.SCRINT */


/** \brief Mask for Ifx_PMS_PMSIEN_Bits.SCRINT */


/** \brief Offset for Ifx_PMS_PMSIEN_Bits.SCRINT */


/** \brief Length for Ifx_PMS_PMSIEN_Bits.SCRRST */


/** \brief Mask for Ifx_PMS_PMSIEN_Bits.SCRRST */


/** \brief Offset for Ifx_PMS_PMSIEN_Bits.SCRRST */


/** \brief Length for Ifx_PMS_PMSIEN_Bits.SCRECC */


/** \brief Mask for Ifx_PMS_PMSIEN_Bits.SCRECC */


/** \brief Offset for Ifx_PMS_PMSIEN_Bits.SCRECC */


/** \brief Length for Ifx_PMS_PMSIEN_Bits.SCRWDT */


/** \brief Mask for Ifx_PMS_PMSIEN_Bits.SCRWDT */


/** \brief Offset for Ifx_PMS_PMSIEN_Bits.SCRWDT */


/** \brief Length for Ifx_PMS_UVMON_Bits.EVRCUVVAL */


/** \brief Mask for Ifx_PMS_UVMON_Bits.EVRCUVVAL */


/** \brief Offset for Ifx_PMS_UVMON_Bits.EVRCUVVAL */


/** \brief Length for Ifx_PMS_UVMON_Bits.EVR33UVVAL */


/** \brief Mask for Ifx_PMS_UVMON_Bits.EVR33UVVAL */


/** \brief Offset for Ifx_PMS_UVMON_Bits.EVR33UVVAL */


/** \brief Length for Ifx_PMS_UVMON_Bits.SWDUVVAL */


/** \brief Mask for Ifx_PMS_UVMON_Bits.SWDUVVAL */


/** \brief Offset for Ifx_PMS_UVMON_Bits.SWDUVVAL */


/** \brief Length for Ifx_PMS_UVMON_Bits.SLCK */


/** \brief Mask for Ifx_PMS_UVMON_Bits.SLCK */


/** \brief Offset for Ifx_PMS_UVMON_Bits.SLCK */


/** \brief Length for Ifx_PMS_OVMON_Bits.EVRCOVVAL */


/** \brief Mask for Ifx_PMS_OVMON_Bits.EVRCOVVAL */


/** \brief Offset for Ifx_PMS_OVMON_Bits.EVRCOVVAL */


/** \brief Length for Ifx_PMS_OVMON_Bits.EVR33OVVAL */


/** \brief Mask for Ifx_PMS_OVMON_Bits.EVR33OVVAL */


/** \brief Offset for Ifx_PMS_OVMON_Bits.EVR33OVVAL */


/** \brief Length for Ifx_PMS_OVMON_Bits.SWDOVVAL */


/** \brief Mask for Ifx_PMS_OVMON_Bits.SWDOVVAL */


/** \brief Offset for Ifx_PMS_OVMON_Bits.SWDOVVAL */


/** \brief Length for Ifx_PMS_OVMON_Bits.SLCK */


/** \brief Mask for Ifx_PMS_OVMON_Bits.SLCK */


/** \brief Offset for Ifx_PMS_OVMON_Bits.SLCK */


/** \brief Length for Ifx_PMS_UVMON2_Bits.PREUVVAL */


/** \brief Mask for Ifx_PMS_UVMON2_Bits.PREUVVAL */


/** \brief Offset for Ifx_PMS_UVMON2_Bits.PREUVVAL */


/** \brief Length for Ifx_PMS_UVMON2_Bits.VDDMUVVAL */


/** \brief Mask for Ifx_PMS_UVMON2_Bits.VDDMUVVAL */


/** \brief Offset for Ifx_PMS_UVMON2_Bits.VDDMUVVAL */


/** \brief Length for Ifx_PMS_UVMON2_Bits.SBUVVAL */


/** \brief Mask for Ifx_PMS_UVMON2_Bits.SBUVVAL */


/** \brief Offset for Ifx_PMS_UVMON2_Bits.SBUVVAL */


/** \brief Length for Ifx_PMS_UVMON2_Bits.VDDMLVLSEL */


/** \brief Mask for Ifx_PMS_UVMON2_Bits.VDDMLVLSEL */


/** \brief Offset for Ifx_PMS_UVMON2_Bits.VDDMLVLSEL */


/** \brief Length for Ifx_PMS_UVMON2_Bits.SLCK */


/** \brief Mask for Ifx_PMS_UVMON2_Bits.SLCK */


/** \brief Offset for Ifx_PMS_UVMON2_Bits.SLCK */


/** \brief Length for Ifx_PMS_OVMON2_Bits.PREOVVAL */


/** \brief Mask for Ifx_PMS_OVMON2_Bits.PREOVVAL */


/** \brief Offset for Ifx_PMS_OVMON2_Bits.PREOVVAL */


/** \brief Length for Ifx_PMS_OVMON2_Bits.VDDMOVVAL */


/** \brief Mask for Ifx_PMS_OVMON2_Bits.VDDMOVVAL */


/** \brief Offset for Ifx_PMS_OVMON2_Bits.VDDMOVVAL */


/** \brief Length for Ifx_PMS_OVMON2_Bits.SBOVVAL */


/** \brief Mask for Ifx_PMS_OVMON2_Bits.SBOVVAL */


/** \brief Offset for Ifx_PMS_OVMON2_Bits.SBOVVAL */


/** \brief Length for Ifx_PMS_OVMON2_Bits.SLCK */


/** \brief Mask for Ifx_PMS_OVMON2_Bits.SLCK */


/** \brief Offset for Ifx_PMS_OVMON2_Bits.SLCK */


/** \brief Length for Ifx_PMS_HSMUVMON_Bits.EVRCUVVAL */


/** \brief Mask for Ifx_PMS_HSMUVMON_Bits.EVRCUVVAL */


/** \brief Offset for Ifx_PMS_HSMUVMON_Bits.EVRCUVVAL */


/** \brief Length for Ifx_PMS_HSMUVMON_Bits.EVR33UVVAL */


/** \brief Mask for Ifx_PMS_HSMUVMON_Bits.EVR33UVVAL */


/** \brief Offset for Ifx_PMS_HSMUVMON_Bits.EVR33UVVAL */


/** \brief Length for Ifx_PMS_HSMUVMON_Bits.SWDUVVAL */


/** \brief Mask for Ifx_PMS_HSMUVMON_Bits.SWDUVVAL */


/** \brief Offset for Ifx_PMS_HSMUVMON_Bits.SWDUVVAL */


/** \brief Length for Ifx_PMS_HSMUVMON_Bits.EVRCOFF */


/** \brief Mask for Ifx_PMS_HSMUVMON_Bits.EVRCOFF */


/** \brief Offset for Ifx_PMS_HSMUVMON_Bits.EVRCOFF */


/** \brief Length for Ifx_PMS_HSMUVMON_Bits.EVR33OFF */


/** \brief Mask for Ifx_PMS_HSMUVMON_Bits.EVR33OFF */


/** \brief Offset for Ifx_PMS_HSMUVMON_Bits.EVR33OFF */


/** \brief Length for Ifx_PMS_HSMUVMON_Bits.SWDOFF */


/** \brief Mask for Ifx_PMS_HSMUVMON_Bits.SWDOFF */


/** \brief Offset for Ifx_PMS_HSMUVMON_Bits.SWDOFF */


/** \brief Length for Ifx_PMS_HSMUVMON_Bits.HSMFIL */


/** \brief Mask for Ifx_PMS_HSMUVMON_Bits.HSMFIL */


/** \brief Offset for Ifx_PMS_HSMUVMON_Bits.HSMFIL */


/** \brief Length for Ifx_PMS_HSMUVMON_Bits.SLCK */


/** \brief Mask for Ifx_PMS_HSMUVMON_Bits.SLCK */


/** \brief Offset for Ifx_PMS_HSMUVMON_Bits.SLCK */


/** \brief Length for Ifx_PMS_HSMOVMON_Bits.EVRCOVVAL */


/** \brief Mask for Ifx_PMS_HSMOVMON_Bits.EVRCOVVAL */


/** \brief Offset for Ifx_PMS_HSMOVMON_Bits.EVRCOVVAL */


/** \brief Length for Ifx_PMS_HSMOVMON_Bits.EVR33OVVAL */


/** \brief Mask for Ifx_PMS_HSMOVMON_Bits.EVR33OVVAL */


/** \brief Offset for Ifx_PMS_HSMOVMON_Bits.EVR33OVVAL */


/** \brief Length for Ifx_PMS_HSMOVMON_Bits.SWDOVVAL */


/** \brief Mask for Ifx_PMS_HSMOVMON_Bits.SWDOVVAL */


/** \brief Offset for Ifx_PMS_HSMOVMON_Bits.SWDOVVAL */


/** \brief Length for Ifx_PMS_HSMOVMON_Bits.EVRCOFF */


/** \brief Mask for Ifx_PMS_HSMOVMON_Bits.EVRCOFF */


/** \brief Offset for Ifx_PMS_HSMOVMON_Bits.EVRCOFF */


/** \brief Length for Ifx_PMS_HSMOVMON_Bits.EVR33OFF */


/** \brief Mask for Ifx_PMS_HSMOVMON_Bits.EVR33OFF */


/** \brief Offset for Ifx_PMS_HSMOVMON_Bits.EVR33OFF */


/** \brief Length for Ifx_PMS_HSMOVMON_Bits.SWDOFF */


/** \brief Mask for Ifx_PMS_HSMOVMON_Bits.SWDOFF */


/** \brief Offset for Ifx_PMS_HSMOVMON_Bits.SWDOFF */


/** \brief Length for Ifx_PMS_HSMOVMON_Bits.SLCK */


/** \brief Mask for Ifx_PMS_HSMOVMON_Bits.SLCK */


/** \brief Offset for Ifx_PMS_HSMOVMON_Bits.SLCK */


/** \brief Length for Ifx_PMS_EVR33CON_Bits.SHVH33 */


/** \brief Mask for Ifx_PMS_EVR33CON_Bits.SHVH33 */


/** \brief Offset for Ifx_PMS_EVR33CON_Bits.SHVH33 */


/** \brief Length for Ifx_PMS_EVR33CON_Bits.SHHVEN */


/** \brief Mask for Ifx_PMS_EVR33CON_Bits.SHHVEN */


/** \brief Offset for Ifx_PMS_EVR33CON_Bits.SHHVEN */


/** \brief Length for Ifx_PMS_EVR33CON_Bits.SHLVEN */


/** \brief Mask for Ifx_PMS_EVR33CON_Bits.SHLVEN */


/** \brief Offset for Ifx_PMS_EVR33CON_Bits.SHLVEN */


/** \brief Length for Ifx_PMS_EVR33CON_Bits.SHVL33 */


/** \brief Mask for Ifx_PMS_EVR33CON_Bits.SHVL33 */


/** \brief Offset for Ifx_PMS_EVR33CON_Bits.SHVL33 */


/** \brief Length for Ifx_PMS_EVR33CON_Bits.SLCK */


/** \brief Mask for Ifx_PMS_EVR33CON_Bits.SLCK */


/** \brief Offset for Ifx_PMS_EVR33CON_Bits.SLCK */


/** \brief Length for Ifx_PMS_EVROSCCTRL_Bits.OSCFTRIM */


/** \brief Mask for Ifx_PMS_EVROSCCTRL_Bits.OSCFTRIM */


/** \brief Offset for Ifx_PMS_EVROSCCTRL_Bits.OSCFTRIM */


/** \brief Length for Ifx_PMS_EVROSCCTRL_Bits.OSCFPTRIM */


/** \brief Mask for Ifx_PMS_EVROSCCTRL_Bits.OSCFPTRIM */


/** \brief Offset for Ifx_PMS_EVROSCCTRL_Bits.OSCFPTRIM */


/** \brief Length for Ifx_PMS_EVROSCCTRL_Bits.OSCTEMPOFFS */


/** \brief Mask for Ifx_PMS_EVROSCCTRL_Bits.OSCTEMPOFFS */


/** \brief Offset for Ifx_PMS_EVROSCCTRL_Bits.OSCTEMPOFFS */


/** \brief Length for Ifx_PMS_EVROSCCTRL_Bits.OSCTRIMEN */


/** \brief Mask for Ifx_PMS_EVROSCCTRL_Bits.OSCTRIMEN */


/** \brief Offset for Ifx_PMS_EVROSCCTRL_Bits.OSCTRIMEN */


/** \brief Length for Ifx_PMS_PMSWCR0_Bits.VEXTSTBYEN */


/** \brief Mask for Ifx_PMS_PMSWCR0_Bits.VEXTSTBYEN */


/** \brief Offset for Ifx_PMS_PMSWCR0_Bits.VEXTSTBYEN */


/** \brief Length for Ifx_PMS_PMSWCR0_Bits.VDDSTBYEN */


/** \brief Mask for Ifx_PMS_PMSWCR0_Bits.VDDSTBYEN */


/** \brief Offset for Ifx_PMS_PMSWCR0_Bits.VDDSTBYEN */


/** \brief Length for Ifx_PMS_PMSWCR0_Bits.ESR0DFEN */


/** \brief Mask for Ifx_PMS_PMSWCR0_Bits.ESR0DFEN */


/** \brief Offset for Ifx_PMS_PMSWCR0_Bits.ESR0DFEN */


/** \brief Length for Ifx_PMS_PMSWCR0_Bits.ESR0EDCON */


/** \brief Mask for Ifx_PMS_PMSWCR0_Bits.ESR0EDCON */


/** \brief Offset for Ifx_PMS_PMSWCR0_Bits.ESR0EDCON */


/** \brief Length for Ifx_PMS_PMSWCR0_Bits.ESR1DFEN */


/** \brief Mask for Ifx_PMS_PMSWCR0_Bits.ESR1DFEN */


/** \brief Offset for Ifx_PMS_PMSWCR0_Bits.ESR1DFEN */


/** \brief Length for Ifx_PMS_PMSWCR0_Bits.ESR1EDCON */


/** \brief Mask for Ifx_PMS_PMSWCR0_Bits.ESR1EDCON */


/** \brief Offset for Ifx_PMS_PMSWCR0_Bits.ESR1EDCON */


/** \brief Length for Ifx_PMS_PMSWCR0_Bits.PINADFEN */


/** \brief Mask for Ifx_PMS_PMSWCR0_Bits.PINADFEN */


/** \brief Offset for Ifx_PMS_PMSWCR0_Bits.PINADFEN */


/** \brief Length for Ifx_PMS_PMSWCR0_Bits.PINAEDCON */


/** \brief Mask for Ifx_PMS_PMSWCR0_Bits.PINAEDCON */


/** \brief Offset for Ifx_PMS_PMSWCR0_Bits.PINAEDCON */


/** \brief Length for Ifx_PMS_PMSWCR0_Bits.PINBDFEN */


/** \brief Mask for Ifx_PMS_PMSWCR0_Bits.PINBDFEN */


/** \brief Offset for Ifx_PMS_PMSWCR0_Bits.PINBDFEN */


/** \brief Length for Ifx_PMS_PMSWCR0_Bits.PINBEDCON */


/** \brief Mask for Ifx_PMS_PMSWCR0_Bits.PINBEDCON */


/** \brief Offset for Ifx_PMS_PMSWCR0_Bits.PINBEDCON */


/** \brief Length for Ifx_PMS_PMSWCR0_Bits.STBYRAMSEL */


/** \brief Mask for Ifx_PMS_PMSWCR0_Bits.STBYRAMSEL */


/** \brief Offset for Ifx_PMS_PMSWCR0_Bits.STBYRAMSEL */


/** \brief Length for Ifx_PMS_PMSWCR0_Bits.BLNKFIL */


/** \brief Mask for Ifx_PMS_PMSWCR0_Bits.BLNKFIL */


/** \brief Offset for Ifx_PMS_PMSWCR0_Bits.BLNKFIL */


/** \brief Length for Ifx_PMS_PMSWCR0_Bits.ESR0WKEN */


/** \brief Mask for Ifx_PMS_PMSWCR0_Bits.ESR0WKEN */


/** \brief Offset for Ifx_PMS_PMSWCR0_Bits.ESR0WKEN */


/** \brief Length for Ifx_PMS_PMSWCR0_Bits.ESR1WKEN */


/** \brief Mask for Ifx_PMS_PMSWCR0_Bits.ESR1WKEN */


/** \brief Offset for Ifx_PMS_PMSWCR0_Bits.ESR1WKEN */


/** \brief Length for Ifx_PMS_PMSWCR0_Bits.PINAWKEN */


/** \brief Mask for Ifx_PMS_PMSWCR0_Bits.PINAWKEN */


/** \brief Offset for Ifx_PMS_PMSWCR0_Bits.PINAWKEN */


/** \brief Length for Ifx_PMS_PMSWCR0_Bits.PINBWKEN */


/** \brief Mask for Ifx_PMS_PMSWCR0_Bits.PINBWKEN */


/** \brief Offset for Ifx_PMS_PMSWCR0_Bits.PINBWKEN */


/** \brief Length for Ifx_PMS_PMSWCR0_Bits.PWRWKEN */


/** \brief Mask for Ifx_PMS_PMSWCR0_Bits.PWRWKEN */


/** \brief Offset for Ifx_PMS_PMSWCR0_Bits.PWRWKEN */


/** \brief Length for Ifx_PMS_PMSWCR0_Bits.SCRWKEN */


/** \brief Mask for Ifx_PMS_PMSWCR0_Bits.SCRWKEN */


/** \brief Offset for Ifx_PMS_PMSWCR0_Bits.SCRWKEN */


/** \brief Length for Ifx_PMS_PMSWCR0_Bits.PORSTWKEN */


/** \brief Mask for Ifx_PMS_PMSWCR0_Bits.PORSTWKEN */


/** \brief Offset for Ifx_PMS_PMSWCR0_Bits.PORSTWKEN */


/** \brief Length for Ifx_PMS_PMSWCR0_Bits.WUTWKEN */


/** \brief Mask for Ifx_PMS_PMSWCR0_Bits.WUTWKEN */


/** \brief Offset for Ifx_PMS_PMSWCR0_Bits.WUTWKEN */


/** \brief Length for Ifx_PMS_PMSWCR2_Bits.SCRINT */


/** \brief Mask for Ifx_PMS_PMSWCR2_Bits.SCRINT */


/** \brief Offset for Ifx_PMS_PMSWCR2_Bits.SCRINT */


/** \brief Length for Ifx_PMS_PMSWCR2_Bits.SCRECC */


/** \brief Mask for Ifx_PMS_PMSWCR2_Bits.SCRECC */


/** \brief Offset for Ifx_PMS_PMSWCR2_Bits.SCRECC */


/** \brief Length for Ifx_PMS_PMSWCR2_Bits.SCRWDT */


/** \brief Mask for Ifx_PMS_PMSWCR2_Bits.SCRWDT */


/** \brief Offset for Ifx_PMS_PMSWCR2_Bits.SCRWDT */


/** \brief Length for Ifx_PMS_PMSWCR2_Bits.SCRRST */


/** \brief Mask for Ifx_PMS_PMSWCR2_Bits.SCRRST */


/** \brief Offset for Ifx_PMS_PMSWCR2_Bits.SCRRST */


/** \brief Length for Ifx_PMS_PMSWCR2_Bits.TCINT */


/** \brief Mask for Ifx_PMS_PMSWCR2_Bits.TCINT */


/** \brief Offset for Ifx_PMS_PMSWCR2_Bits.TCINT */


/** \brief Length for Ifx_PMS_PMSWCR2_Bits.TCINTREQ */


/** \brief Mask for Ifx_PMS_PMSWCR2_Bits.TCINTREQ */


/** \brief Offset for Ifx_PMS_PMSWCR2_Bits.TCINTREQ */


/** \brief Length for Ifx_PMS_PMSWCR2_Bits.SMURST */


/** \brief Mask for Ifx_PMS_PMSWCR2_Bits.SMURST */


/** \brief Offset for Ifx_PMS_PMSWCR2_Bits.SMURST */


/** \brief Length for Ifx_PMS_PMSWCR2_Bits.RST */


/** \brief Mask for Ifx_PMS_PMSWCR2_Bits.RST */


/** \brief Offset for Ifx_PMS_PMSWCR2_Bits.RST */


/** \brief Length for Ifx_PMS_PMSWCR3_Bits.WUTREL */


/** \brief Mask for Ifx_PMS_PMSWCR3_Bits.WUTREL */


/** \brief Offset for Ifx_PMS_PMSWCR3_Bits.WUTREL */


/** \brief Length for Ifx_PMS_PMSWCR3_Bits.WUTEN */


/** \brief Mask for Ifx_PMS_PMSWCR3_Bits.WUTEN */


/** \brief Offset for Ifx_PMS_PMSWCR3_Bits.WUTEN */


/** \brief Length for Ifx_PMS_PMSWCR3_Bits.BUSY */


/** \brief Mask for Ifx_PMS_PMSWCR3_Bits.BUSY */


/** \brief Offset for Ifx_PMS_PMSWCR3_Bits.BUSY */


/** \brief Length for Ifx_PMS_PMSWCR3_Bits.WUTDIV */


/** \brief Mask for Ifx_PMS_PMSWCR3_Bits.WUTDIV */


/** \brief Offset for Ifx_PMS_PMSWCR3_Bits.WUTDIV */


/** \brief Length for Ifx_PMS_PMSWCR3_Bits.WUTMODE */


/** \brief Mask for Ifx_PMS_PMSWCR3_Bits.WUTMODE */


/** \brief Offset for Ifx_PMS_PMSWCR3_Bits.WUTMODE */


/** \brief Length for Ifx_PMS_PMSWCR4_Bits.BPSCRSTREQ */


/** \brief Mask for Ifx_PMS_PMSWCR4_Bits.BPSCRSTREQ */


/** \brief Offset for Ifx_PMS_PMSWCR4_Bits.BPSCRSTREQ */


/** \brief Length for Ifx_PMS_PMSWCR4_Bits.SCRSTREQ */


/** \brief Mask for Ifx_PMS_PMSWCR4_Bits.SCRSTREQ */


/** \brief Offset for Ifx_PMS_PMSWCR4_Bits.SCRSTREQ */


/** \brief Length for Ifx_PMS_PMSWCR4_Bits.BPPORSTREQ */


/** \brief Mask for Ifx_PMS_PMSWCR4_Bits.BPPORSTREQ */


/** \brief Offset for Ifx_PMS_PMSWCR4_Bits.BPPORSTREQ */


/** \brief Length for Ifx_PMS_PMSWCR4_Bits.PORSTREQ */


/** \brief Mask for Ifx_PMS_PMSWCR4_Bits.PORSTREQ */


/** \brief Offset for Ifx_PMS_PMSWCR4_Bits.PORSTREQ */


/** \brief Length for Ifx_PMS_PMSWCR4_Bits.SCRCLKSEL */


/** \brief Mask for Ifx_PMS_PMSWCR4_Bits.SCRCLKSEL */


/** \brief Offset for Ifx_PMS_PMSWCR4_Bits.SCRCLKSEL */


/** \brief Length for Ifx_PMS_PMSWCR4_Bits.SCRCFG */


/** \brief Mask for Ifx_PMS_PMSWCR4_Bits.SCRCFG */


/** \brief Offset for Ifx_PMS_PMSWCR4_Bits.SCRCFG */


/** \brief Length for Ifx_PMS_PMSWCR4_Bits.BPSCREN */


/** \brief Mask for Ifx_PMS_PMSWCR4_Bits.BPSCREN */


/** \brief Offset for Ifx_PMS_PMSWCR4_Bits.BPSCREN */


/** \brief Length for Ifx_PMS_PMSWCR4_Bits.SCREN */


/** \brief Mask for Ifx_PMS_PMSWCR4_Bits.SCREN */


/** \brief Offset for Ifx_PMS_PMSWCR4_Bits.SCREN */


/** \brief Length for Ifx_PMS_PMSWCR5_Bits.BPTRISTREQ */


/** \brief Mask for Ifx_PMS_PMSWCR5_Bits.BPTRISTREQ */


/** \brief Offset for Ifx_PMS_PMSWCR5_Bits.BPTRISTREQ */


/** \brief Length for Ifx_PMS_PMSWCR5_Bits.TRISTREQ */


/** \brief Mask for Ifx_PMS_PMSWCR5_Bits.TRISTREQ */


/** \brief Offset for Ifx_PMS_PMSWCR5_Bits.TRISTREQ */


/** \brief Length for Ifx_PMS_PMSWCR5_Bits.ESR0TRIST */


/** \brief Mask for Ifx_PMS_PMSWCR5_Bits.ESR0TRIST */


/** \brief Offset for Ifx_PMS_PMSWCR5_Bits.ESR0TRIST */


/** \brief Length for Ifx_PMS_PMSWCR5_Bits.PORSTDF */


/** \brief Mask for Ifx_PMS_PMSWCR5_Bits.PORSTDF */


/** \brief Offset for Ifx_PMS_PMSWCR5_Bits.PORSTDF */


/** \brief Length for Ifx_PMS_PMSWCR5_Bits.DCDCSYNCO */


/** \brief Mask for Ifx_PMS_PMSWCR5_Bits.DCDCSYNCO */


/** \brief Offset for Ifx_PMS_PMSWCR5_Bits.DCDCSYNCO */


/** \brief Length for Ifx_PMS_PMSWSTAT_Bits.HWCFGEVR */


/** \brief Mask for Ifx_PMS_PMSWSTAT_Bits.HWCFGEVR */


/** \brief Offset for Ifx_PMS_PMSWSTAT_Bits.HWCFGEVR */


/** \brief Length for Ifx_PMS_PMSWSTAT_Bits.HWCFG4 */


/** \brief Mask for Ifx_PMS_PMSWSTAT_Bits.HWCFG4 */


/** \brief Offset for Ifx_PMS_PMSWSTAT_Bits.HWCFG4 */


/** \brief Length for Ifx_PMS_PMSWSTAT_Bits.HWCFG5 */


/** \brief Mask for Ifx_PMS_PMSWSTAT_Bits.HWCFG5 */


/** \brief Offset for Ifx_PMS_PMSWSTAT_Bits.HWCFG5 */


/** \brief Length for Ifx_PMS_PMSWSTAT_Bits.TRIST */


/** \brief Mask for Ifx_PMS_PMSWSTAT_Bits.TRIST */


/** \brief Offset for Ifx_PMS_PMSWSTAT_Bits.TRIST */


/** \brief Length for Ifx_PMS_PMSWSTAT_Bits.TESTMODE */


/** \brief Mask for Ifx_PMS_PMSWSTAT_Bits.TESTMODE */


/** \brief Offset for Ifx_PMS_PMSWSTAT_Bits.TESTMODE */


/** \brief Length for Ifx_PMS_PMSWSTAT_Bits.ESR0TRIST */


/** \brief Mask for Ifx_PMS_PMSWSTAT_Bits.ESR0TRIST */


/** \brief Offset for Ifx_PMS_PMSWSTAT_Bits.ESR0TRIST */


/** \brief Length for Ifx_PMS_PMSWSTAT_Bits.PORSTDF */


/** \brief Mask for Ifx_PMS_PMSWSTAT_Bits.PORSTDF */


/** \brief Offset for Ifx_PMS_PMSWSTAT_Bits.PORSTDF */


/** \brief Length for Ifx_PMS_PMSWSTAT_Bits.SCR */


/** \brief Mask for Ifx_PMS_PMSWSTAT_Bits.SCR */


/** \brief Offset for Ifx_PMS_PMSWSTAT_Bits.SCR */


/** \brief Length for Ifx_PMS_PMSWSTAT_Bits.SCRST */


/** \brief Mask for Ifx_PMS_PMSWSTAT_Bits.SCRST */


/** \brief Offset for Ifx_PMS_PMSWSTAT_Bits.SCRST */


/** \brief Length for Ifx_PMS_PMSWSTAT_Bits.SCRCLK */


/** \brief Mask for Ifx_PMS_PMSWSTAT_Bits.SCRCLK */


/** \brief Offset for Ifx_PMS_PMSWSTAT_Bits.SCRCLK */


/** \brief Length for Ifx_PMS_PMSWSTAT_Bits.PORSTREQ */


/** \brief Mask for Ifx_PMS_PMSWSTAT_Bits.PORSTREQ */


/** \brief Offset for Ifx_PMS_PMSWSTAT_Bits.PORSTREQ */


/** \brief Length for Ifx_PMS_PMSWSTAT_Bits.WUTEN */


/** \brief Mask for Ifx_PMS_PMSWSTAT_Bits.WUTEN */


/** \brief Offset for Ifx_PMS_PMSWSTAT_Bits.WUTEN */


/** \brief Length for Ifx_PMS_PMSWSTAT_Bits.WUTRUN */


/** \brief Mask for Ifx_PMS_PMSWSTAT_Bits.WUTRUN */


/** \brief Offset for Ifx_PMS_PMSWSTAT_Bits.WUTRUN */


/** \brief Length for Ifx_PMS_PMSWSTAT_Bits.WUTMODE */


/** \brief Mask for Ifx_PMS_PMSWSTAT_Bits.WUTMODE */


/** \brief Offset for Ifx_PMS_PMSWSTAT_Bits.WUTMODE */


/** \brief Length for Ifx_PMS_PMSWSTAT_Bits.ESR0INT */


/** \brief Mask for Ifx_PMS_PMSWSTAT_Bits.ESR0INT */


/** \brief Offset for Ifx_PMS_PMSWSTAT_Bits.ESR0INT */


/** \brief Length for Ifx_PMS_PMSWSTAT_Bits.ESR1INT */


/** \brief Mask for Ifx_PMS_PMSWSTAT_Bits.ESR1INT */


/** \brief Offset for Ifx_PMS_PMSWSTAT_Bits.ESR1INT */


/** \brief Length for Ifx_PMS_PMSWSTAT_Bits.PINAINT */


/** \brief Mask for Ifx_PMS_PMSWSTAT_Bits.PINAINT */


/** \brief Offset for Ifx_PMS_PMSWSTAT_Bits.PINAINT */


/** \brief Length for Ifx_PMS_PMSWSTAT_Bits.PINBINT */


/** \brief Mask for Ifx_PMS_PMSWSTAT_Bits.PINBINT */


/** \brief Offset for Ifx_PMS_PMSWSTAT_Bits.PINBINT */


/** \brief Length for Ifx_PMS_PMSWSTAT2_Bits.ESR0WKP */


/** \brief Mask for Ifx_PMS_PMSWSTAT2_Bits.ESR0WKP */


/** \brief Offset for Ifx_PMS_PMSWSTAT2_Bits.ESR0WKP */


/** \brief Length for Ifx_PMS_PMSWSTAT2_Bits.ESR1WKP */


/** \brief Mask for Ifx_PMS_PMSWSTAT2_Bits.ESR1WKP */


/** \brief Offset for Ifx_PMS_PMSWSTAT2_Bits.ESR1WKP */


/** \brief Length for Ifx_PMS_PMSWSTAT2_Bits.PINAWKP */


/** \brief Mask for Ifx_PMS_PMSWSTAT2_Bits.PINAWKP */


/** \brief Offset for Ifx_PMS_PMSWSTAT2_Bits.PINAWKP */


/** \brief Length for Ifx_PMS_PMSWSTAT2_Bits.PINBWKP */


/** \brief Mask for Ifx_PMS_PMSWSTAT2_Bits.PINBWKP */


/** \brief Offset for Ifx_PMS_PMSWSTAT2_Bits.PINBWKP */


/** \brief Length for Ifx_PMS_PMSWSTAT2_Bits.PWRWKP */


/** \brief Mask for Ifx_PMS_PMSWSTAT2_Bits.PWRWKP */


/** \brief Offset for Ifx_PMS_PMSWSTAT2_Bits.PWRWKP */


/** \brief Length for Ifx_PMS_PMSWSTAT2_Bits.SCRWKP */


/** \brief Mask for Ifx_PMS_PMSWSTAT2_Bits.SCRWKP */


/** \brief Offset for Ifx_PMS_PMSWSTAT2_Bits.SCRWKP */


/** \brief Length for Ifx_PMS_PMSWSTAT2_Bits.PORSTWKP */


/** \brief Mask for Ifx_PMS_PMSWSTAT2_Bits.PORSTWKP */


/** \brief Offset for Ifx_PMS_PMSWSTAT2_Bits.PORSTWKP */


/** \brief Length for Ifx_PMS_PMSWSTAT2_Bits.WUTWKP */


/** \brief Mask for Ifx_PMS_PMSWSTAT2_Bits.WUTWKP */


/** \brief Offset for Ifx_PMS_PMSWSTAT2_Bits.WUTWKP */


/** \brief Length for Ifx_PMS_PMSWSTAT2_Bits.ESR0OVRUN */


/** \brief Mask for Ifx_PMS_PMSWSTAT2_Bits.ESR0OVRUN */


/** \brief Offset for Ifx_PMS_PMSWSTAT2_Bits.ESR0OVRUN */


/** \brief Length for Ifx_PMS_PMSWSTAT2_Bits.ESR1OVRUN */


/** \brief Mask for Ifx_PMS_PMSWSTAT2_Bits.ESR1OVRUN */


/** \brief Offset for Ifx_PMS_PMSWSTAT2_Bits.ESR1OVRUN */


/** \brief Length for Ifx_PMS_PMSWSTAT2_Bits.PINAOVRUN */


/** \brief Mask for Ifx_PMS_PMSWSTAT2_Bits.PINAOVRUN */


/** \brief Offset for Ifx_PMS_PMSWSTAT2_Bits.PINAOVRUN */


/** \brief Length for Ifx_PMS_PMSWSTAT2_Bits.PINBOVRUN */


/** \brief Mask for Ifx_PMS_PMSWSTAT2_Bits.PINBOVRUN */


/** \brief Offset for Ifx_PMS_PMSWSTAT2_Bits.PINBOVRUN */


/** \brief Length for Ifx_PMS_PMSWSTAT2_Bits.VDDSTBYEN */


/** \brief Mask for Ifx_PMS_PMSWSTAT2_Bits.VDDSTBYEN */


/** \brief Offset for Ifx_PMS_PMSWSTAT2_Bits.VDDSTBYEN */


/** \brief Length for Ifx_PMS_PMSWSTAT2_Bits.SCROVRUN */


/** \brief Mask for Ifx_PMS_PMSWSTAT2_Bits.SCROVRUN */


/** \brief Offset for Ifx_PMS_PMSWSTAT2_Bits.SCROVRUN */


/** \brief Length for Ifx_PMS_PMSWSTAT2_Bits.PORSTOVRUN */


/** \brief Mask for Ifx_PMS_PMSWSTAT2_Bits.PORSTOVRUN */


/** \brief Offset for Ifx_PMS_PMSWSTAT2_Bits.PORSTOVRUN */


/** \brief Length for Ifx_PMS_PMSWSTAT2_Bits.WUTOVRUN */


/** \brief Mask for Ifx_PMS_PMSWSTAT2_Bits.WUTOVRUN */


/** \brief Offset for Ifx_PMS_PMSWSTAT2_Bits.WUTOVRUN */


/** \brief Length for Ifx_PMS_PMSWSTAT2_Bits.STBYRAM */


/** \brief Mask for Ifx_PMS_PMSWSTAT2_Bits.STBYRAM */


/** \brief Offset for Ifx_PMS_PMSWSTAT2_Bits.STBYRAM */


/** \brief Length for Ifx_PMS_PMSWSTAT2_Bits.VEXTSTBYEN */


/** \brief Mask for Ifx_PMS_PMSWSTAT2_Bits.VEXTSTBYEN */


/** \brief Offset for Ifx_PMS_PMSWSTAT2_Bits.VEXTSTBYEN */


/** \brief Length for Ifx_PMS_PMSWSTAT2_Bits.BLNKFIL */


/** \brief Mask for Ifx_PMS_PMSWSTAT2_Bits.BLNKFIL */


/** \brief Offset for Ifx_PMS_PMSWSTAT2_Bits.BLNKFIL */


/** \brief Length for Ifx_PMS_PMSWSTAT2_Bits.ESR0WKEN */


/** \brief Mask for Ifx_PMS_PMSWSTAT2_Bits.ESR0WKEN */


/** \brief Offset for Ifx_PMS_PMSWSTAT2_Bits.ESR0WKEN */


/** \brief Length for Ifx_PMS_PMSWSTAT2_Bits.ESR1WKEN */


/** \brief Mask for Ifx_PMS_PMSWSTAT2_Bits.ESR1WKEN */


/** \brief Offset for Ifx_PMS_PMSWSTAT2_Bits.ESR1WKEN */


/** \brief Length for Ifx_PMS_PMSWSTAT2_Bits.PINAWKEN */


/** \brief Mask for Ifx_PMS_PMSWSTAT2_Bits.PINAWKEN */


/** \brief Offset for Ifx_PMS_PMSWSTAT2_Bits.PINAWKEN */


/** \brief Length for Ifx_PMS_PMSWSTAT2_Bits.PINBWKEN */


/** \brief Mask for Ifx_PMS_PMSWSTAT2_Bits.PINBWKEN */


/** \brief Offset for Ifx_PMS_PMSWSTAT2_Bits.PINBWKEN */


/** \brief Length for Ifx_PMS_PMSWSTAT2_Bits.PWRWKEN */


/** \brief Mask for Ifx_PMS_PMSWSTAT2_Bits.PWRWKEN */


/** \brief Offset for Ifx_PMS_PMSWSTAT2_Bits.PWRWKEN */


/** \brief Length for Ifx_PMS_PMSWSTAT2_Bits.SCRWKEN */


/** \brief Mask for Ifx_PMS_PMSWSTAT2_Bits.SCRWKEN */


/** \brief Offset for Ifx_PMS_PMSWSTAT2_Bits.SCRWKEN */


/** \brief Length for Ifx_PMS_PMSWSTAT2_Bits.PORSTWKEN */


/** \brief Mask for Ifx_PMS_PMSWSTAT2_Bits.PORSTWKEN */


/** \brief Offset for Ifx_PMS_PMSWSTAT2_Bits.PORSTWKEN */


/** \brief Length for Ifx_PMS_PMSWSTAT2_Bits.WUTWKEN */


/** \brief Mask for Ifx_PMS_PMSWSTAT2_Bits.WUTWKEN */


/** \brief Offset for Ifx_PMS_PMSWSTAT2_Bits.WUTWKEN */


/** \brief Length for Ifx_PMS_PMSWUTCNT_Bits.WUTCNT */


/** \brief Mask for Ifx_PMS_PMSWUTCNT_Bits.WUTCNT */


/** \brief Offset for Ifx_PMS_PMSWUTCNT_Bits.WUTCNT */


/** \brief Length for Ifx_PMS_PMSWSTATCLR_Bits.ESR0WKPCLR */


/** \brief Mask for Ifx_PMS_PMSWSTATCLR_Bits.ESR0WKPCLR */


/** \brief Offset for Ifx_PMS_PMSWSTATCLR_Bits.ESR0WKPCLR */


/** \brief Length for Ifx_PMS_PMSWSTATCLR_Bits.ESR1WKPCLR */


/** \brief Mask for Ifx_PMS_PMSWSTATCLR_Bits.ESR1WKPCLR */


/** \brief Offset for Ifx_PMS_PMSWSTATCLR_Bits.ESR1WKPCLR */


/** \brief Length for Ifx_PMS_PMSWSTATCLR_Bits.PINAWKPCLR */


/** \brief Mask for Ifx_PMS_PMSWSTATCLR_Bits.PINAWKPCLR */


/** \brief Offset for Ifx_PMS_PMSWSTATCLR_Bits.PINAWKPCLR */


/** \brief Length for Ifx_PMS_PMSWSTATCLR_Bits.PINBWKPCLR */


/** \brief Mask for Ifx_PMS_PMSWSTATCLR_Bits.PINBWKPCLR */


/** \brief Offset for Ifx_PMS_PMSWSTATCLR_Bits.PINBWKPCLR */


/** \brief Length for Ifx_PMS_PMSWSTATCLR_Bits.PWRWKPCLR */


/** \brief Mask for Ifx_PMS_PMSWSTATCLR_Bits.PWRWKPCLR */


/** \brief Offset for Ifx_PMS_PMSWSTATCLR_Bits.PWRWKPCLR */


/** \brief Length for Ifx_PMS_PMSWSTATCLR_Bits.SCRWKPCLR */


/** \brief Mask for Ifx_PMS_PMSWSTATCLR_Bits.SCRWKPCLR */


/** \brief Offset for Ifx_PMS_PMSWSTATCLR_Bits.SCRWKPCLR */


/** \brief Length for Ifx_PMS_PMSWSTATCLR_Bits.PORSTWKPCLR */


/** \brief Mask for Ifx_PMS_PMSWSTATCLR_Bits.PORSTWKPCLR */


/** \brief Offset for Ifx_PMS_PMSWSTATCLR_Bits.PORSTWKPCLR */


/** \brief Length for Ifx_PMS_PMSWSTATCLR_Bits.WUTWKPCLR */


/** \brief Mask for Ifx_PMS_PMSWSTATCLR_Bits.WUTWKPCLR */


/** \brief Offset for Ifx_PMS_PMSWSTATCLR_Bits.WUTWKPCLR */


/** \brief Length for Ifx_PMS_PMSWSTATCLR_Bits.ESR0OVRUNCLR */


/** \brief Mask for Ifx_PMS_PMSWSTATCLR_Bits.ESR0OVRUNCLR */


/** \brief Offset for Ifx_PMS_PMSWSTATCLR_Bits.ESR0OVRUNCLR */


/** \brief Length for Ifx_PMS_PMSWSTATCLR_Bits.ESR1OVRUNCLR */


/** \brief Mask for Ifx_PMS_PMSWSTATCLR_Bits.ESR1OVRUNCLR */


/** \brief Offset for Ifx_PMS_PMSWSTATCLR_Bits.ESR1OVRUNCLR */


/** \brief Length for Ifx_PMS_PMSWSTATCLR_Bits.PINAOVRUNCLR */


/** \brief Mask for Ifx_PMS_PMSWSTATCLR_Bits.PINAOVRUNCLR */


/** \brief Offset for Ifx_PMS_PMSWSTATCLR_Bits.PINAOVRUNCLR */


/** \brief Length for Ifx_PMS_PMSWSTATCLR_Bits.PINBOVRUNCLR */


/** \brief Mask for Ifx_PMS_PMSWSTATCLR_Bits.PINBOVRUNCLR */


/** \brief Offset for Ifx_PMS_PMSWSTATCLR_Bits.PINBOVRUNCLR */


/** \brief Length for Ifx_PMS_PMSWSTATCLR_Bits.SCROVRUNCLR */


/** \brief Mask for Ifx_PMS_PMSWSTATCLR_Bits.SCROVRUNCLR */


/** \brief Offset for Ifx_PMS_PMSWSTATCLR_Bits.SCROVRUNCLR */


/** \brief Length for Ifx_PMS_PMSWSTATCLR_Bits.PORSTOVRUNCLR */


/** \brief Mask for Ifx_PMS_PMSWSTATCLR_Bits.PORSTOVRUNCLR */


/** \brief Offset for Ifx_PMS_PMSWSTATCLR_Bits.PORSTOVRUNCLR */


/** \brief Length for Ifx_PMS_PMSWSTATCLR_Bits.WUTOVRUNCLR */


/** \brief Mask for Ifx_PMS_PMSWSTATCLR_Bits.WUTOVRUNCLR */


/** \brief Offset for Ifx_PMS_PMSWSTATCLR_Bits.WUTOVRUNCLR */


/** \brief Length for Ifx_PMS_PMSWSTATCLR_Bits.SCRSTCLR */


/** \brief Mask for Ifx_PMS_PMSWSTATCLR_Bits.SCRSTCLR */


/** \brief Offset for Ifx_PMS_PMSWSTATCLR_Bits.SCRSTCLR */


/** \brief Length for Ifx_PMS_PMSWSTATCLR_Bits.ESR0INTCLR */


/** \brief Mask for Ifx_PMS_PMSWSTATCLR_Bits.ESR0INTCLR */


/** \brief Offset for Ifx_PMS_PMSWSTATCLR_Bits.ESR0INTCLR */


/** \brief Length for Ifx_PMS_PMSWSTATCLR_Bits.ESR1INTCLR */


/** \brief Mask for Ifx_PMS_PMSWSTATCLR_Bits.ESR1INTCLR */


/** \brief Offset for Ifx_PMS_PMSWSTATCLR_Bits.ESR1INTCLR */


/** \brief Length for Ifx_PMS_PMSWSTATCLR_Bits.PINAINTCLR */


/** \brief Mask for Ifx_PMS_PMSWSTATCLR_Bits.PINAINTCLR */


/** \brief Offset for Ifx_PMS_PMSWSTATCLR_Bits.PINAINTCLR */


/** \brief Length for Ifx_PMS_PMSWSTATCLR_Bits.PINBINTCLR */


/** \brief Mask for Ifx_PMS_PMSWSTATCLR_Bits.PINBINTCLR */


/** \brief Offset for Ifx_PMS_PMSWSTATCLR_Bits.PINBINTCLR */


/** \brief Length for Ifx_PMS_EVRSDSTAT0_Bits.ADCFBCV */


/** \brief Mask for Ifx_PMS_EVRSDSTAT0_Bits.ADCFBCV */


/** \brief Offset for Ifx_PMS_EVRSDSTAT0_Bits.ADCFBCV */


/** \brief Length for Ifx_PMS_EVRSDSTAT0_Bits.DPWMOUT */


/** \brief Mask for Ifx_PMS_EVRSDSTAT0_Bits.DPWMOUT */


/** \brief Offset for Ifx_PMS_EVRSDSTAT0_Bits.DPWMOUT */


/** \brief Length for Ifx_PMS_EVRSDCTRL0_Bits.SDFREQSPRD */


/** \brief Mask for Ifx_PMS_EVRSDCTRL0_Bits.SDFREQSPRD */


/** \brief Offset for Ifx_PMS_EVRSDCTRL0_Bits.SDFREQSPRD */


/** \brief Length for Ifx_PMS_EVRSDCTRL0_Bits.SDFREQ */


/** \brief Mask for Ifx_PMS_EVRSDCTRL0_Bits.SDFREQ */


/** \brief Offset for Ifx_PMS_EVRSDCTRL0_Bits.SDFREQ */


/** \brief Length for Ifx_PMS_EVRSDCTRL0_Bits.NGOFF */


/** \brief Mask for Ifx_PMS_EVRSDCTRL0_Bits.NGOFF */


/** \brief Offset for Ifx_PMS_EVRSDCTRL0_Bits.NGOFF */


/** \brief Length for Ifx_PMS_EVRSDCTRL0_Bits.PGOFF */


/** \brief Mask for Ifx_PMS_EVRSDCTRL0_Bits.PGOFF */


/** \brief Offset for Ifx_PMS_EVRSDCTRL0_Bits.PGOFF */


/** \brief Length for Ifx_PMS_EVRSDCTRL0_Bits.UP */


/** \brief Mask for Ifx_PMS_EVRSDCTRL0_Bits.UP */


/** \brief Offset for Ifx_PMS_EVRSDCTRL0_Bits.UP */


/** \brief Length for Ifx_PMS_EVRSDCTRL0_Bits.LCK */


/** \brief Mask for Ifx_PMS_EVRSDCTRL0_Bits.LCK */


/** \brief Offset for Ifx_PMS_EVRSDCTRL0_Bits.LCK */


/** \brief Length for Ifx_PMS_EVRSDCTRL1_Bits.M0TOFF */


/** \brief Mask for Ifx_PMS_EVRSDCTRL1_Bits.M0TOFF */


/** \brief Offset for Ifx_PMS_EVRSDCTRL1_Bits.M0TOFF */


/** \brief Length for Ifx_PMS_EVRSDCTRL1_Bits.M0TON */


/** \brief Mask for Ifx_PMS_EVRSDCTRL1_Bits.M0TON */


/** \brief Offset for Ifx_PMS_EVRSDCTRL1_Bits.M0TON */


/** \brief Length for Ifx_PMS_EVRSDCTRL1_Bits.M0S0COEFF */


/** \brief Mask for Ifx_PMS_EVRSDCTRL1_Bits.M0S0COEFF */


/** \brief Offset for Ifx_PMS_EVRSDCTRL1_Bits.M0S0COEFF */


/** \brief Length for Ifx_PMS_EVRSDCTRL1_Bits.M0DEADBD */


/** \brief Mask for Ifx_PMS_EVRSDCTRL1_Bits.M0DEADBD */


/** \brief Offset for Ifx_PMS_EVRSDCTRL1_Bits.M0DEADBD */


/** \brief Length for Ifx_PMS_EVRSDCTRL1_Bits.M0ADCZB */


/** \brief Mask for Ifx_PMS_EVRSDCTRL1_Bits.M0ADCZB */


/** \brief Offset for Ifx_PMS_EVRSDCTRL1_Bits.M0ADCZB */


/** \brief Length for Ifx_PMS_EVRSDCTRL1_Bits.M0SKIP */


/** \brief Mask for Ifx_PMS_EVRSDCTRL1_Bits.M0SKIP */


/** \brief Offset for Ifx_PMS_EVRSDCTRL1_Bits.M0SKIP */


/** \brief Length for Ifx_PMS_EVRSDCTRL1_Bits.SYNCEN */


/** \brief Mask for Ifx_PMS_EVRSDCTRL1_Bits.SYNCEN */


/** \brief Offset for Ifx_PMS_EVRSDCTRL1_Bits.SYNCEN */


/** \brief Length for Ifx_PMS_EVRSDCTRL1_Bits.LCK */


/** \brief Mask for Ifx_PMS_EVRSDCTRL1_Bits.LCK */


/** \brief Offset for Ifx_PMS_EVRSDCTRL1_Bits.LCK */


/** \brief Length for Ifx_PMS_EVRSDCTRL2_Bits.LPBNDOFFSET */


/** \brief Mask for Ifx_PMS_EVRSDCTRL2_Bits.LPBNDOFFSET */


/** \brief Offset for Ifx_PMS_EVRSDCTRL2_Bits.LPBNDOFFSET */


/** \brief Length for Ifx_PMS_EVRSDCTRL2_Bits.LPBNDWIDTH */


/** \brief Mask for Ifx_PMS_EVRSDCTRL2_Bits.LPBNDWIDTH */


/** \brief Offset for Ifx_PMS_EVRSDCTRL2_Bits.LPBNDWIDTH */


/** \brief Length for Ifx_PMS_EVRSDCTRL2_Bits.LPLPFCOEFF */


/** \brief Mask for Ifx_PMS_EVRSDCTRL2_Bits.LPLPFCOEFF */


/** \brief Offset for Ifx_PMS_EVRSDCTRL2_Bits.LPLPFCOEFF */


/** \brief Length for Ifx_PMS_EVRSDCTRL2_Bits.SDFREQLP */


/** \brief Mask for Ifx_PMS_EVRSDCTRL2_Bits.SDFREQLP */


/** \brief Offset for Ifx_PMS_EVRSDCTRL2_Bits.SDFREQLP */


/** \brief Length for Ifx_PMS_EVRSDCTRL2_Bits.EVRCMOD */


/** \brief Mask for Ifx_PMS_EVRSDCTRL2_Bits.EVRCMOD */


/** \brief Offset for Ifx_PMS_EVRSDCTRL2_Bits.EVRCMOD */


/** \brief Length for Ifx_PMS_EVRSDCTRL2_Bits.LCK */


/** \brief Mask for Ifx_PMS_EVRSDCTRL2_Bits.LCK */


/** \brief Offset for Ifx_PMS_EVRSDCTRL2_Bits.LCK */


/** \brief Length for Ifx_PMS_EVRSDCTRL3_Bits.M1TOFF */


/** \brief Mask for Ifx_PMS_EVRSDCTRL3_Bits.M1TOFF */


/** \brief Offset for Ifx_PMS_EVRSDCTRL3_Bits.M1TOFF */


/** \brief Length for Ifx_PMS_EVRSDCTRL3_Bits.M1TON */


/** \brief Mask for Ifx_PMS_EVRSDCTRL3_Bits.M1TON */


/** \brief Offset for Ifx_PMS_EVRSDCTRL3_Bits.M1TON */


/** \brief Length for Ifx_PMS_EVRSDCTRL3_Bits.M1S0COEFF */


/** \brief Mask for Ifx_PMS_EVRSDCTRL3_Bits.M1S0COEFF */


/** \brief Offset for Ifx_PMS_EVRSDCTRL3_Bits.M1S0COEFF */


/** \brief Length for Ifx_PMS_EVRSDCTRL3_Bits.M1DEADBD */


/** \brief Mask for Ifx_PMS_EVRSDCTRL3_Bits.M1DEADBD */


/** \brief Offset for Ifx_PMS_EVRSDCTRL3_Bits.M1DEADBD */


/** \brief Length for Ifx_PMS_EVRSDCTRL3_Bits.M1ADCZB */


/** \brief Mask for Ifx_PMS_EVRSDCTRL3_Bits.M1ADCZB */


/** \brief Offset for Ifx_PMS_EVRSDCTRL3_Bits.M1ADCZB */


/** \brief Length for Ifx_PMS_EVRSDCTRL3_Bits.M1SKIP */


/** \brief Mask for Ifx_PMS_EVRSDCTRL3_Bits.M1SKIP */


/** \brief Offset for Ifx_PMS_EVRSDCTRL3_Bits.M1SKIP */


/** \brief Length for Ifx_PMS_EVRSDCTRL4_Bits.VOKCFG */


/** \brief Mask for Ifx_PMS_EVRSDCTRL4_Bits.VOKCFG */


/** \brief Offset for Ifx_PMS_EVRSDCTRL4_Bits.VOKCFG */


/** \brief Length for Ifx_PMS_EVRSDCTRL4_Bits.SDFREQST */


/** \brief Mask for Ifx_PMS_EVRSDCTRL4_Bits.SDFREQST */


/** \brief Offset for Ifx_PMS_EVRSDCTRL4_Bits.SDFREQST */


/** \brief Length for Ifx_PMS_EVRSDCTRL5_Bits.M2TOFF */


/** \brief Mask for Ifx_PMS_EVRSDCTRL5_Bits.M2TOFF */


/** \brief Offset for Ifx_PMS_EVRSDCTRL5_Bits.M2TOFF */


/** \brief Length for Ifx_PMS_EVRSDCTRL5_Bits.M2TON */


/** \brief Mask for Ifx_PMS_EVRSDCTRL5_Bits.M2TON */


/** \brief Offset for Ifx_PMS_EVRSDCTRL5_Bits.M2TON */


/** \brief Length for Ifx_PMS_EVRSDCTRL5_Bits.M2S0COEFF */


/** \brief Mask for Ifx_PMS_EVRSDCTRL5_Bits.M2S0COEFF */


/** \brief Offset for Ifx_PMS_EVRSDCTRL5_Bits.M2S0COEFF */


/** \brief Length for Ifx_PMS_EVRSDCTRL5_Bits.M2DEADBD */


/** \brief Mask for Ifx_PMS_EVRSDCTRL5_Bits.M2DEADBD */


/** \brief Offset for Ifx_PMS_EVRSDCTRL5_Bits.M2DEADBD */


/** \brief Length for Ifx_PMS_EVRSDCTRL5_Bits.M2ADCZB */


/** \brief Mask for Ifx_PMS_EVRSDCTRL5_Bits.M2ADCZB */


/** \brief Offset for Ifx_PMS_EVRSDCTRL5_Bits.M2ADCZB */


/** \brief Length for Ifx_PMS_EVRSDCTRL5_Bits.M2SKIP */


/** \brief Mask for Ifx_PMS_EVRSDCTRL5_Bits.M2SKIP */


/** \brief Offset for Ifx_PMS_EVRSDCTRL5_Bits.M2SKIP */


/** \brief Length for Ifx_PMS_EVRSDCTRL6_Bits.SVINTH */


/** \brief Mask for Ifx_PMS_EVRSDCTRL6_Bits.SVINTH */


/** \brief Offset for Ifx_PMS_EVRSDCTRL6_Bits.SVINTH */


/** \brief Length for Ifx_PMS_EVRSDCTRL6_Bits.SVOTH */


/** \brief Mask for Ifx_PMS_EVRSDCTRL6_Bits.SVOTH */


/** \brief Offset for Ifx_PMS_EVRSDCTRL6_Bits.SVOTH */


/** \brief Length for Ifx_PMS_EVRSDCTRL6_Bits.SINCLO */


/** \brief Mask for Ifx_PMS_EVRSDCTRL6_Bits.SINCLO */


/** \brief Offset for Ifx_PMS_EVRSDCTRL6_Bits.SINCLO */


/** \brief Length for Ifx_PMS_EVRSDCTRL6_Bits.SINCHI */


/** \brief Mask for Ifx_PMS_EVRSDCTRL6_Bits.SINCHI */


/** \brief Offset for Ifx_PMS_EVRSDCTRL6_Bits.SINCHI */


/** \brief Length for Ifx_PMS_EVRSDCTRL6_Bits.LCK */


/** \brief Mask for Ifx_PMS_EVRSDCTRL6_Bits.LCK */


/** \brief Offset for Ifx_PMS_EVRSDCTRL6_Bits.LCK */


/** \brief Length for Ifx_PMS_EVRSDCTRL7_Bits.DRVNI */


/** \brief Mask for Ifx_PMS_EVRSDCTRL7_Bits.DRVNI */


/** \brief Offset for Ifx_PMS_EVRSDCTRL7_Bits.DRVNI */


/** \brief Length for Ifx_PMS_EVRSDCTRL7_Bits.DRVPCBF */


/** \brief Mask for Ifx_PMS_EVRSDCTRL7_Bits.DRVPCBF */


/** \brief Offset for Ifx_PMS_EVRSDCTRL7_Bits.DRVPCBF */


/** \brief Length for Ifx_PMS_EVRSDCTRL7_Bits.DRVP */


/** \brief Mask for Ifx_PMS_EVRSDCTRL7_Bits.DRVP */


/** \brief Offset for Ifx_PMS_EVRSDCTRL7_Bits.DRVP */


/** \brief Length for Ifx_PMS_EVRSDCTRL7_Bits.DRVSLOMODE */


/** \brief Mask for Ifx_PMS_EVRSDCTRL7_Bits.DRVSLOMODE */


/** \brief Offset for Ifx_PMS_EVRSDCTRL7_Bits.DRVSLOMODE */


/** \brief Length for Ifx_PMS_EVRSDCTRL7_Bits.DRVSPR */


/** \brief Mask for Ifx_PMS_EVRSDCTRL7_Bits.DRVSPR */


/** \brief Offset for Ifx_PMS_EVRSDCTRL7_Bits.DRVSPR */


/** \brief Length for Ifx_PMS_EVRSDCTRL7_Bits.SYNCDIVFAC */


/** \brief Mask for Ifx_PMS_EVRSDCTRL7_Bits.SYNCDIVFAC */


/** \brief Offset for Ifx_PMS_EVRSDCTRL7_Bits.SYNCDIVFAC */


/** \brief Length for Ifx_PMS_EVRSDCTRL7_Bits.LCK */


/** \brief Mask for Ifx_PMS_EVRSDCTRL7_Bits.LCK */


/** \brief Offset for Ifx_PMS_EVRSDCTRL7_Bits.LCK */


/** \brief Length for Ifx_PMS_EVRSDCTRL8_Bits.FBADCOFFS */


/** \brief Mask for Ifx_PMS_EVRSDCTRL8_Bits.FBADCOFFS */


/** \brief Offset for Ifx_PMS_EVRSDCTRL8_Bits.FBADCOFFS */


/** \brief Length for Ifx_PMS_EVRSDCTRL8_Bits.FBADCSMP */


/** \brief Mask for Ifx_PMS_EVRSDCTRL8_Bits.FBADCSMP */


/** \brief Offset for Ifx_PMS_EVRSDCTRL8_Bits.FBADCSMP */


/** \brief Length for Ifx_PMS_EVRSDCTRL8_Bits.FBADCBLNK */


/** \brief Mask for Ifx_PMS_EVRSDCTRL8_Bits.FBADCBLNK */


/** \brief Offset for Ifx_PMS_EVRSDCTRL8_Bits.FBADCBLNK */


/** \brief Length for Ifx_PMS_EVRSDCTRL8_Bits.FBADCLPF */


/** \brief Mask for Ifx_PMS_EVRSDCTRL8_Bits.FBADCLPF */


/** \brief Offset for Ifx_PMS_EVRSDCTRL8_Bits.FBADCLPF */


/** \brief Length for Ifx_PMS_EVRSDCTRL8_Bits.FBADCERR */


/** \brief Mask for Ifx_PMS_EVRSDCTRL8_Bits.FBADCERR */


/** \brief Offset for Ifx_PMS_EVRSDCTRL8_Bits.FBADCERR */


/** \brief Length for Ifx_PMS_EVRSDCTRL8_Bits.FBADCLSB */


/** \brief Mask for Ifx_PMS_EVRSDCTRL8_Bits.FBADCLSB */


/** \brief Offset for Ifx_PMS_EVRSDCTRL8_Bits.FBADCLSB */


/** \brief Length for Ifx_PMS_EVRSDCTRL8_Bits.LCK */


/** \brief Mask for Ifx_PMS_EVRSDCTRL8_Bits.LCK */


/** \brief Offset for Ifx_PMS_EVRSDCTRL8_Bits.LCK */


/** \brief Length for Ifx_PMS_EVRSDCTRL9_Bits.FFADCOFFS */


/** \brief Mask for Ifx_PMS_EVRSDCTRL9_Bits.FFADCOFFS */


/** \brief Offset for Ifx_PMS_EVRSDCTRL9_Bits.FFADCOFFS */


/** \brief Length for Ifx_PMS_EVRSDCTRL9_Bits.FFADCLPF */


/** \brief Mask for Ifx_PMS_EVRSDCTRL9_Bits.FFADCLPF */


/** \brief Offset for Ifx_PMS_EVRSDCTRL9_Bits.FFADCLPF */


/** \brief Length for Ifx_PMS_EVRSDCTRL9_Bits.LCK */


/** \brief Mask for Ifx_PMS_EVRSDCTRL9_Bits.LCK */


/** \brief Offset for Ifx_PMS_EVRSDCTRL9_Bits.LCK */


/** \brief Length for Ifx_PMS_EVRSDCTRL10_Bits.SHVH */


/** \brief Mask for Ifx_PMS_EVRSDCTRL10_Bits.SHVH */


/** \brief Offset for Ifx_PMS_EVRSDCTRL10_Bits.SHVH */


/** \brief Length for Ifx_PMS_EVRSDCTRL10_Bits.SHVL */


/** \brief Mask for Ifx_PMS_EVRSDCTRL10_Bits.SHVL */


/** \brief Offset for Ifx_PMS_EVRSDCTRL10_Bits.SHVL */


/** \brief Length for Ifx_PMS_EVRSDCTRL10_Bits.SHHVEN */


/** \brief Mask for Ifx_PMS_EVRSDCTRL10_Bits.SHHVEN */


/** \brief Offset for Ifx_PMS_EVRSDCTRL10_Bits.SHHVEN */


/** \brief Length for Ifx_PMS_EVRSDCTRL10_Bits.SHLVEN */


/** \brief Mask for Ifx_PMS_EVRSDCTRL10_Bits.SHLVEN */


/** \brief Offset for Ifx_PMS_EVRSDCTRL10_Bits.SHLVEN */


/** \brief Length for Ifx_PMS_EVRSDCTRL11_Bits.DROOPVH */


/** \brief Mask for Ifx_PMS_EVRSDCTRL11_Bits.DROOPVH */


/** \brief Offset for Ifx_PMS_EVRSDCTRL11_Bits.DROOPVH */


/** \brief Length for Ifx_PMS_EVRSDCTRL11_Bits.DROOPVL */


/** \brief Mask for Ifx_PMS_EVRSDCTRL11_Bits.DROOPVL */


/** \brief Offset for Ifx_PMS_EVRSDCTRL11_Bits.DROOPVL */


/** \brief Length for Ifx_PMS_EVRSDCTRL11_Bits.SYNCMAXDEV */


/** \brief Mask for Ifx_PMS_EVRSDCTRL11_Bits.SYNCMAXDEV */


/** \brief Offset for Ifx_PMS_EVRSDCTRL11_Bits.SYNCMAXDEV */


/** \brief Length for Ifx_PMS_EVRSDCTRL11_Bits.SYNCHYST */


/** \brief Mask for Ifx_PMS_EVRSDCTRL11_Bits.SYNCHYST */


/** \brief Offset for Ifx_PMS_EVRSDCTRL11_Bits.SYNCHYST */


/** \brief Length for Ifx_PMS_EVRSDCTRL11_Bits.SYNCMUXSEL */


/** \brief Mask for Ifx_PMS_EVRSDCTRL11_Bits.SYNCMUXSEL */


/** \brief Offset for Ifx_PMS_EVRSDCTRL11_Bits.SYNCMUXSEL */


/** \brief Length for Ifx_PMS_EVRSDCTRL11_Bits.LCK */


/** \brief Mask for Ifx_PMS_EVRSDCTRL11_Bits.LCK */


/** \brief Offset for Ifx_PMS_EVRSDCTRL11_Bits.LCK */


/** \brief Length for Ifx_PMS_EVRSDCOEFF0_Bits.M0S0EN */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF0_Bits.M0S0EN */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF0_Bits.M0S0EN */


/** \brief Length for Ifx_PMS_EVRSDCOEFF0_Bits.M0S2EN */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF0_Bits.M0S2EN */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF0_Bits.M0S2EN */


/** \brief Length for Ifx_PMS_EVRSDCOEFF0_Bits.M0S3EN */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF0_Bits.M0S3EN */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF0_Bits.M0S3EN */


/** \brief Length for Ifx_PMS_EVRSDCOEFF0_Bits.M0S3CLIP */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF0_Bits.M0S3CLIP */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF0_Bits.M0S3CLIP */


/** \brief Length for Ifx_PMS_EVRSDCOEFF0_Bits.M0S4EN */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF0_Bits.M0S4EN */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF0_Bits.M0S4EN */


/** \brief Length for Ifx_PMS_EVRSDCOEFF0_Bits.M0RAMPEN */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF0_Bits.M0RAMPEN */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF0_Bits.M0RAMPEN */


/** \brief Length for Ifx_PMS_EVRSDCOEFF0_Bits.M0SFRGET */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF0_Bits.M0SFRGET */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF0_Bits.M0SFRGET */


/** \brief Length for Ifx_PMS_EVRSDCOEFF0_Bits.M0SKIPEN */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF0_Bits.M0SKIPEN */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF0_Bits.M0SKIPEN */


/** \brief Length for Ifx_PMS_EVRSDCOEFF0_Bits.M0S3COEFF */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF0_Bits.M0S3COEFF */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF0_Bits.M0S3COEFF */


/** \brief Length for Ifx_PMS_EVRSDCOEFF0_Bits.M0S4COEFF */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF0_Bits.M0S4COEFF */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF0_Bits.M0S4COEFF */


/** \brief Length for Ifx_PMS_EVRSDCOEFF0_Bits.M0SRMPCOEFF */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF0_Bits.M0SRMPCOEFF */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF0_Bits.M0SRMPCOEFF */


/** \brief Length for Ifx_PMS_EVRSDCOEFF0_Bits.M0FGETCOEFF */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF0_Bits.M0FGETCOEFF */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF0_Bits.M0FGETCOEFF */


/** \brief Length for Ifx_PMS_EVRSDCOEFF0_Bits.M0S2COEFF */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF0_Bits.M0S2COEFF */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF0_Bits.M0S2COEFF */


/** \brief Length for Ifx_PMS_EVRSDCOEFF0_Bits.M0S2VINSRC */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF0_Bits.M0S2VINSRC */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF0_Bits.M0S2VINSRC */


/** \brief Length for Ifx_PMS_EVRSDCOEFF0_Bits.M0S2VOSRC */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF0_Bits.M0S2VOSRC */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF0_Bits.M0S2VOSRC */


/** \brief Length for Ifx_PMS_EVRSDCOEFF0_Bits.M0SRMPCOEFFFRAC */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF0_Bits.M0SRMPCOEFFFRAC */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF0_Bits.M0SRMPCOEFFFRAC */


/** \brief Length for Ifx_PMS_EVRSDCOEFF0_Bits.LCK */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF0_Bits.LCK */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF0_Bits.LCK */


/** \brief Length for Ifx_PMS_EVRSDCOEFF1_Bits.M0VOCFLPF */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF1_Bits.M0VOCFLPF */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF1_Bits.M0VOCFLPF */


/** \brief Length for Ifx_PMS_EVRSDCOEFF1_Bits.M0VOCFINC */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF1_Bits.M0VOCFINC */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF1_Bits.M0VOCFINC */


/** \brief Length for Ifx_PMS_EVRSDCOEFF1_Bits.M0VOUT */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF1_Bits.M0VOUT */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF1_Bits.M0VOUT */


/** \brief Length for Ifx_PMS_EVRSDCOEFF1_Bits.M0VIN */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF1_Bits.M0VIN */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF1_Bits.M0VIN */


/** \brief Length for Ifx_PMS_EVRSDCOEFF1_Bits.M0S3COEFFFRAC */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF1_Bits.M0S3COEFFFRAC */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF1_Bits.M0S3COEFFFRAC */


/** \brief Length for Ifx_PMS_EVRSDCOEFF1_Bits.M0S2COEFFFRAC */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF1_Bits.M0S2COEFFFRAC */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF1_Bits.M0S2COEFFFRAC */


/** \brief Length for Ifx_PMS_EVRSDCOEFF1_Bits.LCK */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF1_Bits.LCK */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF1_Bits.LCK */


/** \brief Length for Ifx_PMS_EVRSDCOEFF2_Bits.M1S0EN */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF2_Bits.M1S0EN */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF2_Bits.M1S0EN */


/** \brief Length for Ifx_PMS_EVRSDCOEFF2_Bits.M1S2EN */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF2_Bits.M1S2EN */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF2_Bits.M1S2EN */


/** \brief Length for Ifx_PMS_EVRSDCOEFF2_Bits.M1S3EN */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF2_Bits.M1S3EN */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF2_Bits.M1S3EN */


/** \brief Length for Ifx_PMS_EVRSDCOEFF2_Bits.M1S3CLIP */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF2_Bits.M1S3CLIP */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF2_Bits.M1S3CLIP */


/** \brief Length for Ifx_PMS_EVRSDCOEFF2_Bits.M1S4EN */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF2_Bits.M1S4EN */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF2_Bits.M1S4EN */


/** \brief Length for Ifx_PMS_EVRSDCOEFF2_Bits.M1RAMPEN */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF2_Bits.M1RAMPEN */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF2_Bits.M1RAMPEN */


/** \brief Length for Ifx_PMS_EVRSDCOEFF2_Bits.M1SFRGET */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF2_Bits.M1SFRGET */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF2_Bits.M1SFRGET */


/** \brief Length for Ifx_PMS_EVRSDCOEFF2_Bits.M1SKIPEN */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF2_Bits.M1SKIPEN */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF2_Bits.M1SKIPEN */


/** \brief Length for Ifx_PMS_EVRSDCOEFF2_Bits.M1S3COEFF */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF2_Bits.M1S3COEFF */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF2_Bits.M1S3COEFF */


/** \brief Length for Ifx_PMS_EVRSDCOEFF2_Bits.M1S4COEFF */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF2_Bits.M1S4COEFF */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF2_Bits.M1S4COEFF */


/** \brief Length for Ifx_PMS_EVRSDCOEFF2_Bits.M1SRMPCOEFF */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF2_Bits.M1SRMPCOEFF */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF2_Bits.M1SRMPCOEFF */


/** \brief Length for Ifx_PMS_EVRSDCOEFF2_Bits.M1FGETCOEFF */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF2_Bits.M1FGETCOEFF */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF2_Bits.M1FGETCOEFF */


/** \brief Length for Ifx_PMS_EVRSDCOEFF2_Bits.M1S2COEFF */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF2_Bits.M1S2COEFF */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF2_Bits.M1S2COEFF */


/** \brief Length for Ifx_PMS_EVRSDCOEFF2_Bits.M1S2VINSRC */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF2_Bits.M1S2VINSRC */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF2_Bits.M1S2VINSRC */


/** \brief Length for Ifx_PMS_EVRSDCOEFF2_Bits.M1S2VOSRC */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF2_Bits.M1S2VOSRC */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF2_Bits.M1S2VOSRC */


/** \brief Length for Ifx_PMS_EVRSDCOEFF3_Bits.M1VOCFLPF */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF3_Bits.M1VOCFLPF */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF3_Bits.M1VOCFLPF */


/** \brief Length for Ifx_PMS_EVRSDCOEFF3_Bits.M1VOCFINC */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF3_Bits.M1VOCFINC */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF3_Bits.M1VOCFINC */


/** \brief Length for Ifx_PMS_EVRSDCOEFF3_Bits.M1VOUT */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF3_Bits.M1VOUT */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF3_Bits.M1VOUT */


/** \brief Length for Ifx_PMS_EVRSDCOEFF3_Bits.M1VIN */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF3_Bits.M1VIN */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF3_Bits.M1VIN */


/** \brief Length for Ifx_PMS_EVRSDCOEFF3_Bits.M1S3COEFFFRAC */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF3_Bits.M1S3COEFFFRAC */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF3_Bits.M1S3COEFFFRAC */


/** \brief Length for Ifx_PMS_EVRSDCOEFF3_Bits.M1S2COEFFFRAC */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF3_Bits.M1S2COEFFFRAC */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF3_Bits.M1S2COEFFFRAC */


/** \brief Length for Ifx_PMS_EVRSDCOEFF3_Bits.M1SRMPCOEFFFRAC */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF3_Bits.M1SRMPCOEFFFRAC */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF3_Bits.M1SRMPCOEFFFRAC */


/** \brief Length for Ifx_PMS_EVRSDCOEFF4_Bits.M2S0EN */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF4_Bits.M2S0EN */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF4_Bits.M2S0EN */


/** \brief Length for Ifx_PMS_EVRSDCOEFF4_Bits.M2S2EN */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF4_Bits.M2S2EN */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF4_Bits.M2S2EN */


/** \brief Length for Ifx_PMS_EVRSDCOEFF4_Bits.M2S3EN */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF4_Bits.M2S3EN */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF4_Bits.M2S3EN */


/** \brief Length for Ifx_PMS_EVRSDCOEFF4_Bits.M2S3CLIP */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF4_Bits.M2S3CLIP */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF4_Bits.M2S3CLIP */


/** \brief Length for Ifx_PMS_EVRSDCOEFF4_Bits.M2S4EN */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF4_Bits.M2S4EN */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF4_Bits.M2S4EN */


/** \brief Length for Ifx_PMS_EVRSDCOEFF4_Bits.M2RAMPEN */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF4_Bits.M2RAMPEN */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF4_Bits.M2RAMPEN */


/** \brief Length for Ifx_PMS_EVRSDCOEFF4_Bits.M2SFRGET */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF4_Bits.M2SFRGET */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF4_Bits.M2SFRGET */


/** \brief Length for Ifx_PMS_EVRSDCOEFF4_Bits.M2SKIPEN */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF4_Bits.M2SKIPEN */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF4_Bits.M2SKIPEN */


/** \brief Length for Ifx_PMS_EVRSDCOEFF4_Bits.M2S3COEFF */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF4_Bits.M2S3COEFF */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF4_Bits.M2S3COEFF */


/** \brief Length for Ifx_PMS_EVRSDCOEFF4_Bits.M2S4COEFF */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF4_Bits.M2S4COEFF */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF4_Bits.M2S4COEFF */


/** \brief Length for Ifx_PMS_EVRSDCOEFF4_Bits.M2SRMPCOEFF */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF4_Bits.M2SRMPCOEFF */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF4_Bits.M2SRMPCOEFF */


/** \brief Length for Ifx_PMS_EVRSDCOEFF4_Bits.M2FGETCOEFF */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF4_Bits.M2FGETCOEFF */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF4_Bits.M2FGETCOEFF */


/** \brief Length for Ifx_PMS_EVRSDCOEFF4_Bits.M2S2COEFF */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF4_Bits.M2S2COEFF */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF4_Bits.M2S2COEFF */


/** \brief Length for Ifx_PMS_EVRSDCOEFF4_Bits.M2S2VINSRC */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF4_Bits.M2S2VINSRC */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF4_Bits.M2S2VINSRC */


/** \brief Length for Ifx_PMS_EVRSDCOEFF4_Bits.M2S2VOSRC */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF4_Bits.M2S2VOSRC */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF4_Bits.M2S2VOSRC */


/** \brief Length for Ifx_PMS_EVRSDCOEFF5_Bits.M2VOCFLPF */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF5_Bits.M2VOCFLPF */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF5_Bits.M2VOCFLPF */


/** \brief Length for Ifx_PMS_EVRSDCOEFF5_Bits.M2VOCFINC */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF5_Bits.M2VOCFINC */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF5_Bits.M2VOCFINC */


/** \brief Length for Ifx_PMS_EVRSDCOEFF5_Bits.M2VOUT */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF5_Bits.M2VOUT */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF5_Bits.M2VOUT */


/** \brief Length for Ifx_PMS_EVRSDCOEFF5_Bits.M2VIN */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF5_Bits.M2VIN */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF5_Bits.M2VIN */


/** \brief Length for Ifx_PMS_EVRSDCOEFF5_Bits.M2S3COEFFFRAC */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF5_Bits.M2S3COEFFFRAC */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF5_Bits.M2S3COEFFFRAC */


/** \brief Length for Ifx_PMS_EVRSDCOEFF5_Bits.M2S2COEFFFRAC */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF5_Bits.M2S2COEFFFRAC */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF5_Bits.M2S2COEFFFRAC */


/** \brief Length for Ifx_PMS_EVRSDCOEFF5_Bits.M2SRMPCOEFFFRAC */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF5_Bits.M2SRMPCOEFFFRAC */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF5_Bits.M2SRMPCOEFFFRAC */


/** \brief Length for Ifx_PMS_EVRSDCOEFF6_Bits.CT5REG0 */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF6_Bits.CT5REG0 */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF6_Bits.CT5REG0 */


/** \brief Length for Ifx_PMS_EVRSDCOEFF6_Bits.CT5REG1 */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF6_Bits.CT5REG1 */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF6_Bits.CT5REG1 */


/** \brief Length for Ifx_PMS_EVRSDCOEFF6_Bits.CT5REG2 */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF6_Bits.CT5REG2 */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF6_Bits.CT5REG2 */


/** \brief Length for Ifx_PMS_EVRSDCOEFF6_Bits.LCK */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF6_Bits.LCK */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF6_Bits.LCK */


/** \brief Length for Ifx_PMS_EVRSDCOEFF7_Bits.CT5REG3 */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF7_Bits.CT5REG3 */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF7_Bits.CT5REG3 */


/** \brief Length for Ifx_PMS_EVRSDCOEFF7_Bits.CT5REG4 */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF7_Bits.CT5REG4 */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF7_Bits.CT5REG4 */


/** \brief Length for Ifx_PMS_EVRSDCOEFF7_Bits.LCK */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF7_Bits.LCK */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF7_Bits.LCK */


/** \brief Length for Ifx_PMS_EVRSDCOEFF8_Bits.CT33REG0 */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF8_Bits.CT33REG0 */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF8_Bits.CT33REG0 */


/** \brief Length for Ifx_PMS_EVRSDCOEFF8_Bits.CT33REG1 */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF8_Bits.CT33REG1 */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF8_Bits.CT33REG1 */


/** \brief Length for Ifx_PMS_EVRSDCOEFF8_Bits.CT33REG2 */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF8_Bits.CT33REG2 */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF8_Bits.CT33REG2 */


/** \brief Length for Ifx_PMS_EVRSDCOEFF8_Bits.LCK */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF8_Bits.LCK */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF8_Bits.LCK */


/** \brief Length for Ifx_PMS_EVRSDCOEFF9_Bits.CT33REG3 */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF9_Bits.CT33REG3 */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF9_Bits.CT33REG3 */


/** \brief Length for Ifx_PMS_EVRSDCOEFF9_Bits.CT33REG4 */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF9_Bits.CT33REG4 */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF9_Bits.CT33REG4 */


/** \brief Length for Ifx_PMS_EVRSDCOEFF9_Bits.LCK */


/** \brief Mask for Ifx_PMS_EVRSDCOEFF9_Bits.LCK */


/** \brief Offset for Ifx_PMS_EVRSDCOEFF9_Bits.LCK */


/** \brief Length for Ifx_PMS_AG_STDBY0_Bits.SF4 */


/** \brief Mask for Ifx_PMS_AG_STDBY0_Bits.SF4 */


/** \brief Offset for Ifx_PMS_AG_STDBY0_Bits.SF4 */


/** \brief Length for Ifx_PMS_AG_STDBY0_Bits.SF5 */


/** \brief Mask for Ifx_PMS_AG_STDBY0_Bits.SF5 */


/** \brief Offset for Ifx_PMS_AG_STDBY0_Bits.SF5 */


/** \brief Length for Ifx_PMS_AG_STDBY0_Bits.SF6 */


/** \brief Mask for Ifx_PMS_AG_STDBY0_Bits.SF6 */


/** \brief Offset for Ifx_PMS_AG_STDBY0_Bits.SF6 */


/** \brief Length for Ifx_PMS_AG_STDBY0_Bits.SF7 */


/** \brief Mask for Ifx_PMS_AG_STDBY0_Bits.SF7 */


/** \brief Offset for Ifx_PMS_AG_STDBY0_Bits.SF7 */


/** \brief Length for Ifx_PMS_AG_STDBY0_Bits.SF8 */


/** \brief Mask for Ifx_PMS_AG_STDBY0_Bits.SF8 */


/** \brief Offset for Ifx_PMS_AG_STDBY0_Bits.SF8 */


/** \brief Length for Ifx_PMS_AG_STDBY0_Bits.SF9 */


/** \brief Mask for Ifx_PMS_AG_STDBY0_Bits.SF9 */


/** \brief Offset for Ifx_PMS_AG_STDBY0_Bits.SF9 */


/** \brief Length for Ifx_PMS_AG_STDBY0_Bits.SF10 */


/** \brief Mask for Ifx_PMS_AG_STDBY0_Bits.SF10 */


/** \brief Offset for Ifx_PMS_AG_STDBY0_Bits.SF10 */


/** \brief Length for Ifx_PMS_AG_STDBY0_Bits.SF11 */


/** \brief Mask for Ifx_PMS_AG_STDBY0_Bits.SF11 */


/** \brief Offset for Ifx_PMS_AG_STDBY0_Bits.SF11 */


/** \brief Length for Ifx_PMS_AG_STDBY0_Bits.SF12 */


/** \brief Mask for Ifx_PMS_AG_STDBY0_Bits.SF12 */


/** \brief Offset for Ifx_PMS_AG_STDBY0_Bits.SF12 */


/** \brief Length for Ifx_PMS_AG_STDBY0_Bits.SF13 */


/** \brief Mask for Ifx_PMS_AG_STDBY0_Bits.SF13 */


/** \brief Offset for Ifx_PMS_AG_STDBY0_Bits.SF13 */


/** \brief Length for Ifx_PMS_AG_STDBY0_Bits.SF14 */


/** \brief Mask for Ifx_PMS_AG_STDBY0_Bits.SF14 */


/** \brief Offset for Ifx_PMS_AG_STDBY0_Bits.SF14 */


/** \brief Length for Ifx_PMS_AG_STDBY0_Bits.SF15 */


/** \brief Mask for Ifx_PMS_AG_STDBY0_Bits.SF15 */


/** \brief Offset for Ifx_PMS_AG_STDBY0_Bits.SF15 */


/** \brief Length for Ifx_PMS_AG_STDBY0_Bits.FSPERR */


/** \brief Mask for Ifx_PMS_AG_STDBY0_Bits.FSPERR */


/** \brief Offset for Ifx_PMS_AG_STDBY0_Bits.FSPERR */


/** \brief Length for Ifx_PMS_AG_STDBY1_Bits.SF0 */


/** \brief Mask for Ifx_PMS_AG_STDBY1_Bits.SF0 */


/** \brief Offset for Ifx_PMS_AG_STDBY1_Bits.SF0 */


/** \brief Length for Ifx_PMS_AG_STDBY1_Bits.SF1 */


/** \brief Mask for Ifx_PMS_AG_STDBY1_Bits.SF1 */


/** \brief Offset for Ifx_PMS_AG_STDBY1_Bits.SF1 */


/** \brief Length for Ifx_PMS_AG_STDBY1_Bits.SF2 */


/** \brief Mask for Ifx_PMS_AG_STDBY1_Bits.SF2 */


/** \brief Offset for Ifx_PMS_AG_STDBY1_Bits.SF2 */


/** \brief Length for Ifx_PMS_AG_STDBY1_Bits.SF3 */


/** \brief Mask for Ifx_PMS_AG_STDBY1_Bits.SF3 */


/** \brief Offset for Ifx_PMS_AG_STDBY1_Bits.SF3 */


/** \brief Length for Ifx_PMS_AG_STDBY1_Bits.SF4 */


/** \brief Mask for Ifx_PMS_AG_STDBY1_Bits.SF4 */


/** \brief Offset for Ifx_PMS_AG_STDBY1_Bits.SF4 */


/** \brief Length for Ifx_PMS_AG_STDBY1_Bits.SF5 */


/** \brief Mask for Ifx_PMS_AG_STDBY1_Bits.SF5 */


/** \brief Offset for Ifx_PMS_AG_STDBY1_Bits.SF5 */


/** \brief Length for Ifx_PMS_AG_STDBY1_Bits.SF7 */


/** \brief Mask for Ifx_PMS_AG_STDBY1_Bits.SF7 */


/** \brief Offset for Ifx_PMS_AG_STDBY1_Bits.SF7 */


/** \brief Length for Ifx_PMS_AG_STDBY1_Bits.SF8 */


/** \brief Mask for Ifx_PMS_AG_STDBY1_Bits.SF8 */


/** \brief Offset for Ifx_PMS_AG_STDBY1_Bits.SF8 */


/** \brief Length for Ifx_PMS_AG_STDBY1_Bits.SF9 */


/** \brief Mask for Ifx_PMS_AG_STDBY1_Bits.SF9 */


/** \brief Offset for Ifx_PMS_AG_STDBY1_Bits.SF9 */


/** \brief Length for Ifx_PMS_AG_STDBY1_Bits.SF10 */


/** \brief Mask for Ifx_PMS_AG_STDBY1_Bits.SF10 */


/** \brief Offset for Ifx_PMS_AG_STDBY1_Bits.SF10 */


/** \brief Length for Ifx_PMS_AG_STDBY1_Bits.SF11 */


/** \brief Mask for Ifx_PMS_AG_STDBY1_Bits.SF11 */


/** \brief Offset for Ifx_PMS_AG_STDBY1_Bits.SF11 */


/** \brief Length for Ifx_PMS_AG_STDBY1_Bits.SF12 */


/** \brief Mask for Ifx_PMS_AG_STDBY1_Bits.SF12 */


/** \brief Offset for Ifx_PMS_AG_STDBY1_Bits.SF12 */


/** \brief Length for Ifx_PMS_AG_STDBY1_Bits.SF13 */


/** \brief Mask for Ifx_PMS_AG_STDBY1_Bits.SF13 */


/** \brief Offset for Ifx_PMS_AG_STDBY1_Bits.SF13 */


/** \brief Length for Ifx_PMS_AG_STDBY1_Bits.SF14 */


/** \brief Mask for Ifx_PMS_AG_STDBY1_Bits.SF14 */


/** \brief Offset for Ifx_PMS_AG_STDBY1_Bits.SF14 */


/** \brief Length for Ifx_PMS_AG_STDBY1_Bits.SF15 */


/** \brief Mask for Ifx_PMS_AG_STDBY1_Bits.SF15 */


/** \brief Offset for Ifx_PMS_AG_STDBY1_Bits.SF15 */


/** \brief Length for Ifx_PMS_AG_STDBY1_Bits.SF16 */


/** \brief Mask for Ifx_PMS_AG_STDBY1_Bits.SF16 */


/** \brief Offset for Ifx_PMS_AG_STDBY1_Bits.SF16 */


/** \brief Length for Ifx_PMS_MONBISTSTAT_Bits.TSTOK */


/** \brief Mask for Ifx_PMS_MONBISTSTAT_Bits.TSTOK */


/** \brief Offset for Ifx_PMS_MONBISTSTAT_Bits.TSTOK */


/** \brief Length for Ifx_PMS_MONBISTSTAT_Bits.TSTRUN */


/** \brief Mask for Ifx_PMS_MONBISTSTAT_Bits.TSTRUN */


/** \brief Offset for Ifx_PMS_MONBISTSTAT_Bits.TSTRUN */


/** \brief Length for Ifx_PMS_MONBISTSTAT_Bits.TSTDONE */


/** \brief Mask for Ifx_PMS_MONBISTSTAT_Bits.TSTDONE */


/** \brief Offset for Ifx_PMS_MONBISTSTAT_Bits.TSTDONE */


/** \brief Length for Ifx_PMS_MONBISTSTAT_Bits.SMUERR */


/** \brief Mask for Ifx_PMS_MONBISTSTAT_Bits.SMUERR */


/** \brief Offset for Ifx_PMS_MONBISTSTAT_Bits.SMUERR */


/** \brief Length for Ifx_PMS_MONBISTSTAT_Bits.PMSERR */


/** \brief Mask for Ifx_PMS_MONBISTSTAT_Bits.PMSERR */


/** \brief Offset for Ifx_PMS_MONBISTSTAT_Bits.PMSERR */


/** \brief Length for Ifx_PMS_MONBISTCTRL_Bits.TSTEN */


/** \brief Mask for Ifx_PMS_MONBISTCTRL_Bits.TSTEN */


/** \brief Offset for Ifx_PMS_MONBISTCTRL_Bits.TSTEN */


/** \brief Length for Ifx_PMS_MONBISTCTRL_Bits.TSTCLR */


/** \brief Mask for Ifx_PMS_MONBISTCTRL_Bits.TSTCLR */


/** \brief Offset for Ifx_PMS_MONBISTCTRL_Bits.TSTCLR */


/** \brief Length for Ifx_PMS_MONBISTCTRL_Bits.BITPROT */


/** \brief Mask for Ifx_PMS_MONBISTCTRL_Bits.BITPROT */


/** \brief Offset for Ifx_PMS_MONBISTCTRL_Bits.BITPROT */


/** \brief Length for Ifx_PMS_CMD_STDBY_Bits.SMUEN */


/** \brief Mask for Ifx_PMS_CMD_STDBY_Bits.SMUEN */


/** \brief Offset for Ifx_PMS_CMD_STDBY_Bits.SMUEN */


/** \brief Length for Ifx_PMS_CMD_STDBY_Bits.FSP0EN */


/** \brief Mask for Ifx_PMS_CMD_STDBY_Bits.FSP0EN */


/** \brief Offset for Ifx_PMS_CMD_STDBY_Bits.FSP0EN */


/** \brief Length for Ifx_PMS_CMD_STDBY_Bits.FSP1EN */


/** \brief Mask for Ifx_PMS_CMD_STDBY_Bits.FSP1EN */


/** \brief Offset for Ifx_PMS_CMD_STDBY_Bits.FSP1EN */


/** \brief Length for Ifx_PMS_CMD_STDBY_Bits.ASCE */


/** \brief Mask for Ifx_PMS_CMD_STDBY_Bits.ASCE */


/** \brief Offset for Ifx_PMS_CMD_STDBY_Bits.ASCE */


/** \brief Length for Ifx_PMS_CMD_STDBY_Bits.BITPROT */


/** \brief Mask for Ifx_PMS_CMD_STDBY_Bits.BITPROT */


/** \brief Offset for Ifx_PMS_CMD_STDBY_Bits.BITPROT */


/** \brief Length for Ifx_PMS_AGFSP_STDBY0_Bits.FE4 */


/** \brief Mask for Ifx_PMS_AGFSP_STDBY0_Bits.FE4 */


/** \brief Offset for Ifx_PMS_AGFSP_STDBY0_Bits.FE4 */


/** \brief Length for Ifx_PMS_AGFSP_STDBY0_Bits.FE5 */


/** \brief Mask for Ifx_PMS_AGFSP_STDBY0_Bits.FE5 */


/** \brief Offset for Ifx_PMS_AGFSP_STDBY0_Bits.FE5 */


/** \brief Length for Ifx_PMS_AGFSP_STDBY0_Bits.FE6 */


/** \brief Mask for Ifx_PMS_AGFSP_STDBY0_Bits.FE6 */


/** \brief Offset for Ifx_PMS_AGFSP_STDBY0_Bits.FE6 */


/** \brief Length for Ifx_PMS_AGFSP_STDBY0_Bits.FE7 */


/** \brief Mask for Ifx_PMS_AGFSP_STDBY0_Bits.FE7 */


/** \brief Offset for Ifx_PMS_AGFSP_STDBY0_Bits.FE7 */


/** \brief Length for Ifx_PMS_AGFSP_STDBY0_Bits.FE8 */


/** \brief Mask for Ifx_PMS_AGFSP_STDBY0_Bits.FE8 */


/** \brief Offset for Ifx_PMS_AGFSP_STDBY0_Bits.FE8 */


/** \brief Length for Ifx_PMS_AGFSP_STDBY0_Bits.FE9 */


/** \brief Mask for Ifx_PMS_AGFSP_STDBY0_Bits.FE9 */


/** \brief Offset for Ifx_PMS_AGFSP_STDBY0_Bits.FE9 */


/** \brief Length for Ifx_PMS_AGFSP_STDBY0_Bits.FE10 */


/** \brief Mask for Ifx_PMS_AGFSP_STDBY0_Bits.FE10 */


/** \brief Offset for Ifx_PMS_AGFSP_STDBY0_Bits.FE10 */


/** \brief Length for Ifx_PMS_AGFSP_STDBY0_Bits.FE11 */


/** \brief Mask for Ifx_PMS_AGFSP_STDBY0_Bits.FE11 */


/** \brief Offset for Ifx_PMS_AGFSP_STDBY0_Bits.FE11 */


/** \brief Length for Ifx_PMS_AGFSP_STDBY0_Bits.FE12 */


/** \brief Mask for Ifx_PMS_AGFSP_STDBY0_Bits.FE12 */


/** \brief Offset for Ifx_PMS_AGFSP_STDBY0_Bits.FE12 */


/** \brief Length for Ifx_PMS_AGFSP_STDBY0_Bits.FE13 */


/** \brief Mask for Ifx_PMS_AGFSP_STDBY0_Bits.FE13 */


/** \brief Offset for Ifx_PMS_AGFSP_STDBY0_Bits.FE13 */


/** \brief Length for Ifx_PMS_AGFSP_STDBY0_Bits.FE14 */


/** \brief Mask for Ifx_PMS_AGFSP_STDBY0_Bits.FE14 */


/** \brief Offset for Ifx_PMS_AGFSP_STDBY0_Bits.FE14 */


/** \brief Length for Ifx_PMS_AGFSP_STDBY0_Bits.FE15 */


/** \brief Mask for Ifx_PMS_AGFSP_STDBY0_Bits.FE15 */


/** \brief Offset for Ifx_PMS_AGFSP_STDBY0_Bits.FE15 */


/** \brief Length for Ifx_PMS_AGFSP_STDBY0_Bits.BITPROT */


/** \brief Mask for Ifx_PMS_AGFSP_STDBY0_Bits.BITPROT */


/** \brief Offset for Ifx_PMS_AGFSP_STDBY0_Bits.BITPROT */


/** \brief Length for Ifx_PMS_AGFSP_STDBY1_Bits.FE0 */


/** \brief Mask for Ifx_PMS_AGFSP_STDBY1_Bits.FE0 */


/** \brief Offset for Ifx_PMS_AGFSP_STDBY1_Bits.FE0 */


/** \brief Length for Ifx_PMS_AGFSP_STDBY1_Bits.FE1 */


/** \brief Mask for Ifx_PMS_AGFSP_STDBY1_Bits.FE1 */


/** \brief Offset for Ifx_PMS_AGFSP_STDBY1_Bits.FE1 */


/** \brief Length for Ifx_PMS_AGFSP_STDBY1_Bits.FE2 */


/** \brief Mask for Ifx_PMS_AGFSP_STDBY1_Bits.FE2 */


/** \brief Offset for Ifx_PMS_AGFSP_STDBY1_Bits.FE2 */


/** \brief Length for Ifx_PMS_AGFSP_STDBY1_Bits.FE3 */


/** \brief Mask for Ifx_PMS_AGFSP_STDBY1_Bits.FE3 */


/** \brief Offset for Ifx_PMS_AGFSP_STDBY1_Bits.FE3 */


/** \brief Length for Ifx_PMS_AGFSP_STDBY1_Bits.FE4 */


/** \brief Mask for Ifx_PMS_AGFSP_STDBY1_Bits.FE4 */


/** \brief Offset for Ifx_PMS_AGFSP_STDBY1_Bits.FE4 */


/** \brief Length for Ifx_PMS_AGFSP_STDBY1_Bits.FE5 */


/** \brief Mask for Ifx_PMS_AGFSP_STDBY1_Bits.FE5 */


/** \brief Offset for Ifx_PMS_AGFSP_STDBY1_Bits.FE5 */


/** \brief Length for Ifx_PMS_AGFSP_STDBY1_Bits.FE7 */


/** \brief Mask for Ifx_PMS_AGFSP_STDBY1_Bits.FE7 */


/** \brief Offset for Ifx_PMS_AGFSP_STDBY1_Bits.FE7 */


/** \brief Length for Ifx_PMS_AGFSP_STDBY1_Bits.FE8 */


/** \brief Mask for Ifx_PMS_AGFSP_STDBY1_Bits.FE8 */


/** \brief Offset for Ifx_PMS_AGFSP_STDBY1_Bits.FE8 */


/** \brief Length for Ifx_PMS_AGFSP_STDBY1_Bits.FE9 */


/** \brief Mask for Ifx_PMS_AGFSP_STDBY1_Bits.FE9 */


/** \brief Offset for Ifx_PMS_AGFSP_STDBY1_Bits.FE9 */


/** \brief Length for Ifx_PMS_AGFSP_STDBY1_Bits.FE10 */


/** \brief Mask for Ifx_PMS_AGFSP_STDBY1_Bits.FE10 */


/** \brief Offset for Ifx_PMS_AGFSP_STDBY1_Bits.FE10 */


/** \brief Length for Ifx_PMS_AGFSP_STDBY1_Bits.FE11 */


/** \brief Mask for Ifx_PMS_AGFSP_STDBY1_Bits.FE11 */


/** \brief Offset for Ifx_PMS_AGFSP_STDBY1_Bits.FE11 */


/** \brief Length for Ifx_PMS_AGFSP_STDBY1_Bits.FE12 */


/** \brief Mask for Ifx_PMS_AGFSP_STDBY1_Bits.FE12 */


/** \brief Offset for Ifx_PMS_AGFSP_STDBY1_Bits.FE12 */


/** \brief Length for Ifx_PMS_AGFSP_STDBY1_Bits.FE13 */


/** \brief Mask for Ifx_PMS_AGFSP_STDBY1_Bits.FE13 */


/** \brief Offset for Ifx_PMS_AGFSP_STDBY1_Bits.FE13 */


/** \brief Length for Ifx_PMS_AGFSP_STDBY1_Bits.FE14 */


/** \brief Mask for Ifx_PMS_AGFSP_STDBY1_Bits.FE14 */


/** \brief Offset for Ifx_PMS_AGFSP_STDBY1_Bits.FE14 */


/** \brief Length for Ifx_PMS_AGFSP_STDBY1_Bits.FE15 */


/** \brief Mask for Ifx_PMS_AGFSP_STDBY1_Bits.FE15 */


/** \brief Offset for Ifx_PMS_AGFSP_STDBY1_Bits.FE15 */


/** \brief Length for Ifx_PMS_AGFSP_STDBY1_Bits.FE16 */


/** \brief Mask for Ifx_PMS_AGFSP_STDBY1_Bits.FE16 */


/** \brief Offset for Ifx_PMS_AGFSP_STDBY1_Bits.FE16 */


/** \brief Length for Ifx_PMS_AGFSP_STDBY1_Bits.BITPROT */


/** \brief Mask for Ifx_PMS_AGFSP_STDBY1_Bits.BITPROT */


/** \brief Offset for Ifx_PMS_AGFSP_STDBY1_Bits.BITPROT */


/** \brief Length for Ifx_PMS_DTSSTAT_Bits.RESULT */


/** \brief Mask for Ifx_PMS_DTSSTAT_Bits.RESULT */


/** \brief Offset for Ifx_PMS_DTSSTAT_Bits.RESULT */


/** \brief Length for Ifx_PMS_DTSLIM_Bits.LOWER */


/** \brief Mask for Ifx_PMS_DTSLIM_Bits.LOWER */


/** \brief Offset for Ifx_PMS_DTSLIM_Bits.LOWER */


/** \brief Length for Ifx_PMS_DTSLIM_Bits.LLU */


/** \brief Mask for Ifx_PMS_DTSLIM_Bits.LLU */


/** \brief Offset for Ifx_PMS_DTSLIM_Bits.LLU */


/** \brief Length for Ifx_PMS_DTSLIM_Bits.UPPER */


/** \brief Mask for Ifx_PMS_DTSLIM_Bits.UPPER */


/** \brief Offset for Ifx_PMS_DTSLIM_Bits.UPPER */


/** \brief Length for Ifx_PMS_DTSLIM_Bits.SLCK */


/** \brief Mask for Ifx_PMS_DTSLIM_Bits.SLCK */


/** \brief Offset for Ifx_PMS_DTSLIM_Bits.SLCK */


/** \brief Length for Ifx_PMS_DTSLIM_Bits.UOF */


/** \brief Mask for Ifx_PMS_DTSLIM_Bits.UOF */


/** \brief Offset for Ifx_PMS_DTSLIM_Bits.UOF */


/** \brief Length for Ifx_PMS_OTSS_Bits.OTGB0 */


/** \brief Mask for Ifx_PMS_OTSS_Bits.OTGB0 */


/** \brief Offset for Ifx_PMS_OTSS_Bits.OTGB0 */


/** \brief Length for Ifx_PMS_OTSS_Bits.OTGB1 */


/** \brief Mask for Ifx_PMS_OTSS_Bits.OTGB1 */


/** \brief Offset for Ifx_PMS_OTSS_Bits.OTGB1 */


/** \brief Length for Ifx_PMS_OTSC0_Bits.B0LAM */


/** \brief Mask for Ifx_PMS_OTSC0_Bits.B0LAM */


/** \brief Offset for Ifx_PMS_OTSC0_Bits.B0LAM */


/** \brief Length for Ifx_PMS_OTSC0_Bits.B0HAM */


/** \brief Mask for Ifx_PMS_OTSC0_Bits.B0HAM */


/** \brief Offset for Ifx_PMS_OTSC0_Bits.B0HAM */


/** \brief Length for Ifx_PMS_OTSC0_Bits.B1LAM */


/** \brief Mask for Ifx_PMS_OTSC0_Bits.B1LAM */


/** \brief Offset for Ifx_PMS_OTSC0_Bits.B1LAM */


/** \brief Length for Ifx_PMS_OTSC0_Bits.B1HAM */


/** \brief Mask for Ifx_PMS_OTSC0_Bits.B1HAM */


/** \brief Offset for Ifx_PMS_OTSC0_Bits.B1HAM */


/** \brief Length for Ifx_PMS_OTSC1_Bits.B0EC */


/** \brief Mask for Ifx_PMS_OTSC1_Bits.B0EC */


/** \brief Offset for Ifx_PMS_OTSC1_Bits.B0EC */


/** \brief Length for Ifx_PMS_OTSC1_Bits.B1EC */


/** \brief Mask for Ifx_PMS_OTSC1_Bits.B1EC */


/** \brief Offset for Ifx_PMS_OTSC1_Bits.B1EC */


/** \brief Length for Ifx_PMS_OTSC1_Bits.DMONAD */


/** \brief Mask for Ifx_PMS_OTSC1_Bits.DMONAD */


/** \brief Offset for Ifx_PMS_OTSC1_Bits.DMONAD */


/** \brief Length for Ifx_PMS_OTSC1_Bits.SMCDBG */


/** \brief Mask for Ifx_PMS_OTSC1_Bits.SMCDBG */


/** \brief Offset for Ifx_PMS_OTSC1_Bits.SMCDBG */


/** \brief Length for Ifx_PMS_ACCEN0_Bits.EN0 */


/** \brief Mask for Ifx_PMS_ACCEN0_Bits.EN0 */


/** \brief Offset for Ifx_PMS_ACCEN0_Bits.EN0 */


/** \brief Length for Ifx_PMS_ACCEN0_Bits.EN1 */


/** \brief Mask for Ifx_PMS_ACCEN0_Bits.EN1 */


/** \brief Offset for Ifx_PMS_ACCEN0_Bits.EN1 */


/** \brief Length for Ifx_PMS_ACCEN0_Bits.EN2 */


/** \brief Mask for Ifx_PMS_ACCEN0_Bits.EN2 */


/** \brief Offset for Ifx_PMS_ACCEN0_Bits.EN2 */


/** \brief Length for Ifx_PMS_ACCEN0_Bits.EN3 */


/** \brief Mask for Ifx_PMS_ACCEN0_Bits.EN3 */


/** \brief Offset for Ifx_PMS_ACCEN0_Bits.EN3 */


/** \brief Length for Ifx_PMS_ACCEN0_Bits.EN4 */


/** \brief Mask for Ifx_PMS_ACCEN0_Bits.EN4 */


/** \brief Offset for Ifx_PMS_ACCEN0_Bits.EN4 */


/** \brief Length for Ifx_PMS_ACCEN0_Bits.EN5 */


/** \brief Mask for Ifx_PMS_ACCEN0_Bits.EN5 */


/** \brief Offset for Ifx_PMS_ACCEN0_Bits.EN5 */


/** \brief Length for Ifx_PMS_ACCEN0_Bits.EN6 */


/** \brief Mask for Ifx_PMS_ACCEN0_Bits.EN6 */


/** \brief Offset for Ifx_PMS_ACCEN0_Bits.EN6 */


/** \brief Length for Ifx_PMS_ACCEN0_Bits.EN7 */


/** \brief Mask for Ifx_PMS_ACCEN0_Bits.EN7 */


/** \brief Offset for Ifx_PMS_ACCEN0_Bits.EN7 */


/** \brief Length for Ifx_PMS_ACCEN0_Bits.EN8 */


/** \brief Mask for Ifx_PMS_ACCEN0_Bits.EN8 */


/** \brief Offset for Ifx_PMS_ACCEN0_Bits.EN8 */


/** \brief Length for Ifx_PMS_ACCEN0_Bits.EN9 */


/** \brief Mask for Ifx_PMS_ACCEN0_Bits.EN9 */


/** \brief Offset for Ifx_PMS_ACCEN0_Bits.EN9 */


/** \brief Length for Ifx_PMS_ACCEN0_Bits.EN10 */


/** \brief Mask for Ifx_PMS_ACCEN0_Bits.EN10 */


/** \brief Offset for Ifx_PMS_ACCEN0_Bits.EN10 */


/** \brief Length for Ifx_PMS_ACCEN0_Bits.EN11 */


/** \brief Mask for Ifx_PMS_ACCEN0_Bits.EN11 */


/** \brief Offset for Ifx_PMS_ACCEN0_Bits.EN11 */


/** \brief Length for Ifx_PMS_ACCEN0_Bits.EN12 */


/** \brief Mask for Ifx_PMS_ACCEN0_Bits.EN12 */


/** \brief Offset for Ifx_PMS_ACCEN0_Bits.EN12 */


/** \brief Length for Ifx_PMS_ACCEN0_Bits.EN13 */


/** \brief Mask for Ifx_PMS_ACCEN0_Bits.EN13 */


/** \brief Offset for Ifx_PMS_ACCEN0_Bits.EN13 */


/** \brief Length for Ifx_PMS_ACCEN0_Bits.EN14 */


/** \brief Mask for Ifx_PMS_ACCEN0_Bits.EN14 */


/** \brief Offset for Ifx_PMS_ACCEN0_Bits.EN14 */


/** \brief Length for Ifx_PMS_ACCEN0_Bits.EN15 */


/** \brief Mask for Ifx_PMS_ACCEN0_Bits.EN15 */


/** \brief Offset for Ifx_PMS_ACCEN0_Bits.EN15 */


/** \brief Length for Ifx_PMS_ACCEN0_Bits.EN16 */


/** \brief Mask for Ifx_PMS_ACCEN0_Bits.EN16 */


/** \brief Offset for Ifx_PMS_ACCEN0_Bits.EN16 */


/** \brief Length for Ifx_PMS_ACCEN0_Bits.EN17 */


/** \brief Mask for Ifx_PMS_ACCEN0_Bits.EN17 */


/** \brief Offset for Ifx_PMS_ACCEN0_Bits.EN17 */


/** \brief Length for Ifx_PMS_ACCEN0_Bits.EN18 */


/** \brief Mask for Ifx_PMS_ACCEN0_Bits.EN18 */


/** \brief Offset for Ifx_PMS_ACCEN0_Bits.EN18 */


/** \brief Length for Ifx_PMS_ACCEN0_Bits.EN19 */


/** \brief Mask for Ifx_PMS_ACCEN0_Bits.EN19 */


/** \brief Offset for Ifx_PMS_ACCEN0_Bits.EN19 */


/** \brief Length for Ifx_PMS_ACCEN0_Bits.EN20 */


/** \brief Mask for Ifx_PMS_ACCEN0_Bits.EN20 */


/** \brief Offset for Ifx_PMS_ACCEN0_Bits.EN20 */


/** \brief Length for Ifx_PMS_ACCEN0_Bits.EN21 */


/** \brief Mask for Ifx_PMS_ACCEN0_Bits.EN21 */


/** \brief Offset for Ifx_PMS_ACCEN0_Bits.EN21 */


/** \brief Length for Ifx_PMS_ACCEN0_Bits.EN22 */


/** \brief Mask for Ifx_PMS_ACCEN0_Bits.EN22 */


/** \brief Offset for Ifx_PMS_ACCEN0_Bits.EN22 */


/** \brief Length for Ifx_PMS_ACCEN0_Bits.EN23 */


/** \brief Mask for Ifx_PMS_ACCEN0_Bits.EN23 */


/** \brief Offset for Ifx_PMS_ACCEN0_Bits.EN23 */


/** \brief Length for Ifx_PMS_ACCEN0_Bits.EN24 */


/** \brief Mask for Ifx_PMS_ACCEN0_Bits.EN24 */


/** \brief Offset for Ifx_PMS_ACCEN0_Bits.EN24 */


/** \brief Length for Ifx_PMS_ACCEN0_Bits.EN25 */


/** \brief Mask for Ifx_PMS_ACCEN0_Bits.EN25 */


/** \brief Offset for Ifx_PMS_ACCEN0_Bits.EN25 */


/** \brief Length for Ifx_PMS_ACCEN0_Bits.EN26 */


/** \brief Mask for Ifx_PMS_ACCEN0_Bits.EN26 */


/** \brief Offset for Ifx_PMS_ACCEN0_Bits.EN26 */


/** \brief Length for Ifx_PMS_ACCEN0_Bits.EN27 */


/** \brief Mask for Ifx_PMS_ACCEN0_Bits.EN27 */


/** \brief Offset for Ifx_PMS_ACCEN0_Bits.EN27 */


/** \brief Length for Ifx_PMS_ACCEN0_Bits.EN28 */


/** \brief Mask for Ifx_PMS_ACCEN0_Bits.EN28 */


/** \brief Offset for Ifx_PMS_ACCEN0_Bits.EN28 */


/** \brief Length for Ifx_PMS_ACCEN0_Bits.EN29 */


/** \brief Mask for Ifx_PMS_ACCEN0_Bits.EN29 */


/** \brief Offset for Ifx_PMS_ACCEN0_Bits.EN29 */


/** \brief Length for Ifx_PMS_ACCEN0_Bits.EN30 */


/** \brief Mask for Ifx_PMS_ACCEN0_Bits.EN30 */


/** \brief Offset for Ifx_PMS_ACCEN0_Bits.EN30 */


/** \brief Length for Ifx_PMS_ACCEN0_Bits.EN31 */


/** \brief Mask for Ifx_PMS_ACCEN0_Bits.EN31 */


/** \brief Offset for Ifx_PMS_ACCEN0_Bits.EN31 */


/** \}  */

/******************************************************************************/

/******************************************************************************/


#line 70 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Pms\\Std\\IfxPmsEvr.h"

#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\Infra\\Sfr\\TC38A\\_Reg\\IfxPms_reg.h"
/**
 * \file IfxPms_reg.h
 * \brief
 * \copyright Copyright (c) 2020 Infineon Technologies AG. All rights reserved.
 *
 *
 * Version: TC38XA_UM_V1.5.0
 * Specification: TC3xx User Manual V1.5.0
 * MAY BE CHANGED BY USER [yes/no]: No
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * \defgroup IfxSfr_Pms_Registers_Cfg Pms address
 * \ingroup IfxSfr_Pms_Registers
 * 
 * \defgroup IfxSfr_Pms_Registers_Cfg_BaseAddress Base address
 * \ingroup IfxSfr_Pms_Registers_Cfg
 *
 * \defgroup IfxSfr_Pms_Registers_Cfg_Pms 2-PMS
 * \ingroup IfxSfr_Pms_Registers_Cfg
 *
 *
 */


/******************************************************************************/

#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\Infra\\Sfr\\TC38A\\_Reg\\IfxPms_regdef.h"
/**
 * \file IfxPms_regdef.h
 * \brief
 * \copyright Copyright (c) 2020 Infineon Technologies AG. All rights reserved.
 *
 *
 * Version: TC38XA_UM_V1.5.0
 * Specification: TC3xx User Manual V1.5.0
 * MAY BE CHANGED BY USER [yes/no]: No
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * \defgroup IfxSfr_Pms_Registers Pms Registers
 * \ingroup IfxSfr
 * 
 * \defgroup IfxSfr_Pms_Registers_Bitfields Bitfields
 * \ingroup IfxSfr_Pms_Registers
 * 
 * \defgroup IfxSfr_Pms_Registers_union Register unions
 * \ingroup IfxSfr_Pms_Registers
 * 
 * \defgroup IfxSfr_Pms_Registers_struct Memory map
 * \ingroup IfxSfr_Pms_Registers
 */


/******************************************************************************/

/******************************************************************************/

/******************************************************************************/

/******************************************************************************/


/** \addtogroup IfxSfr_Pms_Registers_Bitfields
 * \{  */
/** \brief Access Enable Register 0 */
typedef struct _Ifx_PMS_ACCEN0_Bits
{
    unsigned __sfrbit32 EN0:1;           /**< \brief [0:0] Access Enable for Master TAG ID 0 - EN0 (rw) */
    unsigned __sfrbit32 EN1:1;           /**< \brief [1:1] Access Enable for Master TAG ID 1 - EN1 (rw) */
    unsigned __sfrbit32 EN2:1;           /**< \brief [2:2] Access Enable for Master TAG ID 2 - EN2 (rw) */
    unsigned __sfrbit32 EN3:1;           /**< \brief [3:3] Access Enable for Master TAG ID 3 - EN3 (rw) */
    unsigned __sfrbit32 EN4:1;           /**< \brief [4:4] Access Enable for Master TAG ID 4 - EN4 (rw) */
    unsigned __sfrbit32 EN5:1;           /**< \brief [5:5] Access Enable for Master TAG ID 5 - EN5 (rw) */
    unsigned __sfrbit32 EN6:1;           /**< \brief [6:6] Access Enable for Master TAG ID 6 - EN6 (rw) */
    unsigned __sfrbit32 EN7:1;           /**< \brief [7:7] Access Enable for Master TAG ID 7 - EN7 (rw) */
    unsigned __sfrbit32 EN8:1;           /**< \brief [8:8] Access Enable for Master TAG ID 8 - EN8 (rw) */
    unsigned __sfrbit32 EN9:1;           /**< \brief [9:9] Access Enable for Master TAG ID 9 - EN9 (rw) */
    unsigned __sfrbit32 EN10:1;          /**< \brief [10:10] Access Enable for Master TAG ID 10 - EN10 (rw) */
    unsigned __sfrbit32 EN11:1;          /**< \brief [11:11] Access Enable for Master TAG ID 11 - EN11 (rw) */
    unsigned __sfrbit32 EN12:1;          /**< \brief [12:12] Access Enable for Master TAG ID 12 - EN12 (rw) */
    unsigned __sfrbit32 EN13:1;          /**< \brief [13:13] Access Enable for Master TAG ID 13 - EN13 (rw) */
    unsigned __sfrbit32 EN14:1;          /**< \brief [14:14] Access Enable for Master TAG ID 14 - EN14 (rw) */
    unsigned __sfrbit32 EN15:1;          /**< \brief [15:15] Access Enable for Master TAG ID 15 - EN15 (rw) */
    unsigned __sfrbit32 EN16:1;          /**< \brief [16:16] Access Enable for Master TAG ID 16 - EN16 (rw) */
    unsigned __sfrbit32 EN17:1;          /**< \brief [17:17] Access Enable for Master TAG ID 17 - EN17 (rw) */
    unsigned __sfrbit32 EN18:1;          /**< \brief [18:18] Access Enable for Master TAG ID 18 - EN18 (rw) */
    unsigned __sfrbit32 EN19:1;          /**< \brief [19:19] Access Enable for Master TAG ID 19 - EN19 (rw) */
    unsigned __sfrbit32 EN20:1;          /**< \brief [20:20] Access Enable for Master TAG ID 20 - EN20 (rw) */
    unsigned __sfrbit32 EN21:1;          /**< \brief [21:21] Access Enable for Master TAG ID 21 - EN21 (rw) */
    unsigned __sfrbit32 EN22:1;          /**< \brief [22:22] Access Enable for Master TAG ID 22 - EN22 (rw) */
    unsigned __sfrbit32 EN23:1;          /**< \brief [23:23] Access Enable for Master TAG ID 23 - EN23 (rw) */
    unsigned __sfrbit32 EN24:1;          /**< \brief [24:24] Access Enable for Master TAG ID 24 - EN24 (rw) */
    unsigned __sfrbit32 EN25:1;          /**< \brief [25:25] Access Enable for Master TAG ID 25 - EN25 (rw) */
    unsigned __sfrbit32 EN26:1;          /**< \brief [26:26] Access Enable for Master TAG ID 26 - EN26 (rw) */
    unsigned __sfrbit32 EN27:1;          /**< \brief [27:27] Access Enable for Master TAG ID 27 - EN27 (rw) */
    unsigned __sfrbit32 EN28:1;          /**< \brief [28:28] Access Enable for Master TAG ID 28 - EN28 (rw) */
    unsigned __sfrbit32 EN29:1;          /**< \brief [29:29] Access Enable for Master TAG ID 29 - EN29 (rw) */
    unsigned __sfrbit32 EN30:1;          /**< \brief [30:30] Access Enable for Master TAG ID 30 - EN30 (rw) */
    unsigned __sfrbit32 EN31:1;          /**< \brief [31:31] Access Enable for Master TAG ID 31 - EN31 (rw) */
} Ifx_PMS_ACCEN0_Bits;

/** \brief Access Enable Register 1 */
typedef struct _Ifx_PMS_ACCEN1_Bits
{
    unsigned __sfrbit32 reserved_0:32;    /**< \brief [31:0] \internal Reserved */
} Ifx_PMS_ACCEN1_Bits;

/** \brief SMU_stdby FSP Configuration Register */
typedef struct _Ifx_PMS_AGFSP_STDBY0_Bits
{
    Ifx_UReg_32Bit reserved_0:1;      /**< \brief [0:0] \internal Reserved */
    Ifx_UReg_32Bit reserved_1:1;      /**< \brief [1:1] \internal Reserved */
    Ifx_UReg_32Bit reserved_2:1;      /**< \brief [2:2] \internal Reserved */
    Ifx_UReg_32Bit reserved_3:1;      /**< \brief [3:3] \internal Reserved */
    Ifx_UReg_32Bit FE4:1;             /**< \brief [4:4] Fault signaling configuration flag for alarm 4 belonging to alarm group i. - FE4 (rw) */
    Ifx_UReg_32Bit FE5:1;             /**< \brief [5:5] Fault signaling configuration flag for alarm 5 belonging to alarm group i. - FE5 (rw) */
    Ifx_UReg_32Bit FE6:1;             /**< \brief [6:6] Fault signaling configuration flag for alarm 6 belonging to alarm group i. - FE6 (rw) */
    Ifx_UReg_32Bit FE7:1;             /**< \brief [7:7] Fault signaling configuration flag for alarm 7 belonging to alarm group i. - FE7 (rw) */
    Ifx_UReg_32Bit FE8:1;             /**< \brief [8:8] Fault signaling configuration flag for alarm 8 belonging to alarm group i. - FE8 (rw) */
    Ifx_UReg_32Bit FE9:1;             /**< \brief [9:9] Fault signaling configuration flag for alarm 9 belonging to alarm group i. - FE9 (rw) */
    Ifx_UReg_32Bit FE10:1;            /**< \brief [10:10] Fault signaling configuration flag for alarm 10 belonging to alarm group i. - FE10 (rw) */
    Ifx_UReg_32Bit FE11:1;            /**< \brief [11:11] Fault signaling configuration flag for alarm 11 belonging to alarm group i. - FE11 (rw) */
    Ifx_UReg_32Bit FE12:1;            /**< \brief [12:12] Fault signaling configuration flag for alarm 12 belonging to alarm group i. - FE12 (rw) */
    Ifx_UReg_32Bit FE13:1;            /**< \brief [13:13] Fault signaling configuration flag for alarm 13 belonging to alarm group i. - FE13 (rw) */
    Ifx_UReg_32Bit FE14:1;            /**< \brief [14:14] Fault signaling configuration flag for alarm 14 belonging to alarm group i. - FE14 (rw) */
    Ifx_UReg_32Bit FE15:1;            /**< \brief [15:15] Fault signaling configuration flag for alarm 15 belonging to alarm group i. - FE15 (rw) */
    Ifx_UReg_32Bit reserved_16:1;     /**< \brief [16:16] \internal Reserved */
    Ifx_UReg_32Bit reserved_17:13;    /**< \brief [29:17] \internal Reserved */
    Ifx_UReg_32Bit BITPROT:1;         /**< \brief [30:30] AG2iFSP_STDBY register bits protection (w) */
    Ifx_UReg_32Bit reserved_31:1;     /**< \brief [31:31] \internal Reserved */
} Ifx_PMS_AGFSP_STDBY0_Bits;

/** \brief SMU_stdby FSP Configuration Register */
typedef struct _Ifx_PMS_AGFSP_STDBY1_Bits
{
    Ifx_UReg_32Bit FE0:1;             /**< \brief [0:0] Fault signaling configuration flag for alarm 0 belonging to alarm group i. - FE0 (rw) */
    Ifx_UReg_32Bit FE1:1;             /**< \brief [1:1] Fault signaling configuration flag for alarm 1 belonging to alarm group i. - FE1 (rw) */
    Ifx_UReg_32Bit FE2:1;             /**< \brief [2:2] Fault signaling configuration flag for alarm 2 belonging to alarm group i. - FE2 (rw) */
    Ifx_UReg_32Bit FE3:1;             /**< \brief [3:3] Fault signaling configuration flag for alarm 3 belonging to alarm group i. - FE3 (rw) */
    Ifx_UReg_32Bit FE4:1;             /**< \brief [4:4] Fault signaling configuration flag for alarm 4 belonging to alarm group i. - FE4 (rw) */
    Ifx_UReg_32Bit FE5:1;             /**< \brief [5:5] Fault signaling configuration flag for alarm 5 belonging to alarm group i. - FE5 (rw) */
    Ifx_UReg_32Bit reserved_6:1;      /**< \brief [6:6] \internal Reserved */
    Ifx_UReg_32Bit FE7:1;             /**< \brief [7:7] Fault signaling configuration flag for alarm 7 belonging to alarm group i. - FE7 (rw) */
    Ifx_UReg_32Bit FE8:1;             /**< \brief [8:8] Fault signaling configuration flag for alarm 8 belonging to alarm group i. - FE8 (rw) */
    Ifx_UReg_32Bit FE9:1;             /**< \brief [9:9] Fault signaling configuration flag for alarm 9 belonging to alarm group i. - FE9 (rw) */
    Ifx_UReg_32Bit FE10:1;            /**< \brief [10:10] Fault signaling configuration flag for alarm 10 belonging to alarm group i. - FE10 (rw) */
    Ifx_UReg_32Bit FE11:1;            /**< \brief [11:11] Fault signaling configuration flag for alarm 11 belonging to alarm group i. - FE11 (rw) */
    Ifx_UReg_32Bit FE12:1;            /**< \brief [12:12] Fault signaling configuration flag for alarm 12 belonging to alarm group i. - FE12 (rw) */
    Ifx_UReg_32Bit FE13:1;            /**< \brief [13:13] Fault signaling configuration flag for alarm 13 belonging to alarm group i. - FE13 (rw) */
    Ifx_UReg_32Bit FE14:1;            /**< \brief [14:14] Fault signaling configuration flag for alarm 14 belonging to alarm group i. - FE14 (rw) */
    Ifx_UReg_32Bit FE15:1;            /**< \brief [15:15] Fault signaling configuration flag for alarm 15 belonging to alarm group i. - FE15 (rw) */
    Ifx_UReg_32Bit FE16:1;            /**< \brief [16:16] Fault signaling configuration flag for alarm 16 belonging to alarm group i. - FE16 (rw) */
    Ifx_UReg_32Bit reserved_17:13;    /**< \brief [29:17] \internal Reserved */
    Ifx_UReg_32Bit BITPROT:1;         /**< \brief [30:30] AG2iFSP_STDBY register bits protection (w) */
    Ifx_UReg_32Bit reserved_31:1;     /**< \brief [31:31] \internal Reserved */
} Ifx_PMS_AGFSP_STDBY1_Bits;

/** \brief Alarm Status Register */
typedef struct _Ifx_PMS_AG_STDBY0_Bits
{
    Ifx_UReg_32Bit reserved_0:1;      /**< \brief [0:0] \internal Reserved */
    Ifx_UReg_32Bit reserved_1:1;      /**< \brief [1:1] \internal Reserved */
    Ifx_UReg_32Bit reserved_2:1;      /**< \brief [2:2] \internal Reserved */
    Ifx_UReg_32Bit reserved_3:1;      /**< \brief [3:3] \internal Reserved */
    Ifx_UReg_32Bit SF4:1;             /**< \brief [4:4] Status flag for alarm 4 belonging to alarm group i. - SF4 (rwh) */
    Ifx_UReg_32Bit SF5:1;             /**< \brief [5:5] Status flag for alarm 5 belonging to alarm group i. - SF5 (rwh) */
    Ifx_UReg_32Bit SF6:1;             /**< \brief [6:6] Status flag for alarm 6 belonging to alarm group i. - SF6 (rwh) */
    Ifx_UReg_32Bit SF7:1;             /**< \brief [7:7] Status flag for alarm 7 belonging to alarm group i. - SF7 (rwh) */
    Ifx_UReg_32Bit SF8:1;             /**< \brief [8:8] Status flag for alarm 8 belonging to alarm group i. - SF8 (rwh) */
    Ifx_UReg_32Bit SF9:1;             /**< \brief [9:9] Status flag for alarm 9 belonging to alarm group i. - SF9 (rwh) */
    Ifx_UReg_32Bit SF10:1;            /**< \brief [10:10] Status flag for alarm 10 belonging to alarm group i. - SF10 (rwh) */
    Ifx_UReg_32Bit SF11:1;            /**< \brief [11:11] Status flag for alarm 11 belonging to alarm group i. - SF11 (rwh) */
    Ifx_UReg_32Bit SF12:1;            /**< \brief [12:12] Status flag for alarm 12 belonging to alarm group i. - SF12 (rwh) */
    Ifx_UReg_32Bit SF13:1;            /**< \brief [13:13] Status flag for alarm 13 belonging to alarm group i. - SF13 (rwh) */
    Ifx_UReg_32Bit SF14:1;            /**< \brief [14:14] Status flag for alarm 14 belonging to alarm group i. - SF14 (rwh) */
    Ifx_UReg_32Bit SF15:1;            /**< \brief [15:15] Status flag for alarm 15 belonging to alarm group i. - SF15 (rwh) */
    Ifx_UReg_32Bit reserved_16:1;     /**< \brief [16:16] \internal Reserved */
    Ifx_UReg_32Bit reserved_17:13;    /**< \brief [29:17] \internal Reserved */
    Ifx_UReg_32Bit FSPERR:1;          /**< \brief [30:30] Error Pin Fault State Status Bit - FSPERR (rwh) */
    Ifx_UReg_32Bit reserved_31:1;     /**< \brief [31:31] \internal Reserved */
} Ifx_PMS_AG_STDBY0_Bits;

/** \brief Alarm Status Register */
typedef struct _Ifx_PMS_AG_STDBY1_Bits
{
    Ifx_UReg_32Bit SF0:1;             /**< \brief [0:0] Status flag for alarm 0 belonging to alarm group i. - SF0 (rwh) */
    Ifx_UReg_32Bit SF1:1;             /**< \brief [1:1] Status flag for alarm 1 belonging to alarm group i. - SF1 (rwh) */
    Ifx_UReg_32Bit SF2:1;             /**< \brief [2:2] Status flag for alarm 2 belonging to alarm group i. - SF2 (rwh) */
    Ifx_UReg_32Bit SF3:1;             /**< \brief [3:3] Status flag for alarm 3 belonging to alarm group i. - SF3 (rwh) */
    Ifx_UReg_32Bit SF4:1;             /**< \brief [4:4] Status flag for alarm 4 belonging to alarm group i. - SF4 (rwh) */
    Ifx_UReg_32Bit SF5:1;             /**< \brief [5:5] Status flag for alarm 5 belonging to alarm group i. - SF5 (rwh) */
    Ifx_UReg_32Bit reserved_6:1;      /**< \brief [6:6] \internal Reserved */
    Ifx_UReg_32Bit SF7:1;             /**< \brief [7:7] Status flag for alarm 7 belonging to alarm group i. - SF7 (rwh) */
    Ifx_UReg_32Bit SF8:1;             /**< \brief [8:8] Status flag for alarm 8 belonging to alarm group i. - SF8 (rwh) */
    Ifx_UReg_32Bit SF9:1;             /**< \brief [9:9] Status flag for alarm 9 belonging to alarm group i. - SF9 (rwh) */
    Ifx_UReg_32Bit SF10:1;            /**< \brief [10:10] Status flag for alarm 10 belonging to alarm group i. - SF10 (rwh) */
    Ifx_UReg_32Bit SF11:1;            /**< \brief [11:11] Status flag for alarm 11 belonging to alarm group i. - SF11 (rwh) */
    Ifx_UReg_32Bit SF12:1;            /**< \brief [12:12] Status flag for alarm 12 belonging to alarm group i. - SF12 (rwh) */
    Ifx_UReg_32Bit SF13:1;            /**< \brief [13:13] Status flag for alarm 13 belonging to alarm group i. - SF13 (rwh) */
    Ifx_UReg_32Bit SF14:1;            /**< \brief [14:14] Status flag for alarm 14 belonging to alarm group i. - SF14 (rwh) */
    Ifx_UReg_32Bit SF15:1;            /**< \brief [15:15] Status flag for alarm 15 belonging to alarm group i. - SF15 (rwh) */
    Ifx_UReg_32Bit SF16:1;            /**< \brief [16:16] Status flag for alarm 16 belonging to alarm group i. - SF16 (rwh) */
    Ifx_UReg_32Bit reserved_17:13;    /**< \brief [29:17] \internal Reserved */
    Ifx_UReg_32Bit reserved_30:1;     /**< \brief [30:30] \internal Reserved */
    Ifx_UReg_32Bit reserved_31:1;     /**< \brief [31:31] \internal Reserved */
} Ifx_PMS_AG_STDBY1_Bits;

/** \brief SMU_stdby Command Register */
typedef struct _Ifx_PMS_CMD_STDBY_Bits
{
    Ifx_UReg_32Bit SMUEN:1;           /**< \brief [0:0] SMU_stdby Module Enable - SMUEN (rw) */
    Ifx_UReg_32Bit FSP0EN:1;          /**< \brief [1:1] SMU_stdby FSP0 Error pin enable - FSP0EN (rw) */
    Ifx_UReg_32Bit FSP1EN:1;          /**< \brief [2:2] SMU_stdby FSP1 Error pin enable - FSP1EN (rw) */
    Ifx_UReg_32Bit ASCE:1;            /**< \brief [3:3] SMU_stdby alarm status clear enable - ASCE (rwh) */
    Ifx_UReg_32Bit reserved_4:26;     /**< \brief [29:4] \internal Reserved */
    Ifx_UReg_32Bit BITPROT:1;         /**< \brief [30:30] CMD_STDBY register bits protection (w) */
    Ifx_UReg_32Bit reserved_31:1;     /**< \brief [31:31] \internal Reserved */
} Ifx_PMS_CMD_STDBY_Bits;

/** \brief Die Temperature Sensor Limit Register */
typedef struct _Ifx_PMS_DTSLIM_Bits
{
    Ifx_UReg_32Bit LOWER:12;          /**< \brief [11:0] Lower Limit - LOWER (rw) */
    Ifx_UReg_32Bit reserved_12:3;     /**< \brief [14:12] \internal Reserved */
    Ifx_UReg_32Bit LLU:1;             /**< \brief [15:15] Lower Limit Underflow - LLU (rwh) */
    Ifx_UReg_32Bit UPPER:12;          /**< \brief [27:16] Upper Limit - UPPER (rw) */
    Ifx_UReg_32Bit reserved_28:2;     /**< \brief [29:28] \internal Reserved */
    Ifx_UReg_32Bit SLCK:1;            /**< \brief [30:30] HSM Security Lock - SLCK (rw) */
    Ifx_UReg_32Bit UOF:1;             /**< \brief [31:31] Upper Limit Overflow - UOF (rwh) */
} Ifx_PMS_DTSLIM_Bits;

/** \brief Die Temperature Sensor Status Register */
typedef struct _Ifx_PMS_DTSSTAT_Bits
{
    Ifx_UReg_32Bit RESULT:12;         /**< \brief [11:0] Result of the DTS Measurement - RESULT (rh) */
    Ifx_UReg_32Bit reserved_12:20;    /**< \brief [31:12] \internal Reserved */
} Ifx_PMS_DTSSTAT_Bits;

/** \brief EVR33 Control Register */
typedef struct _Ifx_PMS_EVR33CON_Bits
{
    Ifx_UReg_32Bit SHVH33:8;          /**< \brief [7:0] Short to Supply Voltage Threshold(x_i) - SHVH33 (rw) */
    Ifx_UReg_32Bit reserved_8:4;      /**< \brief [11:8] \internal Reserved */
    Ifx_UReg_32Bit SHHVEN:1;          /**< \brief [12:12] Short to High Detection Enable - SHHVEN (rw) */
    Ifx_UReg_32Bit SHLVEN:1;          /**< \brief [13:13] Short to Low Detection Enable - SHLVEN (rw) */
    Ifx_UReg_32Bit reserved_14:2;     /**< \brief [15:14] \internal Reserved */
    Ifx_UReg_32Bit SHVL33:8;          /**< \brief [23:16] Short to Ground Voltage Threshold(x_i) - SHVL33 (rw) */
    Ifx_UReg_32Bit reserved_24:4;     /**< \brief [27:24] \internal Reserved */
    Ifx_UReg_32Bit reserved_28:1;     /**< \brief [28:28] \internal Reserved */
    Ifx_UReg_32Bit reserved_29:1;     /**< \brief [29:29] \internal Reserved */
    Ifx_UReg_32Bit SLCK:1;            /**< \brief [30:30] HSM Security Lock - SLCK (rw) */
    Ifx_UReg_32Bit reserved_31:1;     /**< \brief [31:31] \internal Reserved */
} Ifx_PMS_EVR33CON_Bits;

/** \brief EVR Primary ADC Status Register */
typedef struct _Ifx_PMS_EVRADCSTAT_Bits
{
    Ifx_UReg_32Bit ADCCV:8;           /**< \brief [7:0] ADC VDD Core Voltage Conversion Result - ADCCV (rh) */
    Ifx_UReg_32Bit ADC33V:8;          /**< \brief [15:8] ADC VDDP3 Voltage Conversion Result - ADC33V (rh) */
    Ifx_UReg_32Bit ADCSWDV:8;         /**< \brief [23:16] ADC VEXT Supply Conversion Result - ADCSWDV (rh) */
    Ifx_UReg_32Bit OVC:1;             /**< \brief [24:24] EVRC Regulator or VDD Over-voltage event flag - OVC (rh) */
    Ifx_UReg_32Bit OV33:1;            /**< \brief [25:25] EVR33 Regulator or VDDP3 Over-voltage event flag - OV33 (rh) */
    Ifx_UReg_32Bit OVSWD:1;           /**< \brief [26:26] Supply Watchdog (SWD) or VEXT Over-voltage event flag - OVSWD (rh) */
    Ifx_UReg_32Bit UVC:1;             /**< \brief [27:27] EVRC Regulator or VDD Under-voltage event flag - UVC (rh) */
    Ifx_UReg_32Bit UV33:1;            /**< \brief [28:28] EVR33 Regulator or VDDP3 Under-voltage event flag - UV33 (rh) */
    Ifx_UReg_32Bit UVSWD:1;           /**< \brief [29:29] Supply Watchdog (SWD) or VEXT Under-voltage event flag - UVSWD (rh) */
    Ifx_UReg_32Bit reserved_30:2;     /**< \brief [31:30] \internal Reserved */
} Ifx_PMS_EVRADCSTAT_Bits;

/** \brief EVR Oscillator Control Register */
typedef struct _Ifx_PMS_EVROSCCTRL_Bits
{
    Ifx_UReg_32Bit OSCFTRIM:6;        /**< \brief [5:0] Back-up Clock Fine Trim Value - OSCFTRIM (rw) */
    Ifx_UReg_32Bit reserved_6:10;     /**< \brief [15:6] \internal Reserved */
    Ifx_UReg_32Bit OSCFPTRIM:6;       /**< \brief [21:16] OSC Fine Trim Signed Value - OSCFPTRIM (rw) */
    Ifx_UReg_32Bit reserved_22:7;     /**< \brief [28:22] \internal Reserved */
    Ifx_UReg_32Bit OSCTEMPOFFS:1;     /**< \brief [29:29] Oscillator Temperature Offset Coefficient - OSCTEMPOFFS (rw) */
    Ifx_UReg_32Bit reserved_30:1;     /**< \brief [30:30] \internal Reserved */
    Ifx_UReg_32Bit OSCTRIMEN:1;       /**< \brief [31:31] Dynamic Oscillator Trim Enable - OSCTRIMEN (rw) */
} Ifx_PMS_EVROSCCTRL_Bits;

/** \brief EVR Reset Control Register */
typedef struct _Ifx_PMS_EVRRSTCON_Bits
{
    Ifx_UReg_32Bit RSTCTRIM:8;        /**< \brief [7:0] VDD Supply Reset Trim Value - RSTCTRIM (rw) */
    Ifx_UReg_32Bit RST33TRIM:8;       /**< \brief [15:8] VDDP3 Supply Reset Trim Value - RST33TRIM (rw) */
    Ifx_UReg_32Bit RSTSWDTRIM:8;      /**< \brief [23:16] VEXT Supply Reset Trim Value - RSTSWDTRIM (rw) */
    Ifx_UReg_32Bit RSTCOFF:1;         /**< \brief [24:24] VDD Reset Enable - RSTCOFF (rw) */
    Ifx_UReg_32Bit BPRSTCOFF:1;       /**< \brief [25:25] Bit Protection RSTCOFF - BPRSTCOFF (w) */
    Ifx_UReg_32Bit RST33OFF:1;        /**< \brief [26:26] VDDP3 Reset Enable - RST33OFF (rw) */
    Ifx_UReg_32Bit BPRST33OFF:1;      /**< \brief [27:27] Bit Protection RST33OFF - BPRST33OFF (w) */
    Ifx_UReg_32Bit RSTSWDOFF:1;       /**< \brief [28:28] VEXT Reset Enable - RSTSWDOFF (rw) */
    Ifx_UReg_32Bit BPRSTSWDOFF:1;     /**< \brief [29:29] Bit Protection RSTSWDOFF - BPRSTSWDOFF (w) */
    Ifx_UReg_32Bit SLCK:1;            /**< \brief [30:30] HSM Security Lock - SLCK (rw) */
    Ifx_UReg_32Bit reserved_31:1;     /**< \brief [31:31] \internal Reserved */
} Ifx_PMS_EVRRSTCON_Bits;

/** \brief EVR Reset Status Register */
typedef struct _Ifx_PMS_EVRRSTSTAT_Bits
{
    Ifx_UReg_32Bit RSTC:8;            /**< \brief [7:0] VDD Supply Reset Value Status - RSTC (rh) */
    Ifx_UReg_32Bit RST33:8;           /**< \brief [15:8] VDDP3 Supply Reset Value Status - RST33 (rh) */
    Ifx_UReg_32Bit RSTSWD:8;          /**< \brief [23:16] VEXT Supply Reset Value Status - RSTSWD (rh) */
    Ifx_UReg_32Bit RSTCOFF:1;         /**< \brief [24:24] EVRC Reset Enable Status - RSTCOFF (rh) */
    Ifx_UReg_32Bit reserved_25:1;     /**< \brief [25:25] \internal Reserved */
    Ifx_UReg_32Bit RST33OFF:1;        /**< \brief [26:26] EVR33 Reset Enable Status - RST33OFF (rh) */
    Ifx_UReg_32Bit reserved_27:1;     /**< \brief [27:27] \internal Reserved */
    Ifx_UReg_32Bit RSTSWDOFF:1;       /**< \brief [28:28] EVR SWD Reset Enable - RSTSWDOFF (rh) */
    Ifx_UReg_32Bit reserved_29:3;     /**< \brief [31:29] \internal Reserved */
} Ifx_PMS_EVRRSTSTAT_Bits;

/** \brief EVRC SD Coefficient Register 0 */
typedef struct _Ifx_PMS_EVRSDCOEFF0_Bits
{
    Ifx_UReg_32Bit M0S0EN:1;          /**< \brief [0:0] S0 Enable(m0en_s0en_i) - M0S0EN (rw) */
    Ifx_UReg_32Bit M0S2EN:1;          /**< \brief [1:1] S2 Enable(m0en_s2en_i) - M0S2EN (rw) */
    Ifx_UReg_32Bit M0S3EN:1;          /**< \brief [2:2] S3 Enable(m0en_s3en_i) - M0S3EN (rw) */
    Ifx_UReg_32Bit M0S3CLIP:1;        /**< \brief [3:3] S3 Clip(m0en_s3clip_i) - M0S3CLIP (rw) */
    Ifx_UReg_32Bit M0S4EN:1;          /**< \brief [4:4] S4 Enable(m0en_s4en_i) - M0S4EN (rw) */
    Ifx_UReg_32Bit M0RAMPEN:1;        /**< \brief [5:5] Ramp Enable(m0en_rampen_i) - M0RAMPEN (rw) */
    Ifx_UReg_32Bit M0SFRGET:1;        /**< \brief [6:6] SFRGET(m0en_sfrget_i) - M0SFRGET (rw) */
    Ifx_UReg_32Bit M0SKIPEN:1;        /**< \brief [7:7] Skip Enable(m0en_skipen_i) - M0SKIPEN (rw) */
    Ifx_UReg_32Bit M0S3COEFF:4;       /**< \brief [11:8] S3 Coefficient(m0s3_coeff_i) - M0S3COEFF (rw) */
    Ifx_UReg_32Bit M0S4COEFF:4;       /**< \brief [15:12] S4 Coefficient(m0s4_coeff_i) - M0S4COEFF (rw) */
    Ifx_UReg_32Bit M0SRMPCOEFF:4;     /**< \brief [19:16] S Ramp Coefficient(m0srmp_coeff_i) - M0SRMPCOEFF (rw) */
    Ifx_UReg_32Bit M0FGETCOEFF:4;     /**< \brief [23:20] S2 Forgetting Factor(m0fget_coeff_i) - M0FGETCOEFF (rw) */
    Ifx_UReg_32Bit M0S2COEFF:4;       /**< \brief [27:24] S2 Coefficient(m0s2_coeff_i) - M0S2COEFF (rw) */
    Ifx_UReg_32Bit M0S2VINSRC:1;      /**< \brief [28:28] S2 Vin Source(m0s2_vinsrc_i) - M0S2VINSRC (rw) */
    Ifx_UReg_32Bit M0S2VOSRC:1;       /**< \brief [29:29] S2 Vout Source(m0s2_vosrc_i) - M0S2VOSRC (rw) */
    Ifx_UReg_32Bit M0SRMPCOEFFFRAC:1;    /**< \brief [30:30] S Ramp Fractional Coefficient (rw) */
    Ifx_UReg_32Bit LCK:1;             /**< \brief [31:31] Lock Status - LCK (rh) */
} Ifx_PMS_EVRSDCOEFF0_Bits;

/** \brief EVRC SD Coefficient Register 1 */
typedef struct _Ifx_PMS_EVRSDCOEFF1_Bits
{
    Ifx_UReg_32Bit M0VOCFLPF:4;       /**< \brief [3:0] LPF Coefficient(m0vocf_lpf_i) - M0VOCFLPF (rw) */
    Ifx_UReg_32Bit M0VOCFINC:4;       /**< \brief [7:4] Output Voltage Ramp Coefficient(m0vocf_inc_i) - M0VOCFINC (rw) */
    Ifx_UReg_32Bit M0VOUT:8;          /**< \brief [15:8] Digital representation of the target voltage(m0vo_lb_i) - M0VOUT (rw) */
    Ifx_UReg_32Bit M0VIN:11;          /**< \brief [26:16] Digital representation of the input voltage(m0vinh_vin_i+m0vinl_vin_i)) - M0VIN (rw) */
    Ifx_UReg_32Bit M0S3COEFFFRAC:2;    /**< \brief [28:27] S3 Fractional Coefficient (rw) */
    Ifx_UReg_32Bit M0S2COEFFFRAC:2;    /**< \brief [30:29] S2 Fractional Coefficient (rw) */
    Ifx_UReg_32Bit LCK:1;             /**< \brief [31:31] Lock Status - LCK (rh) */
} Ifx_PMS_EVRSDCOEFF1_Bits;

/** \brief EVRC SD Coefficient Register 2 */
typedef struct _Ifx_PMS_EVRSDCOEFF2_Bits
{
    Ifx_UReg_32Bit M1S0EN:1;          /**< \brief [0:0] S0 Enable(m1en_s0en_i) - M1S0EN (rw) */
    Ifx_UReg_32Bit M1S2EN:1;          /**< \brief [1:1] S2 Enable(m1en_s2en_i) - M1S2EN (rw) */
    Ifx_UReg_32Bit M1S3EN:1;          /**< \brief [2:2] S3 Enable(m1en_s3en_i) - M1S3EN (rw) */
    Ifx_UReg_32Bit M1S3CLIP:1;        /**< \brief [3:3] S3 Clip(m1en_s3clip_i) - M1S3CLIP (rw) */
    Ifx_UReg_32Bit M1S4EN:1;          /**< \brief [4:4] S4 Enable(m1en_s4en_i) - M1S4EN (rw) */
    Ifx_UReg_32Bit M1RAMPEN:1;        /**< \brief [5:5] Ramp Enable(m1en_rampen_i) - M1RAMPEN (rw) */
    Ifx_UReg_32Bit M1SFRGET:1;        /**< \brief [6:6] SFRGET(m1en_sfrget_i) - M1SFRGET (rw) */
    Ifx_UReg_32Bit M1SKIPEN:1;        /**< \brief [7:7] Skip Enable(m1en_skipen_i) - M1SKIPEN (rw) */
    Ifx_UReg_32Bit M1S3COEFF:4;       /**< \brief [11:8] S3 Coefficient(m1s3_coeff_i) - M1S3COEFF (rw) */
    Ifx_UReg_32Bit M1S4COEFF:4;       /**< \brief [15:12] S4 Coefficient(m1s4_coeff_i) - M1S4COEFF (rw) */
    Ifx_UReg_32Bit M1SRMPCOEFF:4;     /**< \brief [19:16] S Ramp Coefficient(m1srmp_coeff_i) - M1SRMPCOEFF (rw) */
    Ifx_UReg_32Bit M1FGETCOEFF:4;     /**< \brief [23:20] S2 Forgetting Factor(m1fget_coeff_i) - M1FGETCOEFF (rw) */
    Ifx_UReg_32Bit M1S2COEFF:4;       /**< \brief [27:24] S2 Coefficient(m1s2_coeff_i) - M1S2COEFF (rw) */
    Ifx_UReg_32Bit M1S2VINSRC:1;      /**< \brief [28:28] S2 Vin Source(m1s2_vinsrc_i) - M1S2VINSRC (rw) */
    Ifx_UReg_32Bit M1S2VOSRC:1;       /**< \brief [29:29] S2 Vout Source(m1s2_vosrc_i) - M1S2VOSRC (rw) */
    Ifx_UReg_32Bit reserved_30:2;     /**< \brief [31:30] \internal Reserved */
} Ifx_PMS_EVRSDCOEFF2_Bits;

/** \brief EVRC SD Coefficient Register 3 */
typedef struct _Ifx_PMS_EVRSDCOEFF3_Bits
{
    Ifx_UReg_32Bit M1VOCFLPF:4;       /**< \brief [3:0] LPF Coefficient(m1vocf_lpf_i) - M1VOCFLPF (rw) */
    Ifx_UReg_32Bit M1VOCFINC:4;       /**< \brief [7:4] Output Voltage Ramp Coefficient(m1vocf_inc_i) - M1VOCFINC (rw) */
    Ifx_UReg_32Bit M1VOUT:8;          /**< \brief [15:8] Digital representation of the target voltage(m1vo_lb_i) - M1VOUT (rw) */
    Ifx_UReg_32Bit M1VIN:11;          /**< \brief [26:16] Digital representation of the input voltage(m1vinh_vin_i+m1vinl_vin_i) - M1VIN (rw) */
    Ifx_UReg_32Bit M1S3COEFFFRAC:2;    /**< \brief [28:27] S3 Fractional Coefficient (rw) */
    Ifx_UReg_32Bit M1S2COEFFFRAC:2;    /**< \brief [30:29] S2 Fractional Coefficient (rw) */
    Ifx_UReg_32Bit M1SRMPCOEFFFRAC:1;    /**< \brief [31:31] S Ramp Fractional Coefficient (rw) */
} Ifx_PMS_EVRSDCOEFF3_Bits;

/** \brief EVRC SD Coefficient Register 4 */
typedef struct _Ifx_PMS_EVRSDCOEFF4_Bits
{
    Ifx_UReg_32Bit M2S0EN:1;          /**< \brief [0:0] S0 Enable(m2en_s0en_i) - M2S0EN (rw) */
    Ifx_UReg_32Bit M2S2EN:1;          /**< \brief [1:1] S2 Enable(m2en_s2en_i) - M2S2EN (rw) */
    Ifx_UReg_32Bit M2S3EN:1;          /**< \brief [2:2] S3 Enable(m2en_s3en_i) - M2S3EN (rw) */
    Ifx_UReg_32Bit M2S3CLIP:1;        /**< \brief [3:3] S3 Clip(m2en_s3clip_i) - M2S3CLIP (rw) */
    Ifx_UReg_32Bit M2S4EN:1;          /**< \brief [4:4] S4 Enable(m2en_s4en_i) - M2S4EN (rw) */
    Ifx_UReg_32Bit M2RAMPEN:1;        /**< \brief [5:5] Ramp Enable(m2en_rampen_i) - M2RAMPEN (rw) */
    Ifx_UReg_32Bit M2SFRGET:1;        /**< \brief [6:6] SFRGET(m2en_sfrget_i) - M2SFRGET (rw) */
    Ifx_UReg_32Bit M2SKIPEN:1;        /**< \brief [7:7] Skip Enable(m2en_skipen_i) - M2SKIPEN (rw) */
    Ifx_UReg_32Bit M2S3COEFF:4;       /**< \brief [11:8] S3 Coefficient(m2s3_coeff_i) - M2S3COEFF (rw) */
    Ifx_UReg_32Bit M2S4COEFF:4;       /**< \brief [15:12] S4 Coefficient(m2s4_coeff_i) - M2S4COEFF (rw) */
    Ifx_UReg_32Bit M2SRMPCOEFF:4;     /**< \brief [19:16] S Ramp Coefficient(m2srmp_coeff_i) - M2SRMPCOEFF (rw) */
    Ifx_UReg_32Bit M2FGETCOEFF:4;     /**< \brief [23:20] S2 Forgetting Factor(m2fget_coeff_i) - M2FGETCOEFF (rw) */
    Ifx_UReg_32Bit M2S2COEFF:4;       /**< \brief [27:24] S2 Coefficient(m2s2_coeff_i) - M2S2COEFF (rw) */
    Ifx_UReg_32Bit M2S2VINSRC:1;      /**< \brief [28:28] S2 Vin Source(m2s2_vinsrc_i) - M2S2VINSRC (rw) */
    Ifx_UReg_32Bit M2S2VOSRC:1;       /**< \brief [29:29] S2 Vout Source(m2s2_vosrc_i) - M2S2VOSRC (rw) */
    Ifx_UReg_32Bit reserved_30:2;     /**< \brief [31:30] \internal Reserved */
} Ifx_PMS_EVRSDCOEFF4_Bits;

/** \brief EVRC SD Coefficient Register 5 */
typedef struct _Ifx_PMS_EVRSDCOEFF5_Bits
{
    Ifx_UReg_32Bit M2VOCFLPF:4;       /**< \brief [3:0] LPF Coefficient(m2vocf_lpf_i) - M2VOCFLPF (rw) */
    Ifx_UReg_32Bit M2VOCFINC:4;       /**< \brief [7:4] Output Voltage Ramp Coefficient(m2vocf_inc_i) - M2VOCFINC (rw) */
    Ifx_UReg_32Bit M2VOUT:8;          /**< \brief [15:8] Digital representation of the target voltage(m2vo_lb_i) - M2VOUT (rw) */
    Ifx_UReg_32Bit M2VIN:11;          /**< \brief [26:16] Digital representation of the input voltage(m2vinh_vin_i+m2vinl_vin_i) - M2VIN (rw) */
    Ifx_UReg_32Bit M2S3COEFFFRAC:2;    /**< \brief [28:27] S3 Fractional Coefficient (rw) */
    Ifx_UReg_32Bit M2S2COEFFFRAC:2;    /**< \brief [30:29] S2 Fractional Coefficient (rw) */
    Ifx_UReg_32Bit M2SRMPCOEFFFRAC:1;    /**< \brief [31:31] S Ramp Fractional Coefficient (rw) */
} Ifx_PMS_EVRSDCOEFF5_Bits;

/** \brief EVRC SD Coefficient Register 6 */
typedef struct _Ifx_PMS_EVRSDCOEFF6_Bits
{
    Ifx_UReg_32Bit CT5REG0:8;         /**< \brief [7:0] Commutation trimming and Slope Control(drv5v0_trim_i) - CT5REG0 (rw) */
    Ifx_UReg_32Bit CT5REG1:8;         /**< \brief [15:8] Commutation trimming(drv5v1_trim_i) - CT5REG1 (rw) */
    Ifx_UReg_32Bit CT5REG2:8;         /**< \brief [23:16] Commutation trimming(drv5v2_trim_i) - CT5REG2 (rw) */
    Ifx_UReg_32Bit reserved_24:7;     /**< \brief [30:24] \internal Reserved */
    Ifx_UReg_32Bit LCK:1;             /**< \brief [31:31] Lock Status - LCK (rh) */
} Ifx_PMS_EVRSDCOEFF6_Bits;

/** \brief EVRC SD Coefficient Register 7 */
typedef struct _Ifx_PMS_EVRSDCOEFF7_Bits
{
    Ifx_UReg_32Bit CT5REG3:8;         /**< \brief [7:0] Commutation trimming(drv5v3_trim_i) - CT5REG3 (rw) */
    Ifx_UReg_32Bit CT5REG4:8;         /**< \brief [15:8] Commutation trimming(drv5v4_trim_i) - CT5REG4 (rw) */
    Ifx_UReg_32Bit reserved_16:15;    /**< \brief [30:16] \internal Reserved */
    Ifx_UReg_32Bit LCK:1;             /**< \brief [31:31] Lock Status - LCK (rh) */
} Ifx_PMS_EVRSDCOEFF7_Bits;

/** \brief EVRC SD Coefficient Register 8 */
typedef struct _Ifx_PMS_EVRSDCOEFF8_Bits
{
    Ifx_UReg_32Bit CT33REG0:8;        /**< \brief [7:0] Commutation trimming(drv3v0_trim_i) - CT33REG0 (rw) */
    Ifx_UReg_32Bit CT33REG1:8;        /**< \brief [15:8] Commutation trimming(drv3v1_trim_i) - CT33REG1 (rw) */
    Ifx_UReg_32Bit CT33REG2:8;        /**< \brief [23:16] Commutation trimming(drv3v2_trim_i) - CT33REG2 (rw) */
    Ifx_UReg_32Bit reserved_24:7;     /**< \brief [30:24] \internal Reserved */
    Ifx_UReg_32Bit LCK:1;             /**< \brief [31:31] Lock Status - LCK (rh) */
} Ifx_PMS_EVRSDCOEFF8_Bits;

/** \brief EVRC SD Coefficient Register 9 */
typedef struct _Ifx_PMS_EVRSDCOEFF9_Bits
{
    Ifx_UReg_32Bit CT33REG3:8;        /**< \brief [7:0] Commutation trimming(drv3v3_trim_i) - CT33REG3 (rw) */
    Ifx_UReg_32Bit CT33REG4:8;        /**< \brief [15:8] Commutation trimming(drv3v4_trim_i) - CT33REG4 (rw) */
    Ifx_UReg_32Bit reserved_16:15;    /**< \brief [30:16] \internal Reserved */
    Ifx_UReg_32Bit LCK:1;             /**< \brief [31:31] Lock Status - LCK (rh) */
} Ifx_PMS_EVRSDCOEFF9_Bits;

/** \brief EVRC SD Control Register 0 */
typedef struct _Ifx_PMS_EVRSDCTRL0_Bits
{
    Ifx_UReg_32Bit SDFREQSPRD:16;     /**< \brief [15:0] Frequency Spread Threshold(freqsp_coeff_i) - SDFREQSPRD (rw) */
    Ifx_UReg_32Bit SDFREQ:12;         /**< \brief [27:16] Regulator Switching Frequency or Over-sampling Factor(m0osfl_fact_i+m0osfh_fact_i) - SDFREQ (rw) */
    Ifx_UReg_32Bit NGOFF:1;           /**< \brief [28:28] NMOS level during OFF state(drvslo_ngoff_i) - NGOFF (rw) */
    Ifx_UReg_32Bit PGOFF:1;           /**< \brief [29:29] PMOS level during OFF state(drvslo_pgoff_i) - PGOFF (rw) */
    Ifx_UReg_32Bit UP:1;              /**< \brief [30:30] Update request for SMPS register values - UP (rwh) */
    Ifx_UReg_32Bit LCK:1;             /**< \brief [31:31] Lock Status - LCK (rh) */
} Ifx_PMS_EVRSDCTRL0_Bits;

/** \brief EVRC SD Control Register 1 */
typedef struct _Ifx_PMS_EVRSDCTRL1_Bits
{
    Ifx_UReg_32Bit M0TOFF:8;          /**< \brief [7:0] Minimum Off Time(m0toff_mintof_i) - M0TOFF (rw) */
    Ifx_UReg_32Bit M0TON:8;           /**< \brief [15:8] Minimum On Time(m0ton_minton_i) - M0TON (rw) */
    Ifx_UReg_32Bit M0S0COEFF:4;       /**< \brief [19:16] S0 coefficient(m0s0_coeff_i) - M0S0COEFF (rw) */
    Ifx_UReg_32Bit M0DEADBD:2;        /**< \brief [21:20] Dead Band(m0s0_deadbd_i) - M0DEADBD (rw) */
    Ifx_UReg_32Bit M0ADCZB:2;         /**< \brief [23:22] ADC Zero Bin(m0fcfg_adczb_i) - M0ADCZB (rw) */
    Ifx_UReg_32Bit M0SKIP:4;          /**< \brief [27:24] Skip Pulse Threshold(m0skip_thres_i) - M0SKIP (rw) */
    Ifx_UReg_32Bit reserved_28:2;     /**< \brief [29:28] \internal Reserved */
    Ifx_UReg_32Bit SYNCEN:1;          /**< \brief [30:30] EVRC Synchronization input enable(synci0_en_i) - SYNCEN (rw) */
    Ifx_UReg_32Bit LCK:1;             /**< \brief [31:31] Lock Status - LCK (rh) */
} Ifx_PMS_EVRSDCTRL1_Bits;

/** \brief EVRC SD Control Register 10 */
typedef struct _Ifx_PMS_EVRSDCTRL10_Bits
{
    Ifx_UReg_32Bit SHVH:8;            /**< \brief [7:0] Short to High Voltage Threshold(shrth1_shvh_i) - SHVH (rw) */
    Ifx_UReg_32Bit SHVL:8;            /**< \brief [15:8] Short to Low Voltage Threshold(shrtl1_shvl_i) - SHVL (rw) */
    Ifx_UReg_32Bit reserved_16:12;    /**< \brief [27:16] \internal Reserved */
    Ifx_UReg_32Bit SHHVEN:1;          /**< \brief [28:28] Short to High Detection Enable(shrth0_shhven_i) - SHHVEN (rw) */
    Ifx_UReg_32Bit SHLVEN:1;          /**< \brief [29:29] Short to Low Detection Enable(shrtl0_shlven_i) - SHLVEN (rw) */
    Ifx_UReg_32Bit reserved_30:2;     /**< \brief [31:30] \internal Reserved */
} Ifx_PMS_EVRSDCTRL10_Bits;

/** \brief EVRC SD Control Register 11 */
typedef struct _Ifx_PMS_EVRSDCTRL11_Bits
{
    Ifx_UReg_32Bit DROOPVH:5;         /**< \brief [4:0] High VDD Limit for Droop request(droopvh_thres_i) - DROOPVH (rw) */
    Ifx_UReg_32Bit reserved_5:3;      /**< \brief [7:5] \internal Reserved */
    Ifx_UReg_32Bit DROOPVL:5;         /**< \brief [12:8] Low VDD Limit for Droop request(droopvl_thres_i) - DROOPVL (rw) */
    Ifx_UReg_32Bit reserved_13:3;     /**< \brief [15:13] \internal Reserved */
    Ifx_UReg_32Bit SYNCMAXDEV:5;      /**< \brief [20:16] Maximum Deviation of the Synchronization Input Frequency(synci1_maxdev_i) - SYNCMAXDEV (rw) */
    Ifx_UReg_32Bit reserved_21:3;     /**< \brief [23:21] \internal Reserved */
    Ifx_UReg_32Bit SYNCHYST:3;        /**< \brief [26:24] Lock Unlock Hysteresis Window(synci0_hyst_i) - SYNCHYST (rw) */
    Ifx_UReg_32Bit reserved_27:1;     /**< \brief [27:27] \internal Reserved */
    Ifx_UReg_32Bit SYNCMUXSEL:2;      /**< \brief [29:28] Synchronisation Input Multiplexer - SYNCMUXSEL (rw) */
    Ifx_UReg_32Bit reserved_30:1;     /**< \brief [30:30] \internal Reserved */
    Ifx_UReg_32Bit LCK:1;             /**< \brief [31:31] Lock Status - LCK (rh) */
} Ifx_PMS_EVRSDCTRL11_Bits;

/** \brief EVRC SD Control Register 2 */
typedef struct _Ifx_PMS_EVRSDCTRL2_Bits
{
    Ifx_UReg_32Bit LPBNDOFFSET:4;     /**< \brief [3:0] Low Power Mode Hysteresis OFFSET(lpbnd_offset_i) - LPBNDOFFSET (rw) */
    Ifx_UReg_32Bit LPBNDWIDTH:4;      /**< \brief [7:4] Low Power Mode Hysteresis Band Width(lpbnd_width_i) - LPBNDWIDTH (rw) */
    Ifx_UReg_32Bit LPLPFCOEFF:4;      /**< \brief [11:8] Low Pass Filter Coefficient(lplpf_coeff_i) - LPLPFCOEFF (rw) */
    Ifx_UReg_32Bit reserved_12:4;     /**< \brief [15:12] \internal Reserved */
    Ifx_UReg_32Bit SDFREQLP:12;       /**< \brief [27:16] Regulator Over-sampling Factor(m1osfl_fact_i+m1osfh_fact_i) - SDFREQLP (rw) */
    Ifx_UReg_32Bit reserved_28:2;     /**< \brief [29:28] \internal Reserved */
    Ifx_UReg_32Bit EVRCMOD:1;         /**< \brief [30:30] LPM or PWM EVRC Mode Activation - EVRCMOD (rw) */
    Ifx_UReg_32Bit LCK:1;             /**< \brief [31:31] Lock Status - LCK (rh) */
} Ifx_PMS_EVRSDCTRL2_Bits;

/** \brief EVRC SD Control Register 3 */
typedef struct _Ifx_PMS_EVRSDCTRL3_Bits
{
    Ifx_UReg_32Bit M1TOFF:8;          /**< \brief [7:0] Minimum Off Time(m1toff_mintof_i) - M1TOFF (rw) */
    Ifx_UReg_32Bit M1TON:8;           /**< \brief [15:8] Minimum On Time(m1ton_minton_i) - M1TON (rw) */
    Ifx_UReg_32Bit M1S0COEFF:4;       /**< \brief [19:16] S0 coefficient(m1s0_coeff_i) - M1S0COEFF (rw) */
    Ifx_UReg_32Bit M1DEADBD:2;        /**< \brief [21:20] Dead Band(m1s0_deadbd_i) - M1DEADBD (rw) */
    Ifx_UReg_32Bit M1ADCZB:2;         /**< \brief [23:22] ADC Zero Bin(m1fcfg_adczb_i) - M1ADCZB (rw) */
    Ifx_UReg_32Bit M1SKIP:4;          /**< \brief [27:24] Skip Pulse Threshold(m1skip_thres_i) - M1SKIP (rw) */
    Ifx_UReg_32Bit reserved_28:4;     /**< \brief [31:28] \internal Reserved */
} Ifx_PMS_EVRSDCTRL3_Bits;

/** \brief EVRC SD Control Register 4 */
typedef struct _Ifx_PMS_EVRSDCTRL4_Bits
{
    Ifx_UReg_32Bit VOKCFG:6;          /**< \brief [5:0] Voltage OK Circuit Configuration(vokcfg_config_i) - VOKCFG (rw) */
    Ifx_UReg_32Bit reserved_6:10;     /**< \brief [15:6] \internal Reserved */
    Ifx_UReg_32Bit SDFREQST:12;       /**< \brief [27:16] Regulator Switching Frequency or Over-sampling Factor(m2osfl_fact_i+m2osfh_fact_i) - SDFREQST (rw) */
    Ifx_UReg_32Bit reserved_28:4;     /**< \brief [31:28] \internal Reserved */
} Ifx_PMS_EVRSDCTRL4_Bits;

/** \brief EVRC SD Control Register 5 */
typedef struct _Ifx_PMS_EVRSDCTRL5_Bits
{
    Ifx_UReg_32Bit M2TOFF:8;          /**< \brief [7:0] Minimum Off Time(m2toff_mintof_i) - M2TOFF (rw) */
    Ifx_UReg_32Bit M2TON:8;           /**< \brief [15:8] Minimum On Time(m2ton_minton_i) - M2TON (rw) */
    Ifx_UReg_32Bit M2S0COEFF:4;       /**< \brief [19:16] S0 coefficient(m2s0_coeff_i) - M2S0COEFF (rw) */
    Ifx_UReg_32Bit M2DEADBD:2;        /**< \brief [21:20] Dead Band(m2s0_deadbd_i) - M2DEADBD (rw) */
    Ifx_UReg_32Bit M2ADCZB:2;         /**< \brief [23:22] ADC Zero Bin(m2fcfg_adczb_i) - M2ADCZB (rw) */
    Ifx_UReg_32Bit M2SKIP:4;          /**< \brief [27:24] Skip Pulse Threshold(m2skip_thres_i) - M2SKIP (rw) */
    Ifx_UReg_32Bit reserved_28:4;     /**< \brief [31:28] \internal Reserved */
} Ifx_PMS_EVRSDCTRL5_Bits;

/** \brief EVRC SD Control Register 6 */
typedef struct _Ifx_PMS_EVRSDCTRL6_Bits
{
    Ifx_UReg_32Bit SVINTH:8;          /**< \brief [7:0] Vin threshold to switch between SINCLO or SINCHI.(svinth_thres_i) - SVINTH (rw) */
    Ifx_UReg_32Bit SVOTH:8;           /**< \brief [15:8] Vout threshold to switch from open loop start-up to closed loop mode.(svoth_thres_i) - SVOTH (rw) */
    Ifx_UReg_32Bit SINCLO:3;          /**< \brief [18:16] Increment for low input voltage.(sinc_sinclo_i) - SINCLO (rw) */
    Ifx_UReg_32Bit reserved_19:1;     /**< \brief [19:19] \internal Reserved */
    Ifx_UReg_32Bit SINCHI:3;          /**< \brief [22:20] Increment for high input voltage.(sinc_sinchi_i) - SINCHI (rw) */
    Ifx_UReg_32Bit reserved_23:8;     /**< \brief [30:23] \internal Reserved */
    Ifx_UReg_32Bit LCK:1;             /**< \brief [31:31] Lock Status - LCK (rh) */
} Ifx_PMS_EVRSDCTRL6_Bits;

/** \brief EVRC SD Control Register 7 */
typedef struct _Ifx_PMS_EVRSDCTRL7_Bits
{
    Ifx_UReg_32Bit DRVNI:2;           /**< \brief [1:0] Selection of N-driver current - DRVNI (rw) */
    Ifx_UReg_32Bit DRVPCBF:2;         /**< \brief [3:2] P-Driver Current Boost Factor(drvp_strgth_i) - DRVPCBF (rw) */
    Ifx_UReg_32Bit DRVP:4;            /**< \brief [7:4] P-Driver Current(drvp_strgth_i) - DRVP (rw) */
    Ifx_UReg_32Bit DRVSLOMODE:2;      /**< \brief [9:8] Switching Configuration(drvslo_mode_i) - DRVSLOMODE (rw) */
    Ifx_UReg_32Bit reserved_10:6;     /**< \brief [15:10] \internal Reserved */
    Ifx_UReg_32Bit DRVSPR:8;          /**< \brief [23:16] Spare bits(drvspr_x_i) - DRVSPR (rw) */
    Ifx_UReg_32Bit SYNCDIVFAC:3;      /**< \brief [26:24] Switching frequency division factor for external synchronisation(synco_divfac_i) - SYNCDIVFAC (rw) */
    Ifx_UReg_32Bit reserved_27:4;     /**< \brief [30:27] \internal Reserved */
    Ifx_UReg_32Bit LCK:1;             /**< \brief [31:31] Lock Status - LCK (rh) */
} Ifx_PMS_EVRSDCTRL7_Bits;

/** \brief EVRC SD Control Register 8 */
typedef struct _Ifx_PMS_EVRSDCTRL8_Bits
{
    Ifx_UReg_32Bit FBADCOFFS:8;       /**< \brief [7:0] Feedback Converted Counter Value Offset(fbadc2_offset_i) - FBADCOFFS (rw) */
    Ifx_UReg_32Bit FBADCSMP:6;        /**< \brief [13:8] FB ADC Sampling period(fbadc1_smpthr_i) - FBADCSMP (rw) */
    Ifx_UReg_32Bit reserved_14:2;     /**< \brief [15:14] \internal Reserved */
    Ifx_UReg_32Bit FBADCBLNK:2;       /**< \brief [17:16] FB ADC Blanked Samples Number(fbadc0_blank_i) - FBADCBLNK (rw) */
    Ifx_UReg_32Bit reserved_18:2;     /**< \brief [19:18] \internal Reserved */
    Ifx_UReg_32Bit FBADCLPF:2;        /**< \brief [21:20] FB ADC Counter LPF Coefficient(fbadc0_lpfcnt_i) - FBADCLPF (rw) */
    Ifx_UReg_32Bit reserved_22:2;     /**< \brief [23:22] \internal Reserved */
    Ifx_UReg_32Bit FBADCERR:2;        /**< \brief [25:24] FB ADC Error LPF Coefficient(fbadc3_lpferr_i) - FBADCERR (rw) */
    Ifx_UReg_32Bit reserved_26:2;     /**< \brief [27:26] \internal Reserved */
    Ifx_UReg_32Bit FBADCLSB:1;        /**< \brief [28:28] FB ADC LSB for Error Computation(fbadc3_lsb_i) - FBADCLSB (rw) */
    Ifx_UReg_32Bit reserved_29:2;     /**< \brief [30:29] \internal Reserved */
    Ifx_UReg_32Bit LCK:1;             /**< \brief [31:31] Lock Status - LCK (rh) */
} Ifx_PMS_EVRSDCTRL8_Bits;

/** \brief EVRC SD Control Register 9 */
typedef struct _Ifx_PMS_EVRSDCTRL9_Bits
{
    Ifx_UReg_32Bit FFADCOFFS:8;       /**< \brief [7:0] Feed Forward Converted Counter Value Offset(ffadc1_offset_i) - FFADCOFFS (rw) */
    Ifx_UReg_32Bit FFADCLPF:3;        /**< \brief [10:8] FF ADC Counter LPF Coefficient(ffadc0_lpfcnt_i) - FFADCLPF (rw) */
    Ifx_UReg_32Bit reserved_11:20;    /**< \brief [30:11] \internal Reserved */
    Ifx_UReg_32Bit LCK:1;             /**< \brief [31:31] Lock Status - LCK (rh) */
} Ifx_PMS_EVRSDCTRL9_Bits;

/** \brief EVR SD Status Register 0 */
typedef struct _Ifx_PMS_EVRSDSTAT0_Bits
{
    Ifx_UReg_32Bit ADCFBCV:8;         /**< \brief [7:0] Step Down Converter Core Voltage Feedback ADC Conversion Result - ADCFBCV (rh) */
    Ifx_UReg_32Bit reserved_8:8;      /**< \brief [15:8] \internal Reserved */
    Ifx_UReg_32Bit DPWMOUT:12;        /**< \brief [27:16] DPWM Control Output Status - DPWMOUT (rh) */
    Ifx_UReg_32Bit reserved_28:4;     /**< \brief [31:28] \internal Reserved */
} Ifx_PMS_EVRSDSTAT0_Bits;

/** \brief EVR Status Register */
typedef struct _Ifx_PMS_EVRSTAT_Bits
{
    Ifx_UReg_32Bit EVRC:1;            /**< \brief [0:0] EVRC status - EVRC (rh) */
    Ifx_UReg_32Bit OVC:1;             /**< \brief [1:1] VDD Over-voltage event flag - OVC (rh) */
    Ifx_UReg_32Bit EVR33:1;           /**< \brief [2:2] EVR33 status - EVR33 (rh) */
    Ifx_UReg_32Bit OV33:1;            /**< \brief [3:3] VDDP3 Over-voltage event flag - OV33 (rh) */
    Ifx_UReg_32Bit OVSWD:1;           /**< \brief [4:4] VEXT Over-voltage event flag - OVSWD (rh) */
    Ifx_UReg_32Bit UVC:1;             /**< \brief [5:5] VDD Under-voltage event flag - UVC (rh) */
    Ifx_UReg_32Bit UV33:1;            /**< \brief [6:6] VDDP3 Under-voltage event flag - UV33 (rh) */
    Ifx_UReg_32Bit UVSWD:1;           /**< \brief [7:7] VEXT Under-voltage event flag - UVSWD (rh) */
    Ifx_UReg_32Bit SYNCLCK:1;         /**< \brief [8:8] EVRC Synchronization Input Locked status(sd_sync_in_locked_o) - SYNCLCK (rh) */
    Ifx_UReg_32Bit EVR33VOK:1;        /**< \brief [9:9] EVR33 Regulator Voltage OK status - EVR33VOK (rh) */
    Ifx_UReg_32Bit reserved_10:3;     /**< \brief [12:10] \internal Reserved */
    Ifx_UReg_32Bit RSTC:1;            /**< \brief [13:13] EVRC Reset Trigger - RSTC (rh) */
    Ifx_UReg_32Bit RST33:1;           /**< \brief [14:14] EVR33 Reset Trigger - RST33 (rh) */
    Ifx_UReg_32Bit RSTSWD:1;          /**< \brief [15:15] EVR SWD Reset Trigger - RSTSWD (rh) */
    Ifx_UReg_32Bit EVRCSHLV:1;        /**< \brief [16:16] Short to ground - EVRCSHLV (rh) */
    Ifx_UReg_32Bit EVRCSHHV:1;        /**< \brief [17:17] Short to supply - EVRCSHHV (rh) */
    Ifx_UReg_32Bit EVR33SHLV:1;       /**< \brief [18:18] Short to ground - EVR33SHLV (rh) */
    Ifx_UReg_32Bit EVR33SHHV:1;       /**< \brief [19:19] Short to supply - EVR33SHHV (rh) */
    Ifx_UReg_32Bit SWDLVL:1;          /**< \brief [20:20] VEXT External Supply Level Status - SWDLVL (rh) */
    Ifx_UReg_32Bit SDVOK:1;           /**< \brief [21:21] EVRC Regulator Voltage OK status - SDVOK (rh) */
    Ifx_UReg_32Bit EVRCMOD:2;         /**< \brief [23:22] EVRC Mode - EVRCMOD (rh) */
    Ifx_UReg_32Bit OVPRE:1;           /**< \brief [24:24] Pre Regulator VDDPD Over-voltage event flag - OVPRE (rh) */
    Ifx_UReg_32Bit OVSB:1;            /**< \brief [25:25] Standby Supply or VEVRSB Over-voltage event flag - OVSB (rh) */
    Ifx_UReg_32Bit OVDDM:1;           /**< \brief [26:26] ADC VDDM Supply Over-voltage event flag - OVDDM (rh) */
    Ifx_UReg_32Bit UVPRE:1;           /**< \brief [27:27] Pre Regulator VDDPD Under-voltage event flag - UVPRE (rh) */
    Ifx_UReg_32Bit UVSB:1;            /**< \brief [28:28] Standby Supply or VEVRSB Under-voltage event flag - UVSB (rh) */
    Ifx_UReg_32Bit UVDDM:1;           /**< \brief [29:29] ADC VDDM Supply Under-voltage event flag - UVDDM (rh) */
    Ifx_UReg_32Bit reserved_30:2;     /**< \brief [31:30] \internal Reserved */
} Ifx_PMS_EVRSTAT_Bits;

/** \brief EVR Trim Control Register */
typedef struct _Ifx_PMS_EVRTRIM_Bits
{
    Ifx_UReg_32Bit EVR33VOUTSEL:8;    /**< \brief [7:0] EVR33 Regulator Output Voltage Target Value - EVR33VOUTSEL (rw) */
    Ifx_UReg_32Bit SDVOUTSEL:8;       /**< \brief [15:8] EVRC Regulator Output Voltage Target Value - SDVOUTSEL (rw) */
    Ifx_UReg_32Bit EVR33VOUTTRIM:6;    /**< \brief [21:16] EVR33 Regulator Output Voltage Trim Value - EVR33VOUTTRIM (rw) */
    Ifx_UReg_32Bit reserved_22:2;     /**< \brief [23:22] \internal Reserved */
    Ifx_UReg_32Bit SDVOUTTRIM:6;      /**< \brief [29:24] EVRC Regulator Output Voltage Trim Value(vtrim_trim_i) - SDVOUTTRIM (rw) */
    Ifx_UReg_32Bit SLCK:1;            /**< \brief [30:30] HSM Security Lock - SLCK (rw) */
    Ifx_UReg_32Bit LCK:1;             /**< \brief [31:31] Lock Status - LCK (rh) */
} Ifx_PMS_EVRTRIM_Bits;

/** \brief EVR Trim Status Register */
typedef struct _Ifx_PMS_EVRTRIMSTAT_Bits
{
    Ifx_UReg_32Bit EVR33VOUTSEL:8;    /**< \brief [7:0] EVR33 Regulator Output Voltage Target Value - EVR33VOUTSEL (rh) */
    Ifx_UReg_32Bit SDVOUTSEL:8;       /**< \brief [15:8] EVRC Regulator Output Voltage Target Value - SDVOUTSEL (rh) */
    Ifx_UReg_32Bit EVR33VOUTTRIM:6;    /**< \brief [21:16] EVR33 Regulator Output Voltage Trim Value - EVR33VOUTTRIM (rh) */
    Ifx_UReg_32Bit reserved_22:2;     /**< \brief [23:22] \internal Reserved */
    Ifx_UReg_32Bit SDVOUTTRIM:6;      /**< \brief [29:24] EVRC Regulator Output Voltage Trim Value(vtrim_trim_o) - SDVOUTTRIM (rh) */
    Ifx_UReg_32Bit reserved_30:2;     /**< \brief [31:30] \internal Reserved */
} Ifx_PMS_EVRTRIMSTAT_Bits;

/** \brief EVR Primary HSM Over-voltage Monitor Register */
typedef struct _Ifx_PMS_HSMOVMON_Bits
{
    Ifx_UReg_32Bit EVRCOVVAL:8;       /**< \brief [7:0] VDD Supply Primary Monitor Alarm Over-voltage threshold - EVRCOVVAL (rw) */
    Ifx_UReg_32Bit EVR33OVVAL:8;      /**< \brief [15:8] VDDP3 Supply Primary Monitor Alarm Over-voltage threshold - EVR33OVVAL (rw) */
    Ifx_UReg_32Bit SWDOVVAL:8;        /**< \brief [23:16] VEXT Supply Primary Monitor Alarm Over-voltage threshold - SWDOVVAL (rw) */
    Ifx_UReg_32Bit EVRCOFF:1;         /**< \brief [24:24] VDD Primary Monitor OV Alarm Disable - EVRCOFF (rw) */
    Ifx_UReg_32Bit EVR33OFF:1;        /**< \brief [25:25] VDDP3 Primary Monitor OV Alarm Disable - EVR33OFF (rw) */
    Ifx_UReg_32Bit SWDOFF:1;          /**< \brief [26:26] VEXT Primary Monitor OV Alarm Disable - SWDOFF (rw) */
    Ifx_UReg_32Bit reserved_27:4;     /**< \brief [30:27] \internal Reserved */
    Ifx_UReg_32Bit SLCK:1;            /**< \brief [31:31] HSM Security Lock - SLCK (rw) */
} Ifx_PMS_HSMOVMON_Bits;

/** \brief EVR Primary HSM Under-voltage Monitor Register */
typedef struct _Ifx_PMS_HSMUVMON_Bits
{
    Ifx_UReg_32Bit EVRCUVVAL:8;       /**< \brief [7:0] VDD Supply Primary Monitor Alarm Under-voltage threshold - EVRCUVVAL (rw) */
    Ifx_UReg_32Bit EVR33UVVAL:8;      /**< \brief [15:8] VDDP3 Supply Primary Monitor Alarm Under-voltage threshold - EVR33UVVAL (rw) */
    Ifx_UReg_32Bit SWDUVVAL:8;        /**< \brief [23:16] VEXT Supply Primary Monitor Alarm Under-voltage threshold - SWDUVVAL (rw) */
    Ifx_UReg_32Bit EVRCOFF:1;         /**< \brief [24:24] VDD Primary Monitor UV Alarm Disable - EVRCOFF (rw) */
    Ifx_UReg_32Bit EVR33OFF:1;        /**< \brief [25:25] VDDP3 Primary Monitor UV Alarm Disable - EVR33OFF (rw) */
    Ifx_UReg_32Bit SWDOFF:1;          /**< \brief [26:26] VEXT Primary Monitor UV Alarm Disable - SWDOFF (rw) */
    Ifx_UReg_32Bit HSMFIL:4;          /**< \brief [30:27] HSM Voltage Filter - HSMFIL (rw) */
    Ifx_UReg_32Bit SLCK:1;            /**< \brief [31:31] HSM Security Lock - SLCK (rw) */
} Ifx_PMS_HSMUVMON_Bits;

/** \brief Identification Register */
typedef struct _Ifx_PMS_ID_Bits
{
    Ifx_UReg_32Bit MODREV:8;          /**< \brief [7:0] Module Revision Number - MODREV (r) */
    Ifx_UReg_32Bit MODTYPE:8;         /**< \brief [15:8] Module Type - MODTYPE (r) */
    Ifx_UReg_32Bit MODNUMBER:16;      /**< \brief [31:16] Module Number - MODNUMBER (r) */
} Ifx_PMS_ID_Bits;

/** \brief SMU_stdby BIST Control Register */
typedef struct _Ifx_PMS_MONBISTCTRL_Bits
{
    Ifx_UReg_32Bit TSTEN:1;           /**< \brief [0:0] SMU_stdby alarm BIST enable - TSTEN (rwh) */
    Ifx_UReg_32Bit TSTCLR:1;          /**< \brief [1:1] SMU_stdby BIST flag clear - TSTCLR (w) */
    Ifx_UReg_32Bit reserved_2:28;     /**< \brief [29:2] \internal Reserved */
    Ifx_UReg_32Bit BITPROT:1;         /**< \brief [30:30] Bit Protection TSTEN - BITPROT (w) */
    Ifx_UReg_32Bit reserved_31:1;     /**< \brief [31:31] \internal Reserved */
} Ifx_PMS_MONBISTCTRL_Bits;

/** \brief SMU_stdby BIST Status Register */
typedef struct _Ifx_PMS_MONBISTSTAT_Bits
{
    Ifx_UReg_32Bit TSTOK:1;           /**< \brief [0:0] SMU_stdby BIST ok bit - TSTOK (rh) */
    Ifx_UReg_32Bit reserved_1:1;      /**< \brief [1:1] \internal Reserved */
    Ifx_UReg_32Bit TSTRUN:1;          /**< \brief [2:2] SMU_stdby BIST run bit - TSTRUN (rh) */
    Ifx_UReg_32Bit TSTDONE:1;         /**< \brief [3:3] SMU_stdby BIST done bit - TSTDONE (rh) */
    Ifx_UReg_32Bit SMUERR:1;          /**< \brief [4:4] Error found in SMU_stdby found by SMU_stdby BIST (rh) */
    Ifx_UReg_32Bit PMSERR:1;          /**< \brief [5:5] Error found in PMS SARADC by SMU_stdby BIST (rh) */
    Ifx_UReg_32Bit reserved_6:26;     /**< \brief [31:6] \internal Reserved */
} Ifx_PMS_MONBISTSTAT_Bits;

/** \brief EVR Secondary Monitor Control Register */
typedef struct _Ifx_PMS_MONCTRL_Bits
{
    Ifx_UReg_32Bit EVRCOVMOD:2;       /**< \brief [1:0] VDD Over-voltage monitoring mode - EVRCOVMOD (rw) */
    Ifx_UReg_32Bit PREOVMOD:2;        /**< \brief [3:2] EVRPR or VDDPD Over-voltage monitoring mode - PREOVMOD (rw) */
    Ifx_UReg_32Bit EVRCUVMOD:2;       /**< \brief [5:4] VDD Under-voltage monitoring mode - EVRCUVMOD (rw) */
    Ifx_UReg_32Bit PREUVMOD:2;        /**< \brief [7:6] EVRPR or VDDPD Under-voltage monitoring mode - PREUVMOD (rw) */
    Ifx_UReg_32Bit EVR33OVMOD:2;      /**< \brief [9:8] VDDP3 Supply Over-voltage monitoring mode - EVR33OVMOD (rw) */
    Ifx_UReg_32Bit VDDMOVMOD:2;       /**< \brief [11:10] VDDM ADC Supply Over-voltage monitoring mode - VDDMOVMOD (rw) */
    Ifx_UReg_32Bit EVR33UVMOD:2;      /**< \brief [13:12] VDDP3 Supply Under-voltage monitoring mode - EVR33UVMOD (rw) */
    Ifx_UReg_32Bit VDDMUVMOD:2;       /**< \brief [15:14] VDDM ADC Supply Under-voltage monitoring mode - VDDMUVMOD (rw) */
    Ifx_UReg_32Bit SWDOVMOD:2;        /**< \brief [17:16] VEXT Over-voltage monitoring mode - SWDOVMOD (rw) */
    Ifx_UReg_32Bit SBOVMOD:2;         /**< \brief [19:18] EVR Standby Supply or VEVRSB Over-voltage monitoring mode - SBOVMOD (rw) */
    Ifx_UReg_32Bit SWDUVMOD:2;        /**< \brief [21:20] VEXT Under-voltage monitoring mode - SWDUVMOD (rw) */
    Ifx_UReg_32Bit SBUVMOD:2;         /**< \brief [23:22] EVR Standby Supply or VEVRSB Under-voltage monitoring mode - SBUVMOD (rw) */
    Ifx_UReg_32Bit reserved_24:6;     /**< \brief [29:24] \internal Reserved */
    Ifx_UReg_32Bit SLCK:1;            /**< \brief [30:30] HSM Security Lock - SLCK (rw) */
    Ifx_UReg_32Bit reserved_31:1;     /**< \brief [31:31] \internal Reserved */
} Ifx_PMS_MONCTRL_Bits;

/** \brief EVR Secondary Monitor Filter Register */
typedef struct _Ifx_PMS_MONFILT_Bits
{
    Ifx_UReg_32Bit EVRCFIL:4;         /**< \brief [3:0] VDD Secondary ADC Supply Filter - EVRCFIL (rw) */
    Ifx_UReg_32Bit PREFIL:4;          /**< \brief [7:4] VDDPD Secondary ADC Supply Filter - PREFIL (rw) */
    Ifx_UReg_32Bit EVR33FIL:4;        /**< \brief [11:8] VDDP3 Secondary ADC Supply Filter - EVR33FIL (rw) */
    Ifx_UReg_32Bit VDDMFIL:4;         /**< \brief [15:12] VDDM Secondary ADC Supply Filter - VDDMFIL (rw) */
    Ifx_UReg_32Bit SWDFIL:4;          /**< \brief [19:16] VEXT Secondary ADC Supply Filter - SWDFIL (rw) */
    Ifx_UReg_32Bit SBFIL:4;           /**< \brief [23:20] VEVRSB Secondary ADC Supply Filter - SBFIL (rw) */
    Ifx_UReg_32Bit reserved_24:5;     /**< \brief [28:24] \internal Reserved */
    Ifx_UReg_32Bit CLRFIL:1;          /**< \brief [29:29] Clear all Spike Filters - CLRFIL (rw) */
    Ifx_UReg_32Bit SLCK:1;            /**< \brief [30:30] HSM Security Lock - SLCK (rw) */
    Ifx_UReg_32Bit reserved_31:1;     /**< \brief [31:31] \internal Reserved */
} Ifx_PMS_MONFILT_Bits;

/** \brief EVR Secondary ADC Status Register 1 */
typedef struct _Ifx_PMS_MONSTAT1_Bits
{
    Ifx_UReg_32Bit ADCCV:8;           /**< \brief [7:0] VDD Supply Secondary ADC Conversion Result - ADCCV (rh) */
    Ifx_UReg_32Bit ADC33V:8;          /**< \brief [15:8] VDDP3 Supply Secondary ADC Conversion Result - ADC33V (rh) */
    Ifx_UReg_32Bit ADCSWDV:8;         /**< \brief [23:16] VEXT Supply Secondary ADC Conversion Result - ADCSWDV (rh) */
    Ifx_UReg_32Bit ACTVCNT:6;         /**< \brief [29:24] Secondary Monitor Activity Counter - ACTVCNT (rh) */
    Ifx_UReg_32Bit reserved_30:2;     /**< \brief [31:30] \internal Reserved */
} Ifx_PMS_MONSTAT1_Bits;

/** \brief EVR Secondary ADC Status Register 2 */
typedef struct _Ifx_PMS_MONSTAT2_Bits
{
    Ifx_UReg_32Bit ADCPRE:8;          /**< \brief [7:0] VDDPD Supply Secondary ADC Conversion Result - ADCPRE (rh) */
    Ifx_UReg_32Bit ADCSB:8;           /**< \brief [15:8] VEVRSB Supply Secondary ADC Conversion Result - ADCSB (rh) */
    Ifx_UReg_32Bit ADCVDDM:8;         /**< \brief [23:16] VDDM Supply Secondary ADC Conversion Result - ADCVDDM (rh) */
    Ifx_UReg_32Bit reserved_24:8;     /**< \brief [31:24] \internal Reserved */
} Ifx_PMS_MONSTAT2_Bits;

/** \brief OCDS Trigger Set Control 0 Register */
typedef struct _Ifx_PMS_OTSC0_Bits
{
    Ifx_UReg_32Bit B0LAM:4;           /**< \brief [3:0] OTGB0 TS16_ADCMON Low Byte - B0LAM (rw) */
    Ifx_UReg_32Bit reserved_4:4;      /**< \brief [7:4] \internal Reserved */
    Ifx_UReg_32Bit B0HAM:4;           /**< \brief [11:8] OTGB0 TS16_ADCMON High Byte - B0HAM (rw) */
    Ifx_UReg_32Bit reserved_12:4;     /**< \brief [15:12] \internal Reserved */
    Ifx_UReg_32Bit B1LAM:4;           /**< \brief [19:16] OTGB1 TS16_ADCMON Low Byte - B1LAM (rw) */
    Ifx_UReg_32Bit reserved_20:4;     /**< \brief [23:20] \internal Reserved */
    Ifx_UReg_32Bit B1HAM:4;           /**< \brief [27:24] OTGB1 TS16_ADCMON High Byte - B1HAM (rw) */
    Ifx_UReg_32Bit reserved_28:4;     /**< \brief [31:28] \internal Reserved */
} Ifx_PMS_OTSC0_Bits;

/** \brief OCDS Trigger Set Control 1 Register */
typedef struct _Ifx_PMS_OTSC1_Bits
{
    Ifx_UReg_32Bit B0EC:4;            /**< \brief [3:0] OTGB0 TS16_EVRCON - B0EC (rw) */
    Ifx_UReg_32Bit reserved_4:4;      /**< \brief [7:4] \internal Reserved */
    Ifx_UReg_32Bit B1EC:4;            /**< \brief [11:8] OTGB1 TS16_EVRCON - B1EC (rw) */
    Ifx_UReg_32Bit reserved_12:4;     /**< \brief [15:12] \internal Reserved */
    Ifx_UReg_32Bit DMONAD:8;          /**< \brief [23:16] OTGB0 TS16_EVRCON DMONAD - DMONAD (rw) */
    Ifx_UReg_32Bit SMCDBG:8;          /**< \brief [31:24] OTGB0 TS16_EVRCON SMCDBG - SMCDBG (rw) */
} Ifx_PMS_OTSC1_Bits;

/** \brief OCDS Trigger Set Select Register */
typedef struct _Ifx_PMS_OTSS_Bits
{
    Ifx_UReg_32Bit OTGB0:4;           /**< \brief [3:0] Trigger Set for OTGB0 - OTGB0 (rw) */
    Ifx_UReg_32Bit reserved_4:4;      /**< \brief [7:4] \internal Reserved */
    Ifx_UReg_32Bit OTGB1:4;           /**< \brief [11:8] Trigger Set for OTGB1 - OTGB1 (rw) */
    Ifx_UReg_32Bit reserved_12:4;     /**< \brief [15:12] \internal Reserved */
    Ifx_UReg_32Bit reserved_16:16;    /**< \brief [31:16] \internal Reserved */
} Ifx_PMS_OTSS_Bits;

/** \brief EVR Secondary Over-voltage Monitor Register */
typedef struct _Ifx_PMS_OVMON_Bits
{
    Ifx_UReg_32Bit EVRCOVVAL:8;       /**< \brief [7:0] VDD Supply Secondary Monitor Over-voltage threshold - EVRCOVVAL (rw) */
    Ifx_UReg_32Bit EVR33OVVAL:8;      /**< \brief [15:8] VDDP3 Supply Secondary Monitor Over-voltage threshold - EVR33OVVAL (rw) */
    Ifx_UReg_32Bit SWDOVVAL:8;        /**< \brief [23:16] VEXT Supply Secondary Monitor Over-voltage threshold - SWDOVVAL (rw) */
    Ifx_UReg_32Bit reserved_24:6;     /**< \brief [29:24] \internal Reserved */
    Ifx_UReg_32Bit SLCK:1;            /**< \brief [30:30] HSM Security Lock - SLCK (rw) */
    Ifx_UReg_32Bit reserved_31:1;     /**< \brief [31:31] \internal Reserved */
} Ifx_PMS_OVMON_Bits;

/** \brief EVR Secondary Over-voltage Monitor Register 2 */
typedef struct _Ifx_PMS_OVMON2_Bits
{
    Ifx_UReg_32Bit PREOVVAL:8;        /**< \brief [7:0] VDDPD Supply Secondary Monitor Over-voltage threshold - PREOVVAL (rw) */
    Ifx_UReg_32Bit VDDMOVVAL:8;       /**< \brief [15:8] VDDM Supply Secondary Monitor Over-voltage threshold - VDDMOVVAL (rw) */
    Ifx_UReg_32Bit SBOVVAL:8;         /**< \brief [23:16] VEVRSB Supply Secondary Monitor Over-voltage threshold - SBOVVAL (rw) */
    Ifx_UReg_32Bit reserved_24:6;     /**< \brief [29:24] \internal Reserved */
    Ifx_UReg_32Bit SLCK:1;            /**< \brief [30:30] HSM Security Lock - SLCK (rw) */
    Ifx_UReg_32Bit reserved_31:1;     /**< \brief [31:31] \internal Reserved */
} Ifx_PMS_OVMON2_Bits;

/** \brief PMS Interrupt Enable Register */
typedef struct _Ifx_PMS_PMSIEN_Bits
{
    Ifx_UReg_32Bit OVSWD:1;           /**< \brief [0:0] OVSWD Interrupt enable - OVSWD (rw) */
    Ifx_UReg_32Bit UVSWD:1;           /**< \brief [1:1] UVSWD Interrupt enable - UVSWD (rw) */
    Ifx_UReg_32Bit OV33:1;            /**< \brief [2:2] OV33 Interrupt enable - OV33 (rw) */
    Ifx_UReg_32Bit UV33:1;            /**< \brief [3:3] UV33 Interrupt enable - UV33 (rw) */
    Ifx_UReg_32Bit OVC:1;             /**< \brief [4:4] OVC Interrupt enable - OVC (rw) */
    Ifx_UReg_32Bit UVC:1;             /**< \brief [5:5] UVC Interrupt enable - UVC (rw) */
    Ifx_UReg_32Bit OVPRE:1;           /**< \brief [6:6] OVPRE Interrupt enable - OVPRE (rw) */
    Ifx_UReg_32Bit UVPRE:1;           /**< \brief [7:7] UVPRE Interrupt enable - UVPRE (rw) */
    Ifx_UReg_32Bit OVDDM:1;           /**< \brief [8:8] OVDDM Interrupt enable - OVDDM (rw) */
    Ifx_UReg_32Bit UVDDM:1;           /**< \brief [9:9] UVDDM Interrupt enable - UVDDM (rw) */
    Ifx_UReg_32Bit OVSB:1;            /**< \brief [10:10] OVSB Interrupt enable - OVSB (rw) */
    Ifx_UReg_32Bit UVSB:1;            /**< \brief [11:11] UVSB Interrupt enable - UVSB (rw) */
    Ifx_UReg_32Bit reserved_12:4;     /**< \brief [15:12] \internal Reserved */
    Ifx_UReg_32Bit EVRCMOD:1;         /**< \brief [16:16] EVRCMOD Interrupt enable - EVRCMOD (rw) */
    Ifx_UReg_32Bit SDVOK:1;           /**< \brief [17:17] SDVOK Interrupt enable - SDVOK (rw) */
    Ifx_UReg_32Bit SYNCLCK:1;         /**< \brief [18:18] SD SYNCLCK Interrupt enable - SYNCLCK (rw) */
    Ifx_UReg_32Bit SWDLVL:1;          /**< \brief [19:19] SWDLVL Interrupt enable - SWDLVL (rw) */
    Ifx_UReg_32Bit reserved_20:1;     /**< \brief [20:20] \internal Reserved */
    Ifx_UReg_32Bit WUTWKP:1;          /**< \brief [21:21] WUTWKP Interrupt enable - WUTWKP (rw) */
    Ifx_UReg_32Bit ESR0WKP:1;         /**< \brief [22:22] ESR0WKP Interrupt enable - ESR0WKP (rw) */
    Ifx_UReg_32Bit ESR1WKP:1;         /**< \brief [23:23] ESR1WKP Interrupt enable - ESR1WKP (rw) */
    Ifx_UReg_32Bit PINAWKP:1;         /**< \brief [24:24] PINAWKP Interrupt enable - PINAWKP (rw) */
    Ifx_UReg_32Bit PINBWKP:1;         /**< \brief [25:25] PINBWKP Interrupt enable - PINBWKP (rw) */
    Ifx_UReg_32Bit SCRINT:1;          /**< \brief [26:26] SCRINT Interrupt enable - SCRINT (rw) */
    Ifx_UReg_32Bit SCRRST:1;          /**< \brief [27:27] SCRRST Interrupt enable - SCRRST (rw) */
    Ifx_UReg_32Bit SCRECC:1;          /**< \brief [28:28] SCRECC Interrupt enable - SCRECC (rw) */
    Ifx_UReg_32Bit SCRWDT:1;          /**< \brief [29:29] SCRWDT Interrupt enable - SCRWDT (rw) */
    Ifx_UReg_32Bit reserved_30:2;     /**< \brief [31:30] \internal Reserved */
} Ifx_PMS_PMSIEN_Bits;

/** \brief Standby and Wake-up Control Register 0 */
typedef struct _Ifx_PMS_PMSWCR0_Bits
{
    Ifx_UReg_32Bit reserved_0:2;      /**< \brief [1:0] \internal Reserved */
    Ifx_UReg_32Bit VEXTSTBYEN:1;      /**< \brief [2:2] Standby Entry on VEXT Supply ramp-down - VEXTSTBYEN (rw) */
    Ifx_UReg_32Bit VDDSTBYEN:1;       /**< \brief [3:3] Standby Entry on VDD Supply ramp-down - VDDSTBYEN (rw) */
    Ifx_UReg_32Bit ESR0DFEN:1;        /**< \brief [4:4] ESR0 Digital Filter Enable - ESR0DFEN (rw) */
    Ifx_UReg_32Bit ESR0EDCON:2;       /**< \brief [6:5] ESR0 Edge Detection Control - ESR0EDCON (rw) */
    Ifx_UReg_32Bit ESR1DFEN:1;        /**< \brief [7:7] ESR1 Digital Filter Enable - ESR1DFEN (rw) */
    Ifx_UReg_32Bit ESR1EDCON:2;       /**< \brief [9:8] ESR1 Edge Detection Control - ESR1EDCON (rw) */
    Ifx_UReg_32Bit PINADFEN:1;        /**< \brief [10:10] PINA Digital Filter Enable - PINADFEN (rw) */
    Ifx_UReg_32Bit PINAEDCON:2;       /**< \brief [12:11] PINA Edge Detection Control - PINAEDCON (rw) */
    Ifx_UReg_32Bit PINBDFEN:1;        /**< \brief [13:13] PINB Digital Filter Enable - PINBDFEN (rw) */
    Ifx_UReg_32Bit PINBEDCON:2;       /**< \brief [15:14] PINB Edge Detection Control - PINBEDCON (rw) */
    Ifx_UReg_32Bit STBYRAMSEL:3;      /**< \brief [18:16] Standby RAM supply in Standby Mode - STBYRAMSEL (rw) */
    Ifx_UReg_32Bit reserved_19:1;     /**< \brief [19:19] \internal Reserved */
    Ifx_UReg_32Bit BLNKFIL:4;         /**< \brief [23:20] Blanking Filter delay for Wake-up - BLNKFIL (rw) */
    Ifx_UReg_32Bit ESR0WKEN:1;        /**< \brief [24:24] ESR0 Wake-up enable from Standby - ESR0WKEN (rw) */
    Ifx_UReg_32Bit ESR1WKEN:1;        /**< \brief [25:25] ESR1 Wake-up enable from Standby - ESR1WKEN (rw) */
    Ifx_UReg_32Bit PINAWKEN:1;        /**< \brief [26:26] Pin A Wake-up enable from Standby - PINAWKEN (rw) */
    Ifx_UReg_32Bit PINBWKEN:1;        /**< \brief [27:27] Pin B Wake-up enable from Standby - PINBWKEN (rw) */
    Ifx_UReg_32Bit PWRWKEN:1;         /**< \brief [28:28] Standby Wake-up Enable on VEXT Supply ramp-up - PWRWKEN (rw) */
    Ifx_UReg_32Bit SCRWKEN:1;         /**< \brief [29:29] Standby Controller Wake-up enable from Standby - SCRWKEN (rw) */
    Ifx_UReg_32Bit PORSTWKEN:1;       /**< \brief [30:30] PORST pin Wake-up enable from Standby - PORSTWKEN (rw) */
    Ifx_UReg_32Bit WUTWKEN:1;         /**< \brief [31:31] WUT Wake-up enable from Standby - WUTWKEN (rw) */
} Ifx_PMS_PMSWCR0_Bits;

/** \brief Standby and Wake-up Control Register 2 */
typedef struct _Ifx_PMS_PMSWCR2_Bits
{
    Ifx_UReg_32Bit SCRINT:8;          /**< \brief [7:0] Data exchange from Standby Controller to PMS main domain. - SCRINT (rh) */
    Ifx_UReg_32Bit reserved_8:1;      /**< \brief [8:8] \internal Reserved */
    Ifx_UReg_32Bit SCRECC:1;          /**< \brief [9:9] SCR RAM ECC error / reset flag - SCRECC (rwh) */
    Ifx_UReg_32Bit SCRWDT:1;          /**< \brief [10:10] SCR Watchdog Timer error / reset flag - SCRWDT (rwh) */
    Ifx_UReg_32Bit SCRRST:1;          /**< \brief [11:11] SCR Software reset flag - SCRRST (rwh) */
    Ifx_UReg_32Bit reserved_12:4;     /**< \brief [15:12] \internal Reserved */
    Ifx_UReg_32Bit TCINT:8;           /**< \brief [23:16] Data exchange from PMS main domain to Standby Controller. - TCINT (rw) */
    Ifx_UReg_32Bit TCINTREQ:1;        /**< \brief [24:24] SW Interrupt request from PMS to Standby Controller. - TCINTREQ (rwh) */
    Ifx_UReg_32Bit SMURST:1;          /**< \brief [25:25] SMU Reset indication flag - SMURST (rh) */
    Ifx_UReg_32Bit RST:1;             /**< \brief [26:26] Application or System Reset indication flag - RST (rh) */
    Ifx_UReg_32Bit reserved_27:5;     /**< \brief [31:27] \internal Reserved */
} Ifx_PMS_PMSWCR2_Bits;

/** \brief Standby and Wake-up Control Register 3 */
typedef struct _Ifx_PMS_PMSWCR3_Bits
{
    Ifx_UReg_32Bit WUTREL:24;         /**< \brief [23:0] WUT reload value. - WUTREL (rw) */
    Ifx_UReg_32Bit reserved_24:3;     /**< \brief [26:24] \internal Reserved */
    Ifx_UReg_32Bit WUTEN:1;           /**< \brief [27:27] WUT enable - WUTEN (rw) */
    Ifx_UReg_32Bit BUSY:1;            /**< \brief [28:28] Lock Status - LCK (rh) */
    Ifx_UReg_32Bit WUTDIV:1;          /**< \brief [29:29] WUT clock divider - WUTDIV (rw) */
    Ifx_UReg_32Bit WUTMODE:1;         /**< \brief [30:30] WUT mode selection - WUTMODE (rw) */
    Ifx_UReg_32Bit reserved_31:1;     /**< \brief [31:31] \internal Reserved */
} Ifx_PMS_PMSWCR3_Bits;

/** \brief Standby and Wake-up Control Register 4 */
typedef struct _Ifx_PMS_PMSWCR4_Bits
{
    Ifx_UReg_32Bit BPSCRSTREQ:1;      /**< \brief [0:0] Standby Controller Reset request enable - SCRSTEN (w) */
    Ifx_UReg_32Bit SCRSTREQ:1;        /**< \brief [1:1] Standby Controller Reset request - SCRSTREQ (rwh) */
    Ifx_UReg_32Bit reserved_2:2;      /**< \brief [3:2] \internal Reserved */
    Ifx_UReg_32Bit BPPORSTREQ:1;      /**< \brief [4:4] Bit Protection for PORSTREQ - PORSTEN (w) */
    Ifx_UReg_32Bit PORSTREQ:1;        /**< \brief [5:5] SCR Reset behavior on warm PORST in Normal RUN / SLEEP mode - PORSTREQ (rw) */
    Ifx_UReg_32Bit SCRCLKSEL:1;       /**< \brief [6:6] Default Clock selection on Standby Mode Entry - SCRCLKSEL (rw) */
    Ifx_UReg_32Bit reserved_7:9;      /**< \brief [15:7] \internal Reserved */
    Ifx_UReg_32Bit SCRCFG:8;          /**< \brief [23:16] Hardware configuration of the 8 bit SCR controller. - SCRCFG (rw) */
    Ifx_UReg_32Bit BPSCREN:1;         /**< \brief [24:24] Standby Controller Reset request enable - BPSCREN (w) */
    Ifx_UReg_32Bit SCREN:1;           /**< \brief [25:25] Standby Controller Enable request - SCREN (rw) */
    Ifx_UReg_32Bit reserved_26:6;     /**< \brief [31:26] \internal Reserved */
} Ifx_PMS_PMSWCR4_Bits;

/** \brief Standby and Wake-up Control Register 5 */
typedef struct _Ifx_PMS_PMSWCR5_Bits
{
    Ifx_UReg_32Bit BPTRISTREQ:1;      /**< \brief [0:0] Bit protection for Tristate request bit (TRISTREQ) - BPTRISTREQ (w) */
    Ifx_UReg_32Bit TRISTREQ:1;        /**< \brief [1:1] Tristate enable - TRISTREQ (rwh) */
    Ifx_UReg_32Bit ESR0TRIST:1;       /**< \brief [2:2] ESR0 Tristate enable - ESR0TRIST (rw) */
    Ifx_UReg_32Bit reserved_3:1;      /**< \brief [3:3] \internal Reserved */
    Ifx_UReg_32Bit PORSTDF:1;         /**< \brief [4:4] PORST Digital Filter enable - PORSTDF (rw) */
    Ifx_UReg_32Bit reserved_5:1;      /**< \brief [5:5] \internal Reserved */
    Ifx_UReg_32Bit DCDCSYNCO:1;       /**< \brief [6:6] DC-DC Synchronisation Output (rw) */
    Ifx_UReg_32Bit reserved_7:25;     /**< \brief [31:7] \internal Reserved */
} Ifx_PMS_PMSWCR5_Bits;

/** \brief Standby and Wake-up Status Register */
typedef struct _Ifx_PMS_PMSWSTAT_Bits
{
    Ifx_UReg_32Bit reserved_0:1;      /**< \brief [0:0] \internal Reserved */
    Ifx_UReg_32Bit HWCFGEVR:2;        /**< \brief [2:1] EVR Hardware Configuration status - HWCFGEVR (rh) */
    Ifx_UReg_32Bit reserved_3:1;      /**< \brief [3:3] \internal Reserved */
    Ifx_UReg_32Bit HWCFG4:1;          /**< \brief [4:4] Hardware Configuration Pin 4 status - HWCFG4 (rh) */
    Ifx_UReg_32Bit HWCFG5:1;          /**< \brief [5:5] Hardware Configuration Pin 5 status - HWCFG5 (rh) */
    Ifx_UReg_32Bit TRIST:1;           /**< \brief [6:6] Pad Tristate / Pull-up status - TRIST (rh) */
    Ifx_UReg_32Bit TESTMODE:1;        /**< \brief [7:7] TESTMODE Pin status - TESTMODE (rh) */
    Ifx_UReg_32Bit ESR0TRIST:1;       /**< \brief [8:8] ESR0 pin status during Standby - ESR0TRIST (rh) */
    Ifx_UReg_32Bit reserved_9:2;      /**< \brief [10:9] \internal Reserved */
    Ifx_UReg_32Bit PORSTDF:1;         /**< \brief [11:11] PORST Digital Filter status - PORSTDF (rh) */
    Ifx_UReg_32Bit reserved_12:4;     /**< \brief [15:12] \internal Reserved */
    Ifx_UReg_32Bit SCR:1;             /**< \brief [16:16] Standby Controller status - SCR (rh) */
    Ifx_UReg_32Bit SCRST:1;           /**< \brief [17:17] Standby Controller Reset Indication flag - SCRST (rh) */
    Ifx_UReg_32Bit SCRCLK:1;          /**< \brief [18:18] Current Clock configuration for SCR before Standby Mode Entry - SCRCLK (rh) */
    Ifx_UReg_32Bit PORSTREQ:1;        /**< \brief [19:19] Standby Controller Reset on warm PORST - PORSTREQ (rh) */
    Ifx_UReg_32Bit reserved_20:4;     /**< \brief [23:20] \internal Reserved */
    Ifx_UReg_32Bit WUTEN:1;           /**< \brief [24:24] WUT Enable status - WUTEN (rh) */
    Ifx_UReg_32Bit WUTRUN:1;          /**< \brief [25:25] WUT Run status - WUTRUN (rh) */
    Ifx_UReg_32Bit WUTMODE:1;         /**< \brief [26:26] WUT Mode status - WUTMODE (rh) */
    Ifx_UReg_32Bit reserved_27:1;     /**< \brief [27:27] \internal Reserved */
    Ifx_UReg_32Bit ESR0INT:1;         /**< \brief [28:28] ESR0 Interrupt flag - ESR0INT (rh) */
    Ifx_UReg_32Bit ESR1INT:1;         /**< \brief [29:29] ESR1 Interrupt flag - ESR1INT (rh) */
    Ifx_UReg_32Bit PINAINT:1;         /**< \brief [30:30] Pin A Interrupt flag - PINAINT (rh) */
    Ifx_UReg_32Bit PINBINT:1;         /**< \brief [31:31] Pin B Interrupt flag - PINBINT (rh) */
} Ifx_PMS_PMSWSTAT_Bits;

/** \brief Standby and Wake-up Status Register 2 */
typedef struct _Ifx_PMS_PMSWSTAT2_Bits
{
    Ifx_UReg_32Bit ESR0WKP:1;         /**< \brief [0:0] ESR0 Wake-up flag - ESR0WKP (rh) */
    Ifx_UReg_32Bit ESR1WKP:1;         /**< \brief [1:1] ESR1 Wake-up flag - ESR1WKP (rh) */
    Ifx_UReg_32Bit PINAWKP:1;         /**< \brief [2:2] Pin Wake-up flag - PINAWKP (rh) */
    Ifx_UReg_32Bit PINBWKP:1;         /**< \brief [3:3] Pin B Wake-up flag - PINBWKP (rh) */
    Ifx_UReg_32Bit PWRWKP:1;          /**< \brief [4:4] Wake-up event on VEXT Supply ramp-up - PWRWKP (rh) */
    Ifx_UReg_32Bit SCRWKP:1;          /**< \brief [5:5] SCR Wake-up flag - SCRWKP (rh) */
    Ifx_UReg_32Bit PORSTWKP:1;        /**< \brief [6:6] PORST Wake-up flag - PORSTWKP (rh) */
    Ifx_UReg_32Bit WUTWKP:1;          /**< \brief [7:7] WUT Wake-up flag - WUTWKP (rh) */
    Ifx_UReg_32Bit ESR0OVRUN:1;       /**< \brief [8:8] ESR0 Overrun status flag - ESR0OVRUN (rh) */
    Ifx_UReg_32Bit ESR1OVRUN:1;       /**< \brief [9:9] ESR1 Overrun status flag - ESR1OVRUN (rh) */
    Ifx_UReg_32Bit PINAOVRUN:1;       /**< \brief [10:10] Pin A Overrun status flag - PINAOVRUN (rh) */
    Ifx_UReg_32Bit PINBOVRUN:1;       /**< \brief [11:11] Pin B Overrun status flag - PINBOVRUN (rh) */
    Ifx_UReg_32Bit VDDSTBYEN:1;       /**< \brief [12:12] Standby Entry Enable status on VDD Supply ramp-down - VDDSTBYWKEN (rh) */
    Ifx_UReg_32Bit SCROVRUN:1;        /**< \brief [13:13] SCR Overrun status flag - SCROVRUN (rh) */
    Ifx_UReg_32Bit PORSTOVRUN:1;      /**< \brief [14:14] PORST Overrun status flag - PORSTOVRUN (rh) */
    Ifx_UReg_32Bit WUTOVRUN:1;        /**< \brief [15:15] WUT Overrun status flag - WUTOVRUN (rh) */
    Ifx_UReg_32Bit STBYRAM:3;         /**< \brief [18:16] Standby RAM Supply status - STBYRAM (rh) */
    Ifx_UReg_32Bit VEXTSTBYEN:1;      /**< \brief [19:19] Standby Entry Enable status on VEXT Supply ramp-down - VEXTSTBYWKEN (rh) */
    Ifx_UReg_32Bit BLNKFIL:4;         /**< \brief [23:20] Blanking Filter Delay for VEXT Supply Wake-up - BLNKFIL (rh) */
    Ifx_UReg_32Bit ESR0WKEN:1;        /**< \brief [24:24] ESR0 Wake-up enable status - ESR0WKEN (rh) */
    Ifx_UReg_32Bit ESR1WKEN:1;        /**< \brief [25:25] ESR1 Wake-up enable status - ESR1WKEN (rh) */
    Ifx_UReg_32Bit PINAWKEN:1;        /**< \brief [26:26] Pin A Wake-up enable status - PINAWKEN (rh) */
    Ifx_UReg_32Bit PINBWKEN:1;        /**< \brief [27:27] Pin B Wake-up enable status - PINBWKEN (rh) */
    Ifx_UReg_32Bit PWRWKEN:1;         /**< \brief [28:28] Standby Wake-up Enable status on VEXT Supply ramp-up - PWRWKEN (rh) */
    Ifx_UReg_32Bit SCRWKEN:1;         /**< \brief [29:29] Standby Controller Wake-up Enable status - SCRWKEN (rh) */
    Ifx_UReg_32Bit PORSTWKEN:1;       /**< \brief [30:30] PORST pin Wake-up enable status from Standby - PORSTWKEN (rh) */
    Ifx_UReg_32Bit WUTWKEN:1;         /**< \brief [31:31] WUT Wake-up enable status - WUTWKEN (rh) */
} Ifx_PMS_PMSWSTAT2_Bits;

/** \brief Standby and Wake-up Status Clear Register */
typedef struct _Ifx_PMS_PMSWSTATCLR_Bits
{
    Ifx_UReg_32Bit ESR0WKPCLR:1;      /**< \brief [0:0] ESR0 Wake-up indication flag clear - ESR0WKPCLR (w) */
    Ifx_UReg_32Bit ESR1WKPCLR:1;      /**< \brief [1:1] ESR1 Wake-up indication flag clear - ESR1WKPCLR (w) */
    Ifx_UReg_32Bit PINAWKPCLR:1;      /**< \brief [2:2] PINA Wake-up indication flag clear - PINAWKPCLR (w) */
    Ifx_UReg_32Bit PINBWKPCLR:1;      /**< \brief [3:3] PINB Wake-up indication flag clear - PINBWKPCLR (w) */
    Ifx_UReg_32Bit PWRWKPCLR:1;       /**< \brief [4:4] PWRWKP Wake-up indication flag clear - PWRWKPCLR (w) */
    Ifx_UReg_32Bit SCRWKPCLR:1;       /**< \brief [5:5] SCR Wake-up indication flag clear - SCRWKPCLR (w) */
    Ifx_UReg_32Bit PORSTWKPCLR:1;     /**< \brief [6:6] PORST Wake-up indication flag clear - PORSTWKPCLR (w) */
    Ifx_UReg_32Bit WUTWKPCLR:1;       /**< \brief [7:7] WUT Wake-up indication flag clear - WUTWKPCLR (w) */
    Ifx_UReg_32Bit ESR0OVRUNCLR:1;    /**< \brief [8:8] ESR0 Overrun status indication flag clear - ESR0OVRUNCLR (w) */
    Ifx_UReg_32Bit ESR1OVRUNCLR:1;    /**< \brief [9:9] ESR1 Overrun status indication flag clear - ESR1OVRUNCLR (w) */
    Ifx_UReg_32Bit PINAOVRUNCLR:1;    /**< \brief [10:10] PINA Overrun status indication flag clear - PINAOVRUNCLR (w) */
    Ifx_UReg_32Bit PINBOVRUNCLR:1;    /**< \brief [11:11] PINB Overrun status indication flag clear - PINBOVRUNCLR (w) */
    Ifx_UReg_32Bit reserved_12:1;     /**< \brief [12:12] \internal Reserved */
    Ifx_UReg_32Bit SCROVRUNCLR:1;     /**< \brief [13:13] SCR Overrun status indication flag clear - SCROVRUNCLR (w) */
    Ifx_UReg_32Bit PORSTOVRUNCLR:1;    /**< \brief [14:14] PORST Overrun status indication flag clear - PORSTOVRUNCLR (w) */
    Ifx_UReg_32Bit WUTOVRUNCLR:1;     /**< \brief [15:15] WUT Overrun status indication flag clear - WUTOVRUNCLR (w) */
    Ifx_UReg_32Bit SCRSTCLR:1;        /**< \brief [16:16] Standby controller SCRST indication flag clear - SCRSTCLR (w) */
    Ifx_UReg_32Bit reserved_17:11;    /**< \brief [27:17] \internal Reserved */
    Ifx_UReg_32Bit ESR0INTCLR:1;      /**< \brief [28:28] ESR0 Interrupt indication flag clear - ESR0INTCLR (w) */
    Ifx_UReg_32Bit ESR1INTCLR:1;      /**< \brief [29:29] ESR1 Interrupt indication flag clear - ESR1INTCLR (w) */
    Ifx_UReg_32Bit PINAINTCLR:1;      /**< \brief [30:30] PINA Interrupt indication flag clear - PINAINTCLR (w) */
    Ifx_UReg_32Bit PINBINTCLR:1;      /**< \brief [31:31] PINB Interrupt indication flag clear - PINBINTCLR (w) */
} Ifx_PMS_PMSWSTATCLR_Bits;

/** \brief Standby WUT Counter Register */
typedef struct _Ifx_PMS_PMSWUTCNT_Bits
{
    Ifx_UReg_32Bit WUTCNT:24;         /**< \brief [23:0] WUT counter value. - WUTCNT (rh) */
    Ifx_UReg_32Bit reserved_24:8;     /**< \brief [31:24] \internal Reserved */
} Ifx_PMS_PMSWUTCNT_Bits;

/** \brief EVR Secondary Under-voltage Monitor Register */
typedef struct _Ifx_PMS_UVMON_Bits
{
    Ifx_UReg_32Bit EVRCUVVAL:8;       /**< \brief [7:0] VDD Supply Secondary Monitor Under-voltage threshold - EVRCUVVAL (rw) */
    Ifx_UReg_32Bit EVR33UVVAL:8;      /**< \brief [15:8] VDDP3 Supply Secondary Monitor Under-voltage threshold - EVR33UVVAL (rw) */
    Ifx_UReg_32Bit SWDUVVAL:8;        /**< \brief [23:16] VEXT Supply Secondary Monitor Under-voltage threshold - SWDUVVAL (rw) */
    Ifx_UReg_32Bit reserved_24:6;     /**< \brief [29:24] \internal Reserved */
    Ifx_UReg_32Bit SLCK:1;            /**< \brief [30:30] HSM Security Lock - SLCK (rw) */
    Ifx_UReg_32Bit reserved_31:1;     /**< \brief [31:31] \internal Reserved */
} Ifx_PMS_UVMON_Bits;

/** \brief EVR Secondary Under-voltage Monitor Register 2 */
typedef struct _Ifx_PMS_UVMON2_Bits
{
    Ifx_UReg_32Bit PREUVVAL:8;        /**< \brief [7:0] VDDPD Supply Secondary Monitor Under-voltage threshold - PREUVVAL (rw) */
    Ifx_UReg_32Bit VDDMUVVAL:8;       /**< \brief [15:8] VDDM Supply Secondary Monitor Under-voltage threshold - VDDMUVVAL (rw) */
    Ifx_UReg_32Bit SBUVVAL:8;         /**< \brief [23:16] VEVRSB Supply Secondary Monitor Under-voltage threshold - SBUVVAL (rw) */
    Ifx_UReg_32Bit VDDMLVLSEL:6;      /**< \brief [29:24] VDDM Level Select - VDDMLVLSEL (rw) */
    Ifx_UReg_32Bit SLCK:1;            /**< \brief [30:30] HSM Security Lock - SLCK (rw) */
    Ifx_UReg_32Bit reserved_31:1;     /**< \brief [31:31] \internal Reserved */
} Ifx_PMS_UVMON2_Bits;

/** \}  */
/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_pms_Registers_union
 * \{   */
/** \brief Access Enable Register 0   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_PMS_ACCEN0_Bits B;            /**< \brief Bitfield access */
} Ifx_PMS_ACCEN0;

/** \brief Access Enable Register 1   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_PMS_ACCEN1_Bits B;            /**< \brief Bitfield access */
} Ifx_PMS_ACCEN1;

/** \brief SMU_stdby FSP Configuration Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_PMS_AGFSP_STDBY0_Bits B;      /**< \brief Bitfield access */
} Ifx_PMS_AGFSP_STDBY0;

/** \brief SMU_stdby FSP Configuration Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_PMS_AGFSP_STDBY1_Bits B;      /**< \brief Bitfield access */
} Ifx_PMS_AGFSP_STDBY1;

/** \brief Alarm Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_PMS_AG_STDBY0_Bits B;         /**< \brief Bitfield access */
} Ifx_PMS_AG_STDBY0;

/** \brief Alarm Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_PMS_AG_STDBY1_Bits B;         /**< \brief Bitfield access */
} Ifx_PMS_AG_STDBY1;

/** \brief SMU_stdby Command Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_PMS_CMD_STDBY_Bits B;         /**< \brief Bitfield access */
} Ifx_PMS_CMD_STDBY;

/** \brief Die Temperature Sensor Limit Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_PMS_DTSLIM_Bits B;            /**< \brief Bitfield access */
} Ifx_PMS_DTSLIM;

/** \brief Die Temperature Sensor Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_PMS_DTSSTAT_Bits B;           /**< \brief Bitfield access */
} Ifx_PMS_DTSSTAT;

/** \brief EVR33 Control Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_PMS_EVR33CON_Bits B;          /**< \brief Bitfield access */
} Ifx_PMS_EVR33CON;

/** \brief EVR Primary ADC Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_PMS_EVRADCSTAT_Bits B;        /**< \brief Bitfield access */
} Ifx_PMS_EVRADCSTAT;

/** \brief EVR Oscillator Control Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_PMS_EVROSCCTRL_Bits B;        /**< \brief Bitfield access */
} Ifx_PMS_EVROSCCTRL;

/** \brief EVR Reset Control Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_PMS_EVRRSTCON_Bits B;         /**< \brief Bitfield access */
} Ifx_PMS_EVRRSTCON;

/** \brief EVR Reset Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_PMS_EVRRSTSTAT_Bits B;        /**< \brief Bitfield access */
} Ifx_PMS_EVRRSTSTAT;

/** \brief EVRC SD Coefficient Register 0   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_PMS_EVRSDCOEFF0_Bits B;       /**< \brief Bitfield access */
} Ifx_PMS_EVRSDCOEFF0;

/** \brief EVRC SD Coefficient Register 1   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_PMS_EVRSDCOEFF1_Bits B;       /**< \brief Bitfield access */
} Ifx_PMS_EVRSDCOEFF1;

/** \brief EVRC SD Coefficient Register 2   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_PMS_EVRSDCOEFF2_Bits B;       /**< \brief Bitfield access */
} Ifx_PMS_EVRSDCOEFF2;

/** \brief EVRC SD Coefficient Register 3   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_PMS_EVRSDCOEFF3_Bits B;       /**< \brief Bitfield access */
} Ifx_PMS_EVRSDCOEFF3;

/** \brief EVRC SD Coefficient Register 4   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_PMS_EVRSDCOEFF4_Bits B;       /**< \brief Bitfield access */
} Ifx_PMS_EVRSDCOEFF4;

/** \brief EVRC SD Coefficient Register 5   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_PMS_EVRSDCOEFF5_Bits B;       /**< \brief Bitfield access */
} Ifx_PMS_EVRSDCOEFF5;

/** \brief EVRC SD Coefficient Register 6   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_PMS_EVRSDCOEFF6_Bits B;       /**< \brief Bitfield access */
} Ifx_PMS_EVRSDCOEFF6;

/** \brief EVRC SD Coefficient Register 7   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_PMS_EVRSDCOEFF7_Bits B;       /**< \brief Bitfield access */
} Ifx_PMS_EVRSDCOEFF7;

/** \brief EVRC SD Coefficient Register 8   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_PMS_EVRSDCOEFF8_Bits B;       /**< \brief Bitfield access */
} Ifx_PMS_EVRSDCOEFF8;

/** \brief EVRC SD Coefficient Register 9   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_PMS_EVRSDCOEFF9_Bits B;       /**< \brief Bitfield access */
} Ifx_PMS_EVRSDCOEFF9;

/** \brief EVRC SD Control Register 0   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_PMS_EVRSDCTRL0_Bits B;        /**< \brief Bitfield access */
} Ifx_PMS_EVRSDCTRL0;

/** \brief EVRC SD Control Register 1   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_PMS_EVRSDCTRL1_Bits B;        /**< \brief Bitfield access */
} Ifx_PMS_EVRSDCTRL1;

/** \brief EVRC SD Control Register 10   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_PMS_EVRSDCTRL10_Bits B;       /**< \brief Bitfield access */
} Ifx_PMS_EVRSDCTRL10;

/** \brief EVRC SD Control Register 11   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_PMS_EVRSDCTRL11_Bits B;       /**< \brief Bitfield access */
} Ifx_PMS_EVRSDCTRL11;

/** \brief EVRC SD Control Register 2   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_PMS_EVRSDCTRL2_Bits B;        /**< \brief Bitfield access */
} Ifx_PMS_EVRSDCTRL2;

/** \brief EVRC SD Control Register 3   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_PMS_EVRSDCTRL3_Bits B;        /**< \brief Bitfield access */
} Ifx_PMS_EVRSDCTRL3;

/** \brief EVRC SD Control Register 4   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_PMS_EVRSDCTRL4_Bits B;        /**< \brief Bitfield access */
} Ifx_PMS_EVRSDCTRL4;

/** \brief EVRC SD Control Register 5   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_PMS_EVRSDCTRL5_Bits B;        /**< \brief Bitfield access */
} Ifx_PMS_EVRSDCTRL5;

/** \brief EVRC SD Control Register 6   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_PMS_EVRSDCTRL6_Bits B;        /**< \brief Bitfield access */
} Ifx_PMS_EVRSDCTRL6;

/** \brief EVRC SD Control Register 7   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_PMS_EVRSDCTRL7_Bits B;        /**< \brief Bitfield access */
} Ifx_PMS_EVRSDCTRL7;

/** \brief EVRC SD Control Register 8   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_PMS_EVRSDCTRL8_Bits B;        /**< \brief Bitfield access */
} Ifx_PMS_EVRSDCTRL8;

/** \brief EVRC SD Control Register 9   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_PMS_EVRSDCTRL9_Bits B;        /**< \brief Bitfield access */
} Ifx_PMS_EVRSDCTRL9;

/** \brief EVR SD Status Register 0   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_PMS_EVRSDSTAT0_Bits B;        /**< \brief Bitfield access */
} Ifx_PMS_EVRSDSTAT0;

/** \brief EVR Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_PMS_EVRSTAT_Bits B;           /**< \brief Bitfield access */
} Ifx_PMS_EVRSTAT;

/** \brief EVR Trim Control Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_PMS_EVRTRIM_Bits B;           /**< \brief Bitfield access */
} Ifx_PMS_EVRTRIM;

/** \brief EVR Trim Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_PMS_EVRTRIMSTAT_Bits B;       /**< \brief Bitfield access */
} Ifx_PMS_EVRTRIMSTAT;

/** \brief EVR Primary HSM Over-voltage Monitor Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_PMS_HSMOVMON_Bits B;          /**< \brief Bitfield access */
} Ifx_PMS_HSMOVMON;

/** \brief EVR Primary HSM Under-voltage Monitor Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_PMS_HSMUVMON_Bits B;          /**< \brief Bitfield access */
} Ifx_PMS_HSMUVMON;

/** \brief Identification Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_PMS_ID_Bits B;                /**< \brief Bitfield access */
} Ifx_PMS_ID;

/** \brief SMU_stdby BIST Control Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_PMS_MONBISTCTRL_Bits B;       /**< \brief Bitfield access */
} Ifx_PMS_MONBISTCTRL;

/** \brief SMU_stdby BIST Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_PMS_MONBISTSTAT_Bits B;       /**< \brief Bitfield access */
} Ifx_PMS_MONBISTSTAT;

/** \brief EVR Secondary Monitor Control Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_PMS_MONCTRL_Bits B;           /**< \brief Bitfield access */
} Ifx_PMS_MONCTRL;

/** \brief EVR Secondary Monitor Filter Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_PMS_MONFILT_Bits B;           /**< \brief Bitfield access */
} Ifx_PMS_MONFILT;

/** \brief EVR Secondary ADC Status Register 1   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_PMS_MONSTAT1_Bits B;          /**< \brief Bitfield access */
} Ifx_PMS_MONSTAT1;

/** \brief EVR Secondary ADC Status Register 2   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_PMS_MONSTAT2_Bits B;          /**< \brief Bitfield access */
} Ifx_PMS_MONSTAT2;

/** \brief OCDS Trigger Set Control 0 Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_PMS_OTSC0_Bits B;             /**< \brief Bitfield access */
} Ifx_PMS_OTSC0;

/** \brief OCDS Trigger Set Control 1 Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_PMS_OTSC1_Bits B;             /**< \brief Bitfield access */
} Ifx_PMS_OTSC1;

/** \brief OCDS Trigger Set Select Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_PMS_OTSS_Bits B;              /**< \brief Bitfield access */
} Ifx_PMS_OTSS;

/** \brief EVR Secondary Over-voltage Monitor Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_PMS_OVMON_Bits B;             /**< \brief Bitfield access */
} Ifx_PMS_OVMON;

/** \brief EVR Secondary Over-voltage Monitor Register 2   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_PMS_OVMON2_Bits B;            /**< \brief Bitfield access */
} Ifx_PMS_OVMON2;

/** \brief PMS Interrupt Enable Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_PMS_PMSIEN_Bits B;            /**< \brief Bitfield access */
} Ifx_PMS_PMSIEN;

/** \brief Standby and Wake-up Control Register 0   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_PMS_PMSWCR0_Bits B;           /**< \brief Bitfield access */
} Ifx_PMS_PMSWCR0;

/** \brief Standby and Wake-up Control Register 2   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_PMS_PMSWCR2_Bits B;           /**< \brief Bitfield access */
} Ifx_PMS_PMSWCR2;

/** \brief Standby and Wake-up Control Register 3   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_PMS_PMSWCR3_Bits B;           /**< \brief Bitfield access */
} Ifx_PMS_PMSWCR3;

/** \brief Standby and Wake-up Control Register 4   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_PMS_PMSWCR4_Bits B;           /**< \brief Bitfield access */
} Ifx_PMS_PMSWCR4;

/** \brief Standby and Wake-up Control Register 5   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_PMS_PMSWCR5_Bits B;           /**< \brief Bitfield access */
} Ifx_PMS_PMSWCR5;

/** \brief Standby and Wake-up Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_PMS_PMSWSTAT_Bits B;          /**< \brief Bitfield access */
} Ifx_PMS_PMSWSTAT;

/** \brief Standby and Wake-up Status Register 2   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_PMS_PMSWSTAT2_Bits B;         /**< \brief Bitfield access */
} Ifx_PMS_PMSWSTAT2;

/** \brief Standby and Wake-up Status Clear Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_PMS_PMSWSTATCLR_Bits B;       /**< \brief Bitfield access */
} Ifx_PMS_PMSWSTATCLR;

/** \brief Standby WUT Counter Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_PMS_PMSWUTCNT_Bits B;         /**< \brief Bitfield access */
} Ifx_PMS_PMSWUTCNT;

/** \brief EVR Secondary Under-voltage Monitor Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_PMS_UVMON_Bits B;             /**< \brief Bitfield access */
} Ifx_PMS_UVMON;

/** \brief EVR Secondary Under-voltage Monitor Register 2   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_PMS_UVMON2_Bits B;            /**< \brief Bitfield access */
} Ifx_PMS_UVMON2;

/** \}  */

/******************************************************************************/
/** \addtogroup IfxSfr_Pms_Registers_struct
 * \{  */
/******************************************************************************/
/** \name Object L0
 * \{  */

/** \brief PMS object */
typedef volatile struct _Ifx_PMS
{
       Ifx_UReg_8Bit                       reserved_0[8];          /**< \brief 0, \internal Reserved */
       Ifx_PMS_ID                          ID;                     /**< \brief 8, Identification Register*/
       Ifx_UReg_8Bit                       reserved_C[32];         /**< \brief C, \internal Reserved */
       Ifx_PMS_EVRSTAT                     EVRSTAT;                /**< \brief 2C, EVR Status Register*/
       Ifx_UReg_8Bit                       reserved_30[4];         /**< \brief 30, \internal Reserved */
       Ifx_PMS_EVRADCSTAT                  EVRADCSTAT;             /**< \brief 34, EVR Primary ADC Status Register*/
       Ifx_UReg_8Bit                       reserved_38[4];         /**< \brief 38, \internal Reserved */
       Ifx_PMS_EVRRSTCON                   EVRRSTCON;              /**< \brief 3C, EVR Reset Control Register*/
       Ifx_UReg_8Bit                       reserved_40[4];         /**< \brief 40, \internal Reserved */
       Ifx_PMS_EVRRSTSTAT                  EVRRSTSTAT;             /**< \brief 44, EVR Reset Status Register*/
       Ifx_UReg_8Bit                       reserved_48[4];         /**< \brief 48, \internal Reserved */
       Ifx_PMS_EVRTRIM                     EVRTRIM;                /**< \brief 4C, EVR Trim Control Register*/
       Ifx_PMS_EVRTRIMSTAT                 EVRTRIMSTAT;            /**< \brief 50, EVR Trim Status Register*/
       Ifx_UReg_8Bit                       reserved_54[12];        /**< \brief 54, \internal Reserved */
       Ifx_PMS_MONSTAT1                    MONSTAT1;               /**< \brief 60, EVR Secondary ADC Status Register 1*/
       Ifx_PMS_MONSTAT2                    MONSTAT2;               /**< \brief 64, EVR Secondary ADC Status Register 2*/
       Ifx_PMS_MONCTRL                     MONCTRL;                /**< \brief 68, EVR Secondary Monitor Control Register*/
       Ifx_UReg_8Bit                       reserved_6C[4];         /**< \brief 6C, \internal Reserved */
       Ifx_PMS_MONFILT                     MONFILT;                /**< \brief 70, EVR Secondary Monitor Filter Register*/
       Ifx_PMS_PMSIEN                      PMSIEN;                 /**< \brief 74, PMS Interrupt Enable Register*/
       Ifx_PMS_UVMON                       UVMON;                  /**< \brief 78, EVR Secondary Under-voltage Monitor Register*/
       Ifx_PMS_OVMON                       OVMON;                  /**< \brief 7C, EVR Secondary Over-voltage Monitor Register*/
       Ifx_PMS_UVMON2                      UVMON2;                 /**< \brief 80, EVR Secondary Under-voltage Monitor Register 2*/
       Ifx_PMS_OVMON2                      OVMON2;                 /**< \brief 84, EVR Secondary Over-voltage Monitor Register 2*/
       Ifx_PMS_HSMUVMON                    HSMUVMON;               /**< \brief 88, EVR Primary HSM Under-voltage Monitor Register*/
       Ifx_PMS_HSMOVMON                    HSMOVMON;               /**< \brief 8C, EVR Primary HSM Over-voltage Monitor Register*/
       Ifx_PMS_EVR33CON                    EVR33CON;               /**< \brief 90, EVR33 Control Register*/
       Ifx_UReg_8Bit                       reserved_94[12];        /**< \brief 94, \internal Reserved */
       Ifx_PMS_EVROSCCTRL                  EVROSCCTRL;             /**< \brief A0, EVR Oscillator Control Register*/
       Ifx_UReg_8Bit                       reserved_A4[16];        /**< \brief A4, \internal Reserved */
       Ifx_PMS_PMSWCR0                     PMSWCR0;                /**< \brief B4, Standby and Wake-up Control Register 0*/
       Ifx_PMS_PMSWCR2                     PMSWCR2;                /**< \brief B8, Standby and Wake-up Control Register 2*/
       Ifx_UReg_8Bit                       reserved_BC[4];         /**< \brief BC, \internal Reserved */
       Ifx_PMS_PMSWCR3                     PMSWCR3;                /**< \brief C0, Standby and Wake-up Control Register 3*/
       Ifx_PMS_PMSWCR4                     PMSWCR4;                /**< \brief C4, Standby and Wake-up Control Register 4*/
       Ifx_PMS_PMSWCR5                     PMSWCR5;                /**< \brief C8, Standby and Wake-up Control Register 5*/
       Ifx_UReg_8Bit                       reserved_CC[8];         /**< \brief CC, \internal Reserved */
       Ifx_PMS_PMSWSTAT                    PMSWSTAT;               /**< \brief D4, Standby and Wake-up Status Register*/
       Ifx_PMS_PMSWSTAT2                   PMSWSTAT2;              /**< \brief D8, Standby and Wake-up Status Register 2*/
       Ifx_PMS_PMSWUTCNT                   PMSWUTCNT;              /**< \brief DC, Standby WUT Counter Register*/
       Ifx_UReg_8Bit                       reserved_E0[8];         /**< \brief E0, \internal Reserved */
       Ifx_PMS_PMSWSTATCLR                 PMSWSTATCLR;            /**< \brief E8, Standby and Wake-up Status Clear Register*/
       Ifx_UReg_8Bit                       reserved_EC[16];        /**< \brief EC, \internal Reserved */
       Ifx_PMS_EVRSDSTAT0                  EVRSDSTAT0;             /**< \brief FC, EVR SD Status Register 0*/
       Ifx_UReg_8Bit                       reserved_100[8];        /**< \brief 100, \internal Reserved */
       Ifx_PMS_EVRSDCTRL0                  EVRSDCTRL0;             /**< \brief 108, EVRC SD Control Register 0*/
       Ifx_PMS_EVRSDCTRL1                  EVRSDCTRL1;             /**< \brief 10C, EVRC SD Control Register 1*/
       Ifx_PMS_EVRSDCTRL2                  EVRSDCTRL2;             /**< \brief 110, EVRC SD Control Register 2*/
       Ifx_PMS_EVRSDCTRL3                  EVRSDCTRL3;             /**< \brief 114, EVRC SD Control Register 3*/
       Ifx_PMS_EVRSDCTRL4                  EVRSDCTRL4;             /**< \brief 118, EVRC SD Control Register 4*/
       Ifx_PMS_EVRSDCTRL5                  EVRSDCTRL5;             /**< \brief 11C, EVRC SD Control Register 5*/
       Ifx_PMS_EVRSDCTRL6                  EVRSDCTRL6;             /**< \brief 120, EVRC SD Control Register 6*/
       Ifx_PMS_EVRSDCTRL7                  EVRSDCTRL7;             /**< \brief 124, EVRC SD Control Register 7*/
       Ifx_PMS_EVRSDCTRL8                  EVRSDCTRL8;             /**< \brief 128, EVRC SD Control Register 8*/
       Ifx_PMS_EVRSDCTRL9                  EVRSDCTRL9;             /**< \brief 12C, EVRC SD Control Register 9*/
       Ifx_PMS_EVRSDCTRL10                 EVRSDCTRL10;            /**< \brief 130, EVRC SD Control Register 10*/
       Ifx_PMS_EVRSDCTRL11                 EVRSDCTRL11;            /**< \brief 134, EVRC SD Control Register 11*/
       Ifx_UReg_8Bit                       reserved_138[16];       /**< \brief 138, \internal Reserved */
       Ifx_PMS_EVRSDCOEFF0                 EVRSDCOEFF0;            /**< \brief 148, EVRC SD Coefficient Register 0*/
       Ifx_PMS_EVRSDCOEFF1                 EVRSDCOEFF1;            /**< \brief 14C, EVRC SD Coefficient Register 1*/
       Ifx_PMS_EVRSDCOEFF2                 EVRSDCOEFF2;            /**< \brief 150, EVRC SD Coefficient Register 2*/
       Ifx_PMS_EVRSDCOEFF3                 EVRSDCOEFF3;            /**< \brief 154, EVRC SD Coefficient Register 3*/
       Ifx_PMS_EVRSDCOEFF4                 EVRSDCOEFF4;            /**< \brief 158, EVRC SD Coefficient Register 4*/
       Ifx_PMS_EVRSDCOEFF5                 EVRSDCOEFF5;            /**< \brief 15C, EVRC SD Coefficient Register 5*/
       Ifx_PMS_EVRSDCOEFF6                 EVRSDCOEFF6;            /**< \brief 160, EVRC SD Coefficient Register 6*/
       Ifx_PMS_EVRSDCOEFF7                 EVRSDCOEFF7;            /**< \brief 164, EVRC SD Coefficient Register 7*/
       Ifx_PMS_EVRSDCOEFF8                 EVRSDCOEFF8;            /**< \brief 168, EVRC SD Coefficient Register 8*/
       Ifx_PMS_EVRSDCOEFF9                 EVRSDCOEFF9;            /**< \brief 16C, EVRC SD Coefficient Register 9*/
       Ifx_UReg_8Bit                       reserved_170[24];       /**< \brief 170, \internal Reserved */
       Ifx_PMS_AG_STDBY0                   AG_STDBY0;              /**< \brief 188, Alarm Status Register*/
       Ifx_PMS_AG_STDBY1                   AG_STDBY1;              /**< \brief 18C, Alarm Status Register*/
       Ifx_PMS_MONBISTSTAT                 MONBISTSTAT;            /**< \brief 190, SMU_stdby BIST Status Register*/
       Ifx_UReg_8Bit                       reserved_194[4];        /**< \brief 194, \internal Reserved */
       Ifx_PMS_MONBISTCTRL                 MONBISTCTRL;            /**< \brief 198, SMU_stdby BIST Control Register*/
       Ifx_PMS_CMD_STDBY                   CMD_STDBY;              /**< \brief 19C, SMU_stdby Command Register*/
       Ifx_UReg_8Bit                       reserved_1A0[4];        /**< \brief 1A0, \internal Reserved */
       Ifx_PMS_AGFSP_STDBY0                AGFSP_STDBY0;           /**< \brief 1A4, SMU_stdby FSP Configuration Register*/
       Ifx_PMS_AGFSP_STDBY1                AGFSP_STDBY1;           /**< \brief 1A8, SMU_stdby FSP Configuration Register*/
       Ifx_UReg_8Bit                       reserved_1AC[20];       /**< \brief 1AC, \internal Reserved */
       Ifx_PMS_DTSSTAT                     DTSSTAT;                /**< \brief 1C0, Die Temperature Sensor Status Register*/
       Ifx_UReg_8Bit                       reserved_1C4[4];        /**< \brief 1C4, \internal Reserved */
       Ifx_PMS_DTSLIM                      DTSLIM;                 /**< \brief 1C8, Die Temperature Sensor Limit Register*/
       Ifx_UReg_8Bit                       reserved_1CC[20];       /**< \brief 1CC, \internal Reserved */
       Ifx_PMS_OTSS                        OTSS;                   /**< \brief 1E0, OCDS Trigger Set Select Register*/
       Ifx_PMS_OTSC0                       OTSC0;                  /**< \brief 1E4, OCDS Trigger Set Control 0 Register*/
       Ifx_PMS_OTSC1                       OTSC1;                  /**< \brief 1E8, OCDS Trigger Set Control 1 Register*/
       Ifx_UReg_8Bit                       reserved_1EC[12];       /**< \brief 1EC, \internal Reserved */
       Ifx_PMS_ACCEN1                      ACCEN1;                 /**< \brief 1F8, Access Enable Register 1*/
       Ifx_PMS_ACCEN0                      ACCEN0;                 /**< \brief 1FC, Access Enable Register 0*/
} Ifx_PMS;

/** \}  */
/******************************************************************************/
/** \}  */


/******************************************************************************/

/******************************************************************************/


#line 57 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\Infra\\Sfr\\TC38A\\_Reg\\IfxPms_reg.h"
/******************************************************************************/

/******************************************************************************/

/******************************************************************************/

/** \addtogroup IfxSfr_Pms_Registers_Cfg_BaseAddress
 * \{  */

/** \brief PMS object */

/** \}  */


/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Pms_Registers_Cfg_Pms
 * \{  */
/** \brief 0, Standby Controller Extension RAM */


/** \brief 8, Identification Register */


/** \brief 2C, EVR Status Register */


/** \brief 34, EVR Primary ADC Status Register */


/** \brief 3C, EVR Reset Control Register */


/** \brief 44, EVR Reset Status Register */


/** \brief 4C, EVR Trim Control Register */


/** \brief 50, EVR Trim Status Register */


/** \brief 60, EVR Secondary ADC Status Register 1 */

/** Alias (User Manual Name) for PMS_MONSTAT1.
* To use register names with standard convension, please use PMS_MONSTAT1.
*/


/** \brief 64, EVR Secondary ADC Status Register 2 */

/** Alias (User Manual Name) for PMS_MONSTAT2.
* To use register names with standard convension, please use PMS_MONSTAT2.
*/


/** \brief 68, EVR Secondary Monitor Control Register */

/** Alias (User Manual Name) for PMS_MONCTRL.
* To use register names with standard convension, please use PMS_MONCTRL.
*/


/** \brief 70, EVR Secondary Monitor Filter Register */

/** Alias (User Manual Name) for PMS_MONFILT.
* To use register names with standard convension, please use PMS_MONFILT.
*/


/** \brief 74, PMS Interrupt Enable Register */


/** \brief 78, EVR Secondary Under-voltage Monitor Register */

/** Alias (User Manual Name) for PMS_UVMON.
* To use register names with standard convension, please use PMS_UVMON.
*/


/** \brief 7C, EVR Secondary Over-voltage Monitor Register */

/** Alias (User Manual Name) for PMS_OVMON.
* To use register names with standard convension, please use PMS_OVMON.
*/


/** \brief 80, EVR Secondary Under-voltage Monitor Register 2 */

/** Alias (User Manual Name) for PMS_UVMON2.
* To use register names with standard convension, please use PMS_UVMON2.
*/


/** \brief 84, EVR Secondary Over-voltage Monitor Register 2 */

/** Alias (User Manual Name) for PMS_OVMON2.
* To use register names with standard convension, please use PMS_OVMON2.
*/


/** \brief 88, EVR Primary HSM Under-voltage Monitor Register */


/** \brief 8C, EVR Primary HSM Over-voltage Monitor Register */


/** \brief 90, EVR33 Control Register */


/** \brief A0, EVR Oscillator Control Register */


/** \brief B4, Standby and Wake-up Control Register 0 */


/** \brief B8, Standby and Wake-up Control Register 2 */


/** \brief C0, Standby and Wake-up Control Register 3 */


/** \brief C4, Standby and Wake-up Control Register 4 */


/** \brief C8, Standby and Wake-up Control Register 5 */


/** \brief D4, Standby and Wake-up Status Register */


/** \brief D8, Standby and Wake-up Status Register 2 */


/** \brief DC, Standby WUT Counter Register */


/** \brief E8, Standby and Wake-up Status Clear Register */


/** \brief FC, EVR SD Status Register 0 */


/** \brief 108, EVRC SD Control Register 0 */


/** \brief 10C, EVRC SD Control Register 1 */


/** \brief 110, EVRC SD Control Register 2 */


/** \brief 114, EVRC SD Control Register 3 */


/** \brief 118, EVRC SD Control Register 4 */


/** \brief 11C, EVRC SD Control Register 5 */


/** \brief 120, EVRC SD Control Register 6 */


/** \brief 124, EVRC SD Control Register 7 */


/** \brief 128, EVRC SD Control Register 8 */


/** \brief 12C, EVRC SD Control Register 9 */


/** \brief 130, EVRC SD Control Register 10 */


/** \brief 134, EVRC SD Control Register 11 */


/** \brief 148, EVRC SD Coefficient Register 0 */


/** \brief 14C, EVRC SD Coefficient Register 1 */


/** \brief 150, EVRC SD Coefficient Register 2 */


/** \brief 154, EVRC SD Coefficient Register 3 */


/** \brief 158, EVRC SD Coefficient Register 4 */


/** \brief 15C, EVRC SD Coefficient Register 5 */


/** \brief 160, EVRC SD Coefficient Register 6 */


/** \brief 164, EVRC SD Coefficient Register 7 */


/** \brief 168, EVRC SD Coefficient Register 8 */


/** \brief 16C, EVRC SD Coefficient Register 9 */


/** \brief 188, Alarm Status Register */

/** Alias (User Manual Name) for PMS_AG_STDBY0.
* To use register names with standard convension, please use PMS_AG_STDBY0.
*/


/** \brief 18C, Alarm Status Register */

/** Alias (User Manual Name) for PMS_AG_STDBY1.
* To use register names with standard convension, please use PMS_AG_STDBY1.
*/


/** \brief 190, SMU_stdby BIST Status Register */


/** \brief 198, SMU_stdby BIST Control Register */


/** \brief 19C, SMU_stdby Command Register */


/** \brief 1A4, SMU_stdby FSP Configuration Register */

/** Alias (User Manual Name) for PMS_AGFSP_STDBY0.
* To use register names with standard convension, please use PMS_AGFSP_STDBY0.
*/


/** \brief 1A8, SMU_stdby FSP Configuration Register */

/** Alias (User Manual Name) for PMS_AGFSP_STDBY1.
* To use register names with standard convension, please use PMS_AGFSP_STDBY1.
*/


/** \brief 1C0, Die Temperature Sensor Status Register */


/** \brief 1C8, Die Temperature Sensor Limit Register */


/** \brief 1E0, OCDS Trigger Set Select Register */


/** \brief 1E4, OCDS Trigger Set Control 0 Register */


/** \brief 1E8, OCDS Trigger Set Control 1 Register */


/** \brief 1F8, Access Enable Register 1 */


/** \brief 1FC, Access Enable Register 0 */



/** \}  */

/******************************************************************************/

/******************************************************************************/


#line 71 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Pms\\Std\\IfxPmsEvr.h"



/******************************************************************************/
/*-----------------------------------Macros-----------------------------------*/
/******************************************************************************/









/******************************************************************************/
/*--------------------------------Enumerations--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Pms_Std_Evr_Enum
 * \{ */
/** \brief Configure respective interrupts define in register Ifx_PMS.PMSIEN
 */
typedef enum
{
    IfxPmsEvr_EnableInterrupt_ovswd   = 0,   /**< \brief OVSWD Interrupt enable */
    IfxPmsEvr_EnableInterrupt_uvswd   = 1,   /**< \brief UVSWD Interrupt enable */
    IfxPmsEvr_EnableInterrupt_ov33    = 2,   /**< \brief OV33Interrupt enable */
    IfxPmsEvr_EnableInterrupt_uv33    = 3,   /**< \brief UV33 Interrupt enable */
    IfxPmsEvr_EnableInterrupt_ovc     = 4,   /**< \brief OVC Interrupt enable */
    IfxPmsEvr_EnableInterrupt_uvc     = 5,   /**< \brief UVC Interrupt enable */
    IfxPmsEvr_EnableInterrupt_ovpre   = 6,   /**< \brief OVPRE Interrupt enable */
    IfxPmsEvr_EnableInterrupt_uvpre   = 7,   /**< \brief UVPRE Interrupt enable */
    IfxPmsEvr_EnableInterrupt_ovddm   = 8,   /**< \brief OVDDM Interrupt enable */
    IfxPmsEvr_EnableInterrupt_uvddm   = 9,   /**< \brief UVDDM Interrupt enable */
    IfxPmsEvr_EnableInterrupt_ovsb    = 10,  /**< \brief OVSB Interrupt enable */
    IfxPmsEvr_EnableInterrupt_uvsb    = 11,  /**< \brief UVSB Interrupt enable */
    IfxPmsEvr_EnableInterrupt_evrcmod = 16,  /**< \brief EVRCMOD Interrupt enable */
    IfxPmsEvr_EnableInterrupt_sdvok   = 17,  /**< \brief SDVOK Interrupt enable */
    IfxPmsEvr_EnableInterrupt_synclck = 18,  /**< \brief SD SYNCLCK Interrupt enable */
    IfxPmsEvr_EnableInterrupt_swdlvl  = 19,  /**< \brief SWDLVL Interrupt enable */
    IfxPmsEvr_EnableInterrupt_wutwkp  = 21,  /**< \brief WUT WKP Interrupt enable */
    IfxPmsEvr_EnableInterrupt_esr0wkp = 22,  /**< \brief ESR0 WKP Interrupt enable */
    IfxPmsEvr_EnableInterrupt_esr1wkp = 23,  /**< \brief ESR1 WKP Interrupt enable */
    IfxPmsEvr_EnableInterrupt_pinawkp = 24,  /**< \brief PINA WKP Interrupt enable */
    IfxPmsEvr_EnableInterrupt_pinbwkp = 25,  /**< \brief PINB WKP Interrupt enable */
    IfxPmsEvr_EnableInterrupt_scrint  = 26,  /**< \brief SCR INT Interrupt enable */
    IfxPmsEvr_EnableInterrupt_scrrst  = 27,  /**< \brief SCR RST Interrupt enable */
    IfxPmsEvr_EnableInterrupt_screcc  = 28,  /**< \brief SCR ECC Interrupt enable */
    IfxPmsEvr_EnableInterrupt_scrwdt  = 29   /**< \brief SCR WDT Interrupt enable */
} IfxPmsEvr_EnableInterrupt;

/** \brief Current operation mode of EVRC Regulator defined in Ifx_PMS.EVR.STAT.B.EVRCMOD
 */
typedef enum
{
    IfxPmsEvr_EvrcMode_pwmMode      = 0,  /**< \brief The step-down converter is in
                                          * normal operational closed loop state */
    IfxPmsEvr_EvrcMode_lowPowerMode = 1,  /**< \brief The step-down converter is in low
                                           * power state */
    IfxPmsEvr_EvrcMode_startupMode  = 2,  /**< \brief The step-down converter is in start-up
                                           * phase */
    IfxPmsEvr_EvrcMode_disableMode  = 3   /**< \brief EVRC is Disable */
} IfxPmsEvr_EvrcMode;

/** \brief Switching frequency division factor for external synchronisation defined in Ifx_PMS.EVRSDCTRL7.B.SYNCDIVFAC
 */
typedef enum
{
    IfxPmsEvr_ExtSyncSwitchingFreqDivFactor_1  = 0,  /**< \brief fDCDCSYNC = fDCDC. The actual duty cycle is routed. */
    IfxPmsEvr_ExtSyncSwitchingFreqDivFactor_2  = 1,  /**< \brief fDCDCSYNC = fDCDC/2. Duty cycle is constant at 50%. */
    IfxPmsEvr_ExtSyncSwitchingFreqDivFactor_4  = 2,  /**< \brief fDCDCSYNC = fDCDC/4. Duty cycle is constant at 50%. */
    IfxPmsEvr_ExtSyncSwitchingFreqDivFactor_8  = 3,  /**< \brief fDCDCSYNC = fDCDC/8. Duty cycle is constant at 50%. */
    IfxPmsEvr_ExtSyncSwitchingFreqDivFactor_16 = 4,  /**< \brief fDCDCSYNC = fDCDC/16. Duty cycle is constant at 50%. */
    IfxPmsEvr_ExtSyncSwitchingFreqDivFactor_32 = 5   /**< \brief fDCDCSYNC = fDCDC/32. Duty cycle is constant at 50%. */
} IfxPmsEvr_ExtSyncSwitchingFreqDivFactor;

/** \brief Monitoring OverVoltage for all bitfields defined
 * in .Ifx_PMS.EVR.MONCTRL register for overvoltage monitoring
 */
typedef enum
{
    IfxPmsEvr_OverVoltageMonitoring_inactive                         = 0, /**< \brief Over-Voltage Monitoring inactive */
    IfxPmsEvr_OverVoltageMonitoring_lowToHighVoltageTransition       = 1, /**< \brief Over-Voltage event is generated when threshold is crossed in lower to higher voltage transition */
    IfxPmsEvr_OverVoltageMonitoring_highToLowVoltageTransition       = 2, /**< \brief Over-Voltage event is generated when threshold is crossed in higher to lower voltage transition */
    IfxPmsEvr_OverVoltageMonitoring_eitherDirectionVoltageTransition = 3  /**< \brief Over-Voltage event is generated when threshold is crossed in either direction */
} IfxPmsEvr_OverVoltageMonitoring;

/** \brief set TRIM Value For respective Voltages.
 * Defined in Ifx_PMS.EVR.TRIM and Ifx_PMS.EVR.TRIM2
 */
typedef enum
{
    IfxPmsEvr_PrimaryAdcTrimValue_0 = 0,      /**< \brief Primary Adc Trim Value 0  */
    IfxPmsEvr_PrimaryAdcTrimValue_1,          /**< \brief Primary Adc Trim Value 1  */
    IfxPmsEvr_PrimaryAdcTrimValue_2,          /**< \brief Primary Adc Trim Value 2  */
    IfxPmsEvr_PrimaryAdcTrimValue_3,          /**< \brief Primary Adc Trim Value 3  */
    IfxPmsEvr_PrimaryAdcTrimValue_4,          /**< \brief Primary Adc Trim Value 4  */
    IfxPmsEvr_PrimaryAdcTrimValue_5,          /**< \brief Primary Adc Trim Value 5  */
    IfxPmsEvr_PrimaryAdcTrimValue_6,          /**< \brief Primary Adc Trim Value 6  */
    IfxPmsEvr_PrimaryAdcTrimValue_7,          /**< \brief Primary Adc Trim Value 7  */
    IfxPmsEvr_PrimaryAdcTrimValue_8,          /**< \brief Primary Adc Trim Value 8  */
    IfxPmsEvr_PrimaryAdcTrimValue_9,          /**< \brief Primary Adc Trim Value 9  */
    IfxPmsEvr_PrimaryAdcTrimValue_10,         /**< \brief Primary Adc Trim Value 10  */
    IfxPmsEvr_PrimaryAdcTrimValue_11,         /**< \brief Primary Adc Trim Value 11  */
    IfxPmsEvr_PrimaryAdcTrimValue_12,         /**< \brief Primary Adc Trim Value 12  */
    IfxPmsEvr_PrimaryAdcTrimValue_13,         /**< \brief Primary Adc Trim Value 13  */
    IfxPmsEvr_PrimaryAdcTrimValue_14,         /**< \brief Primary Adc Trim Value 14  */
    IfxPmsEvr_PrimaryAdcTrimValue_15,         /**< \brief Primary Adc Trim Value 15  */
    IfxPmsEvr_PrimaryAdcTrimValue_16,         /**< \brief Primary Adc Trim Value 16  */
    IfxPmsEvr_PrimaryAdcTrimValue_17,         /**< \brief Primary Adc Trim Value 17  */
    IfxPmsEvr_PrimaryAdcTrimValue_18,         /**< \brief Primary Adc Trim Value 18  */
    IfxPmsEvr_PrimaryAdcTrimValue_19,         /**< \brief Primary Adc Trim Value 19  */
    IfxPmsEvr_PrimaryAdcTrimValue_20,         /**< \brief Primary Adc Trim Value 20  */
    IfxPmsEvr_PrimaryAdcTrimValue_21,         /**< \brief Primary Adc Trim Value 21  */
    IfxPmsEvr_PrimaryAdcTrimValue_22,         /**< \brief Primary Adc Trim Value 22  */
    IfxPmsEvr_PrimaryAdcTrimValue_23,         /**< \brief Primary Adc Trim Value 23  */
    IfxPmsEvr_PrimaryAdcTrimValue_24,         /**< \brief Primary Adc Trim Value 24  */
    IfxPmsEvr_PrimaryAdcTrimValue_25,         /**< \brief Primary Adc Trim Value 25  */
    IfxPmsEvr_PrimaryAdcTrimValue_26,         /**< \brief Primary Adc Trim Value 26  */
    IfxPmsEvr_PrimaryAdcTrimValue_27,         /**< \brief Primary Adc Trim Value 27  */
    IfxPmsEvr_PrimaryAdcTrimValue_28,         /**< \brief Primary Adc Trim Value 28  */
    IfxPmsEvr_PrimaryAdcTrimValue_29,         /**< \brief Primary Adc Trim Value 29  */
    IfxPmsEvr_PrimaryAdcTrimValue_30,         /**< \brief Primary Adc Trim Value 30  */
    IfxPmsEvr_PrimaryAdcTrimValue_31,         /**< \brief Primary Adc Trim Value 31  */
    IfxPmsEvr_PrimaryAdcTrimValue_32,         /**< \brief Primary Adc Trim Value 32  */
    IfxPmsEvr_PrimaryAdcTrimValue_33,         /**< \brief Primary Adc Trim Value 33  */
    IfxPmsEvr_PrimaryAdcTrimValue_34,         /**< \brief Primary Adc Trim Value 34  */
    IfxPmsEvr_PrimaryAdcTrimValue_35,         /**< \brief Primary Adc Trim Value 35  */
    IfxPmsEvr_PrimaryAdcTrimValue_36,         /**< \brief Primary Adc Trim Value 36  */
    IfxPmsEvr_PrimaryAdcTrimValue_37,         /**< \brief Primary Adc Trim Value 37  */
    IfxPmsEvr_PrimaryAdcTrimValue_38,         /**< \brief Primary Adc Trim Value 38  */
    IfxPmsEvr_PrimaryAdcTrimValue_39,         /**< \brief Primary Adc Trim Value 39  */
    IfxPmsEvr_PrimaryAdcTrimValue_40,         /**< \brief Primary Adc Trim Value 40  */
    IfxPmsEvr_PrimaryAdcTrimValue_41,         /**< \brief Primary Adc Trim Value 41  */
    IfxPmsEvr_PrimaryAdcTrimValue_42,         /**< \brief Primary Adc Trim Value 42  */
    IfxPmsEvr_PrimaryAdcTrimValue_43,         /**< \brief Primary Adc Trim Value 43  */
    IfxPmsEvr_PrimaryAdcTrimValue_44,         /**< \brief Primary Adc Trim Value 44  */
    IfxPmsEvr_PrimaryAdcTrimValue_45,         /**< \brief Primary Adc Trim Value 45  */
    IfxPmsEvr_PrimaryAdcTrimValue_46,         /**< \brief Primary Adc Trim Value 46  */
    IfxPmsEvr_PrimaryAdcTrimValue_47,         /**< \brief Primary Adc Trim Value 47  */
    IfxPmsEvr_PrimaryAdcTrimValue_48,         /**< \brief Primary Adc Trim Value 48  */
    IfxPmsEvr_PrimaryAdcTrimValue_49,         /**< \brief Primary Adc Trim Value 49  */
    IfxPmsEvr_PrimaryAdcTrimValue_50,         /**< \brief Primary Adc Trim Value 50  */
    IfxPmsEvr_PrimaryAdcTrimValue_51,         /**< \brief Primary Adc Trim Value 51  */
    IfxPmsEvr_PrimaryAdcTrimValue_52,         /**< \brief Primary Adc Trim Value 52  */
    IfxPmsEvr_PrimaryAdcTrimValue_53,         /**< \brief Primary Adc Trim Value 53  */
    IfxPmsEvr_PrimaryAdcTrimValue_54,         /**< \brief Primary Adc Trim Value 54  */
    IfxPmsEvr_PrimaryAdcTrimValue_55,         /**< \brief Primary Adc Trim Value 55  */
    IfxPmsEvr_PrimaryAdcTrimValue_56,         /**< \brief Primary Adc Trim Value 56  */
    IfxPmsEvr_PrimaryAdcTrimValue_57,         /**< \brief Primary Adc Trim Value 57  */
    IfxPmsEvr_PrimaryAdcTrimValue_58,         /**< \brief Primary Adc Trim Value 58  */
    IfxPmsEvr_PrimaryAdcTrimValue_59,         /**< \brief Primary Adc Trim Value 59  */
    IfxPmsEvr_PrimaryAdcTrimValue_60,         /**< \brief Primary Adc Trim Value 60  */
    IfxPmsEvr_PrimaryAdcTrimValue_61,         /**< \brief Primary Adc Trim Value 61  */
    IfxPmsEvr_PrimaryAdcTrimValue_62,         /**< \brief Primary Adc Trim Value 62  */
    IfxPmsEvr_PrimaryAdcTrimValue_63          /**< \brief Primary Adc Trim Value 63  */
} IfxPmsEvr_PrimaryAdcTrimValue;

/** \brief This Declare the Under and overvoltage counter defined in Ifx_PMS.EVR.MONFILT.B.ERRCNTLIMT
 */
typedef enum
{
    IfxPmsEvr_SecondaryVoltageErrorCounter_level0 = 0,      /**< \brief Error Counter Limit 0  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level1,          /**< \brief Error Counter Limit 1  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level2,          /**< \brief Error Counter Limit 2  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level3,          /**< \brief Error Counter Limit 3  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level4,          /**< \brief Error Counter Limit 4  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level5,          /**< \brief Error Counter Limit 5  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level6,          /**< \brief Error Counter Limit 6  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level7,          /**< \brief Error Counter Limit 7  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level8,          /**< \brief Error Counter Limit 8  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level9,          /**< \brief Error Counter Limit 9  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level10,         /**< \brief Error Counter Limit 10  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level11,         /**< \brief Error Counter Limit 11  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level12,         /**< \brief Error Counter Limit 12  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level13,         /**< \brief Error Counter Limit 13  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level14,         /**< \brief Error Counter Limit 14  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level15,         /**< \brief Error Counter Limit 15  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level16,         /**< \brief Error Counter Limit 16  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level17,         /**< \brief Error Counter Limit 17  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level18,         /**< \brief Error Counter Limit 18  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level19,         /**< \brief Error Counter Limit 19  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level20,         /**< \brief Error Counter Limit 20  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level21,         /**< \brief Error Counter Limit 21  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level22,         /**< \brief Error Counter Limit 22  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level23,         /**< \brief Error Counter Limit 23  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level24,         /**< \brief Error Counter Limit 24  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level25,         /**< \brief Error Counter Limit 25  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level26,         /**< \brief Error Counter Limit 26  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level27,         /**< \brief Error Counter Limit 27  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level28,         /**< \brief Error Counter Limit 28  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level29,         /**< \brief Error Counter Limit 29  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level30,         /**< \brief Error Counter Limit 30  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level31,         /**< \brief Error Counter Limit 31  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level32,         /**< \brief Error Counter Limit 32  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level33,         /**< \brief Error Counter Limit 33  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level34,         /**< \brief Error Counter Limit 34  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level35,         /**< \brief Error Counter Limit 35  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level36,         /**< \brief Error Counter Limit 36  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level37,         /**< \brief Error Counter Limit 37  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level38,         /**< \brief Error Counter Limit 38  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level39,         /**< \brief Error Counter Limit 39  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level40,         /**< \brief Error Counter Limit 40  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level41,         /**< \brief Error Counter Limit 41  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level42,         /**< \brief Error Counter Limit 42  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level43,         /**< \brief Error Counter Limit 43  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level44,         /**< \brief Error Counter Limit 44  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level45,         /**< \brief Error Counter Limit 45  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level46,         /**< \brief Error Counter Limit 46  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level47,         /**< \brief Error Counter Limit 47  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level48,         /**< \brief Error Counter Limit 48  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level49,         /**< \brief Error Counter Limit 49  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level50,         /**< \brief Error Counter Limit 50  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level51,         /**< \brief Error Counter Limit 51  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level52,         /**< \brief Error Counter Limit 52  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level53,         /**< \brief Error Counter Limit 53  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level54,         /**< \brief Error Counter Limit 54  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level55,         /**< \brief Error Counter Limit 55  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level56,         /**< \brief Error Counter Limit 56  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level57,         /**< \brief Error Counter Limit 57  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level58,         /**< \brief Error Counter Limit 58  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level59,         /**< \brief Error Counter Limit 59  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level60,         /**< \brief Error Counter Limit 60  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level61,         /**< \brief Error Counter Limit 61  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level62,         /**< \brief Error Counter Limit 62  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level63          /**< \brief Error Counter Limit 63  */
} IfxPmsEvr_SecondaryVoltageErrorCounter;

/** \brief ADC result for the generating Alarm declare in Ifx_PMS.EVR.MONFILT
 */
typedef enum
{
    IfxPmsEvr_SupplyFilter_eachConversionResult    = 0,    /**< \brief Each conversion result is compared with threshold to generate alarm */
    IfxPmsEvr_SupplyFilter_avgAdcConversionResult0 = 1,    /**< \brief A moving mean average of consecutive 0 ADC results  */
    IfxPmsEvr_SupplyFilter_avgAdcConversionResult1,        /**< \brief A moving mean average of consecutive 1 ADC results  */
    IfxPmsEvr_SupplyFilter_avgAdcConversionResult2,        /**< \brief A moving mean average of consecutive 2 ADC results  */
    IfxPmsEvr_SupplyFilter_avgAdcConversionResult3,        /**< \brief A moving mean average of consecutive 3 ADC results  */
    IfxPmsEvr_SupplyFilter_avgAdcConversionResult4,        /**< \brief A moving mean average of consecutive 4 ADC results  */
    IfxPmsEvr_SupplyFilter_avgAdcConversionResult5,        /**< \brief A moving mean average of consecutive 5 ADC results  */
    IfxPmsEvr_SupplyFilter_avgAdcConversionResult6,        /**< \brief A moving mean average of consecutive 6 ADC results  */
    IfxPmsEvr_SupplyFilter_avgAdcConversionResult7,        /**< \brief A moving mean average of consecutive 7 ADC results  */
    IfxPmsEvr_SupplyFilter_avgAdcConversionResult8,        /**< \brief A moving mean average of consecutive 8 ADC results  */
    IfxPmsEvr_SupplyFilter_avgAdcConversionResult9,        /**< \brief A moving mean average of consecutive 9 ADC results  */
    IfxPmsEvr_SupplyFilter_avgAdcConversionResult10,       /**< \brief A moving mean average of consecutive 10 ADC results  */
    IfxPmsEvr_SupplyFilter_avgAdcConversionResult11,       /**< \brief A moving mean average of consecutive 11 ADC results  */
    IfxPmsEvr_SupplyFilter_avgAdcConversionResult12,       /**< \brief A moving mean average of consecutive 12 ADC results  */
    IfxPmsEvr_SupplyFilter_avgAdcConversionResult13,       /**< \brief A moving mean average of consecutive 13 ADC results  */
    IfxPmsEvr_SupplyFilter_avgAdcConversionResult14        /**< \brief A moving mean average of consecutive 14 ADC results  */
} IfxPmsEvr_SupplyFilter;

/** \brief Controls the voltage supply Type
 */
typedef enum
{
    IfxPmsEvr_SupplyMode_evrc  = 0,  /**< \brief select EVRC regulator or VDD Supply */
    IfxPmsEvr_SupplyMode_evr33 = 1,  /**< \brief select EVR33 regulator or VDDP3 Supply */
    IfxPmsEvr_SupplyMode_swd   = 2,  /**< \brief select  external VEXT suppy watchdog */
    IfxPmsEvr_SupplyMode_evrpr = 3,  /**< \brief select EVRPR or VDDPD supply */
    IfxPmsEvr_SupplyMode_vddm  = 4,  /**< \brief VDDM ADC Supply */
    IfxPmsEvr_SupplyMode_sb    = 5   /**< \brief EVR Standby Supply or VEVRSB supply */
} IfxPmsEvr_SupplyMode;

/** \brief Monitoring underVoltage for all bitfields defined
 * in Ifx_PMS.EVR.MONCTRL register for undervoltage monitoring
 */
typedef enum
{
    IfxPmsEvr_UnderVoltageMonitoring_inactive                         = 0, /**< \brief Under-Voltage Monitoring inactive */
    IfxPmsEvr_UnderVoltageMonitoring_lowToHighVoltageTransition       = 1, /**< \brief under-Voltage event is generated when threshold is crossed in lower to higher voltage transition */
    IfxPmsEvr_UnderVoltageMonitoring_highToLowVoltageTransition       = 2, /**< \brief Under-Voltage event is generated when threshold is crossed in higher to lower voltage transition */
    IfxPmsEvr_UnderVoltageMonitoring_eitherDirectionVoltageTransition = 3  /**< \brief Under-Voltage event is generated when threshold is crossed in either direction */
} IfxPmsEvr_UnderVoltageMonitoring;

/** \} */

/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/

typedef struct
{
    volatile void *regAddr;       /**< \brief Register Address to be updated. */
    uint32         value;         /**< \brief Register value to be updated. */
    uint32         mask;          /**< \brief Mask to select the bit fields to be updated. */
} IfxPmsEvr_StepDownRegulatorRegConfig;

typedef struct
{
    uint8                                           numOfRegisters;
    const IfxPmsEvr_StepDownRegulatorRegConfig *regConfig;
    float32                                         waitInSecs;
} IfxPmsEvr_initSequencePhase;

typedef struct
{
    uint8                                           numOfRegisters;
    const IfxPmsEvr_StepDownRegulatorRegConfig *regConfig;
} IfxPmsEvr_checkRegConfig;

typedef struct
{
    uint8                                  numOfPhases;
    const IfxPmsEvr_initSequencePhase *phaseConfig;
} IfxPmsEvr_initSequence;

/** \addtogroup IfxLld_Pms_Std_Evr_Over-Voltage
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief set Over Voltage Monitoring Mode
 * \param pms pointer to the Module space
 * \param mode specifies the monitoring mode
 * \param supply select EVRC,EVR33,VDDM,SWD or SB supply
 * \return None
 */
static inline void IfxPmsEvr_setOverVoltageMonitoringMode(Ifx_PMS *pms, IfxPmsEvr_OverVoltageMonitoring mode, IfxPmsEvr_SupplyMode supply);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief set Secondary Over Voltage Threshold level
 * \param pms Pointer to PMS Module
 * \param thresholdLevel over-voltage monitoring threshold level of the respective
 * regulator output or supply
 * \param supply select EVRC,EVR33,SWD,EVRPR,VDDM or SB supply mode
 * \return None
 */
extern void IfxPmsEvr_setSecondaryOverVoltageThresholdMv(Ifx_PMS *pms, float32 thresholdLevel, IfxPmsEvr_SupplyMode supply);

/** \} */

/** \addtogroup IfxLld_Pms_Std_Evr_Module
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Configure a Blanking Filter Delay
 * \param pms Pointer To PMS Module
 * \param delay Blanking Filter Delay in ms
 * \return None
 */
static inline void IfxPmsEvr_configureBlankingFilterDelay(Ifx_PMS *pms, uint8 delay);

/** \brief This function enables the synchronisation output to synchronize the external
 * SMPS regulator with respect to the internal EVRC regulator
 * \param pms Pointer to PMS Module
 * \param enabled enable/disable DC-DC synchronisation
 * \return None
 */
static inline void IfxPmsEvr_enableDcdcSynchronisation(Ifx_PMS *pms, boolean enabled);

/** \brief Enable Interrupts
 * \param pms Pointer to PMS Module
 * \param interruptType Select The Interrupt Type
 * \return None
 */
static inline void IfxPmsEvr_enableInterrupts(Ifx_PMS *pms, IfxPmsEvr_EnableInterrupt interruptType);

/** \brief enables wakeup on VEXT supply ramp-up after blanking filter
 * time has expired
 * \param pms Pointer To PMS Module
 * \param enabled Wake-up Enable on VEXT Supply ramp-up
 * \return None
 */
static inline void IfxPmsEvr_enableWakeupOnVextSupplyRampUp(Ifx_PMS *pms, boolean enabled);

/** \brief OSC Fine Trim 100MHz Clock
 * \param pms pointer to PMS Module
 * \param trimValue OSC fine trim value
 * \return None
 */
static inline void IfxPmsEvr_fineTrimEvrClock(Ifx_PMS *pms, uint8 trimValue);

/** \brief set frequency spread threshold
 * \param pms pointer to PMS module
 * \param thresholdLevel maximum frequency spreading value
 * \return None
 */
static inline void IfxPmsEvr_setFrequencySpreadThreshold(Ifx_PMS *pms, uint16 thresholdLevel);

/** \brief This configures the state of N ch. MOSFET driver during start-up and
 * shut-down phases
 * \param pms Pointer to PMS Module
 * \param nmosLevel TRISTATE/LOW
 * \return None
 */
static inline void IfxPmsEvr_setNmosLevel(Ifx_PMS *pms, boolean nmosLevel);

/** \brief This configures the state of P ch. MOSFET driver during start-up and
 * shut-down phases
 * \param pms Pointer to PMS Module
 * \param pmosLevel TRISTATE/LOW
 * \return None
 */
static inline void IfxPmsEvr_setPmosLevel(Ifx_PMS *pms, boolean pmosLevel);

/** \brief set regulator switching frequency in Hz....(100MHz/samplingFactor)
 * \param pms Pointer to PMS Module
 * \param samplingFactor Over-sampling Factor
 * \return None
 */
static inline void IfxPmsEvr_setRegulatorSwitchingFrequency(Ifx_PMS *pms, uint16 samplingFactor);

/** \brief set reset trim value for EVRC,EVR33 and external VEXT supply
 * \param pms Pointer to PMS Module Space
 * \param resetTrimValue Reset Trim Value
 * \param supply select EVRC,EVR33 regulator or external VEXT supply watchdog
 * \return None
 */
static inline void IfxPmsEvr_setResetTrimValueMv(Ifx_PMS *pms, float32 resetTrimValue, IfxPmsEvr_SupplyMode supply);

/** \brief SD Regulator Voltage Target selection
 * \param pms Pointer to PMS Module
 * \param outputLevel The VDD output level of the Step down regulator
 * \return None
 */
static inline void IfxPmsEvr_setSdRegulatorOutputLevel(Ifx_PMS *pms, uint8 outputLevel);

/** \brief SD Regulator Voltage Trim Value
 * \param pms Pointer to PMS Moule Space
 * \param trimValue offset added to the VDD output level
 * \return None
 */
static inline void IfxPmsEvr_setSdRegulatorPrimaryAdcTrimValue(Ifx_PMS *pms, IfxPmsEvr_PrimaryAdcTrimValue trimValue);

/** \brief set DLMU RAM Block in Standby Mode
 * \param pms Pointer To PMS Module
 * \param ramBlock DLMU RAM block
 * \return None
 */
static inline void IfxPmsEvr_setStandbyRamSupply(Ifx_PMS *pms, uint8 ramBlock);

/** \brief Set Switching frequency division factor for external synchronisation.
 * \param pms Pointer To PMS Module
 * \param divider Switching frequency division factor for external synchronisation
 * \return None
 */
static inline void IfxPmsEvr_setSwitchingFreqDivFactorForExternalsync(Ifx_PMS *pms, IfxPmsEvr_ExtSyncSwitchingFreqDivFactor divider);

/** \brief OSC Fine Trim 100MHz Clock
 * \param pms Pointer to PMS Module
 * \param trimValue OSC Signed fine trim value
 * \return None
 */
static inline void IfxPmsEvr_signedFineTrimEvrClock(Ifx_PMS *pms, sint8 trimValue);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief filter the  each conversion result or avarage of consecutive adc result to compare with threshold
 * \param pms Pointer to PMS Module
 * \param adcFilterValue specify average of consecutive ADC results
 * \param supply select EVRC,EVR33,SWD,EVRPR,VDDM or SB supply mode
 * \return None
 */
extern void IfxPmsEvr_filterSecondaryConversionResult(Ifx_PMS *pms, IfxPmsEvr_SupplyFilter adcFilterValue, IfxPmsEvr_SupplyMode supply);

/** \brief get secondray ADC result for respective Voltage supply
 * \param pms Pointer To PMS Module
 * \param supply select EVRC,EVR33,SWD,EVRPR,VDDM or SB supply mode
 * \return last conversion result of the ADC measurement
 * of respective voltage by secondary monitor
 */
extern uint8 IfxPmsEvr_getSecondaryAdcResult(Ifx_PMS *pms, IfxPmsEvr_SupplyMode supply);

/** \} */

/** \addtogroup IfxLld_Pms_Std_Evr_Under-Voltage
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief set Under Voltage Monitoring mode
 * \param pms Pointer to the PMS Module space
 * \param mode specifies the monitoring mode
 * \param supply select EVRC,EVR33,VDDM,SWD or SB supply
 * \return None
 */
static inline void IfxPmsEvr_setUnderVoltageMonitoringMode(Ifx_PMS *pms, IfxPmsEvr_UnderVoltageMonitoring mode, IfxPmsEvr_SupplyMode supply);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief set Secondary under Voltage Threshold level
 * \param pms Pointer to PMS Module space
 * \param thresholdLevel under-voltage monitoring threshold level of the respective
 * regulator output or supply
 * \param supply select EVRC,EVR33,SWD,EVRPR,VDDM or SB supply mode
 * \return None
 */
extern void IfxPmsEvr_setSecondaryUnderVoltageThresholdMv(Ifx_PMS *pms, float32 thresholdLevel, IfxPmsEvr_SupplyMode supply);

/** \} */

/** \addtogroup IfxLld_Pms_Std_Evr_EVRC
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Enabled/Disable Reset Trigger signal for EVRC
 * \param pms pointer to PMS Module
 * \param enableReset Enable/Disable the reset trigger signal
 * \return None
 */
static inline void IfxPmsEvr_evrcResetTriggerSignalConfig(Ifx_PMS *pms, boolean enableReset);

/**
 * \param averageADCC Average value of PMS_EVRADCSTAT.ADCCV.
 * \return ADC VDD Core Voltage Conversion Result
 */
static inline float32 IfxPmsEvr_getAdcVddResult(float32 averageADCC);

/** \brief get current operating mode of EVRC
 * \param pms Pointer to PMS Module Space
 * \return EVRC Mode
 */
static inline IfxPmsEvr_EvrcMode IfxPmsEvr_getEvrcMode(Ifx_PMS *pms);

/** \brief get EVRC Regulator Voltage status
 * \param pms Pointer to PMS Module Space
 * \return EVRC Regulator Voltage OK status
 */
static inline boolean IfxPmsEvr_getEvrcVoltageRegulator(Ifx_PMS *pms);

/** \brief get ADC 1.25 V Core Voltage Conversion Result
 * \param pms Pointer to PMS Module space
 * \return last conversion result of the ADC measurement of
 * the VDD / EVRC supply by the Primary Monitor
 */
static inline uint8 IfxPmsEvr_getPrimaryAdcEvrcResult(Ifx_PMS *pms);

/** \} */

/** \addtogroup IfxLld_Pms_Std_Evr_EVR33
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Enabled/Disable Reset Trigger signal for EVR33
 * \param pms pointer to PMS Module
 * \param enableReset Enable/Disable the reset trigger signal
 * \return None
 */
static inline void IfxPmsEvr_evr33ResetTriggerSignalConfig(Ifx_PMS *pms, boolean enableReset);

/** \brief get ADC 3.3 V Voltage Conversion Result
 * \param pms Pointer to PMS Module Space
 * \return last conversion result of the ADC measurement of
 * the VDDP3 / EVR33 supply by the Primary Monitor
 */
static inline uint8 IfxPmsEvr_getPrimaryAdcEvr33Result(Ifx_PMS *pms);

/** \brief set 3.3 V Regulator Voltage Primary ADC Trim Value
 * \param pms Pointer to PMS Module
 * \param trimValue Trimming value offeset added to Output level
 * \return None
 */
static inline void IfxPmsEvr_setEvr33PrimaryAdcTrimValue(Ifx_PMS *pms, IfxPmsEvr_PrimaryAdcTrimValue trimValue);

/** \brief The VDDP3 output level of the EVR33 LDO regulator
 * \param pms Pointer to PMS Module
 * \param outputLevel define VDDP3 output level of the EVR33 LDO regulator.
 * \return None
 */
static inline void IfxPmsEvr_setEvr33VoltageOutputlevel(Ifx_PMS *pms, uint8 outputLevel);

/** \} */

/** \addtogroup IfxLld_Pms_Std_Evr_SWD
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief get ADC External Supply Conversion Result
 * \param pms Pointer to PMS Module space
 * \return last conversion result of the ADC measurement of
 * the external VEXT (3.3V / 5V) supply by the Primary Monitor
 */
static inline uint8 IfxPmsEvr_getPrimaryAdcSwdResult(Ifx_PMS *pms);

/** \brief Enabled/Disable Reset Trigger signal for SWD
 * \param pms Pointer to PMS Module
 * \param enableReset Enable/Disable the reset trigger signal
 * \return None
 */
static inline void IfxPmsEvr_swdResetTriggerSignalConfig(Ifx_PMS *pms, boolean enableReset);

/** \} */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/**
 */
static inline boolean IfxPmsEvr_areInitValuesRight(const IfxPmsEvr_checkRegConfig *const checkConfig);

/** \brief Disable Interrupts
 * \return None
 */
static inline void IfxPmsEvr_disableInterrupt(Ifx_PMS *pms, IfxPmsEvr_EnableInterrupt interruptType);

/**
 * \param averageADC33V Average of PMS_EVRSTAT.ADC33V values
 * \return ADC VDDP3 Voltage Conversion Result
 */
static inline float32 IfxPmsEvr_getAdcVddp3Result(float32 averageADC33V);

/**
 * \param averageADCSWDV Average of PMS_EVRADCSTAT.ADCSWDV values.
 * \return ADC VEXT Supply Conversion Result
 */
static inline float32 IfxPmsEvr_getAdcVextResult(float32 averageADCSWDV);

/**
 */
static inline boolean IfxPmsEvr_runInitSequence(const IfxPmsEvr_initSequence *const sequence);

/**
 * \return None
 */
static inline void IfxPmsEvr_wait(float32 waitInSec);

/******************************************************************************/
/*-------------------Global Exported Variables/Constants----------------------*/
/******************************************************************************/

extern const IfxPmsEvr_StepDownRegulatorRegConfig IfxPmsEvr_cfgPhase1Default[];

extern const IfxPmsEvr_StepDownRegulatorRegConfig IfxPmsEvr_cfgPhase2Default[];

/** \brief
 */
extern const IfxPmsEvr_StepDownRegulatorRegConfig IfxPmsEvr_cfgPhase3Default[];

extern const IfxPmsEvr_initSequencePhase          IfxPmsEvr_cfgPhasesDefault[];

extern const IfxPmsEvr_initSequence               IfxPmsEvr_cfgSequenceDefault;

extern const IfxPmsEvr_checkRegConfig             IfxPmsEvr_checkRegCfgDefault;

extern const IfxPmsEvr_StepDownRegulatorRegConfig IfxPmsEvr_checkRegValuesDefault[];

/******************************************************************************/
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

static inline boolean IfxPmsEvr_areInitValuesRight(const IfxPmsEvr_checkRegConfig *const checkConfig)
{
    boolean allRight = (1u);
    sint32  regCfgCount;

    if ((*(volatile Ifx_PMS_EVRSTAT*)0xF024802Cu).B.EVRC == 1U)
    {
        for (regCfgCount = 0; regCfgCount < checkConfig->numOfRegisters; regCfgCount++)
        {
            uint32                                      regVal;
            const IfxPmsEvr_StepDownRegulatorRegConfig *regConfig = &checkConfig->regConfig[regCfgCount];
            regVal  = (*((volatile uint32 *)regConfig->regAddr));
            regVal &= regConfig->mask;

            if (regVal != regConfig->value)
            {
                allRight = (0u);
            }
        }

        /*Check if EVRSTAT.SDVOK is set*/
        if (allRight == (1u))
        {
            if ((*(volatile Ifx_PMS_EVRSTAT*)0xF024802Cu).B.SDVOK != 1)
            {
                allRight = (0u);
            }
        }
    }

    return allRight;
}


static inline void IfxPmsEvr_configureBlankingFilterDelay(Ifx_PMS *pms, uint8 delay)
{
    uint16 passwd = IfxScuWdt_getSafetyWatchdogPassword();

    IfxScuWdt_clearSafetyEndinit(passwd);

    pms->PMSWCR0.B.BLNKFIL = delay;

    IfxScuWdt_setSafetyEndinit(passwd);
}


static inline void IfxPmsEvr_disableInterrupt(Ifx_PMS *pms, IfxPmsEvr_EnableInterrupt interruptType)
{
    uint16 passwd = IfxScuWdt_getSafetyWatchdogPassword();

    IfxScuWdt_clearSafetyEndinit(passwd);
    uint32 mask = (1U << interruptType);
    pms->PMSIEN.U &= (~mask);

    IfxScuWdt_setSafetyEndinit(passwd);
}


static inline void IfxPmsEvr_enableDcdcSynchronisation(Ifx_PMS *pms, boolean enabled)
{
    uint16 passwd = IfxScuWdt_getSafetyWatchdogPassword();

    IfxScuWdt_clearSafetyEndinit(passwd);

    pms->PMSWCR5.B.DCDCSYNCO = enabled;

    IfxScuWdt_setSafetyEndinit(passwd);
}


static inline void IfxPmsEvr_enableInterrupts(Ifx_PMS *pms, IfxPmsEvr_EnableInterrupt interruptType)
{
    uint16 passwd = IfxScuWdt_getSafetyWatchdogPassword();

    IfxScuWdt_clearSafetyEndinit(passwd);

    pms->PMSIEN.U |= (1U << interruptType);

    IfxScuWdt_setSafetyEndinit(passwd);
}


static inline void IfxPmsEvr_enableWakeupOnVextSupplyRampUp(Ifx_PMS *pms, boolean enabled)
{
    uint16 passwd = IfxScuWdt_getSafetyWatchdogPassword();

    IfxScuWdt_clearSafetyEndinit(passwd);

    pms->PMSWCR0.B.PWRWKEN = enabled;

    IfxScuWdt_setSafetyEndinit(passwd);
}


static inline void IfxPmsEvr_evr33ResetTriggerSignalConfig(Ifx_PMS *pms, boolean enableReset)
{
    uint16 passwd = IfxScuWdt_getSafetyWatchdogPassword();

    IfxScuWdt_clearSafetyEndinit(passwd);
    pms->EVRRSTCON.B.BPRST33OFF = 1;
    pms->EVRRSTCON.B.RST33OFF   = enableReset;

    IfxScuWdt_setSafetyEndinit(passwd);
}


static inline void IfxPmsEvr_evrcResetTriggerSignalConfig(Ifx_PMS *pms, boolean enableReset)
{
    uint16 passwd = IfxScuWdt_getSafetyWatchdogPassword();

    IfxScuWdt_clearSafetyEndinit(passwd);

    pms->EVRRSTCON.B.BPRSTCOFF = 1;
    pms->EVRRSTCON.B.RSTCOFF   = enableReset;

    IfxScuWdt_setSafetyEndinit(passwd);
}


static inline void IfxPmsEvr_fineTrimEvrClock(Ifx_PMS *pms, uint8 trimValue)
{
    uint16 passwd = IfxScuWdt_getSafetyWatchdogPassword();

    IfxScuWdt_clearSafetyEndinit(passwd);

    pms->EVROSCCTRL.B.OSCFTRIM = trimValue;

    IfxScuWdt_setSafetyEndinit(passwd);
}


static inline float32 IfxPmsEvr_getAdcVddResult(float32 averageADCC)
{
    float32 vddVoltage = 0;
    vddVoltage = ((0.005f) * averageADCC + 0.7125);
    return vddVoltage;
}


static inline float32 IfxPmsEvr_getAdcVddp3Result(float32 averageADC33V)
{
    float32 vddp3Voltage = 0;
    vddp3Voltage = ((0.015f) * averageADC33V + 0.9375);
    return vddp3Voltage;
}


static inline float32 IfxPmsEvr_getAdcVextResult(float32 averageADCSWDV)
{
    float32 vextVoltage = 0;
    vextVoltage = ((0.02f) * averageADCSWDV + 1.050);
    return vextVoltage;
}


static inline IfxPmsEvr_EvrcMode IfxPmsEvr_getEvrcMode(Ifx_PMS *pms)
{
    return (IfxPmsEvr_EvrcMode)pms->EVRSTAT.B.EVRCMOD;
}


static inline boolean IfxPmsEvr_getEvrcVoltageRegulator(Ifx_PMS *pms)
{
    return (boolean)pms->EVRSTAT.B.SDVOK;
}


static inline uint8 IfxPmsEvr_getPrimaryAdcEvr33Result(Ifx_PMS *pms)
{
    return pms->EVRADCSTAT.B.ADC33V;
}


static inline uint8 IfxPmsEvr_getPrimaryAdcEvrcResult(Ifx_PMS *pms)
{
    return pms->EVRADCSTAT.B.ADCCV;
}


static inline uint8 IfxPmsEvr_getPrimaryAdcSwdResult(Ifx_PMS *pms)
{
    return pms->EVRADCSTAT.B.ADCSWDV;
}



#pragma optimize L



static inline boolean IfxPmsEvr_runInitSequence(const IfxPmsEvr_initSequence *const sequence)
{
    boolean                                     pmsInitDone    = (1u);
    uint32                                      regVal;
    uint16                                      endinitSfty_pw = IfxScuWdt_getGlobalSafetyEndinitPasswordInline();
    const IfxPmsEvr_initSequencePhase          *phaseConfig;
    const IfxPmsEvr_StepDownRegulatorRegConfig *regConfig;

    if ((*(volatile Ifx_PMS_EVRSTAT*)0xF024802Cu).B.EVRC == 1U)
    {
        /*Loop through each configured phase*/
        for (phaseConfig = &sequence->phaseConfig[0];
             phaseConfig < &sequence->phaseConfig[sequence->numOfPhases];
             phaseConfig++)
        {
            IfxScuWdt_clearGlobalSafetyEndinitInline(endinitSfty_pw);

            /*Loop through each register which is configured in the phase configuration*/
            for (regConfig = &phaseConfig->regConfig[0];
                 regConfig < &phaseConfig->regConfig[phaseConfig->numOfRegisters];
                 regConfig++)
            {
                regVal  = (*((volatile uint32 *)regConfig->regAddr));
                regVal &= ~regConfig->mask;
                regVal |= regConfig->value;

                /** During normal running one must wait for the LCK bit.
                 * However, for this function, as this is used only with CPU0 startup no wait required
                 */
                (*((volatile uint32 *)regConfig->regAddr)) = regVal; /*Write to the physical register*/
            }

            (*(volatile Ifx_PMS_EVRSDCTRL0*)0xF0248108u).B.UP = 1;
            IfxScuWdt_setGlobalSafetyEndinitInline(endinitSfty_pw);

            /* wait for the UP bit*/
            sint32 timeoutCount = (0x100);

            /*Now, wait for the UP bit at EVRSDCTRL0 is reset, which is to indicate the configurations are done*/
            do
            {
                if (--timeoutCount <= 0)
                {
                    pmsInitDone = (0u);
                    break;
                }
            } while ((*(volatile Ifx_PMS_EVRSDCTRL0*)0xF0248108u).B.UP == 1);

            IfxPmsEvr_wait(phaseConfig->waitInSecs);        // wait for configured time
        }
    }

    /*return the status*/
    return pmsInitDone;
}

#pragma endoptimize





static inline void IfxPmsEvr_setEvr33PrimaryAdcTrimValue(Ifx_PMS *pms, IfxPmsEvr_PrimaryAdcTrimValue trimValue)
{
    uint16 passwd = IfxScuWdt_getSafetyWatchdogPassword();

    IfxScuWdt_clearSafetyEndinit(passwd);
    pms->EVRTRIM.B.EVR33VOUTTRIM = trimValue;

    IfxScuWdt_setSafetyEndinit(passwd);
}


static inline void IfxPmsEvr_setEvr33VoltageOutputlevel(Ifx_PMS *pms, uint8 outputLevel)
{
    uint16 passwd = IfxScuWdt_getSafetyWatchdogPassword();

    IfxScuWdt_clearSafetyEndinit(passwd);

    pms->EVRTRIM.B.EVR33VOUTSEL = outputLevel;

    IfxScuWdt_setSafetyEndinit(passwd);
}


static inline void IfxPmsEvr_setFrequencySpreadThreshold(Ifx_PMS *pms, uint16 thresholdLevel)
{
    uint16 passwd = IfxScuWdt_getSafetyWatchdogPassword();

    IfxScuWdt_clearSafetyEndinit(passwd);
    pms->EVRSDCTRL0.B.SDFREQSPRD = thresholdLevel;
    pms->EVRSDCTRL0.B.UP         = 1;

    IfxScuWdt_setSafetyEndinit(passwd);
}


static inline void IfxPmsEvr_setNmosLevel(Ifx_PMS *pms, boolean nmosLevel)
{
    uint16 passwd = IfxScuWdt_getSafetyWatchdogPassword();

    IfxScuWdt_clearSafetyEndinit(passwd);

    pms->EVRSDCTRL0.B.NGOFF = nmosLevel;
    pms->EVRSDCTRL0.B.UP    = 1;

    IfxScuWdt_setSafetyEndinit(passwd);
}


static inline void IfxPmsEvr_setOverVoltageMonitoringMode(Ifx_PMS *pms, IfxPmsEvr_OverVoltageMonitoring mode, IfxPmsEvr_SupplyMode supply)
{
    uint16          passwd = IfxScuWdt_getSafetyWatchdogPassword();

    Ifx_PMS_MONCTRL tempMONCTRL;
    IfxScuWdt_clearSafetyEndinit(passwd);
    tempMONCTRL.U = pms->MONCTRL.U;

    switch (supply)
    {
    case IfxPmsEvr_SupplyMode_evrc:
        tempMONCTRL.B.EVRCOVMOD = mode;
        break;
    case IfxPmsEvr_SupplyMode_evr33:
        tempMONCTRL.B.EVR33OVMOD = mode;
        break;
    case IfxPmsEvr_SupplyMode_swd:
        tempMONCTRL.B.SWDOVMOD = mode;
        break;
    case IfxPmsEvr_SupplyMode_evrpr:
        tempMONCTRL.B.PREOVMOD = mode;
        break;
    case IfxPmsEvr_SupplyMode_vddm:
        tempMONCTRL.B.VDDMOVMOD = mode;
        break;
    case IfxPmsEvr_SupplyMode_sb:
        tempMONCTRL.B.SBOVMOD = mode;
        break;
    }

    pms->MONCTRL.U = tempMONCTRL.U;

    IfxScuWdt_setSafetyEndinit(passwd);
}


static inline void IfxPmsEvr_setPmosLevel(Ifx_PMS *pms, boolean pmosLevel)
{
    uint16 passwd = IfxScuWdt_getSafetyWatchdogPassword();

    IfxScuWdt_clearSafetyEndinit(passwd);

    pms->EVRSDCTRL0.B.PGOFF = pmosLevel;
    pms->EVRSDCTRL0.B.UP    = 1;

    IfxScuWdt_setSafetyEndinit(passwd);
}


static inline void IfxPmsEvr_setRegulatorSwitchingFrequency(Ifx_PMS *pms, uint16 samplingFactor)
{
    uint16 passwd = IfxScuWdt_getSafetyWatchdogPassword();

    IfxScuWdt_clearSafetyEndinit(passwd);

    pms->EVRSDCTRL0.B.SDFREQ = samplingFactor;
    pms->EVRSDCTRL0.B.UP     = 1;

    IfxScuWdt_setSafetyEndinit(passwd);
}


static inline void IfxPmsEvr_setResetTrimValueMv(Ifx_PMS *pms, float32 resetTrimValue, IfxPmsEvr_SupplyMode supply)
{
    uint16            passwd = IfxScuWdt_getSafetyWatchdogPassword();

    Ifx_PMS_EVRRSTCON tempRSTCON;
    IfxScuWdt_clearSafetyEndinit(passwd);
    tempRSTCON.U = pms->EVRRSTCON.U;

    switch (supply)
    {
    case IfxPmsEvr_SupplyMode_evrc:
        tempRSTCON.B.RSTCTRIM = ((resetTrimValue - 712.5) / 5);
        break;
    case IfxPmsEvr_SupplyMode_evr33:
        tempRSTCON.B.RST33TRIM = ((resetTrimValue - 937.5) / 15);
        break;
    case IfxPmsEvr_SupplyMode_swd:
        tempRSTCON.B.RSTSWDTRIM = ((resetTrimValue - 1050) / 20);
        break;
    default:
        break;
    }

    pms->EVRRSTCON.U = tempRSTCON.U;

    IfxScuWdt_setSafetyEndinit(passwd);
}


static inline void IfxPmsEvr_setSdRegulatorOutputLevel(Ifx_PMS *pms, uint8 outputLevel)
{
    uint16 passwd = IfxScuWdt_getSafetyWatchdogPassword();

    IfxScuWdt_clearSafetyEndinit(passwd);

    pms->EVRTRIM.B.SDVOUTSEL = outputLevel;

    IfxScuWdt_setSafetyEndinit(passwd);
}


static inline void IfxPmsEvr_setSdRegulatorPrimaryAdcTrimValue(Ifx_PMS *pms, IfxPmsEvr_PrimaryAdcTrimValue trimValue)
{
    uint16 passwd = IfxScuWdt_getSafetyWatchdogPassword();

    IfxScuWdt_clearSafetyEndinit(passwd);
    pms->EVRTRIM.B.SDVOUTTRIM = trimValue;

    IfxScuWdt_setSafetyEndinit(passwd);
}


static inline void IfxPmsEvr_setStandbyRamSupply(Ifx_PMS *pms, uint8 ramBlock)
{
    uint16 passwd = IfxScuWdt_getSafetyWatchdogPassword();

    IfxScuWdt_clearSafetyEndinit(passwd);

    pms->PMSWCR0.B.STBYRAMSEL = ramBlock;

    IfxScuWdt_setSafetyEndinit(passwd);
}


static inline void IfxPmsEvr_setSwitchingFreqDivFactorForExternalsync(Ifx_PMS *pms, IfxPmsEvr_ExtSyncSwitchingFreqDivFactor divider)
{
    uint16 passwd = IfxScuWdt_getSafetyWatchdogPassword();

    IfxScuWdt_clearSafetyEndinit(passwd);
    pms->EVRSDCTRL7.B.SYNCDIVFAC = divider;
    IfxScuWdt_setSafetyEndinit(passwd);
}


static inline void IfxPmsEvr_setUnderVoltageMonitoringMode(Ifx_PMS *pms, IfxPmsEvr_UnderVoltageMonitoring mode, IfxPmsEvr_SupplyMode supply)
{
    uint16          passwd = IfxScuWdt_getSafetyWatchdogPassword();
    Ifx_PMS_MONCTRL tempMONCTRL;
    IfxScuWdt_clearSafetyEndinit(passwd);
    tempMONCTRL.U = pms->MONCTRL.U;

    switch (supply)
    {
    case IfxPmsEvr_SupplyMode_evrc:
        tempMONCTRL.B.EVRCUVMOD = mode;
        break;
    case IfxPmsEvr_SupplyMode_evr33:
        tempMONCTRL.B.EVR33UVMOD = mode;
        break;
    case IfxPmsEvr_SupplyMode_swd:
        tempMONCTRL.B.SWDUVMOD = mode;
        break;
    case IfxPmsEvr_SupplyMode_evrpr:
        tempMONCTRL.B.PREUVMOD = mode;
        break;
    case IfxPmsEvr_SupplyMode_vddm:
        tempMONCTRL.B.VDDMUVMOD = mode;
        break;
    case IfxPmsEvr_SupplyMode_sb:
        tempMONCTRL.B.SBUVMOD = mode;
        break;
    }

    pms->MONCTRL.U = tempMONCTRL.U;

    IfxScuWdt_setSafetyEndinit(passwd);
}


static inline void IfxPmsEvr_signedFineTrimEvrClock(Ifx_PMS *pms, sint8 trimValue)
{
    uint16 passwd = IfxScuWdt_getSafetyWatchdogPassword();

    IfxScuWdt_clearSafetyEndinit(passwd);
    pms->EVROSCCTRL.B.OSCFPTRIM = trimValue;

    IfxScuWdt_setSafetyEndinit(passwd);
}


static inline void IfxPmsEvr_swdResetTriggerSignalConfig(Ifx_PMS *pms, boolean enableReset)
{
    uint16 passwd = IfxScuWdt_getSafetyWatchdogPassword();

    IfxScuWdt_clearSafetyEndinit(passwd);
    pms->EVRRSTCON.B.BPRSTSWDOFF = 1;
    pms->EVRRSTCON.B.RSTSWDOFF   = enableReset;

    IfxScuWdt_setSafetyEndinit(passwd);
}


static inline void IfxPmsEvr_wait(float32 waitInSec)
{
    uint32 stmCount      = (uint32)((float32)33000000UL * waitInSec);
    uint32 stmCountBegin = (*(volatile Ifx_STM_TIM0*)0xF0001010u).U;     /* it is necessary to get this value to have minimum 100uS delay in subsequent CPU start */

    while ((uint32)((*(volatile Ifx_STM_TIM0*)0xF0001010u).U - stmCountBegin) < stmCount)
    {
        /* There is no need to check overflow of the STM timer.
         * When counter after overflow subtracted with counter before overflow,
         * the subtraction result will be as expected, as long as both are unsigned 32 bits
         * eg: stmCountBegin= 0xFFFFFFFE (before overflow)
         *     stmCountNow = 0x00000002 (before overflow)
         *     diff= stmCountNow - stmCountBegin = 4 as expected.*/
    }
}



#line 67 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Pms\\Std\\IfxPmsPm.h"

#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Cpu\\Irq\\IfxCpu_Irq.h"
/**
 * \file IfxCpu_Irq.h
 * \brief This file contains the APIs for Interrupt related functions.
 *
 *
 * \version iLLD_1_0_1_15_0_1
 * \copyright Copyright (c) 2012 Infineon Technologies AG. All rights reserved.
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * \defgroup IfxLld_Cpu_Irq Interrupt Functions
 * \ingroup IfxLld_Cpu
 *
 * \defgroup IfxLld_Cpu_Irq_Usage How to define Interrupts?
 * \ingroup IfxLld_Cpu_Irq
 *
 */



/*******************************************************************************
**                      Includes                                              **
*******************************************************************************/


#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Cpu\\Std\\Ifx_Types.h"
/**
 * \file Ifx_Types.h
 * \brief This files defines all types used by the IFX HAL and libraries
 *
 * \version iLLD_1_0_1_15_0_1
 * \copyright Copyright (c) 2018 Infineon Technologies AG. All rights reserved.
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */
























































































































































































#line 56 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Cpu\\Irq\\IfxCpu_Irq.h"


#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Src\\Std\\IfxSrc.h"
/**
 * \file IfxSrc.h
 * \brief SRC  basic functionality
 * \ingroup IfxLld_Src
 *
 * \version iLLD_1_0_1_15_0_1
 * \copyright Copyright (c) 2016 Infineon Technologies AG. All rights reserved.
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * \defgroup IfxLld_Src SRC
 * \addtogroup IfxLld_Src
 * \{
 * \defgroup IfxLld_Src_Usage How to use Service Request Mechanism?
 * \addtogroup IfxLld_Src_Usage
 * \{
 *
 * For Aurix controller peripherals that can generate service requests is connected to one
 * or more Service Request Nodes (SRNs) in the central Interrupt Router(IR) module. Refer to Controller User Manual for more details\n
 *
 * IfxSrc driver provides the APIs to configure and control service requests. Refer \ref IfxLld_Src_Usage for
 * details of these APIs.
 *
 *
 * \section Ifx_Src_UsageInit Initialize the Service Request Node
 *
 * Service request node is initialized to configure the following,\n
 * 1) Route the interrupt trigger to service provider, which are:\n
 *  __a. One of the available CPUs or\n
 *  __b. DMA controller\n
 *
 * 2) Priority of CPU Interrupt or DMA Trigger.
 *
 * For Interrupt or DMA to be correctly triggered, following steps are to be done in the user code:
 *
 * \subsection Ifx_Src_UsageInitStep1 Step1: Configure the Node
 *
 * User must configure the service request node in the application / driver files.
 *
 * \subsection Ifx_Src_UsageInitStep2 Step2: Enable the Trigger
 *
 * Enable the service request node to connect the trigger event from the hardware to service provider.
 *
 * Example:
 * Following example show the configuration for STM0 Service request 0 trigger configured to trigger
 * CPU1 with the priority specified by IFX_INTPRIO_STM0 (from the example at IfxCpu_Irq)
 *
 * \code
 * //file: myApplication.c
 *
 * #include "Ifx_IntPrioDef.h" // to get the priority numbers
 *
 * void myDriverInitFunction(void)
 * {
 *    // driver init code
 *
 *    // Step1: Call the function to route the trigger from for SRC_STM0_SR0 to CPU1
 *    // and priority specified at Ifx_IntPrioDef.h globally
 *    IfxSrc_init(&MODULE_SRC.STM.STM[0].SR[0], IfxSrc_Tos_cpu1, IFX_INTPRIO_STM0);
 *
 *    // Step2: Enable the service request node
 *    IfxSrc_enable(&MODULE_SRC.STM.STM[0].SR[0]);
 * }
 * \endcode
 *
 * \}
 * \}
 *
 * \defgroup IfxLld_Src_Std_Service_Request Service Request Functions
 * \ingroup IfxLld_Src_Std
 * \defgroup IfxLld_Src_Std_Module Module Functions
 * \ingroup IfxLld_Src_Std
 */




/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/


#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\_Impl\\IfxSrc_cfg.h"
/**
 * \file IfxSrc_cfg.h
 * \brief SRC on-chip implementation data
 * \ingroup IfxLld_Src
 *
 * \version iLLD_1_0_1_15_0_1
 * \copyright Copyright (c) 2016 Infineon Technologies AG. All rights reserved.
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * \defgroup IfxLld_Src SRC
 * \ingroup IfxLld
 * \defgroup IfxLld_Src_Impl Implementation
 * \ingroup IfxLld_Src
 * \defgroup IfxLld_Src_Std Standard Driver
 * \ingroup IfxLld_Src
 * \defgroup IfxLld_Src_Impl_Enumerations Enumerations
 * \ingroup IfxLld_Src_Impl
 */




/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

/******************************************************************************/
/*--------------------------------Enumerations--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Src_Impl_Enumerations
 * \{ */
/** \brief Identifier of interrupt service provider, which handles the interrupt service request.
 */
typedef enum
{
    IfxSrc_Tos_cpu0 = 0,  /**< \brief CPU0 interrupt service provider, which handles the interrupt service request. */
    IfxSrc_Tos_dma  = 1,  /**< \brief DMA interrupt service provider, which handles the interrupt service request. */
    IfxSrc_Tos_cpu1 = 2,  /**< \brief CPU1 interrupt service provider, which handles the interrupt service request. */
    IfxSrc_Tos_cpu2 = 3,  /**< \brief CPU2 interrupt service provider, which handles the interrupt service request. */
    IfxSrc_Tos_cpu3 = 4   /**< \brief CPU3 interrupt service provider, which handles the interrupt service request. */
} IfxSrc_Tos;

/** \} */


#line 113 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Src\\Std\\IfxSrc.h"


/** \addtogroup IfxLld_Src_Std_Service_Request
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Resets the overrun flag of the Service Request.
 * \param src pointer to the Service Request Control register which the overrun flag should be cleared.
 * \return None
 *
 * Usage example: see \ref IfxSrc_init
 *
 */
static inline void IfxSrc_clearOverrun(volatile Ifx_SRC_SRCR *src);

/** \brief Resets a specific interrupt service by software.
 * \param src pointer to the Service Request Control register which the request should be cleared.
 * \return None
 *
 * Usage example: see \ref IfxSrc_init
 *
 */
static inline void IfxSrc_clearRequest(volatile Ifx_SRC_SRCR *src);

/** \brief Gets the current overrun status.
 * \param src pointer to the Service Request Control register for which the overrun status should be returned.
 * \return current service request control overrun status.
 *
 * Usage example: see \ref IfxSrc_init
 *
 */
static inline boolean IfxSrc_isOverrun(volatile Ifx_SRC_SRCR *src);

/** \brief Gets the current request status.
 * \param src pointer to the Service Request Control register for which the request status should be returned.
 * \return current service request control request status.
 *
 * Usage example: see \ref IfxSrc_init
 *
 */
static inline boolean IfxSrc_isRequested(volatile Ifx_SRC_SRCR *src);

/** \brief Requests a specific interrupt service by software
 * \param src pointer to the Service Request Control register which the interrupt has to be requested.
 * \return None
 *
 * Usage example: see \ref IfxSrc_init
 *
 */
static inline void IfxSrc_setRequest(volatile Ifx_SRC_SRCR *src);

/** \} */

/** \addtogroup IfxLld_Src_Std_Module
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief DeInitializes the service request control register.
 * \param src pointer to the Service Request Control register which should be deinitialised.
 * \return None
 *
 * Usage example: see \ref IfxSrc_init
 *
 */
static inline void IfxSrc_deinit(volatile Ifx_SRC_SRCR *src);

/** \brief Disables a specific interrupt service request.
 * \param src pointer to the Service Request Control register for which the interrupt has to be disabled.
 * \return None
 *
 * Usage example: see \ref IfxSrc_init
 *
 */
static inline void IfxSrc_disable(volatile Ifx_SRC_SRCR *src);

/** \brief Enables a specific interrupt service request.
 * \param src pointer to the Service Request Control register for which the interrupt has to be enabled.
 * \return None
 *
 * Usage example: see \ref IfxSrc_init
 *
 */
static inline void IfxSrc_enable(volatile Ifx_SRC_SRCR *src);

/** \brief Initializes the service request control register.
 * \param src pointer to the Service Request Control register which should be initialised.
 * \param typOfService type of interrupt service provider.
 * \param priority Interrupt priority.
 * \return None
 *
 * Get the peripheral service control register which request need to be serviced and assign this service to any of service providers.
 * \code
 * //define the interrupt priority
 * #define IFXASCLIN0_TX_INTPRIO 2
 * //get the service request
 * volatile Ifx_SRC_SRCR *src = IfxAsclin_getSrcPointerRx( &MODULE_ASCLIN0 );
 * //initlaise the service request
 * IfxSrc_init( src, IfxSrc_Tos_cpu0, IFXASCLIN0_TX_INTPRIO );
 * // enable the service
 * IfxSrc_enable( src );
 * //check for service request flags and clear if they occur
 * if ( IfxSrc_isRequested( src ) == TRUE )
 * {
 *    IfxSrc_clearRequest( src );
 * }
 * if ( IfxSrc_isOverrun( src ) == TRUE )
 * {
 *      IfxSrc_clearOverrun( src );
 * }
 * // Atlast deinitialise the service control
 * IfxSrc_deinit( src );
 * \endcode
 *
 */
static inline void IfxSrc_init(volatile Ifx_SRC_SRCR *src, IfxSrc_Tos typOfService, Ifx_Priority priority);

/** \} */

/******************************************************************************/
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

static inline void IfxSrc_clearOverrun(volatile Ifx_SRC_SRCR *src)
{
    src->B.IOVCLR = 1;
}


static inline void IfxSrc_clearRequest(volatile Ifx_SRC_SRCR *src)
{
    src->B.CLRR = 1;
}


static inline void IfxSrc_deinit(volatile Ifx_SRC_SRCR *src)
{
    src->U = 0;
}


static inline void IfxSrc_disable(volatile Ifx_SRC_SRCR *src)
{
    src->B.SRE = 0;
}


static inline void IfxSrc_enable(volatile Ifx_SRC_SRCR *src)
{
    src->B.SRE = 1;
}


static inline void IfxSrc_init(volatile Ifx_SRC_SRCR *src, IfxSrc_Tos typOfService, Ifx_Priority priority)
{
    src->B.SRPN = priority;
    src->B.TOS  = typOfService;
    IfxSrc_clearRequest(src);
}


static inline boolean IfxSrc_isOverrun(volatile Ifx_SRC_SRCR *src)
{
    return src->B.IOV ? (1u) : (0u);
}


static inline boolean IfxSrc_isRequested(volatile Ifx_SRC_SRCR *src)
{
    return src->B.SRR ? (1u) : (0u);
}


static inline void IfxSrc_setRequest(volatile Ifx_SRC_SRCR *src)
{
    src->B.SETR = 1;
}



#line 58 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Cpu\\Irq\\IfxCpu_Irq.h"
/*******************************************************************************
**                      Type definitions                                     **
*******************************************************************************/

/*******************************************************************************
**                Global Exported variables/constants                         **
*******************************************************************************/

/*******************************************************************************
**         Global Exported macros/inlines/function ptototypes                 **
*******************************************************************************/























/** \addtogroup IfxLld_Cpu_Irq_Usage
 * \{  */
/** \brief API to get type of service of the caller CPU.
 * \param coreId core id of the core
 * \return type of service for the corresponding CPU.
 */
extern IfxSrc_Tos IfxCpu_Irq_getTos(IfxCpu_ResourceCpu coreId);

/** \}  */

/*Documentation */
/** \addtogroup IfxLld_Cpu_Irq_Usage
 * \{
 *
 * This page describes how to use interrupts with application framework.\n
 *
 * \section IfxLld_Cpu_Irq_Terminology Interrupts Terminology:
 * \subsection IfxLld_Cpu_Irq_HWManaged Hardware Managed Interrupt Mechanism.
 * Hardware managed interrupts have static interrupt vector which are defined for each priority separately.
 * These vectors have jump instruction to the interrupt handler.
 *
 * Advantages:\n
 * This mechanism has less interrupt latency time.
 *
 * \subsection IfxLld_Cpu_Irq_SWManaged Software Managed Interrupt Mechanism.
 * Software managed interrupts have single interrupt vector statically defined at vector position 255.
 * This address is assigned to BIV during startup.\n
 * For Tricore, this vector position is important, because whenever an interrupt occurs, with whichever priority,
 * the execution control jumps to this vector position. The code at this vector position will:\n
 * 1) fetch the priority of the targetted interrupt.\n
 * 2) fetch the interrupt handler defined for this priority (this is done by Interrupt handler installation. Refer
 * \ref IfxLld_Cpu_Irq_Step4\n
 * 3) Then call the handler as notmal function call.
 *
 * Advantages:\n
 * This kind of mechanism is useful when project wants to change the handler for an interrupt during runtime.
 *
 * Disadvantages:\n
 * This mechanism has more interrupt latency time.
 *
 * of the interrupt and in tand jumps to the function
 *
 * \section IfxLld_Cpu_Irq_Steps Steps to use Interrupt Mechanism.
 * Dependency: Ifx_Compilers, Ifx_Cpu, Ifx_Src, IfxCpu_Irq\n
 * Following are the steps to use interrupt mechanism.
 *
 * \section IfxLld_Cpu_Irq_Step1 Step1: Define Interrupt priorities.
 * Define priorities of all interrupts with names corresponding to their functionality. It is recommended to define
 * such priority definitions in single header file, because it is easy to detect if ISR priorities are conflicting.
 * In Tricore architecture, two Isrs can't have same priority at same point of time.
 * \note These defines shall be defined without brackets surrounding priority number. (eg. #define PRIO (10) is not allowed)
 *
 * In a user defined file eg. Ifx_IntPrioDef.h, placed in folder: 0_AppSw/Tricore/DemoApp:
 * \code
 * //file: Ifx_IntPrioDef.h.
 * #define IFX_INTPRIO_FUNCT1	1
 * #define IFX_INTPRIO_FUNCT2	2
 * #define IFX_INTPRIO_FUNCT3	5
 * #define IFX_INTPRIO_STM0	8
 * #define IFX_INTPRIO_ADC_FUNC1 10
 * //etc.
 * \endcode
 *
 * \note !! IMPORTANT !!\n As explained above, the definition with closing bracket around priority number as,
 *  #define IFX_INTPRIO_FUNCT1   (1) will cause compilation error. Because linker sections which are constructed
 *  using such information will also get these brackets included. Which look like ".intvec_tc0_(1)" instead of the
 *  expected ".intvec_tc0_1"\n
 *  Linker sections' definitions are predefined statically in .lsl file,
 * for all 255 interrupts, with the format ".intvec_tc<vector number>_<interrupt priority>".
 *
 * \section IfxLld_Cpu_Irq_Step2 Step2: Define Type of interrupt mechanism.
 * \subsection IfxLld_Cpu_Irq_HWManaged_Usage To use Hardware Managed Interrupt Mechanism.
 * Refer \ref IfxLld_Cpu_Irq_HWManaged
 * If project is designed for hardware managed interrupts, this feature is enabled at the file Ifx_Cfg.h, at path:
 * 0_Src/0_AppSw/Config/Common/, as shown below. IFX_USE_SW_MANAGED_INT definition must be undefined (i.e. the
 * statement "#define IFX_USE_SW_MANAGED_INT" shall be commented as below).
 *
 * \code
 * //file: Ifx_Cfg.h
 *
 * //#define IFX_USE_SW_MANAGED_INT
 *
 * \endcode
 *
 * \subsection IfxLld_Cpu_Irq_SWManaged_Usage To use Software Managed Interrupt Mechanism.
 * Refer \ref IfxLld_Cpu_Irq_SWManaged
 * If project is designed for software managed interrupts, this feature is enabled at the file Ifx_Cfg.h, at path:
 * 0_Src/0_AppSw/Config/Common/, as shown below.
 * IFX_USE_SW_MANAGED_INT definition must be defined.
 *
 * \code
 * //file: Ifx_Cfg.h
 *
 * #define IFX_USE_SW_MANAGED_INT
 *
 * \endcode
 *
 * Software managed interrupts must also install the "Interrupt Handlers" Refer \ref IfxLld_Cpu_Irq_Step4
 *
 * \section IfxLld_Cpu_Irq_Step3 Step3: How to define an Interrupt Service routine?
 * Interrupt service routines or interrupt handlers are defined in driver specific files or application specific
 * files.
 *
 * \code
 * //file usercode1.c
 * #include "Compilers.h"		// to get the compiler abstracted macros for interrupt definition
 * #include "Ifx_IntPrioDef.h"	// to get the priority numbers
 *
 * //define an ISR with name Isr_Stm0 with priority defined by IFX_INTPRIO_STM0
 * IFX_INTERRUPT (Isr_Stm0, 0, IFX_INTPRIO_STM0)
 * {
 *  //Isr code here
 * }
 * \endcode
 *
 * \code
 * //file usercode2.c
 * #include "Compilers.h"		// to get the compiler abstracted macros for interrupt definition
 * #include "Ifx_IntPrioDef.h"	// to get the priority numbers
 *
 * //define an ISR with name Isr_Adc_fun1 with priority defined by IFX_INTPRIO_ADC_FUNC1
 * IFX_INTERRUPT (Isr_Adc_fun1, 0, IFX_INTPRIO_ADC_FUNC1)
 * {
 *   //Isr code here
 * }
 * \endcode
 *
 * \section IfxLld_Cpu_Irq_Step4 Step4: How to install Interrupt Service routine/handler?
 * This step is not required for HW managed interrupts.\n
 * Interrupt service routines or interrupt handlers are installed in driver specific files or application specific
 * files
 *
 *  \code
 * //file usermain.c
 * #include "IfxCpu_Irq.h"
 * #include "Ifx_IntPrioDef.h"	// to get the priority numbers
 *
 * void userfunction_init(void)
 * {
 *   //code for user function init
 *   // :
 *   // :
 *   IfxCpu_Irq_installInterruptHandler (Isr_Stm0, IFX_INTPRIO_STM0);
 *   IfxCpu_Irq_installInterruptHandler (Isr_Adc_fun1, IFX_INTPRIO_ADC_FUNC1);
 *
 *   // :
 * }
 *
 * \endcode
 *
 * \section IfxLld_Cpu_Irq_Step5 Step5: Managing the Service Request Node.
 * For the interrupt to get activated, interrupt triggers are needed. These triggers are activated by peripheral modules
 * and corresponding service request node must be\n
 * 1) Configured with correct priority number\n
 * 2) The request node must be enabled\n
 * Refer to \ref IfxLld_Src_Usage
 */

/** \} */

#line 68 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Pms\\Std\\IfxPmsPm.h"

#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Scu\\Std\\IfxScuCcu.h"
/**
 * \file IfxScuCcu.h
 * \brief SCU  basic functionality
 * \ingroup IfxLld_Scu
 *
 * \version iLLD_1_0_1_15_0_1
 * \copyright Copyright (c) 2019 Infineon Technologies AG. All rights reserved.
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 * \defgroup IfxLld_Scu SCU
 * \addtogroup IfxLld_Scu
 * \{
 * \defgroup IfxLld_ScuCcu How to use the Scu Clock driver?
 * \addtogroup IfxLld_ScuCcu
 * \{
 *
 * The Scu Clock control unit driver provides a default configuration for pll and Clock initialisation and set of peripheral clock configuration functions.
 *
 * In the following sections it will be described, how to integrate the driver into the application framework.
 *
 * \section IfxLld_ScuCcu_Std_Preparation Preparation
 * \subsection IfxLld_ScuCcu_Std_Include Include Files
 *
 * Include following header file into your C code:
 * \code
 * #include <Scu/Std/IfxScuCcu.h>
 * \endcode
 *
 * \subsection IfxLld_ScuCcu_Std_Variables Variables
 *
 * Declare the Clock Configuration variables in your C code:
 *
 * \code
 * // used globally
 *
 * // configuration for the PLL  steps
 * static IfxScuCcu_PllStepsConfig IfxScuCcu_testPllConfigSteps[] = {
 *     IFXSCU_CFG_PLL_STEPS
 * };
 *
 * static const IfxScuCcu_FlashWaitstateConfig IfxScuCcu_defaultFlashWaitstateConfig = IFXSCU_CFG_FLASH_WAITSTATE;
 * // Default configuration for the Clock Configuration
 * IfxScuCcu_Config                      IfxScuCcu_testClockConfig = {
 *     // IfxScuCcu_InitialStepConfig: Configuration of first step which is same as internal osc frequency.
 *     IFXSCU_CFG_PLL_INITIAL_STEP,
 *     //IfxScuCcu_PllThrottleConfig: Configuration of PLL throttling.
 *     {
 *         sizeof(IfxScuCcu_defaultPllConfigSteps) / sizeof(IfxScuCcu_PllStepConfig),
 *         IfxScuCcu_defaultPllConfigSteps
 *     },
 *     IFXSCU_CFG_CLK_DISTRIBUTION,
 *     &IfxScuCcu_defaultFlashWaitstateConfig,
 *     &IfxScuCcu_defaultModConfig
 * };
 *
 * \endcode
 *
 * \subsection IfxLld_ScuCcu_Std_Init Module Initialisation
 *
 * The module initialisation can be done in the same function. Here an example:
 * \code
 *
 *        // standard PLL & clock initialisation
 *         IfxScuCcu_init(&IfxScuCcu_testClockConfig);
 * \endcode
 *
 *    The SYS PLL, PER PLL1 , PLL2 and clocks are now initialised based on the XTAL and PLL values configured in Ifx_Cfg.h and are ready for use now!
 *
 * Alternately the PLL and clocks can be initialised using below method which provides greater control on the configuration.
 *
 * \code
 * static const IfxScuCcu_PllStepConfig IfxScuCcu_defaultPllConfigSteps[] = {
 *     {                   //Step 0 Config: 150MHz
 *         (4 - 1),        //uint8 k2Step;
 *         0.000100,       //float32 waitTime;
 *     },
 *     {                   //Step 1 Config: 200MHz
 *         (3 - 1),       //uint8 k2Step;
 *         0.000100,       //float32 waitTime;
 *     },
 *     {                   //Step 2 Config: 300MHz
 *         (2 - 1),        //uint8 k2Step;
 *         0.000100,       //float32 waitTime;
 *     }
 * };
 *     IfxScuCcu_Config        IfxScuCcu_sampleClockConfig;
 *
 *     IfxScuCcu_initConfig(&IfxScuCcu_sampleClockConfig);
 *
 *
 *
 *     IfxScuCcu_sampleClockConfig.pllInitialStepConfig.pllsParameters.pllInputClockSelection = IfxScuCcu_PllInputClockSelection_fOsc0;
 *
 *     //SYS PLL = 300Mhz, XTAL = 20Mhz
 *     IfxScuCcu_sampleClockConfig.pllInitialStepConfig.pllsParameters.sysPllConfig.k2Divider = IfxScuCcu_K2divider_2;
 *     IfxScuCcu_sampleClockConfig.pllInitialStepConfig.pllsParameters.sysPllConfig.nDivider = IfxScuCcu_Ndivider_60;
 *     IfxScuCcu_sampleClockConfig.pllInitialStepConfig.pllsParameters.sysPllConfig.pDivider = IfxScuCcu_Pdivider_2;
 *     IfxScuCcu_sampleClockConfig.pllInitialStepConfig.waitTime = 0.000200F;  // wait time
 *
 *     IfxScuCcu_sampleClockConfig.sysPllThrottleConfig.numOfSteps = sizeof(IfxScuCcu_defaultPllConfigSteps) / sizeof(IfxScuCcu_PllStepConfig); //  step clock incr
 *     IfxScuCcu_sampleClockConfig.sysPllThrottleConfig.pllSteps = IfxScuCcu_defaultPllConfigSteps;
 *
 *     // PER PLL1 = 240Mhz, PERPLL2 = 50Mhz
 *     IfxScuCcu_sampleClockConfig.pllInitialStepConfig.pllsParameters.perPllConfig.k2Divider = IfxScuCcu_K2divider_2;
 *     IfxScuCcu_sampleClockConfig.pllInitialStepConfig.pllsParameters.perPllConfig.k3Divider = IfxScuCcu_K3divider_6;
 *     IfxScuCcu_sampleClockConfig.pllInitialStepConfig.pllsParameters.perPllConfig.k3DividerBypass = 0;
 *     IfxScuCcu_sampleClockConfig.pllInitialStepConfig.pllsParameters.perPllConfig.nDivider = IfxScuCcu_Ndivider_24;
 *     IfxScuCcu_sampleClockConfig.pllInitialStepConfig.pllsParameters.perPllConfig.pDivider = IfxScuCcu_Pdivider_1;
 *
 *     // update CCUCON Config use mask and value as below
 *     IfxScuCcu_sampleClockConfig.clockDistribution.ccucon0.mask =IFXSCU_CFG_CCUCON0_MASK;
 *     IfxScuCcu_sampleClockConfig.clockDistribution.ccucon0.value = IFXSCU_CFG_CCUCON0;
 *
 *     // standard PLL & clock initialisation
 *     IfxScuCcu_init(&IfxScuCcu_sampleClockConfig);
 *
 * \endcode
 *
 * ** Modulation Configuration **
 * The SCU CCU module also provides an option to Frequency Modulate the clock.
 * The Modulation configuration can be done as follows:
 *
 * \code
 *
 * //define your modulation configuration structure:
 *
 *  IFX_CONST IfxScuCcu_Mod_Config IfxScuCcu_SampleModConfig = {
 *          IfxScuCcu_ModEn_disabled,          // disable is default //enable / disable modulation
 *          IfxScuCcu_ModulationAmplitude_0p5, // default 0 value  // specify the modulation amplitude %
 *
 *  }
 *  // put this as part of the CCU configuration:
 *  IfxScuCcu_sampleClockConfig.modulationConfig = &IfxScuCcu_SampleModConfig;
 *
 *  // now initalize the CCU PLL and clock with the init function
 *  IfxScuCcu_init(&IfxScuCcu_sampleClockConfig)
 * \endcode
 *
 * \}
 * \}
 *
 * \defgroup IfxLld_Scu_Std_Ccu Ccu Basic Functionality
 * \ingroup IfxLld_Scu_Std
 * \defgroup IfxLld_Scu_Std_Ccu_Ccu Clock Control Functions
 * \ingroup IfxLld_Scu_Std_Ccu
 * \defgroup IfxLld_Scu_Std_Ccu_Ccu_Operative Clock Control Operative Functions
 * \ingroup IfxLld_Scu_Std_Ccu
 * \defgroup IfxLld_Scu_Std_Ccu_Ccu_Configuration Clock Control Configuration Functions
 * \ingroup IfxLld_Scu_Std_Ccu
 * \defgroup IfxLld_Scu_Std_Ccu_Enum Enumerations
 * \ingroup IfxLld_Scu_Std_Ccu
 */









































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 69 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Pms\\Std\\IfxPmsPm.h"

#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\Infra\\Sfr\\TC38A\\_Reg\\IfxCpu_bf.h"
/**
 * \file IfxCpu_bf.h
 * \brief
 * \copyright Copyright (c) 2020 Infineon Technologies AG. All rights reserved.
 *
 *
 * Version: TC38XA_UM_V1.5.0
 * Specification: TC3xx User Manual V1.5.0
 * MAY BE CHANGED BY USER [yes/no]: No
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * \defgroup IfxSfr_Cpu_Registers_BitfieldsMask Bitfields mask and offset
 * \ingroup IfxSfr_Cpu_Registers
 * 
 */



/******************************************************************************/

/******************************************************************************/

/** \addtogroup IfxSfr_Cpu_Registers_BitfieldsMask
 * \{  */
/** \brief Length for Ifx_CPU_FLASHCON0_Bits.TAG1 */


/** \brief Mask for Ifx_CPU_FLASHCON0_Bits.TAG1 */


/** \brief Offset for Ifx_CPU_FLASHCON0_Bits.TAG1 */


/** \brief Length for Ifx_CPU_FLASHCON0_Bits.TAG2 */


/** \brief Mask for Ifx_CPU_FLASHCON0_Bits.TAG2 */


/** \brief Offset for Ifx_CPU_FLASHCON0_Bits.TAG2 */


/** \brief Length for Ifx_CPU_FLASHCON0_Bits.TAG3 */


/** \brief Mask for Ifx_CPU_FLASHCON0_Bits.TAG3 */


/** \brief Offset for Ifx_CPU_FLASHCON0_Bits.TAG3 */


/** \brief Length for Ifx_CPU_FLASHCON0_Bits.TAG4 */


/** \brief Mask for Ifx_CPU_FLASHCON0_Bits.TAG4 */


/** \brief Offset for Ifx_CPU_FLASHCON0_Bits.TAG4 */


/** \brief Length for Ifx_CPU_FLASHCON1_Bits.STALL */


/** \brief Mask for Ifx_CPU_FLASHCON1_Bits.STALL */


/** \brief Offset for Ifx_CPU_FLASHCON1_Bits.STALL */


/** \brief Length for Ifx_CPU_FLASHCON1_Bits.MASKUECC */


/** \brief Mask for Ifx_CPU_FLASHCON1_Bits.MASKUECC */


/** \brief Offset for Ifx_CPU_FLASHCON1_Bits.MASKUECC */


/** \brief Length for Ifx_CPU_FLASHCON2_Bits.RECDIS */


/** \brief Mask for Ifx_CPU_FLASHCON2_Bits.RECDIS */


/** \brief Offset for Ifx_CPU_FLASHCON2_Bits.RECDIS */


/** \brief Length for Ifx_CPU_FLASHCON2_Bits.ECCCORDIS */


/** \brief Mask for Ifx_CPU_FLASHCON2_Bits.ECCCORDIS */


/** \brief Offset for Ifx_CPU_FLASHCON2_Bits.ECCCORDIS */


/** \brief Length for Ifx_CPU_FLASHCON2_Bits.HMARGIN */


/** \brief Mask for Ifx_CPU_FLASHCON2_Bits.HMARGIN */


/** \brief Offset for Ifx_CPU_FLASHCON2_Bits.HMARGIN */


/** \brief Length for Ifx_CPU_FLASHCON2_Bits.MSEL */


/** \brief Mask for Ifx_CPU_FLASHCON2_Bits.MSEL */


/** \brief Offset for Ifx_CPU_FLASHCON2_Bits.MSEL */


/** \brief Length for Ifx_CPU_FLASHCON2_Bits.ECCSCLR */


/** \brief Mask for Ifx_CPU_FLASHCON2_Bits.ECCSCLR */


/** \brief Offset for Ifx_CPU_FLASHCON2_Bits.ECCSCLR */


/** \brief Length for Ifx_CPU_FLASHCON2_Bits.SBABCLR */


/** \brief Mask for Ifx_CPU_FLASHCON2_Bits.SBABCLR */


/** \brief Offset for Ifx_CPU_FLASHCON2_Bits.SBABCLR */


/** \brief Length for Ifx_CPU_FLASHCON2_Bits.DBABCLR */


/** \brief Mask for Ifx_CPU_FLASHCON2_Bits.DBABCLR */


/** \brief Offset for Ifx_CPU_FLASHCON2_Bits.DBABCLR */


/** \brief Length for Ifx_CPU_FLASHCON2_Bits.MBABCLR */


/** \brief Mask for Ifx_CPU_FLASHCON2_Bits.MBABCLR */


/** \brief Offset for Ifx_CPU_FLASHCON2_Bits.MBABCLR */


/** \brief Length for Ifx_CPU_FLASHCON2_Bits.ZBABCLR */


/** \brief Mask for Ifx_CPU_FLASHCON2_Bits.ZBABCLR */


/** \brief Offset for Ifx_CPU_FLASHCON2_Bits.ZBABCLR */


/** \brief Length for Ifx_CPU_FLASHCON3_Bits.ECCERRINJ */


/** \brief Mask for Ifx_CPU_FLASHCON3_Bits.ECCERRINJ */


/** \brief Offset for Ifx_CPU_FLASHCON3_Bits.ECCERRINJ */


/** \brief Length for Ifx_CPU_FLASHCON3_Bits.EDCERRINJ */


/** \brief Mask for Ifx_CPU_FLASHCON3_Bits.EDCERRINJ */


/** \brief Offset for Ifx_CPU_FLASHCON3_Bits.EDCERRINJ */


/** \brief Length for Ifx_CPU_FLASHCON3_Bits.SBABERRINJ */


/** \brief Mask for Ifx_CPU_FLASHCON3_Bits.SBABERRINJ */


/** \brief Offset for Ifx_CPU_FLASHCON3_Bits.SBABERRINJ */


/** \brief Length for Ifx_CPU_FLASHCON3_Bits.DBABERRINJ */


/** \brief Mask for Ifx_CPU_FLASHCON3_Bits.DBABERRINJ */


/** \brief Offset for Ifx_CPU_FLASHCON3_Bits.DBABERRINJ */


/** \brief Length for Ifx_CPU_FLASHCON3_Bits.MBABERRINJ */


/** \brief Mask for Ifx_CPU_FLASHCON3_Bits.MBABERRINJ */


/** \brief Offset for Ifx_CPU_FLASHCON3_Bits.MBABERRINJ */


/** \brief Length for Ifx_CPU_FLASHCON3_Bits.ZBABERRINJ */


/** \brief Mask for Ifx_CPU_FLASHCON3_Bits.ZBABERRINJ */


/** \brief Offset for Ifx_CPU_FLASHCON3_Bits.ZBABERRINJ */


/** \brief Length for Ifx_CPU_FLASHCON3_Bits.SBERERRINJ */


/** \brief Mask for Ifx_CPU_FLASHCON3_Bits.SBERERRINJ */


/** \brief Offset for Ifx_CPU_FLASHCON3_Bits.SBERERRINJ */


/** \brief Length for Ifx_CPU_FLASHCON3_Bits.DBERERRINJ */


/** \brief Mask for Ifx_CPU_FLASHCON3_Bits.DBERERRINJ */


/** \brief Offset for Ifx_CPU_FLASHCON3_Bits.DBERERRINJ */


/** \brief Length for Ifx_CPU_FLASHCON3_Bits.NVMCERRINJ */


/** \brief Mask for Ifx_CPU_FLASHCON3_Bits.NVMCERRINJ */


/** \brief Offset for Ifx_CPU_FLASHCON3_Bits.NVMCERRINJ */


/** \brief Length for Ifx_CPU_FLASHCON3_Bits.FLCONERRINJ */


/** \brief Mask for Ifx_CPU_FLASHCON3_Bits.FLCONERRINJ */


/** \brief Offset for Ifx_CPU_FLASHCON3_Bits.FLCONERRINJ */


/** \brief Length for Ifx_CPU_FLASHCON4_Bits.DDIS */


/** \brief Mask for Ifx_CPU_FLASHCON4_Bits.DDIS */


/** \brief Offset for Ifx_CPU_FLASHCON4_Bits.DDIS */


/** \brief Length for Ifx_CPU_KRST0_Bits.RST */


/** \brief Mask for Ifx_CPU_KRST0_Bits.RST */


/** \brief Offset for Ifx_CPU_KRST0_Bits.RST */


/** \brief Length for Ifx_CPU_KRST0_Bits.RSTSTAT */


/** \brief Mask for Ifx_CPU_KRST0_Bits.RSTSTAT */


/** \brief Offset for Ifx_CPU_KRST0_Bits.RSTSTAT */


/** \brief Length for Ifx_CPU_KRST1_Bits.RST */


/** \brief Mask for Ifx_CPU_KRST1_Bits.RST */


/** \brief Offset for Ifx_CPU_KRST1_Bits.RST */


/** \brief Length for Ifx_CPU_KRSTCLR_Bits.CLR */


/** \brief Mask for Ifx_CPU_KRSTCLR_Bits.CLR */


/** \brief Offset for Ifx_CPU_KRSTCLR_Bits.CLR */


/** \brief Length for Ifx_CPU_RGN_LA_Bits.ADDR */


/** \brief Mask for Ifx_CPU_RGN_LA_Bits.ADDR */


/** \brief Offset for Ifx_CPU_RGN_LA_Bits.ADDR */


/** \brief Length for Ifx_CPU_RGN_UA_Bits.ADDR */


/** \brief Mask for Ifx_CPU_RGN_UA_Bits.ADDR */


/** \brief Offset for Ifx_CPU_RGN_UA_Bits.ADDR */


/** \brief Length for Ifx_CPU_RGN_ACCENA_Bits.EN0 */


/** \brief Mask for Ifx_CPU_RGN_ACCENA_Bits.EN0 */


/** \brief Offset for Ifx_CPU_RGN_ACCENA_Bits.EN0 */


/** \brief Length for Ifx_CPU_RGN_ACCENA_Bits.EN1 */


/** \brief Mask for Ifx_CPU_RGN_ACCENA_Bits.EN1 */


/** \brief Offset for Ifx_CPU_RGN_ACCENA_Bits.EN1 */


/** \brief Length for Ifx_CPU_RGN_ACCENA_Bits.EN2 */


/** \brief Mask for Ifx_CPU_RGN_ACCENA_Bits.EN2 */


/** \brief Offset for Ifx_CPU_RGN_ACCENA_Bits.EN2 */


/** \brief Length for Ifx_CPU_RGN_ACCENA_Bits.EN3 */


/** \brief Mask for Ifx_CPU_RGN_ACCENA_Bits.EN3 */


/** \brief Offset for Ifx_CPU_RGN_ACCENA_Bits.EN3 */


/** \brief Length for Ifx_CPU_RGN_ACCENA_Bits.EN4 */


/** \brief Mask for Ifx_CPU_RGN_ACCENA_Bits.EN4 */


/** \brief Offset for Ifx_CPU_RGN_ACCENA_Bits.EN4 */


/** \brief Length for Ifx_CPU_RGN_ACCENA_Bits.EN5 */


/** \brief Mask for Ifx_CPU_RGN_ACCENA_Bits.EN5 */


/** \brief Offset for Ifx_CPU_RGN_ACCENA_Bits.EN5 */


/** \brief Length for Ifx_CPU_RGN_ACCENA_Bits.EN6 */


/** \brief Mask for Ifx_CPU_RGN_ACCENA_Bits.EN6 */


/** \brief Offset for Ifx_CPU_RGN_ACCENA_Bits.EN6 */


/** \brief Length for Ifx_CPU_RGN_ACCENA_Bits.EN7 */


/** \brief Mask for Ifx_CPU_RGN_ACCENA_Bits.EN7 */


/** \brief Offset for Ifx_CPU_RGN_ACCENA_Bits.EN7 */


/** \brief Length for Ifx_CPU_RGN_ACCENA_Bits.EN8 */


/** \brief Mask for Ifx_CPU_RGN_ACCENA_Bits.EN8 */


/** \brief Offset for Ifx_CPU_RGN_ACCENA_Bits.EN8 */


/** \brief Length for Ifx_CPU_RGN_ACCENA_Bits.EN9 */


/** \brief Mask for Ifx_CPU_RGN_ACCENA_Bits.EN9 */


/** \brief Offset for Ifx_CPU_RGN_ACCENA_Bits.EN9 */


/** \brief Length for Ifx_CPU_RGN_ACCENA_Bits.EN10 */


/** \brief Mask for Ifx_CPU_RGN_ACCENA_Bits.EN10 */


/** \brief Offset for Ifx_CPU_RGN_ACCENA_Bits.EN10 */


/** \brief Length for Ifx_CPU_RGN_ACCENA_Bits.EN11 */


/** \brief Mask for Ifx_CPU_RGN_ACCENA_Bits.EN11 */


/** \brief Offset for Ifx_CPU_RGN_ACCENA_Bits.EN11 */


/** \brief Length for Ifx_CPU_RGN_ACCENA_Bits.EN12 */


/** \brief Mask for Ifx_CPU_RGN_ACCENA_Bits.EN12 */


/** \brief Offset for Ifx_CPU_RGN_ACCENA_Bits.EN12 */


/** \brief Length for Ifx_CPU_RGN_ACCENA_Bits.EN13 */


/** \brief Mask for Ifx_CPU_RGN_ACCENA_Bits.EN13 */


/** \brief Offset for Ifx_CPU_RGN_ACCENA_Bits.EN13 */


/** \brief Length for Ifx_CPU_RGN_ACCENA_Bits.EN14 */


/** \brief Mask for Ifx_CPU_RGN_ACCENA_Bits.EN14 */


/** \brief Offset for Ifx_CPU_RGN_ACCENA_Bits.EN14 */


/** \brief Length for Ifx_CPU_RGN_ACCENA_Bits.EN15 */


/** \brief Mask for Ifx_CPU_RGN_ACCENA_Bits.EN15 */


/** \brief Offset for Ifx_CPU_RGN_ACCENA_Bits.EN15 */


/** \brief Length for Ifx_CPU_RGN_ACCENA_Bits.EN16 */


/** \brief Mask for Ifx_CPU_RGN_ACCENA_Bits.EN16 */


/** \brief Offset for Ifx_CPU_RGN_ACCENA_Bits.EN16 */


/** \brief Length for Ifx_CPU_RGN_ACCENA_Bits.EN17 */


/** \brief Mask for Ifx_CPU_RGN_ACCENA_Bits.EN17 */


/** \brief Offset for Ifx_CPU_RGN_ACCENA_Bits.EN17 */


/** \brief Length for Ifx_CPU_RGN_ACCENA_Bits.EN18 */


/** \brief Mask for Ifx_CPU_RGN_ACCENA_Bits.EN18 */


/** \brief Offset for Ifx_CPU_RGN_ACCENA_Bits.EN18 */


/** \brief Length for Ifx_CPU_RGN_ACCENA_Bits.EN19 */


/** \brief Mask for Ifx_CPU_RGN_ACCENA_Bits.EN19 */


/** \brief Offset for Ifx_CPU_RGN_ACCENA_Bits.EN19 */


/** \brief Length for Ifx_CPU_RGN_ACCENA_Bits.EN20 */


/** \brief Mask for Ifx_CPU_RGN_ACCENA_Bits.EN20 */


/** \brief Offset for Ifx_CPU_RGN_ACCENA_Bits.EN20 */


/** \brief Length for Ifx_CPU_RGN_ACCENA_Bits.EN21 */


/** \brief Mask for Ifx_CPU_RGN_ACCENA_Bits.EN21 */


/** \brief Offset for Ifx_CPU_RGN_ACCENA_Bits.EN21 */


/** \brief Length for Ifx_CPU_RGN_ACCENA_Bits.EN22 */


/** \brief Mask for Ifx_CPU_RGN_ACCENA_Bits.EN22 */


/** \brief Offset for Ifx_CPU_RGN_ACCENA_Bits.EN22 */


/** \brief Length for Ifx_CPU_RGN_ACCENA_Bits.EN23 */


/** \brief Mask for Ifx_CPU_RGN_ACCENA_Bits.EN23 */


/** \brief Offset for Ifx_CPU_RGN_ACCENA_Bits.EN23 */


/** \brief Length for Ifx_CPU_RGN_ACCENA_Bits.EN24 */


/** \brief Mask for Ifx_CPU_RGN_ACCENA_Bits.EN24 */


/** \brief Offset for Ifx_CPU_RGN_ACCENA_Bits.EN24 */


/** \brief Length for Ifx_CPU_RGN_ACCENA_Bits.EN25 */


/** \brief Mask for Ifx_CPU_RGN_ACCENA_Bits.EN25 */


/** \brief Offset for Ifx_CPU_RGN_ACCENA_Bits.EN25 */


/** \brief Length for Ifx_CPU_RGN_ACCENA_Bits.EN26 */


/** \brief Mask for Ifx_CPU_RGN_ACCENA_Bits.EN26 */


/** \brief Offset for Ifx_CPU_RGN_ACCENA_Bits.EN26 */


/** \brief Length for Ifx_CPU_RGN_ACCENA_Bits.EN27 */


/** \brief Mask for Ifx_CPU_RGN_ACCENA_Bits.EN27 */


/** \brief Offset for Ifx_CPU_RGN_ACCENA_Bits.EN27 */


/** \brief Length for Ifx_CPU_RGN_ACCENA_Bits.EN28 */


/** \brief Mask for Ifx_CPU_RGN_ACCENA_Bits.EN28 */


/** \brief Offset for Ifx_CPU_RGN_ACCENA_Bits.EN28 */


/** \brief Length for Ifx_CPU_RGN_ACCENA_Bits.EN29 */


/** \brief Mask for Ifx_CPU_RGN_ACCENA_Bits.EN29 */


/** \brief Offset for Ifx_CPU_RGN_ACCENA_Bits.EN29 */


/** \brief Length for Ifx_CPU_RGN_ACCENA_Bits.EN30 */


/** \brief Mask for Ifx_CPU_RGN_ACCENA_Bits.EN30 */


/** \brief Offset for Ifx_CPU_RGN_ACCENA_Bits.EN30 */


/** \brief Length for Ifx_CPU_RGN_ACCENA_Bits.EN31 */


/** \brief Mask for Ifx_CPU_RGN_ACCENA_Bits.EN31 */


/** \brief Offset for Ifx_CPU_RGN_ACCENA_Bits.EN31 */


/** \brief Length for Ifx_CPU_RGN_ACCENB_Bits.EN32 */


/** \brief Mask for Ifx_CPU_RGN_ACCENB_Bits.EN32 */


/** \brief Offset for Ifx_CPU_RGN_ACCENB_Bits.EN32 */


/** \brief Length for Ifx_CPU_RGN_ACCENB_Bits.EN33 */


/** \brief Mask for Ifx_CPU_RGN_ACCENB_Bits.EN33 */


/** \brief Offset for Ifx_CPU_RGN_ACCENB_Bits.EN33 */


/** \brief Length for Ifx_CPU_RGN_ACCENB_Bits.EN34 */


/** \brief Mask for Ifx_CPU_RGN_ACCENB_Bits.EN34 */


/** \brief Offset for Ifx_CPU_RGN_ACCENB_Bits.EN34 */


/** \brief Length for Ifx_CPU_RGN_ACCENB_Bits.EN35 */


/** \brief Mask for Ifx_CPU_RGN_ACCENB_Bits.EN35 */


/** \brief Offset for Ifx_CPU_RGN_ACCENB_Bits.EN35 */


/** \brief Length for Ifx_CPU_RGN_ACCENB_Bits.EN36 */


/** \brief Mask for Ifx_CPU_RGN_ACCENB_Bits.EN36 */


/** \brief Offset for Ifx_CPU_RGN_ACCENB_Bits.EN36 */


/** \brief Length for Ifx_CPU_RGN_ACCENB_Bits.EN37 */


/** \brief Mask for Ifx_CPU_RGN_ACCENB_Bits.EN37 */


/** \brief Offset for Ifx_CPU_RGN_ACCENB_Bits.EN37 */


/** \brief Length for Ifx_CPU_RGN_ACCENB_Bits.EN38 */


/** \brief Mask for Ifx_CPU_RGN_ACCENB_Bits.EN38 */


/** \brief Offset for Ifx_CPU_RGN_ACCENB_Bits.EN38 */


/** \brief Length for Ifx_CPU_RGN_ACCENB_Bits.EN39 */


/** \brief Mask for Ifx_CPU_RGN_ACCENB_Bits.EN39 */


/** \brief Offset for Ifx_CPU_RGN_ACCENB_Bits.EN39 */


/** \brief Length for Ifx_CPU_RGN_ACCENB_Bits.EN40 */


/** \brief Mask for Ifx_CPU_RGN_ACCENB_Bits.EN40 */


/** \brief Offset for Ifx_CPU_RGN_ACCENB_Bits.EN40 */


/** \brief Length for Ifx_CPU_RGN_ACCENB_Bits.EN41 */


/** \brief Mask for Ifx_CPU_RGN_ACCENB_Bits.EN41 */


/** \brief Offset for Ifx_CPU_RGN_ACCENB_Bits.EN41 */


/** \brief Length for Ifx_CPU_RGN_ACCENB_Bits.EN42 */


/** \brief Mask for Ifx_CPU_RGN_ACCENB_Bits.EN42 */


/** \brief Offset for Ifx_CPU_RGN_ACCENB_Bits.EN42 */


/** \brief Length for Ifx_CPU_RGN_ACCENB_Bits.EN43 */


/** \brief Mask for Ifx_CPU_RGN_ACCENB_Bits.EN43 */


/** \brief Offset for Ifx_CPU_RGN_ACCENB_Bits.EN43 */


/** \brief Length for Ifx_CPU_RGN_ACCENB_Bits.EN44 */


/** \brief Mask for Ifx_CPU_RGN_ACCENB_Bits.EN44 */


/** \brief Offset for Ifx_CPU_RGN_ACCENB_Bits.EN44 */


/** \brief Length for Ifx_CPU_RGN_ACCENB_Bits.EN45 */


/** \brief Mask for Ifx_CPU_RGN_ACCENB_Bits.EN45 */


/** \brief Offset for Ifx_CPU_RGN_ACCENB_Bits.EN45 */


/** \brief Length for Ifx_CPU_RGN_ACCENB_Bits.EN46 */


/** \brief Mask for Ifx_CPU_RGN_ACCENB_Bits.EN46 */


/** \brief Offset for Ifx_CPU_RGN_ACCENB_Bits.EN46 */


/** \brief Length for Ifx_CPU_RGN_ACCENB_Bits.EN47 */


/** \brief Mask for Ifx_CPU_RGN_ACCENB_Bits.EN47 */


/** \brief Offset for Ifx_CPU_RGN_ACCENB_Bits.EN47 */


/** \brief Length for Ifx_CPU_RGN_ACCENB_Bits.EN48 */


/** \brief Mask for Ifx_CPU_RGN_ACCENB_Bits.EN48 */


/** \brief Offset for Ifx_CPU_RGN_ACCENB_Bits.EN48 */


/** \brief Length for Ifx_CPU_RGN_ACCENB_Bits.EN49 */


/** \brief Mask for Ifx_CPU_RGN_ACCENB_Bits.EN49 */


/** \brief Offset for Ifx_CPU_RGN_ACCENB_Bits.EN49 */


/** \brief Length for Ifx_CPU_RGN_ACCENB_Bits.EN50 */


/** \brief Mask for Ifx_CPU_RGN_ACCENB_Bits.EN50 */


/** \brief Offset for Ifx_CPU_RGN_ACCENB_Bits.EN50 */


/** \brief Length for Ifx_CPU_RGN_ACCENB_Bits.EN51 */


/** \brief Mask for Ifx_CPU_RGN_ACCENB_Bits.EN51 */


/** \brief Offset for Ifx_CPU_RGN_ACCENB_Bits.EN51 */


/** \brief Length for Ifx_CPU_RGN_ACCENB_Bits.EN52 */


/** \brief Mask for Ifx_CPU_RGN_ACCENB_Bits.EN52 */


/** \brief Offset for Ifx_CPU_RGN_ACCENB_Bits.EN52 */


/** \brief Length for Ifx_CPU_RGN_ACCENB_Bits.EN53 */


/** \brief Mask for Ifx_CPU_RGN_ACCENB_Bits.EN53 */


/** \brief Offset for Ifx_CPU_RGN_ACCENB_Bits.EN53 */


/** \brief Length for Ifx_CPU_RGN_ACCENB_Bits.EN54 */


/** \brief Mask for Ifx_CPU_RGN_ACCENB_Bits.EN54 */


/** \brief Offset for Ifx_CPU_RGN_ACCENB_Bits.EN54 */


/** \brief Length for Ifx_CPU_RGN_ACCENB_Bits.EN55 */


/** \brief Mask for Ifx_CPU_RGN_ACCENB_Bits.EN55 */


/** \brief Offset for Ifx_CPU_RGN_ACCENB_Bits.EN55 */


/** \brief Length for Ifx_CPU_RGN_ACCENB_Bits.EN56 */


/** \brief Mask for Ifx_CPU_RGN_ACCENB_Bits.EN56 */


/** \brief Offset for Ifx_CPU_RGN_ACCENB_Bits.EN56 */


/** \brief Length for Ifx_CPU_RGN_ACCENB_Bits.EN57 */


/** \brief Mask for Ifx_CPU_RGN_ACCENB_Bits.EN57 */


/** \brief Offset for Ifx_CPU_RGN_ACCENB_Bits.EN57 */


/** \brief Length for Ifx_CPU_RGN_ACCENB_Bits.EN58 */


/** \brief Mask for Ifx_CPU_RGN_ACCENB_Bits.EN58 */


/** \brief Offset for Ifx_CPU_RGN_ACCENB_Bits.EN58 */


/** \brief Length for Ifx_CPU_RGN_ACCENB_Bits.EN59 */


/** \brief Mask for Ifx_CPU_RGN_ACCENB_Bits.EN59 */


/** \brief Offset for Ifx_CPU_RGN_ACCENB_Bits.EN59 */


/** \brief Length for Ifx_CPU_RGN_ACCENB_Bits.EN60 */


/** \brief Mask for Ifx_CPU_RGN_ACCENB_Bits.EN60 */


/** \brief Offset for Ifx_CPU_RGN_ACCENB_Bits.EN60 */


/** \brief Length for Ifx_CPU_RGN_ACCENB_Bits.EN61 */


/** \brief Mask for Ifx_CPU_RGN_ACCENB_Bits.EN61 */


/** \brief Offset for Ifx_CPU_RGN_ACCENB_Bits.EN61 */


/** \brief Length for Ifx_CPU_RGN_ACCENB_Bits.EN62 */


/** \brief Mask for Ifx_CPU_RGN_ACCENB_Bits.EN62 */


/** \brief Offset for Ifx_CPU_RGN_ACCENB_Bits.EN62 */


/** \brief Length for Ifx_CPU_RGN_ACCENB_Bits.EN63 */


/** \brief Mask for Ifx_CPU_RGN_ACCENB_Bits.EN63 */


/** \brief Offset for Ifx_CPU_RGN_ACCENB_Bits.EN63 */


/** \brief Length for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN0 */


/** \brief Mask for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN0 */


/** \brief Offset for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN0 */


/** \brief Length for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN1 */


/** \brief Mask for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN1 */


/** \brief Offset for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN1 */


/** \brief Length for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN2 */


/** \brief Mask for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN2 */


/** \brief Offset for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN2 */


/** \brief Length for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN3 */


/** \brief Mask for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN3 */


/** \brief Offset for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN3 */


/** \brief Length for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN4 */


/** \brief Mask for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN4 */


/** \brief Offset for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN4 */


/** \brief Length for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN5 */


/** \brief Mask for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN5 */


/** \brief Offset for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN5 */


/** \brief Length for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN6 */


/** \brief Mask for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN6 */


/** \brief Offset for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN6 */


/** \brief Length for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN7 */


/** \brief Mask for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN7 */


/** \brief Offset for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN7 */


/** \brief Length for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN8 */


/** \brief Mask for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN8 */


/** \brief Offset for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN8 */


/** \brief Length for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN9 */


/** \brief Mask for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN9 */


/** \brief Offset for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN9 */


/** \brief Length for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN10 */


/** \brief Mask for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN10 */


/** \brief Offset for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN10 */


/** \brief Length for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN11 */


/** \brief Mask for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN11 */


/** \brief Offset for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN11 */


/** \brief Length for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN12 */


/** \brief Mask for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN12 */


/** \brief Offset for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN12 */


/** \brief Length for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN13 */


/** \brief Mask for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN13 */


/** \brief Offset for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN13 */


/** \brief Length for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN14 */


/** \brief Mask for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN14 */


/** \brief Offset for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN14 */


/** \brief Length for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN15 */


/** \brief Mask for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN15 */


/** \brief Offset for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN15 */


/** \brief Length for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN16 */


/** \brief Mask for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN16 */


/** \brief Offset for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN16 */


/** \brief Length for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN17 */


/** \brief Mask for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN17 */


/** \brief Offset for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN17 */


/** \brief Length for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN18 */


/** \brief Mask for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN18 */


/** \brief Offset for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN18 */


/** \brief Length for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN19 */


/** \brief Mask for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN19 */


/** \brief Offset for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN19 */


/** \brief Length for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN20 */


/** \brief Mask for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN20 */


/** \brief Offset for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN20 */


/** \brief Length for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN21 */


/** \brief Mask for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN21 */


/** \brief Offset for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN21 */


/** \brief Length for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN22 */


/** \brief Mask for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN22 */


/** \brief Offset for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN22 */


/** \brief Length for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN23 */


/** \brief Mask for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN23 */


/** \brief Offset for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN23 */


/** \brief Length for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN24 */


/** \brief Mask for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN24 */


/** \brief Offset for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN24 */


/** \brief Length for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN25 */


/** \brief Mask for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN25 */


/** \brief Offset for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN25 */


/** \brief Length for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN26 */


/** \brief Mask for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN26 */


/** \brief Offset for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN26 */


/** \brief Length for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN27 */


/** \brief Mask for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN27 */


/** \brief Offset for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN27 */


/** \brief Length for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN28 */


/** \brief Mask for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN28 */


/** \brief Offset for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN28 */


/** \brief Length for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN29 */


/** \brief Mask for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN29 */


/** \brief Offset for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN29 */


/** \brief Length for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN30 */


/** \brief Mask for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN30 */


/** \brief Offset for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN30 */


/** \brief Length for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN31 */


/** \brief Mask for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN31 */


/** \brief Offset for Ifx_CPU_SPR_SPROT_RGNACCENA_R_Bits.EN31 */


/** \brief Length for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN32 */


/** \brief Mask for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN32 */


/** \brief Offset for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN32 */


/** \brief Length for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN33 */


/** \brief Mask for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN33 */


/** \brief Offset for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN33 */


/** \brief Length for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN34 */


/** \brief Mask for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN34 */


/** \brief Offset for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN34 */


/** \brief Length for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN35 */


/** \brief Mask for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN35 */


/** \brief Offset for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN35 */


/** \brief Length for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN36 */


/** \brief Mask for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN36 */


/** \brief Offset for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN36 */


/** \brief Length for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN37 */


/** \brief Mask for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN37 */


/** \brief Offset for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN37 */


/** \brief Length for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN38 */


/** \brief Mask for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN38 */


/** \brief Offset for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN38 */


/** \brief Length for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN39 */


/** \brief Mask for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN39 */


/** \brief Offset for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN39 */


/** \brief Length for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN40 */


/** \brief Mask for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN40 */


/** \brief Offset for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN40 */


/** \brief Length for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN41 */


/** \brief Mask for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN41 */


/** \brief Offset for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN41 */


/** \brief Length for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN42 */


/** \brief Mask for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN42 */


/** \brief Offset for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN42 */


/** \brief Length for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN43 */


/** \brief Mask for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN43 */


/** \brief Offset for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN43 */


/** \brief Length for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN44 */


/** \brief Mask for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN44 */


/** \brief Offset for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN44 */


/** \brief Length for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN45 */


/** \brief Mask for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN45 */


/** \brief Offset for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN45 */


/** \brief Length for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN46 */


/** \brief Mask for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN46 */


/** \brief Offset for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN46 */


/** \brief Length for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN47 */


/** \brief Mask for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN47 */


/** \brief Offset for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN47 */


/** \brief Length for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN48 */


/** \brief Mask for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN48 */


/** \brief Offset for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN48 */


/** \brief Length for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN49 */


/** \brief Mask for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN49 */


/** \brief Offset for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN49 */


/** \brief Length for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN50 */


/** \brief Mask for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN50 */


/** \brief Offset for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN50 */


/** \brief Length for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN51 */


/** \brief Mask for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN51 */


/** \brief Offset for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN51 */


/** \brief Length for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN52 */


/** \brief Mask for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN52 */


/** \brief Offset for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN52 */


/** \brief Length for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN53 */


/** \brief Mask for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN53 */


/** \brief Offset for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN53 */


/** \brief Length for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN54 */


/** \brief Mask for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN54 */


/** \brief Offset for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN54 */


/** \brief Length for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN55 */


/** \brief Mask for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN55 */


/** \brief Offset for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN55 */


/** \brief Length for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN56 */


/** \brief Mask for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN56 */


/** \brief Offset for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN56 */


/** \brief Length for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN57 */


/** \brief Mask for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN57 */


/** \brief Offset for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN57 */


/** \brief Length for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN58 */


/** \brief Mask for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN58 */


/** \brief Offset for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN58 */


/** \brief Length for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN59 */


/** \brief Mask for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN59 */


/** \brief Offset for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN59 */


/** \brief Length for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN60 */


/** \brief Mask for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN60 */


/** \brief Offset for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN60 */


/** \brief Length for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN61 */


/** \brief Mask for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN61 */


/** \brief Offset for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN61 */


/** \brief Length for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN62 */


/** \brief Mask for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN62 */


/** \brief Offset for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN62 */


/** \brief Length for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN63 */


/** \brief Mask for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN63 */


/** \brief Offset for Ifx_CPU_SPR_SPROT_RGNACCENB_R_Bits.EN63 */


/** \brief Length for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN0 */


/** \brief Mask for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN0 */


/** \brief Offset for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN0 */


/** \brief Length for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN1 */


/** \brief Mask for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN1 */


/** \brief Offset for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN1 */


/** \brief Length for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN2 */


/** \brief Mask for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN2 */


/** \brief Offset for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN2 */


/** \brief Length for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN3 */


/** \brief Mask for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN3 */


/** \brief Offset for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN3 */


/** \brief Length for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN4 */


/** \brief Mask for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN4 */


/** \brief Offset for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN4 */


/** \brief Length for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN5 */


/** \brief Mask for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN5 */


/** \brief Offset for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN5 */


/** \brief Length for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN6 */


/** \brief Mask for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN6 */


/** \brief Offset for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN6 */


/** \brief Length for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN7 */


/** \brief Mask for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN7 */


/** \brief Offset for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN7 */


/** \brief Length for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN8 */


/** \brief Mask for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN8 */


/** \brief Offset for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN8 */


/** \brief Length for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN9 */


/** \brief Mask for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN9 */


/** \brief Offset for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN9 */


/** \brief Length for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN10 */


/** \brief Mask for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN10 */


/** \brief Offset for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN10 */


/** \brief Length for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN11 */


/** \brief Mask for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN11 */


/** \brief Offset for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN11 */


/** \brief Length for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN12 */


/** \brief Mask for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN12 */


/** \brief Offset for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN12 */


/** \brief Length for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN13 */


/** \brief Mask for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN13 */


/** \brief Offset for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN13 */


/** \brief Length for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN14 */


/** \brief Mask for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN14 */


/** \brief Offset for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN14 */


/** \brief Length for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN15 */


/** \brief Mask for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN15 */


/** \brief Offset for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN15 */


/** \brief Length for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN16 */


/** \brief Mask for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN16 */


/** \brief Offset for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN16 */


/** \brief Length for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN17 */


/** \brief Mask for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN17 */


/** \brief Offset for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN17 */


/** \brief Length for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN18 */


/** \brief Mask for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN18 */


/** \brief Offset for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN18 */


/** \brief Length for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN19 */


/** \brief Mask for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN19 */


/** \brief Offset for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN19 */


/** \brief Length for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN20 */


/** \brief Mask for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN20 */


/** \brief Offset for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN20 */


/** \brief Length for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN21 */


/** \brief Mask for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN21 */


/** \brief Offset for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN21 */


/** \brief Length for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN22 */


/** \brief Mask for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN22 */


/** \brief Offset for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN22 */


/** \brief Length for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN23 */


/** \brief Mask for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN23 */


/** \brief Offset for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN23 */


/** \brief Length for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN24 */


/** \brief Mask for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN24 */


/** \brief Offset for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN24 */


/** \brief Length for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN25 */


/** \brief Mask for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN25 */


/** \brief Offset for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN25 */


/** \brief Length for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN26 */


/** \brief Mask for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN26 */


/** \brief Offset for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN26 */


/** \brief Length for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN27 */


/** \brief Mask for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN27 */


/** \brief Offset for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN27 */


/** \brief Length for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN28 */


/** \brief Mask for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN28 */


/** \brief Offset for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN28 */


/** \brief Length for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN29 */


/** \brief Mask for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN29 */


/** \brief Offset for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN29 */


/** \brief Length for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN30 */


/** \brief Mask for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN30 */


/** \brief Offset for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN30 */


/** \brief Length for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN31 */


/** \brief Mask for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN31 */


/** \brief Offset for Ifx_CPU_SFR_SPROT_ACCENA_W_Bits.EN31 */


/** \brief Length for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN32 */


/** \brief Mask for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN32 */


/** \brief Offset for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN32 */


/** \brief Length for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN33 */


/** \brief Mask for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN33 */


/** \brief Offset for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN33 */


/** \brief Length for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN34 */


/** \brief Mask for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN34 */


/** \brief Offset for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN34 */


/** \brief Length for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN35 */


/** \brief Mask for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN35 */


/** \brief Offset for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN35 */


/** \brief Length for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN36 */


/** \brief Mask for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN36 */


/** \brief Offset for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN36 */


/** \brief Length for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN37 */


/** \brief Mask for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN37 */


/** \brief Offset for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN37 */


/** \brief Length for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN38 */


/** \brief Mask for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN38 */


/** \brief Offset for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN38 */


/** \brief Length for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN39 */


/** \brief Mask for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN39 */


/** \brief Offset for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN39 */


/** \brief Length for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN40 */


/** \brief Mask for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN40 */


/** \brief Offset for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN40 */


/** \brief Length for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN41 */


/** \brief Mask for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN41 */


/** \brief Offset for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN41 */


/** \brief Length for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN42 */


/** \brief Mask for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN42 */


/** \brief Offset for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN42 */


/** \brief Length for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN43 */


/** \brief Mask for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN43 */


/** \brief Offset for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN43 */


/** \brief Length for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN44 */


/** \brief Mask for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN44 */


/** \brief Offset for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN44 */


/** \brief Length for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN45 */


/** \brief Mask for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN45 */


/** \brief Offset for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN45 */


/** \brief Length for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN46 */


/** \brief Mask for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN46 */


/** \brief Offset for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN46 */


/** \brief Length for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN47 */


/** \brief Mask for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN47 */


/** \brief Offset for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN47 */


/** \brief Length for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN48 */


/** \brief Mask for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN48 */


/** \brief Offset for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN48 */


/** \brief Length for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN49 */


/** \brief Mask for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN49 */


/** \brief Offset for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN49 */


/** \brief Length for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN50 */


/** \brief Mask for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN50 */


/** \brief Offset for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN50 */


/** \brief Length for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN51 */


/** \brief Mask for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN51 */


/** \brief Offset for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN51 */


/** \brief Length for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN52 */


/** \brief Mask for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN52 */


/** \brief Offset for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN52 */


/** \brief Length for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN53 */


/** \brief Mask for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN53 */


/** \brief Offset for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN53 */


/** \brief Length for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN54 */


/** \brief Mask for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN54 */


/** \brief Offset for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN54 */


/** \brief Length for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN55 */


/** \brief Mask for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN55 */


/** \brief Offset for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN55 */


/** \brief Length for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN56 */


/** \brief Mask for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN56 */


/** \brief Offset for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN56 */


/** \brief Length for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN57 */


/** \brief Mask for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN57 */


/** \brief Offset for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN57 */


/** \brief Length for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN58 */


/** \brief Mask for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN58 */


/** \brief Offset for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN58 */


/** \brief Length for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN59 */


/** \brief Mask for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN59 */


/** \brief Offset for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN59 */


/** \brief Length for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN60 */


/** \brief Mask for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN60 */


/** \brief Offset for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN60 */


/** \brief Length for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN61 */


/** \brief Mask for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN61 */


/** \brief Offset for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN61 */


/** \brief Length for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN62 */


/** \brief Mask for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN62 */


/** \brief Offset for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN62 */


/** \brief Length for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN63 */


/** \brief Mask for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN63 */


/** \brief Offset for Ifx_CPU_SFR_SPROT_ACCENB_W_Bits.EN63 */


/** \brief Length for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN0 */


/** \brief Mask for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN0 */


/** \brief Offset for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN0 */


/** \brief Length for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN1 */


/** \brief Mask for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN1 */


/** \brief Offset for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN1 */


/** \brief Length for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN2 */


/** \brief Mask for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN2 */


/** \brief Offset for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN2 */


/** \brief Length for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN3 */


/** \brief Mask for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN3 */


/** \brief Offset for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN3 */


/** \brief Length for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN4 */


/** \brief Mask for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN4 */


/** \brief Offset for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN4 */


/** \brief Length for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN5 */


/** \brief Mask for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN5 */


/** \brief Offset for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN5 */


/** \brief Length for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN6 */


/** \brief Mask for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN6 */


/** \brief Offset for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN6 */


/** \brief Length for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN7 */


/** \brief Mask for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN7 */


/** \brief Offset for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN7 */


/** \brief Length for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN8 */


/** \brief Mask for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN8 */


/** \brief Offset for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN8 */


/** \brief Length for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN9 */


/** \brief Mask for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN9 */


/** \brief Offset for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN9 */


/** \brief Length for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN10 */


/** \brief Mask for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN10 */


/** \brief Offset for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN10 */


/** \brief Length for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN11 */


/** \brief Mask for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN11 */


/** \brief Offset for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN11 */


/** \brief Length for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN12 */


/** \brief Mask for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN12 */


/** \brief Offset for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN12 */


/** \brief Length for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN13 */


/** \brief Mask for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN13 */


/** \brief Offset for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN13 */


/** \brief Length for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN14 */


/** \brief Mask for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN14 */


/** \brief Offset for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN14 */


/** \brief Length for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN15 */


/** \brief Mask for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN15 */


/** \brief Offset for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN15 */


/** \brief Length for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN16 */


/** \brief Mask for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN16 */


/** \brief Offset for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN16 */


/** \brief Length for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN17 */


/** \brief Mask for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN17 */


/** \brief Offset for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN17 */


/** \brief Length for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN18 */


/** \brief Mask for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN18 */


/** \brief Offset for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN18 */


/** \brief Length for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN19 */


/** \brief Mask for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN19 */


/** \brief Offset for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN19 */


/** \brief Length for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN20 */


/** \brief Mask for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN20 */


/** \brief Offset for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN20 */


/** \brief Length for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN21 */


/** \brief Mask for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN21 */


/** \brief Offset for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN21 */


/** \brief Length for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN22 */


/** \brief Mask for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN22 */


/** \brief Offset for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN22 */


/** \brief Length for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN23 */


/** \brief Mask for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN23 */


/** \brief Offset for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN23 */


/** \brief Length for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN24 */


/** \brief Mask for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN24 */


/** \brief Offset for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN24 */


/** \brief Length for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN25 */


/** \brief Mask for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN25 */


/** \brief Offset for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN25 */


/** \brief Length for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN26 */


/** \brief Mask for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN26 */


/** \brief Offset for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN26 */


/** \brief Length for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN27 */


/** \brief Mask for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN27 */


/** \brief Offset for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN27 */


/** \brief Length for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN28 */


/** \brief Mask for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN28 */


/** \brief Offset for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN28 */


/** \brief Length for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN29 */


/** \brief Mask for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN29 */


/** \brief Offset for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN29 */


/** \brief Length for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN30 */


/** \brief Mask for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN30 */


/** \brief Offset for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN30 */


/** \brief Length for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN31 */


/** \brief Mask for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN31 */


/** \brief Offset for Ifx_CPU_LPB_SPROT_ACCENA_R_Bits.EN31 */


/** \brief Length for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN32 */


/** \brief Mask for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN32 */


/** \brief Offset for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN32 */


/** \brief Length for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN33 */


/** \brief Mask for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN33 */


/** \brief Offset for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN33 */


/** \brief Length for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN34 */


/** \brief Mask for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN34 */


/** \brief Offset for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN34 */


/** \brief Length for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN35 */


/** \brief Mask for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN35 */


/** \brief Offset for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN35 */


/** \brief Length for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN36 */


/** \brief Mask for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN36 */


/** \brief Offset for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN36 */


/** \brief Length for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN37 */


/** \brief Mask for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN37 */


/** \brief Offset for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN37 */


/** \brief Length for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN38 */


/** \brief Mask for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN38 */


/** \brief Offset for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN38 */


/** \brief Length for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN39 */


/** \brief Mask for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN39 */


/** \brief Offset for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN39 */


/** \brief Length for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN40 */


/** \brief Mask for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN40 */


/** \brief Offset for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN40 */


/** \brief Length for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN41 */


/** \brief Mask for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN41 */


/** \brief Offset for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN41 */


/** \brief Length for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN42 */


/** \brief Mask for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN42 */


/** \brief Offset for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN42 */


/** \brief Length for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN43 */


/** \brief Mask for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN43 */


/** \brief Offset for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN43 */


/** \brief Length for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN44 */


/** \brief Mask for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN44 */


/** \brief Offset for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN44 */


/** \brief Length for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN45 */


/** \brief Mask for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN45 */


/** \brief Offset for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN45 */


/** \brief Length for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN46 */


/** \brief Mask for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN46 */


/** \brief Offset for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN46 */


/** \brief Length for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN47 */


/** \brief Mask for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN47 */


/** \brief Offset for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN47 */


/** \brief Length for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN48 */


/** \brief Mask for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN48 */


/** \brief Offset for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN48 */


/** \brief Length for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN49 */


/** \brief Mask for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN49 */


/** \brief Offset for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN49 */


/** \brief Length for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN50 */


/** \brief Mask for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN50 */


/** \brief Offset for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN50 */


/** \brief Length for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN51 */


/** \brief Mask for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN51 */


/** \brief Offset for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN51 */


/** \brief Length for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN52 */


/** \brief Mask for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN52 */


/** \brief Offset for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN52 */


/** \brief Length for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN53 */


/** \brief Mask for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN53 */


/** \brief Offset for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN53 */


/** \brief Length for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN54 */


/** \brief Mask for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN54 */


/** \brief Offset for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN54 */


/** \brief Length for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN55 */


/** \brief Mask for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN55 */


/** \brief Offset for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN55 */


/** \brief Length for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN56 */


/** \brief Mask for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN56 */


/** \brief Offset for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN56 */


/** \brief Length for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN57 */


/** \brief Mask for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN57 */


/** \brief Offset for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN57 */


/** \brief Length for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN58 */


/** \brief Mask for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN58 */


/** \brief Offset for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN58 */


/** \brief Length for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN59 */


/** \brief Mask for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN59 */


/** \brief Offset for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN59 */


/** \brief Length for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN60 */


/** \brief Mask for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN60 */


/** \brief Offset for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN60 */


/** \brief Length for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN61 */


/** \brief Mask for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN61 */


/** \brief Offset for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN61 */


/** \brief Length for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN62 */


/** \brief Mask for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN62 */


/** \brief Offset for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN62 */


/** \brief Length for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN63 */


/** \brief Mask for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN63 */


/** \brief Offset for Ifx_CPU_LPB_SPROT_ACCENB_R_Bits.EN63 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNLA_Bits.ADDR */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNLA_Bits.ADDR */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNLA_Bits.ADDR */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNUA_Bits.ADDR */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNUA_Bits.ADDR */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNUA_Bits.ADDR */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN0 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN0 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN0 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN1 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN1 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN1 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN2 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN2 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN2 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN3 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN3 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN3 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN4 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN4 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN4 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN5 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN5 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN5 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN6 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN6 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN6 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN7 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN7 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN7 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN8 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN8 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN8 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN9 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN9 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN9 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN10 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN10 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN10 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN11 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN11 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN11 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN12 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN12 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN12 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN13 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN13 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN13 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN14 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN14 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN14 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN15 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN15 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN15 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN16 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN16 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN16 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN17 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN17 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN17 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN18 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN18 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN18 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN19 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN19 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN19 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN20 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN20 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN20 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN21 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN21 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN21 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN22 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN22 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN22 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN23 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN23 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN23 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN24 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN24 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN24 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN25 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN25 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN25 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN26 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN26 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN26 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN27 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN27 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN27 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN28 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN28 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN28 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN29 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN29 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN29 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN30 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN30 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN30 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN31 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN31 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENA_W_Bits.EN31 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN32 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN32 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN32 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN33 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN33 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN33 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN34 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN34 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN34 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN35 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN35 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN35 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN36 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN36 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN36 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN37 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN37 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN37 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN38 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN38 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN38 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN39 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN39 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN39 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN40 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN40 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN40 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN41 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN41 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN41 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN42 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN42 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN42 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN43 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN43 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN43 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN44 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN44 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN44 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN45 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN45 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN45 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN46 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN46 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN46 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN47 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN47 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN47 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN48 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN48 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN48 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN49 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN49 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN49 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN50 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN50 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN50 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN51 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN51 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN51 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN52 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN52 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN52 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN53 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN53 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN53 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN54 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN54 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN54 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN55 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN55 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN55 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN56 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN56 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN56 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN57 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN57 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN57 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN58 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN58 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN58 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN59 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN59 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN59 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN60 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN60 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN60 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN61 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN61 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN61 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN62 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN62 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN62 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN63 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN63 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENB_W_Bits.EN63 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN0 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN0 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN0 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN1 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN1 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN1 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN2 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN2 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN2 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN3 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN3 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN3 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN4 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN4 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN4 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN5 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN5 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN5 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN6 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN6 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN6 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN7 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN7 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN7 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN8 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN8 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN8 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN9 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN9 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN9 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN10 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN10 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN10 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN11 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN11 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN11 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN12 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN12 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN12 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN13 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN13 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN13 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN14 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN14 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN14 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN15 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN15 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN15 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN16 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN16 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN16 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN17 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN17 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN17 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN18 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN18 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN18 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN19 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN19 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN19 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN20 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN20 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN20 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN21 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN21 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN21 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN22 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN22 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN22 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN23 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN23 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN23 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN24 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN24 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN24 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN25 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN25 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN25 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN26 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN26 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN26 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN27 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN27 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN27 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN28 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN28 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN28 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN29 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN29 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN29 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN30 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN30 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN30 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN31 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN31 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENA_R_Bits.EN31 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN32 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN32 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN32 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN33 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN33 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN33 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN34 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN34 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN34 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN35 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN35 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN35 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN36 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN36 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN36 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN37 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN37 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN37 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN38 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN38 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN38 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN39 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN39 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN39 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN40 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN40 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN40 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN41 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN41 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN41 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN42 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN42 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN42 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN43 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN43 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN43 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN44 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN44 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN44 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN45 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN45 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN45 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN46 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN46 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN46 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN47 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN47 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN47 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN48 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN48 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN48 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN49 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN49 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN49 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN50 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN50 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN50 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN51 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN51 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN51 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN52 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN52 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN52 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN53 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN53 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN53 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN54 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN54 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN54 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN55 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN55 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN55 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN56 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN56 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN56 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN57 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN57 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN57 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN58 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN58 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN58 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN59 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN59 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN59 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN60 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN60 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN60 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN61 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN61 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN61 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN62 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN62 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN62 */


/** \brief Length for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN63 */


/** \brief Mask for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN63 */


/** \brief Offset for Ifx_CPU_DLMU_SPROT_RGNACCENB_R_Bits.EN63 */


/** \brief Length for Ifx_CPU_OSEL_Bits.SHOVEN_x */


/** \brief Mask for Ifx_CPU_OSEL_Bits.SHOVEN_x */


/** \brief Offset for Ifx_CPU_OSEL_Bits.SHOVEN_x */


/** \brief Length for Ifx_CPU_BLK_RABR_Bits.OBASE */


/** \brief Mask for Ifx_CPU_BLK_RABR_Bits.OBASE */


/** \brief Offset for Ifx_CPU_BLK_RABR_Bits.OBASE */


/** \brief Length for Ifx_CPU_BLK_RABR_Bits.OMEM */


/** \brief Mask for Ifx_CPU_BLK_RABR_Bits.OMEM */


/** \brief Offset for Ifx_CPU_BLK_RABR_Bits.OMEM */


/** \brief Length for Ifx_CPU_BLK_RABR_Bits.OVEN */


/** \brief Mask for Ifx_CPU_BLK_RABR_Bits.OVEN */


/** \brief Offset for Ifx_CPU_BLK_RABR_Bits.OVEN */


/** \brief Length for Ifx_CPU_BLK_OTAR_Bits.TBASE */


/** \brief Mask for Ifx_CPU_BLK_OTAR_Bits.TBASE */


/** \brief Offset for Ifx_CPU_BLK_OTAR_Bits.TBASE */


/** \brief Length for Ifx_CPU_BLK_OMASK_Bits.OMASK */


/** \brief Mask for Ifx_CPU_BLK_OMASK_Bits.OMASK */


/** \brief Offset for Ifx_CPU_BLK_OMASK_Bits.OMASK */


/** \brief Length for Ifx_CPU_BLK_OMASK_Bits.ONE */


/** \brief Mask for Ifx_CPU_BLK_OMASK_Bits.ONE */


/** \brief Offset for Ifx_CPU_BLK_OMASK_Bits.ONE */


/** \brief Length for Ifx_CPU_SEGEN_Bits.ADFLIP */


/** \brief Mask for Ifx_CPU_SEGEN_Bits.ADFLIP */


/** \brief Offset for Ifx_CPU_SEGEN_Bits.ADFLIP */


/** \brief Length for Ifx_CPU_SEGEN_Bits.ADTYPE */


/** \brief Mask for Ifx_CPU_SEGEN_Bits.ADTYPE */


/** \brief Offset for Ifx_CPU_SEGEN_Bits.ADTYPE */


/** \brief Length for Ifx_CPU_SEGEN_Bits.AE */


/** \brief Mask for Ifx_CPU_SEGEN_Bits.AE */


/** \brief Offset for Ifx_CPU_SEGEN_Bits.AE */


/** \brief Length for Ifx_CPU_TASK_ASI_Bits.ASI */


/** \brief Mask for Ifx_CPU_TASK_ASI_Bits.ASI */


/** \brief Offset for Ifx_CPU_TASK_ASI_Bits.ASI */


/** \brief Length for Ifx_CPU_PMA0_Bits.DAC */


/** \brief Mask for Ifx_CPU_PMA0_Bits.DAC */


/** \brief Offset for Ifx_CPU_PMA0_Bits.DAC */


/** \brief Length for Ifx_CPU_PMA1_Bits.CAC */


/** \brief Mask for Ifx_CPU_PMA1_Bits.CAC */


/** \brief Offset for Ifx_CPU_PMA1_Bits.CAC */


/** \brief Length for Ifx_CPU_PMA2_Bits.PSI */


/** \brief Mask for Ifx_CPU_PMA2_Bits.PSI */


/** \brief Offset for Ifx_CPU_PMA2_Bits.PSI */


/** \brief Length for Ifx_CPU_DCON2_Bits.DCACHE_SZE */


/** \brief Mask for Ifx_CPU_DCON2_Bits.DCACHE_SZE */


/** \brief Offset for Ifx_CPU_DCON2_Bits.DCACHE_SZE */


/** \brief Length for Ifx_CPU_DCON2_Bits.DSCRATCH_SZE */


/** \brief Mask for Ifx_CPU_DCON2_Bits.DSCRATCH_SZE */


/** \brief Offset for Ifx_CPU_DCON2_Bits.DSCRATCH_SZE */


/** \brief Length for Ifx_CPU_SMACON_Bits.IODT */


/** \brief Mask for Ifx_CPU_SMACON_Bits.IODT */


/** \brief Offset for Ifx_CPU_SMACON_Bits.IODT */


/** \brief Length for Ifx_CPU_DSTR_Bits.SRE */


/** \brief Mask for Ifx_CPU_DSTR_Bits.SRE */


/** \brief Offset for Ifx_CPU_DSTR_Bits.SRE */


/** \brief Length for Ifx_CPU_DSTR_Bits.GAE */


/** \brief Mask for Ifx_CPU_DSTR_Bits.GAE */


/** \brief Offset for Ifx_CPU_DSTR_Bits.GAE */


/** \brief Length for Ifx_CPU_DSTR_Bits.LBE */


/** \brief Mask for Ifx_CPU_DSTR_Bits.LBE */


/** \brief Offset for Ifx_CPU_DSTR_Bits.LBE */


/** \brief Length for Ifx_CPU_DSTR_Bits.DRE */


/** \brief Mask for Ifx_CPU_DSTR_Bits.DRE */


/** \brief Offset for Ifx_CPU_DSTR_Bits.DRE */


/** \brief Length for Ifx_CPU_DSTR_Bits.CRE */


/** \brief Mask for Ifx_CPU_DSTR_Bits.CRE */


/** \brief Offset for Ifx_CPU_DSTR_Bits.CRE */


/** \brief Length for Ifx_CPU_DSTR_Bits.DTME */


/** \brief Mask for Ifx_CPU_DSTR_Bits.DTME */


/** \brief Offset for Ifx_CPU_DSTR_Bits.DTME */


/** \brief Length for Ifx_CPU_DSTR_Bits.LOE */


/** \brief Mask for Ifx_CPU_DSTR_Bits.LOE */


/** \brief Offset for Ifx_CPU_DSTR_Bits.LOE */


/** \brief Length for Ifx_CPU_DSTR_Bits.SDE */


/** \brief Mask for Ifx_CPU_DSTR_Bits.SDE */


/** \brief Offset for Ifx_CPU_DSTR_Bits.SDE */


/** \brief Length for Ifx_CPU_DSTR_Bits.SCE */


/** \brief Mask for Ifx_CPU_DSTR_Bits.SCE */


/** \brief Offset for Ifx_CPU_DSTR_Bits.SCE */


/** \brief Length for Ifx_CPU_DSTR_Bits.CAC */


/** \brief Mask for Ifx_CPU_DSTR_Bits.CAC */


/** \brief Offset for Ifx_CPU_DSTR_Bits.CAC */


/** \brief Length for Ifx_CPU_DSTR_Bits.MPE */


/** \brief Mask for Ifx_CPU_DSTR_Bits.MPE */


/** \brief Offset for Ifx_CPU_DSTR_Bits.MPE */


/** \brief Length for Ifx_CPU_DSTR_Bits.CLE */


/** \brief Mask for Ifx_CPU_DSTR_Bits.CLE */


/** \brief Offset for Ifx_CPU_DSTR_Bits.CLE */


/** \brief Length for Ifx_CPU_DSTR_Bits.ALN */


/** \brief Mask for Ifx_CPU_DSTR_Bits.ALN */


/** \brief Offset for Ifx_CPU_DSTR_Bits.ALN */


/** \brief Length for Ifx_CPU_DATR_Bits.SBE */


/** \brief Mask for Ifx_CPU_DATR_Bits.SBE */


/** \brief Offset for Ifx_CPU_DATR_Bits.SBE */


/** \brief Length for Ifx_CPU_DATR_Bits.CWE */


/** \brief Mask for Ifx_CPU_DATR_Bits.CWE */


/** \brief Offset for Ifx_CPU_DATR_Bits.CWE */


/** \brief Length for Ifx_CPU_DATR_Bits.CFE */


/** \brief Mask for Ifx_CPU_DATR_Bits.CFE */


/** \brief Offset for Ifx_CPU_DATR_Bits.CFE */


/** \brief Length for Ifx_CPU_DATR_Bits.SOE */


/** \brief Mask for Ifx_CPU_DATR_Bits.SOE */


/** \brief Offset for Ifx_CPU_DATR_Bits.SOE */


/** \brief Length for Ifx_CPU_DEADD_Bits.ERROR_ADDRESS */


/** \brief Mask for Ifx_CPU_DEADD_Bits.ERROR_ADDRESS */


/** \brief Offset for Ifx_CPU_DEADD_Bits.ERROR_ADDRESS */


/** \brief Length for Ifx_CPU_DIEAR_Bits.TA */


/** \brief Mask for Ifx_CPU_DIEAR_Bits.TA */


/** \brief Offset for Ifx_CPU_DIEAR_Bits.TA */


/** \brief Length for Ifx_CPU_DIETR_Bits.IED */


/** \brief Mask for Ifx_CPU_DIETR_Bits.IED */


/** \brief Offset for Ifx_CPU_DIETR_Bits.IED */


/** \brief Length for Ifx_CPU_DIETR_Bits.IE_T */


/** \brief Mask for Ifx_CPU_DIETR_Bits.IE_T */


/** \brief Offset for Ifx_CPU_DIETR_Bits.IE_T */


/** \brief Length for Ifx_CPU_DIETR_Bits.IE_C */


/** \brief Mask for Ifx_CPU_DIETR_Bits.IE_C */


/** \brief Offset for Ifx_CPU_DIETR_Bits.IE_C */


/** \brief Length for Ifx_CPU_DIETR_Bits.IE_S */


/** \brief Mask for Ifx_CPU_DIETR_Bits.IE_S */


/** \brief Offset for Ifx_CPU_DIETR_Bits.IE_S */


/** \brief Length for Ifx_CPU_DIETR_Bits.IE_BI */


/** \brief Mask for Ifx_CPU_DIETR_Bits.IE_BI */


/** \brief Offset for Ifx_CPU_DIETR_Bits.IE_BI */


/** \brief Length for Ifx_CPU_DIETR_Bits.E_INFO */


/** \brief Mask for Ifx_CPU_DIETR_Bits.E_INFO */


/** \brief Offset for Ifx_CPU_DIETR_Bits.E_INFO */


/** \brief Length for Ifx_CPU_DIETR_Bits.IE_UNC */


/** \brief Mask for Ifx_CPU_DIETR_Bits.IE_UNC */


/** \brief Offset for Ifx_CPU_DIETR_Bits.IE_UNC */


/** \brief Length for Ifx_CPU_DIETR_Bits.IE_SP */


/** \brief Mask for Ifx_CPU_DIETR_Bits.IE_SP */


/** \brief Offset for Ifx_CPU_DIETR_Bits.IE_SP */


/** \brief Length for Ifx_CPU_DIETR_Bits.IE_BS */


/** \brief Mask for Ifx_CPU_DIETR_Bits.IE_BS */


/** \brief Offset for Ifx_CPU_DIETR_Bits.IE_BS */


/** \brief Length for Ifx_CPU_DIETR_Bits.IE_DLMU */


/** \brief Mask for Ifx_CPU_DIETR_Bits.IE_DLMU */


/** \brief Offset for Ifx_CPU_DIETR_Bits.IE_DLMU */


/** \brief Length for Ifx_CPU_DIETR_Bits.IE_LPB */


/** \brief Mask for Ifx_CPU_DIETR_Bits.IE_LPB */


/** \brief Offset for Ifx_CPU_DIETR_Bits.IE_LPB */


/** \brief Length for Ifx_CPU_DIETR_Bits.IE_MTMV */


/** \brief Mask for Ifx_CPU_DIETR_Bits.IE_MTMV */


/** \brief Offset for Ifx_CPU_DIETR_Bits.IE_MTMV */


/** \brief Length for Ifx_CPU_DCON0_Bits.DCBYP */


/** \brief Mask for Ifx_CPU_DCON0_Bits.DCBYP */


/** \brief Offset for Ifx_CPU_DCON0_Bits.DCBYP */


/** \brief Length for Ifx_CPU_PSTR_Bits.FRE */


/** \brief Mask for Ifx_CPU_PSTR_Bits.FRE */


/** \brief Offset for Ifx_CPU_PSTR_Bits.FRE */


/** \brief Length for Ifx_CPU_PSTR_Bits.FBE */


/** \brief Mask for Ifx_CPU_PSTR_Bits.FBE */


/** \brief Offset for Ifx_CPU_PSTR_Bits.FBE */


/** \brief Length for Ifx_CPU_PSTR_Bits.FPE */


/** \brief Mask for Ifx_CPU_PSTR_Bits.FPE */


/** \brief Offset for Ifx_CPU_PSTR_Bits.FPE */


/** \brief Length for Ifx_CPU_PSTR_Bits.FME */


/** \brief Mask for Ifx_CPU_PSTR_Bits.FME */


/** \brief Offset for Ifx_CPU_PSTR_Bits.FME */


/** \brief Length for Ifx_CPU_PCON1_Bits.PCINV */


/** \brief Mask for Ifx_CPU_PCON1_Bits.PCINV */


/** \brief Offset for Ifx_CPU_PCON1_Bits.PCINV */


/** \brief Length for Ifx_CPU_PCON1_Bits.PBINV */


/** \brief Mask for Ifx_CPU_PCON1_Bits.PBINV */


/** \brief Offset for Ifx_CPU_PCON1_Bits.PBINV */


/** \brief Length for Ifx_CPU_PCON2_Bits.PCACHE_SZE */


/** \brief Mask for Ifx_CPU_PCON2_Bits.PCACHE_SZE */


/** \brief Offset for Ifx_CPU_PCON2_Bits.PCACHE_SZE */


/** \brief Length for Ifx_CPU_PCON2_Bits.PSCRATCH_SZE */


/** \brief Mask for Ifx_CPU_PCON2_Bits.PSCRATCH_SZE */


/** \brief Offset for Ifx_CPU_PCON2_Bits.PSCRATCH_SZE */


/** \brief Length for Ifx_CPU_PCON0_Bits.PCBYP */


/** \brief Mask for Ifx_CPU_PCON0_Bits.PCBYP */


/** \brief Offset for Ifx_CPU_PCON0_Bits.PCBYP */


/** \brief Length for Ifx_CPU_PIEAR_Bits.TA */


/** \brief Mask for Ifx_CPU_PIEAR_Bits.TA */


/** \brief Offset for Ifx_CPU_PIEAR_Bits.TA */


/** \brief Length for Ifx_CPU_PIETR_Bits.IED */


/** \brief Mask for Ifx_CPU_PIETR_Bits.IED */


/** \brief Offset for Ifx_CPU_PIETR_Bits.IED */


/** \brief Length for Ifx_CPU_PIETR_Bits.IE_T */


/** \brief Mask for Ifx_CPU_PIETR_Bits.IE_T */


/** \brief Offset for Ifx_CPU_PIETR_Bits.IE_T */


/** \brief Length for Ifx_CPU_PIETR_Bits.IE_C */


/** \brief Mask for Ifx_CPU_PIETR_Bits.IE_C */


/** \brief Offset for Ifx_CPU_PIETR_Bits.IE_C */


/** \brief Length for Ifx_CPU_PIETR_Bits.IE_S */


/** \brief Mask for Ifx_CPU_PIETR_Bits.IE_S */


/** \brief Offset for Ifx_CPU_PIETR_Bits.IE_S */


/** \brief Length for Ifx_CPU_PIETR_Bits.IE_BI */


/** \brief Mask for Ifx_CPU_PIETR_Bits.IE_BI */


/** \brief Offset for Ifx_CPU_PIETR_Bits.IE_BI */


/** \brief Length for Ifx_CPU_PIETR_Bits.E_INFO */


/** \brief Mask for Ifx_CPU_PIETR_Bits.E_INFO */


/** \brief Offset for Ifx_CPU_PIETR_Bits.E_INFO */


/** \brief Length for Ifx_CPU_PIETR_Bits.IE_UNC */


/** \brief Mask for Ifx_CPU_PIETR_Bits.IE_UNC */


/** \brief Offset for Ifx_CPU_PIETR_Bits.IE_UNC */


/** \brief Length for Ifx_CPU_PIETR_Bits.IE_SP */


/** \brief Mask for Ifx_CPU_PIETR_Bits.IE_SP */


/** \brief Offset for Ifx_CPU_PIETR_Bits.IE_SP */


/** \brief Length for Ifx_CPU_PIETR_Bits.IE_BS */


/** \brief Mask for Ifx_CPU_PIETR_Bits.IE_BS */


/** \brief Offset for Ifx_CPU_PIETR_Bits.IE_BS */


/** \brief Length for Ifx_CPU_PIETR_Bits.IE_ADDR */


/** \brief Mask for Ifx_CPU_PIETR_Bits.IE_ADDR */


/** \brief Offset for Ifx_CPU_PIETR_Bits.IE_ADDR */


/** \brief Length for Ifx_CPU_PIETR_Bits.IE_LPB */


/** \brief Mask for Ifx_CPU_PIETR_Bits.IE_LPB */


/** \brief Offset for Ifx_CPU_PIETR_Bits.IE_LPB */


/** \brief Length for Ifx_CPU_PIETR_Bits.IE_MTMV */


/** \brief Mask for Ifx_CPU_PIETR_Bits.IE_MTMV */


/** \brief Offset for Ifx_CPU_PIETR_Bits.IE_MTMV */


/** \brief Length for Ifx_CPU_COMPAT_Bits.RM */


/** \brief Mask for Ifx_CPU_COMPAT_Bits.RM */


/** \brief Offset for Ifx_CPU_COMPAT_Bits.RM */


/** \brief Length for Ifx_CPU_COMPAT_Bits.SP */


/** \brief Mask for Ifx_CPU_COMPAT_Bits.SP */


/** \brief Offset for Ifx_CPU_COMPAT_Bits.SP */


/** \brief Length for Ifx_CPU_FPU_TRAP_CON_Bits.TST */


/** \brief Mask for Ifx_CPU_FPU_TRAP_CON_Bits.TST */


/** \brief Offset for Ifx_CPU_FPU_TRAP_CON_Bits.TST */


/** \brief Length for Ifx_CPU_FPU_TRAP_CON_Bits.TCL */


/** \brief Mask for Ifx_CPU_FPU_TRAP_CON_Bits.TCL */


/** \brief Offset for Ifx_CPU_FPU_TRAP_CON_Bits.TCL */


/** \brief Length for Ifx_CPU_FPU_TRAP_CON_Bits.RM */


/** \brief Mask for Ifx_CPU_FPU_TRAP_CON_Bits.RM */


/** \brief Offset for Ifx_CPU_FPU_TRAP_CON_Bits.RM */


/** \brief Length for Ifx_CPU_FPU_TRAP_CON_Bits.FXE */


/** \brief Mask for Ifx_CPU_FPU_TRAP_CON_Bits.FXE */


/** \brief Offset for Ifx_CPU_FPU_TRAP_CON_Bits.FXE */


/** \brief Length for Ifx_CPU_FPU_TRAP_CON_Bits.FUE */


/** \brief Mask for Ifx_CPU_FPU_TRAP_CON_Bits.FUE */


/** \brief Offset for Ifx_CPU_FPU_TRAP_CON_Bits.FUE */


/** \brief Length for Ifx_CPU_FPU_TRAP_CON_Bits.FZE */


/** \brief Mask for Ifx_CPU_FPU_TRAP_CON_Bits.FZE */


/** \brief Offset for Ifx_CPU_FPU_TRAP_CON_Bits.FZE */


/** \brief Length for Ifx_CPU_FPU_TRAP_CON_Bits.FVE */


/** \brief Mask for Ifx_CPU_FPU_TRAP_CON_Bits.FVE */


/** \brief Offset for Ifx_CPU_FPU_TRAP_CON_Bits.FVE */


/** \brief Length for Ifx_CPU_FPU_TRAP_CON_Bits.FIE */


/** \brief Mask for Ifx_CPU_FPU_TRAP_CON_Bits.FIE */


/** \brief Offset for Ifx_CPU_FPU_TRAP_CON_Bits.FIE */


/** \brief Length for Ifx_CPU_FPU_TRAP_CON_Bits.FX */


/** \brief Mask for Ifx_CPU_FPU_TRAP_CON_Bits.FX */


/** \brief Offset for Ifx_CPU_FPU_TRAP_CON_Bits.FX */


/** \brief Length for Ifx_CPU_FPU_TRAP_CON_Bits.FU */


/** \brief Mask for Ifx_CPU_FPU_TRAP_CON_Bits.FU */


/** \brief Offset for Ifx_CPU_FPU_TRAP_CON_Bits.FU */


/** \brief Length for Ifx_CPU_FPU_TRAP_CON_Bits.FZ */


/** \brief Mask for Ifx_CPU_FPU_TRAP_CON_Bits.FZ */


/** \brief Offset for Ifx_CPU_FPU_TRAP_CON_Bits.FZ */


/** \brief Length for Ifx_CPU_FPU_TRAP_CON_Bits.FV */


/** \brief Mask for Ifx_CPU_FPU_TRAP_CON_Bits.FV */


/** \brief Offset for Ifx_CPU_FPU_TRAP_CON_Bits.FV */


/** \brief Length for Ifx_CPU_FPU_TRAP_CON_Bits.FI */


/** \brief Mask for Ifx_CPU_FPU_TRAP_CON_Bits.FI */


/** \brief Offset for Ifx_CPU_FPU_TRAP_CON_Bits.FI */


/** \brief Length for Ifx_CPU_FPU_TRAP_PC_Bits.PC */


/** \brief Mask for Ifx_CPU_FPU_TRAP_PC_Bits.PC */


/** \brief Offset for Ifx_CPU_FPU_TRAP_PC_Bits.PC */


/** \brief Length for Ifx_CPU_FPU_TRAP_OPC_Bits.OPC */


/** \brief Mask for Ifx_CPU_FPU_TRAP_OPC_Bits.OPC */


/** \brief Offset for Ifx_CPU_FPU_TRAP_OPC_Bits.OPC */


/** \brief Length for Ifx_CPU_FPU_TRAP_OPC_Bits.FMT */


/** \brief Mask for Ifx_CPU_FPU_TRAP_OPC_Bits.FMT */


/** \brief Offset for Ifx_CPU_FPU_TRAP_OPC_Bits.FMT */


/** \brief Length for Ifx_CPU_FPU_TRAP_OPC_Bits.DREG */


/** \brief Mask for Ifx_CPU_FPU_TRAP_OPC_Bits.DREG */


/** \brief Offset for Ifx_CPU_FPU_TRAP_OPC_Bits.DREG */


/** \brief Length for Ifx_CPU_FPU_TRAP_SRC1_Bits.SRC1 */


/** \brief Mask for Ifx_CPU_FPU_TRAP_SRC1_Bits.SRC1 */


/** \brief Offset for Ifx_CPU_FPU_TRAP_SRC1_Bits.SRC1 */


/** \brief Length for Ifx_CPU_FPU_TRAP_SRC2_Bits.SRC2 */


/** \brief Mask for Ifx_CPU_FPU_TRAP_SRC2_Bits.SRC2 */


/** \brief Offset for Ifx_CPU_FPU_TRAP_SRC2_Bits.SRC2 */


/** \brief Length for Ifx_CPU_FPU_TRAP_SRC3_Bits.SRC3 */


/** \brief Mask for Ifx_CPU_FPU_TRAP_SRC3_Bits.SRC3 */


/** \brief Offset for Ifx_CPU_FPU_TRAP_SRC3_Bits.SRC3 */


/** \brief Length for Ifx_CPU_DPR_L_Bits.LOWBND */


/** \brief Mask for Ifx_CPU_DPR_L_Bits.LOWBND */


/** \brief Offset for Ifx_CPU_DPR_L_Bits.LOWBND */


/** \brief Length for Ifx_CPU_DPR_U_Bits.UPPBND */


/** \brief Mask for Ifx_CPU_DPR_U_Bits.UPPBND */


/** \brief Offset for Ifx_CPU_DPR_U_Bits.UPPBND */


/** \brief Length for Ifx_CPU_CPR_L_Bits.LOWBND */


/** \brief Mask for Ifx_CPU_CPR_L_Bits.LOWBND */


/** \brief Offset for Ifx_CPU_CPR_L_Bits.LOWBND */


/** \brief Length for Ifx_CPU_CPR_U_Bits.UPPBND */


/** \brief Mask for Ifx_CPU_CPR_U_Bits.UPPBND */


/** \brief Offset for Ifx_CPU_CPR_U_Bits.UPPBND */


/** \brief Length for Ifx_CPU_CPXE_Bits.XE_n */


/** \brief Mask for Ifx_CPU_CPXE_Bits.XE_n */


/** \brief Offset for Ifx_CPU_CPXE_Bits.XE_n */


/** \brief Length for Ifx_CPU_DPRE_Bits.RE_n */


/** \brief Mask for Ifx_CPU_DPRE_Bits.RE_n */


/** \brief Offset for Ifx_CPU_DPRE_Bits.RE_n */


/** \brief Length for Ifx_CPU_DPWE_Bits.WE_n */


/** \brief Mask for Ifx_CPU_DPWE_Bits.WE_n */


/** \brief Offset for Ifx_CPU_DPWE_Bits.WE_n */


/** \brief Length for Ifx_CPU_TPS_CON_Bits.TEXP0 */


/** \brief Mask for Ifx_CPU_TPS_CON_Bits.TEXP0 */


/** \brief Offset for Ifx_CPU_TPS_CON_Bits.TEXP0 */


/** \brief Length for Ifx_CPU_TPS_CON_Bits.TEXP1 */


/** \brief Mask for Ifx_CPU_TPS_CON_Bits.TEXP1 */


/** \brief Offset for Ifx_CPU_TPS_CON_Bits.TEXP1 */


/** \brief Length for Ifx_CPU_TPS_CON_Bits.TEXP2 */


/** \brief Mask for Ifx_CPU_TPS_CON_Bits.TEXP2 */


/** \brief Offset for Ifx_CPU_TPS_CON_Bits.TEXP2 */


/** \brief Length for Ifx_CPU_TPS_CON_Bits.TTRAP */


/** \brief Mask for Ifx_CPU_TPS_CON_Bits.TTRAP */


/** \brief Offset for Ifx_CPU_TPS_CON_Bits.TTRAP */


/** \brief Length for Ifx_CPU_TPS_TIMER_Bits.Timer */


/** \brief Mask for Ifx_CPU_TPS_TIMER_Bits.Timer */


/** \brief Offset for Ifx_CPU_TPS_TIMER_Bits.Timer */


/** \brief Length for Ifx_CPU_TPS_EXTIM_ENTRY_LVAL_Bits.ENTRY_LVAL */


/** \brief Mask for Ifx_CPU_TPS_EXTIM_ENTRY_LVAL_Bits.ENTRY_LVAL */


/** \brief Offset for Ifx_CPU_TPS_EXTIM_ENTRY_LVAL_Bits.ENTRY_LVAL */


/** \brief Length for Ifx_CPU_TPS_EXTIM_ENTRY_CVAL_Bits.ENTRY_CVAL */


/** \brief Mask for Ifx_CPU_TPS_EXTIM_ENTRY_CVAL_Bits.ENTRY_CVAL */


/** \brief Offset for Ifx_CPU_TPS_EXTIM_ENTRY_CVAL_Bits.ENTRY_CVAL */


/** \brief Length for Ifx_CPU_TPS_EXTIM_EXIT_LVAL_Bits.EXIT_LVAL */


/** \brief Mask for Ifx_CPU_TPS_EXTIM_EXIT_LVAL_Bits.EXIT_LVAL */


/** \brief Offset for Ifx_CPU_TPS_EXTIM_EXIT_LVAL_Bits.EXIT_LVAL */


/** \brief Length for Ifx_CPU_TPS_EXTIM_EXIT_CVAL_Bits.EXIT_CVAL */


/** \brief Mask for Ifx_CPU_TPS_EXTIM_EXIT_CVAL_Bits.EXIT_CVAL */


/** \brief Offset for Ifx_CPU_TPS_EXTIM_EXIT_CVAL_Bits.EXIT_CVAL */


/** \brief Length for Ifx_CPU_TPS_EXTIM_CLASS_EN_Bits.EXTIM_CLASS_EN */


/** \brief Mask for Ifx_CPU_TPS_EXTIM_CLASS_EN_Bits.EXTIM_CLASS_EN */


/** \brief Offset for Ifx_CPU_TPS_EXTIM_CLASS_EN_Bits.EXTIM_CLASS_EN */


/** \brief Length for Ifx_CPU_TPS_EXTIM_STAT_Bits.EXIT_TIN */


/** \brief Mask for Ifx_CPU_TPS_EXTIM_STAT_Bits.EXIT_TIN */


/** \brief Offset for Ifx_CPU_TPS_EXTIM_STAT_Bits.EXIT_TIN */


/** \brief Length for Ifx_CPU_TPS_EXTIM_STAT_Bits.EXIT_CLASS */


/** \brief Mask for Ifx_CPU_TPS_EXTIM_STAT_Bits.EXIT_CLASS */


/** \brief Offset for Ifx_CPU_TPS_EXTIM_STAT_Bits.EXIT_CLASS */


/** \brief Length for Ifx_CPU_TPS_EXTIM_STAT_Bits.EXIT_AT */


/** \brief Mask for Ifx_CPU_TPS_EXTIM_STAT_Bits.EXIT_AT */


/** \brief Offset for Ifx_CPU_TPS_EXTIM_STAT_Bits.EXIT_AT */


/** \brief Length for Ifx_CPU_TPS_EXTIM_STAT_Bits.ENTRY_TIN */


/** \brief Mask for Ifx_CPU_TPS_EXTIM_STAT_Bits.ENTRY_TIN */


/** \brief Offset for Ifx_CPU_TPS_EXTIM_STAT_Bits.ENTRY_TIN */


/** \brief Length for Ifx_CPU_TPS_EXTIM_STAT_Bits.ENTRY_CLASS */


/** \brief Mask for Ifx_CPU_TPS_EXTIM_STAT_Bits.ENTRY_CLASS */


/** \brief Offset for Ifx_CPU_TPS_EXTIM_STAT_Bits.ENTRY_CLASS */


/** \brief Length for Ifx_CPU_TPS_EXTIM_STAT_Bits.ENTRY_AT */


/** \brief Mask for Ifx_CPU_TPS_EXTIM_STAT_Bits.ENTRY_AT */


/** \brief Offset for Ifx_CPU_TPS_EXTIM_STAT_Bits.ENTRY_AT */


/** \brief Length for Ifx_CPU_TPS_EXTIM_FCX_Bits.EXIT_FCX */


/** \brief Mask for Ifx_CPU_TPS_EXTIM_FCX_Bits.EXIT_FCX */


/** \brief Offset for Ifx_CPU_TPS_EXTIM_FCX_Bits.EXIT_FCX */


/** \brief Length for Ifx_CPU_TR_EVT_Bits.EVTA */


/** \brief Mask for Ifx_CPU_TR_EVT_Bits.EVTA */


/** \brief Offset for Ifx_CPU_TR_EVT_Bits.EVTA */


/** \brief Length for Ifx_CPU_TR_EVT_Bits.BBM */


/** \brief Mask for Ifx_CPU_TR_EVT_Bits.BBM */


/** \brief Offset for Ifx_CPU_TR_EVT_Bits.BBM */


/** \brief Length for Ifx_CPU_TR_EVT_Bits.BOD */


/** \brief Mask for Ifx_CPU_TR_EVT_Bits.BOD */


/** \brief Offset for Ifx_CPU_TR_EVT_Bits.BOD */


/** \brief Length for Ifx_CPU_TR_EVT_Bits.SUSP */


/** \brief Mask for Ifx_CPU_TR_EVT_Bits.SUSP */


/** \brief Offset for Ifx_CPU_TR_EVT_Bits.SUSP */


/** \brief Length for Ifx_CPU_TR_EVT_Bits.CNT */


/** \brief Mask for Ifx_CPU_TR_EVT_Bits.CNT */


/** \brief Offset for Ifx_CPU_TR_EVT_Bits.CNT */


/** \brief Length for Ifx_CPU_TR_EVT_Bits.TYP */


/** \brief Mask for Ifx_CPU_TR_EVT_Bits.TYP */


/** \brief Offset for Ifx_CPU_TR_EVT_Bits.TYP */


/** \brief Length for Ifx_CPU_TR_EVT_Bits.RNG */


/** \brief Mask for Ifx_CPU_TR_EVT_Bits.RNG */


/** \brief Offset for Ifx_CPU_TR_EVT_Bits.RNG */


/** \brief Length for Ifx_CPU_TR_EVT_Bits.ASI_EN */


/** \brief Mask for Ifx_CPU_TR_EVT_Bits.ASI_EN */


/** \brief Offset for Ifx_CPU_TR_EVT_Bits.ASI_EN */


/** \brief Length for Ifx_CPU_TR_EVT_Bits.ASI */


/** \brief Mask for Ifx_CPU_TR_EVT_Bits.ASI */


/** \brief Offset for Ifx_CPU_TR_EVT_Bits.ASI */


/** \brief Length for Ifx_CPU_TR_EVT_Bits.AST */


/** \brief Mask for Ifx_CPU_TR_EVT_Bits.AST */


/** \brief Offset for Ifx_CPU_TR_EVT_Bits.AST */


/** \brief Length for Ifx_CPU_TR_EVT_Bits.ALD */


/** \brief Mask for Ifx_CPU_TR_EVT_Bits.ALD */


/** \brief Offset for Ifx_CPU_TR_EVT_Bits.ALD */


/** \brief Length for Ifx_CPU_TR_ADR_Bits.ADDR */


/** \brief Mask for Ifx_CPU_TR_ADR_Bits.ADDR */


/** \brief Offset for Ifx_CPU_TR_ADR_Bits.ADDR */


/** \brief Length for Ifx_CPU_CCTRL_Bits.CM */


/** \brief Mask for Ifx_CPU_CCTRL_Bits.CM */


/** \brief Offset for Ifx_CPU_CCTRL_Bits.CM */


/** \brief Length for Ifx_CPU_CCTRL_Bits.CE */


/** \brief Mask for Ifx_CPU_CCTRL_Bits.CE */


/** \brief Offset for Ifx_CPU_CCTRL_Bits.CE */


/** \brief Length for Ifx_CPU_CCTRL_Bits.M1 */


/** \brief Mask for Ifx_CPU_CCTRL_Bits.M1 */


/** \brief Offset for Ifx_CPU_CCTRL_Bits.M1 */


/** \brief Length for Ifx_CPU_CCTRL_Bits.M2 */


/** \brief Mask for Ifx_CPU_CCTRL_Bits.M2 */


/** \brief Offset for Ifx_CPU_CCTRL_Bits.M2 */


/** \brief Length for Ifx_CPU_CCTRL_Bits.M3 */


/** \brief Mask for Ifx_CPU_CCTRL_Bits.M3 */


/** \brief Offset for Ifx_CPU_CCTRL_Bits.M3 */


/** \brief Length for Ifx_CPU_CCNT_Bits.CountValue */


/** \brief Mask for Ifx_CPU_CCNT_Bits.CountValue */


/** \brief Offset for Ifx_CPU_CCNT_Bits.CountValue */


/** \brief Length for Ifx_CPU_CCNT_Bits.SOvf */


/** \brief Mask for Ifx_CPU_CCNT_Bits.SOvf */


/** \brief Offset for Ifx_CPU_CCNT_Bits.SOvf */


/** \brief Length for Ifx_CPU_ICNT_Bits.CountValue */


/** \brief Mask for Ifx_CPU_ICNT_Bits.CountValue */


/** \brief Offset for Ifx_CPU_ICNT_Bits.CountValue */


/** \brief Length for Ifx_CPU_ICNT_Bits.SOvf */


/** \brief Mask for Ifx_CPU_ICNT_Bits.SOvf */


/** \brief Offset for Ifx_CPU_ICNT_Bits.SOvf */


/** \brief Length for Ifx_CPU_M1CNT_Bits.CountValue */


/** \brief Mask for Ifx_CPU_M1CNT_Bits.CountValue */


/** \brief Offset for Ifx_CPU_M1CNT_Bits.CountValue */


/** \brief Length for Ifx_CPU_M1CNT_Bits.SOvf */


/** \brief Mask for Ifx_CPU_M1CNT_Bits.SOvf */


/** \brief Offset for Ifx_CPU_M1CNT_Bits.SOvf */


/** \brief Length for Ifx_CPU_M2CNT_Bits.CountValue */


/** \brief Mask for Ifx_CPU_M2CNT_Bits.CountValue */


/** \brief Offset for Ifx_CPU_M2CNT_Bits.CountValue */


/** \brief Length for Ifx_CPU_M2CNT_Bits.SOvf */


/** \brief Mask for Ifx_CPU_M2CNT_Bits.SOvf */


/** \brief Offset for Ifx_CPU_M2CNT_Bits.SOvf */


/** \brief Length for Ifx_CPU_M3CNT_Bits.CountValue */


/** \brief Mask for Ifx_CPU_M3CNT_Bits.CountValue */


/** \brief Offset for Ifx_CPU_M3CNT_Bits.CountValue */


/** \brief Length for Ifx_CPU_M3CNT_Bits.SOvf */


/** \brief Mask for Ifx_CPU_M3CNT_Bits.SOvf */


/** \brief Offset for Ifx_CPU_M3CNT_Bits.SOvf */


/** \brief Length for Ifx_CPU_DBGSR_Bits.DE */


/** \brief Mask for Ifx_CPU_DBGSR_Bits.DE */


/** \brief Offset for Ifx_CPU_DBGSR_Bits.DE */


/** \brief Length for Ifx_CPU_DBGSR_Bits.HALT */


/** \brief Mask for Ifx_CPU_DBGSR_Bits.HALT */


/** \brief Offset for Ifx_CPU_DBGSR_Bits.HALT */


/** \brief Length for Ifx_CPU_DBGSR_Bits.SIH */


/** \brief Mask for Ifx_CPU_DBGSR_Bits.SIH */


/** \brief Offset for Ifx_CPU_DBGSR_Bits.SIH */


/** \brief Length for Ifx_CPU_DBGSR_Bits.SUSP */


/** \brief Mask for Ifx_CPU_DBGSR_Bits.SUSP */


/** \brief Offset for Ifx_CPU_DBGSR_Bits.SUSP */


/** \brief Length for Ifx_CPU_DBGSR_Bits.PREVSUSP */


/** \brief Mask for Ifx_CPU_DBGSR_Bits.PREVSUSP */


/** \brief Offset for Ifx_CPU_DBGSR_Bits.PREVSUSP */


/** \brief Length for Ifx_CPU_DBGSR_Bits.PEVT */


/** \brief Mask for Ifx_CPU_DBGSR_Bits.PEVT */


/** \brief Offset for Ifx_CPU_DBGSR_Bits.PEVT */


/** \brief Length for Ifx_CPU_DBGSR_Bits.EVTSRC */


/** \brief Mask for Ifx_CPU_DBGSR_Bits.EVTSRC */


/** \brief Offset for Ifx_CPU_DBGSR_Bits.EVTSRC */


/** \brief Length for Ifx_CPU_EXEVT_Bits.EVTA */


/** \brief Mask for Ifx_CPU_EXEVT_Bits.EVTA */


/** \brief Offset for Ifx_CPU_EXEVT_Bits.EVTA */


/** \brief Length for Ifx_CPU_EXEVT_Bits.BBM */


/** \brief Mask for Ifx_CPU_EXEVT_Bits.BBM */


/** \brief Offset for Ifx_CPU_EXEVT_Bits.BBM */


/** \brief Length for Ifx_CPU_EXEVT_Bits.BOD */


/** \brief Mask for Ifx_CPU_EXEVT_Bits.BOD */


/** \brief Offset for Ifx_CPU_EXEVT_Bits.BOD */


/** \brief Length for Ifx_CPU_EXEVT_Bits.SUSP */


/** \brief Mask for Ifx_CPU_EXEVT_Bits.SUSP */


/** \brief Offset for Ifx_CPU_EXEVT_Bits.SUSP */


/** \brief Length for Ifx_CPU_EXEVT_Bits.CNT */


/** \brief Mask for Ifx_CPU_EXEVT_Bits.CNT */


/** \brief Offset for Ifx_CPU_EXEVT_Bits.CNT */


/** \brief Length for Ifx_CPU_CREVT_Bits.EVTA */


/** \brief Mask for Ifx_CPU_CREVT_Bits.EVTA */


/** \brief Offset for Ifx_CPU_CREVT_Bits.EVTA */


/** \brief Length for Ifx_CPU_CREVT_Bits.BBM */


/** \brief Mask for Ifx_CPU_CREVT_Bits.BBM */


/** \brief Offset for Ifx_CPU_CREVT_Bits.BBM */


/** \brief Length for Ifx_CPU_CREVT_Bits.BOD */


/** \brief Mask for Ifx_CPU_CREVT_Bits.BOD */


/** \brief Offset for Ifx_CPU_CREVT_Bits.BOD */


/** \brief Length for Ifx_CPU_CREVT_Bits.SUSP */


/** \brief Mask for Ifx_CPU_CREVT_Bits.SUSP */


/** \brief Offset for Ifx_CPU_CREVT_Bits.SUSP */


/** \brief Length for Ifx_CPU_CREVT_Bits.CNT */


/** \brief Mask for Ifx_CPU_CREVT_Bits.CNT */


/** \brief Offset for Ifx_CPU_CREVT_Bits.CNT */


/** \brief Length for Ifx_CPU_SWEVT_Bits.EVTA */


/** \brief Mask for Ifx_CPU_SWEVT_Bits.EVTA */


/** \brief Offset for Ifx_CPU_SWEVT_Bits.EVTA */


/** \brief Length for Ifx_CPU_SWEVT_Bits.BBM */


/** \brief Mask for Ifx_CPU_SWEVT_Bits.BBM */


/** \brief Offset for Ifx_CPU_SWEVT_Bits.BBM */


/** \brief Length for Ifx_CPU_SWEVT_Bits.BOD */


/** \brief Mask for Ifx_CPU_SWEVT_Bits.BOD */


/** \brief Offset for Ifx_CPU_SWEVT_Bits.BOD */


/** \brief Length for Ifx_CPU_SWEVT_Bits.SUSP */


/** \brief Mask for Ifx_CPU_SWEVT_Bits.SUSP */


/** \brief Offset for Ifx_CPU_SWEVT_Bits.SUSP */


/** \brief Length for Ifx_CPU_SWEVT_Bits.CNT */


/** \brief Mask for Ifx_CPU_SWEVT_Bits.CNT */


/** \brief Offset for Ifx_CPU_SWEVT_Bits.CNT */


/** \brief Length for Ifx_CPU_TRIG_ACC_Bits.T0 */


/** \brief Mask for Ifx_CPU_TRIG_ACC_Bits.T0 */


/** \brief Offset for Ifx_CPU_TRIG_ACC_Bits.T0 */


/** \brief Length for Ifx_CPU_TRIG_ACC_Bits.T1 */


/** \brief Mask for Ifx_CPU_TRIG_ACC_Bits.T1 */


/** \brief Offset for Ifx_CPU_TRIG_ACC_Bits.T1 */


/** \brief Length for Ifx_CPU_TRIG_ACC_Bits.T2 */


/** \brief Mask for Ifx_CPU_TRIG_ACC_Bits.T2 */


/** \brief Offset for Ifx_CPU_TRIG_ACC_Bits.T2 */


/** \brief Length for Ifx_CPU_TRIG_ACC_Bits.T3 */


/** \brief Mask for Ifx_CPU_TRIG_ACC_Bits.T3 */


/** \brief Offset for Ifx_CPU_TRIG_ACC_Bits.T3 */


/** \brief Length for Ifx_CPU_TRIG_ACC_Bits.T4 */


/** \brief Mask for Ifx_CPU_TRIG_ACC_Bits.T4 */


/** \brief Offset for Ifx_CPU_TRIG_ACC_Bits.T4 */


/** \brief Length for Ifx_CPU_TRIG_ACC_Bits.T5 */


/** \brief Mask for Ifx_CPU_TRIG_ACC_Bits.T5 */


/** \brief Offset for Ifx_CPU_TRIG_ACC_Bits.T5 */


/** \brief Length for Ifx_CPU_TRIG_ACC_Bits.T6 */


/** \brief Mask for Ifx_CPU_TRIG_ACC_Bits.T6 */


/** \brief Offset for Ifx_CPU_TRIG_ACC_Bits.T6 */


/** \brief Length for Ifx_CPU_TRIG_ACC_Bits.T7 */


/** \brief Mask for Ifx_CPU_TRIG_ACC_Bits.T7 */


/** \brief Offset for Ifx_CPU_TRIG_ACC_Bits.T7 */


/** \brief Length for Ifx_CPU_DMS_Bits.DMSValue */


/** \brief Mask for Ifx_CPU_DMS_Bits.DMSValue */


/** \brief Offset for Ifx_CPU_DMS_Bits.DMSValue */


/** \brief Length for Ifx_CPU_DCX_Bits.DCXValue */


/** \brief Mask for Ifx_CPU_DCX_Bits.DCXValue */


/** \brief Offset for Ifx_CPU_DCX_Bits.DCXValue */


/** \brief Length for Ifx_CPU_DBGTCR_Bits.DTA */


/** \brief Mask for Ifx_CPU_DBGTCR_Bits.DTA */


/** \brief Offset for Ifx_CPU_DBGTCR_Bits.DTA */


/** \brief Length for Ifx_CPU_PCXI_Bits.PCXO */


/** \brief Mask for Ifx_CPU_PCXI_Bits.PCXO */


/** \brief Offset for Ifx_CPU_PCXI_Bits.PCXO */


/** \brief Length for Ifx_CPU_PCXI_Bits.PCXS */


/** \brief Mask for Ifx_CPU_PCXI_Bits.PCXS */


/** \brief Offset for Ifx_CPU_PCXI_Bits.PCXS */


/** \brief Length for Ifx_CPU_PCXI_Bits.UL */


/** \brief Mask for Ifx_CPU_PCXI_Bits.UL */


/** \brief Offset for Ifx_CPU_PCXI_Bits.UL */


/** \brief Length for Ifx_CPU_PCXI_Bits.PIE */


/** \brief Mask for Ifx_CPU_PCXI_Bits.PIE */


/** \brief Offset for Ifx_CPU_PCXI_Bits.PIE */


/** \brief Length for Ifx_CPU_PCXI_Bits.PCPN */


/** \brief Mask for Ifx_CPU_PCXI_Bits.PCPN */


/** \brief Offset for Ifx_CPU_PCXI_Bits.PCPN */


/** \brief Length for Ifx_CPU_PSW_Bits.CDC */


/** \brief Mask for Ifx_CPU_PSW_Bits.CDC */


/** \brief Offset for Ifx_CPU_PSW_Bits.CDC */


/** \brief Length for Ifx_CPU_PSW_Bits.CDE */


/** \brief Mask for Ifx_CPU_PSW_Bits.CDE */


/** \brief Offset for Ifx_CPU_PSW_Bits.CDE */


/** \brief Length for Ifx_CPU_PSW_Bits.GW */


/** \brief Mask for Ifx_CPU_PSW_Bits.GW */


/** \brief Offset for Ifx_CPU_PSW_Bits.GW */


/** \brief Length for Ifx_CPU_PSW_Bits.IS */


/** \brief Mask for Ifx_CPU_PSW_Bits.IS */


/** \brief Offset for Ifx_CPU_PSW_Bits.IS */


/** \brief Length for Ifx_CPU_PSW_Bits.IO */


/** \brief Mask for Ifx_CPU_PSW_Bits.IO */


/** \brief Offset for Ifx_CPU_PSW_Bits.IO */


/** \brief Length for Ifx_CPU_PSW_Bits.PRS */


/** \brief Mask for Ifx_CPU_PSW_Bits.PRS */


/** \brief Offset for Ifx_CPU_PSW_Bits.PRS */


/** \brief Length for Ifx_CPU_PSW_Bits.S */


/** \brief Mask for Ifx_CPU_PSW_Bits.S */


/** \brief Offset for Ifx_CPU_PSW_Bits.S */


/** \brief Length for Ifx_CPU_PSW_Bits.PRS2 */


/** \brief Mask for Ifx_CPU_PSW_Bits.PRS2 */


/** \brief Offset for Ifx_CPU_PSW_Bits.PRS2 */


/** \brief Length for Ifx_CPU_PSW_Bits.USB */


/** \brief Mask for Ifx_CPU_PSW_Bits.USB */


/** \brief Offset for Ifx_CPU_PSW_Bits.USB */


/** \brief Length for Ifx_CPU_PC_Bits.PC */


/** \brief Mask for Ifx_CPU_PC_Bits.PC */


/** \brief Offset for Ifx_CPU_PC_Bits.PC */


/** \brief Length for Ifx_CPU_SYSCON_Bits.FCDSF */


/** \brief Mask for Ifx_CPU_SYSCON_Bits.FCDSF */


/** \brief Offset for Ifx_CPU_SYSCON_Bits.FCDSF */


/** \brief Length for Ifx_CPU_SYSCON_Bits.PROTEN */


/** \brief Mask for Ifx_CPU_SYSCON_Bits.PROTEN */


/** \brief Offset for Ifx_CPU_SYSCON_Bits.PROTEN */


/** \brief Length for Ifx_CPU_SYSCON_Bits.TPROTEN */


/** \brief Mask for Ifx_CPU_SYSCON_Bits.TPROTEN */


/** \brief Offset for Ifx_CPU_SYSCON_Bits.TPROTEN */


/** \brief Length for Ifx_CPU_SYSCON_Bits.IS */


/** \brief Mask for Ifx_CPU_SYSCON_Bits.IS */


/** \brief Offset for Ifx_CPU_SYSCON_Bits.IS */


/** \brief Length for Ifx_CPU_SYSCON_Bits.TS */


/** \brief Mask for Ifx_CPU_SYSCON_Bits.TS */


/** \brief Offset for Ifx_CPU_SYSCON_Bits.TS */


/** \brief Length for Ifx_CPU_SYSCON_Bits.ESDIS */


/** \brief Mask for Ifx_CPU_SYSCON_Bits.ESDIS */


/** \brief Offset for Ifx_CPU_SYSCON_Bits.ESDIS */


/** \brief Length for Ifx_CPU_SYSCON_Bits.U1_IED */


/** \brief Mask for Ifx_CPU_SYSCON_Bits.U1_IED */


/** \brief Offset for Ifx_CPU_SYSCON_Bits.U1_IED */


/** \brief Length for Ifx_CPU_SYSCON_Bits.U1_IOS */


/** \brief Mask for Ifx_CPU_SYSCON_Bits.U1_IOS */


/** \brief Offset for Ifx_CPU_SYSCON_Bits.U1_IOS */


/** \brief Length for Ifx_CPU_SYSCON_Bits.BHALT */


/** \brief Mask for Ifx_CPU_SYSCON_Bits.BHALT */


/** \brief Offset for Ifx_CPU_SYSCON_Bits.BHALT */


/** \brief Length for Ifx_CPU_CPU_ID_Bits.MOD_REV */


/** \brief Mask for Ifx_CPU_CPU_ID_Bits.MOD_REV */


/** \brief Offset for Ifx_CPU_CPU_ID_Bits.MOD_REV */


/** \brief Length for Ifx_CPU_CPU_ID_Bits.MOD_32B */


/** \brief Mask for Ifx_CPU_CPU_ID_Bits.MOD_32B */


/** \brief Offset for Ifx_CPU_CPU_ID_Bits.MOD_32B */


/** \brief Length for Ifx_CPU_CPU_ID_Bits.MOD */


/** \brief Mask for Ifx_CPU_CPU_ID_Bits.MOD */


/** \brief Offset for Ifx_CPU_CPU_ID_Bits.MOD */


/** \brief Length for Ifx_CPU_CORE_ID_Bits.CORE_ID */


/** \brief Mask for Ifx_CPU_CORE_ID_Bits.CORE_ID */


/** \brief Offset for Ifx_CPU_CORE_ID_Bits.CORE_ID */


/** \brief Length for Ifx_CPU_BIV_Bits.VSS */


/** \brief Mask for Ifx_CPU_BIV_Bits.VSS */


/** \brief Offset for Ifx_CPU_BIV_Bits.VSS */


/** \brief Length for Ifx_CPU_BIV_Bits.BIV */


/** \brief Mask for Ifx_CPU_BIV_Bits.BIV */


/** \brief Offset for Ifx_CPU_BIV_Bits.BIV */


/** \brief Length for Ifx_CPU_BTV_Bits.BTV */


/** \brief Mask for Ifx_CPU_BTV_Bits.BTV */


/** \brief Offset for Ifx_CPU_BTV_Bits.BTV */


/** \brief Length for Ifx_CPU_ISP_Bits.ISP */


/** \brief Mask for Ifx_CPU_ISP_Bits.ISP */


/** \brief Offset for Ifx_CPU_ISP_Bits.ISP */


/** \brief Length for Ifx_CPU_ICR_Bits.CCPN */


/** \brief Mask for Ifx_CPU_ICR_Bits.CCPN */


/** \brief Offset for Ifx_CPU_ICR_Bits.CCPN */


/** \brief Length for Ifx_CPU_ICR_Bits.IE */


/** \brief Mask for Ifx_CPU_ICR_Bits.IE */


/** \brief Offset for Ifx_CPU_ICR_Bits.IE */


/** \brief Length for Ifx_CPU_ICR_Bits.PIPN */


/** \brief Mask for Ifx_CPU_ICR_Bits.PIPN */


/** \brief Offset for Ifx_CPU_ICR_Bits.PIPN */


/** \brief Length for Ifx_CPU_FCX_Bits.FCXO */


/** \brief Mask for Ifx_CPU_FCX_Bits.FCXO */


/** \brief Offset for Ifx_CPU_FCX_Bits.FCXO */


/** \brief Length for Ifx_CPU_FCX_Bits.FCXS */


/** \brief Mask for Ifx_CPU_FCX_Bits.FCXS */


/** \brief Offset for Ifx_CPU_FCX_Bits.FCXS */


/** \brief Length for Ifx_CPU_LCX_Bits.LCXO */


/** \brief Mask for Ifx_CPU_LCX_Bits.LCXO */


/** \brief Offset for Ifx_CPU_LCX_Bits.LCXO */


/** \brief Length for Ifx_CPU_LCX_Bits.LCXS */


/** \brief Mask for Ifx_CPU_LCX_Bits.LCXS */


/** \brief Offset for Ifx_CPU_LCX_Bits.LCXS */


/** \brief Length for Ifx_CPU_CUS_ID_Bits.CID */


/** \brief Mask for Ifx_CPU_CUS_ID_Bits.CID */


/** \brief Offset for Ifx_CPU_CUS_ID_Bits.CID */


/** \brief Length for Ifx_CPU_D_Bits.DATA */


/** \brief Mask for Ifx_CPU_D_Bits.DATA */


/** \brief Offset for Ifx_CPU_D_Bits.DATA */


/** \brief Length for Ifx_CPU_A_Bits.ADDR */


/** \brief Mask for Ifx_CPU_A_Bits.ADDR */


/** \brief Offset for Ifx_CPU_A_Bits.ADDR */


/** \}  */

/******************************************************************************/

/******************************************************************************/


#line 70 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Pms\\Std\\IfxPmsPm.h"

#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Scu\\Std\\IfxScuWdt.h"
/**
 * \file IfxScuWdt.h
 * \brief SCU  basic functionality
 * \ingroup IfxLld_Scu
 *
 * \version iLLD_1_0_1_15_0_1
 * \copyright Copyright (c) 2019 Infineon Technologies AG. All rights reserved.
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 * This file contains the APIs for SCU Watchdog and Endinit related functions.
 *
 * \defgroup IfxLld_Scu_Std_Wdt Wdt Basic Functionality
 * \ingroup IfxLld_Scu_Std
 * \defgroup IfxLld_Scu_Std_Wdt_Wdt_Configuration Watchdog Configuration functions
 * \ingroup IfxLld_Scu_Std_Wdt
 * \defgroup IfxLld_Scu_Std_Wdt_Wdt_Endinit Watchdog Endinit functions
 * \ingroup IfxLld_Scu_Std_Wdt
 * \defgroup IfxLld_Scu_Std_Wdt_Wdt_Operative Watchdog Operative functions
 * \ingroup IfxLld_Scu_Std_Wdt
 * \defgroup IfxLld_Scu_Std_Wdt_Wdt_Endinit_Usage How to use Endinit APIs?
 * \ingroup IfxLld_Scu_Std_Wdt
 */


















































































































































































































































































































































































































































































































































































































































































#line 71 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Pms\\Std\\IfxPmsPm.h"


#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\Infra\\Sfr\\TC38A\\_Reg\\IfxDmu_reg.h"
/**
 * \file IfxDmu_reg.h
 * \brief
 * \copyright Copyright (c) 2020 Infineon Technologies AG. All rights reserved.
 *
 *
 * Version: TC38XA_UM_V1.5.0
 * Specification: TC3xx User Manual V1.5.0
 * MAY BE CHANGED BY USER [yes/no]: No
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * \defgroup IfxSfr_Dmu_Registers_Cfg Dmu address
 * \ingroup IfxSfr_Dmu_Registers
 * 
 * \defgroup IfxSfr_Dmu_Registers_Cfg_BaseAddress Base address
 * \ingroup IfxSfr_Dmu_Registers_Cfg
 *
 * \defgroup IfxSfr_Dmu_Registers_Cfg_Dmu 2-DMU
 * \ingroup IfxSfr_Dmu_Registers_Cfg
 *
 *
 */


/******************************************************************************/

#line 1 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\Infra\\Sfr\\TC38A\\_Reg\\IfxDmu_regdef.h"
/**
 * \file IfxDmu_regdef.h
 * \brief
 * \copyright Copyright (c) 2020 Infineon Technologies AG. All rights reserved.
 *
 *
 * Version: TC38XA_UM_V1.5.0
 * Specification: TC3xx User Manual V1.5.0
 * MAY BE CHANGED BY USER [yes/no]: No
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * \defgroup IfxSfr_Dmu_Registers Dmu Registers
 * \ingroup IfxSfr
 * 
 * \defgroup IfxSfr_Dmu_Registers_Bitfields Bitfields
 * \ingroup IfxSfr_Dmu_Registers
 * 
 * \defgroup IfxSfr_Dmu_Registers_union Register unions
 * \ingroup IfxSfr_Dmu_Registers
 * 
 * \defgroup IfxSfr_Dmu_Registers_struct Memory map
 * \ingroup IfxSfr_Dmu_Registers
 */


/******************************************************************************/

/******************************************************************************/

/******************************************************************************/

/******************************************************************************/


/** \addtogroup IfxSfr_Dmu_Registers_Bitfields
 * \{  */
/** \brief Access Enable Register 0 */
typedef struct _Ifx_DMU_HF_ACCEN0_Bits
{
    Ifx_UReg_32Bit EN0:1;             /**< \brief [0:0] Access Enable for Master TAG ID 0 - EN0 (rw) */
    Ifx_UReg_32Bit EN1:1;             /**< \brief [1:1] Access Enable for Master TAG ID 1 - EN1 (rw) */
    Ifx_UReg_32Bit EN2:1;             /**< \brief [2:2] Access Enable for Master TAG ID 2 - EN2 (rw) */
    Ifx_UReg_32Bit EN3:1;             /**< \brief [3:3] Access Enable for Master TAG ID 3 - EN3 (rw) */
    Ifx_UReg_32Bit EN4:1;             /**< \brief [4:4] Access Enable for Master TAG ID 4 - EN4 (rw) */
    Ifx_UReg_32Bit EN5:1;             /**< \brief [5:5] Access Enable for Master TAG ID 5 - EN5 (rw) */
    Ifx_UReg_32Bit EN6:1;             /**< \brief [6:6] Access Enable for Master TAG ID 6 - EN6 (rw) */
    Ifx_UReg_32Bit EN7:1;             /**< \brief [7:7] Access Enable for Master TAG ID 7 - EN7 (rw) */
    Ifx_UReg_32Bit EN8:1;             /**< \brief [8:8] Access Enable for Master TAG ID 8 - EN8 (rw) */
    Ifx_UReg_32Bit EN9:1;             /**< \brief [9:9] Access Enable for Master TAG ID 9 - EN9 (rw) */
    Ifx_UReg_32Bit EN10:1;            /**< \brief [10:10] Access Enable for Master TAG ID 10 - EN10 (rw) */
    Ifx_UReg_32Bit EN11:1;            /**< \brief [11:11] Access Enable for Master TAG ID 11 - EN11 (rw) */
    Ifx_UReg_32Bit EN12:1;            /**< \brief [12:12] Access Enable for Master TAG ID 12 - EN12 (rw) */
    Ifx_UReg_32Bit EN13:1;            /**< \brief [13:13] Access Enable for Master TAG ID 13 - EN13 (rw) */
    Ifx_UReg_32Bit EN14:1;            /**< \brief [14:14] Access Enable for Master TAG ID 14 - EN14 (rw) */
    Ifx_UReg_32Bit EN15:1;            /**< \brief [15:15] Access Enable for Master TAG ID 15 - EN15 (rw) */
    Ifx_UReg_32Bit EN16:1;            /**< \brief [16:16] Access Enable for Master TAG ID 16 - EN16 (rw) */
    Ifx_UReg_32Bit EN17:1;            /**< \brief [17:17] Access Enable for Master TAG ID 17 - EN17 (rw) */
    Ifx_UReg_32Bit EN18:1;            /**< \brief [18:18] Access Enable for Master TAG ID 18 - EN18 (rw) */
    Ifx_UReg_32Bit EN19:1;            /**< \brief [19:19] Access Enable for Master TAG ID 19 - EN19 (rw) */
    Ifx_UReg_32Bit EN20:1;            /**< \brief [20:20] Access Enable for Master TAG ID 20 - EN20 (rw) */
    Ifx_UReg_32Bit EN21:1;            /**< \brief [21:21] Access Enable for Master TAG ID 21 - EN21 (rw) */
    Ifx_UReg_32Bit EN22:1;            /**< \brief [22:22] Access Enable for Master TAG ID 22 - EN22 (rw) */
    Ifx_UReg_32Bit EN23:1;            /**< \brief [23:23] Access Enable for Master TAG ID 23 - EN23 (rw) */
    Ifx_UReg_32Bit EN24:1;            /**< \brief [24:24] Access Enable for Master TAG ID 24 - EN24 (rw) */
    Ifx_UReg_32Bit EN25:1;            /**< \brief [25:25] Access Enable for Master TAG ID 25 - EN25 (rw) */
    Ifx_UReg_32Bit EN26:1;            /**< \brief [26:26] Access Enable for Master TAG ID 26 - EN26 (rw) */
    Ifx_UReg_32Bit EN27:1;            /**< \brief [27:27] Access Enable for Master TAG ID 27 - EN27 (rw) */
    Ifx_UReg_32Bit EN28:1;            /**< \brief [28:28] Access Enable for Master TAG ID 28 - EN28 (rw) */
    Ifx_UReg_32Bit EN29:1;            /**< \brief [29:29] Access Enable for Master TAG ID 29 - EN29 (rw) */
    Ifx_UReg_32Bit EN30:1;            /**< \brief [30:30] Access Enable for Master TAG ID 30 - EN30 (rw) */
    Ifx_UReg_32Bit EN31:1;            /**< \brief [31:31] Access Enable for Master TAG ID 31 - EN31 (rw) */
} Ifx_DMU_HF_ACCEN0_Bits;

/** \brief Access Enable Register 1 */
typedef struct _Ifx_DMU_HF_ACCEN1_Bits
{
    Ifx_UReg_32Bit reserved_0:32;     /**< \brief [31:0] \internal Reserved */
} Ifx_DMU_HF_ACCEN1_Bits;

/** \brief Cranking Control Register */
typedef struct _Ifx_DMU_HF_CCONTROL_Bits
{
    Ifx_UReg_32Bit CRANKING:2;        /**< \brief [1:0] Cranking Mode Control - CRANKING (rw) */
    Ifx_UReg_32Bit reserved_2:30;     /**< \brief [31:2] \internal Reserved */
} Ifx_DMU_HF_CCONTROL_Bits;

/** \brief Clear Error Register */
typedef struct _Ifx_DMU_HF_CLRE_Bits
{
    Ifx_UReg_32Bit reserved_0:1;      /**< \brief [0:0] \internal Reserved */
    Ifx_UReg_32Bit CSQER:1;           /**< \brief [1:1] Clear Command Sequence Error - CSQER (w) */
    Ifx_UReg_32Bit CPROER:1;          /**< \brief [2:2] Clear Protection Error - CPROER (w) */
    Ifx_UReg_32Bit CPVER:1;           /**< \brief [3:3] Clear Program Verify Error - CPVER (w) */
    Ifx_UReg_32Bit CEVER:1;           /**< \brief [4:4] Clear Erase Verify Error - CEVER (w) */
    Ifx_UReg_32Bit CADER:1;           /**< \brief [5:5] Clear SRI Bus Address ECC Error - CADER (w) */
    Ifx_UReg_32Bit reserved_6:26;     /**< \brief [31:6] \internal Reserved */
} Ifx_DMU_HF_CLRE_Bits;

/** \brief Flash Confirm Status Register 0 */
typedef struct _Ifx_DMU_HF_CONFIRM0_Bits
{
    Ifx_UReg_32Bit PROINBMHD0O:2;     /**< \brief [1:0] UCB_BMHD0_ORIG Confirmation - PROINBMHD0O (rh) */
    Ifx_UReg_32Bit PROINBMHD1O:2;     /**< \brief [3:2] UCB_BMHD1_ORIG Confirmation - PROINBMHD1O (rh) */
    Ifx_UReg_32Bit PROINBMHD2O:2;     /**< \brief [5:4] UCB_BMHD2_ORIG Confirmation - PROINBMHD2O (rh) */
    Ifx_UReg_32Bit PROINBMHD3O:2;     /**< \brief [7:6] UCB_BMHD3_ORIG Confirmation - PROINBMHD3O (rh) */
    Ifx_UReg_32Bit PROINSSW:2;        /**< \brief [9:8] UCB_SSW Confirmation - PROINSSW (rh) */
    Ifx_UReg_32Bit PROINUSER:2;       /**< \brief [11:10] UCB_USER Confirmation - PROINUSER (rh) */
    Ifx_UReg_32Bit PROINTEST:2;       /**< \brief [13:12] UCB_TEST Confirmation - PROINTEST (rh) */
    Ifx_UReg_32Bit PROINHSMCFG:2;     /**< \brief [15:14] UCB_HSMCFG Confirmation - PROINHSMCFG (rh) */
    Ifx_UReg_32Bit PROINBMHD0C:2;     /**< \brief [17:16] UCB_BMHD0_COPY Confirmation - PROINBMHD0C (rh) */
    Ifx_UReg_32Bit PROINBMHD1C:2;     /**< \brief [19:18] UCB_BMHD1_COPY Confirmation - PROINBMHD1C (rh) */
    Ifx_UReg_32Bit PROINBMHD2C:2;     /**< \brief [21:20] UCB_BMHD2_COPY Confirmation - PROINBMHD2C (rh) */
    Ifx_UReg_32Bit PROINBMHD3C:2;     /**< \brief [23:22] UCB_BMHD3_COPY Confirmation - PROINBMHD3C (rh) */
    Ifx_UReg_32Bit PROINREDSEC:2;     /**< \brief [25:24] UCB_REDSEC Confirmation - PROINREDSEC (rh) */
    Ifx_UReg_32Bit reserved_26:4;     /**< \brief [29:26] \internal Reserved */
    Ifx_UReg_32Bit PROINSRT:2;        /**< \brief [31:30] UCB_RETEST Confirmation - PROINSRT (rh) */
} Ifx_DMU_HF_CONFIRM0_Bits;

/** \brief Flash Confirm Status Register 1 */
typedef struct _Ifx_DMU_HF_CONFIRM1_Bits
{
    Ifx_UReg_32Bit PROINPO:2;         /**< \brief [1:0] UCB_PFLASH_ORIG Confirmation - PROINPO (rh) */
    Ifx_UReg_32Bit PROINDO:2;         /**< \brief [3:2] UCB_DFLASH_ORIG Confirmation - PROINDO (rh) */
    Ifx_UReg_32Bit PROINDBGO:2;       /**< \brief [5:4] UCB_DBG_ORIG Confirmation - PROINDBGO (rh) */
    Ifx_UReg_32Bit PROINHSMO:2;       /**< \brief [7:6] UCB_HSM_ORIG Confirmation - PROINHSMO (rh) */
    Ifx_UReg_32Bit PROINHSMCOTP0O:2;    /**< \brief [9:8] UCB_HSMCOTP0_ORIG Protection - PROINHSMCOTP0O (rh) */
    Ifx_UReg_32Bit PROINHSMCOTP1O:2;    /**< \brief [11:10] UCB_HSMCOTP1_ORIG Protection - PROINHSMCOTP1O (rh) */
    Ifx_UReg_32Bit PROINECO:2;        /**< \brief [13:12] UCB_ECPRIO_ORIG Confirmation - PROINECO (rh) */
    Ifx_UReg_32Bit reserved_14:2;     /**< \brief [15:14] \internal Reserved */
    Ifx_UReg_32Bit PROINPC:2;         /**< \brief [17:16] UCB_PFLASH_COPY Confirmation - PROINPC (rh) */
    Ifx_UReg_32Bit PROINDC:2;         /**< \brief [19:18] UCB_DFLASH_COPY Confirmation - PROINDC (rh) */
    Ifx_UReg_32Bit PROINDBGC:2;       /**< \brief [21:20] UCB_DBG_COPY Interface Confirmation - PROINDBGC (rh) */
    Ifx_UReg_32Bit PROINHSMC:2;       /**< \brief [23:22] UCB_HSM_COPY Confirmation - PROINHSMC (rh) */
    Ifx_UReg_32Bit PROINHSMCOTP0C:2;    /**< \brief [25:24] UCB_HSMCOTP0_COPY Protection - PROINHSMCOTP0C (rh) */
    Ifx_UReg_32Bit PROINHSMCOTP1C:2;    /**< \brief [27:26] UCB_HSMCOTP1_COPY Protection - PROINHSMCOTP1C (rh) */
    Ifx_UReg_32Bit PROINECC:2;        /**< \brief [29:28] UCB_ECPRIO_COPY Confirmation - PROINECC (rh) */
    Ifx_UReg_32Bit reserved_30:2;     /**< \brief [31:30] \internal Reserved */
} Ifx_DMU_HF_CONFIRM1_Bits;

/** \brief Flash Confirm Status Register 2 */
typedef struct _Ifx_DMU_HF_CONFIRM2_Bits
{
    Ifx_UReg_32Bit PROINOTP0O:2;      /**< \brief [1:0] UCB_OTP0_ORIG Confirmation - PROINOTP0O (rh) */
    Ifx_UReg_32Bit PROINOTP1O:2;      /**< \brief [3:2] UCB_OTP1_ORIG Confirmation - PROINOTP1O (rh) */
    Ifx_UReg_32Bit PROINOTP2O:2;      /**< \brief [5:4] UCB_OTP2_ORIG Confirmation - PROINOTP2O (rh) */
    Ifx_UReg_32Bit PROINOTP3O:2;      /**< \brief [7:6] UCB_OTP3_ORIG Confirmation - PROINOTP3O (rh) */
    Ifx_UReg_32Bit PROINOTP4O:2;      /**< \brief [9:8] UCB_OTP4_ORIG Confirmation - PROINOTP4O (rh) */
    Ifx_UReg_32Bit PROINOTP5O:2;      /**< \brief [11:10] UCB_OTP5_ORIG Confirmation - PROINOTP5O (rh) */
    Ifx_UReg_32Bit PROINOTP6O:2;      /**< \brief [13:12] UCB_OTP6_ORIG Confirmation - PROINOTP6O (rh) */
    Ifx_UReg_32Bit PROINOTP7O:2;      /**< \brief [15:14] UCB_OTP7_ORIG Confirmation - PROINOTP7O (rh) */
    Ifx_UReg_32Bit PROINOTP0C:2;      /**< \brief [17:16] UCB_OTP0_COPY Confirmation - PROINOTP0C (rh) */
    Ifx_UReg_32Bit PROINOTP1C:2;      /**< \brief [19:18] UCB_OTP1_COPY Confirmation - PROINOTP1C (rh) */
    Ifx_UReg_32Bit PROINOTP2C:2;      /**< \brief [21:20] UCB_OTP2_COPY Confirmation - PROINOTP2C (rh) */
    Ifx_UReg_32Bit PROINOTP3C:2;      /**< \brief [23:22] UCB_OTP3_COPY Confirmation - PROINOTP3C (rh) */
    Ifx_UReg_32Bit PROINOTP4C:2;      /**< \brief [25:24] UCB_OTP4_COPY Confirmation - PROINOTP4C (rh) */
    Ifx_UReg_32Bit PROINOTP5C:2;      /**< \brief [27:26] UCB_OTP5_COPY Confirmation - PROINOTP5C (rh) */
    Ifx_UReg_32Bit PROINOTP6C:2;      /**< \brief [29:28] UCB_OTP6_COPY Confirmation - PROINOTP6C (rh) */
    Ifx_UReg_32Bit PROINOTP7C:2;      /**< \brief [31:30] UCB_OTP7_COPY Confirmation - PROINOTP7C (rh) */
} Ifx_DMU_HF_CONFIRM2_Bits;

/** \brief Flash Control Register */
typedef struct _Ifx_DMU_HF_CONTROL_Bits
{
    Ifx_UReg_32Bit reserved_0:3;      /**< \brief [2:0] \internal Reserved */
    Ifx_UReg_32Bit reserved_3:1;      /**< \brief [3:3] \internal Reserved */
    Ifx_UReg_32Bit FSIENPE:2;         /**< \brief [5:4] Enable Program/Erase - FSIENPE (rw) */
    Ifx_UReg_32Bit reserved_6:1;      /**< \brief [6:6] \internal Reserved */
    Ifx_UReg_32Bit WSERRINJ:1;        /**< \brief [7:7] PFlash Wait State ECC error injection - WSERRINJ (rw) */
    Ifx_UReg_32Bit DDFP:1;            /**< \brief [8:8] Disable Read from PFLASH - DDFP (rwh) */
    Ifx_UReg_32Bit DDFD:1;            /**< \brief [9:9] Disable Data Fetch from DF0_EEPROM - DDFD (rwh) */
    Ifx_UReg_32Bit reserved_10:6;     /**< \brief [15:10] \internal Reserved */
    Ifx_UReg_32Bit CPROG:1;           /**< \brief [16:16] Clear Programming State - CPROG (w) */
    Ifx_UReg_32Bit CERASE:1;          /**< \brief [17:17] Clear Erase State - CERASE (w) */
    Ifx_UReg_32Bit reserved_18:1;     /**< \brief [18:18] \internal Reserved */
    Ifx_UReg_32Bit reserved_19:13;    /**< \brief [31:19] \internal Reserved */
} Ifx_DMU_HF_CONTROL_Bits;

/** \brief DFLASH Wait Cycle Register */
typedef struct _Ifx_DMU_HF_DWAIT_Bits
{
    Ifx_UReg_32Bit RFLASH:8;          /**< \brief [7:0] Operation Mode - RFLASH (rw) */
    Ifx_UReg_32Bit reserved_8:8;      /**< \brief [15:8] \internal Reserved */
    Ifx_UReg_32Bit RECC:3;            /**< \brief [18:16] Operation Mode - RECC (rw) */
    Ifx_UReg_32Bit reserved_19:13;    /**< \brief [31:19] \internal Reserved */
} Ifx_DMU_HF_DWAIT_Bits;

/** \brief DF0 ECC Control Register */
typedef struct _Ifx_DMU_HF_ECCC_Bits
{
    Ifx_UReg_32Bit CLR:2;             /**< \brief [1:0] Clear ECC status bits - CLR (w) */
    Ifx_UReg_32Bit reserved_2:26;     /**< \brief [27:2] \internal Reserved */
    Ifx_UReg_32Bit ECCCORDIS:2;       /**< \brief [29:28] Host Command Interface ECC Correction Disable - ECCCORDIS (rw) */
    Ifx_UReg_32Bit TRAPDIS:2;         /**< \brief [31:30] Host Command Interface Uncorrectable ECC Bit Error Trap Disable - TRAPDIS (rw) */
} Ifx_DMU_HF_ECCC_Bits;

/** \brief DF0 ECC Read Register */
typedef struct _Ifx_DMU_HF_ECCR_Bits
{
    Ifx_UReg_32Bit RCODE:22;          /**< \brief [21:0] Error Correction Read Code - RCODE (rh) */
    Ifx_UReg_32Bit reserved_22:2;     /**< \brief [23:22] \internal Reserved */
    Ifx_UReg_32Bit reserved_24:8;     /**< \brief [31:24] \internal Reserved */
} Ifx_DMU_HF_ECCR_Bits;

/** \brief DF0 ECC Status Register */
typedef struct _Ifx_DMU_HF_ECCS_Bits
{
    Ifx_UReg_32Bit ERR1:1;            /**< \brief [0:0] Read Access Single Bit ECC Error - ERR1 (rh) */
    Ifx_UReg_32Bit ERR2:1;            /**< \brief [1:1] Read Access Double Bit ECC Error - ERR2 (rh) */
    Ifx_UReg_32Bit ERR3:1;            /**< \brief [2:2] Read Access Triple Bit ECC Error - ERR3 (rh) */
    Ifx_UReg_32Bit ERRM:1;            /**< \brief [3:3] Read Access Multi-bit ECC Error - ERRM (rh) */
    Ifx_UReg_32Bit reserved_4:3;      /**< \brief [6:4] \internal Reserved */
    Ifx_UReg_32Bit ERRANY:1;          /**< \brief [7:7] Any Read Access ECC Error - ERRANY (rh) */
    Ifx_UReg_32Bit reserved_8:1;      /**< \brief [8:8] \internal Reserved */
    Ifx_UReg_32Bit BLANKA:1;          /**< \brief [9:9] Read Access Blank Analog - BLANKA (rh) */
    Ifx_UReg_32Bit reserved_10:6;     /**< \brief [15:10] \internal Reserved */
    Ifx_UReg_32Bit AER1:1;            /**< \brief [16:16] Accumulated Single Bit ECC Errors - AER1 (rh) */
    Ifx_UReg_32Bit AER2:1;            /**< \brief [17:17] Accumulated Double Bit ECC Errors - AER2 (rh) */
    Ifx_UReg_32Bit AER3:1;            /**< \brief [18:18] Accumulated Triple Bit ECC Errors - AER3 (rh) */
    Ifx_UReg_32Bit AERM:1;            /**< \brief [19:19] Accumulated Multi-bit ECC Errors - AERM (rh) */
    Ifx_UReg_32Bit reserved_20:3;     /**< \brief [22:20] \internal Reserved */
    Ifx_UReg_32Bit AERANY:1;          /**< \brief [23:23] Accumulated Any Read Access ECC Error - AERANY (rh) */
    Ifx_UReg_32Bit reserved_24:1;     /**< \brief [24:24] \internal Reserved */
    Ifx_UReg_32Bit ABLANKA:1;         /**< \brief [25:25] Accumulated Blank Analog - ABLANKA (rh) */
    Ifx_UReg_32Bit reserved_26:6;     /**< \brief [31:26] \internal Reserved */
} Ifx_DMU_HF_ECCS_Bits;

/** \brief DF0 ECC Write Register */
typedef struct _Ifx_DMU_HF_ECCW_Bits
{
    Ifx_UReg_32Bit WCODE:22;          /**< \brief [21:0] Error Correction Write Code - WCODE (rw) */
    Ifx_UReg_32Bit reserved_22:6;     /**< \brief [27:22] \internal Reserved */
    Ifx_UReg_32Bit PECENCDIS:2;       /**< \brief [29:28] PFLASH ECC Encoding Disable - PECENCDIS (rw) */
    Ifx_UReg_32Bit DECENCDIS:2;       /**< \brief [31:30] DFLASH ECC Encoding Disable - DECENCDIS (rw) */
} Ifx_DMU_HF_ECCW_Bits;

/** \brief Enable Error Interrupt Control Register */
typedef struct _Ifx_DMU_HF_EER_Bits
{
    Ifx_UReg_32Bit OPERM:1;           /**< \brief [0:0] Operation Error Interrupt Mask - OPERM (rw) */
    Ifx_UReg_32Bit SQERM:1;           /**< \brief [1:1] Command Sequence Error Interrupt Mask - SQERM (rw) */
    Ifx_UReg_32Bit PROERM:1;          /**< \brief [2:2] Protection Error Interrupt Mask - PROERM (rw) */
    Ifx_UReg_32Bit PVERM:1;           /**< \brief [3:3] Program Verify Error Interrupt Mask - PVERM (rw) */
    Ifx_UReg_32Bit EVERM:1;           /**< \brief [4:4] Erase Verify Error Interrupt Mask - EVERM (rw) */
    Ifx_UReg_32Bit reserved_5:26;     /**< \brief [30:5] \internal Reserved */
    Ifx_UReg_32Bit EOBM:1;            /**< \brief [31:31] End of Busy Interrupt Mask - EOBM (rw) */
} Ifx_DMU_HF_EER_Bits;

/** \brief Error Status Register */
typedef struct _Ifx_DMU_HF_ERRSR_Bits
{
    Ifx_UReg_32Bit OPER:1;            /**< \brief [0:0] Flash Operation Error - OPER (rh) */
    Ifx_UReg_32Bit SQER:1;            /**< \brief [1:1] Command Sequence Error - SQER (rh) */
    Ifx_UReg_32Bit PROER:1;           /**< \brief [2:2] Protection Error - PROER (rh) */
    Ifx_UReg_32Bit PVER:1;            /**< \brief [3:3] Program Verify Error - PVER (rh) */
    Ifx_UReg_32Bit EVER:1;            /**< \brief [4:4] Erase Verify Error - EVER (rh) */
    Ifx_UReg_32Bit ADER:1;            /**< \brief [5:5] SRI Bus Address ECC Error - ADER (rh) */
    Ifx_UReg_32Bit ORIER:1;           /**< \brief [6:6] Original Error - ORIER (rh) */
    Ifx_UReg_32Bit reserved_7:1;      /**< \brief [7:7] \internal Reserved */
    Ifx_UReg_32Bit reserved_8:24;     /**< \brief [31:8] \internal Reserved */
} Ifx_DMU_HF_ERRSR_Bits;

/** \brief Module Identification Register */
typedef struct _Ifx_DMU_HF_ID_Bits
{
    Ifx_UReg_32Bit MOD_REV:8;         /**< \brief [7:0] Module Revision Number - MOD_REV (r) */
    Ifx_UReg_32Bit MOD_TYPE:8;        /**< \brief [15:8] Module Type - MOD_TYPE (r) */
    Ifx_UReg_32Bit MOD_NUMBER:8;      /**< \brief [23:16] Module Number Value - MOD_NUMBER (r) */
    Ifx_UReg_32Bit FLASH_REV:8;       /**< \brief [31:24] Flash Revision - FLASH_REV (r) */
} Ifx_DMU_HF_ID_Bits;

/** \brief Margin Control Register */
typedef struct _Ifx_DMU_HF_MARGIN_Bits
{
    Ifx_UReg_32Bit SELD0:2;           /**< \brief [1:0] DF0 Margin Read Selection - SELD0 (rw) */
    Ifx_UReg_32Bit reserved_2:6;      /**< \brief [7:2] \internal Reserved */
    Ifx_UReg_32Bit HMARGIN:1;         /**< \brief [8:8] Hard Margin Selection - HMARGIN (rw) */
    Ifx_UReg_32Bit reserved_9:23;     /**< \brief [31:9] \internal Reserved */
} Ifx_DMU_HF_MARGIN_Bits;

/** \brief Flash Operation Register */
typedef struct _Ifx_DMU_HF_OPERATION_Bits
{
    Ifx_UReg_32Bit PROG:1;            /**< \brief [0:0] Programming State - PROG (rh) */
    Ifx_UReg_32Bit ERASE:1;           /**< \brief [1:1] Erase State - ERASE (rh) */
    Ifx_UReg_32Bit reserved_2:1;      /**< \brief [2:2] \internal Reserved */
    Ifx_UReg_32Bit reserved_3:5;      /**< \brief [7:3] \internal Reserved */
    Ifx_UReg_32Bit reserved_8:3;      /**< \brief [10:8] \internal Reserved */
    Ifx_UReg_32Bit reserved_11:21;    /**< \brief [31:11] \internal Reserved */
} Ifx_DMU_HF_OPERATION_Bits;

/** \brief Power Control Register */
typedef struct _Ifx_DMU_HF_PCONTROL_Bits
{
    Ifx_UReg_32Bit SLEEP:2;           /**< \brief [1:0] Sleep Mode Control - SLEEP (rw) */
    Ifx_UReg_32Bit reserved_2:6;      /**< \brief [7:2] \internal Reserved */
    Ifx_UReg_32Bit IDLE:2;            /**< \brief [9:8] Dynamic Idle Enable - IDLE (w) */
    Ifx_UReg_32Bit DEMAND:2;          /**< \brief [11:10] Demand Enable - DEMAND (w) */
    Ifx_UReg_32Bit reserved_12:4;     /**< \brief [15:12] \internal Reserved */
    Ifx_UReg_32Bit ESLDIS:2;          /**< \brief [17:16] External Sleep Mode Request Disable - ESLDIS (rw) */
    Ifx_UReg_32Bit reserved_18:12;    /**< \brief [29:18] \internal Reserved */
    Ifx_UReg_32Bit PR5V:2;            /**< \brief [31:30] Programming Supply 5V - PR5V (rw) */
} Ifx_DMU_HF_PCONTROL_Bits;

/** \brief Debug Interface Protection Configuration */
typedef struct _Ifx_DMU_HF_PROCONDBG_Bits
{
    Ifx_UReg_32Bit OCDSDIS:1;         /**< \brief [0:0] OCDS Disabled - OCDSDIS (rh) */
    Ifx_UReg_32Bit DBGIFLCK:1;        /**< \brief [1:1] Debug Interface Locked - DBGIFLCK (rh) */
    Ifx_UReg_32Bit EDM:2;             /**< \brief [3:2] Entered Debug Mode - EDM (rh) */
    Ifx_UReg_32Bit reserved_4:4;      /**< \brief [7:4] \internal Reserved */
    Ifx_UReg_32Bit TIC:4;             /**< \brief [11:8] Tool Interface Control - TIC (rh) */
    Ifx_UReg_32Bit reserved_12:4;     /**< \brief [15:12] \internal Reserved */
    Ifx_UReg_32Bit reserved_16:16;    /**< \brief [31:16] \internal Reserved */
} Ifx_DMU_HF_PROCONDBG_Bits;

/** \brief DFLASH Protection Configuration */
typedef struct _Ifx_DMU_HF_PROCONDF_Bits
{
    Ifx_UReg_32Bit L:1;               /**< \brief [0:0] DF0_EEPROM Locked for Write Protection - L (rh) */
    Ifx_UReg_32Bit reserved_1:2;      /**< \brief [2:1] \internal Reserved */
    Ifx_UReg_32Bit HYSEN:1;           /**< \brief [3:3] Hysteresis enable (rh) */
    Ifx_UReg_32Bit HYSCTL:2;          /**< \brief [5:4] Hysteresis Control (rh) */
    Ifx_UReg_32Bit AMPCTL:2;          /**< \brief [7:6] Amplitude Control (rh) */
    Ifx_UReg_32Bit OSCCFG:1;          /**< \brief [8:8] OSC Configuration by SSW - OSCCFG (rh) */
    Ifx_UReg_32Bit MODE:2;            /**< \brief [10:9] OSC Mode - MODE (rh) */
    Ifx_UReg_32Bit APREN:1;           /**< \brief [11:11] OSC Amplitude Regulation Enable - APREN (rh) */
    Ifx_UReg_32Bit CAP0EN:1;          /**< \brief [12:12] OSC Capacitance 0 Enable (x=0-3) - CAP0EN (rh) */
    Ifx_UReg_32Bit CAP1EN:1;          /**< \brief [13:13] OSC Capacitance 1 Enable (x=0-3) - CAP1EN (rh) */
    Ifx_UReg_32Bit CAP2EN:1;          /**< \brief [14:14] OSC Capacitance 2 Enable (x=0-3) - CAP2EN (rh) */
    Ifx_UReg_32Bit CAP3EN:1;          /**< \brief [15:15] OSC Capacitance 3 Enable (x=0-3) - CAP3EN (rh) */
    Ifx_UReg_32Bit ESR0CNT:12;        /**< \brief [27:16] ESR0 Prolongation Counter - ESR0CNT (rh) */
    Ifx_UReg_32Bit reserved_28:3;     /**< \brief [30:28] \internal Reserved */
    Ifx_UReg_32Bit RPRO:1;            /**< \brief [31:31] Read Protection Configuration - RPRO (rh) */
} Ifx_DMU_HF_PROCONDF_Bits;

/** \brief PFLASH Protection Configuration */
typedef struct _Ifx_DMU_HF_PROCONPF_Bits
{
    Ifx_UReg_32Bit reserved_0:31;     /**< \brief [30:0] \internal Reserved */
    Ifx_UReg_32Bit RPRO:1;            /**< \brief [31:31] Read Protection Configuration - RPRO (rh) */
} Ifx_DMU_HF_PROCONPF_Bits;

/** \brief RAM Configuration */
typedef struct _Ifx_DMU_HF_PROCONRAM_Bits
{
    Ifx_UReg_32Bit RAMIN:2;           /**< \brief [1:0] RAM Initialization by SSW Control - RAMIN (rh) */
    Ifx_UReg_32Bit reserved_2:14;     /**< \brief [15:2] \internal Reserved */
    Ifx_UReg_32Bit RAMINSEL:6;        /**< \brief [21:16] RAM Initialization Selection - RAMINSEL (rh) */
    Ifx_UReg_32Bit reserved_22:2;     /**< \brief [23:22] \internal Reserved */
    Ifx_UReg_32Bit LMUINSEL:7;        /**< \brief [30:24] LMU Initialization Selection - LMUINSEL (rh) */
    Ifx_UReg_32Bit reserved_31:1;     /**< \brief [31:31] \internal Reserved */
} Ifx_DMU_HF_PROCONRAM_Bits;

/** \brief Tuning Protection Configuration */
typedef struct _Ifx_DMU_HF_PROCONTP_Bits
{
    Ifx_UReg_32Bit TP:1;              /**< \brief [0:0] Tuning Protection - TP (rh) */
    Ifx_UReg_32Bit reserved_1:7;      /**< \brief [7:1] \internal Reserved */
    Ifx_UReg_32Bit BML:2;             /**< \brief [9:8] Boot Mode Lock - BML (rh) */
    Ifx_UReg_32Bit reserved_10:6;     /**< \brief [15:10] \internal Reserved */
    Ifx_UReg_32Bit SWAPEN:2;          /**< \brief [17:16] Enable SOTA mode - SWAPEN (rh) */
    Ifx_UReg_32Bit CPU0DDIS:1;        /**< \brief [18:18] Disable direct LPB access (rh) */
    Ifx_UReg_32Bit CPU1DDIS:1;        /**< \brief [19:19] Disable direct LPB access (rh) */
    Ifx_UReg_32Bit CPU2DDIS:1;        /**< \brief [20:20] Disable direct LPB access (rh) */
    Ifx_UReg_32Bit CPU3DDIS:1;        /**< \brief [21:21] Disable direct LPB access (rh) */
    Ifx_UReg_32Bit reserved_22:1;     /**< \brief [22:22] \internal Reserved */
    Ifx_UReg_32Bit reserved_23:1;     /**< \brief [23:23] \internal Reserved */
    Ifx_UReg_32Bit reserved_24:8;     /**< \brief [31:24] \internal Reserved */
} Ifx_DMU_HF_PROCONTP_Bits;

/** \brief DF0 User Mode Control */
typedef struct _Ifx_DMU_HF_PROCONUSR_Bits
{
    Ifx_UReg_32Bit MODE:2;            /**< \brief [1:0] DF0 User Mode Control - MODE (rh) */
    Ifx_UReg_32Bit reserved_2:30;     /**< \brief [31:2] \internal Reserved */
} Ifx_DMU_HF_PROCONUSR_Bits;

/** \brief Flash Protection Status Register */
typedef struct _Ifx_DMU_HF_PROTECT_Bits
{
    Ifx_UReg_32Bit PRODISP:1;         /**< \brief [0:0] PFLASH Protection Disabled - PRODISP (rh) */
    Ifx_UReg_32Bit PRODISD:1;         /**< \brief [1:1] DFLASH Protection Disabled - PRODISD (rh) */
    Ifx_UReg_32Bit PRODISDBG:1;       /**< \brief [2:2] Debug Interface Password Protection Disabled - PRODISDBG (rh) */
    Ifx_UReg_32Bit PRODISEC:1;        /**< \brief [3:3] Erase Counter Priority Protection Disabled - PRODISEC (rh) */
    Ifx_UReg_32Bit PRODISBMHD:1;      /**< \brief [4:4] BMHD Protection Disabled - PRODISBMHD (rh) */
    Ifx_UReg_32Bit PRODISSWAP:1;      /**< \brief [5:5] UCB_SWAP protection Disabled - PRODISSWAP (rh) */
    Ifx_UReg_32Bit reserved_6:2;      /**< \brief [7:6] \internal Reserved */
    Ifx_UReg_32Bit PRODISP0:1;        /**< \brief [8:8] Program Flash Protection Disable PRODISP0 (rh) */
    Ifx_UReg_32Bit PRODISP1:1;        /**< \brief [9:9] Program Flash Protection Disable PRODISP1 (rh) */
    Ifx_UReg_32Bit PRODISP2:1;        /**< \brief [10:10] Program Flash Protection Disable PRODISP2 (rh) */
    Ifx_UReg_32Bit PRODISP3:1;        /**< \brief [11:11] Program Flash Protection Disable PRODISP3 (rh) */
    Ifx_UReg_32Bit reserved_12:1;     /**< \brief [12:12] \internal Reserved */
    Ifx_UReg_32Bit reserved_13:1;     /**< \brief [13:13] \internal Reserved */
    Ifx_UReg_32Bit reserved_14:10;    /**< \brief [23:14] \internal Reserved */
    Ifx_UReg_32Bit SRT:1;             /**< \brief [24:24] Secure Retest Password Protection Disabled - SRT (rh) */
    Ifx_UReg_32Bit reserved_25:7;     /**< \brief [31:25] \internal Reserved */
} Ifx_DMU_HF_PROTECT_Bits;

/** \brief Power Status Register */
typedef struct _Ifx_DMU_HF_PSTATUS_Bits
{
    Ifx_UReg_32Bit SLEEP:1;           /**< \brief [0:0] Sleep Mode - SLEEP (rh) */
    Ifx_UReg_32Bit IDLE:1;            /**< \brief [1:1] Dynamic Idle - IDLE (rh) */
    Ifx_UReg_32Bit DEMAND:1;          /**< \brief [2:2] Demand - DEMAND (rh) */
    Ifx_UReg_32Bit reserved_3:29;     /**< \brief [31:3] \internal Reserved */
} Ifx_DMU_HF_PSTATUS_Bits;

/** \brief PFLASH Wait Cycle Register */
typedef struct _Ifx_DMU_HF_PWAIT_Bits
{
    Ifx_UReg_32Bit RFLASH:6;          /**< \brief [5:0] Operation Mode - RFLASH (rw) */
    Ifx_UReg_32Bit reserved_6:2;      /**< \brief [7:6] \internal Reserved */
    Ifx_UReg_32Bit RECC:3;            /**< \brief [10:8] Operation Mode - RECC (rw) */
    Ifx_UReg_32Bit reserved_11:5;     /**< \brief [15:11] \internal Reserved */
    Ifx_UReg_32Bit CFLASH:6;          /**< \brief [21:16] Cranking Mode - CFLASH (rw) */
    Ifx_UReg_32Bit reserved_22:2;     /**< \brief [23:22] \internal Reserved */
    Ifx_UReg_32Bit CECC:3;            /**< \brief [26:24] Cranking Mode - CECC (rw) */
    Ifx_UReg_32Bit reserved_27:5;     /**< \brief [31:27] \internal Reserved */
} Ifx_DMU_HF_PWAIT_Bits;

/** \brief Flash Status Register */
typedef struct _Ifx_DMU_HF_STATUS_Bits
{
    Ifx_UReg_32Bit D0BUSY:1;          /**< \brief [0:0] Data Flash Bank 0 Busy - D0BUSY (rh) */
    Ifx_UReg_32Bit D1BUSY:1;          /**< \brief [1:1] Data Flash Bank 1 Busy - D1BUSY (rh) */
    Ifx_UReg_32Bit P0BUSY:1;          /**< \brief [2:2] Program Flash PF0BUSY - P0BUSY (rh) */
    Ifx_UReg_32Bit P1BUSY:1;          /**< \brief [3:3] Program Flash PF1BUSY - P1BUSY (rh) */
    Ifx_UReg_32Bit P2BUSY:1;          /**< \brief [4:4] Program Flash PF2BUSY - P2BUSY (rh) */
    Ifx_UReg_32Bit P3BUSY:1;          /**< \brief [5:5] Program Flash PF3BUSY - P3BUSY (rh) */
    Ifx_UReg_32Bit reserved_6:1;      /**< \brief [6:6] \internal Reserved */
    Ifx_UReg_32Bit reserved_7:1;      /**< \brief [7:7] \internal Reserved */
    Ifx_UReg_32Bit reserved_8:8;      /**< \brief [15:8] \internal Reserved */
    Ifx_UReg_32Bit reserved_16:1;     /**< \brief [16:16] \internal Reserved */
    Ifx_UReg_32Bit reserved_17:1;     /**< \brief [17:17] \internal Reserved */
    Ifx_UReg_32Bit reserved_18:1;     /**< \brief [18:18] \internal Reserved */
    Ifx_UReg_32Bit reserved_19:1;     /**< \brief [19:19] \internal Reserved */
    Ifx_UReg_32Bit DFPAGE:1;          /**< \brief [20:20] Data Flash in Page Mode - DFPAGE (rh) */
    Ifx_UReg_32Bit PFPAGE:1;          /**< \brief [21:21] Program Flash in Page Mode - PFPAGE (rh) */
    Ifx_UReg_32Bit reserved_22:1;     /**< \brief [22:22] \internal Reserved */
    Ifx_UReg_32Bit reserved_23:1;     /**< \brief [23:23] \internal Reserved */
    Ifx_UReg_32Bit reserved_24:2;     /**< \brief [25:24] \internal Reserved */
    Ifx_UReg_32Bit reserved_26:6;     /**< \brief [31:26] \internal Reserved */
} Ifx_DMU_HF_STATUS_Bits;

/** \brief Suspend Control Register */
typedef struct _Ifx_DMU_HF_SUSPEND_Bits
{
    Ifx_UReg_32Bit REQ:1;             /**< \brief [0:0] Suspend Request - REQ (rwh) */
    Ifx_UReg_32Bit CLR:1;             /**< \brief [1:1] Suspend Clear - CLR (w) */
    Ifx_UReg_32Bit reserved_2:14;     /**< \brief [15:2] \internal Reserved */
    Ifx_UReg_32Bit SPND:1;            /**< \brief [16:16] Flash Operation Suspended - SPND (rh) */
    Ifx_UReg_32Bit ERR:1;             /**< \brief [17:17] Suspend Error - ERR (rh) */
    Ifx_UReg_32Bit reserved_18:14;    /**< \brief [31:18] \internal Reserved */
} Ifx_DMU_HF_SUSPEND_Bits;

/** \brief PFLASH Bank ${i} Erase Counter Priority configuration 0 */
typedef struct _Ifx_DMU_HP_ECPRIO_P0_Bits
{
    Ifx_UReg_32Bit S0L:1;             /**< \brief [0:0] PFLASH p Sector 0 Erase Counter priority - S0L (rh) */
    Ifx_UReg_32Bit S1L:1;             /**< \brief [1:1] PFLASH p Sector 1 Erase Counter priority - S1L (rh) */
    Ifx_UReg_32Bit S2L:1;             /**< \brief [2:2] PFLASH p Sector 2 Erase Counter priority - S2L (rh) */
    Ifx_UReg_32Bit S3L:1;             /**< \brief [3:3] PFLASH p Sector 3 Erase Counter priority - S3L (rh) */
    Ifx_UReg_32Bit S4L:1;             /**< \brief [4:4] PFLASH p Sector 4 Erase Counter priority - S4L (rh) */
    Ifx_UReg_32Bit S5L:1;             /**< \brief [5:5] PFLASH p Sector 5 Erase Counter priority - S5L (rh) */
    Ifx_UReg_32Bit S6L:1;             /**< \brief [6:6] PFLASH p Sector 6 Erase Counter priority - S6L (rh) */
    Ifx_UReg_32Bit S7L:1;             /**< \brief [7:7] PFLASH p Sector 7 Erase Counter priority - S7L (rh) */
    Ifx_UReg_32Bit S8L:1;             /**< \brief [8:8] PFLASH p Sector 8 Erase Counter priority - S8L (rh) */
    Ifx_UReg_32Bit S9L:1;             /**< \brief [9:9] PFLASH p Sector 9 Erase Counter priority - S9L (rh) */
    Ifx_UReg_32Bit S10L:1;            /**< \brief [10:10] PFLASH p Sector 10 Erase Counter priority - S10L (rh) */
    Ifx_UReg_32Bit S11L:1;            /**< \brief [11:11] PFLASH p Sector 11 Erase Counter priority - S11L (rh) */
    Ifx_UReg_32Bit S12L:1;            /**< \brief [12:12] PFLASH p Sector 12 Erase Counter priority - S12L (rh) */
    Ifx_UReg_32Bit S13L:1;            /**< \brief [13:13] PFLASH p Sector 13 Erase Counter priority - S13L (rh) */
    Ifx_UReg_32Bit S14L:1;            /**< \brief [14:14] PFLASH p Sector 14 Erase Counter priority - S14L (rh) */
    Ifx_UReg_32Bit S15L:1;            /**< \brief [15:15] PFLASH p Sector 15 Erase Counter priority - S15L (rh) */
    Ifx_UReg_32Bit S16L:1;            /**< \brief [16:16] PFLASH p Sector 16 Erase Counter priority - S16L (rh) */
    Ifx_UReg_32Bit S17L:1;            /**< \brief [17:17] PFLASH p Sector 17 Erase Counter priority - S17L (rh) */
    Ifx_UReg_32Bit S18L:1;            /**< \brief [18:18] PFLASH p Sector 18 Erase Counter priority - S18L (rh) */
    Ifx_UReg_32Bit S19L:1;            /**< \brief [19:19] PFLASH p Sector 19 Erase Counter priority - S19L (rh) */
    Ifx_UReg_32Bit S20L:1;            /**< \brief [20:20] PFLASH p Sector 20 Erase Counter priority - S20L (rh) */
    Ifx_UReg_32Bit S21L:1;            /**< \brief [21:21] PFLASH p Sector 21 Erase Counter priority - S21L (rh) */
    Ifx_UReg_32Bit S22L:1;            /**< \brief [22:22] PFLASH p Sector 22 Erase Counter priority - S22L (rh) */
    Ifx_UReg_32Bit S23L:1;            /**< \brief [23:23] PFLASH p Sector 23 Erase Counter priority - S23L (rh) */
    Ifx_UReg_32Bit S24L:1;            /**< \brief [24:24] PFLASH p Sector 24 Erase Counter priority - S24L (rh) */
    Ifx_UReg_32Bit S25L:1;            /**< \brief [25:25] PFLASH p Sector 25 Erase Counter priority - S25L (rh) */
    Ifx_UReg_32Bit S26L:1;            /**< \brief [26:26] PFLASH p Sector 26 Erase Counter priority - S26L (rh) */
    Ifx_UReg_32Bit S27L:1;            /**< \brief [27:27] PFLASH p Sector 27 Erase Counter priority - S27L (rh) */
    Ifx_UReg_32Bit S28L:1;            /**< \brief [28:28] PFLASH p Sector 28 Erase Counter priority - S28L (rh) */
    Ifx_UReg_32Bit S29L:1;            /**< \brief [29:29] PFLASH p Sector 29 Erase Counter priority - S29L (rh) */
    Ifx_UReg_32Bit S30L:1;            /**< \brief [30:30] PFLASH p Sector 30 Erase Counter priority - S30L (rh) */
    Ifx_UReg_32Bit S31L:1;            /**< \brief [31:31] PFLASH p Sector 31 Erase Counter priority - S31L (rh) */
} Ifx_DMU_HP_ECPRIO_P0_Bits;

/** \brief PFLASH Bank ${i} Erase Counter Priority Configuration 1 */
typedef struct _Ifx_DMU_HP_ECPRIO_P1_Bits
{
    Ifx_UReg_32Bit S32L:1;            /**< \brief [0:0] PFLASH p Sector 32 Erase Counter priority - S32L (rh) */
    Ifx_UReg_32Bit S33L:1;            /**< \brief [1:1] PFLASH p Sector 33 Erase Counter priority - S33L (rh) */
    Ifx_UReg_32Bit S34L:1;            /**< \brief [2:2] PFLASH p Sector 34 Erase Counter priority - S34L (rh) */
    Ifx_UReg_32Bit S35L:1;            /**< \brief [3:3] PFLASH p Sector 35 Erase Counter priority - S35L (rh) */
    Ifx_UReg_32Bit S36L:1;            /**< \brief [4:4] PFLASH p Sector 36 Erase Counter priority - S36L (rh) */
    Ifx_UReg_32Bit S37L:1;            /**< \brief [5:5] PFLASH p Sector 37 Erase Counter priority - S37L (rh) */
    Ifx_UReg_32Bit S38L:1;            /**< \brief [6:6] PFLASH p Sector 38 Erase Counter priority - S38L (rh) */
    Ifx_UReg_32Bit S39L:1;            /**< \brief [7:7] PFLASH p Sector 39 Erase Counter priority - S39L (rh) */
    Ifx_UReg_32Bit S40L:1;            /**< \brief [8:8] PFLASH p Sector 40 Erase Counter priority - S40L (rh) */
    Ifx_UReg_32Bit S41L:1;            /**< \brief [9:9] PFLASH p Sector 41 Erase Counter priority - S41L (rh) */
    Ifx_UReg_32Bit S42L:1;            /**< \brief [10:10] PFLASH p Sector 42 Erase Counter priority - S42L (rh) */
    Ifx_UReg_32Bit S43L:1;            /**< \brief [11:11] PFLASH p Sector 43 Erase Counter priority - S43L (rh) */
    Ifx_UReg_32Bit S44L:1;            /**< \brief [12:12] PFLASH p Sector 44 Erase Counter priority - S44L (rh) */
    Ifx_UReg_32Bit S45L:1;            /**< \brief [13:13] PFLASH p Sector 45 Erase Counter priority - S45L (rh) */
    Ifx_UReg_32Bit S46L:1;            /**< \brief [14:14] PFLASH p Sector 46 Erase Counter priority - S46L (rh) */
    Ifx_UReg_32Bit S47L:1;            /**< \brief [15:15] PFLASH p Sector 47 Erase Counter priority - S47L (rh) */
    Ifx_UReg_32Bit S48L:1;            /**< \brief [16:16] PFLASH p Sector 48 Erase Counter priority - S48L (rh) */
    Ifx_UReg_32Bit S49L:1;            /**< \brief [17:17] PFLASH p Sector 49 Erase Counter priority - S49L (rh) */
    Ifx_UReg_32Bit S50L:1;            /**< \brief [18:18] PFLASH p Sector 50 Erase Counter priority - S50L (rh) */
    Ifx_UReg_32Bit S51L:1;            /**< \brief [19:19] PFLASH p Sector 51 Erase Counter priority - S51L (rh) */
    Ifx_UReg_32Bit S52L:1;            /**< \brief [20:20] PFLASH p Sector 52 Erase Counter priority - S52L (rh) */
    Ifx_UReg_32Bit S53L:1;            /**< \brief [21:21] PFLASH p Sector 53 Erase Counter priority - S53L (rh) */
    Ifx_UReg_32Bit S54L:1;            /**< \brief [22:22] PFLASH p Sector 54 Erase Counter priority - S54L (rh) */
    Ifx_UReg_32Bit S55L:1;            /**< \brief [23:23] PFLASH p Sector 55 Erase Counter priority - S55L (rh) */
    Ifx_UReg_32Bit S56L:1;            /**< \brief [24:24] PFLASH p Sector 56 Erase Counter priority - S56L (rh) */
    Ifx_UReg_32Bit S57L:1;            /**< \brief [25:25] PFLASH p Sector 57 Erase Counter priority - S57L (rh) */
    Ifx_UReg_32Bit S58L:1;            /**< \brief [26:26] PFLASH p Sector 58 Erase Counter priority - S58L (rh) */
    Ifx_UReg_32Bit S59L:1;            /**< \brief [27:27] PFLASH p Sector 59 Erase Counter priority - S59L (rh) */
    Ifx_UReg_32Bit S60L:1;            /**< \brief [28:28] PFLASH p Sector 60 Erase Counter priority - S60L (rh) */
    Ifx_UReg_32Bit S61L:1;            /**< \brief [29:29] PFLASH p Sector 61 Erase Counter priority - S61L (rh) */
    Ifx_UReg_32Bit S62L:1;            /**< \brief [30:30] PFLASH p Sector 62 Erase Counter priority - S62L (rh) */
    Ifx_UReg_32Bit S63L:1;            /**< \brief [31:31] PFLASH p Sector 63 Erase Counter priority - S63L (rh) */
} Ifx_DMU_HP_ECPRIO_P1_Bits;

/** \brief PFLASH Bank ${i} Erase Counter Priority Configuration 2 */
typedef struct _Ifx_DMU_HP_ECPRIO_P2_Bits
{
    Ifx_UReg_32Bit S64L:1;            /**< \brief [0:0] PFLASH p Sector 64 Erase Counter priority - S64L (rh) */
    Ifx_UReg_32Bit S65L:1;            /**< \brief [1:1] PFLASH p Sector 65 Erase Counter priority - S65L (rh) */
    Ifx_UReg_32Bit S66L:1;            /**< \brief [2:2] PFLASH p Sector 66 Erase Counter priority - S66L (rh) */
    Ifx_UReg_32Bit S67L:1;            /**< \brief [3:3] PFLASH p Sector 67 Erase Counter priority - S67L (rh) */
    Ifx_UReg_32Bit S68L:1;            /**< \brief [4:4] PFLASH p Sector 68 Erase Counter priority - S68L (rh) */
    Ifx_UReg_32Bit S69L:1;            /**< \brief [5:5] PFLASH p Sector 69 Erase Counter priority - S69L (rh) */
    Ifx_UReg_32Bit S70L:1;            /**< \brief [6:6] PFLASH p Sector 70 Erase Counter priority - S70L (rh) */
    Ifx_UReg_32Bit S71L:1;            /**< \brief [7:7] PFLASH p Sector 71 Erase Counter priority - S71L (rh) */
    Ifx_UReg_32Bit S72L:1;            /**< \brief [8:8] PFLASH p Sector 72 Erase Counter priority - S72L (rh) */
    Ifx_UReg_32Bit S73L:1;            /**< \brief [9:9] PFLASH p Sector 73 Erase Counter priority - S73L (rh) */
    Ifx_UReg_32Bit S74L:1;            /**< \brief [10:10] PFLASH p Sector 74 Erase Counter priority - S74L (rh) */
    Ifx_UReg_32Bit S75L:1;            /**< \brief [11:11] PFLASH p Sector 75 Erase Counter priority - S75L (rh) */
    Ifx_UReg_32Bit S76L:1;            /**< \brief [12:12] PFLASH p Sector 76 Erase Counter priority - S76L (rh) */
    Ifx_UReg_32Bit S77L:1;            /**< \brief [13:13] PFLASH p Sector 77 Erase Counter priority - S77L (rh) */
    Ifx_UReg_32Bit S78L:1;            /**< \brief [14:14] PFLASH p Sector 78 Erase Counter priority - S78L (rh) */
    Ifx_UReg_32Bit S79L:1;            /**< \brief [15:15] PFLASH p Sector 79 Erase Counter priority - S79L (rh) */
    Ifx_UReg_32Bit S80L:1;            /**< \brief [16:16] PFLASH p Sector 80 Erase Counter priority - S80L (rh) */
    Ifx_UReg_32Bit S81L:1;            /**< \brief [17:17] PFLASH p Sector 81 Erase Counter priority - S81L (rh) */
    Ifx_UReg_32Bit S82L:1;            /**< \brief [18:18] PFLASH p Sector 82 Erase Counter priority - S82L (rh) */
    Ifx_UReg_32Bit S83L:1;            /**< \brief [19:19] PFLASH p Sector 83 Erase Counter priority - S83L (rh) */
    Ifx_UReg_32Bit S84L:1;            /**< \brief [20:20] PFLASH p Sector 84 Erase Counter priority - S84L (rh) */
    Ifx_UReg_32Bit S85L:1;            /**< \brief [21:21] PFLASH p Sector 85 Erase Counter priority - S85L (rh) */
    Ifx_UReg_32Bit S86L:1;            /**< \brief [22:22] PFLASH p Sector 86 Erase Counter priority - S86L (rh) */
    Ifx_UReg_32Bit S87L:1;            /**< \brief [23:23] PFLASH p Sector 87 Erase Counter priority - S87L (rh) */
    Ifx_UReg_32Bit S88L:1;            /**< \brief [24:24] PFLASH p Sector 88 Erase Counter priority - S88L (rh) */
    Ifx_UReg_32Bit S89L:1;            /**< \brief [25:25] PFLASH p Sector 89 Erase Counter priority - S89L (rh) */
    Ifx_UReg_32Bit S90L:1;            /**< \brief [26:26] PFLASH p Sector 90 Erase Counter priority - S90L (rh) */
    Ifx_UReg_32Bit S91L:1;            /**< \brief [27:27] PFLASH p Sector 91 Erase Counter priority - S91L (rh) */
    Ifx_UReg_32Bit S92L:1;            /**< \brief [28:28] PFLASH p Sector 92 Erase Counter priority - S92L (rh) */
    Ifx_UReg_32Bit S93L:1;            /**< \brief [29:29] PFLASH p Sector 93 Erase Counter priority - S93L (rh) */
    Ifx_UReg_32Bit S94L:1;            /**< \brief [30:30] PFLASH p Sector 94 Erase Counter priority - S94L (rh) */
    Ifx_UReg_32Bit S95L:1;            /**< \brief [31:31] PFLASH p Sector 95 Erase Counter priority - S95L (rh) */
} Ifx_DMU_HP_ECPRIO_P2_Bits;

/** \brief PFLASH Bank ${i} Erase Counter Priority Configuration 3 */
typedef struct _Ifx_DMU_HP_ECPRIO_P3_Bits
{
    Ifx_UReg_32Bit S96L:1;            /**< \brief [0:0] PFLASH p Sector 96 Erase Counter priority - S96L (rh) */
    Ifx_UReg_32Bit S97L:1;            /**< \brief [1:1] PFLASH p Sector 97 Erase Counter priority - S97L (rh) */
    Ifx_UReg_32Bit S98L:1;            /**< \brief [2:2] PFLASH p Sector 98 Erase Counter priority - S98L (rh) */
    Ifx_UReg_32Bit S99L:1;            /**< \brief [3:3] PFLASH p Sector 99 Erase Counter priority - S99L (rh) */
    Ifx_UReg_32Bit S100L:1;           /**< \brief [4:4] PFLASH p Sector 100 Erase Counter priority - S100L (rh) */
    Ifx_UReg_32Bit S101L:1;           /**< \brief [5:5] PFLASH p Sector 101 Erase Counter priority - S101L (rh) */
    Ifx_UReg_32Bit S102L:1;           /**< \brief [6:6] PFLASH p Sector 102 Erase Counter priority - S102L (rh) */
    Ifx_UReg_32Bit S103L:1;           /**< \brief [7:7] PFLASH p Sector 103 Erase Counter priority - S103L (rh) */
    Ifx_UReg_32Bit S104L:1;           /**< \brief [8:8] PFLASH p Sector 104 Erase Counter priority - S104L (rh) */
    Ifx_UReg_32Bit S105L:1;           /**< \brief [9:9] PFLASH p Sector 105 Erase Counter priority - S105L (rh) */
    Ifx_UReg_32Bit S106L:1;           /**< \brief [10:10] PFLASH p Sector 106 Erase Counter priority - S106L (rh) */
    Ifx_UReg_32Bit S107L:1;           /**< \brief [11:11] PFLASH p Sector 107 Erase Counter priority - S107L (rh) */
    Ifx_UReg_32Bit S108L:1;           /**< \brief [12:12] PFLASH p Sector 108 Erase Counter priority - S108L (rh) */
    Ifx_UReg_32Bit S109L:1;           /**< \brief [13:13] PFLASH p Sector 109 Erase Counter priority - S109L (rh) */
    Ifx_UReg_32Bit S110L:1;           /**< \brief [14:14] PFLASH p Sector 110 Erase Counter priority - S110L (rh) */
    Ifx_UReg_32Bit S111L:1;           /**< \brief [15:15] PFLASH p Sector 111 Erase Counter priority - S111L (rh) */
    Ifx_UReg_32Bit S112L:1;           /**< \brief [16:16] PFLASH p Sector 112 Erase Counter priority - S112L (rh) */
    Ifx_UReg_32Bit S113L:1;           /**< \brief [17:17] PFLASH p Sector 113 Erase Counter priority - S113L (rh) */
    Ifx_UReg_32Bit S114L:1;           /**< \brief [18:18] PFLASH p Sector 114 Erase Counter priority - S114L (rh) */
    Ifx_UReg_32Bit S115L:1;           /**< \brief [19:19] PFLASH p Sector 115 Erase Counter priority - S115L (rh) */
    Ifx_UReg_32Bit S116L:1;           /**< \brief [20:20] PFLASH p Sector 116 Erase Counter priority - S116L (rh) */
    Ifx_UReg_32Bit S117L:1;           /**< \brief [21:21] PFLASH p Sector 117 Erase Counter priority - S117L (rh) */
    Ifx_UReg_32Bit S118L:1;           /**< \brief [22:22] PFLASH p Sector 118 Erase Counter priority - S118L (rh) */
    Ifx_UReg_32Bit S119L:1;           /**< \brief [23:23] PFLASH p Sector 119 Erase Counter priority - S119L (rh) */
    Ifx_UReg_32Bit S120L:1;           /**< \brief [24:24] PFLASH p Sector 120 Erase Counter priority - S120L (rh) */
    Ifx_UReg_32Bit S121L:1;           /**< \brief [25:25] PFLASH p Sector 121 Erase Counter priority - S121L (rh) */
    Ifx_UReg_32Bit S122L:1;           /**< \brief [26:26] PFLASH p Sector 122 Erase Counter priority - S122L (rh) */
    Ifx_UReg_32Bit S123L:1;           /**< \brief [27:27] PFLASH p Sector 123 Erase Counter priority - S123L (rh) */
    Ifx_UReg_32Bit S124L:1;           /**< \brief [28:28] PFLASH p Sector 124 Erase Counter priority - S124L (rh) */
    Ifx_UReg_32Bit S125L:1;           /**< \brief [29:29] PFLASH p Sector 125 Erase Counter priority - S125L (rh) */
    Ifx_UReg_32Bit S126L:1;           /**< \brief [30:30] PFLASH p Sector 126 Erase Counter priority - S126L (rh) */
    Ifx_UReg_32Bit S127L:1;           /**< \brief [31:31] PFLASH p Sector 127 Erase Counter priority - S127L (rh) */
} Ifx_DMU_HP_ECPRIO_P3_Bits;

/** \brief PFLASH Bank ${i} Erase Counter Priority Configuration 4 */
typedef struct _Ifx_DMU_HP_ECPRIO_P4_Bits
{
    Ifx_UReg_32Bit S128L:1;           /**< \brief [0:0] PFLASH p Sector 128 Erase Counter priority - S128L (rh) */
    Ifx_UReg_32Bit S129L:1;           /**< \brief [1:1] PFLASH p Sector 129 Erase Counter priority - S129L (rh) */
    Ifx_UReg_32Bit S130L:1;           /**< \brief [2:2] PFLASH p Sector 130 Erase Counter priority - S130L (rh) */
    Ifx_UReg_32Bit S131L:1;           /**< \brief [3:3] PFLASH p Sector 131 Erase Counter priority - S131L (rh) */
    Ifx_UReg_32Bit S132L:1;           /**< \brief [4:4] PFLASH p Sector 132 Erase Counter priority - S132L (rh) */
    Ifx_UReg_32Bit S133L:1;           /**< \brief [5:5] PFLASH p Sector 133 Erase Counter priority - S133L (rh) */
    Ifx_UReg_32Bit S134L:1;           /**< \brief [6:6] PFLASH p Sector 134 Erase Counter priority - S134L (rh) */
    Ifx_UReg_32Bit S135L:1;           /**< \brief [7:7] PFLASH p Sector 135 Erase Counter priority - S135L (rh) */
    Ifx_UReg_32Bit S136L:1;           /**< \brief [8:8] PFLASH p Sector 136 Erase Counter priority - S136L (rh) */
    Ifx_UReg_32Bit S137L:1;           /**< \brief [9:9] PFLASH p Sector 137 Erase Counter priority - S137L (rh) */
    Ifx_UReg_32Bit S138L:1;           /**< \brief [10:10] PFLASH p Sector 138 Erase Counter priority - S138L (rh) */
    Ifx_UReg_32Bit S139L:1;           /**< \brief [11:11] PFLASH p Sector 139 Erase Counter priority - S139L (rh) */
    Ifx_UReg_32Bit S140L:1;           /**< \brief [12:12] PFLASH p Sector 140 Erase Counter priority - S140L (rh) */
    Ifx_UReg_32Bit S141L:1;           /**< \brief [13:13] PFLASH p Sector 141 Erase Counter priority - S141L (rh) */
    Ifx_UReg_32Bit S142L:1;           /**< \brief [14:14] PFLASH p Sector 142 Erase Counter priority - S142L (rh) */
    Ifx_UReg_32Bit S143L:1;           /**< \brief [15:15] PFLASH p Sector 143 Erase Counter priority - S143L (rh) */
    Ifx_UReg_32Bit S144L:1;           /**< \brief [16:16] PFLASH p Sector 144 Erase Counter priority - S144L (rh) */
    Ifx_UReg_32Bit S145L:1;           /**< \brief [17:17] PFLASH p Sector 145 Erase Counter priority - S145L (rh) */
    Ifx_UReg_32Bit S146L:1;           /**< \brief [18:18] PFLASH p Sector 146 Erase Counter priority - S146L (rh) */
    Ifx_UReg_32Bit S147L:1;           /**< \brief [19:19] PFLASH p Sector 147 Erase Counter priority - S147L (rh) */
    Ifx_UReg_32Bit S148L:1;           /**< \brief [20:20] PFLASH p Sector 148 Erase Counter priority - S148L (rh) */
    Ifx_UReg_32Bit S149L:1;           /**< \brief [21:21] PFLASH p Sector 149 Erase Counter priority - S149L (rh) */
    Ifx_UReg_32Bit S150L:1;           /**< \brief [22:22] PFLASH p Sector 150 Erase Counter priority - S150L (rh) */
    Ifx_UReg_32Bit S151L:1;           /**< \brief [23:23] PFLASH p Sector 151 Erase Counter priority - S151L (rh) */
    Ifx_UReg_32Bit S152L:1;           /**< \brief [24:24] PFLASH p Sector 152 Erase Counter priority - S152L (rh) */
    Ifx_UReg_32Bit S153L:1;           /**< \brief [25:25] PFLASH p Sector 153 Erase Counter priority - S153L (rh) */
    Ifx_UReg_32Bit S154L:1;           /**< \brief [26:26] PFLASH p Sector 154 Erase Counter priority - S154L (rh) */
    Ifx_UReg_32Bit S155L:1;           /**< \brief [27:27] PFLASH p Sector 155 Erase Counter priority - S155L (rh) */
    Ifx_UReg_32Bit S156L:1;           /**< \brief [28:28] PFLASH p Sector 156 Erase Counter priority - S156L (rh) */
    Ifx_UReg_32Bit S157L:1;           /**< \brief [29:29] PFLASH p Sector 157 Erase Counter priority - S157L (rh) */
    Ifx_UReg_32Bit S158L:1;           /**< \brief [30:30] PFLASH p Sector 158 Erase Counter priority - S158L (rh) */
    Ifx_UReg_32Bit S159L:1;           /**< \brief [31:31] PFLASH p Sector 159 Erase Counter priority - S159L (rh) */
} Ifx_DMU_HP_ECPRIO_P4_Bits;

/** \brief PFLASH Bank ${i} Erase Counter Priority Configuration 5 */
typedef struct _Ifx_DMU_HP_ECPRIO_P5_Bits
{
    Ifx_UReg_32Bit S160L:1;           /**< \brief [0:0] PFLASH p Sector 160 Erase Counter priority - S160L (rh) */
    Ifx_UReg_32Bit S161L:1;           /**< \brief [1:1] PFLASH p Sector 161 Erase Counter priority - S161L (rh) */
    Ifx_UReg_32Bit S162L:1;           /**< \brief [2:2] PFLASH p Sector 162 Erase Counter priority - S162L (rh) */
    Ifx_UReg_32Bit S163L:1;           /**< \brief [3:3] PFLASH p Sector 163 Erase Counter priority - S163L (rh) */
    Ifx_UReg_32Bit S164L:1;           /**< \brief [4:4] PFLASH p Sector 164 Erase Counter priority - S164L (rh) */
    Ifx_UReg_32Bit S165L:1;           /**< \brief [5:5] PFLASH p Sector 165 Erase Counter priority - S165L (rh) */
    Ifx_UReg_32Bit S166L:1;           /**< \brief [6:6] PFLASH p Sector 166 Erase Counter priority - S166L (rh) */
    Ifx_UReg_32Bit S167L:1;           /**< \brief [7:7] PFLASH p Sector 167 Erase Counter priority - S167L (rh) */
    Ifx_UReg_32Bit S168L:1;           /**< \brief [8:8] PFLASH p Sector 168 Erase Counter priority - S168L (rh) */
    Ifx_UReg_32Bit S169L:1;           /**< \brief [9:9] PFLASH p Sector 169 Erase Counter priority - S169L (rh) */
    Ifx_UReg_32Bit S170L:1;           /**< \brief [10:10] PFLASH p Sector 170 Erase Counter priority - S170L (rh) */
    Ifx_UReg_32Bit S171L:1;           /**< \brief [11:11] PFLASH p Sector 171 Erase Counter priority - S171L (rh) */
    Ifx_UReg_32Bit S172L:1;           /**< \brief [12:12] PFLASH p Sector 172 Erase Counter priority - S172L (rh) */
    Ifx_UReg_32Bit S173L:1;           /**< \brief [13:13] PFLASH p Sector 173 Erase Counter priority - S173L (rh) */
    Ifx_UReg_32Bit S174L:1;           /**< \brief [14:14] PFLASH p Sector 174 Erase Counter priority - S174L (rh) */
    Ifx_UReg_32Bit S175L:1;           /**< \brief [15:15] PFLASH p Sector 175 Erase Counter priority - S175L (rh) */
    Ifx_UReg_32Bit S176L:1;           /**< \brief [16:16] PFLASH p Sector 176 Erase Counter priority - S176L (rh) */
    Ifx_UReg_32Bit S177L:1;           /**< \brief [17:17] PFLASH p Sector 177 Erase Counter priority - S177L (rh) */
    Ifx_UReg_32Bit S178L:1;           /**< \brief [18:18] PFLASH p Sector 178 Erase Counter priority - S178L (rh) */
    Ifx_UReg_32Bit S179L:1;           /**< \brief [19:19] PFLASH p Sector 179 Erase Counter priority - S179L (rh) */
    Ifx_UReg_32Bit S180L:1;           /**< \brief [20:20] PFLASH p Sector 180 Erase Counter priority - S180L (rh) */
    Ifx_UReg_32Bit S181L:1;           /**< \brief [21:21] PFLASH p Sector 181 Erase Counter priority - S181L (rh) */
    Ifx_UReg_32Bit S182L:1;           /**< \brief [22:22] PFLASH p Sector 182 Erase Counter priority - S182L (rh) */
    Ifx_UReg_32Bit S183L:1;           /**< \brief [23:23] PFLASH p Sector 183 Erase Counter priority - S183L (rh) */
    Ifx_UReg_32Bit S184L:1;           /**< \brief [24:24] PFLASH p Sector 184 Erase Counter priority - S184L (rh) */
    Ifx_UReg_32Bit S185L:1;           /**< \brief [25:25] PFLASH p Sector 185 Erase Counter priority - S185L (rh) */
    Ifx_UReg_32Bit S186L:1;           /**< \brief [26:26] PFLASH p Sector 186 Erase Counter priority - S186L (rh) */
    Ifx_UReg_32Bit S187L:1;           /**< \brief [27:27] PFLASH p Sector 187 Erase Counter priority - S187L (rh) */
    Ifx_UReg_32Bit S188L:1;           /**< \brief [28:28] PFLASH p Sector 188 Erase Counter priority - S188L (rh) */
    Ifx_UReg_32Bit S189L:1;           /**< \brief [29:29] PFLASH p Sector 189 Erase Counter priority - S189L (rh) */
    Ifx_UReg_32Bit S190L:1;           /**< \brief [30:30] PFLASH p Sector 190 Erase Counter priority - S190L (rh) */
    Ifx_UReg_32Bit S191L:1;           /**< \brief [31:31] PFLASH p Sector 191 Erase Counter priority - S191L (rh) */
} Ifx_DMU_HP_ECPRIO_P5_Bits;

/** \brief PFLASH Bank ${i} OTP Protection Configuration 0 */
typedef struct _Ifx_DMU_HP_PROCON_OTP0_Bits
{
    Ifx_UReg_32Bit S0ROM:1;           /**< \brief [0:0] PFLASH p Sector 0 Locked for Forever - S0ROM (rh) */
    Ifx_UReg_32Bit S1ROM:1;           /**< \brief [1:1] PFLASH p Sector 1 Locked for Forever - S1ROM (rh) */
    Ifx_UReg_32Bit S2ROM:1;           /**< \brief [2:2] PFLASH p Sector 2 Locked for Forever - S2ROM (rh) */
    Ifx_UReg_32Bit S3ROM:1;           /**< \brief [3:3] PFLASH p Sector 3 Locked for Forever - S3ROM (rh) */
    Ifx_UReg_32Bit S4ROM:1;           /**< \brief [4:4] PFLASH p Sector 4 Locked for Forever - S4ROM (rh) */
    Ifx_UReg_32Bit S5ROM:1;           /**< \brief [5:5] PFLASH p Sector 5 Locked for Forever - S5ROM (rh) */
    Ifx_UReg_32Bit S6ROM:1;           /**< \brief [6:6] PFLASH p Sector 6 Locked for Forever - S6ROM (rh) */
    Ifx_UReg_32Bit S7ROM:1;           /**< \brief [7:7] PFLASH p Sector 7 Locked for Forever - S7ROM (rh) */
    Ifx_UReg_32Bit S8ROM:1;           /**< \brief [8:8] PFLASH p Sector 8 Locked for Forever - S8ROM (rh) */
    Ifx_UReg_32Bit S9ROM:1;           /**< \brief [9:9] PFLASH p Sector 9 Locked for Forever - S9ROM (rh) */
    Ifx_UReg_32Bit S10ROM:1;          /**< \brief [10:10] PFLASH p Sector 10 Locked for Forever - S10ROM (rh) */
    Ifx_UReg_32Bit S11ROM:1;          /**< \brief [11:11] PFLASH p Sector 11 Locked for Forever - S11ROM (rh) */
    Ifx_UReg_32Bit S12ROM:1;          /**< \brief [12:12] PFLASH p Sector 12 Locked for Forever - S12ROM (rh) */
    Ifx_UReg_32Bit S13ROM:1;          /**< \brief [13:13] PFLASH p Sector 13 Locked for Forever - S13ROM (rh) */
    Ifx_UReg_32Bit S14ROM:1;          /**< \brief [14:14] PFLASH p Sector 14 Locked for Forever - S14ROM (rh) */
    Ifx_UReg_32Bit S15ROM:1;          /**< \brief [15:15] PFLASH p Sector 15 Locked for Forever - S15ROM (rh) */
    Ifx_UReg_32Bit S16ROM:1;          /**< \brief [16:16] PFLASH p Sector 16 Locked for Forever - S16ROM (rh) */
    Ifx_UReg_32Bit S17ROM:1;          /**< \brief [17:17] PFLASH p Sector 17 Locked for Forever - S17ROM (rh) */
    Ifx_UReg_32Bit S18ROM:1;          /**< \brief [18:18] PFLASH p Sector 18 Locked for Forever - S18ROM (rh) */
    Ifx_UReg_32Bit S19ROM:1;          /**< \brief [19:19] PFLASH p Sector 19 Locked for Forever - S19ROM (rh) */
    Ifx_UReg_32Bit S20ROM:1;          /**< \brief [20:20] PFLASH p Sector 20 Locked for Forever - S20ROM (rh) */
    Ifx_UReg_32Bit S21ROM:1;          /**< \brief [21:21] PFLASH p Sector 21 Locked for Forever - S21ROM (rh) */
    Ifx_UReg_32Bit S22ROM:1;          /**< \brief [22:22] PFLASH p Sector 22 Locked for Forever - S22ROM (rh) */
    Ifx_UReg_32Bit S23ROM:1;          /**< \brief [23:23] PFLASH p Sector 23 Locked for Forever - S23ROM (rh) */
    Ifx_UReg_32Bit S24ROM:1;          /**< \brief [24:24] PFLASH p Sector 24 Locked for Forever - S24ROM (rh) */
    Ifx_UReg_32Bit S25ROM:1;          /**< \brief [25:25] PFLASH p Sector 25 Locked for Forever - S25ROM (rh) */
    Ifx_UReg_32Bit S26ROM:1;          /**< \brief [26:26] PFLASH p Sector 26 Locked for Forever - S26ROM (rh) */
    Ifx_UReg_32Bit S27ROM:1;          /**< \brief [27:27] PFLASH p Sector 27 Locked for Forever - S27ROM (rh) */
    Ifx_UReg_32Bit S28ROM:1;          /**< \brief [28:28] PFLASH p Sector 28 Locked for Forever - S28ROM (rh) */
    Ifx_UReg_32Bit S29ROM:1;          /**< \brief [29:29] PFLASH p Sector 29 Locked for Forever - S29ROM (rh) */
    Ifx_UReg_32Bit S30ROM:1;          /**< \brief [30:30] PFLASH p Sector 30 Locked for Forever - S30ROM (rh) */
    Ifx_UReg_32Bit S31ROM:1;          /**< \brief [31:31] PFLASH p Sector 31 Locked for Forever - S31ROM (rh) */
} Ifx_DMU_HP_PROCON_OTP0_Bits;

/** \brief PFLASH Bank ${i} OTP Protection Configuration 1 */
typedef struct _Ifx_DMU_HP_PROCON_OTP1_Bits
{
    Ifx_UReg_32Bit S32ROM:1;          /**< \brief [0:0] PFLASH p Sector 32 Locked for Forever - S32ROM (rh) */
    Ifx_UReg_32Bit S33ROM:1;          /**< \brief [1:1] PFLASH p Sector 33 Locked for Forever - S33ROM (rh) */
    Ifx_UReg_32Bit S34ROM:1;          /**< \brief [2:2] PFLASH p Sector 34 Locked for Forever - S34ROM (rh) */
    Ifx_UReg_32Bit S35ROM:1;          /**< \brief [3:3] PFLASH p Sector 35 Locked for Forever - S35ROM (rh) */
    Ifx_UReg_32Bit S36ROM:1;          /**< \brief [4:4] PFLASH p Sector 36 Locked for Forever - S36ROM (rh) */
    Ifx_UReg_32Bit S37ROM:1;          /**< \brief [5:5] PFLASH p Sector 37 Locked for Forever - S37ROM (rh) */
    Ifx_UReg_32Bit S38ROM:1;          /**< \brief [6:6] PFLASH p Sector 38 Locked for Forever - S38ROM (rh) */
    Ifx_UReg_32Bit S39ROM:1;          /**< \brief [7:7] PFLASH p Sector 39 Locked for Forever - S39ROM (rh) */
    Ifx_UReg_32Bit S40ROM:1;          /**< \brief [8:8] PFLASH p Sector 40 Locked for Forever - S40ROM (rh) */
    Ifx_UReg_32Bit S41ROM:1;          /**< \brief [9:9] PFLASH p Sector 41 Locked for Forever - S41ROM (rh) */
    Ifx_UReg_32Bit S42ROM:1;          /**< \brief [10:10] PFLASH p Sector 42 Locked for Forever - S42ROM (rh) */
    Ifx_UReg_32Bit S43ROM:1;          /**< \brief [11:11] PFLASH p Sector 43 Locked for Forever - S43ROM (rh) */
    Ifx_UReg_32Bit S44ROM:1;          /**< \brief [12:12] PFLASH p Sector 44 Locked for Forever - S44ROM (rh) */
    Ifx_UReg_32Bit S45ROM:1;          /**< \brief [13:13] PFLASH p Sector 45 Locked for Forever - S45ROM (rh) */
    Ifx_UReg_32Bit S46ROM:1;          /**< \brief [14:14] PFLASH p Sector 46 Locked for Forever - S46ROM (rh) */
    Ifx_UReg_32Bit S47ROM:1;          /**< \brief [15:15] PFLASH p Sector 47 Locked for Forever - S47ROM (rh) */
    Ifx_UReg_32Bit S48ROM:1;          /**< \brief [16:16] PFLASH p Sector 48 Locked for Forever - S48ROM (rh) */
    Ifx_UReg_32Bit S49ROM:1;          /**< \brief [17:17] PFLASH p Sector 49 Locked for Forever - S49ROM (rh) */
    Ifx_UReg_32Bit S50ROM:1;          /**< \brief [18:18] PFLASH p Sector 50 Locked for Forever - S50ROM (rh) */
    Ifx_UReg_32Bit S51ROM:1;          /**< \brief [19:19] PFLASH p Sector 51 Locked for Forever - S51ROM (rh) */
    Ifx_UReg_32Bit S52ROM:1;          /**< \brief [20:20] PFLASH p Sector 52 Locked for Forever - S52ROM (rh) */
    Ifx_UReg_32Bit S53ROM:1;          /**< \brief [21:21] PFLASH p Sector 53 Locked for Forever - S53ROM (rh) */
    Ifx_UReg_32Bit S54ROM:1;          /**< \brief [22:22] PFLASH p Sector 54 Locked for Forever - S54ROM (rh) */
    Ifx_UReg_32Bit S55ROM:1;          /**< \brief [23:23] PFLASH p Sector 55 Locked for Forever - S55ROM (rh) */
    Ifx_UReg_32Bit S56ROM:1;          /**< \brief [24:24] PFLASH p Sector 56 Locked for Forever - S56ROM (rh) */
    Ifx_UReg_32Bit S57ROM:1;          /**< \brief [25:25] PFLASH p Sector 57 Locked for Forever - S57ROM (rh) */
    Ifx_UReg_32Bit S58ROM:1;          /**< \brief [26:26] PFLASH p Sector 58 Locked for Forever - S58ROM (rh) */
    Ifx_UReg_32Bit S59ROM:1;          /**< \brief [27:27] PFLASH p Sector 59 Locked for Forever - S59ROM (rh) */
    Ifx_UReg_32Bit S60ROM:1;          /**< \brief [28:28] PFLASH p Sector 60 Locked for Forever - S60ROM (rh) */
    Ifx_UReg_32Bit S61ROM:1;          /**< \brief [29:29] PFLASH p Sector 61 Locked for Forever - S61ROM (rh) */
    Ifx_UReg_32Bit S62ROM:1;          /**< \brief [30:30] PFLASH p Sector 62 Locked for Forever - S62ROM (rh) */
    Ifx_UReg_32Bit S63ROM:1;          /**< \brief [31:31] PFLASH p Sector 63 Locked for Forever - S63ROM (rh) */
} Ifx_DMU_HP_PROCON_OTP1_Bits;

/** \brief PFLASH Bank ${i} OTP Protection Configuration 2 */
typedef struct _Ifx_DMU_HP_PROCON_OTP2_Bits
{
    Ifx_UReg_32Bit S64ROM:1;          /**< \brief [0:0] PFLASH p Sector 64 Locked for Forever - S64ROM (rh) */
    Ifx_UReg_32Bit S65ROM:1;          /**< \brief [1:1] PFLASH p Sector 65 Locked for Forever - S65ROM (rh) */
    Ifx_UReg_32Bit S66ROM:1;          /**< \brief [2:2] PFLASH p Sector 66 Locked for Forever - S66ROM (rh) */
    Ifx_UReg_32Bit S67ROM:1;          /**< \brief [3:3] PFLASH p Sector 67 Locked for Forever - S67ROM (rh) */
    Ifx_UReg_32Bit S68ROM:1;          /**< \brief [4:4] PFLASH p Sector 68 Locked for Forever - S68ROM (rh) */
    Ifx_UReg_32Bit S69ROM:1;          /**< \brief [5:5] PFLASH p Sector 69 Locked for Forever - S69ROM (rh) */
    Ifx_UReg_32Bit S70ROM:1;          /**< \brief [6:6] PFLASH p Sector 70 Locked for Forever - S70ROM (rh) */
    Ifx_UReg_32Bit S71ROM:1;          /**< \brief [7:7] PFLASH p Sector 71 Locked for Forever - S71ROM (rh) */
    Ifx_UReg_32Bit S72ROM:1;          /**< \brief [8:8] PFLASH p Sector 72 Locked for Forever - S72ROM (rh) */
    Ifx_UReg_32Bit S73ROM:1;          /**< \brief [9:9] PFLASH p Sector 73 Locked for Forever - S73ROM (rh) */
    Ifx_UReg_32Bit S74ROM:1;          /**< \brief [10:10] PFLASH p Sector 74 Locked for Forever - S74ROM (rh) */
    Ifx_UReg_32Bit S75ROM:1;          /**< \brief [11:11] PFLASH p Sector 75 Locked for Forever - S75ROM (rh) */
    Ifx_UReg_32Bit S76ROM:1;          /**< \brief [12:12] PFLASH p Sector 76 Locked for Forever - S76ROM (rh) */
    Ifx_UReg_32Bit S77ROM:1;          /**< \brief [13:13] PFLASH p Sector 77 Locked for Forever - S77ROM (rh) */
    Ifx_UReg_32Bit S78ROM:1;          /**< \brief [14:14] PFLASH p Sector 78 Locked for Forever - S78ROM (rh) */
    Ifx_UReg_32Bit S79ROM:1;          /**< \brief [15:15] PFLASH p Sector 79 Locked for Forever - S79ROM (rh) */
    Ifx_UReg_32Bit S80ROM:1;          /**< \brief [16:16] PFLASH p Sector 80 Locked for Forever - S80ROM (rh) */
    Ifx_UReg_32Bit S81ROM:1;          /**< \brief [17:17] PFLASH p Sector 81 Locked for Forever - S81ROM (rh) */
    Ifx_UReg_32Bit S82ROM:1;          /**< \brief [18:18] PFLASH p Sector 82 Locked for Forever - S82ROM (rh) */
    Ifx_UReg_32Bit S83ROM:1;          /**< \brief [19:19] PFLASH p Sector 83 Locked for Forever - S83ROM (rh) */
    Ifx_UReg_32Bit S84ROM:1;          /**< \brief [20:20] PFLASH p Sector 84 Locked for Forever - S84ROM (rh) */
    Ifx_UReg_32Bit S85ROM:1;          /**< \brief [21:21] PFLASH p Sector 85 Locked for Forever - S85ROM (rh) */
    Ifx_UReg_32Bit S86ROM:1;          /**< \brief [22:22] PFLASH p Sector 86 Locked for Forever - S86ROM (rh) */
    Ifx_UReg_32Bit S87ROM:1;          /**< \brief [23:23] PFLASH p Sector 87 Locked for Forever - S87ROM (rh) */
    Ifx_UReg_32Bit S88ROM:1;          /**< \brief [24:24] PFLASH p Sector 88 Locked for Forever - S88ROM (rh) */
    Ifx_UReg_32Bit S89ROM:1;          /**< \brief [25:25] PFLASH p Sector 89 Locked for Forever - S89ROM (rh) */
    Ifx_UReg_32Bit S90ROM:1;          /**< \brief [26:26] PFLASH p Sector 90 Locked for Forever - S90ROM (rh) */
    Ifx_UReg_32Bit S91ROM:1;          /**< \brief [27:27] PFLASH p Sector 91 Locked for Forever - S91ROM (rh) */
    Ifx_UReg_32Bit S92ROM:1;          /**< \brief [28:28] PFLASH p Sector 92 Locked for Forever - S92ROM (rh) */
    Ifx_UReg_32Bit S93ROM:1;          /**< \brief [29:29] PFLASH p Sector 93 Locked for Forever - S93ROM (rh) */
    Ifx_UReg_32Bit S94ROM:1;          /**< \brief [30:30] PFLASH p Sector 94 Locked for Forever - S94ROM (rh) */
    Ifx_UReg_32Bit S95ROM:1;          /**< \brief [31:31] PFLASH p Sector 95 Locked for Forever - S95ROM (rh) */
} Ifx_DMU_HP_PROCON_OTP2_Bits;

/** \brief PFLASH Bank ${i} OTP Protection Configuration 3 */
typedef struct _Ifx_DMU_HP_PROCON_OTP3_Bits
{
    Ifx_UReg_32Bit S96ROM:1;          /**< \brief [0:0] PFLASH p Sector 96 Locked for Forever - S96ROM (rh) */
    Ifx_UReg_32Bit S97ROM:1;          /**< \brief [1:1] PFLASH p Sector 97 Locked for Forever - S97ROM (rh) */
    Ifx_UReg_32Bit S98ROM:1;          /**< \brief [2:2] PFLASH p Sector 98 Locked for Forever - S98ROM (rh) */
    Ifx_UReg_32Bit S99ROM:1;          /**< \brief [3:3] PFLASH p Sector 99 Locked for Forever - S99ROM (rh) */
    Ifx_UReg_32Bit S100ROM:1;         /**< \brief [4:4] PFLASH p Sector 100 Locked for Forever - S100ROM (rh) */
    Ifx_UReg_32Bit S101ROM:1;         /**< \brief [5:5] PFLASH p Sector 101 Locked for Forever - S101ROM (rh) */
    Ifx_UReg_32Bit S102ROM:1;         /**< \brief [6:6] PFLASH p Sector 102 Locked for Forever - S102ROM (rh) */
    Ifx_UReg_32Bit S103ROM:1;         /**< \brief [7:7] PFLASH p Sector 103 Locked for Forever - S103ROM (rh) */
    Ifx_UReg_32Bit S104ROM:1;         /**< \brief [8:8] PFLASH p Sector 104 Locked for Forever - S104ROM (rh) */
    Ifx_UReg_32Bit S105ROM:1;         /**< \brief [9:9] PFLASH p Sector 105 Locked for Forever - S105ROM (rh) */
    Ifx_UReg_32Bit S106ROM:1;         /**< \brief [10:10] PFLASH p Sector 106 Locked for Forever - S106ROM (rh) */
    Ifx_UReg_32Bit S107ROM:1;         /**< \brief [11:11] PFLASH p Sector 107 Locked for Forever - S107ROM (rh) */
    Ifx_UReg_32Bit S108ROM:1;         /**< \brief [12:12] PFLASH p Sector 108 Locked for Forever - S108ROM (rh) */
    Ifx_UReg_32Bit S109ROM:1;         /**< \brief [13:13] PFLASH p Sector 109 Locked for Forever - S109ROM (rh) */
    Ifx_UReg_32Bit S110ROM:1;         /**< \brief [14:14] PFLASH p Sector 110 Locked for Forever - S110ROM (rh) */
    Ifx_UReg_32Bit S111ROM:1;         /**< \brief [15:15] PFLASH p Sector 111 Locked for Forever - S111ROM (rh) */
    Ifx_UReg_32Bit S112ROM:1;         /**< \brief [16:16] PFLASH p Sector 112 Locked for Forever - S112ROM (rh) */
    Ifx_UReg_32Bit S113ROM:1;         /**< \brief [17:17] PFLASH p Sector 113 Locked for Forever - S113ROM (rh) */
    Ifx_UReg_32Bit S114ROM:1;         /**< \brief [18:18] PFLASH p Sector 114 Locked for Forever - S114ROM (rh) */
    Ifx_UReg_32Bit S115ROM:1;         /**< \brief [19:19] PFLASH p Sector 115 Locked for Forever - S115ROM (rh) */
    Ifx_UReg_32Bit S116ROM:1;         /**< \brief [20:20] PFLASH p Sector 116 Locked for Forever - S116ROM (rh) */
    Ifx_UReg_32Bit S117ROM:1;         /**< \brief [21:21] PFLASH p Sector 117 Locked for Forever - S117ROM (rh) */
    Ifx_UReg_32Bit S118ROM:1;         /**< \brief [22:22] PFLASH p Sector 118 Locked for Forever - S118ROM (rh) */
    Ifx_UReg_32Bit S119ROM:1;         /**< \brief [23:23] PFLASH p Sector 119 Locked for Forever - S119ROM (rh) */
    Ifx_UReg_32Bit S120ROM:1;         /**< \brief [24:24] PFLASH p Sector 120 Locked for Forever - S120ROM (rh) */
    Ifx_UReg_32Bit S121ROM:1;         /**< \brief [25:25] PFLASH p Sector 121 Locked for Forever - S121ROM (rh) */
    Ifx_UReg_32Bit S122ROM:1;         /**< \brief [26:26] PFLASH p Sector 122 Locked for Forever - S122ROM (rh) */
    Ifx_UReg_32Bit S123ROM:1;         /**< \brief [27:27] PFLASH p Sector 123 Locked for Forever - S123ROM (rh) */
    Ifx_UReg_32Bit S124ROM:1;         /**< \brief [28:28] PFLASH p Sector 124 Locked for Forever - S124ROM (rh) */
    Ifx_UReg_32Bit S125ROM:1;         /**< \brief [29:29] PFLASH p Sector 125 Locked for Forever - S125ROM (rh) */
    Ifx_UReg_32Bit S126ROM:1;         /**< \brief [30:30] PFLASH p Sector 126 Locked for Forever - S126ROM (rh) */
    Ifx_UReg_32Bit S127ROM:1;         /**< \brief [31:31] PFLASH p Sector 127 Locked for Forever - S127ROM (rh) */
} Ifx_DMU_HP_PROCON_OTP3_Bits;

/** \brief PFLASH Bank ${i} OTP Protection Configuration 4 */
typedef struct _Ifx_DMU_HP_PROCON_OTP4_Bits
{
    Ifx_UReg_32Bit S128ROM:1;         /**< \brief [0:0] PFLASH p Sector 128 Locked for Forever - S128ROM (rh) */
    Ifx_UReg_32Bit S129ROM:1;         /**< \brief [1:1] PFLASH p Sector 129 Locked for Forever - S129ROM (rh) */
    Ifx_UReg_32Bit S130ROM:1;         /**< \brief [2:2] PFLASH p Sector 130 Locked for Forever - S130ROM (rh) */
    Ifx_UReg_32Bit S131ROM:1;         /**< \brief [3:3] PFLASH p Sector 131 Locked for Forever - S131ROM (rh) */
    Ifx_UReg_32Bit S132ROM:1;         /**< \brief [4:4] PFLASH p Sector 132 Locked for Forever - S132ROM (rh) */
    Ifx_UReg_32Bit S133ROM:1;         /**< \brief [5:5] PFLASH p Sector 133 Locked for Forever - S133ROM (rh) */
    Ifx_UReg_32Bit S134ROM:1;         /**< \brief [6:6] PFLASH p Sector 134 Locked for Forever - S134ROM (rh) */
    Ifx_UReg_32Bit S135ROM:1;         /**< \brief [7:7] PFLASH p Sector 135 Locked for Forever - S135ROM (rh) */
    Ifx_UReg_32Bit S136ROM:1;         /**< \brief [8:8] PFLASH p Sector 136 Locked for Forever - S136ROM (rh) */
    Ifx_UReg_32Bit S137ROM:1;         /**< \brief [9:9] PFLASH p Sector 137 Locked for Forever - S137ROM (rh) */
    Ifx_UReg_32Bit S138ROM:1;         /**< \brief [10:10] PFLASH p Sector 138 Locked for Forever - S138ROM (rh) */
    Ifx_UReg_32Bit S139ROM:1;         /**< \brief [11:11] PFLASH p Sector 139 Locked for Forever - S139ROM (rh) */
    Ifx_UReg_32Bit S140ROM:1;         /**< \brief [12:12] PFLASH p Sector 140 Locked for Forever - S140ROM (rh) */
    Ifx_UReg_32Bit S141ROM:1;         /**< \brief [13:13] PFLASH p Sector 141 Locked for Forever - S141ROM (rh) */
    Ifx_UReg_32Bit S142ROM:1;         /**< \brief [14:14] PFLASH p Sector 142 Locked for Forever - S142ROM (rh) */
    Ifx_UReg_32Bit S143ROM:1;         /**< \brief [15:15] PFLASH p Sector 143 Locked for Forever - S143ROM (rh) */
    Ifx_UReg_32Bit S144ROM:1;         /**< \brief [16:16] PFLASH p Sector 144 Locked for Forever - S144ROM (rh) */
    Ifx_UReg_32Bit S145ROM:1;         /**< \brief [17:17] PFLASH p Sector 145 Locked for Forever - S145ROM (rh) */
    Ifx_UReg_32Bit S146ROM:1;         /**< \brief [18:18] PFLASH p Sector 146 Locked for Forever - S146ROM (rh) */
    Ifx_UReg_32Bit S147ROM:1;         /**< \brief [19:19] PFLASH p Sector 147 Locked for Forever - S147ROM (rh) */
    Ifx_UReg_32Bit S148ROM:1;         /**< \brief [20:20] PFLASH p Sector 148 Locked for Forever - S148ROM (rh) */
    Ifx_UReg_32Bit S149ROM:1;         /**< \brief [21:21] PFLASH p Sector 149 Locked for Forever - S149ROM (rh) */
    Ifx_UReg_32Bit S150ROM:1;         /**< \brief [22:22] PFLASH p Sector 150 Locked for Forever - S150ROM (rh) */
    Ifx_UReg_32Bit S151ROM:1;         /**< \brief [23:23] PFLASH p Sector 151 Locked for Forever - S151ROM (rh) */
    Ifx_UReg_32Bit S152ROM:1;         /**< \brief [24:24] PFLASH p Sector 152 Locked for Forever - S152ROM (rh) */
    Ifx_UReg_32Bit S153ROM:1;         /**< \brief [25:25] PFLASH p Sector 153 Locked for Forever - S153ROM (rh) */
    Ifx_UReg_32Bit S154ROM:1;         /**< \brief [26:26] PFLASH p Sector 154 Locked for Forever - S154ROM (rh) */
    Ifx_UReg_32Bit S155ROM:1;         /**< \brief [27:27] PFLASH p Sector 155 Locked for Forever - S155ROM (rh) */
    Ifx_UReg_32Bit S156ROM:1;         /**< \brief [28:28] PFLASH p Sector 156 Locked for Forever - S156ROM (rh) */
    Ifx_UReg_32Bit S157ROM:1;         /**< \brief [29:29] PFLASH p Sector 157 Locked for Forever - S157ROM (rh) */
    Ifx_UReg_32Bit S158ROM:1;         /**< \brief [30:30] PFLASH p Sector 158 Locked for Forever - S158ROM (rh) */
    Ifx_UReg_32Bit S159ROM:1;         /**< \brief [31:31] PFLASH p Sector 159 Locked for Forever - S159ROM (rh) */
} Ifx_DMU_HP_PROCON_OTP4_Bits;

/** \brief PFLASH Bank ${i} OTP Protection Configuration 5 */
typedef struct _Ifx_DMU_HP_PROCON_OTP5_Bits
{
    Ifx_UReg_32Bit S160ROM:1;         /**< \brief [0:0] PFLASH p Sector 160 Locked for Forever - S160ROM (rh) */
    Ifx_UReg_32Bit S161ROM:1;         /**< \brief [1:1] PFLASH p Sector 161 Locked for Forever - S161ROM (rh) */
    Ifx_UReg_32Bit S162ROM:1;         /**< \brief [2:2] PFLASH p Sector 162 Locked for Forever - S162ROM (rh) */
    Ifx_UReg_32Bit S163ROM:1;         /**< \brief [3:3] PFLASH p Sector 163 Locked for Forever - S163ROM (rh) */
    Ifx_UReg_32Bit S164ROM:1;         /**< \brief [4:4] PFLASH p Sector 164 Locked for Forever - S164ROM (rh) */
    Ifx_UReg_32Bit S165ROM:1;         /**< \brief [5:5] PFLASH p Sector 165 Locked for Forever - S165ROM (rh) */
    Ifx_UReg_32Bit S166ROM:1;         /**< \brief [6:6] PFLASH p Sector 166 Locked for Forever - S166ROM (rh) */
    Ifx_UReg_32Bit S167ROM:1;         /**< \brief [7:7] PFLASH p Sector 167 Locked for Forever - S167ROM (rh) */
    Ifx_UReg_32Bit S168ROM:1;         /**< \brief [8:8] PFLASH p Sector 168 Locked for Forever - S168ROM (rh) */
    Ifx_UReg_32Bit S169ROM:1;         /**< \brief [9:9] PFLASH p Sector 169 Locked for Forever - S169ROM (rh) */
    Ifx_UReg_32Bit S170ROM:1;         /**< \brief [10:10] PFLASH p Sector 170 Locked for Forever - S170ROM (rh) */
    Ifx_UReg_32Bit S171ROM:1;         /**< \brief [11:11] PFLASH p Sector 171 Locked for Forever - S171ROM (rh) */
    Ifx_UReg_32Bit S172ROM:1;         /**< \brief [12:12] PFLASH p Sector 172 Locked for Forever - S172ROM (rh) */
    Ifx_UReg_32Bit S173ROM:1;         /**< \brief [13:13] PFLASH p Sector 173 Locked for Forever - S173ROM (rh) */
    Ifx_UReg_32Bit S174ROM:1;         /**< \brief [14:14] PFLASH p Sector 174 Locked for Forever - S174ROM (rh) */
    Ifx_UReg_32Bit S175ROM:1;         /**< \brief [15:15] PFLASH p Sector 175 Locked for Forever - S175ROM (rh) */
    Ifx_UReg_32Bit S176ROM:1;         /**< \brief [16:16] PFLASH p Sector 176 Locked for Forever - S176ROM (rh) */
    Ifx_UReg_32Bit S177ROM:1;         /**< \brief [17:17] PFLASH p Sector 177 Locked for Forever - S177ROM (rh) */
    Ifx_UReg_32Bit S178ROM:1;         /**< \brief [18:18] PFLASH p Sector 178 Locked for Forever - S178ROM (rh) */
    Ifx_UReg_32Bit S179ROM:1;         /**< \brief [19:19] PFLASH p Sector 179 Locked for Forever - S179ROM (rh) */
    Ifx_UReg_32Bit S180ROM:1;         /**< \brief [20:20] PFLASH p Sector 180 Locked for Forever - S180ROM (rh) */
    Ifx_UReg_32Bit S181ROM:1;         /**< \brief [21:21] PFLASH p Sector 181 Locked for Forever - S181ROM (rh) */
    Ifx_UReg_32Bit S182ROM:1;         /**< \brief [22:22] PFLASH p Sector 182 Locked for Forever - S182ROM (rh) */
    Ifx_UReg_32Bit S183ROM:1;         /**< \brief [23:23] PFLASH p Sector 183 Locked for Forever - S183ROM (rh) */
    Ifx_UReg_32Bit S184ROM:1;         /**< \brief [24:24] PFLASH p Sector 184 Locked for Forever - S184ROM (rh) */
    Ifx_UReg_32Bit S185ROM:1;         /**< \brief [25:25] PFLASH p Sector 185 Locked for Forever - S185ROM (rh) */
    Ifx_UReg_32Bit S186ROM:1;         /**< \brief [26:26] PFLASH p Sector 186 Locked for Forever - S186ROM (rh) */
    Ifx_UReg_32Bit S187ROM:1;         /**< \brief [27:27] PFLASH p Sector 187 Locked for Forever - S187ROM (rh) */
    Ifx_UReg_32Bit S188ROM:1;         /**< \brief [28:28] PFLASH p Sector 188 Locked for Forever - S188ROM (rh) */
    Ifx_UReg_32Bit S189ROM:1;         /**< \brief [29:29] PFLASH p Sector 189 Locked for Forever - S189ROM (rh) */
    Ifx_UReg_32Bit S190ROM:1;         /**< \brief [30:30] PFLASH p Sector 190 Locked for Forever - S190ROM (rh) */
    Ifx_UReg_32Bit S191ROM:1;         /**< \brief [31:31] PFLASH p Sector 191 Locked for Forever - S191ROM (rh) */
} Ifx_DMU_HP_PROCON_OTP5_Bits;

/** \brief PFLASH Bank ${i} Protection Configuration 0 */
typedef struct _Ifx_DMU_HP_PROCON_P0_Bits
{
    Ifx_UReg_32Bit S0L:1;             /**< \brief [0:0] PFLASH p Sector 0 Locked for Write Protection - S0L (rh) */
    Ifx_UReg_32Bit S1L:1;             /**< \brief [1:1] PFLASH p Sector 1 Locked for Write Protection - S1L (rh) */
    Ifx_UReg_32Bit S2L:1;             /**< \brief [2:2] PFLASH p Sector 2 Locked for Write Protection - S2L (rh) */
    Ifx_UReg_32Bit S3L:1;             /**< \brief [3:3] PFLASH p Sector 3 Locked for Write Protection - S3L (rh) */
    Ifx_UReg_32Bit S4L:1;             /**< \brief [4:4] PFLASH p Sector 4 Locked for Write Protection - S4L (rh) */
    Ifx_UReg_32Bit S5L:1;             /**< \brief [5:5] PFLASH p Sector 5 Locked for Write Protection - S5L (rh) */
    Ifx_UReg_32Bit S6L:1;             /**< \brief [6:6] PFLASH p Sector 6 Locked for Write Protection - S6L (rh) */
    Ifx_UReg_32Bit S7L:1;             /**< \brief [7:7] PFLASH p Sector 7 Locked for Write Protection - S7L (rh) */
    Ifx_UReg_32Bit S8L:1;             /**< \brief [8:8] PFLASH p Sector 8 Locked for Write Protection - S8L (rh) */
    Ifx_UReg_32Bit S9L:1;             /**< \brief [9:9] PFLASH p Sector 9 Locked for Write Protection - S9L (rh) */
    Ifx_UReg_32Bit S10L:1;            /**< \brief [10:10] PFLASH p Sector 10 Locked for Write Protection - S10L (rh) */
    Ifx_UReg_32Bit S11L:1;            /**< \brief [11:11] PFLASH p Sector 11 Locked for Write Protection - S11L (rh) */
    Ifx_UReg_32Bit S12L:1;            /**< \brief [12:12] PFLASH p Sector 12 Locked for Write Protection - S12L (rh) */
    Ifx_UReg_32Bit S13L:1;            /**< \brief [13:13] PFLASH p Sector 13 Locked for Write Protection - S13L (rh) */
    Ifx_UReg_32Bit S14L:1;            /**< \brief [14:14] PFLASH p Sector 14 Locked for Write Protection - S14L (rh) */
    Ifx_UReg_32Bit S15L:1;            /**< \brief [15:15] PFLASH p Sector 15 Locked for Write Protection - S15L (rh) */
    Ifx_UReg_32Bit S16L:1;            /**< \brief [16:16] PFLASH p Sector 16 Locked for Write Protection - S16L (rh) */
    Ifx_UReg_32Bit S17L:1;            /**< \brief [17:17] PFLASH p Sector 17 Locked for Write Protection - S17L (rh) */
    Ifx_UReg_32Bit S18L:1;            /**< \brief [18:18] PFLASH p Sector 18 Locked for Write Protection - S18L (rh) */
    Ifx_UReg_32Bit S19L:1;            /**< \brief [19:19] PFLASH p Sector 19 Locked for Write Protection - S19L (rh) */
    Ifx_UReg_32Bit S20L:1;            /**< \brief [20:20] PFLASH p Sector 20 Locked for Write Protection - S20L (rh) */
    Ifx_UReg_32Bit S21L:1;            /**< \brief [21:21] PFLASH p Sector 21 Locked for Write Protection - S21L (rh) */
    Ifx_UReg_32Bit S22L:1;            /**< \brief [22:22] PFLASH p Sector 22 Locked for Write Protection - S22L (rh) */
    Ifx_UReg_32Bit S23L:1;            /**< \brief [23:23] PFLASH p Sector 23 Locked for Write Protection - S23L (rh) */
    Ifx_UReg_32Bit S24L:1;            /**< \brief [24:24] PFLASH p Sector 24 Locked for Write Protection - S24L (rh) */
    Ifx_UReg_32Bit S25L:1;            /**< \brief [25:25] PFLASH p Sector 25 Locked for Write Protection - S25L (rh) */
    Ifx_UReg_32Bit S26L:1;            /**< \brief [26:26] PFLASH p Sector 26 Locked for Write Protection - S26L (rh) */
    Ifx_UReg_32Bit S27L:1;            /**< \brief [27:27] PFLASH p Sector 27 Locked for Write Protection - S27L (rh) */
    Ifx_UReg_32Bit S28L:1;            /**< \brief [28:28] PFLASH p Sector 28 Locked for Write Protection - S28L (rh) */
    Ifx_UReg_32Bit S29L:1;            /**< \brief [29:29] PFLASH p Sector 29 Locked for Write Protection - S29L (rh) */
    Ifx_UReg_32Bit S30L:1;            /**< \brief [30:30] PFLASH p Sector 30 Locked for Write Protection - S30L (rh) */
    Ifx_UReg_32Bit S31L:1;            /**< \brief [31:31] PFLASH p Sector 31 Locked for Write Protection - S31L (rh) */
} Ifx_DMU_HP_PROCON_P0_Bits;

/** \brief PFLASH Bank ${i} Protection Configuration 1 */
typedef struct _Ifx_DMU_HP_PROCON_P1_Bits
{
    Ifx_UReg_32Bit S32L:1;            /**< \brief [0:0] PFLASH p Sector 32 Locked for Write Protection - S32L (rh) */
    Ifx_UReg_32Bit S33L:1;            /**< \brief [1:1] PFLASH p Sector 33 Locked for Write Protection - S33L (rh) */
    Ifx_UReg_32Bit S34L:1;            /**< \brief [2:2] PFLASH p Sector 34 Locked for Write Protection - S34L (rh) */
    Ifx_UReg_32Bit S35L:1;            /**< \brief [3:3] PFLASH p Sector 35 Locked for Write Protection - S35L (rh) */
    Ifx_UReg_32Bit S36L:1;            /**< \brief [4:4] PFLASH p Sector 36 Locked for Write Protection - S36L (rh) */
    Ifx_UReg_32Bit S37L:1;            /**< \brief [5:5] PFLASH p Sector 37 Locked for Write Protection - S37L (rh) */
    Ifx_UReg_32Bit S38L:1;            /**< \brief [6:6] PFLASH p Sector 38 Locked for Write Protection - S38L (rh) */
    Ifx_UReg_32Bit S39L:1;            /**< \brief [7:7] PFLASH p Sector 39 Locked for Write Protection - S39L (rh) */
    Ifx_UReg_32Bit S40L:1;            /**< \brief [8:8] PFLASH p Sector 40 Locked for Write Protection - S40L (rh) */
    Ifx_UReg_32Bit S41L:1;            /**< \brief [9:9] PFLASH p Sector 41 Locked for Write Protection - S41L (rh) */
    Ifx_UReg_32Bit S42L:1;            /**< \brief [10:10] PFLASH p Sector 42 Locked for Write Protection - S42L (rh) */
    Ifx_UReg_32Bit S43L:1;            /**< \brief [11:11] PFLASH p Sector 43 Locked for Write Protection - S43L (rh) */
    Ifx_UReg_32Bit S44L:1;            /**< \brief [12:12] PFLASH p Sector 44 Locked for Write Protection - S44L (rh) */
    Ifx_UReg_32Bit S45L:1;            /**< \brief [13:13] PFLASH p Sector 45 Locked for Write Protection - S45L (rh) */
    Ifx_UReg_32Bit S46L:1;            /**< \brief [14:14] PFLASH p Sector 46 Locked for Write Protection - S46L (rh) */
    Ifx_UReg_32Bit S47L:1;            /**< \brief [15:15] PFLASH p Sector 47 Locked for Write Protection - S47L (rh) */
    Ifx_UReg_32Bit S48L:1;            /**< \brief [16:16] PFLASH p Sector 48 Locked for Write Protection - S48L (rh) */
    Ifx_UReg_32Bit S49L:1;            /**< \brief [17:17] PFLASH p Sector 49 Locked for Write Protection - S49L (rh) */
    Ifx_UReg_32Bit S50L:1;            /**< \brief [18:18] PFLASH p Sector 50 Locked for Write Protection - S50L (rh) */
    Ifx_UReg_32Bit S51L:1;            /**< \brief [19:19] PFLASH p Sector 51 Locked for Write Protection - S51L (rh) */
    Ifx_UReg_32Bit S52L:1;            /**< \brief [20:20] PFLASH p Sector 52 Locked for Write Protection - S52L (rh) */
    Ifx_UReg_32Bit S53L:1;            /**< \brief [21:21] PFLASH p Sector 53 Locked for Write Protection - S53L (rh) */
    Ifx_UReg_32Bit S54L:1;            /**< \brief [22:22] PFLASH p Sector 54 Locked for Write Protection - S54L (rh) */
    Ifx_UReg_32Bit S55L:1;            /**< \brief [23:23] PFLASH p Sector 55 Locked for Write Protection - S55L (rh) */
    Ifx_UReg_32Bit S56L:1;            /**< \brief [24:24] PFLASH p Sector 56 Locked for Write Protection - S56L (rh) */
    Ifx_UReg_32Bit S57L:1;            /**< \brief [25:25] PFLASH p Sector 57 Locked for Write Protection - S57L (rh) */
    Ifx_UReg_32Bit S58L:1;            /**< \brief [26:26] PFLASH p Sector 58 Locked for Write Protection - S58L (rh) */
    Ifx_UReg_32Bit S59L:1;            /**< \brief [27:27] PFLASH p Sector 59 Locked for Write Protection - S59L (rh) */
    Ifx_UReg_32Bit S60L:1;            /**< \brief [28:28] PFLASH p Sector 60 Locked for Write Protection - S60L (rh) */
    Ifx_UReg_32Bit S61L:1;            /**< \brief [29:29] PFLASH p Sector 61 Locked for Write Protection - S61L (rh) */
    Ifx_UReg_32Bit S62L:1;            /**< \brief [30:30] PFLASH p Sector 62 Locked for Write Protection - S62L (rh) */
    Ifx_UReg_32Bit S63L:1;            /**< \brief [31:31] PFLASH p Sector 63 Locked for Write Protection - S63L (rh) */
} Ifx_DMU_HP_PROCON_P1_Bits;

/** \brief PFLASH Bank ${i} Protection Configuration 2 */
typedef struct _Ifx_DMU_HP_PROCON_P2_Bits
{
    Ifx_UReg_32Bit S64L:1;            /**< \brief [0:0] PFLASH p Sector 64 Locked for Write Protection - S64L (rh) */
    Ifx_UReg_32Bit S65L:1;            /**< \brief [1:1] PFLASH p Sector 65 Locked for Write Protection - S65L (rh) */
    Ifx_UReg_32Bit S66L:1;            /**< \brief [2:2] PFLASH p Sector 66 Locked for Write Protection - S66L (rh) */
    Ifx_UReg_32Bit S67L:1;            /**< \brief [3:3] PFLASH p Sector 67 Locked for Write Protection - S67L (rh) */
    Ifx_UReg_32Bit S68L:1;            /**< \brief [4:4] PFLASH p Sector 68 Locked for Write Protection - S68L (rh) */
    Ifx_UReg_32Bit S69L:1;            /**< \brief [5:5] PFLASH p Sector 69 Locked for Write Protection - S69L (rh) */
    Ifx_UReg_32Bit S70L:1;            /**< \brief [6:6] PFLASH p Sector 70 Locked for Write Protection - S70L (rh) */
    Ifx_UReg_32Bit S71L:1;            /**< \brief [7:7] PFLASH p Sector 71 Locked for Write Protection - S71L (rh) */
    Ifx_UReg_32Bit S72L:1;            /**< \brief [8:8] PFLASH p Sector 72 Locked for Write Protection - S72L (rh) */
    Ifx_UReg_32Bit S73L:1;            /**< \brief [9:9] PFLASH p Sector 73 Locked for Write Protection - S73L (rh) */
    Ifx_UReg_32Bit S74L:1;            /**< \brief [10:10] PFLASH p Sector 74 Locked for Write Protection - S74L (rh) */
    Ifx_UReg_32Bit S75L:1;            /**< \brief [11:11] PFLASH p Sector 75 Locked for Write Protection - S75L (rh) */
    Ifx_UReg_32Bit S76L:1;            /**< \brief [12:12] PFLASH p Sector 76 Locked for Write Protection - S76L (rh) */
    Ifx_UReg_32Bit S77L:1;            /**< \brief [13:13] PFLASH p Sector 77 Locked for Write Protection - S77L (rh) */
    Ifx_UReg_32Bit S78L:1;            /**< \brief [14:14] PFLASH p Sector 78 Locked for Write Protection - S78L (rh) */
    Ifx_UReg_32Bit S79L:1;            /**< \brief [15:15] PFLASH p Sector 79 Locked for Write Protection - S79L (rh) */
    Ifx_UReg_32Bit S80L:1;            /**< \brief [16:16] PFLASH p Sector 80 Locked for Write Protection - S80L (rh) */
    Ifx_UReg_32Bit S81L:1;            /**< \brief [17:17] PFLASH p Sector 81 Locked for Write Protection - S81L (rh) */
    Ifx_UReg_32Bit S82L:1;            /**< \brief [18:18] PFLASH p Sector 82 Locked for Write Protection - S82L (rh) */
    Ifx_UReg_32Bit S83L:1;            /**< \brief [19:19] PFLASH p Sector 83 Locked for Write Protection - S83L (rh) */
    Ifx_UReg_32Bit S84L:1;            /**< \brief [20:20] PFLASH p Sector 84 Locked for Write Protection - S84L (rh) */
    Ifx_UReg_32Bit S85L:1;            /**< \brief [21:21] PFLASH p Sector 85 Locked for Write Protection - S85L (rh) */
    Ifx_UReg_32Bit S86L:1;            /**< \brief [22:22] PFLASH p Sector 86 Locked for Write Protection - S86L (rh) */
    Ifx_UReg_32Bit S87L:1;            /**< \brief [23:23] PFLASH p Sector 87 Locked for Write Protection - S87L (rh) */
    Ifx_UReg_32Bit S88L:1;            /**< \brief [24:24] PFLASH p Sector 88 Locked for Write Protection - S88L (rh) */
    Ifx_UReg_32Bit S89L:1;            /**< \brief [25:25] PFLASH p Sector 89 Locked for Write Protection - S89L (rh) */
    Ifx_UReg_32Bit S90L:1;            /**< \brief [26:26] PFLASH p Sector 90 Locked for Write Protection - S90L (rh) */
    Ifx_UReg_32Bit S91L:1;            /**< \brief [27:27] PFLASH p Sector 91 Locked for Write Protection - S91L (rh) */
    Ifx_UReg_32Bit S92L:1;            /**< \brief [28:28] PFLASH p Sector 92 Locked for Write Protection - S92L (rh) */
    Ifx_UReg_32Bit S93L:1;            /**< \brief [29:29] PFLASH p Sector 93 Locked for Write Protection - S93L (rh) */
    Ifx_UReg_32Bit S94L:1;            /**< \brief [30:30] PFLASH p Sector 94 Locked for Write Protection - S94L (rh) */
    Ifx_UReg_32Bit S95L:1;            /**< \brief [31:31] PFLASH p Sector 95 Locked for Write Protection - S95L (rh) */
} Ifx_DMU_HP_PROCON_P2_Bits;

/** \brief PFLASH Bank ${i} Protection Configuration 3 */
typedef struct _Ifx_DMU_HP_PROCON_P3_Bits
{
    Ifx_UReg_32Bit S96L:1;            /**< \brief [0:0] PFLASH p Sector 96 Locked for Write Protection - S96L (rh) */
    Ifx_UReg_32Bit S97L:1;            /**< \brief [1:1] PFLASH p Sector 97 Locked for Write Protection - S97L (rh) */
    Ifx_UReg_32Bit S98L:1;            /**< \brief [2:2] PFLASH p Sector 98 Locked for Write Protection - S98L (rh) */
    Ifx_UReg_32Bit S99L:1;            /**< \brief [3:3] PFLASH p Sector 99 Locked for Write Protection - S99L (rh) */
    Ifx_UReg_32Bit S100L:1;           /**< \brief [4:4] PFLASH p Sector 100 Locked for Write Protection - S100L (rh) */
    Ifx_UReg_32Bit S101L:1;           /**< \brief [5:5] PFLASH p Sector 101 Locked for Write Protection - S101L (rh) */
    Ifx_UReg_32Bit S102L:1;           /**< \brief [6:6] PFLASH p Sector 102 Locked for Write Protection - S102L (rh) */
    Ifx_UReg_32Bit S103L:1;           /**< \brief [7:7] PFLASH p Sector 103 Locked for Write Protection - S103L (rh) */
    Ifx_UReg_32Bit S104L:1;           /**< \brief [8:8] PFLASH p Sector 104 Locked for Write Protection - S104L (rh) */
    Ifx_UReg_32Bit S105L:1;           /**< \brief [9:9] PFLASH p Sector 105 Locked for Write Protection - S105L (rh) */
    Ifx_UReg_32Bit S106L:1;           /**< \brief [10:10] PFLASH p Sector 106 Locked for Write Protection - S106L (rh) */
    Ifx_UReg_32Bit S107L:1;           /**< \brief [11:11] PFLASH p Sector 107 Locked for Write Protection - S107L (rh) */
    Ifx_UReg_32Bit S108L:1;           /**< \brief [12:12] PFLASH p Sector 108 Locked for Write Protection - S108L (rh) */
    Ifx_UReg_32Bit S109L:1;           /**< \brief [13:13] PFLASH p Sector 109 Locked for Write Protection - S109L (rh) */
    Ifx_UReg_32Bit S110L:1;           /**< \brief [14:14] PFLASH p Sector 110 Locked for Write Protection - S110L (rh) */
    Ifx_UReg_32Bit S111L:1;           /**< \brief [15:15] PFLASH p Sector 111 Locked for Write Protection - S111L (rh) */
    Ifx_UReg_32Bit S112L:1;           /**< \brief [16:16] PFLASH p Sector 112 Locked for Write Protection - S112L (rh) */
    Ifx_UReg_32Bit S113L:1;           /**< \brief [17:17] PFLASH p Sector 113 Locked for Write Protection - S113L (rh) */
    Ifx_UReg_32Bit S114L:1;           /**< \brief [18:18] PFLASH p Sector 114 Locked for Write Protection - S114L (rh) */
    Ifx_UReg_32Bit S115L:1;           /**< \brief [19:19] PFLASH p Sector 115 Locked for Write Protection - S115L (rh) */
    Ifx_UReg_32Bit S116L:1;           /**< \brief [20:20] PFLASH p Sector 116 Locked for Write Protection - S116L (rh) */
    Ifx_UReg_32Bit S117L:1;           /**< \brief [21:21] PFLASH p Sector 117 Locked for Write Protection - S117L (rh) */
    Ifx_UReg_32Bit S118L:1;           /**< \brief [22:22] PFLASH p Sector 118 Locked for Write Protection - S118L (rh) */
    Ifx_UReg_32Bit S119L:1;           /**< \brief [23:23] PFLASH p Sector 119 Locked for Write Protection - S119L (rh) */
    Ifx_UReg_32Bit S120L:1;           /**< \brief [24:24] PFLASH p Sector 120 Locked for Write Protection - S120L (rh) */
    Ifx_UReg_32Bit S121L:1;           /**< \brief [25:25] PFLASH p Sector 121 Locked for Write Protection - S121L (rh) */
    Ifx_UReg_32Bit S122L:1;           /**< \brief [26:26] PFLASH p Sector 122 Locked for Write Protection - S122L (rh) */
    Ifx_UReg_32Bit S123L:1;           /**< \brief [27:27] PFLASH p Sector 123 Locked for Write Protection - S123L (rh) */
    Ifx_UReg_32Bit S124L:1;           /**< \brief [28:28] PFLASH p Sector 124 Locked for Write Protection - S124L (rh) */
    Ifx_UReg_32Bit S125L:1;           /**< \brief [29:29] PFLASH p Sector 125 Locked for Write Protection - S125L (rh) */
    Ifx_UReg_32Bit S126L:1;           /**< \brief [30:30] PFLASH p Sector 126 Locked for Write Protection - S126L (rh) */
    Ifx_UReg_32Bit S127L:1;           /**< \brief [31:31] PFLASH p Sector 127 Locked for Write Protection - S127L (rh) */
} Ifx_DMU_HP_PROCON_P3_Bits;

/** \brief PFLASH Bank ${i} Protection Configuration 4 */
typedef struct _Ifx_DMU_HP_PROCON_P4_Bits
{
    Ifx_UReg_32Bit S128L:1;           /**< \brief [0:0] PFLASH p Sector 128 Locked for Write Protection - S128L (rh) */
    Ifx_UReg_32Bit S129L:1;           /**< \brief [1:1] PFLASH p Sector 129 Locked for Write Protection - S129L (rh) */
    Ifx_UReg_32Bit S130L:1;           /**< \brief [2:2] PFLASH p Sector 130 Locked for Write Protection - S130L (rh) */
    Ifx_UReg_32Bit S131L:1;           /**< \brief [3:3] PFLASH p Sector 131 Locked for Write Protection - S131L (rh) */
    Ifx_UReg_32Bit S132L:1;           /**< \brief [4:4] PFLASH p Sector 132 Locked for Write Protection - S132L (rh) */
    Ifx_UReg_32Bit S133L:1;           /**< \brief [5:5] PFLASH p Sector 133 Locked for Write Protection - S133L (rh) */
    Ifx_UReg_32Bit S134L:1;           /**< \brief [6:6] PFLASH p Sector 134 Locked for Write Protection - S134L (rh) */
    Ifx_UReg_32Bit S135L:1;           /**< \brief [7:7] PFLASH p Sector 135 Locked for Write Protection - S135L (rh) */
    Ifx_UReg_32Bit S136L:1;           /**< \brief [8:8] PFLASH p Sector 136 Locked for Write Protection - S136L (rh) */
    Ifx_UReg_32Bit S137L:1;           /**< \brief [9:9] PFLASH p Sector 137 Locked for Write Protection - S137L (rh) */
    Ifx_UReg_32Bit S138L:1;           /**< \brief [10:10] PFLASH p Sector 138 Locked for Write Protection - S138L (rh) */
    Ifx_UReg_32Bit S139L:1;           /**< \brief [11:11] PFLASH p Sector 139 Locked for Write Protection - S139L (rh) */
    Ifx_UReg_32Bit S140L:1;           /**< \brief [12:12] PFLASH p Sector 140 Locked for Write Protection - S140L (rh) */
    Ifx_UReg_32Bit S141L:1;           /**< \brief [13:13] PFLASH p Sector 141 Locked for Write Protection - S141L (rh) */
    Ifx_UReg_32Bit S142L:1;           /**< \brief [14:14] PFLASH p Sector 142 Locked for Write Protection - S142L (rh) */
    Ifx_UReg_32Bit S143L:1;           /**< \brief [15:15] PFLASH p Sector 143 Locked for Write Protection - S143L (rh) */
    Ifx_UReg_32Bit S144L:1;           /**< \brief [16:16] PFLASH p Sector 144 Locked for Write Protection - S144L (rh) */
    Ifx_UReg_32Bit S145L:1;           /**< \brief [17:17] PFLASH p Sector 145 Locked for Write Protection - S145L (rh) */
    Ifx_UReg_32Bit S146L:1;           /**< \brief [18:18] PFLASH p Sector 146 Locked for Write Protection - S146L (rh) */
    Ifx_UReg_32Bit S147L:1;           /**< \brief [19:19] PFLASH p Sector 147 Locked for Write Protection - S147L (rh) */
    Ifx_UReg_32Bit S148L:1;           /**< \brief [20:20] PFLASH p Sector 148 Locked for Write Protection - S148L (rh) */
    Ifx_UReg_32Bit S149L:1;           /**< \brief [21:21] PFLASH p Sector 149 Locked for Write Protection - S149L (rh) */
    Ifx_UReg_32Bit S150L:1;           /**< \brief [22:22] PFLASH p Sector 150 Locked for Write Protection - S150L (rh) */
    Ifx_UReg_32Bit S151L:1;           /**< \brief [23:23] PFLASH p Sector 151 Locked for Write Protection - S151L (rh) */
    Ifx_UReg_32Bit S152L:1;           /**< \brief [24:24] PFLASH p Sector 152 Locked for Write Protection - S152L (rh) */
    Ifx_UReg_32Bit S153L:1;           /**< \brief [25:25] PFLASH p Sector 153 Locked for Write Protection - S153L (rh) */
    Ifx_UReg_32Bit S154L:1;           /**< \brief [26:26] PFLASH p Sector 154 Locked for Write Protection - S154L (rh) */
    Ifx_UReg_32Bit S155L:1;           /**< \brief [27:27] PFLASH p Sector 155 Locked for Write Protection - S155L (rh) */
    Ifx_UReg_32Bit S156L:1;           /**< \brief [28:28] PFLASH p Sector 156 Locked for Write Protection - S156L (rh) */
    Ifx_UReg_32Bit S157L:1;           /**< \brief [29:29] PFLASH p Sector 157 Locked for Write Protection - S157L (rh) */
    Ifx_UReg_32Bit S158L:1;           /**< \brief [30:30] PFLASH p Sector 158 Locked for Write Protection - S158L (rh) */
    Ifx_UReg_32Bit S159L:1;           /**< \brief [31:31] PFLASH p Sector 159 Locked for Write Protection - S159L (rh) */
} Ifx_DMU_HP_PROCON_P4_Bits;

/** \brief PFLASH Bank ${i} Protection Configuration 5 */
typedef struct _Ifx_DMU_HP_PROCON_P5_Bits
{
    Ifx_UReg_32Bit S160L:1;           /**< \brief [0:0] PFLASH p Sector 160 Locked for Write Protection - S160L (rh) */
    Ifx_UReg_32Bit S161L:1;           /**< \brief [1:1] PFLASH p Sector 161 Locked for Write Protection - S161L (rh) */
    Ifx_UReg_32Bit S162L:1;           /**< \brief [2:2] PFLASH p Sector 162 Locked for Write Protection - S162L (rh) */
    Ifx_UReg_32Bit S163L:1;           /**< \brief [3:3] PFLASH p Sector 163 Locked for Write Protection - S163L (rh) */
    Ifx_UReg_32Bit S164L:1;           /**< \brief [4:4] PFLASH p Sector 164 Locked for Write Protection - S164L (rh) */
    Ifx_UReg_32Bit S165L:1;           /**< \brief [5:5] PFLASH p Sector 165 Locked for Write Protection - S165L (rh) */
    Ifx_UReg_32Bit S166L:1;           /**< \brief [6:6] PFLASH p Sector 166 Locked for Write Protection - S166L (rh) */
    Ifx_UReg_32Bit S167L:1;           /**< \brief [7:7] PFLASH p Sector 167 Locked for Write Protection - S167L (rh) */
    Ifx_UReg_32Bit S168L:1;           /**< \brief [8:8] PFLASH p Sector 168 Locked for Write Protection - S168L (rh) */
    Ifx_UReg_32Bit S169L:1;           /**< \brief [9:9] PFLASH p Sector 169 Locked for Write Protection - S169L (rh) */
    Ifx_UReg_32Bit S170L:1;           /**< \brief [10:10] PFLASH p Sector 170 Locked for Write Protection - S170L (rh) */
    Ifx_UReg_32Bit S171L:1;           /**< \brief [11:11] PFLASH p Sector 171 Locked for Write Protection - S171L (rh) */
    Ifx_UReg_32Bit S172L:1;           /**< \brief [12:12] PFLASH p Sector 172 Locked for Write Protection - S172L (rh) */
    Ifx_UReg_32Bit S173L:1;           /**< \brief [13:13] PFLASH p Sector 173 Locked for Write Protection - S173L (rh) */
    Ifx_UReg_32Bit S174L:1;           /**< \brief [14:14] PFLASH p Sector 174 Locked for Write Protection - S174L (rh) */
    Ifx_UReg_32Bit S175L:1;           /**< \brief [15:15] PFLASH p Sector 175 Locked for Write Protection - S175L (rh) */
    Ifx_UReg_32Bit S176L:1;           /**< \brief [16:16] PFLASH p Sector 176 Locked for Write Protection - S176L (rh) */
    Ifx_UReg_32Bit S177L:1;           /**< \brief [17:17] PFLASH p Sector 177 Locked for Write Protection - S177L (rh) */
    Ifx_UReg_32Bit S178L:1;           /**< \brief [18:18] PFLASH p Sector 178 Locked for Write Protection - S178L (rh) */
    Ifx_UReg_32Bit S179L:1;           /**< \brief [19:19] PFLASH p Sector 179 Locked for Write Protection - S179L (rh) */
    Ifx_UReg_32Bit S180L:1;           /**< \brief [20:20] PFLASH p Sector 180 Locked for Write Protection - S180L (rh) */
    Ifx_UReg_32Bit S181L:1;           /**< \brief [21:21] PFLASH p Sector 181 Locked for Write Protection - S181L (rh) */
    Ifx_UReg_32Bit S182L:1;           /**< \brief [22:22] PFLASH p Sector 182 Locked for Write Protection - S182L (rh) */
    Ifx_UReg_32Bit S183L:1;           /**< \brief [23:23] PFLASH p Sector 183 Locked for Write Protection - S183L (rh) */
    Ifx_UReg_32Bit S184L:1;           /**< \brief [24:24] PFLASH p Sector 184 Locked for Write Protection - S184L (rh) */
    Ifx_UReg_32Bit S185L:1;           /**< \brief [25:25] PFLASH p Sector 185 Locked for Write Protection - S185L (rh) */
    Ifx_UReg_32Bit S186L:1;           /**< \brief [26:26] PFLASH p Sector 186 Locked for Write Protection - S186L (rh) */
    Ifx_UReg_32Bit S187L:1;           /**< \brief [27:27] PFLASH p Sector 187 Locked for Write Protection - S187L (rh) */
    Ifx_UReg_32Bit S188L:1;           /**< \brief [28:28] PFLASH p Sector 188 Locked for Write Protection - S188L (rh) */
    Ifx_UReg_32Bit S189L:1;           /**< \brief [29:29] PFLASH p Sector 189 Locked for Write Protection - S189L (rh) */
    Ifx_UReg_32Bit S190L:1;           /**< \brief [30:30] PFLASH p Sector 190 Locked for Write Protection - S190L (rh) */
    Ifx_UReg_32Bit S191L:1;           /**< \brief [31:31] PFLASH p Sector 191 Locked for Write Protection - S191L (rh) */
} Ifx_DMU_HP_PROCON_P5_Bits;

/** \brief PFLASH Bank ${i} WOP Configuration 0 */
typedef struct _Ifx_DMU_HP_PROCON_WOP0_Bits
{
    Ifx_UReg_32Bit S0WOP:1;           /**< \brief [0:0] PFLASH p Sector 0 Configured for Write-Once Protection - S0WOP (rh) */
    Ifx_UReg_32Bit S1WOP:1;           /**< \brief [1:1] PFLASH p Sector 1 Configured for Write-Once Protection - S1WOP (rh) */
    Ifx_UReg_32Bit S2WOP:1;           /**< \brief [2:2] PFLASH p Sector 2 Configured for Write-Once Protection - S2WOP (rh) */
    Ifx_UReg_32Bit S3WOP:1;           /**< \brief [3:3] PFLASH p Sector 3 Configured for Write-Once Protection - S3WOP (rh) */
    Ifx_UReg_32Bit S4WOP:1;           /**< \brief [4:4] PFLASH p Sector 4 Configured for Write-Once Protection - S4WOP (rh) */
    Ifx_UReg_32Bit S5WOP:1;           /**< \brief [5:5] PFLASH p Sector 5 Configured for Write-Once Protection - S5WOP (rh) */
    Ifx_UReg_32Bit S6WOP:1;           /**< \brief [6:6] PFLASH p Sector 6 Configured for Write-Once Protection - S6WOP (rh) */
    Ifx_UReg_32Bit S7WOP:1;           /**< \brief [7:7] PFLASH p Sector 7 Configured for Write-Once Protection - S7WOP (rh) */
    Ifx_UReg_32Bit S8WOP:1;           /**< \brief [8:8] PFLASH p Sector 8 Configured for Write-Once Protection - S8WOP (rh) */
    Ifx_UReg_32Bit S9WOP:1;           /**< \brief [9:9] PFLASH p Sector 9 Configured for Write-Once Protection - S9WOP (rh) */
    Ifx_UReg_32Bit S10WOP:1;          /**< \brief [10:10] PFLASH p Sector 10 Configured for Write-Once Protection - S10WOP (rh) */
    Ifx_UReg_32Bit S11WOP:1;          /**< \brief [11:11] PFLASH p Sector 11 Configured for Write-Once Protection - S11WOP (rh) */
    Ifx_UReg_32Bit S12WOP:1;          /**< \brief [12:12] PFLASH p Sector 12 Configured for Write-Once Protection - S12WOP (rh) */
    Ifx_UReg_32Bit S13WOP:1;          /**< \brief [13:13] PFLASH p Sector 13 Configured for Write-Once Protection - S13WOP (rh) */
    Ifx_UReg_32Bit S14WOP:1;          /**< \brief [14:14] PFLASH p Sector 14 Configured for Write-Once Protection - S14WOP (rh) */
    Ifx_UReg_32Bit S15WOP:1;          /**< \brief [15:15] PFLASH p Sector 15 Configured for Write-Once Protection - S15WOP (rh) */
    Ifx_UReg_32Bit S16WOP:1;          /**< \brief [16:16] PFLASH p Sector 16 Configured for Write-Once Protection - S16WOP (rh) */
    Ifx_UReg_32Bit S17WOP:1;          /**< \brief [17:17] PFLASH p Sector 17 Configured for Write-Once Protection - S17WOP (rh) */
    Ifx_UReg_32Bit S18WOP:1;          /**< \brief [18:18] PFLASH p Sector 18 Configured for Write-Once Protection - S18WOP (rh) */
    Ifx_UReg_32Bit S19WOP:1;          /**< \brief [19:19] PFLASH p Sector 19 Configured for Write-Once Protection - S19WOP (rh) */
    Ifx_UReg_32Bit S20WOP:1;          /**< \brief [20:20] PFLASH p Sector 20 Configured for Write-Once Protection - S20WOP (rh) */
    Ifx_UReg_32Bit S21WOP:1;          /**< \brief [21:21] PFLASH p Sector 21 Configured for Write-Once Protection - S21WOP (rh) */
    Ifx_UReg_32Bit S22WOP:1;          /**< \brief [22:22] PFLASH p Sector 22 Configured for Write-Once Protection - S22WOP (rh) */
    Ifx_UReg_32Bit S23WOP:1;          /**< \brief [23:23] PFLASH p Sector 23 Configured for Write-Once Protection - S23WOP (rh) */
    Ifx_UReg_32Bit S24WOP:1;          /**< \brief [24:24] PFLASH p Sector 24 Configured for Write-Once Protection - S24WOP (rh) */
    Ifx_UReg_32Bit S25WOP:1;          /**< \brief [25:25] PFLASH p Sector 25 Configured for Write-Once Protection - S25WOP (rh) */
    Ifx_UReg_32Bit S26WOP:1;          /**< \brief [26:26] PFLASH p Sector 26 Configured for Write-Once Protection - S26WOP (rh) */
    Ifx_UReg_32Bit S27WOP:1;          /**< \brief [27:27] PFLASH p Sector 27 Configured for Write-Once Protection - S27WOP (rh) */
    Ifx_UReg_32Bit S28WOP:1;          /**< \brief [28:28] PFLASH p Sector 28 Configured for Write-Once Protection - S28WOP (rh) */
    Ifx_UReg_32Bit S29WOP:1;          /**< \brief [29:29] PFLASH p Sector 29 Configured for Write-Once Protection - S29WOP (rh) */
    Ifx_UReg_32Bit S30WOP:1;          /**< \brief [30:30] PFLASH p Sector 30 Configured for Write-Once Protection - S30WOP (rh) */
    Ifx_UReg_32Bit S31WOP:1;          /**< \brief [31:31] PFLASH p Sector 31 Configured for Write-Once Protection - S31WOP (rh) */
} Ifx_DMU_HP_PROCON_WOP0_Bits;

/** \brief PFLASH Bank ${i} WOP Configuration 1 */
typedef struct _Ifx_DMU_HP_PROCON_WOP1_Bits
{
    Ifx_UReg_32Bit S32WOP:1;          /**< \brief [0:0] PFLASH p Sector 32 Configured for Write-Once Protection - S32WOP (rh) */
    Ifx_UReg_32Bit S33WOP:1;          /**< \brief [1:1] PFLASH p Sector 33 Configured for Write-Once Protection - S33WOP (rh) */
    Ifx_UReg_32Bit S34WOP:1;          /**< \brief [2:2] PFLASH p Sector 34 Configured for Write-Once Protection - S34WOP (rh) */
    Ifx_UReg_32Bit S35WOP:1;          /**< \brief [3:3] PFLASH p Sector 35 Configured for Write-Once Protection - S35WOP (rh) */
    Ifx_UReg_32Bit S36WOP:1;          /**< \brief [4:4] PFLASH p Sector 36 Configured for Write-Once Protection - S36WOP (rh) */
    Ifx_UReg_32Bit S37WOP:1;          /**< \brief [5:5] PFLASH p Sector 37 Configured for Write-Once Protection - S37WOP (rh) */
    Ifx_UReg_32Bit S38WOP:1;          /**< \brief [6:6] PFLASH p Sector 38 Configured for Write-Once Protection - S38WOP (rh) */
    Ifx_UReg_32Bit S39WOP:1;          /**< \brief [7:7] PFLASH p Sector 39 Configured for Write-Once Protection - S39WOP (rh) */
    Ifx_UReg_32Bit S40WOP:1;          /**< \brief [8:8] PFLASH p Sector 40 Configured for Write-Once Protection - S40WOP (rh) */
    Ifx_UReg_32Bit S41WOP:1;          /**< \brief [9:9] PFLASH p Sector 41 Configured for Write-Once Protection - S41WOP (rh) */
    Ifx_UReg_32Bit S42WOP:1;          /**< \brief [10:10] PFLASH p Sector 42 Configured for Write-Once Protection - S42WOP (rh) */
    Ifx_UReg_32Bit S43WOP:1;          /**< \brief [11:11] PFLASH p Sector 43 Configured for Write-Once Protection - S43WOP (rh) */
    Ifx_UReg_32Bit S44WOP:1;          /**< \brief [12:12] PFLASH p Sector 44 Configured for Write-Once Protection - S44WOP (rh) */
    Ifx_UReg_32Bit S45WOP:1;          /**< \brief [13:13] PFLASH p Sector 45 Configured for Write-Once Protection - S45WOP (rh) */
    Ifx_UReg_32Bit S46WOP:1;          /**< \brief [14:14] PFLASH p Sector 46 Configured for Write-Once Protection - S46WOP (rh) */
    Ifx_UReg_32Bit S47WOP:1;          /**< \brief [15:15] PFLASH p Sector 47 Configured for Write-Once Protection - S47WOP (rh) */
    Ifx_UReg_32Bit S48WOP:1;          /**< \brief [16:16] PFLASH p Sector 48 Configured for Write-Once Protection - S48WOP (rh) */
    Ifx_UReg_32Bit S49WOP:1;          /**< \brief [17:17] PFLASH p Sector 49 Configured for Write-Once Protection - S49WOP (rh) */
    Ifx_UReg_32Bit S50WOP:1;          /**< \brief [18:18] PFLASH p Sector 50 Configured for Write-Once Protection - S50WOP (rh) */
    Ifx_UReg_32Bit S51WOP:1;          /**< \brief [19:19] PFLASH p Sector 51 Configured for Write-Once Protection - S51WOP (rh) */
    Ifx_UReg_32Bit S52WOP:1;          /**< \brief [20:20] PFLASH p Sector 52 Configured for Write-Once Protection - S52WOP (rh) */
    Ifx_UReg_32Bit S53WOP:1;          /**< \brief [21:21] PFLASH p Sector 53 Configured for Write-Once Protection - S53WOP (rh) */
    Ifx_UReg_32Bit S54WOP:1;          /**< \brief [22:22] PFLASH p Sector 54 Configured for Write-Once Protection - S54WOP (rh) */
    Ifx_UReg_32Bit S55WOP:1;          /**< \brief [23:23] PFLASH p Sector 55 Configured for Write-Once Protection - S55WOP (rh) */
    Ifx_UReg_32Bit S56WOP:1;          /**< \brief [24:24] PFLASH p Sector 56 Configured for Write-Once Protection - S56WOP (rh) */
    Ifx_UReg_32Bit S57WOP:1;          /**< \brief [25:25] PFLASH p Sector 57 Configured for Write-Once Protection - S57WOP (rh) */
    Ifx_UReg_32Bit S58WOP:1;          /**< \brief [26:26] PFLASH p Sector 58 Configured for Write-Once Protection - S58WOP (rh) */
    Ifx_UReg_32Bit S59WOP:1;          /**< \brief [27:27] PFLASH p Sector 59 Configured for Write-Once Protection - S59WOP (rh) */
    Ifx_UReg_32Bit S60WOP:1;          /**< \brief [28:28] PFLASH p Sector 60 Configured for Write-Once Protection - S60WOP (rh) */
    Ifx_UReg_32Bit S61WOP:1;          /**< \brief [29:29] PFLASH p Sector 61 Configured for Write-Once Protection - S61WOP (rh) */
    Ifx_UReg_32Bit S62WOP:1;          /**< \brief [30:30] PFLASH p Sector 62 Configured for Write-Once Protection - S62WOP (rh) */
    Ifx_UReg_32Bit S63WOP:1;          /**< \brief [31:31] PFLASH p Sector 63 Configured for Write-Once Protection - S63WOP (rh) */
} Ifx_DMU_HP_PROCON_WOP1_Bits;

/** \brief PFLASH Bank ${i} WOP Configuration 2 */
typedef struct _Ifx_DMU_HP_PROCON_WOP2_Bits
{
    Ifx_UReg_32Bit S64WOP:1;          /**< \brief [0:0] PFLASH p Sector 64 Configured for Write-Once Protection - S64WOP (rh) */
    Ifx_UReg_32Bit S65WOP:1;          /**< \brief [1:1] PFLASH p Sector 65 Configured for Write-Once Protection - S65WOP (rh) */
    Ifx_UReg_32Bit S66WOP:1;          /**< \brief [2:2] PFLASH p Sector 66 Configured for Write-Once Protection - S66WOP (rh) */
    Ifx_UReg_32Bit S67WOP:1;          /**< \brief [3:3] PFLASH p Sector 67 Configured for Write-Once Protection - S67WOP (rh) */
    Ifx_UReg_32Bit S68WOP:1;          /**< \brief [4:4] PFLASH p Sector 68 Configured for Write-Once Protection - S68WOP (rh) */
    Ifx_UReg_32Bit S69WOP:1;          /**< \brief [5:5] PFLASH p Sector 69 Configured for Write-Once Protection - S69WOP (rh) */
    Ifx_UReg_32Bit S70WOP:1;          /**< \brief [6:6] PFLASH p Sector 70 Configured for Write-Once Protection - S70WOP (rh) */
    Ifx_UReg_32Bit S71WOP:1;          /**< \brief [7:7] PFLASH p Sector 71 Configured for Write-Once Protection - S71WOP (rh) */
    Ifx_UReg_32Bit S72WOP:1;          /**< \brief [8:8] PFLASH p Sector 72 Configured for Write-Once Protection - S72WOP (rh) */
    Ifx_UReg_32Bit S73WOP:1;          /**< \brief [9:9] PFLASH p Sector 73 Configured for Write-Once Protection - S73WOP (rh) */
    Ifx_UReg_32Bit S74WOP:1;          /**< \brief [10:10] PFLASH p Sector 74 Configured for Write-Once Protection - S74WOP (rh) */
    Ifx_UReg_32Bit S75WOP:1;          /**< \brief [11:11] PFLASH p Sector 75 Configured for Write-Once Protection - S75WOP (rh) */
    Ifx_UReg_32Bit S76WOP:1;          /**< \brief [12:12] PFLASH p Sector 76 Configured for Write-Once Protection - S76WOP (rh) */
    Ifx_UReg_32Bit S77WOP:1;          /**< \brief [13:13] PFLASH p Sector 77 Configured for Write-Once Protection - S77WOP (rh) */
    Ifx_UReg_32Bit S78WOP:1;          /**< \brief [14:14] PFLASH p Sector 78 Configured for Write-Once Protection - S78WOP (rh) */
    Ifx_UReg_32Bit S79WOP:1;          /**< \brief [15:15] PFLASH p Sector 79 Configured for Write-Once Protection - S79WOP (rh) */
    Ifx_UReg_32Bit S80WOP:1;          /**< \brief [16:16] PFLASH p Sector 80 Configured for Write-Once Protection - S80WOP (rh) */
    Ifx_UReg_32Bit S81WOP:1;          /**< \brief [17:17] PFLASH p Sector 81 Configured for Write-Once Protection - S81WOP (rh) */
    Ifx_UReg_32Bit S82WOP:1;          /**< \brief [18:18] PFLASH p Sector 82 Configured for Write-Once Protection - S82WOP (rh) */
    Ifx_UReg_32Bit S83WOP:1;          /**< \brief [19:19] PFLASH p Sector 83 Configured for Write-Once Protection - S83WOP (rh) */
    Ifx_UReg_32Bit S84WOP:1;          /**< \brief [20:20] PFLASH p Sector 84 Configured for Write-Once Protection - S84WOP (rh) */
    Ifx_UReg_32Bit S85WOP:1;          /**< \brief [21:21] PFLASH p Sector 85 Configured for Write-Once Protection - S85WOP (rh) */
    Ifx_UReg_32Bit S86WOP:1;          /**< \brief [22:22] PFLASH p Sector 86 Configured for Write-Once Protection - S86WOP (rh) */
    Ifx_UReg_32Bit S87WOP:1;          /**< \brief [23:23] PFLASH p Sector 87 Configured for Write-Once Protection - S87WOP (rh) */
    Ifx_UReg_32Bit S88WOP:1;          /**< \brief [24:24] PFLASH p Sector 88 Configured for Write-Once Protection - S88WOP (rh) */
    Ifx_UReg_32Bit S89WOP:1;          /**< \brief [25:25] PFLASH p Sector 89 Configured for Write-Once Protection - S89WOP (rh) */
    Ifx_UReg_32Bit S90WOP:1;          /**< \brief [26:26] PFLASH p Sector 90 Configured for Write-Once Protection - S90WOP (rh) */
    Ifx_UReg_32Bit S91WOP:1;          /**< \brief [27:27] PFLASH p Sector 91 Configured for Write-Once Protection - S91WOP (rh) */
    Ifx_UReg_32Bit S92WOP:1;          /**< \brief [28:28] PFLASH p Sector 92 Configured for Write-Once Protection - S92WOP (rh) */
    Ifx_UReg_32Bit S93WOP:1;          /**< \brief [29:29] PFLASH p Sector 93 Configured for Write-Once Protection - S93WOP (rh) */
    Ifx_UReg_32Bit S94WOP:1;          /**< \brief [30:30] PFLASH p Sector 94 Configured for Write-Once Protection - S94WOP (rh) */
    Ifx_UReg_32Bit S95WOP:1;          /**< \brief [31:31] PFLASH p Sector 95 Configured for Write-Once Protection - S95WOP (rh) */
} Ifx_DMU_HP_PROCON_WOP2_Bits;

/** \brief PFLASH Bank ${i} WOP Configuration 3 */
typedef struct _Ifx_DMU_HP_PROCON_WOP3_Bits
{
    Ifx_UReg_32Bit S96WOP:1;          /**< \brief [0:0] PFLASH p Sector 96 Configured for Write-Once Protection - S96WOP (rh) */
    Ifx_UReg_32Bit S97WOP:1;          /**< \brief [1:1] PFLASH p Sector 97 Configured for Write-Once Protection - S97WOP (rh) */
    Ifx_UReg_32Bit S98WOP:1;          /**< \brief [2:2] PFLASH p Sector 98 Configured for Write-Once Protection - S98WOP (rh) */
    Ifx_UReg_32Bit S99WOP:1;          /**< \brief [3:3] PFLASH p Sector 99 Configured for Write-Once Protection - S99WOP (rh) */
    Ifx_UReg_32Bit S100WOP:1;         /**< \brief [4:4] PFLASH p Sector 100 Configured for Write-Once Protection - S100WOP (rh) */
    Ifx_UReg_32Bit S101WOP:1;         /**< \brief [5:5] PFLASH p Sector 101 Configured for Write-Once Protection - S101WOP (rh) */
    Ifx_UReg_32Bit S102WOP:1;         /**< \brief [6:6] PFLASH p Sector 102 Configured for Write-Once Protection - S102WOP (rh) */
    Ifx_UReg_32Bit S103WOP:1;         /**< \brief [7:7] PFLASH p Sector 103 Configured for Write-Once Protection - S103WOP (rh) */
    Ifx_UReg_32Bit S104WOP:1;         /**< \brief [8:8] PFLASH p Sector 104 Configured for Write-Once Protection - S104WOP (rh) */
    Ifx_UReg_32Bit S105WOP:1;         /**< \brief [9:9] PFLASH p Sector 105 Configured for Write-Once Protection - S105WOP (rh) */
    Ifx_UReg_32Bit S106WOP:1;         /**< \brief [10:10] PFLASH p Sector 106 Configured for Write-Once Protection - S106WOP (rh) */
    Ifx_UReg_32Bit S107WOP:1;         /**< \brief [11:11] PFLASH p Sector 107 Configured for Write-Once Protection - S107WOP (rh) */
    Ifx_UReg_32Bit S108WOP:1;         /**< \brief [12:12] PFLASH p Sector 108 Configured for Write-Once Protection - S108WOP (rh) */
    Ifx_UReg_32Bit S109WOP:1;         /**< \brief [13:13] PFLASH p Sector 109 Configured for Write-Once Protection - S109WOP (rh) */
    Ifx_UReg_32Bit S110WOP:1;         /**< \brief [14:14] PFLASH p Sector 110 Configured for Write-Once Protection - S110WOP (rh) */
    Ifx_UReg_32Bit S111WOP:1;         /**< \brief [15:15] PFLASH p Sector 111 Configured for Write-Once Protection - S111WOP (rh) */
    Ifx_UReg_32Bit S112WOP:1;         /**< \brief [16:16] PFLASH p Sector 112 Configured for Write-Once Protection - S112WOP (rh) */
    Ifx_UReg_32Bit S113WOP:1;         /**< \brief [17:17] PFLASH p Sector 113 Configured for Write-Once Protection - S113WOP (rh) */
    Ifx_UReg_32Bit S114WOP:1;         /**< \brief [18:18] PFLASH p Sector 114 Configured for Write-Once Protection - S114WOP (rh) */
    Ifx_UReg_32Bit S115WOP:1;         /**< \brief [19:19] PFLASH p Sector 115 Configured for Write-Once Protection - S115WOP (rh) */
    Ifx_UReg_32Bit S116WOP:1;         /**< \brief [20:20] PFLASH p Sector 116 Configured for Write-Once Protection - S116WOP (rh) */
    Ifx_UReg_32Bit S117WOP:1;         /**< \brief [21:21] PFLASH p Sector 117 Configured for Write-Once Protection - S117WOP (rh) */
    Ifx_UReg_32Bit S118WOP:1;         /**< \brief [22:22] PFLASH p Sector 118 Configured for Write-Once Protection - S118WOP (rh) */
    Ifx_UReg_32Bit S119WOP:1;         /**< \brief [23:23] PFLASH p Sector 119 Configured for Write-Once Protection - S119WOP (rh) */
    Ifx_UReg_32Bit S120WOP:1;         /**< \brief [24:24] PFLASH p Sector 120 Configured for Write-Once Protection - S120WOP (rh) */
    Ifx_UReg_32Bit S121WOP:1;         /**< \brief [25:25] PFLASH p Sector 121 Configured for Write-Once Protection - S121WOP (rh) */
    Ifx_UReg_32Bit S122WOP:1;         /**< \brief [26:26] PFLASH p Sector 122 Configured for Write-Once Protection - S122WOP (rh) */
    Ifx_UReg_32Bit S123WOP:1;         /**< \brief [27:27] PFLASH p Sector 123 Configured for Write-Once Protection - S123WOP (rh) */
    Ifx_UReg_32Bit S124WOP:1;         /**< \brief [28:28] PFLASH p Sector 124 Configured for Write-Once Protection - S124WOP (rh) */
    Ifx_UReg_32Bit S125WOP:1;         /**< \brief [29:29] PFLASH p Sector 125 Configured for Write-Once Protection - S125WOP (rh) */
    Ifx_UReg_32Bit S126WOP:1;         /**< \brief [30:30] PFLASH p Sector 126 Configured for Write-Once Protection - S126WOP (rh) */
    Ifx_UReg_32Bit S127WOP:1;         /**< \brief [31:31] PFLASH p Sector 127 Configured for Write-Once Protection - S127WOP (rh) */
} Ifx_DMU_HP_PROCON_WOP3_Bits;

/** \brief PFLASH Bank ${i} WOP Configuration 4 */
typedef struct _Ifx_DMU_HP_PROCON_WOP4_Bits
{
    Ifx_UReg_32Bit S128WOP:1;         /**< \brief [0:0] PFLASH p Sector 128 Configured for Write-Once Protection - S128WOP (rh) */
    Ifx_UReg_32Bit S129WOP:1;         /**< \brief [1:1] PFLASH p Sector 129 Configured for Write-Once Protection - S129WOP (rh) */
    Ifx_UReg_32Bit S130WOP:1;         /**< \brief [2:2] PFLASH p Sector 130 Configured for Write-Once Protection - S130WOP (rh) */
    Ifx_UReg_32Bit S131WOP:1;         /**< \brief [3:3] PFLASH p Sector 131 Configured for Write-Once Protection - S131WOP (rh) */
    Ifx_UReg_32Bit S132WOP:1;         /**< \brief [4:4] PFLASH p Sector 132 Configured for Write-Once Protection - S132WOP (rh) */
    Ifx_UReg_32Bit S133WOP:1;         /**< \brief [5:5] PFLASH p Sector 133 Configured for Write-Once Protection - S133WOP (rh) */
    Ifx_UReg_32Bit S134WOP:1;         /**< \brief [6:6] PFLASH p Sector 134 Configured for Write-Once Protection - S134WOP (rh) */
    Ifx_UReg_32Bit S135WOP:1;         /**< \brief [7:7] PFLASH p Sector 135 Configured for Write-Once Protection - S135WOP (rh) */
    Ifx_UReg_32Bit S136WOP:1;         /**< \brief [8:8] PFLASH p Sector 136 Configured for Write-Once Protection - S136WOP (rh) */
    Ifx_UReg_32Bit S137WOP:1;         /**< \brief [9:9] PFLASH p Sector 137 Configured for Write-Once Protection - S137WOP (rh) */
    Ifx_UReg_32Bit S138WOP:1;         /**< \brief [10:10] PFLASH p Sector 138 Configured for Write-Once Protection - S138WOP (rh) */
    Ifx_UReg_32Bit S139WOP:1;         /**< \brief [11:11] PFLASH p Sector 139 Configured for Write-Once Protection - S139WOP (rh) */
    Ifx_UReg_32Bit S140WOP:1;         /**< \brief [12:12] PFLASH p Sector 140 Configured for Write-Once Protection - S140WOP (rh) */
    Ifx_UReg_32Bit S141WOP:1;         /**< \brief [13:13] PFLASH p Sector 141 Configured for Write-Once Protection - S141WOP (rh) */
    Ifx_UReg_32Bit S142WOP:1;         /**< \brief [14:14] PFLASH p Sector 142 Configured for Write-Once Protection - S142WOP (rh) */
    Ifx_UReg_32Bit S143WOP:1;         /**< \brief [15:15] PFLASH p Sector 143 Configured for Write-Once Protection - S143WOP (rh) */
    Ifx_UReg_32Bit S144WOP:1;         /**< \brief [16:16] PFLASH p Sector 144 Configured for Write-Once Protection - S144WOP (rh) */
    Ifx_UReg_32Bit S145WOP:1;         /**< \brief [17:17] PFLASH p Sector 145 Configured for Write-Once Protection - S145WOP (rh) */
    Ifx_UReg_32Bit S146WOP:1;         /**< \brief [18:18] PFLASH p Sector 146 Configured for Write-Once Protection - S146WOP (rh) */
    Ifx_UReg_32Bit S147WOP:1;         /**< \brief [19:19] PFLASH p Sector 147 Configured for Write-Once Protection - S147WOP (rh) */
    Ifx_UReg_32Bit S148WOP:1;         /**< \brief [20:20] PFLASH p Sector 148 Configured for Write-Once Protection - S148WOP (rh) */
    Ifx_UReg_32Bit S149WOP:1;         /**< \brief [21:21] PFLASH p Sector 149 Configured for Write-Once Protection - S149WOP (rh) */
    Ifx_UReg_32Bit S150WOP:1;         /**< \brief [22:22] PFLASH p Sector 150 Configured for Write-Once Protection - S150WOP (rh) */
    Ifx_UReg_32Bit S151WOP:1;         /**< \brief [23:23] PFLASH p Sector 151 Configured for Write-Once Protection - S151WOP (rh) */
    Ifx_UReg_32Bit S152WOP:1;         /**< \brief [24:24] PFLASH p Sector 152 Configured for Write-Once Protection - S152WOP (rh) */
    Ifx_UReg_32Bit S153WOP:1;         /**< \brief [25:25] PFLASH p Sector 153 Configured for Write-Once Protection - S153WOP (rh) */
    Ifx_UReg_32Bit S154WOP:1;         /**< \brief [26:26] PFLASH p Sector 154 Configured for Write-Once Protection - S154WOP (rh) */
    Ifx_UReg_32Bit S155WOP:1;         /**< \brief [27:27] PFLASH p Sector 155 Configured for Write-Once Protection - S155WOP (rh) */
    Ifx_UReg_32Bit S156WOP:1;         /**< \brief [28:28] PFLASH p Sector 156 Configured for Write-Once Protection - S156WOP (rh) */
    Ifx_UReg_32Bit S157WOP:1;         /**< \brief [29:29] PFLASH p Sector 157 Configured for Write-Once Protection - S157WOP (rh) */
    Ifx_UReg_32Bit S158WOP:1;         /**< \brief [30:30] PFLASH p Sector 158 Configured for Write-Once Protection - S158WOP (rh) */
    Ifx_UReg_32Bit S159WOP:1;         /**< \brief [31:31] PFLASH p Sector 159 Configured for Write-Once Protection - S159WOP (rh) */
} Ifx_DMU_HP_PROCON_WOP4_Bits;

/** \brief PFLASH Bank ${i} WOP Configuration 5 */
typedef struct _Ifx_DMU_HP_PROCON_WOP5_Bits
{
    Ifx_UReg_32Bit S160WOP:1;         /**< \brief [0:0] PFLASH p Sector 160 Configured for Write-Once Protection - S160WOP (rh) */
    Ifx_UReg_32Bit S161WOP:1;         /**< \brief [1:1] PFLASH p Sector 161 Configured for Write-Once Protection - S161WOP (rh) */
    Ifx_UReg_32Bit S162WOP:1;         /**< \brief [2:2] PFLASH p Sector 162 Configured for Write-Once Protection - S162WOP (rh) */
    Ifx_UReg_32Bit S163WOP:1;         /**< \brief [3:3] PFLASH p Sector 163 Configured for Write-Once Protection - S163WOP (rh) */
    Ifx_UReg_32Bit S164WOP:1;         /**< \brief [4:4] PFLASH p Sector 164 Configured for Write-Once Protection - S164WOP (rh) */
    Ifx_UReg_32Bit S165WOP:1;         /**< \brief [5:5] PFLASH p Sector 165 Configured for Write-Once Protection - S165WOP (rh) */
    Ifx_UReg_32Bit S166WOP:1;         /**< \brief [6:6] PFLASH p Sector 166 Configured for Write-Once Protection - S166WOP (rh) */
    Ifx_UReg_32Bit S167WOP:1;         /**< \brief [7:7] PFLASH p Sector 167 Configured for Write-Once Protection - S167WOP (rh) */
    Ifx_UReg_32Bit S168WOP:1;         /**< \brief [8:8] PFLASH p Sector 168 Configured for Write-Once Protection - S168WOP (rh) */
    Ifx_UReg_32Bit S169WOP:1;         /**< \brief [9:9] PFLASH p Sector 169 Configured for Write-Once Protection - S169WOP (rh) */
    Ifx_UReg_32Bit S170WOP:1;         /**< \brief [10:10] PFLASH p Sector 170 Configured for Write-Once Protection - S170WOP (rh) */
    Ifx_UReg_32Bit S171WOP:1;         /**< \brief [11:11] PFLASH p Sector 171 Configured for Write-Once Protection - S171WOP (rh) */
    Ifx_UReg_32Bit S172WOP:1;         /**< \brief [12:12] PFLASH p Sector 172 Configured for Write-Once Protection - S172WOP (rh) */
    Ifx_UReg_32Bit S173WOP:1;         /**< \brief [13:13] PFLASH p Sector 173 Configured for Write-Once Protection - S173WOP (rh) */
    Ifx_UReg_32Bit S174WOP:1;         /**< \brief [14:14] PFLASH p Sector 174 Configured for Write-Once Protection - S174WOP (rh) */
    Ifx_UReg_32Bit S175WOP:1;         /**< \brief [15:15] PFLASH p Sector 175 Configured for Write-Once Protection - S175WOP (rh) */
    Ifx_UReg_32Bit S176WOP:1;         /**< \brief [16:16] PFLASH p Sector 176 Configured for Write-Once Protection - S176WOP (rh) */
    Ifx_UReg_32Bit S177WOP:1;         /**< \brief [17:17] PFLASH p Sector 177 Configured for Write-Once Protection - S177WOP (rh) */
    Ifx_UReg_32Bit S178WOP:1;         /**< \brief [18:18] PFLASH p Sector 178 Configured for Write-Once Protection - S178WOP (rh) */
    Ifx_UReg_32Bit S179WOP:1;         /**< \brief [19:19] PFLASH p Sector 179 Configured for Write-Once Protection - S179WOP (rh) */
    Ifx_UReg_32Bit S180WOP:1;         /**< \brief [20:20] PFLASH p Sector 180 Configured for Write-Once Protection - S180WOP (rh) */
    Ifx_UReg_32Bit S181WOP:1;         /**< \brief [21:21] PFLASH p Sector 181 Configured for Write-Once Protection - S181WOP (rh) */
    Ifx_UReg_32Bit S182WOP:1;         /**< \brief [22:22] PFLASH p Sector 182 Configured for Write-Once Protection - S182WOP (rh) */
    Ifx_UReg_32Bit S183WOP:1;         /**< \brief [23:23] PFLASH p Sector 183 Configured for Write-Once Protection - S183WOP (rh) */
    Ifx_UReg_32Bit S184WOP:1;         /**< \brief [24:24] PFLASH p Sector 184 Configured for Write-Once Protection - S184WOP (rh) */
    Ifx_UReg_32Bit S185WOP:1;         /**< \brief [25:25] PFLASH p Sector 185 Configured for Write-Once Protection - S185WOP (rh) */
    Ifx_UReg_32Bit S186WOP:1;         /**< \brief [26:26] PFLASH p Sector 186 Configured for Write-Once Protection - S186WOP (rh) */
    Ifx_UReg_32Bit S187WOP:1;         /**< \brief [27:27] PFLASH p Sector 187 Configured for Write-Once Protection - S187WOP (rh) */
    Ifx_UReg_32Bit S188WOP:1;         /**< \brief [28:28] PFLASH p Sector 188 Configured for Write-Once Protection - S188WOP (rh) */
    Ifx_UReg_32Bit S189WOP:1;         /**< \brief [29:29] PFLASH p Sector 189 Configured for Write-Once Protection - S189WOP (rh) */
    Ifx_UReg_32Bit S190WOP:1;         /**< \brief [30:30] PFLASH p Sector 190 Configured for Write-Once Protection - S190WOP (rh) */
    Ifx_UReg_32Bit S191WOP:1;         /**< \brief [31:31] PFLASH p Sector 191 Configured for Write-Once Protection - S191WOP (rh) */
} Ifx_DMU_HP_PROCON_WOP5_Bits;

/** \brief HSM Clear Error Register */
typedef struct _Ifx_DMU_SF_CLRE_Bits
{
    Ifx_UReg_32Bit reserved_0:1;      /**< \brief [0:0] \internal Reserved */
    Ifx_UReg_32Bit CSQER:1;           /**< \brief [1:1] Clear Command Sequence Error - CSQER (w) */
    Ifx_UReg_32Bit reserved_2:1;      /**< \brief [2:2] \internal Reserved */
    Ifx_UReg_32Bit CPVER:1;           /**< \brief [3:3] Clear Program Verify Error - CPVER (w) */
    Ifx_UReg_32Bit CEVER:1;           /**< \brief [4:4] Clear Erase Verify Error - CEVER (w) */
    Ifx_UReg_32Bit reserved_5:27;     /**< \brief [31:5] \internal Reserved */
} Ifx_DMU_SF_CLRE_Bits;

/** \brief HSM Flash Configuration Register */
typedef struct _Ifx_DMU_SF_CONTROL_Bits
{
    Ifx_UReg_32Bit LCKHSMUCB:2;       /**< \brief [1:0] Lock Access to UCB_HSMCFG - LCKHSMUCB (rwh) */
    Ifx_UReg_32Bit reserved_2:1;      /**< \brief [2:2] \internal Reserved */
    Ifx_UReg_32Bit reserved_3:1;      /**< \brief [3:3] \internal Reserved */
    Ifx_UReg_32Bit reserved_4:12;     /**< \brief [15:4] \internal Reserved */
    Ifx_UReg_32Bit CPROG:1;           /**< \brief [16:16] Clear Programming State - CPROG (w) */
    Ifx_UReg_32Bit CERASE:1;          /**< \brief [17:17] Clear Erase State - CERASE (w) */
    Ifx_UReg_32Bit reserved_18:1;     /**< \brief [18:18] \internal Reserved */
    Ifx_UReg_32Bit reserved_19:13;    /**< \brief [31:19] \internal Reserved */
} Ifx_DMU_SF_CONTROL_Bits;

/** \brief HSM DF1 ECC Control Register */
typedef struct _Ifx_DMU_SF_ECCC_Bits
{
    Ifx_UReg_32Bit CLR:2;             /**< \brief [1:0] Clear ECC status bits - CLR (w) */
    Ifx_UReg_32Bit reserved_2:26;     /**< \brief [27:2] \internal Reserved */
    Ifx_UReg_32Bit ECCCORDIS:2;       /**< \brief [29:28] HSM Command Interface ECC Correction Disable - ECCCORDIS (rw) */
    Ifx_UReg_32Bit TRAPDIS:2;         /**< \brief [31:30] HSM Command Interface Uncorrectable ECC Bit Error Trap Disable - TRAPDIS (rw) */
} Ifx_DMU_SF_ECCC_Bits;

/** \brief HSM DF1 ECC Read Register */
typedef struct _Ifx_DMU_SF_ECCR_Bits
{
    Ifx_UReg_32Bit RCODE:22;          /**< \brief [21:0] Error Correction Read Code - RCODE (rh) */
    Ifx_UReg_32Bit reserved_22:2;     /**< \brief [23:22] \internal Reserved */
    Ifx_UReg_32Bit reserved_24:8;     /**< \brief [31:24] \internal Reserved */
} Ifx_DMU_SF_ECCR_Bits;

/** \brief HSM DF1 ECC Status Register */
typedef struct _Ifx_DMU_SF_ECCS_Bits
{
    Ifx_UReg_32Bit ERR1:1;            /**< \brief [0:0] Read Access Single Bit ECC Error - ERR1 (rh) */
    Ifx_UReg_32Bit ERR2:1;            /**< \brief [1:1] Read Access Double Bit ECC Error - ERR2 (rh) */
    Ifx_UReg_32Bit ERR3:1;            /**< \brief [2:2] Read Access Triple Bit ECC Error - ERR3 (rh) */
    Ifx_UReg_32Bit ERRM:1;            /**< \brief [3:3] Read Access Multi-bit ECC Error - ERRM (rh) */
    Ifx_UReg_32Bit reserved_4:3;      /**< \brief [6:4] \internal Reserved */
    Ifx_UReg_32Bit ERRANY:1;          /**< \brief [7:7] Any Read Access ECC Error - ERRANY (rh) */
    Ifx_UReg_32Bit reserved_8:1;      /**< \brief [8:8] \internal Reserved */
    Ifx_UReg_32Bit BLANKA:1;          /**< \brief [9:9] Read Access Blank Analog - BLANKA (rh) */
    Ifx_UReg_32Bit reserved_10:6;     /**< \brief [15:10] \internal Reserved */
    Ifx_UReg_32Bit AER1:1;            /**< \brief [16:16] Accumulated Single Bit ECC Errors - AER1 (rh) */
    Ifx_UReg_32Bit AER2:1;            /**< \brief [17:17] Accumulated Double Bit ECC Errors - AER2 (rh) */
    Ifx_UReg_32Bit AER3:1;            /**< \brief [18:18] Accumulated Triple Bit ECC Errors - AER3 (rh) */
    Ifx_UReg_32Bit AERM:1;            /**< \brief [19:19] Accumulated Multi-bit ECC Errors - AERM (rh) */
    Ifx_UReg_32Bit reserved_20:3;     /**< \brief [22:20] \internal Reserved */
    Ifx_UReg_32Bit AERANY:1;          /**< \brief [23:23] Accumulated Any Read Access ECC Error - AERANY (rh) */
    Ifx_UReg_32Bit reserved_24:1;     /**< \brief [24:24] \internal Reserved */
    Ifx_UReg_32Bit ABLANKA:1;         /**< \brief [25:25] Accumulated Blank Analog - ABLANKA (rh) */
    Ifx_UReg_32Bit reserved_26:6;     /**< \brief [31:26] \internal Reserved */
} Ifx_DMU_SF_ECCS_Bits;

/** \brief HSM DF1 ECC Write Register */
typedef struct _Ifx_DMU_SF_ECCW_Bits
{
    Ifx_UReg_32Bit WCODE:22;          /**< \brief [21:0] Error Correction Write Code - WCODE (rw) */
    Ifx_UReg_32Bit reserved_22:8;     /**< \brief [29:22] \internal Reserved */
    Ifx_UReg_32Bit ECCENCDIS:2;       /**< \brief [31:30] ECC Encoding Disable - ECCENCDIS (rw) */
} Ifx_DMU_SF_ECCW_Bits;

/** \brief HSM Enable Error Interrupt Control Register */
typedef struct _Ifx_DMU_SF_EER_Bits
{
    Ifx_UReg_32Bit OPERM:1;           /**< \brief [0:0] Operation Error Interrupt Mask - OPERM (rw) */
    Ifx_UReg_32Bit SQERM:1;           /**< \brief [1:1] Command Sequence Error Interrupt Mask - SQERM (rw) */
    Ifx_UReg_32Bit reserved_2:1;      /**< \brief [2:2] \internal Reserved */
    Ifx_UReg_32Bit PVERM:1;           /**< \brief [3:3] Program Verify Error Interrupt Mask - PVERM (rw) */
    Ifx_UReg_32Bit EVERM:1;           /**< \brief [4:4] Erase Verify Error Interrupt Mask - EVERM (rw) */
    Ifx_UReg_32Bit reserved_5:26;     /**< \brief [30:5] \internal Reserved */
    Ifx_UReg_32Bit EOBM:1;            /**< \brief [31:31] End of Busy Interrupt Mask - EOBM (rw) */
} Ifx_DMU_SF_EER_Bits;

/** \brief HSM Error Status Register */
typedef struct _Ifx_DMU_SF_ERRSR_Bits
{
    Ifx_UReg_32Bit OPER:1;            /**< \brief [0:0] Flash Operation Error - OPER (rh) */
    Ifx_UReg_32Bit SQER:1;            /**< \brief [1:1] Command Sequence Error - SQER (rh) */
    Ifx_UReg_32Bit reserved_2:1;      /**< \brief [2:2] \internal Reserved */
    Ifx_UReg_32Bit PVER:1;            /**< \brief [3:3] Program Verify Error - PVER (rh) */
    Ifx_UReg_32Bit EVER:1;            /**< \brief [4:4] Erase Verify Error - EVER (rh) */
    Ifx_UReg_32Bit reserved_5:27;     /**< \brief [31:5] \internal Reserved */
} Ifx_DMU_SF_ERRSR_Bits;

/** \brief HSM DF1 Margin Control Register */
typedef struct _Ifx_DMU_SF_MARGIN_Bits
{
    Ifx_UReg_32Bit SELD1:2;           /**< \brief [1:0] DF1 Margin Read Selection - SELD1 (rw) */
    Ifx_UReg_32Bit reserved_2:6;      /**< \brief [7:2] \internal Reserved */
    Ifx_UReg_32Bit HMARGIN:1;         /**< \brief [8:8] Hard Margin Selection - HMARGIN (rw) */
    Ifx_UReg_32Bit reserved_9:23;     /**< \brief [31:9] \internal Reserved */
} Ifx_DMU_SF_MARGIN_Bits;

/** \brief HSM Flash Operation Register */
typedef struct _Ifx_DMU_SF_OPERATION_Bits
{
    Ifx_UReg_32Bit PROG:1;            /**< \brief [0:0] Programming State - PROG (rh) */
    Ifx_UReg_32Bit ERASE:1;           /**< \brief [1:1] Erase State - ERASE (rh) */
    Ifx_UReg_32Bit reserved_2:1;      /**< \brief [2:2] \internal Reserved */
    Ifx_UReg_32Bit reserved_3:29;     /**< \brief [31:3] \internal Reserved */
} Ifx_DMU_SF_OPERATION_Bits;

/** \brief HSM DF1 User Mode Control */
typedef struct _Ifx_DMU_SF_PROCONUSR_Bits
{
    Ifx_UReg_32Bit MODE:2;            /**< \brief [1:0] DF1 User Mode Control - MODE (rh) */
    Ifx_UReg_32Bit reserved_2:30;     /**< \brief [31:2] \internal Reserved */
} Ifx_DMU_SF_PROCONUSR_Bits;

/** \brief HSM Flash Status Register */
typedef struct _Ifx_DMU_SF_STATUS_Bits
{
    Ifx_UReg_32Bit reserved_0:1;      /**< \brief [0:0] \internal Reserved */
    Ifx_UReg_32Bit D1BUSY:1;          /**< \brief [1:1] Data Flash Bank 1 Busy - D1BUSY (rh) */
    Ifx_UReg_32Bit reserved_2:18;     /**< \brief [19:2] \internal Reserved */
    Ifx_UReg_32Bit DFPAGE:1;          /**< \brief [20:20] Data Flash in Page Mode - DFPAGE (rh) */
    Ifx_UReg_32Bit reserved_21:11;    /**< \brief [31:21] \internal Reserved */
} Ifx_DMU_SF_STATUS_Bits;

/** \brief HSM Suspend Control Register */
typedef struct _Ifx_DMU_SF_SUSPEND_Bits
{
    Ifx_UReg_32Bit REQ:1;             /**< \brief [0:0] Suspend Request - REQ (rwh) */
    Ifx_UReg_32Bit CLR:1;             /**< \brief [1:1] Suspend Clear - CLR (w) */
    Ifx_UReg_32Bit reserved_2:14;     /**< \brief [15:2] \internal Reserved */
    Ifx_UReg_32Bit SPND:1;            /**< \brief [16:16] Flash Operation Suspended - SPND (rh) */
    Ifx_UReg_32Bit ERR:1;             /**< \brief [17:17] Suspend Error - ERR (rh) */
    Ifx_UReg_32Bit reserved_18:14;    /**< \brief [31:18] \internal Reserved */
} Ifx_DMU_SF_SUSPEND_Bits;

/** \brief HSM Interface Protection Configuration */
typedef struct _Ifx_DMU_SP_PROCONHSM_Bits
{
    Ifx_UReg_32Bit HSMDBGDIS:1;       /**< \brief [0:0] HSM Debug Disable - HSMDBGDIS (rh) */
    Ifx_UReg_32Bit DBGIFLCK:1;        /**< \brief [1:1] Debug Interface Locked - DBGIFLCK (rh) */
    Ifx_UReg_32Bit TSTIFLCK:1;        /**< \brief [2:2] Test Interface Locked - TSTIFLCK (rh) */
    Ifx_UReg_32Bit HSMTSTDIS:1;       /**< \brief [3:3] HSM Test Disable - HSMTSTDIS (rh) */
    Ifx_UReg_32Bit HSMTRDIS:2;        /**< \brief [5:4] HSM Trace Disable - HSMTRDIS (rh) */
    Ifx_UReg_32Bit HSMTRTYPE:1;       /**< \brief [6:6] HSM Type of Trace - HSMTRTYPE (rh) */
    Ifx_UReg_32Bit reserved_7:9;      /**< \brief [15:7] \internal Reserved */
    Ifx_UReg_32Bit reserved_16:16;    /**< \brief [31:16] \internal Reserved */
} Ifx_DMU_SP_PROCONHSM_Bits;

/** \brief HSM Code Boot Sector */
typedef struct _Ifx_DMU_SP_PROCONHSMCBS_Bits
{
    Ifx_UReg_32Bit BOOTSEL0:6;        /**< \brief [5:0] Boot Sector Selection - BOOTSEL0 (rh) */
    Ifx_UReg_32Bit reserved_6:2;      /**< \brief [7:6] \internal Reserved */
    Ifx_UReg_32Bit BOOTSEL1:6;        /**< \brief [13:8] Boot Sector Selection - BOOTSEL1 (rh) */
    Ifx_UReg_32Bit reserved_14:2;     /**< \brief [15:14] \internal Reserved */
    Ifx_UReg_32Bit BOOTSEL2:6;        /**< \brief [21:16] Boot Sector Selection - BOOTSEL2 (rh) */
    Ifx_UReg_32Bit reserved_22:2;     /**< \brief [23:22] \internal Reserved */
    Ifx_UReg_32Bit BOOTSEL3:6;        /**< \brief [29:24] Boot Sector Selection - BOOTSEL3 (rh) */
    Ifx_UReg_32Bit reserved_30:2;     /**< \brief [31:30] \internal Reserved */
} Ifx_DMU_SP_PROCONHSMCBS_Bits;

/** \brief HSM Protection Configuration */
typedef struct _Ifx_DMU_SP_PROCONHSMCFG_Bits
{
    Ifx_UReg_32Bit HSMBOOTEN:1;       /**< \brief [0:0] HSM Boot Enable - HSMBOOTEN (rh) */
    Ifx_UReg_32Bit SSWWAIT:1;         /**< \brief [1:1] SSW Wait - SSWWAIT (rh) */
    Ifx_UReg_32Bit HSMDX:1;           /**< \brief [2:2] HSM Data Sectors Exclusive - HSMDX (rh) */
    Ifx_UReg_32Bit reserved_3:1;      /**< \brief [3:3] \internal Reserved */
    Ifx_UReg_32Bit HSMRAMKEEP:2;      /**< \brief [5:4] HSM RAM Clear - HSMRAMKEEP (rh) */
    Ifx_UReg_32Bit reserved_6:1;      /**< \brief [6:6] \internal Reserved */
    Ifx_UReg_32Bit HSMENPINS:2;       /**< \brief [8:7] Enable HSM Forcing of Pins HSM1/2 - HSMENPINS (rh) */
    Ifx_UReg_32Bit HSMENRES:2;        /**< \brief [10:9] Enable HSM Triggering Resets - HSMENRES (rh) */
    Ifx_UReg_32Bit DESTDBG:2;         /**< \brief [12:11] Destructive Debug Entry - DESTDBG (rh) */
    Ifx_UReg_32Bit BLKFLAN:1;         /**< \brief [13:13] Block Flash Analysis - BLKFLAN (rh) */
    Ifx_UReg_32Bit reserved_14:2;     /**< \brief [15:14] \internal Reserved */
    Ifx_UReg_32Bit reserved_16:16;    /**< \brief [31:16] \internal Reserved */
} Ifx_DMU_SP_PROCONHSMCFG_Bits;

/** \brief HSM Code OTP Protection Configuration */
typedef struct _Ifx_DMU_SP_PROCONHSMCOTP0_Bits
{
    Ifx_UReg_32Bit HSM0ROM:1;         /**< \brief [0:0] PFLASH Sector 0 HSM Code Locked Forever - HSM0ROM (rh) */
    Ifx_UReg_32Bit HSM1ROM:1;         /**< \brief [1:1] PFLASH Sector 1 HSM Code Locked Forever - HSM1ROM (rh) */
    Ifx_UReg_32Bit HSM2ROM:1;         /**< \brief [2:2] PFLASH Sector 2 HSM Code Locked Forever - HSM2ROM (rh) */
    Ifx_UReg_32Bit HSM3ROM:1;         /**< \brief [3:3] PFLASH Sector 3 HSM Code Locked Forever - HSM3ROM (rh) */
    Ifx_UReg_32Bit HSM4ROM:1;         /**< \brief [4:4] PFLASH Sector 4 HSM Code Locked Forever - HSM4ROM (rh) */
    Ifx_UReg_32Bit HSM5ROM:1;         /**< \brief [5:5] PFLASH Sector 5 HSM Code Locked Forever - HSM5ROM (rh) */
    Ifx_UReg_32Bit HSM6ROM:1;         /**< \brief [6:6] PFLASH Sector 6 HSM Code Locked Forever - HSM6ROM (rh) */
    Ifx_UReg_32Bit HSM7ROM:1;         /**< \brief [7:7] PFLASH Sector 7 HSM Code Locked Forever - HSM7ROM (rh) */
    Ifx_UReg_32Bit HSM8ROM:1;         /**< \brief [8:8] PFLASH Sector 8 HSM Code Locked Forever - HSM8ROM (rh) */
    Ifx_UReg_32Bit HSM9ROM:1;         /**< \brief [9:9] PFLASH Sector 9 HSM Code Locked Forever - HSM9ROM (rh) */
    Ifx_UReg_32Bit HSM10ROM:1;        /**< \brief [10:10] PFLASH Sector 10 HSM Code Locked Forever - HSM10ROM (rh) */
    Ifx_UReg_32Bit HSM11ROM:1;        /**< \brief [11:11] PFLASH Sector 11 HSM Code Locked Forever - HSM11ROM (rh) */
    Ifx_UReg_32Bit HSM12ROM:1;        /**< \brief [12:12] PFLASH Sector 12 HSM Code Locked Forever - HSM12ROM (rh) */
    Ifx_UReg_32Bit HSM13ROM:1;        /**< \brief [13:13] PFLASH Sector 13 HSM Code Locked Forever - HSM13ROM (rh) */
    Ifx_UReg_32Bit HSM14ROM:1;        /**< \brief [14:14] PFLASH Sector 14 HSM Code Locked Forever - HSM14ROM (rh) */
    Ifx_UReg_32Bit HSM15ROM:1;        /**< \brief [15:15] PFLASH Sector 15 HSM Code Locked Forever - HSM15ROM (rh) */
    Ifx_UReg_32Bit HSM16ROM:1;        /**< \brief [16:16] PFLASH Sector 16 HSM Code Locked Forever - HSM16ROM (rh) */
    Ifx_UReg_32Bit HSM17ROM:1;        /**< \brief [17:17] PFLASH Sector 17 HSM Code Locked Forever - HSM17ROM (rh) */
    Ifx_UReg_32Bit HSM18ROM:1;        /**< \brief [18:18] PFLASH Sector 18 HSM Code Locked Forever - HSM18ROM (rh) */
    Ifx_UReg_32Bit HSM19ROM:1;        /**< \brief [19:19] PFLASH Sector 19 HSM Code Locked Forever - HSM19ROM (rh) */
    Ifx_UReg_32Bit HSM20ROM:1;        /**< \brief [20:20] PFLASH Sector 20 HSM Code Locked Forever - HSM20ROM (rh) */
    Ifx_UReg_32Bit HSM21ROM:1;        /**< \brief [21:21] PFLASH Sector 21 HSM Code Locked Forever - HSM21ROM (rh) */
    Ifx_UReg_32Bit HSM22ROM:1;        /**< \brief [22:22] PFLASH Sector 22 HSM Code Locked Forever - HSM22ROM (rh) */
    Ifx_UReg_32Bit HSM23ROM:1;        /**< \brief [23:23] PFLASH Sector 23 HSM Code Locked Forever - HSM23ROM (rh) */
    Ifx_UReg_32Bit HSM24ROM:1;        /**< \brief [24:24] PFLASH Sector 24 HSM Code Locked Forever - HSM24ROM (rh) */
    Ifx_UReg_32Bit HSM25ROM:1;        /**< \brief [25:25] PFLASH Sector 25 HSM Code Locked Forever - HSM25ROM (rh) */
    Ifx_UReg_32Bit HSM26ROM:1;        /**< \brief [26:26] PFLASH Sector 26 HSM Code Locked Forever - HSM26ROM (rh) */
    Ifx_UReg_32Bit HSM27ROM:1;        /**< \brief [27:27] PFLASH Sector 27 HSM Code Locked Forever - HSM27ROM (rh) */
    Ifx_UReg_32Bit HSM28ROM:1;        /**< \brief [28:28] PFLASH Sector 28 HSM Code Locked Forever - HSM28ROM (rh) */
    Ifx_UReg_32Bit HSM29ROM:1;        /**< \brief [29:29] PFLASH Sector 29 HSM Code Locked Forever - HSM29ROM (rh) */
    Ifx_UReg_32Bit HSM30ROM:1;        /**< \brief [30:30] PFLASH Sector 30 HSM Code Locked Forever - HSM30ROM (rh) */
    Ifx_UReg_32Bit HSM31ROM:1;        /**< \brief [31:31] PFLASH Sector 31 HSM Code Locked Forever - HSM31ROM (rh) */
} Ifx_DMU_SP_PROCONHSMCOTP0_Bits;

/** \brief HSM Code OTP Protection Configuration */
typedef struct _Ifx_DMU_SP_PROCONHSMCOTP1_Bits
{
    Ifx_UReg_32Bit HSM32ROM:1;        /**< \brief [0:0] PFLASH Sector 32 HSM Code Locked Forever - HSM32ROM (rh) */
    Ifx_UReg_32Bit HSM33ROM:1;        /**< \brief [1:1] PFLASH Sector 33 HSM Code Locked Forever - HSM33ROM (rh) */
    Ifx_UReg_32Bit HSM34ROM:1;        /**< \brief [2:2] PFLASH Sector 34 HSM Code Locked Forever - HSM34ROM (rh) */
    Ifx_UReg_32Bit HSM35ROM:1;        /**< \brief [3:3] PFLASH Sector 35 HSM Code Locked Forever - HSM35ROM (rh) */
    Ifx_UReg_32Bit HSM36ROM:1;        /**< \brief [4:4] PFLASH Sector 36 HSM Code Locked Forever - HSM36ROM (rh) */
    Ifx_UReg_32Bit HSM37ROM:1;        /**< \brief [5:5] PFLASH Sector 37 HSM Code Locked Forever - HSM37ROM (rh) */
    Ifx_UReg_32Bit HSM38ROM:1;        /**< \brief [6:6] PFLASH Sector 38 HSM Code Locked Forever - HSM38ROM (rh) */
    Ifx_UReg_32Bit HSM39ROM:1;        /**< \brief [7:7] PFLASH Sector 39 HSM Code Locked Forever - HSM39ROM (rh) */
    Ifx_UReg_32Bit reserved_8:24;     /**< \brief [31:8] \internal Reserved */
} Ifx_DMU_SP_PROCONHSMCOTP1_Bits;

/** \brief HSM Code Exclusive Protection Configuration */
typedef struct _Ifx_DMU_SP_PROCONHSMCX0_Bits
{
    Ifx_UReg_32Bit HSM0X:1;           /**< \brief [0:0] PFLASH Sector 0 HSM Code Exclusive - HSM0X (rh) */
    Ifx_UReg_32Bit HSM1X:1;           /**< \brief [1:1] PFLASH Sector 1 HSM Code Exclusive - HSM1X (rh) */
    Ifx_UReg_32Bit HSM2X:1;           /**< \brief [2:2] PFLASH Sector 2 HSM Code Exclusive - HSM2X (rh) */
    Ifx_UReg_32Bit HSM3X:1;           /**< \brief [3:3] PFLASH Sector 3 HSM Code Exclusive - HSM3X (rh) */
    Ifx_UReg_32Bit HSM4X:1;           /**< \brief [4:4] PFLASH Sector 4 HSM Code Exclusive - HSM4X (rh) */
    Ifx_UReg_32Bit HSM5X:1;           /**< \brief [5:5] PFLASH Sector 5 HSM Code Exclusive - HSM5X (rh) */
    Ifx_UReg_32Bit HSM6X:1;           /**< \brief [6:6] PFLASH Sector 6 HSM Code Exclusive - HSM6X (rh) */
    Ifx_UReg_32Bit HSM7X:1;           /**< \brief [7:7] PFLASH Sector 7 HSM Code Exclusive - HSM7X (rh) */
    Ifx_UReg_32Bit HSM8X:1;           /**< \brief [8:8] PFLASH Sector 8 HSM Code Exclusive - HSM8X (rh) */
    Ifx_UReg_32Bit HSM9X:1;           /**< \brief [9:9] PFLASH Sector 9 HSM Code Exclusive - HSM9X (rh) */
    Ifx_UReg_32Bit HSM10X:1;          /**< \brief [10:10] PFLASH Sector 10 HSM Code Exclusive - HSM10X (rh) */
    Ifx_UReg_32Bit HSM11X:1;          /**< \brief [11:11] PFLASH Sector 11 HSM Code Exclusive - HSM11X (rh) */
    Ifx_UReg_32Bit HSM12X:1;          /**< \brief [12:12] PFLASH Sector 12 HSM Code Exclusive - HSM12X (rh) */
    Ifx_UReg_32Bit HSM13X:1;          /**< \brief [13:13] PFLASH Sector 13 HSM Code Exclusive - HSM13X (rh) */
    Ifx_UReg_32Bit HSM14X:1;          /**< \brief [14:14] PFLASH Sector 14 HSM Code Exclusive - HSM14X (rh) */
    Ifx_UReg_32Bit HSM15X:1;          /**< \brief [15:15] PFLASH Sector 15 HSM Code Exclusive - HSM15X (rh) */
    Ifx_UReg_32Bit HSM16X:1;          /**< \brief [16:16] PFLASH Sector 16 HSM Code Exclusive - HSM16X (rh) */
    Ifx_UReg_32Bit HSM17X:1;          /**< \brief [17:17] PFLASH Sector 17 HSM Code Exclusive - HSM17X (rh) */
    Ifx_UReg_32Bit HSM18X:1;          /**< \brief [18:18] PFLASH Sector 18 HSM Code Exclusive - HSM18X (rh) */
    Ifx_UReg_32Bit HSM19X:1;          /**< \brief [19:19] PFLASH Sector 19 HSM Code Exclusive - HSM19X (rh) */
    Ifx_UReg_32Bit HSM20X:1;          /**< \brief [20:20] PFLASH Sector 20 HSM Code Exclusive - HSM20X (rh) */
    Ifx_UReg_32Bit HSM21X:1;          /**< \brief [21:21] PFLASH Sector 21 HSM Code Exclusive - HSM21X (rh) */
    Ifx_UReg_32Bit HSM22X:1;          /**< \brief [22:22] PFLASH Sector 22 HSM Code Exclusive - HSM22X (rh) */
    Ifx_UReg_32Bit HSM23X:1;          /**< \brief [23:23] PFLASH Sector 23 HSM Code Exclusive - HSM23X (rh) */
    Ifx_UReg_32Bit HSM24X:1;          /**< \brief [24:24] PFLASH Sector 24 HSM Code Exclusive - HSM24X (rh) */
    Ifx_UReg_32Bit HSM25X:1;          /**< \brief [25:25] PFLASH Sector 25 HSM Code Exclusive - HSM25X (rh) */
    Ifx_UReg_32Bit HSM26X:1;          /**< \brief [26:26] PFLASH Sector 26 HSM Code Exclusive - HSM26X (rh) */
    Ifx_UReg_32Bit HSM27X:1;          /**< \brief [27:27] PFLASH Sector 27 HSM Code Exclusive - HSM27X (rh) */
    Ifx_UReg_32Bit HSM28X:1;          /**< \brief [28:28] PFLASH Sector 28 HSM Code Exclusive - HSM28X (rh) */
    Ifx_UReg_32Bit HSM29X:1;          /**< \brief [29:29] PFLASH Sector 29 HSM Code Exclusive - HSM29X (rh) */
    Ifx_UReg_32Bit HSM30X:1;          /**< \brief [30:30] PFLASH Sector 30 HSM Code Exclusive - HSM30X (rh) */
    Ifx_UReg_32Bit HSM31X:1;          /**< \brief [31:31] PFLASH Sector 31 HSM Code Exclusive - HSM31X (rh) */
} Ifx_DMU_SP_PROCONHSMCX0_Bits;

/** \brief HSM Code Exclusive Protection Configuration */
typedef struct _Ifx_DMU_SP_PROCONHSMCX1_Bits
{
    Ifx_UReg_32Bit HSM32X:1;          /**< \brief [0:0] PFLASH Sector 32 HSM Code Exclusive - HSM32X (rh) */
    Ifx_UReg_32Bit HSM33X:1;          /**< \brief [1:1] PFLASH Sector 33 HSM Code Exclusive - HSM33X (rh) */
    Ifx_UReg_32Bit HSM34X:1;          /**< \brief [2:2] PFLASH Sector 34 HSM Code Exclusive - HSM34X (rh) */
    Ifx_UReg_32Bit HSM35X:1;          /**< \brief [3:3] PFLASH Sector 35 HSM Code Exclusive - HSM35X (rh) */
    Ifx_UReg_32Bit HSM36X:1;          /**< \brief [4:4] PFLASH Sector 36 HSM Code Exclusive - HSM36X (rh) */
    Ifx_UReg_32Bit HSM37X:1;          /**< \brief [5:5] PFLASH Sector 37 HSM Code Exclusive - HSM37X (rh) */
    Ifx_UReg_32Bit HSM38X:1;          /**< \brief [6:6] PFLASH Sector 38 HSM Code Exclusive - HSM38X (rh) */
    Ifx_UReg_32Bit HSM39X:1;          /**< \brief [7:7] PFLASH Sector 39 HSM Code Exclusive - HSM39X (rh) */
    Ifx_UReg_32Bit reserved_8:24;     /**< \brief [31:8] \internal Reserved */
} Ifx_DMU_SP_PROCONHSMCX1_Bits;

/** \}  */
/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_dmu_Registers_union
 * \{   */
/** \brief Access Enable Register 0   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_HF_ACCEN0_Bits B;         /**< \brief Bitfield access */
} Ifx_DMU_HF_ACCEN0;

/** \brief Access Enable Register 1   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_HF_ACCEN1_Bits B;         /**< \brief Bitfield access */
} Ifx_DMU_HF_ACCEN1;

/** \brief Cranking Control Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_HF_CCONTROL_Bits B;       /**< \brief Bitfield access */
} Ifx_DMU_HF_CCONTROL;

/** \brief Clear Error Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_HF_CLRE_Bits B;           /**< \brief Bitfield access */
} Ifx_DMU_HF_CLRE;

/** \brief Flash Confirm Status Register 0   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_HF_CONFIRM0_Bits B;       /**< \brief Bitfield access */
} Ifx_DMU_HF_CONFIRM0;

/** \brief Flash Confirm Status Register 1   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_HF_CONFIRM1_Bits B;       /**< \brief Bitfield access */
} Ifx_DMU_HF_CONFIRM1;

/** \brief Flash Confirm Status Register 2   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_HF_CONFIRM2_Bits B;       /**< \brief Bitfield access */
} Ifx_DMU_HF_CONFIRM2;

/** \brief Flash Control Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_HF_CONTROL_Bits B;        /**< \brief Bitfield access */
} Ifx_DMU_HF_CONTROL;

/** \brief DFLASH Wait Cycle Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_HF_DWAIT_Bits B;          /**< \brief Bitfield access */
} Ifx_DMU_HF_DWAIT;

/** \brief DF0 ECC Control Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_HF_ECCC_Bits B;           /**< \brief Bitfield access */
} Ifx_DMU_HF_ECCC;

/** \brief DF0 ECC Read Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_HF_ECCR_Bits B;           /**< \brief Bitfield access */
} Ifx_DMU_HF_ECCR;

/** \brief DF0 ECC Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_HF_ECCS_Bits B;           /**< \brief Bitfield access */
} Ifx_DMU_HF_ECCS;

/** \brief DF0 ECC Write Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_HF_ECCW_Bits B;           /**< \brief Bitfield access */
} Ifx_DMU_HF_ECCW;

/** \brief Enable Error Interrupt Control Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_HF_EER_Bits B;            /**< \brief Bitfield access */
} Ifx_DMU_HF_EER;

/** \brief Error Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_HF_ERRSR_Bits B;          /**< \brief Bitfield access */
} Ifx_DMU_HF_ERRSR;

/** \brief Module Identification Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_HF_ID_Bits B;             /**< \brief Bitfield access */
} Ifx_DMU_HF_ID;

/** \brief Margin Control Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_HF_MARGIN_Bits B;         /**< \brief Bitfield access */
} Ifx_DMU_HF_MARGIN;

/** \brief Flash Operation Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_HF_OPERATION_Bits B;      /**< \brief Bitfield access */
} Ifx_DMU_HF_OPERATION;

/** \brief Power Control Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_HF_PCONTROL_Bits B;       /**< \brief Bitfield access */
} Ifx_DMU_HF_PCONTROL;

/** \brief Debug Interface Protection Configuration   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_HF_PROCONDBG_Bits B;      /**< \brief Bitfield access */
} Ifx_DMU_HF_PROCONDBG;

/** \brief DFLASH Protection Configuration   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_HF_PROCONDF_Bits B;       /**< \brief Bitfield access */
} Ifx_DMU_HF_PROCONDF;

/** \brief PFLASH Protection Configuration   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_HF_PROCONPF_Bits B;       /**< \brief Bitfield access */
} Ifx_DMU_HF_PROCONPF;

/** \brief RAM Configuration   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_HF_PROCONRAM_Bits B;      /**< \brief Bitfield access */
} Ifx_DMU_HF_PROCONRAM;

/** \brief Tuning Protection Configuration   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_HF_PROCONTP_Bits B;       /**< \brief Bitfield access */
} Ifx_DMU_HF_PROCONTP;

/** \brief DF0 User Mode Control   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_HF_PROCONUSR_Bits B;      /**< \brief Bitfield access */
} Ifx_DMU_HF_PROCONUSR;

/** \brief Flash Protection Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_HF_PROTECT_Bits B;        /**< \brief Bitfield access */
} Ifx_DMU_HF_PROTECT;

/** \brief Power Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_HF_PSTATUS_Bits B;        /**< \brief Bitfield access */
} Ifx_DMU_HF_PSTATUS;

/** \brief PFLASH Wait Cycle Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_HF_PWAIT_Bits B;          /**< \brief Bitfield access */
} Ifx_DMU_HF_PWAIT;

/** \brief Flash Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_HF_STATUS_Bits B;         /**< \brief Bitfield access */
} Ifx_DMU_HF_STATUS;

/** \brief Suspend Control Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_HF_SUSPEND_Bits B;        /**< \brief Bitfield access */
} Ifx_DMU_HF_SUSPEND;

/** \brief PFLASH Bank ${i} Erase Counter Priority configuration 0   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_HP_ECPRIO_P0_Bits B;      /**< \brief Bitfield access */
} Ifx_DMU_HP_ECPRIO_P0;

/** \brief PFLASH Bank ${i} Erase Counter Priority Configuration 1   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_HP_ECPRIO_P1_Bits B;      /**< \brief Bitfield access */
} Ifx_DMU_HP_ECPRIO_P1;

/** \brief PFLASH Bank ${i} Erase Counter Priority Configuration 2   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_HP_ECPRIO_P2_Bits B;      /**< \brief Bitfield access */
} Ifx_DMU_HP_ECPRIO_P2;

/** \brief PFLASH Bank ${i} Erase Counter Priority Configuration 3   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_HP_ECPRIO_P3_Bits B;      /**< \brief Bitfield access */
} Ifx_DMU_HP_ECPRIO_P3;

/** \brief PFLASH Bank ${i} Erase Counter Priority Configuration 4   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_HP_ECPRIO_P4_Bits B;      /**< \brief Bitfield access */
} Ifx_DMU_HP_ECPRIO_P4;

/** \brief PFLASH Bank ${i} Erase Counter Priority Configuration 5   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_HP_ECPRIO_P5_Bits B;      /**< \brief Bitfield access */
} Ifx_DMU_HP_ECPRIO_P5;

/** \brief PFLASH Bank ${i} OTP Protection Configuration 0   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_HP_PROCON_OTP0_Bits B;    /**< \brief Bitfield access */
} Ifx_DMU_HP_PROCON_OTP0;

/** \brief PFLASH Bank ${i} OTP Protection Configuration 1   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_HP_PROCON_OTP1_Bits B;    /**< \brief Bitfield access */
} Ifx_DMU_HP_PROCON_OTP1;

/** \brief PFLASH Bank ${i} OTP Protection Configuration 2   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_HP_PROCON_OTP2_Bits B;    /**< \brief Bitfield access */
} Ifx_DMU_HP_PROCON_OTP2;

/** \brief PFLASH Bank ${i} OTP Protection Configuration 3   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_HP_PROCON_OTP3_Bits B;    /**< \brief Bitfield access */
} Ifx_DMU_HP_PROCON_OTP3;

/** \brief PFLASH Bank ${i} OTP Protection Configuration 4   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_HP_PROCON_OTP4_Bits B;    /**< \brief Bitfield access */
} Ifx_DMU_HP_PROCON_OTP4;

/** \brief PFLASH Bank ${i} OTP Protection Configuration 5   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_HP_PROCON_OTP5_Bits B;    /**< \brief Bitfield access */
} Ifx_DMU_HP_PROCON_OTP5;

/** \brief PFLASH Bank ${i} Protection Configuration 0   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_HP_PROCON_P0_Bits B;      /**< \brief Bitfield access */
} Ifx_DMU_HP_PROCON_P0;

/** \brief PFLASH Bank ${i} Protection Configuration 1   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_HP_PROCON_P1_Bits B;      /**< \brief Bitfield access */
} Ifx_DMU_HP_PROCON_P1;

/** \brief PFLASH Bank ${i} Protection Configuration 2   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_HP_PROCON_P2_Bits B;      /**< \brief Bitfield access */
} Ifx_DMU_HP_PROCON_P2;

/** \brief PFLASH Bank ${i} Protection Configuration 3   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_HP_PROCON_P3_Bits B;      /**< \brief Bitfield access */
} Ifx_DMU_HP_PROCON_P3;

/** \brief PFLASH Bank ${i} Protection Configuration 4   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_HP_PROCON_P4_Bits B;      /**< \brief Bitfield access */
} Ifx_DMU_HP_PROCON_P4;

/** \brief PFLASH Bank ${i} Protection Configuration 5   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_HP_PROCON_P5_Bits B;      /**< \brief Bitfield access */
} Ifx_DMU_HP_PROCON_P5;

/** \brief PFLASH Bank ${i} WOP Configuration 0   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_HP_PROCON_WOP0_Bits B;    /**< \brief Bitfield access */
} Ifx_DMU_HP_PROCON_WOP0;

/** \brief PFLASH Bank ${i} WOP Configuration 1   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_HP_PROCON_WOP1_Bits B;    /**< \brief Bitfield access */
} Ifx_DMU_HP_PROCON_WOP1;

/** \brief PFLASH Bank ${i} WOP Configuration 2   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_HP_PROCON_WOP2_Bits B;    /**< \brief Bitfield access */
} Ifx_DMU_HP_PROCON_WOP2;

/** \brief PFLASH Bank ${i} WOP Configuration 3   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_HP_PROCON_WOP3_Bits B;    /**< \brief Bitfield access */
} Ifx_DMU_HP_PROCON_WOP3;

/** \brief PFLASH Bank ${i} WOP Configuration 4   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_HP_PROCON_WOP4_Bits B;    /**< \brief Bitfield access */
} Ifx_DMU_HP_PROCON_WOP4;

/** \brief PFLASH Bank ${i} WOP Configuration 5   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_HP_PROCON_WOP5_Bits B;    /**< \brief Bitfield access */
} Ifx_DMU_HP_PROCON_WOP5;

/** \brief HSM Clear Error Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_SF_CLRE_Bits B;           /**< \brief Bitfield access */
} Ifx_DMU_SF_CLRE;

/** \brief HSM Flash Configuration Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_SF_CONTROL_Bits B;        /**< \brief Bitfield access */
} Ifx_DMU_SF_CONTROL;

/** \brief HSM DF1 ECC Control Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_SF_ECCC_Bits B;           /**< \brief Bitfield access */
} Ifx_DMU_SF_ECCC;

/** \brief HSM DF1 ECC Read Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_SF_ECCR_Bits B;           /**< \brief Bitfield access */
} Ifx_DMU_SF_ECCR;

/** \brief HSM DF1 ECC Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_SF_ECCS_Bits B;           /**< \brief Bitfield access */
} Ifx_DMU_SF_ECCS;

/** \brief HSM DF1 ECC Write Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_SF_ECCW_Bits B;           /**< \brief Bitfield access */
} Ifx_DMU_SF_ECCW;

/** \brief HSM Enable Error Interrupt Control Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_SF_EER_Bits B;            /**< \brief Bitfield access */
} Ifx_DMU_SF_EER;

/** \brief HSM Error Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_SF_ERRSR_Bits B;          /**< \brief Bitfield access */
} Ifx_DMU_SF_ERRSR;

/** \brief HSM DF1 Margin Control Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_SF_MARGIN_Bits B;         /**< \brief Bitfield access */
} Ifx_DMU_SF_MARGIN;

/** \brief HSM Flash Operation Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_SF_OPERATION_Bits B;      /**< \brief Bitfield access */
} Ifx_DMU_SF_OPERATION;

/** \brief HSM DF1 User Mode Control   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_SF_PROCONUSR_Bits B;      /**< \brief Bitfield access */
} Ifx_DMU_SF_PROCONUSR;

/** \brief HSM Flash Status Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_SF_STATUS_Bits B;         /**< \brief Bitfield access */
} Ifx_DMU_SF_STATUS;

/** \brief HSM Suspend Control Register   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_SF_SUSPEND_Bits B;        /**< \brief Bitfield access */
} Ifx_DMU_SF_SUSPEND;

/** \brief HSM Interface Protection Configuration   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_SP_PROCONHSM_Bits B;      /**< \brief Bitfield access */
} Ifx_DMU_SP_PROCONHSM;

/** \brief HSM Code Boot Sector   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_SP_PROCONHSMCBS_Bits B;    /**< \brief Bitfield access */
} Ifx_DMU_SP_PROCONHSMCBS;

/** \brief HSM Protection Configuration   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_SP_PROCONHSMCFG_Bits B;    /**< \brief Bitfield access */
} Ifx_DMU_SP_PROCONHSMCFG;

/** \brief HSM Code OTP Protection Configuration   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_SP_PROCONHSMCOTP0_Bits B;    /**< \brief Bitfield access */
} Ifx_DMU_SP_PROCONHSMCOTP0;

/** \brief HSM Code OTP Protection Configuration   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_SP_PROCONHSMCOTP1_Bits B;    /**< \brief Bitfield access */
} Ifx_DMU_SP_PROCONHSMCOTP1;

/** \brief HSM Code Exclusive Protection Configuration   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_SP_PROCONHSMCX0_Bits B;    /**< \brief Bitfield access */
} Ifx_DMU_SP_PROCONHSMCX0;

/** \brief HSM Code Exclusive Protection Configuration   */
typedef union
{
    Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_DMU_SP_PROCONHSMCX1_Bits B;    /**< \brief Bitfield access */
} Ifx_DMU_SP_PROCONHSMCX1;

/** \}  */

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Dmu_HP_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief HP object */
typedef volatile struct _Ifx_DMU_HP
{
       Ifx_DMU_HP_PROCON_P0                PROCON_P0;              /**< \brief 0, PFLASH Bank ${i} Protection Configuration 0*/
       Ifx_DMU_HP_PROCON_P1                PROCON_P1;              /**< \brief 4, PFLASH Bank ${i} Protection Configuration 1*/
       Ifx_DMU_HP_PROCON_P2                PROCON_P2;              /**< \brief 8, PFLASH Bank ${i} Protection Configuration 2*/
       Ifx_DMU_HP_PROCON_P3                PROCON_P3;              /**< \brief C, PFLASH Bank ${i} Protection Configuration 3*/
       Ifx_DMU_HP_PROCON_P4                PROCON_P4;              /**< \brief 10, PFLASH Bank ${i} Protection Configuration 4*/
       Ifx_DMU_HP_PROCON_P5                PROCON_P5;              /**< \brief 14, PFLASH Bank ${i} Protection Configuration 5*/
       Ifx_UReg_8Bit                       reserved_18[40];        /**< \brief 18, \internal Reserved */
       Ifx_DMU_HP_PROCON_OTP0              PROCON_OTP0;            /**< \brief 40, PFLASH Bank ${i} OTP Protection Configuration 0*/
       Ifx_DMU_HP_PROCON_OTP1              PROCON_OTP1;            /**< \brief 44, PFLASH Bank ${i} OTP Protection Configuration 1*/
       Ifx_DMU_HP_PROCON_OTP2              PROCON_OTP2;            /**< \brief 48, PFLASH Bank ${i} OTP Protection Configuration 2*/
       Ifx_DMU_HP_PROCON_OTP3              PROCON_OTP3;            /**< \brief 4C, PFLASH Bank ${i} OTP Protection Configuration 3*/
       Ifx_DMU_HP_PROCON_OTP4              PROCON_OTP4;            /**< \brief 50, PFLASH Bank ${i} OTP Protection Configuration 4*/
       Ifx_DMU_HP_PROCON_OTP5              PROCON_OTP5;            /**< \brief 54, PFLASH Bank ${i} OTP Protection Configuration 5*/
       Ifx_UReg_8Bit                       reserved_58[40];        /**< \brief 58, \internal Reserved */
       Ifx_DMU_HP_PROCON_WOP0              PROCON_WOP0;            /**< \brief 80, PFLASH Bank ${i} WOP Configuration 0*/
       Ifx_DMU_HP_PROCON_WOP1              PROCON_WOP1;            /**< \brief 84, PFLASH Bank ${i} WOP Configuration 1*/
       Ifx_DMU_HP_PROCON_WOP2              PROCON_WOP2;            /**< \brief 88, PFLASH Bank ${i} WOP Configuration 2*/
       Ifx_DMU_HP_PROCON_WOP3              PROCON_WOP3;            /**< \brief 8C, PFLASH Bank ${i} WOP Configuration 3*/
       Ifx_DMU_HP_PROCON_WOP4              PROCON_WOP4;            /**< \brief 90, PFLASH Bank ${i} WOP Configuration 4*/
       Ifx_DMU_HP_PROCON_WOP5              PROCON_WOP5;            /**< \brief 94, PFLASH Bank ${i} WOP Configuration 5*/
       Ifx_UReg_8Bit                       reserved_98[8];         /**< \brief 98, \internal Reserved */
       Ifx_DMU_HP_ECPRIO_P0                ECPRIO_P0;              /**< \brief A0, PFLASH Bank ${i} Erase Counter Priority configuration 0*/
       Ifx_DMU_HP_ECPRIO_P1                ECPRIO_P1;              /**< \brief A4, PFLASH Bank ${i} Erase Counter Priority Configuration 1*/
       Ifx_DMU_HP_ECPRIO_P2                ECPRIO_P2;              /**< \brief A8, PFLASH Bank ${i} Erase Counter Priority Configuration 2*/
       Ifx_DMU_HP_ECPRIO_P3                ECPRIO_P3;              /**< \brief AC, PFLASH Bank ${i} Erase Counter Priority Configuration 3*/
       Ifx_DMU_HP_ECPRIO_P4                ECPRIO_P4;              /**< \brief B0, PFLASH Bank ${i} Erase Counter Priority Configuration 4*/
       Ifx_DMU_HP_ECPRIO_P5                ECPRIO_P5;              /**< \brief B4, PFLASH Bank ${i} Erase Counter Priority Configuration 5*/
       Ifx_UReg_8Bit                       reserved_B8[72];        /**< \brief B8, \internal Reserved */
} Ifx_DMU_HP;
/** \}  */
/******************************************************************************/
/** \}  */
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/** \addtogroup IfxSfr_Dmu_Registers_struct
 * \{  */
/******************************************************************************/
/** \name Object L0
 * \{  */

/** \brief DMU object */
typedef volatile struct _Ifx_DMU
{
       Ifx_UReg_8Bit                       reserved_0[8];          /**< \brief 0, \internal Reserved */
       Ifx_DMU_HF_ID                       HF_ID;                  /**< \brief 8, Module Identification Register*/
       Ifx_UReg_8Bit                       reserved_C[4];          /**< \brief C, \internal Reserved */
       Ifx_DMU_HF_STATUS                   HF_STATUS;              /**< \brief 10, Flash Status Register*/
       Ifx_DMU_HF_CONTROL                  HF_CONTROL;             /**< \brief 14, Flash Control Register*/
       Ifx_DMU_HF_OPERATION                HF_OPERATION;           /**< \brief 18, Flash Operation Register*/
       Ifx_DMU_HF_PROTECT                  HF_PROTECT;             /**< \brief 1C, Flash Protection Status Register*/
       Ifx_DMU_HF_CONFIRM0                 HF_CONFIRM0;            /**< \brief 20, Flash Confirm Status Register 0*/
       Ifx_DMU_HF_CONFIRM1                 HF_CONFIRM1;            /**< \brief 24, Flash Confirm Status Register 1*/
       Ifx_DMU_HF_CONFIRM2                 HF_CONFIRM2;            /**< \brief 28, Flash Confirm Status Register 2*/
       Ifx_UReg_8Bit                       reserved_2C[4];         /**< \brief 2C, \internal Reserved */
       Ifx_DMU_HF_EER                      HF_EER;                 /**< \brief 30, Enable Error Interrupt Control Register*/
       Ifx_DMU_HF_ERRSR                    HF_ERRSR;               /**< \brief 34, Error Status Register*/
       Ifx_DMU_HF_CLRE                     HF_CLRE;                /**< \brief 38, Clear Error Register*/
       Ifx_UReg_8Bit                       reserved_3C[4];         /**< \brief 3C, \internal Reserved */
       Ifx_DMU_HF_ECCR                     HF_ECCR;                /**< \brief 40, DF0 ECC Read Register*/
       Ifx_DMU_HF_ECCS                     HF_ECCS;                /**< \brief 44, DF0 ECC Status Register*/
       Ifx_DMU_HF_ECCC                     HF_ECCC;                /**< \brief 48, DF0 ECC Control Register*/
       Ifx_DMU_HF_ECCW                     HF_ECCW;                /**< \brief 4C, DF0 ECC Write Register*/
       Ifx_DMU_HF_CCONTROL                 HF_CCONTROL;            /**< \brief 50, Cranking Control Register*/
       Ifx_UReg_8Bit                       reserved_54[12];        /**< \brief 54, \internal Reserved */
       Ifx_DMU_HF_PSTATUS                  HF_PSTATUS;             /**< \brief 60, Power Status Register*/
       Ifx_DMU_HF_PCONTROL                 HF_PCONTROL;            /**< \brief 64, Power Control Register*/
       Ifx_DMU_HF_PWAIT                    HF_PWAIT;               /**< \brief 68, PFLASH Wait Cycle Register*/
       Ifx_DMU_HF_DWAIT                    HF_DWAIT;               /**< \brief 6C, DFLASH Wait Cycle Register*/
       Ifx_UReg_8Bit                       reserved_70[4];         /**< \brief 70, \internal Reserved */
       Ifx_DMU_HF_PROCONUSR                HF_PROCONUSR;           /**< \brief 74, DF0 User Mode Control*/
       Ifx_UReg_8Bit                       reserved_78[8];         /**< \brief 78, \internal Reserved */
       Ifx_DMU_HF_PROCONPF                 HF_PROCONPF;            /**< \brief 80, PFLASH Protection Configuration*/
       Ifx_DMU_HF_PROCONTP                 HF_PROCONTP;            /**< \brief 84, Tuning Protection Configuration*/
       Ifx_DMU_HF_PROCONDF                 HF_PROCONDF;            /**< \brief 88, DFLASH Protection Configuration*/
       Ifx_DMU_HF_PROCONRAM                HF_PROCONRAM;           /**< \brief 8C, RAM Configuration*/
       Ifx_DMU_HF_PROCONDBG                HF_PROCONDBG;           /**< \brief 90, Debug Interface Protection Configuration*/
       Ifx_UReg_8Bit                       reserved_94[92];        /**< \brief 94, \internal Reserved */
       Ifx_DMU_HF_SUSPEND                  HF_SUSPEND;             /**< \brief F0, Suspend Control Register*/
       Ifx_DMU_HF_MARGIN                   HF_MARGIN;              /**< \brief F4, Margin Control Register*/
       Ifx_DMU_HF_ACCEN1                   HF_ACCEN1;              /**< \brief F8, Access Enable Register 1*/
       Ifx_DMU_HF_ACCEN0                   HF_ACCEN0;              /**< \brief FC, Access Enable Register 0*/
       Ifx_UReg_8Bit                       reserved_100[65280];    /**< \brief 100, \internal Reserved */
       Ifx_DMU_HP                          HP[4];                  /**< \brief 10000, */
       Ifx_UReg_8Bit                       reserved_10400[64528];    /**< \brief 10400, \internal Reserved */
       Ifx_DMU_SF_STATUS                   SF_STATUS;              /**< \brief 20010, HSM Flash Status Register*/
       Ifx_DMU_SF_CONTROL                  SF_CONTROL;             /**< \brief 20014, HSM Flash Configuration Register*/
       Ifx_DMU_SF_OPERATION                SF_OPERATION;           /**< \brief 20018, HSM Flash Operation Register*/
       Ifx_UReg_8Bit                       reserved_2001C[20];     /**< \brief 2001C, \internal Reserved */
       Ifx_DMU_SF_EER                      SF_EER;                 /**< \brief 20030, HSM Enable Error Interrupt Control Register*/
       Ifx_DMU_SF_ERRSR                    SF_ERRSR;               /**< \brief 20034, HSM Error Status Register*/
       Ifx_DMU_SF_CLRE                     SF_CLRE;                /**< \brief 20038, HSM Clear Error Register*/
       Ifx_UReg_8Bit                       reserved_2003C[4];      /**< \brief 2003C, \internal Reserved */
       Ifx_DMU_SF_ECCR                     SF_ECCR;                /**< \brief 20040, HSM DF1 ECC Read Register*/
       Ifx_DMU_SF_ECCS                     SF_ECCS;                /**< \brief 20044, HSM DF1 ECC Status Register*/
       Ifx_DMU_SF_ECCC                     SF_ECCC;                /**< \brief 20048, HSM DF1 ECC Control Register*/
       Ifx_DMU_SF_ECCW                     SF_ECCW;                /**< \brief 2004C, HSM DF1 ECC Write Register*/
       Ifx_UReg_8Bit                       reserved_20050[36];     /**< \brief 20050, \internal Reserved */
       Ifx_DMU_SF_PROCONUSR                SF_PROCONUSR;           /**< \brief 20074, HSM DF1 User Mode Control*/
       Ifx_UReg_8Bit                       reserved_20078[112];    /**< \brief 20078, \internal Reserved */
       Ifx_DMU_SF_SUSPEND                  SF_SUSPEND;             /**< \brief 200E8, HSM Suspend Control Register*/
       Ifx_DMU_SF_MARGIN                   SF_MARGIN;              /**< \brief 200EC, HSM DF1 Margin Control Register*/
       Ifx_UReg_8Bit                       reserved_200F0[65296];    /**< \brief 200F0, \internal Reserved */
       Ifx_DMU_SP_PROCONHSMCFG             SP_PROCONHSMCFG;        /**< \brief 30000, HSM Protection Configuration*/
       Ifx_DMU_SP_PROCONHSMCBS             SP_PROCONHSMCBS;        /**< \brief 30004, HSM Code Boot Sector*/
       Ifx_DMU_SP_PROCONHSMCX0             SP_PROCONHSMCX0;        /**< \brief 30008, HSM Code Exclusive Protection Configuration*/
       Ifx_DMU_SP_PROCONHSMCX1             SP_PROCONHSMCX1;        /**< \brief 3000C, HSM Code Exclusive Protection Configuration*/
       Ifx_DMU_SP_PROCONHSMCOTP0           SP_PROCONHSMCOTP0;      /**< \brief 30010, HSM Code OTP Protection Configuration*/
       Ifx_DMU_SP_PROCONHSMCOTP1           SP_PROCONHSMCOTP1;      /**< \brief 30014, HSM Code OTP Protection Configuration*/
       Ifx_UReg_8Bit                       reserved_30018[40];     /**< \brief 30018, \internal Reserved */
       Ifx_DMU_SP_PROCONHSM                SP_PROCONHSM;           /**< \brief 30040, HSM Interface Protection Configuration*/
       Ifx_UReg_8Bit                       reserved_30044[65468];    /**< \brief 30044, \internal Reserved */
} Ifx_DMU;

/** \}  */
/******************************************************************************/
/** \}  */


/******************************************************************************/

/******************************************************************************/


#line 57 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\Infra\\Sfr\\TC38A\\_Reg\\IfxDmu_reg.h"
/******************************************************************************/

/******************************************************************************/

/******************************************************************************/

/** \addtogroup IfxSfr_Dmu_Registers_Cfg_BaseAddress
 * \{  */

/** \brief DMU object */

/** \}  */


/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Dmu_Registers_Cfg_Dmu
 * \{  */
/** \brief 8, Module Identification Register */


/** \brief 10, Flash Status Register */


/** \brief 14, Flash Control Register */


/** \brief 18, Flash Operation Register */


/** \brief 1C, Flash Protection Status Register */


/** \brief 20, Flash Confirm Status Register 0 */


/** \brief 24, Flash Confirm Status Register 1 */


/** \brief 28, Flash Confirm Status Register 2 */


/** \brief 30, Enable Error Interrupt Control Register */


/** \brief 34, Error Status Register */


/** \brief 38, Clear Error Register */


/** \brief 40, DF0 ECC Read Register */


/** \brief 44, DF0 ECC Status Register */


/** \brief 48, DF0 ECC Control Register */


/** \brief 4C, DF0 ECC Write Register */


/** \brief 50, Cranking Control Register */


/** \brief 60, Power Status Register */


/** \brief 64, Power Control Register */


/** \brief 68, PFLASH Wait Cycle Register */


/** \brief 6C, DFLASH Wait Cycle Register */


/** \brief 74, DF0 User Mode Control */


/** \brief 80, PFLASH Protection Configuration */


/** \brief 84, Tuning Protection Configuration */


/** \brief 88, DFLASH Protection Configuration */


/** \brief 8C, RAM Configuration */


/** \brief 90, Debug Interface Protection Configuration */


/** \brief F0, Suspend Control Register */


/** \brief F4, Margin Control Register */


/** \brief F8, Access Enable Register 1 */


/** \brief FC, Access Enable Register 0 */


/** \brief 10000, PFLASH Bank 0 Protection Configuration 0 */

/** Alias (User Manual Name) for DMU_HP0_PROCON_P0.
* To use register names with standard convension, please use DMU_HP0_PROCON_P0.
*/


/** \brief 10004, PFLASH Bank 0 Protection Configuration 1 */

/** Alias (User Manual Name) for DMU_HP0_PROCON_P1.
* To use register names with standard convension, please use DMU_HP0_PROCON_P1.
*/


/** \brief 10008, PFLASH Bank 0 Protection Configuration 2 */

/** Alias (User Manual Name) for DMU_HP0_PROCON_P2.
* To use register names with standard convension, please use DMU_HP0_PROCON_P2.
*/


/** \brief 1000C, PFLASH Bank 0 Protection Configuration 3 */

/** Alias (User Manual Name) for DMU_HP0_PROCON_P3.
* To use register names with standard convension, please use DMU_HP0_PROCON_P3.
*/


/** \brief 10010, PFLASH Bank 0 Protection Configuration 4 */

/** Alias (User Manual Name) for DMU_HP0_PROCON_P4.
* To use register names with standard convension, please use DMU_HP0_PROCON_P4.
*/


/** \brief 10014, PFLASH Bank 0 Protection Configuration 5 */

/** Alias (User Manual Name) for DMU_HP0_PROCON_P5.
* To use register names with standard convension, please use DMU_HP0_PROCON_P5.
*/


/** \brief 10040, PFLASH Bank 0 OTP Protection Configuration 0 */

/** Alias (User Manual Name) for DMU_HP0_PROCON_OTP0.
* To use register names with standard convension, please use DMU_HP0_PROCON_OTP0.
*/


/** \brief 10044, PFLASH Bank 0 OTP Protection Configuration 1 */

/** Alias (User Manual Name) for DMU_HP0_PROCON_OTP1.
* To use register names with standard convension, please use DMU_HP0_PROCON_OTP1.
*/


/** \brief 10048, PFLASH Bank 0 OTP Protection Configuration 2 */

/** Alias (User Manual Name) for DMU_HP0_PROCON_OTP2.
* To use register names with standard convension, please use DMU_HP0_PROCON_OTP2.
*/


/** \brief 1004C, PFLASH Bank 0 OTP Protection Configuration 3 */

/** Alias (User Manual Name) for DMU_HP0_PROCON_OTP3.
* To use register names with standard convension, please use DMU_HP0_PROCON_OTP3.
*/


/** \brief 10050, PFLASH Bank 0 OTP Protection Configuration 4 */

/** Alias (User Manual Name) for DMU_HP0_PROCON_OTP4.
* To use register names with standard convension, please use DMU_HP0_PROCON_OTP4.
*/


/** \brief 10054, PFLASH Bank 0 OTP Protection Configuration 5 */

/** Alias (User Manual Name) for DMU_HP0_PROCON_OTP5.
* To use register names with standard convension, please use DMU_HP0_PROCON_OTP5.
*/


/** \brief 10080, PFLASH Bank 0 WOP Configuration 0 */

/** Alias (User Manual Name) for DMU_HP0_PROCON_WOP0.
* To use register names with standard convension, please use DMU_HP0_PROCON_WOP0.
*/


/** \brief 10084, PFLASH Bank 0 WOP Configuration 1 */

/** Alias (User Manual Name) for DMU_HP0_PROCON_WOP1.
* To use register names with standard convension, please use DMU_HP0_PROCON_WOP1.
*/


/** \brief 10088, PFLASH Bank 0 WOP Configuration 2 */

/** Alias (User Manual Name) for DMU_HP0_PROCON_WOP2.
* To use register names with standard convension, please use DMU_HP0_PROCON_WOP2.
*/


/** \brief 1008C, PFLASH Bank 0 WOP Configuration 3 */

/** Alias (User Manual Name) for DMU_HP0_PROCON_WOP3.
* To use register names with standard convension, please use DMU_HP0_PROCON_WOP3.
*/


/** \brief 10090, PFLASH Bank 0 WOP Configuration 4 */

/** Alias (User Manual Name) for DMU_HP0_PROCON_WOP4.
* To use register names with standard convension, please use DMU_HP0_PROCON_WOP4.
*/


/** \brief 10094, PFLASH Bank 0 WOP Configuration 5 */

/** Alias (User Manual Name) for DMU_HP0_PROCON_WOP5.
* To use register names with standard convension, please use DMU_HP0_PROCON_WOP5.
*/


/** \brief 100A0, PFLASH Bank 0 Erase Counter Priority configuration 0 */

/** Alias (User Manual Name) for DMU_HP0_ECPRIO_P0.
* To use register names with standard convension, please use DMU_HP0_ECPRIO_P0.
*/


/** \brief 100A4, PFLASH Bank 0 Erase Counter Priority Configuration 1 */

/** Alias (User Manual Name) for DMU_HP0_ECPRIO_P1.
* To use register names with standard convension, please use DMU_HP0_ECPRIO_P1.
*/


/** \brief 100A8, PFLASH Bank 0 Erase Counter Priority Configuration 2 */

/** Alias (User Manual Name) for DMU_HP0_ECPRIO_P2.
* To use register names with standard convension, please use DMU_HP0_ECPRIO_P2.
*/


/** \brief 100AC, PFLASH Bank 0 Erase Counter Priority Configuration 3 */

/** Alias (User Manual Name) for DMU_HP0_ECPRIO_P3.
* To use register names with standard convension, please use DMU_HP0_ECPRIO_P3.
*/


/** \brief 100B0, PFLASH Bank 0 Erase Counter Priority Configuration 4 */

/** Alias (User Manual Name) for DMU_HP0_ECPRIO_P4.
* To use register names with standard convension, please use DMU_HP0_ECPRIO_P4.
*/


/** \brief 100B4, PFLASH Bank 0 Erase Counter Priority Configuration 5 */

/** Alias (User Manual Name) for DMU_HP0_ECPRIO_P5.
* To use register names with standard convension, please use DMU_HP0_ECPRIO_P5.
*/


/** \brief 10100, PFLASH Bank 1 Protection Configuration 0 */

/** Alias (User Manual Name) for DMU_HP1_PROCON_P0.
* To use register names with standard convension, please use DMU_HP1_PROCON_P0.
*/


/** \brief 10104, PFLASH Bank 1 Protection Configuration 1 */

/** Alias (User Manual Name) for DMU_HP1_PROCON_P1.
* To use register names with standard convension, please use DMU_HP1_PROCON_P1.
*/


/** \brief 10108, PFLASH Bank 1 Protection Configuration 2 */

/** Alias (User Manual Name) for DMU_HP1_PROCON_P2.
* To use register names with standard convension, please use DMU_HP1_PROCON_P2.
*/


/** \brief 1010C, PFLASH Bank 1 Protection Configuration 3 */

/** Alias (User Manual Name) for DMU_HP1_PROCON_P3.
* To use register names with standard convension, please use DMU_HP1_PROCON_P3.
*/


/** \brief 10110, PFLASH Bank 1 Protection Configuration 4 */

/** Alias (User Manual Name) for DMU_HP1_PROCON_P4.
* To use register names with standard convension, please use DMU_HP1_PROCON_P4.
*/


/** \brief 10114, PFLASH Bank 1 Protection Configuration 5 */

/** Alias (User Manual Name) for DMU_HP1_PROCON_P5.
* To use register names with standard convension, please use DMU_HP1_PROCON_P5.
*/


/** \brief 10140, PFLASH Bank 1 OTP Protection Configuration 0 */

/** Alias (User Manual Name) for DMU_HP1_PROCON_OTP0.
* To use register names with standard convension, please use DMU_HP1_PROCON_OTP0.
*/


/** \brief 10144, PFLASH Bank 1 OTP Protection Configuration 1 */

/** Alias (User Manual Name) for DMU_HP1_PROCON_OTP1.
* To use register names with standard convension, please use DMU_HP1_PROCON_OTP1.
*/


/** \brief 10148, PFLASH Bank 1 OTP Protection Configuration 2 */

/** Alias (User Manual Name) for DMU_HP1_PROCON_OTP2.
* To use register names with standard convension, please use DMU_HP1_PROCON_OTP2.
*/


/** \brief 1014C, PFLASH Bank 1 OTP Protection Configuration 3 */

/** Alias (User Manual Name) for DMU_HP1_PROCON_OTP3.
* To use register names with standard convension, please use DMU_HP1_PROCON_OTP3.
*/


/** \brief 10150, PFLASH Bank 1 OTP Protection Configuration 4 */

/** Alias (User Manual Name) for DMU_HP1_PROCON_OTP4.
* To use register names with standard convension, please use DMU_HP1_PROCON_OTP4.
*/


/** \brief 10154, PFLASH Bank 1 OTP Protection Configuration 5 */

/** Alias (User Manual Name) for DMU_HP1_PROCON_OTP5.
* To use register names with standard convension, please use DMU_HP1_PROCON_OTP5.
*/


/** \brief 10180, PFLASH Bank 1 WOP Configuration 0 */

/** Alias (User Manual Name) for DMU_HP1_PROCON_WOP0.
* To use register names with standard convension, please use DMU_HP1_PROCON_WOP0.
*/


/** \brief 10184, PFLASH Bank 1 WOP Configuration 1 */

/** Alias (User Manual Name) for DMU_HP1_PROCON_WOP1.
* To use register names with standard convension, please use DMU_HP1_PROCON_WOP1.
*/


/** \brief 10188, PFLASH Bank 1 WOP Configuration 2 */

/** Alias (User Manual Name) for DMU_HP1_PROCON_WOP2.
* To use register names with standard convension, please use DMU_HP1_PROCON_WOP2.
*/


/** \brief 1018C, PFLASH Bank 1 WOP Configuration 3 */

/** Alias (User Manual Name) for DMU_HP1_PROCON_WOP3.
* To use register names with standard convension, please use DMU_HP1_PROCON_WOP3.
*/


/** \brief 10190, PFLASH Bank 1 WOP Configuration 4 */

/** Alias (User Manual Name) for DMU_HP1_PROCON_WOP4.
* To use register names with standard convension, please use DMU_HP1_PROCON_WOP4.
*/


/** \brief 10194, PFLASH Bank 1 WOP Configuration 5 */

/** Alias (User Manual Name) for DMU_HP1_PROCON_WOP5.
* To use register names with standard convension, please use DMU_HP1_PROCON_WOP5.
*/


/** \brief 101A0, PFLASH Bank 1 Erase Counter Priority configuration 0 */

/** Alias (User Manual Name) for DMU_HP1_ECPRIO_P0.
* To use register names with standard convension, please use DMU_HP1_ECPRIO_P0.
*/


/** \brief 101A4, PFLASH Bank 1 Erase Counter Priority Configuration 1 */

/** Alias (User Manual Name) for DMU_HP1_ECPRIO_P1.
* To use register names with standard convension, please use DMU_HP1_ECPRIO_P1.
*/


/** \brief 101A8, PFLASH Bank 1 Erase Counter Priority Configuration 2 */

/** Alias (User Manual Name) for DMU_HP1_ECPRIO_P2.
* To use register names with standard convension, please use DMU_HP1_ECPRIO_P2.
*/


/** \brief 101AC, PFLASH Bank 1 Erase Counter Priority Configuration 3 */

/** Alias (User Manual Name) for DMU_HP1_ECPRIO_P3.
* To use register names with standard convension, please use DMU_HP1_ECPRIO_P3.
*/


/** \brief 101B0, PFLASH Bank 1 Erase Counter Priority Configuration 4 */

/** Alias (User Manual Name) for DMU_HP1_ECPRIO_P4.
* To use register names with standard convension, please use DMU_HP1_ECPRIO_P4.
*/


/** \brief 101B4, PFLASH Bank 1 Erase Counter Priority Configuration 5 */

/** Alias (User Manual Name) for DMU_HP1_ECPRIO_P5.
* To use register names with standard convension, please use DMU_HP1_ECPRIO_P5.
*/


/** \brief 10200, PFLASH Bank 2 Protection Configuration 0 */

/** Alias (User Manual Name) for DMU_HP2_PROCON_P0.
* To use register names with standard convension, please use DMU_HP2_PROCON_P0.
*/


/** \brief 10204, PFLASH Bank 2 Protection Configuration 1 */

/** Alias (User Manual Name) for DMU_HP2_PROCON_P1.
* To use register names with standard convension, please use DMU_HP2_PROCON_P1.
*/


/** \brief 10208, PFLASH Bank 2 Protection Configuration 2 */

/** Alias (User Manual Name) for DMU_HP2_PROCON_P2.
* To use register names with standard convension, please use DMU_HP2_PROCON_P2.
*/


/** \brief 1020C, PFLASH Bank 2 Protection Configuration 3 */

/** Alias (User Manual Name) for DMU_HP2_PROCON_P3.
* To use register names with standard convension, please use DMU_HP2_PROCON_P3.
*/


/** \brief 10210, PFLASH Bank 2 Protection Configuration 4 */

/** Alias (User Manual Name) for DMU_HP2_PROCON_P4.
* To use register names with standard convension, please use DMU_HP2_PROCON_P4.
*/


/** \brief 10214, PFLASH Bank 2 Protection Configuration 5 */

/** Alias (User Manual Name) for DMU_HP2_PROCON_P5.
* To use register names with standard convension, please use DMU_HP2_PROCON_P5.
*/


/** \brief 10240, PFLASH Bank 2 OTP Protection Configuration 0 */

/** Alias (User Manual Name) for DMU_HP2_PROCON_OTP0.
* To use register names with standard convension, please use DMU_HP2_PROCON_OTP0.
*/


/** \brief 10244, PFLASH Bank 2 OTP Protection Configuration 1 */

/** Alias (User Manual Name) for DMU_HP2_PROCON_OTP1.
* To use register names with standard convension, please use DMU_HP2_PROCON_OTP1.
*/


/** \brief 10248, PFLASH Bank 2 OTP Protection Configuration 2 */

/** Alias (User Manual Name) for DMU_HP2_PROCON_OTP2.
* To use register names with standard convension, please use DMU_HP2_PROCON_OTP2.
*/


/** \brief 1024C, PFLASH Bank 2 OTP Protection Configuration 3 */

/** Alias (User Manual Name) for DMU_HP2_PROCON_OTP3.
* To use register names with standard convension, please use DMU_HP2_PROCON_OTP3.
*/


/** \brief 10250, PFLASH Bank 2 OTP Protection Configuration 4 */

/** Alias (User Manual Name) for DMU_HP2_PROCON_OTP4.
* To use register names with standard convension, please use DMU_HP2_PROCON_OTP4.
*/


/** \brief 10254, PFLASH Bank 2 OTP Protection Configuration 5 */

/** Alias (User Manual Name) for DMU_HP2_PROCON_OTP5.
* To use register names with standard convension, please use DMU_HP2_PROCON_OTP5.
*/


/** \brief 10280, PFLASH Bank 2 WOP Configuration 0 */

/** Alias (User Manual Name) for DMU_HP2_PROCON_WOP0.
* To use register names with standard convension, please use DMU_HP2_PROCON_WOP0.
*/


/** \brief 10284, PFLASH Bank 2 WOP Configuration 1 */

/** Alias (User Manual Name) for DMU_HP2_PROCON_WOP1.
* To use register names with standard convension, please use DMU_HP2_PROCON_WOP1.
*/


/** \brief 10288, PFLASH Bank 2 WOP Configuration 2 */

/** Alias (User Manual Name) for DMU_HP2_PROCON_WOP2.
* To use register names with standard convension, please use DMU_HP2_PROCON_WOP2.
*/


/** \brief 1028C, PFLASH Bank 2 WOP Configuration 3 */

/** Alias (User Manual Name) for DMU_HP2_PROCON_WOP3.
* To use register names with standard convension, please use DMU_HP2_PROCON_WOP3.
*/


/** \brief 10290, PFLASH Bank 2 WOP Configuration 4 */

/** Alias (User Manual Name) for DMU_HP2_PROCON_WOP4.
* To use register names with standard convension, please use DMU_HP2_PROCON_WOP4.
*/


/** \brief 10294, PFLASH Bank 2 WOP Configuration 5 */

/** Alias (User Manual Name) for DMU_HP2_PROCON_WOP5.
* To use register names with standard convension, please use DMU_HP2_PROCON_WOP5.
*/


/** \brief 102A0, PFLASH Bank 2 Erase Counter Priority configuration 0 */

/** Alias (User Manual Name) for DMU_HP2_ECPRIO_P0.
* To use register names with standard convension, please use DMU_HP2_ECPRIO_P0.
*/


/** \brief 102A4, PFLASH Bank 2 Erase Counter Priority Configuration 1 */

/** Alias (User Manual Name) for DMU_HP2_ECPRIO_P1.
* To use register names with standard convension, please use DMU_HP2_ECPRIO_P1.
*/


/** \brief 102A8, PFLASH Bank 2 Erase Counter Priority Configuration 2 */

/** Alias (User Manual Name) for DMU_HP2_ECPRIO_P2.
* To use register names with standard convension, please use DMU_HP2_ECPRIO_P2.
*/


/** \brief 102AC, PFLASH Bank 2 Erase Counter Priority Configuration 3 */

/** Alias (User Manual Name) for DMU_HP2_ECPRIO_P3.
* To use register names with standard convension, please use DMU_HP2_ECPRIO_P3.
*/


/** \brief 102B0, PFLASH Bank 2 Erase Counter Priority Configuration 4 */

/** Alias (User Manual Name) for DMU_HP2_ECPRIO_P4.
* To use register names with standard convension, please use DMU_HP2_ECPRIO_P4.
*/


/** \brief 102B4, PFLASH Bank 2 Erase Counter Priority Configuration 5 */

/** Alias (User Manual Name) for DMU_HP2_ECPRIO_P5.
* To use register names with standard convension, please use DMU_HP2_ECPRIO_P5.
*/


/** \brief 10300, PFLASH Bank 3 Protection Configuration 0 */

/** Alias (User Manual Name) for DMU_HP3_PROCON_P0.
* To use register names with standard convension, please use DMU_HP3_PROCON_P0.
*/


/** \brief 10304, PFLASH Bank 3 Protection Configuration 1 */

/** Alias (User Manual Name) for DMU_HP3_PROCON_P1.
* To use register names with standard convension, please use DMU_HP3_PROCON_P1.
*/


/** \brief 10308, PFLASH Bank 3 Protection Configuration 2 */

/** Alias (User Manual Name) for DMU_HP3_PROCON_P2.
* To use register names with standard convension, please use DMU_HP3_PROCON_P2.
*/


/** \brief 1030C, PFLASH Bank 3 Protection Configuration 3 */

/** Alias (User Manual Name) for DMU_HP3_PROCON_P3.
* To use register names with standard convension, please use DMU_HP3_PROCON_P3.
*/


/** \brief 10310, PFLASH Bank 3 Protection Configuration 4 */

/** Alias (User Manual Name) for DMU_HP3_PROCON_P4.
* To use register names with standard convension, please use DMU_HP3_PROCON_P4.
*/


/** \brief 10314, PFLASH Bank 3 Protection Configuration 5 */

/** Alias (User Manual Name) for DMU_HP3_PROCON_P5.
* To use register names with standard convension, please use DMU_HP3_PROCON_P5.
*/


/** \brief 10340, PFLASH Bank 3 OTP Protection Configuration 0 */

/** Alias (User Manual Name) for DMU_HP3_PROCON_OTP0.
* To use register names with standard convension, please use DMU_HP3_PROCON_OTP0.
*/


/** \brief 10344, PFLASH Bank 3 OTP Protection Configuration 1 */

/** Alias (User Manual Name) for DMU_HP3_PROCON_OTP1.
* To use register names with standard convension, please use DMU_HP3_PROCON_OTP1.
*/


/** \brief 10348, PFLASH Bank 3 OTP Protection Configuration 2 */

/** Alias (User Manual Name) for DMU_HP3_PROCON_OTP2.
* To use register names with standard convension, please use DMU_HP3_PROCON_OTP2.
*/


/** \brief 1034C, PFLASH Bank 3 OTP Protection Configuration 3 */

/** Alias (User Manual Name) for DMU_HP3_PROCON_OTP3.
* To use register names with standard convension, please use DMU_HP3_PROCON_OTP3.
*/


/** \brief 10350, PFLASH Bank 3 OTP Protection Configuration 4 */

/** Alias (User Manual Name) for DMU_HP3_PROCON_OTP4.
* To use register names with standard convension, please use DMU_HP3_PROCON_OTP4.
*/


/** \brief 10354, PFLASH Bank 3 OTP Protection Configuration 5 */

/** Alias (User Manual Name) for DMU_HP3_PROCON_OTP5.
* To use register names with standard convension, please use DMU_HP3_PROCON_OTP5.
*/


/** \brief 10380, PFLASH Bank 3 WOP Configuration 0 */

/** Alias (User Manual Name) for DMU_HP3_PROCON_WOP0.
* To use register names with standard convension, please use DMU_HP3_PROCON_WOP0.
*/


/** \brief 10384, PFLASH Bank 3 WOP Configuration 1 */

/** Alias (User Manual Name) for DMU_HP3_PROCON_WOP1.
* To use register names with standard convension, please use DMU_HP3_PROCON_WOP1.
*/


/** \brief 10388, PFLASH Bank 3 WOP Configuration 2 */

/** Alias (User Manual Name) for DMU_HP3_PROCON_WOP2.
* To use register names with standard convension, please use DMU_HP3_PROCON_WOP2.
*/


/** \brief 1038C, PFLASH Bank 3 WOP Configuration 3 */

/** Alias (User Manual Name) for DMU_HP3_PROCON_WOP3.
* To use register names with standard convension, please use DMU_HP3_PROCON_WOP3.
*/


/** \brief 10390, PFLASH Bank 3 WOP Configuration 4 */

/** Alias (User Manual Name) for DMU_HP3_PROCON_WOP4.
* To use register names with standard convension, please use DMU_HP3_PROCON_WOP4.
*/


/** \brief 10394, PFLASH Bank 3 WOP Configuration 5 */

/** Alias (User Manual Name) for DMU_HP3_PROCON_WOP5.
* To use register names with standard convension, please use DMU_HP3_PROCON_WOP5.
*/


/** \brief 103A0, PFLASH Bank 3 Erase Counter Priority configuration 0 */

/** Alias (User Manual Name) for DMU_HP3_ECPRIO_P0.
* To use register names with standard convension, please use DMU_HP3_ECPRIO_P0.
*/


/** \brief 103A4, PFLASH Bank 3 Erase Counter Priority Configuration 1 */

/** Alias (User Manual Name) for DMU_HP3_ECPRIO_P1.
* To use register names with standard convension, please use DMU_HP3_ECPRIO_P1.
*/


/** \brief 103A8, PFLASH Bank 3 Erase Counter Priority Configuration 2 */

/** Alias (User Manual Name) for DMU_HP3_ECPRIO_P2.
* To use register names with standard convension, please use DMU_HP3_ECPRIO_P2.
*/


/** \brief 103AC, PFLASH Bank 3 Erase Counter Priority Configuration 3 */

/** Alias (User Manual Name) for DMU_HP3_ECPRIO_P3.
* To use register names with standard convension, please use DMU_HP3_ECPRIO_P3.
*/


/** \brief 103B0, PFLASH Bank 3 Erase Counter Priority Configuration 4 */

/** Alias (User Manual Name) for DMU_HP3_ECPRIO_P4.
* To use register names with standard convension, please use DMU_HP3_ECPRIO_P4.
*/


/** \brief 103B4, PFLASH Bank 3 Erase Counter Priority Configuration 5 */

/** Alias (User Manual Name) for DMU_HP3_ECPRIO_P5.
* To use register names with standard convension, please use DMU_HP3_ECPRIO_P5.
*/


/** \brief 20010, HSM Flash Status Register */


/** \brief 20014, HSM Flash Configuration Register */


/** \brief 20018, HSM Flash Operation Register */


/** \brief 20030, HSM Enable Error Interrupt Control Register */


/** \brief 20034, HSM Error Status Register */


/** \brief 20038, HSM Clear Error Register */


/** \brief 20040, HSM DF1 ECC Read Register */


/** \brief 20044, HSM DF1 ECC Status Register */


/** \brief 20048, HSM DF1 ECC Control Register */


/** \brief 2004C, HSM DF1 ECC Write Register */


/** \brief 20074, HSM DF1 User Mode Control */


/** \brief 200E8, HSM Suspend Control Register */


/** \brief 200EC, HSM DF1 Margin Control Register */


/** \brief 30000, HSM Protection Configuration */


/** \brief 30004, HSM Code Boot Sector */


/** \brief 30008, HSM Code Exclusive Protection Configuration */


/** \brief 3000C, HSM Code Exclusive Protection Configuration */


/** \brief 30010, HSM Code OTP Protection Configuration */


/** \brief 30014, HSM Code OTP Protection Configuration */


/** \brief 30040, HSM Interface Protection Configuration */



/** \}  */

/******************************************************************************/

/******************************************************************************/


#line 73 "D:\\RTOS_PROJEKT\\erica\\aurix_workspace\\can_erika\\Libraries\\iLLD\\TC38A\\Tricore\\Pms\\Std\\IfxPmsPm.h"

/******************************************************************************/
/*--------------------------------Enumerations--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Pms_Std_Pm_Enumerations
 * \{ */
/** \brief Exposes the optons for minimum duration between standby entry and Wakeup.If any wakeup request comes up before this time is elapsed after standby entry, then it's ignored.Configured in PMS_PMSWCR.B.BLNKFIL
 */
typedef enum
{
    IfxPmsPm_BlankingFilterDelay_0ms     = 0,   /**< \brief No blanking filter delay */
    IfxPmsPm_BlankingFilterDelay_2_5ms   = 1,   /**< \brief Blanking delay on 2.5ms */
    IfxPmsPm_BlankingFilterDelay_5ms     = 2,   /**< \brief Blanking delay on 5ms */
    IfxPmsPm_BlankingFilterDelay_10ms    = 3,   /**< \brief Blanking delay on 10ms */
    IfxPmsPm_BlankingFilterDelay_20ms    = 4,   /**< \brief Blanking delay on 20ms */
    IfxPmsPm_BlankingFilterDelay_40ms    = 5,   /**< \brief Blanking delay on 40ms */
    IfxPmsPm_BlankingFilterDelay_80ms    = 6,   /**< \brief Blanking delay on 80ms */
    IfxPmsPm_BlankingFilterDelay_160ms   = 7,   /**< \brief Blanking delay on 160ms */
    IfxPmsPm_BlankingFilterDelay_320ms   = 8,   /**< \brief Blanking delay on 320ms */
    IfxPmsPm_BlankingFilterDelay_640ms   = 9,   /**< \brief Blanking delay on 640ms */
    IfxPmsPm_BlankingFilterDelay_1280ms  = 0xA, /**< \brief Blanking delay on 1280ms */
    IfxPmsPm_BlankingFilterDelay_2560ms  = 0xB, /**< \brief Blanking delay on 2560ms */
    IfxPmsPm_BlankingFilterDelay_5120ms  = 0xC, /**< \brief Blanking delay on 5120ms */
    IfxPmsPm_BlankingFilterDelay_10240ms = 0xD  /**< \brief Blanking delay on 1024ms */
} IfxPmsPm_BlankingFilterDelay;

/** \brief The Digital filter enable/disabled
 * As defined in Ifx_PMS.PMSW.CR0.B.ESRxDFEN and Ifx_PMS.PMSW.CR0.B.PINxDFEN
 */
typedef enum
{
    IfxPmsPm_DigitalFilter_bypassed = 0,  /**< \brief The Filter is Bypassed */
    IfxPmsPm_DigitalFilter_used     = 1   /**< \brief The Filter is Used */
} IfxPmsPm_DigitalFilter;

/** \brief Edge detection control mode for ESR and PINA/PINB
 * As defined in Ifx_PMS.PMSW.CR0.B.ESRxEDCON  and Ifx_PMS.PMSW.CR0.B.PINxEDCON
 */
typedef enum
{
    IfxPmsPm_EdgeDetectionControl_never         = 0,  /**< \brief No Trigger is Generated */
    IfxPmsPm_EdgeDetectionControl_onRisingEdge  = 1,  /**< \brief Trigger is generated upon a Rising edge */
    IfxPmsPm_EdgeDetectionControl_onFallingEdge = 2,  /**< \brief Triggerr is generated upon a falling edge */
    IfxPmsPm_EdgeDetectionControl_always        = 3   /**< \brief A trigger is generated upon a either edges */
} IfxPmsPm_EdgeDetectionControl;

/** \brief Request to set ESR0 pin pads to either input with weak pullup or tristate.Configured in PMS_PMSWCR5.B.ESR0TRIST
 */
typedef enum
{
    IfxPmsPm_Esr0PinStateRequest_resetOutput = 0,
    IfxPmsPm_Esr0PinStateRequest_tristate    = 1   /**< \brief Set the ESR0 pin pad to tristate */
} IfxPmsPm_Esr0PinStateRequest;

/** \brief List of different statuses related to Load Jump
 * This is reflected in SCU_PMTRCSR2.B.LJTRUN
 */
typedef enum
{
    IfxPmsPm_LoadJumpStatus_inactive                 = 0,  /**< \brief Load Jump and Load Jump Timer inactive */
    IfxPmsPm_LoadJumpStatus_swTriggeredRequestActive = 1,  /**< \brief A SW triggered Load Jump active and Load Jump Timer active */
    IfxPmsPm_LoadJumpStatus_hwTriggeredRequestActive = 2   /**< \brief A HW triggered Load Jump active and Load Jump Timer active */
} IfxPmsPm_LoadJumpStatus;

/** \brief Request to set pads to either input with weak pullup or tristate.Configured in PMS_PMSWCR5.B.TRISTREQ
 */
typedef enum
{
    IfxPmsPm_PadStateRequest_inputWithWeakPullUp = 0,  /**< \brief Set pads to input with weak pullup */
    IfxPmsPm_PadStateRequest_tristate            = 1   /**< \brief Set pads to tristate */
} IfxPmsPm_PadStateRequest;

typedef enum
{
    IfxPmsPm_PinEdgeTriggerEvent_none                     = 0, /**< \brief None of the edges will trigger anything */
    IfxPmsPm_PinEdgeTriggerEvent_risingEdge               = 1, /**< \brief Trigger is generated upon a rising edge */
    IfxPmsPm_PinEdgeTriggerEvent_fallingEdge              = 2, /**< \brief Trigger is generated upon a falling edge */
    IfxPmsPm_PinEdgeTriggerEvent_bothRisingAndFallingEdge = 3  /**< \brief A trigger is generated upon a rising OR falling edge */
} IfxPmsPm_PinEdgeTriggerEvent;

/** \brief Different options for when event triggering is desired(See EVRMONCTRL).
 */
typedef enum
{
    IfxPmsPm_RampingMode_none = 0,  /**< \brief Monitoring inactive. This results in a complete reset
                                     * of the comparator unit, status bits and filter values and alarm is
                                     * deasserted. */
    IfxPmsPm_RampingMode_up   = 1,  /**< \brief Event is triggered when the threshold is crossed in
                                     * a lower to higher voltage transition. Greater than or equal compare
                                     * is used. */
    IfxPmsPm_RampingMode_down = 2,  /**< \brief Event is triggered when the threshold is crossed in
                                     * a higher to lower voltage transition. Less than or equal compare is
                                     * used. */
    IfxPmsPm_RampingMode_both = 3   /**< \brief Event is triggered when the threshold is crossed in
                                     * either direction. Greater than or equal compare is used. */
} IfxPmsPm_RampingMode;

/** \brief System power mode
 * As defined in Ifx_SCU.PMCSR[x].B.REQSLP
 */
typedef enum
{
    IfxPmsPm_RequestPowerMode_run     = 0, /**< \brief Request CPU Run Mode */
    IfxPmsPm_RequestPowerMode_idle    = 1, /**< \brief Request CPU Idle Mode */
    IfxPmsPm_RequestPowerMode_sleep   = 2, /**< \brief Request CPU Sleep Mode */
    IfxPmsPm_RequestPowerMode_standby = 3  /**< \brief Request CPU Standby Mode */
} IfxPmsPm_RequestPowerMode;

/** \brief Defines Clocking options for SCR in PMS_PMSWCR4.B.SCRCLKSEL
 */
typedef enum
{
    IfxPmsPm_ScrClocking_100mhzOptional    = 0, /**< \brief 100MHz oscillator can be enabled or disabled based on request
                                                 * from Standby Controller. By default 100 MHz Oscillator is
                                                 * requested by SCR in Standby Mode. */
    IfxPmsPm_ScrClocking_bothClocksActiive = 1  /**< \brief 100MHz oscillator is always active irrespective of SCR requests.
                                                 * Thus both 70 KHz Oscillator and 100 MHz oscillator are active in
                                                 * Standby Mode. */
} IfxPmsPm_ScrClocking;

/** \brief The RAM being used in Standby mode
 * As defined in Ifx_PMS.PMSW.CR0.B.STBYRAMSEL
 */
typedef enum
{
    IfxPmsPm_StandbyRamSupply_never       = 0,  /**< \brief Standby RAM is not supplied */
    IfxPmsPm_StandbyRamSupply_cpu0Block0  = 1,  /**< \brief Standby RAM (CPU0 dLMU RAM Block 0) is supplied */
    IfxPmsPm_StandbyRamSupply_cpu0Block01 = 2,  /**< \brief Standby RAM (CPU0 dLMU RAM Block0 + Block1) is supplied */
    IfxPmsPm_StandbyRamSupply_cpu1Block01 = 4,  /**< \brief Standby RAM (CPU1 dLMU RAM Block0 + Block1) is supplied */
    IfxPmsPm_StandbyRamSupply_cpu0Cpu1    = 7   /**< \brief Standby RAM (CPU0 dLMU RAM Block0 + Block1) &  (CPU1 dLMU RAM Block0 + Block1)  is supplied */
} IfxPmsPm_StandbyRamSupply;

/** \brief Defines events to trigger entry to Standby mode.
 */
typedef enum
{
    IfxPmsPm_StandbyTriggerMode_software              = 0,  /**< \brief Standby request using MODULE_SCU.PMCSRx.B.REQSLP */
    IfxPmsPm_StandbyTriggerMode_hardware_undervoltage = 1,  /**< \brief Standby trigger arising from VEXT/VDD undervoltage */
    IfxPmsPm_StandbyTriggerMode_hardware_nmi          = 4   /**< \brief Standby request arising from any NMI/ESR1 pin assertion */
} IfxPmsPm_StandbyTriggerMode;

/** \brief types of event
 */
typedef enum
{
    IfxPmsPm_ThresholdEvent_overvoltage  = 0, /**< \brief Voltage is greater than the higher threshold */
    IfxPmsPm_ThresholdEvent_undervoltage = 4  /**< \brief Voltage is lesser than the lower threshold */
} IfxPmsPm_ThresholdEvent;

/** \brief Direction of Voltage Droop(positive and negative)
 * To be specified in SCU_PMTRCSR3.B.VDROOPREQ
 */
typedef enum
{
    IfxPmsPm_VoltageDroopRequest_positive = 1,  /**< \brief A Positive Voltage Droop Request made and taken. Voltage Droop
                                                 * Timer activated. */
    IfxPmsPm_VoltageDroopRequest_negative = 2   /**< \brief A Negative Voltage Droop Request made and taken. Voltage Droop
                                                 * Timer activated. */
} IfxPmsPm_VoltageDroopRequest;

/** \brief List of different statuses related to Load Jump
 * This is reflected in SCU_PMTRCSR3.B.VDTRUN
 */
typedef enum
{
    IfxPmsPm_VoltageDroopStatus_inactive                 = 0,  /**< \brief Voltage Droop and Voltage Droop Timer inactive */
    IfxPmsPm_VoltageDroopStatus_swTriggeredRequestActive = 1,  /**< \brief A SW triggered Voltage Droop active and Voltage Droop Timer
                                                                * active */
    IfxPmsPm_VoltageDroopStatus_hwTriggeredRequestActive = 2   /**< \brief A HW triggered Voltage Droop active and Voltage Droop Timer
                                                                * active */
} IfxPmsPm_VoltageDroopStatus;

/** \brief Lists out volatge droop steps
 */
typedef enum
{
    IfxPmsPm_VoltageDroopStep_0mV  = 0,    /**< \brief Voltage  Droop request of 0 mV */
    IfxPmsPm_VoltageDroopStep_5mV  = 1U,   /**< \brief Voltage  Droop request of 5 mV */
    IfxPmsPm_VoltageDroopStep_10mV = 2U,   /**< \brief Voltage  Droop request of 10 mV */
    IfxPmsPm_VoltageDroopStep_15mV = 3U,   /**< \brief Voltage  Droop request of 15 mV */
    IfxPmsPm_VoltageDroopStep_20mV = 4U,   /**< \brief Voltage  Droop request of 20 mV */
    IfxPmsPm_VoltageDroopStep_25mV = 5U,   /**< \brief Voltage  Droop request of 25 mV */
    IfxPmsPm_VoltageDroopStep_30mV = 6U,   /**< \brief Voltage  Droop request of 30 mV */
    IfxPmsPm_VoltageDroopStep_35mV = 7U,   /**< \brief Voltage  Droop request of 35 mV */
    IfxPmsPm_VoltageDroopStep_40mV = 8U,   /**< \brief Voltage  Droop request of 40 mV */
    IfxPmsPm_VoltageDroopStep_45mV = 9U,   /**< \brief Voltage  Droop request of 45 mV */
    IfxPmsPm_VoltageDroopStep_50mV = 10U,  /**< \brief Voltage  Droop request of 50 mV */
    IfxPmsPm_VoltageDroopStep_55mV = 11U,  /**< \brief Voltage  Droop request of 55 mV */
    IfxPmsPm_VoltageDroopStep_60mV = 12U,  /**< \brief Voltage  Droop request of 60 mV */
    IfxPmsPm_VoltageDroopStep_65mV = 13U,  /**< \brief Voltage  Droop request of 65 mV */
    IfxPmsPm_VoltageDroopStep_70mV = 14U,  /**< \brief Voltage  Droop request of 70 mV */
    IfxPmsPm_VoltageDroopStep_75mV = 15U   /**< \brief Voltage  Droop request of 75 mV */
} IfxPmsPm_VoltageDroopStep;

/** \brief Different voltage sources extrnally supplied to/inside AURIX2G
 */
typedef enum
{
    IfxPmsPm_VoltageSource_vdd    = 0,  /**< \brief 1.25V VDD voltage source(either from EVRC/supplied externally) */
    IfxPmsPm_VoltageSource_vddpd  = 2,  /**< \brief 1.25V VDDPD Pre-Regulator Voltage */
    IfxPmsPm_VoltageSource_vddp3  = 8,  /**< \brief 3.3V VDDP3(either generated by EVR33 or externally provided) */
    IfxPmsPm_VoltageSource_vddm   = 10, /**< \brief VDDM - Analog supply for ADCs */
    IfxPmsPm_VoltageSource_vext   = 16, /**< \brief VEXT(3.3V or 5V) external supply */
    IfxPmsPm_VoltageSource_vevrsb = 18  /**< \brief VEVRSB(3.3V or 5V) - Standby Domain Supply */
} IfxPmsPm_VoltageSource;

/** \brief Wake up configuration defined in Ifx_PMS.PMSW.CR0.B.ESRxWKEN,Ifx_PMS.PMSW.CR0.B.PINxWKEN
 * and Ifx_PMS.PMSW.CR0.B.PORSTWKEN
 */
typedef enum
{
    IfxPmsPm_WakeupOn_esr0  = 0,  /**< \brief ESR0 Wake-up enable from Standby */
    IfxPmsPm_WakeupOn_esr1  = 1,  /**< \brief ESR1 Wake-up enable from Standby */
    IfxPmsPm_WakeupOn_pinA  = 2,  /**< \brief PINA Wake-up enable from Standby */
    IfxPmsPm_WakeupOn_pinB  = 3,  /**< \brief PINB Wake-up enable from Standby */
    IfxPmsPm_WakeupOn_porst = 4,  /**< \brief PORST Wake-up enable from Standby */
    IfxPmsPm_WakeupOn_timer = 5,  /**< \brief WUT Wake-up enable from Standby */
    IfxPmsPm_WakeupOn_power = 6,  /**< \brief Power Wake-up enable  Standby */
    IfxPmsPm_WakeupOn_scr   = 7   /**< \brief SCR Wake-up enable from Standby */
} IfxPmsPm_WakeupOn;

/** \brief Select wakup timer operation mode
 * As defined in Ifx_PMS.PMSW.CR3.B.WUTMODE
 */
typedef enum
{
    IfxPmsPm_WakeupTimerMode_autoReload = 0,  /**< \brief WUT auto reload mode selected */
    IfxPmsPm_WakeupTimerMode_autoStop   = 1   /**< \brief WUT auto stop mode selected */
} IfxPmsPm_WakeupTimerMode;

/** \brief Clock for WUT
 */
typedef enum
{
    IfxPmsPm_WutClock_70kHz = 0,  /**< \brief WUT has a 70 kHz clock input */
    IfxPmsPm_WutClock_68Hz  = 1   /**< \brief Clock to WUT passes through a divider of 10 */
} IfxPmsPm_WutClock;

/** \} */

/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Pms_Std_Pm_DataStructures
 * \{ */
/** \brief Options for Load Jump
 */
typedef struct
{
    boolean enableLoadJumpTimer;                        /**< \brief Enable or disable Load Jump Timer */
    boolean enableLoadJumpTimerOverflowFlag;            /**< \brief Enable or disable update of Load Jump Timer Overflow Flag */
    boolean enableLoadJumpTimerOverflowInterrupt;       /**< \brief Enable or disable Load Jump Timer Overflow Interrupt */
} IfxPmsPm_LoadJumpConfig;

/** \brief Configurable options for sleep mode
 */
typedef struct
{
    boolean           mcanEnabled;              /**< \brief Whether MCAN will be enabled ir disabled during Sleep mode. */
    IfxScuCcu_Fsource mcanClockSource;          /**< \brief Clock Source for MCAN
                                                 * IfxScuCcu_Fsource_1 is f_source1 from K2 divider of Peripheral PLL
                                                 * IfxScuCcu_Fsource_2 is Oscillator clock bypassing the Peripheral PLL */
    boolean           asclinEnabled;            /**< \brief Whether ASCLIN will be enabled ir disabled during Sleep mode. */
    IfxScuCcu_Fsource asclinClockSource;        /**< \brief Clock Source for ASCLIN
                                                 * IfxScuCcu_Fsource_1 is f_source1 from K2 divider of Peripheral PLL
                                                 * IfxScuCcu_Fsource_2 is Oscillator clock bypassing the Peripheral PLL */
    boolean           gpt12Enabled;             /**< \brief Whether GPT12 will be enabled ir disabled during Sleep mode. */
    boolean           ccu6Enabled;              /**< \brief Whether CCU6 will be enabled ir disabled during Sleep mode. */
    boolean           qspiEnabled;              /**< \brief Whether QSPI will be enabled ir disabled during Sleep mode. */
    IfxScuCcu_Fsource qspiClockSource;          /**< \brief Clock Source for MCAN
                                                 * IfxScuCcu_Fsource_1 is f_source1 from K2 divider of Peripheral PLL
                                                 * IfxScuCcu_Fsource_2 is f_source2 from K3 divider of Peripheral PLL */
    boolean            gethEnabled;             /**< \brief Whether QSPI will be enabled ir disabled during Sleep mode. */
    boolean            i2cEnabled;              /**< \brief Whether I2C will be enabled ir disabled during Sleep mode. */
    boolean            gtmEnabled;              /**< \brief Whether GTM will be enabled ir disabled during Sleep mode. */
    boolean            stmEnabled;              /**< \brief Whether STM will be enabled ir disabled during Sleep mode. */
    IfxCpu_ResourceCpu masterCpu;               /**< \brief Core index of the master CPU */
} IfxPmsPm_SleepConfig;

/** \brief Configurable Standby options
 */
typedef struct
{
    IfxPmsPm_StandbyTriggerMode  trigger;                              /**< \brief Events which'll trigger Standby mode */
    IfxPmsPm_StandbyRamSupply    standbyRamBlock;                      /**< \brief Options for which part of the DLMU can be provided supply during standby. */
    boolean                      enableScr;                            /**< \brief Whether to enable SCR or not. */
    IfxPmsPm_ScrClocking         scrClockSupply;                       /**< \brief Options for SCR clock supply */
    IfxPmsPm_BlankingFilterDelay minDelayBeforeWakeUp;                 /**< \brief Selecting the duration, starting from Standby entry, after which wake-up triggers are effective. */
    IfxPmsPm_PadStateRequest     padStateRequest;                      /**< \brief Request to remain in input with weak pull-up or get into tristate. */
    IfxPmsPm_Esr0PinStateRequest esr0PinStateRequest;                  /**< \brief Request to remain in input with weak pull-up or get into tristate. */
    boolean                      enableStandbyOnVextRampDown;          /**< \brief Enable Standby On VEXT Ramp Down */
    boolean                      enableStandbyOnVddRampDown;           /**< \brief Enable Standby On VDD Ramp Down */
    float32                      vextUnderVoltageThresholdLevel;       /**< \brief Undervoltage threshold for VEXT */
    float32                      vddUnderVoltageThresholdLevel;        /**< \brief Undervoltage threshold for VDD */
    boolean                      enableWakeupOnEsr0;                   /**< \brief Enable wake-up on ESR0 */
    boolean                      enableWakeupOnEsr1;                   /**< \brief Enable wake-up on ESR1 */
    boolean                      enableWakeupOnPinA;                   /**< \brief Enable wake-up on PINA */
    boolean                      enableWakeupOnPinB;                   /**< \brief Enable wake-up on PINB */
    boolean                      enableWakeupOnTimer;                  /**< \brief Enable wake-up on Wake Up Timer(WUT) */
    boolean                      enableWakeupOnPorst;                  /**< \brief Enable wake-up on PORST pin assertion */
    boolean                      enableWakeupOnScr;                    /**< \brief Enable wake-up on request from SCR */
    uint8                        enableWakeupOnPower;                  /**< \brief Enable wake-up on VEXT ramp up. */
    boolean                      useWutStandbyAutoStopMode;            /**< \brief Use the Auto Stop mode in WUT */
    uint32                       wutReloadValue;                       /**< \brief The value from which the WUT will start downward count upon entering Standby */
    IfxPmsPm_WutClock            wutClock;                             /**< \brief Clock select for WUT */
    IfxPmsPm_DigitalFilter       esr0DigitalFilterUsage;               /**< \brief Whether to use didital filer withe interpreting the pulse on ESR0 pin */
    IfxPmsPm_DigitalFilter       pinADigitalFilterUsage;               /**< \brief Whether to use didital filer withe interpreting the pulse on PINA pin */
    IfxPmsPm_DigitalFilter       esr1DigitalFilterUsage;               /**< \brief Whether to use didital filer withe interpreting the pulse on ESR1 pin */
    IfxPmsPm_DigitalFilter       pinBDigitalFilterUsage;               /**< \brief Whether to use didital filer withe interpreting the pulse on PINB pin */
    IfxPmsPm_PinEdgeTriggerEvent esr0TriggerEvent;                     /**< \brief Trigger will be generated on which pulse edge of a pulse on ESR0 pin. */
    IfxPmsPm_PinEdgeTriggerEvent esr1TriggerEvent;                     /**< \brief Trigger will be generated on which pulse edge of a pulse on ESR1 pin. */
    IfxPmsPm_PinEdgeTriggerEvent pinATriggerEvent;                     /**< \brief Trigger will be generated on which pulse edge of a pulse on PINA pin. */
    IfxPmsPm_PinEdgeTriggerEvent pinBTriggerEvent;                     /**< \brief Trigger will be generated on which pulse edge of a pulse on PINB pin. */
    IfxCpu_ResourceCpu           masterCpu;                            /**< \brief CPU which can call powerdown modes.In IfxPmsPm_startStandbySequenceInFlash(),this value is being filled to reflect the core in which standby sequence is running as we're explicitly making it as the master CPU. */
} IfxPmsPm_StandbyConfig;

/** \brief Volatge Droop Configuration
 */
typedef struct
{
    boolean                      enableVoltageDroopTimer;                        /**< \brief Enable or disable usage of Voltage Droop Timer */
    boolean                      enableVoltageDroopTimerOverflowFlag;            /**< \brief Enable or disable usage of Voltage Droop Timer Overflow Flag */
    boolean                      enableVoltageDroopTimerOverflowInterrupt;       /**< \brief Enable or disable usage of Voltage Droop Interrupt */
    IfxPmsPm_VoltageDroopRequest droopRequestType;                               /**< \brief Type of Voltage Droop Request */
    IfxPmsPm_VoltageDroopStep    droopStep;                                      /**< \brief Value by which voltage change must happen */
} IfxPmsPm_VoltageDroopConfig;

/** \brief Configure Wakeup in standby mode
 */
typedef struct
{
    IfxPmsPm_WakeupOn             wakeup;              /**< \brief wake-up configuration */
    IfxPmsPm_DigitalFilter        filter;              /**< \brief bypass/use digital filter */
    IfxPmsPm_EdgeDetectionControl trigger;             /**< \brief Enable Wake-up on rising or falling edge */
    IfxPmsPm_StandbyRamSupply     standbyRam;          /**< \brief RAM being supply during standby mode */
    IfxPmsPm_WakeupTimerMode      mode;                /**< \brief wake-up timer mode */
    uint32                        reloadCounter;       /**< \brief reload count from where value starts counting down used in case of WUT configuration */
} IfxPmsPm_WakeupConfig;

/** \} */

/** \addtogroup IfxLld_Pms_Std_Pm_SystemModes
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief set system into sleep mode
 * \param powerMode Select System power mode
 * \return None
 *
 * IfxPmsPm_setSleepMode(IfxPmsPm_RequestPowerMode_idle);
 *
 */
static inline void IfxPmsPm_setSleepMode(IfxPmsPm_RequestPowerMode powerMode);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief set system into stand by mode
 * Note: In this API Alarm has been disabled.Enable of SMU alarm has to be taken care
 * seprately at application level
 * \param pms Pointer to Module Space
 * \param config Pointer to Wakeup configuration Structure
 * \param powerMode Selects System standby mode
 * \return None
 *
 * IfxPmsPm_WakeupConfig config;
 * config.wakeup =IfxPmsPm_WakeupOn_esr1;           //Wakeup using ESR1
 * config.filter      = IfxPmsPm_DigitalFilter_used;     //Digital Filter is used
 * config.trigger     = IfxPmsPm_EdgeDetectionControl_onRisingEdge; //Trigger is generated upon rising edge
 * config.standbyRam  = IfxPmsPm_StandbyRamSupply_cpu0Block0; // Standby RAM (CPU0 dLMU RAM Block 0) is supplied
 * IfxPmsPm_setStandbyMode(&MODULE_PMS,&config, IfxPmsPm_RequestPowerMode_standby);
 *
 */
extern void IfxPmsPm_setStandbyMode(Ifx_PMS *pms, IfxPmsPm_WakeupConfig *config, IfxPmsPm_RequestPowerMode powerMode);

/** \brief This function will initialize the configuration structure with default values.
 * NOTE:
 *
 * 1. Default values of vextUnderVoltageThresholdLevel and vddUnderVoltageThresholdLevel in the StandbyConfig structure are set to 0.
 * Set it to appropriate levels(depending on application) before calling IfxPmsPm_startStandbySequenceInFlash().
 * \param standbyConfig Configurable options for Standby Mode
 * \return None
 */
extern void IfxPmsPm_initStandbyConfig(IfxPmsPm_StandbyConfig *standbyConfig);

/**
 * \param standbyConfig Configuration structure with initialized Standby configuration options
 * \param clockConfig Clock Configuration, with frequency ramp-up/down sequence
 * \return None
 */
extern void IfxPmsPm_startStandbySequenceInFlash(IfxPmsPm_StandbyConfig *standbyConfig, const IfxScuCcu_Config *clockConfig);

/**
 * \param standbyConfig Configuration structure with initialized Standby configuration options
 * \param clockConfig Clock Configuration, with frequency ramp-up/down sequence
 * \return None
 */
extern void IfxPmsPm_continueStandbySequenceInRAM(IfxPmsPm_StandbyConfig *standbyConfig, const IfxScuCcu_Config *clockConfig);

/**
 * \param sleepConfig Configurable options for sleep mode
 * \return None
 */
extern void IfxPmsPm_initSleepConfig(IfxPmsPm_SleepConfig *sleepConfig);

/**
 * \param sleepConfig Configurable options for sleep mode
 * \param clockConfig
 * \return None
 */
extern void IfxPmsPm_startSleepSequenceinFlash(IfxPmsPm_SleepConfig *sleepConfig, IfxScuCcu_Config *clockConfig);

/** \brief This is to be placed in PSPR of the Master CPU
 * \param sleepConfig Configurable options for sleep mode
 * \return None
 */
extern void IfxPmsPm_continueSleepSequenceInRAM(IfxPmsPm_SleepConfig *sleepConfig);

/** \} */

/** \addtogroup IfxLld_Pms_Std_Pm_CpuModes
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Set a given CPU as a Master CPU i.e. ability to trigger power down modes
 * \param cpuIndex Index to identify different CPU cores
 * \return None
 */
static inline void IfxPmsPm_setMasterCpu(IfxCpu_ResourceCpu cpuIndex);

/** \brief Gets the index of Master CPU
 */
static inline IfxCpu_ResourceCpu IfxPmsPm_getMasterCpu(void);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Set core mode(Idle/Run)
 * \param cpuIndex specifies cpu index
 * \param mode Select mode to be set to put CPU into IDLE/RUN State
 * \return TRUE: If activity successfully performed
 * FALSE: If Activity is not performed successfully
 *
 * IfxCpu_setCoreMode(&MODULE_CPU0, IfxCpu_CoreMode_idle);
 *
 */
extern boolean IfxPmsPm_setCoreMode(IfxCpu_ResourceCpu cpuIndex, IfxCpu_CoreMode mode);

/** \} */

/** \addtogroup IfxLld_Pms_Std_Pm_WakeupModes
 * \{ */

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Enable Wakeup using PORST/ESR1/PINA/PINB/WUT/SCR/Power
 * \param pms Pointer to PMS Module space
 * \param wakeup Pointer to  wakeup configuration strucutre
 * \return None
 */
extern void IfxPmsPm_enableWakeup(Ifx_PMS *pms, IfxPmsPm_WakeupConfig *wakeup);

/**
 * \param standbyConfig Pointer to Standby Configuration Structure
 * \return None
 */
extern void IfxPmsPm_configureWakeup(IfxPmsPm_StandbyConfig *standbyConfig);

/**
 * \return None
 */
extern void IfxPmsPm_initiateWakeup(IfxScuCcu_Config *clockConfig);

/** \} */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Enables the usage of load jump timer
 * \return None
 */
static inline void IfxPmsPm_enableLoadJumpTimer(void);

/** \brief Disables the usage of load jump timer
 * \return None
 */
static inline void IfxPmsPm_disableLoadJumpTimer(void);

/** \brief Enables the update of SCU_PMTRCSR2.B.LJTOV status bit on timer overflow or timeout.
 * \return None
 */
static inline void IfxPmsPm_enableLoadJumpTimerOverflowFlag(void);

/** \brief Disables the update of SCU_PMTRCSR2.B.LJTOV status bit on timer overflow or timeout.
 * \return None
 */
static inline void IfxPmsPm_disableLoadJumpTimerOverflowFlag(void);

/** \brief Enables the activation of interrupt on timer overflow or timeout.
 * \return None
 */
static inline void IfxPmsPm_enableLoadJumpTimerOverflowInterrupt(void);

/** \brief Disables the activation of interrupt on timer overflow or timeout.
 * \return None
 */
static inline void IfxPmsPm_disableLoadJumpTimerOverflowInterrupt(void);

/** \brief Starts Load jump timer. The SCU_PMTRCSR0.B.LJTSTRT bitfield remains set on a write and is cleared when SCU_PMTRCSR2.B.LJTOV bit is set if SCU_PMTRCSR0.B.LJTOVEN bit is enabled(Update of Load Jump Timer Overflow Flag SCU_PMTRCSR2.B.LJTOV is enabled ).
 * \return None
 */
static inline void IfxPmsPm_startLoadJumpTimer(void);

/** \brief This stops the Load jump timer. The Load Jump Timer stops counter at the current value and timer
 * re-starts from that value when LJTSTP is cleared and LJTSTRT is set.
 * \return None
 */
static inline void IfxPmsPm_stopLoadJumpTimer(void);

/** \brief Clears the Load Jump timer count
 * \return None
 */
static inline void IfxPmsPm_clearLoadJumpTimer(void);

/** \brief Clears Load Jump Timer Overflow Flag (SCU_PMTRCSR2.B.LJTOV) and sets PMTRCSR3.B.VDROOPREQ and PMTRCSR2.B.LDJMPREQ to
 * 0 if Load Jump Timer Overflow Flag bit is enabled
 * \return None
 */
static inline void IfxPmsPm_clearLoadJumpTimerOverflowFlag(void);

/** \brief Returns status of Load Jump Timer Overflow condition
 * \return Status of Load Jump Timer Overflow condition
 */
static inline boolean IfxPmsPm_hasLoadJumpTimerOverflowOccured(void);

/** \brief Loads the compare value for Load Jump Timer in SCU_PMTRCSR1.B.LJTCV
 * When the Timer count reaches this value, overflow condition occurs and the respective flag and interrupt occurs, if enabled
 * \param compareValue Compare value for Load Jump Timer
 * \return None
 */
static inline void IfxPmsPm_setLoadJumpTimerCompareValue(uint16 compareValue);

/** \brief Reads the Load Jump Timer Compare value
 * \return Load Jump Timer compare value
 */
static inline uint16 IfxPmsPm_getLoadJumpTimerCompareValue(void);

/** \brief Returns the Load Jump Timer count value
 * \return Load Jump Timer count value
 */
static inline uint16 IfxPmsPm_getLoadJumpTimerCountValue(void);

/** \brief Issues a Load Jump request
 * \return None
 */
static inline void IfxPmsPm_requestLoadJump(void);

/** \brief Returns the status of Load Jump request
 * \return Load Jump request status
 */
static inline IfxPmsPm_LoadJumpStatus IfxPmsPm_getLoadJumpStatus(void);

/** \brief Enables the usage of Voltage Droop Timer
 * \return None
 */
static inline void IfxPmsPm_enableVoltageDroopTimer(void);

/** \brief Enables the update of Voltage Droop Timer Overflow Flag on timer overflow or timeout.
 * \return None
 */
static inline void IfxPmsPm_enableVoltageDroopTimerOverflowFlag(void);

/** \brief Enables the activation of interrupt on timer overflow or timeout.
 * \return None
 */
static inline void IfxPmsPm_enableVoltageDroopTimerOverflowInterrupt(void);

/** \brief Disables the usage of Voltage Droop Timer
 * \return None
 */
static inline void IfxPmsPm_disableVoltageDroopTimer(void);

/** \brief Disables the update of Voltage Droop Timer Overflow Flag on timer overflow or timeout.
 * \return None
 */
static inline void IfxPmsPm_disableVoltageDroopTimerOverflowFlag(void);

/** \brief Disables the activation of interrupt on timer overflow or timeout.
 * \return None
 */
static inline void IfxPmsPm_disableVoltageDroopTimerOverflowInterrupt(void);

/** \brief Starts Voltage Droop timer
 * \return None
 */
static inline void IfxPmsPm_startVoltageDroopTimer(void);

/** \brief Stops Voltage Droop timer and SCU cancels the droop request.
 * \return None
 */
static inline void IfxPmsPm_stopVoltageDroopTimer(void);

/** \brief Clear Voltage Droop timer count. Resets the Voltage Droop Timer and clears VDTRUN if usage of Voltage Droop Timer is enabled.
 * \return None
 */
static inline void IfxPmsPm_clearVoltageDroopTimer(void);

/** \brief Clears Voltage Droop Timer Overflow Flag if Overflow Flag is enabled
 * \return None
 */
static inline void IfxPmsPm_clearVoltageDroopTimerOverflowFlag(void);

/** \brief Returns Status of Voltage Droop Time overflow condition
 * \return Status of Voltage Droop Time overflow
 */
static inline boolean IfxPmsPm_hasVoltageDroopTimerOverflowOccured(void);

/** \brief Loads the compare value for Voltage Droop Timer in SCU_PMTRCSR1.B.VDTCV
 * When the Timer count reaches this value, overflow condition occurs and the respective flag and interrupt occurs, if enabled
 * \param compareValue Voltage Droop Timer Compare Value
 * \return None
 */
static inline void IfxPmsPm_setVoltageDroopTimerCompareValue(uint16 compareValue);

/** \brief Reads the Voltage Droop Timer Compare Value
 * \return Voltage Droop Timer Compare Value
 */
static inline uint16 IfxPmsPm_getVoltageDroopTimerCompareValue(void);

/** \brief Gives Voltage Droop Timer count value
 * \return Voltage Droop Timer Count Value
 */
static inline uint16 IfxPmsPm_readVoltageDroopTimerCountValue(void);

/** \brief Issue a voltage droop request
 * \param droopRequest Type of Voltage Droop Request
 * \return None
 */
static inline void IfxPmsPm_requestVoltageDroop(IfxPmsPm_VoltageDroopRequest droopRequest);

/** \brief Returns the status of Load Jump request
 * \return Voltage Droop request status
 */
static inline IfxPmsPm_VoltageDroopStatus IfxPmsPm_getVoltageDroopStatus(void);

/** \brief Loads the amount by which voltage will be requested to change
 * \param droopStep The amount why by voltage change is requested
 * \return None
 */
static inline void IfxPmsPm_setVoltageDroopStep(IfxPmsPm_VoltageDroopStep droopStep);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/**
 * \param pms Pointer to PMS SFRs
 * \param source Voltage source to be monitored
 * \param event Type of event to be monitored.
 * \param mode Ramping directions on which event needs to be detected.
 * \return None
 */
extern void IfxPmsPm_configureSupplyMonitoring(Ifx_PMS *pms, IfxPmsPm_VoltageSource source, IfxPmsPm_ThresholdEvent event, IfxPmsPm_RampingMode mode);

/**
 * \param loadJumpConfig Initialize the Load Jump configuration
 * \return None
 */
extern void IfxPmsPm_initLoadJumpConfig(IfxPmsPm_LoadJumpConfig *loadJumpConfig);

/**
 * \return None
 */
extern void IfxPmsPm_initAndRequestLoadJump(IfxPmsPm_LoadJumpConfig *loadJumpConfig);

/**
 * \return None
 */
extern void IfxPmsPm_initVoltageDroopConfig(IfxPmsPm_VoltageDroopConfig *voltageDroopConfig);

/**
 * \param voltageDroopConfig Voltage Droop Configuration Structure
 * \return None
 */
extern void IfxPmsPm_initAndRequestVoltageDroop(IfxPmsPm_VoltageDroopConfig *voltageDroopConfig);

/** \brief Copies dataSize bytes of data to standby RAM starting at dataPointer and appends the CRC over the copied data to it.
 * \param dataPointer Pointer to beginning of the region containing addresses of the data to be saved.
 * This is in standby RAM
 * \param dataSize Total size(in units of 32 bit word) of the data to be copied
 * \return None
 */
extern void IfxPmsPm_handleStandbyRam(uint32 *dataPointer, uint8 dataSize);

/******************************************************************************/
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

static inline void IfxPmsPm_setSleepMode(IfxPmsPm_RequestPowerMode powerMode)
{
    uint16 cpuWdtPw = IfxScuWdt_getCpuWatchdogPassword();

    uint8  index    = IfxCpu_getCoreIndex();
    IfxScuWdt_clearCpuEndinit(cpuWdtPw);

    switch (index)
    {
    case 0:
        ((*(Ifx_SCU*)0xF0036000u)).PMCSR0.B.REQSLP = powerMode;
        break;
    case 1:
        ((*(Ifx_SCU*)0xF0036000u)).PMCSR1.B.REQSLP = powerMode;
        break;
    case 2:
        ((*(Ifx_SCU*)0xF0036000u)).PMCSR2.B.REQSLP = powerMode;
        break;
    case 3:
        ((*(Ifx_SCU*)0xF0036000u)).PMCSR3.B.REQSLP = powerMode;
        break;
    }

    IfxScuWdt_setCpuEndinit(cpuWdtPw);
}


static inline void IfxPmsPm_setMasterCpu(IfxCpu_ResourceCpu cpuIndex)
{
    uint16 endinitSfty_pw;
    /*get the watch-dog passwords for usage with this function*/
    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPasswordInline();
    /* Reset Safety ENDINIT, SCU_CCUCON registers are protected*/
    IfxScuWdt_clearSafetyEndinitInline(endinitSfty_pw);
    ((*(Ifx_SCU*)0xF0036000u)).PMSWCR1.B.CPUSEL = cpuIndex + 1; //check if it's xENDINIT protected
    IfxScuWdt_setSafetyEndinitInline(endinitSfty_pw);
}


static inline IfxCpu_ResourceCpu IfxPmsPm_getMasterCpu(void)
{
    return (IfxCpu_ResourceCpu)(((*(Ifx_SCU*)0xF0036000u)).PMSWCR1.B.CPUSEL - 1);
}


static inline void IfxPmsPm_enableLoadJumpTimer(void)
{
    uint16 safetyWdtPw = IfxScuWdt_getSafetyWatchdogPassword();
    IfxScuWdt_clearSafetyEndinit(safetyWdtPw);
    (*(volatile Ifx_SCU_PMTRCSR0*)0xF0036198u).B.LJTEN = 1;
    IfxScuWdt_setSafetyEndinit(safetyWdtPw);
}


static inline void IfxPmsPm_disableLoadJumpTimer(void)
{
    uint16 safetyWdtPw = IfxScuWdt_getSafetyWatchdogPassword();
    IfxScuWdt_clearSafetyEndinit(safetyWdtPw);
    (*(volatile Ifx_SCU_PMTRCSR0*)0xF0036198u).B.LJTEN = 0;
    IfxScuWdt_setSafetyEndinit(safetyWdtPw);
}


static inline void IfxPmsPm_enableLoadJumpTimerOverflowFlag(void)
{
    uint16 safetyWdtPw = IfxScuWdt_getSafetyWatchdogPassword();
    IfxScuWdt_clearSafetyEndinit(safetyWdtPw);
    (*(volatile Ifx_SCU_PMTRCSR0*)0xF0036198u).B.LJTOVEN = 1;
    IfxScuWdt_setSafetyEndinit(safetyWdtPw);
}


static inline void IfxPmsPm_disableLoadJumpTimerOverflowFlag(void)
{
    uint16 safetyWdtPw = IfxScuWdt_getSafetyWatchdogPassword();
    IfxScuWdt_clearSafetyEndinit(safetyWdtPw);
    (*(volatile Ifx_SCU_PMTRCSR0*)0xF0036198u).B.LJTOVEN = 0;
    IfxScuWdt_setSafetyEndinit(safetyWdtPw);
}


static inline void IfxPmsPm_enableLoadJumpTimerOverflowInterrupt(void)
{
    uint16 safetyWdtPw = IfxScuWdt_getSafetyWatchdogPassword();
    IfxScuWdt_clearSafetyEndinit(safetyWdtPw);
    (*(volatile Ifx_SCU_PMTRCSR0*)0xF0036198u).B.LJTOVIEN = 1;
    IfxScuWdt_setSafetyEndinit(safetyWdtPw);
}


static inline void IfxPmsPm_disableLoadJumpTimerOverflowInterrupt(void)
{
    uint16 safetyWdtPw = IfxScuWdt_getSafetyWatchdogPassword();
    IfxScuWdt_clearSafetyEndinit(safetyWdtPw);
    (*(volatile Ifx_SCU_PMTRCSR0*)0xF0036198u).B.LJTOVIEN = 0;
    IfxScuWdt_setSafetyEndinit(safetyWdtPw);
}


static inline void IfxPmsPm_startLoadJumpTimer(void)
{
    uint16 safetyWdtPw = IfxScuWdt_getSafetyWatchdogPassword();
    IfxScuWdt_clearSafetyEndinit(safetyWdtPw);
    (*(volatile Ifx_SCU_PMTRCSR0*)0xF0036198u).B.LJTSTRT = 1;
    IfxScuWdt_setSafetyEndinit(safetyWdtPw);
}


static inline void IfxPmsPm_stopLoadJumpTimer(void)
{
    uint16 safetyWdtPw = IfxScuWdt_getSafetyWatchdogPassword();
    IfxScuWdt_clearSafetyEndinit(safetyWdtPw);
    (*(volatile Ifx_SCU_PMTRCSR0*)0xF0036198u).B.LJTSTP = 1;
    IfxScuWdt_setSafetyEndinit(safetyWdtPw);
}


static inline void IfxPmsPm_clearLoadJumpTimer(void)
{
    uint16 safetyWdtPw = IfxScuWdt_getSafetyWatchdogPassword();
    IfxScuWdt_clearSafetyEndinit(safetyWdtPw);
    (*(volatile Ifx_SCU_PMTRCSR0*)0xF0036198u).B.LJTCLR = 1;
    IfxScuWdt_setSafetyEndinit(safetyWdtPw);
}


static inline void IfxPmsPm_clearLoadJumpTimerOverflowFlag(void)
{
    uint16 safetyWdtPw = IfxScuWdt_getSafetyWatchdogPassword();
    IfxScuWdt_clearSafetyEndinit(safetyWdtPw);
    (*(volatile Ifx_SCU_PMTRCSR2*)0xF00361A0u).B.LJTOVCLR = 1;
    IfxScuWdt_setSafetyEndinit(safetyWdtPw);
}


static inline boolean IfxPmsPm_hasLoadJumpTimerOverflowOccured(void)
{
    return (boolean)(*(volatile Ifx_SCU_PMTRCSR2*)0xF00361A0u).B.LJTOV;
}


static inline void IfxPmsPm_setLoadJumpTimerCompareValue(uint16 compareValue)
{
    uint16 safetyWdtPw = IfxScuWdt_getSafetyWatchdogPassword();
    IfxScuWdt_clearSafetyEndinit(safetyWdtPw);
    (*(volatile Ifx_SCU_PMTRCSR1*)0xF003619Cu).B.LJTCV = compareValue;
    IfxScuWdt_setSafetyEndinit(safetyWdtPw);
}


static inline uint16 IfxPmsPm_getLoadJumpTimerCompareValue(void)
{
    return (uint16)(*(volatile Ifx_SCU_PMTRCSR1*)0xF003619Cu).B.LJTCV;
}


static inline uint16 IfxPmsPm_getLoadJumpTimerCountValue(void)
{
    return (uint16)(*(volatile Ifx_SCU_PMTRCSR2*)0xF00361A0u).B.LJTCNT;
}


static inline void IfxPmsPm_requestLoadJump(void)
{
    uint16 safetyWdtPw = IfxScuWdt_getSafetyWatchdogPassword();
    IfxScuWdt_clearSafetyEndinit(safetyWdtPw);
    (*(volatile Ifx_SCU_PMTRCSR2*)0xF00361A0u).B.LDJMPREQ = 1U;
    IfxScuWdt_setSafetyEndinit(safetyWdtPw);
}


static inline IfxPmsPm_LoadJumpStatus IfxPmsPm_getLoadJumpStatus(void)
{
    return (IfxPmsPm_LoadJumpStatus)(*(volatile Ifx_SCU_PMTRCSR2*)0xF00361A0u).B.LJTRUN;
}


static inline void IfxPmsPm_enableVoltageDroopTimer(void)
{
    uint16 safetyWdtPw = IfxScuWdt_getSafetyWatchdogPassword();
    IfxScuWdt_clearSafetyEndinit(safetyWdtPw);
    (*(volatile Ifx_SCU_PMTRCSR0*)0xF0036198u).B.VDTEN = 1;
    IfxScuWdt_setSafetyEndinit(safetyWdtPw);
}


static inline void IfxPmsPm_enableVoltageDroopTimerOverflowFlag(void)
{
    uint16 safetyWdtPw = IfxScuWdt_getSafetyWatchdogPassword();
    IfxScuWdt_clearSafetyEndinit(safetyWdtPw);
    (*(volatile Ifx_SCU_PMTRCSR0*)0xF0036198u).B.VDTOVEN = 1;
    IfxScuWdt_setSafetyEndinit(safetyWdtPw);
}


static inline void IfxPmsPm_enableVoltageDroopTimerOverflowInterrupt(void)
{
    uint16 safetyWdtPw = IfxScuWdt_getSafetyWatchdogPassword();
    IfxScuWdt_clearSafetyEndinit(safetyWdtPw);
    (*(volatile Ifx_SCU_PMTRCSR0*)0xF0036198u).B.VDTOVIEN = 1;
    IfxScuWdt_setSafetyEndinit(safetyWdtPw);
}


static inline void IfxPmsPm_disableVoltageDroopTimer(void)
{
    uint16 safetyWdtPw = IfxScuWdt_getSafetyWatchdogPassword();
    IfxScuWdt_clearSafetyEndinit(safetyWdtPw);
    (*(volatile Ifx_SCU_PMTRCSR0*)0xF0036198u).B.VDTEN = 0;
    IfxScuWdt_setSafetyEndinit(safetyWdtPw);
}


static inline void IfxPmsPm_disableVoltageDroopTimerOverflowFlag(void)
{
    uint16 safetyWdtPw = IfxScuWdt_getSafetyWatchdogPassword();
    IfxScuWdt_clearSafetyEndinit(safetyWdtPw);
    (*(volatile Ifx_SCU_PMTRCSR0*)0xF0036198u).B.VDTOVEN = 0;
    IfxScuWdt_setSafetyEndinit(safetyWdtPw);
}


static inline void IfxPmsPm_disableVoltageDroopTimerOverflowInterrupt(void)
{
    uint16 safetyWdtPw = IfxScuWdt_getSafetyWatchdogPassword();
    IfxScuWdt_clearSafetyEndinit(safetyWdtPw);
    (*(volatile Ifx_SCU_PMTRCSR0*)0xF0036198u).B.VDTOVIEN = 0;
    IfxScuWdt_setSafetyEndinit(safetyWdtPw);
}


static inline void IfxPmsPm_startVoltageDroopTimer(void)
{
    uint16 safetyWdtPw = IfxScuWdt_getSafetyWatchdogPassword();
    IfxScuWdt_clearSafetyEndinit(safetyWdtPw);
    (*(volatile Ifx_SCU_PMTRCSR0*)0xF0036198u).B.VDTSTRT = 1;
    IfxScuWdt_setSafetyEndinit(safetyWdtPw);
}


static inline void IfxPmsPm_stopVoltageDroopTimer(void)
{
    uint16 safetyWdtPw = IfxScuWdt_getSafetyWatchdogPassword();
    IfxScuWdt_clearSafetyEndinit(safetyWdtPw);
    (*(volatile Ifx_SCU_PMTRCSR0*)0xF0036198u).B.VDTSTP = 1;
    IfxScuWdt_setSafetyEndinit(safetyWdtPw);
}


static inline void IfxPmsPm_clearVoltageDroopTimer(void)
{
    uint16 safetyWdtPw = IfxScuWdt_getSafetyWatchdogPassword();
    IfxScuWdt_clearSafetyEndinit(safetyWdtPw);
    (*(volatile Ifx_SCU_PMTRCSR0*)0xF0036198u).B.VDTCLR = 1;
    IfxScuWdt_setSafetyEndinit(safetyWdtPw);
}


static inline void IfxPmsPm_clearVoltageDroopTimerOverflowFlag(void)
{
    uint16 safetyWdtPw = IfxScuWdt_getSafetyWatchdogPassword();
    IfxScuWdt_clearSafetyEndinit(safetyWdtPw);
    (*(volatile Ifx_SCU_PMTRCSR3*)0xF00361A4u).B.VDTOVCLR = 1;
    IfxScuWdt_setSafetyEndinit(safetyWdtPw);
}


static inline boolean IfxPmsPm_hasVoltageDroopTimerOverflowOccured(void)
{
    return (boolean)(*(volatile Ifx_SCU_PMTRCSR3*)0xF00361A4u).B.VDTOV;
}


static inline void IfxPmsPm_setVoltageDroopTimerCompareValue(uint16 compareValue)
{
    uint16 safetyWdtPw = IfxScuWdt_getSafetyWatchdogPassword();
    IfxScuWdt_clearSafetyEndinit(safetyWdtPw);
    (*(volatile Ifx_SCU_PMTRCSR1*)0xF003619Cu).B.VDTCV = compareValue;
    IfxScuWdt_setSafetyEndinit(safetyWdtPw);
}


static inline uint16 IfxPmsPm_getVoltageDroopTimerCompareValue(void)
{
    return (uint16)(*(volatile Ifx_SCU_PMTRCSR1*)0xF003619Cu).B.VDTCV;
}


static inline uint16 IfxPmsPm_readVoltageDroopTimerCountValue(void)
{
    return (uint16)(*(volatile Ifx_SCU_PMTRCSR3*)0xF00361A4u).B.VDTCNT;
}


static inline void IfxPmsPm_requestVoltageDroop(IfxPmsPm_VoltageDroopRequest droopRequest)
{
    uint16 safetyWdtPw = IfxScuWdt_getSafetyWatchdogPassword();
    IfxScuWdt_clearSafetyEndinit(safetyWdtPw);
    (*(volatile Ifx_SCU_PMTRCSR3*)0xF00361A4u).B.VDROOPREQ = droopRequest;
    IfxScuWdt_setSafetyEndinit(safetyWdtPw);
}


static inline IfxPmsPm_VoltageDroopStatus IfxPmsPm_getVoltageDroopStatus(void)
{
    return (IfxPmsPm_VoltageDroopStatus)(*(volatile Ifx_SCU_PMTRCSR3*)0xF00361A4u).B.VDTRUN;
}


static inline void IfxPmsPm_setVoltageDroopStep(IfxPmsPm_VoltageDroopStep droopStep)
{
    uint16 safetyWdtPw = IfxScuWdt_getSafetyWatchdogPassword();
    IfxScuWdt_clearSafetyEndinit(safetyWdtPw);
    (*(volatile Ifx_SCU_PMTRCSR0*)0xF0036198u).B.SDSTEP = droopStep;
    IfxScuWdt_setSafetyEndinit(safetyWdtPw);
}



#line 49 "D:/RTOS_PROJEKT/erica/aurix_workspace/can_erika/ee/../Libraries/iLLD/TC38A/Tricore/Cpu/Std/IfxCpu.c"

/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

boolean IfxCpu_acquireMutex(IfxCpu_mutexLock *lock)
{
    boolean         retVal;
    volatile uint32 spinLockVal;

    retVal      = (0u);

    spinLockVal = 1UL;
    spinLockVal =
        (uint32)__cmpswapw((((unsigned int *)lock)), ((unsigned long)spinLockVal), (0) );

    /* Check if the SpinLock WAS set before the attempt to acquire spinlock */
    if (spinLockVal == 0)
    {
        retVal = (1u);
    }

    return retVal;
}


void IfxCpu_disableOverlayBlock(IfxCpu_ResourceCpu cpu, uint16 overlayBlock)
{
    Ifx_CPU          *ovcSfrBase = ((void *)0);

    Ifx_SCU_OVCCON    ovccon;
    Ifx_SCU_OVCENABLE ovcenable;
    uint16            safetyWdtPw = IfxScuWdt_getSafetyWatchdogPassword();
    IfxScuWdt_clearSafetyEndinit(safetyWdtPw);
    ovccon.U    = ((*(Ifx_SCU*)0xF0036000u)).OVCCON.U;
    ovcenable.U = ((*(Ifx_SCU*)0xF0036000u)).OVCENABLE.U;

    /* Disable Overlay in SCU */
    switch (cpu)
    {
    case IfxCpu_ResourceCpu_1:
        ovcSfrBase        = &((*(Ifx_CPU*)0xF8820000u));
        ovcenable.B.OVEN1 = 0;
        ovccon.B.CSEL1    = 0;
        break;
    case IfxCpu_ResourceCpu_2:
        ovcSfrBase        = &((*(Ifx_CPU*)0xF8840000u));
        ovcenable.B.OVEN2 = 0;
        ovccon.B.CSEL2    = 0;
        break;

    case IfxCpu_ResourceCpu_3:
        ovcSfrBase        = &((*(Ifx_CPU*)0xF8860000u));
        ovcenable.B.OVEN3 = 0;
        ovccon.B.CSEL3    = 0;
        break;
    default:
        ovcSfrBase        = &((*(Ifx_CPU*)0xF8800000u));
        ovcenable.B.OVEN0 = 0;
        ovccon.B.CSEL0    = 0;
        break;
    }

    ovccon.B.OVSTP         = 1;
    ovccon.B.DCINVAL       = 1;
    ((*(Ifx_SCU*)0xF0036000u)).OVCCON.U    = ovccon.U;
    ((*(Ifx_SCU*)0xF0036000u)).OVCENABLE.U = ovcenable.U;
    IfxScuWdt_setSafetyEndinit(safetyWdtPw);

    ovcSfrBase->BLK[overlayBlock].RABR.U  = 0;
    ovcSfrBase->BLK[overlayBlock].OTAR.U  = 0;
    ovcSfrBase->BLK[overlayBlock].OMASK.U = 0;
}


void IfxCpu_enableOverlayBlock(IfxCpu_ResourceCpu cpu, uint16 overlayBlock, IfxCpu_OverlayMemorySelect overlayMemorySelect, IfxCpu_OverlayAddressMask overlayAddressMask, uint32 targetBaseAddress, uint32 overlayBaseAddress)
{
    Ifx_CPU *ovcSfrBase = ((void *)0);

    switch (cpu)
    {
    case IfxCpu_ResourceCpu_1:
        ovcSfrBase = &((*(Ifx_CPU*)0xF8820000u));
        break;
    case IfxCpu_ResourceCpu_2:
        ovcSfrBase = &((*(Ifx_CPU*)0xF8840000u));
        break;

    case IfxCpu_ResourceCpu_3:
        ovcSfrBase = &((*(Ifx_CPU*)0xF8860000u));
        break;

    default:
        ovcSfrBase = &((*(Ifx_CPU*)0xF8800000u));
        break;
    }

    /* Select overlay Block */
    ovcSfrBase->OSEL.U |= 1 << overlayBlock;

    /* Configure ovcBlock */
    Ifx_CPU_BLK_RABR rabr;
    Ifx_CPU_BLK_OTAR otar;
    rabr.U                                = 0;
    rabr.B.OMEM                           = overlayMemorySelect;
    rabr.B.OBASE                          = overlayBaseAddress >> 5;

    otar.U                                = 0;
    otar.B.TBASE                          = targetBaseAddress >> 5;

    ovcSfrBase->BLK[overlayBlock].RABR.U  = rabr.U;
    ovcSfrBase->BLK[overlayBlock].OTAR.U  = otar.U;
    ovcSfrBase->BLK[overlayBlock].OMASK.U = ((overlayAddressMask << 5) & 0x0001FFE0);

    /* Enable Overlay in SCU */
    uint16         safetyWdtPw = IfxScuWdt_getSafetyWatchdogPassword();
    IfxScuWdt_clearSafetyEndinit(safetyWdtPw);
    Ifx_SCU_OVCCON ovccon;
    ovccon.U = ((*(Ifx_SCU*)0xF0036000u)).OVCCON.U;

    switch (cpu)
    {
    case IfxCpu_ResourceCpu_1:
        ((*(Ifx_SCU*)0xF0036000u)).OVCENABLE.B.OVEN1 = 1;
        ovccon.B.CSEL1               = 1;
        break;
    case IfxCpu_ResourceCpu_2:
        ((*(Ifx_SCU*)0xF0036000u)).OVCENABLE.B.OVEN2 = 1;
        ovccon.B.CSEL2               = 1;
        break;
    case IfxCpu_ResourceCpu_3:
        ((*(Ifx_SCU*)0xF0036000u)).OVCENABLE.B.OVEN3 = 1;
        ovccon.B.CSEL3               = 1;
        break;
    default:
        ((*(Ifx_SCU*)0xF0036000u)).OVCENABLE.B.OVEN0 = 1;
        ovccon.B.CSEL0               = 1;
        break;
    }

    ovccon.B.OVSTRT     = 1;
    ((*(Ifx_SCU*)0xF0036000u)).OVCCON.U = ovccon.U;
    IfxScuWdt_setSafetyEndinit(safetyWdtPw);
}


IfxCpu_CoreMode IfxCpu_getCoreMode(Ifx_CPU *cpu)
{
    IfxCpu_CoreMode          cpuMode;
    Ifx_CPU_DBGSR            dbgsr;
    IfxCpu_ResourceCpu       index = IfxCpu_getIndex(cpu);

    volatile Ifx_SCU_PMCSR0 *pmcsr_val0;
    volatile Ifx_SCU_PMCSR1 *pmcsr_val1;
    volatile Ifx_SCU_PMCSR2 *pmcsr_val2;
    volatile Ifx_SCU_PMCSR3 *pmcsr_val3;
    cpuMode = IfxCpu_CoreMode_unknown;

    /*get the DBGSR.HALT status */
    /*Check if the request is done for same cpu as the host for this call */
    if (IfxCpu_getCoreIndex() != index)
    {                           /*status request is for other cpu than the host */
        dbgsr = cpu->DBGSR;
    }
    else
    {                           /*status request is for same cpu as the host */
        dbgsr.U = __mfcr(0xFD00);
    }

    /*Check if the requested CPU is in DBG HALT mode */
    if (dbgsr.B.HALT == (uint32)IfxCpu_DBGST_HALT_halt)
    {                           /*CPU is in DBG HALT mode */
        cpuMode = IfxCpu_CoreMode_halt;
    }
    else
    {
        if (dbgsr.B.HALT == (uint32)IfxCpu_DBGST_HALT_run)
        {                       /*CPU is in DBG RUNNING mode now check PMCSR status */
            switch (index)
            {
            case IfxCpu_ResourceCpu_0:

                pmcsr_val0 = &((*(Ifx_SCU*)0xF0036000u)).PMCSR0;

                if (pmcsr_val0->B.PMST == (uint32)IfxCpu_PMCSR_PMST_normalMode)
                {                   /*Cpu is in normal run mode */
                    cpuMode = IfxCpu_CoreMode_run;
                }
                else
                {                   /*Cpu is not in run mode */
                    if (pmcsr_val0->B.PMST == (uint32)IfxCpu_PMCSR_PMST_idleMode)
                    {               /*Cpu is in idle mode */
                        cpuMode = IfxCpu_CoreMode_idle;
                    }
                }

                break;
            case IfxCpu_ResourceCpu_1:

                pmcsr_val1 = &((*(Ifx_SCU*)0xF0036000u)).PMCSR1;

                if (pmcsr_val1->B.PMST == (uint32)IfxCpu_PMCSR_PMST_normalMode)
                {                   /*Cpu is in normal run mode */
                    cpuMode = IfxCpu_CoreMode_run;
                }
                else
                {                   /*Cpu is not in run mode */
                    if (pmcsr_val1->B.PMST == (uint32)IfxCpu_PMCSR_PMST_idleMode)
                    {               /*Cpu is in idle mode */
                        cpuMode = IfxCpu_CoreMode_idle;
                    }
                }

                break;
            case IfxCpu_ResourceCpu_2:

                pmcsr_val2 = &((*(Ifx_SCU*)0xF0036000u)).PMCSR2;

                if (pmcsr_val2->B.PMST == (uint32)IfxCpu_PMCSR_PMST_normalMode)
                {                   /*Cpu is in normal run mode */
                    cpuMode = IfxCpu_CoreMode_run;
                }
                else
                {                   /*Cpu is not in run mode */
                    if (pmcsr_val2->B.PMST == (uint32)IfxCpu_PMCSR_PMST_idleMode)
                    {               /*Cpu is in idle mode */
                        cpuMode = IfxCpu_CoreMode_idle;
                    }
                }

                break;
            case IfxCpu_ResourceCpu_3:

                pmcsr_val3 = &((*(Ifx_SCU*)0xF0036000u)).PMCSR3;

                if (pmcsr_val3->B.PMST == (uint32)IfxCpu_PMCSR_PMST_normalMode)
                {                   /*Cpu is in normal run mode */
                    cpuMode = IfxCpu_CoreMode_run;
                }
                else
                {                   /*Cpu is not in run mode */
                    if (pmcsr_val3->B.PMST == (uint32)IfxCpu_PMCSR_PMST_idleMode)
                    {               /*Cpu is in idle mode */
                        cpuMode = IfxCpu_CoreMode_idle;
                    }
                }

                break;
            default:
                /* Invalid core selected */
                break;
            }
        }
    }

    return cpuMode;
}


IfxCpu_ResourceCpu IfxCpu_getIndex(Ifx_CPU *cpu)
{
    IfxCpu_ResourceCpu result;
    uint32             index;
    result = IfxCpu_ResourceCpu_none;

    for (index = 0; index < (4); index++)
    {
        if (IfxCpu_cfg_indexMap[index].module == cpu)
        {
            result = (IfxCpu_ResourceCpu)IfxCpu_cfg_indexMap[index].index;
            break;
        }
    }

    return result;
}


uint32 IfxCpu_getRandomValue(uint32 *seed)
{
    /*************************************************************************
     * the choice of a and m is important for a long period of the LCG
     * with a =  279470273 and
     *       m = 4294967291
     * a maximum period of 2^32-5 is given
     * values for a:
     * 0x5EB0A82F = 1588635695
     * 0x48E7211F = 1223106847
     * 0x10a860c1 =  279470273
     ***************************************************************************/
    uint32 x = *seed;

    /* a seed of 0 is not allowed, and therefore will be changed to a valid value */
    if (x == 0)
    {
        x = 42;
    }

    uint32 a = 0x10a860c1;  // 279470273
    uint32 m = 0xfffffffb;  // 4294967291
    uint32 result;

    //__asm(a,m,x,tmp1,tmp2              );
    //EhEl = a * x;
    //result = e14 %  m;
    // %0 result
    // %1 a
    // %2 x
    // %3 m
    result = IfxCpu_getRandomVal(a, x, m);

    *seed  = result; // to simplify seed passing

    return result;
}


uint32 IfxCpu_getRandomValueWithinRange(uint32 *seed, uint32 min, uint32 max)
{
    uint32 new_value = IfxCpu_getRandomValue(seed);

    /* swap min/max if required */
    if (min > max)
    {
        unsigned swap = max;
        max = min;
        min = swap;
    }

    /* special case */
    if ((min == 0) && (max == 0xffffffff))
    {
        return new_value;
    }

    /* return value within range */
    return (new_value % (max - min + 1)) + min;
}


void IfxCpu_releaseMutex(IfxCpu_mutexLock *lock)
{
    /*Reset the SpinLock*/
    *lock = 0;
}


void IfxCpu_resetSpinLock(IfxCpu_spinLock *lock)
{
    /*Reset the SpinLock*/
    *lock = 0;
}


boolean IfxCpu_setCoreMode(Ifx_CPU *cpu, IfxCpu_CoreMode mode)
{
    IfxCpu_ResourceCpu cpuIndex;
    cpuIndex = IfxCpu_getIndex(cpu);
    return IfxPmsPm_setCoreMode(cpuIndex, mode);
}


boolean IfxCpu_setProgramCounter(Ifx_CPU *cpu, uint32 programCounter)
{
    boolean retVal = (1u);

    if (cpu == IfxCpu_getAddress(IfxCpu_getCoreIndex()))
    {
        retVal = (0u);
    }
    else
    {
        cpu->PC.B.PC = programCounter >> 1;
    }

    return retVal;
}


boolean IfxCpu_setSpinLock(IfxCpu_spinLock *lock, uint32 timeoutCount)
{
    boolean         retVal;
    volatile uint32 spinLockVal;

    retVal = (0u);

    do
    {
        spinLockVal = 1UL;
        spinLockVal =
            (uint32)__cmpswapw((((unsigned int *)lock)), ((unsigned long)spinLockVal), (0) );

        /* Check if the SpinLock WAS set before the attempt to acquire spinlock */
        if (spinLockVal == 0)
        {
            retVal = (1u);
        }
        else
        {
            timeoutCount--;
        }
    } while ((retVal == (0u)) && (timeoutCount > 0));

    return retVal;
}


boolean IfxCpu_startCore(Ifx_CPU *cpu, uint32 programCounter)
{
    boolean retVal = (1u);

    /* Set the PC */
    retVal &= IfxCpu_setProgramCounter(cpu, programCounter);

    /* release boot halt mode if required */
    {
        Ifx_CPU_SYSCON syscon;
        syscon = cpu->SYSCON;

        if (syscon.B.BHALT)
        {
            syscon.B.BHALT = 0; cpu->SYSCON = syscon;
        }
    }

    return retVal;
}


boolean IfxCpu_waitEvent(IfxCpu_syncEvent *event, uint32 timeoutMilliSec)
{
    volatile uint32 *sync          = (volatile uint32 *)((((((unsigned)(event) & 0xF0000000) == 0xD0000000) ? ((((unsigned)(event) & 0x000fffff) | 0x70000000) - ((__mfcr(0xFE1C)) * 0x10000000)) : (unsigned)(event))));

    boolean          errorcnt      = 0U;
    /* Divide with 1000, gives the count value equivalent to milliseconds */
    uint32           stmCount      = (uint32)((IfxScuCcu_getStmFrequency() / 1000) * timeoutMilliSec);
    uint32           stmCountBegin = (*(volatile Ifx_STM_TIM0*)0xF0001010u).U;

    while ((*sync & (0xF)) != (0xF))
    {
        __nop();

        if ((uint32)((*(volatile Ifx_STM_TIM0*)0xF0001010u).U - stmCountBegin) >= stmCount)
        {
            errorcnt = 1;
            break;
        }

        /* There is no need to check overflow of the STM timer.
         * When counter after overflow subtracted with counter before overflow,
         * the subtraction result will be as expected, as long as both are unsigned 32 bits
         * eg: stmCountBegin= 0xFFFFFFFE (before overflow)
         *     stmCountNow = 0x00000002 (before overflow)
         *     diff= stmCountNow - stmCountBegin = 4 as expected.*/
    }

    return errorcnt;
}


void IfxCpu_emitEvent(IfxCpu_syncEvent *event)
{
    __imaskldmst((int*)event, 1, __mfcr(0xFE1C), 1);
}


void IfxCpu_triggerCpuReset(IfxCpu_ResourceCpu coreIndex)
{
    if (coreIndex != IfxCpu_getCoreIndex())
    {
        uint16   password = IfxScuWdt_getGlobalEndinitPassword();
        Ifx_CPU *cpu      = IfxCpu_getAddress(coreIndex);
        IfxScuWdt_clearGlobalEndinit(password);
        cpu->KRST0.B.RST = 1;
        cpu->KRST1.B.RST = 1;
        IfxScuWdt_setGlobalEndinit(password);
    }

    else

    {
//Do nothing because one cannot set the endinit back from the same CPU which is reset
    }
}


IfxCpu_ResetStatus IfxCpu_getCpuResetStatus(IfxCpu_ResourceCpu coreIndex)
{
    Ifx_CPU           *cpu    = IfxCpu_getAddress(coreIndex);
    IfxCpu_ResetStatus status = (IfxCpu_ResetStatus)cpu->KRST0.B.RSTSTAT;
    cpu->KRSTCLR.B.CLR = 1;
    return status;
}


void IfxCpu_setAllIdleExceptMasterCpu(IfxCpu_ResourceCpu masterCpu)
{
    uint16 endinitSfty_pw;
    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPasswordInline();
    IfxScuWdt_clearSafetyEndinitInline(endinitSfty_pw);

    switch (masterCpu)
    {
    case IfxCpu_ResourceCpu_0:
        (*(volatile Ifx_SCU_PMCSR1*)0xF00360CCu).B.REQSLP = 0x1;

        while ((*(volatile Ifx_SCU_PMSTAT0*)0xF00360E4u).B.CPU1)
        {}

        (*(volatile Ifx_SCU_PMCSR2*)0xF00360D0u).B.REQSLP = 0x1;

        while ((*(volatile Ifx_SCU_PMSTAT0*)0xF00360E4u).B.CPU2)
        {}

        (*(volatile Ifx_SCU_PMCSR3*)0xF00360D4u).B.REQSLP = 0x1;

        while ((*(volatile Ifx_SCU_PMSTAT0*)0xF00360E4u).B.CPU3)
        {}

        break;

    case IfxCpu_ResourceCpu_1:
        (*(volatile Ifx_SCU_PMCSR0*)0xF00360C8u).B.REQSLP = 0x1;

        while ((*(volatile Ifx_SCU_PMSTAT0*)0xF00360E4u).B.CPU0)
        {}

        (*(volatile Ifx_SCU_PMCSR2*)0xF00360D0u).B.REQSLP = 0x1;

        while ((*(volatile Ifx_SCU_PMSTAT0*)0xF00360E4u).B.CPU2)
        {}

        (*(volatile Ifx_SCU_PMCSR3*)0xF00360D4u).B.REQSLP = 0x1;

        while ((*(volatile Ifx_SCU_PMSTAT0*)0xF00360E4u).B.CPU3)
        {}

        break;

    case IfxCpu_ResourceCpu_2:
        (*(volatile Ifx_SCU_PMCSR0*)0xF00360C8u).B.REQSLP = 0x1;

        while ((*(volatile Ifx_SCU_PMSTAT0*)0xF00360E4u).B.CPU0)
        {}

        (*(volatile Ifx_SCU_PMCSR1*)0xF00360CCu).B.REQSLP = 0x1;

        while ((*(volatile Ifx_SCU_PMSTAT0*)0xF00360E4u).B.CPU1)
        {}

        (*(volatile Ifx_SCU_PMCSR3*)0xF00360D4u).B.REQSLP = 0x1;

        while ((*(volatile Ifx_SCU_PMSTAT0*)0xF00360E4u).B.CPU3)
        {}

        break;

    case IfxCpu_ResourceCpu_3:
        (*(volatile Ifx_SCU_PMCSR0*)0xF00360C8u).B.REQSLP = 0x1;

        while ((*(volatile Ifx_SCU_PMSTAT0*)0xF00360E4u).B.CPU0)
        {}

        (*(volatile Ifx_SCU_PMCSR1*)0xF00360CCu).B.REQSLP = 0x1;

        while ((*(volatile Ifx_SCU_PMSTAT0*)0xF00360E4u).B.CPU1)
        {}

        (*(volatile Ifx_SCU_PMCSR2*)0xF00360D0u).B.REQSLP = 0x1;

        while ((*(volatile Ifx_SCU_PMSTAT0*)0xF00360E4u).B.CPU2)
        {}

        break;
    default:
        /* Invalid core selected */
        break;
    }

    IfxScuWdt_setSafetyEndinitInline(endinitSfty_pw);
}


void IfxCpu_disableInterruptsAllExceptMaster(IfxCpu_ResourceCpu masterCpu)
{
    uint16 password = IfxScuWdt_getGlobalEndinitPassword();
    IfxScuWdt_clearGlobalEndinit(password);

    switch (masterCpu)
    {
    case IfxCpu_ResourceCpu_0:
        (*(volatile Ifx_CPU_ICR*)0xF883FE2Cu).B.IE = 0;

        while ((*(volatile Ifx_CPU_ICR*)0xF883FE2Cu).B.IE)
        {}

        (*(volatile Ifx_CPU_ICR*)0xF885FE2Cu).B.IE = 0;

        while ((*(volatile Ifx_CPU_ICR*)0xF885FE2Cu).B.IE)
        {}

        (*(volatile Ifx_CPU_ICR*)0xF887FE2Cu).B.IE = 0;

        while ((*(volatile Ifx_CPU_ICR*)0xF887FE2Cu).B.IE)
        {}

        break;

    case IfxCpu_ResourceCpu_1:
        (*(volatile Ifx_CPU_ICR*)0xF881FE2Cu).B.IE = 0;

        while ((*(volatile Ifx_CPU_ICR*)0xF881FE2Cu).B.IE)
        {}

        (*(volatile Ifx_CPU_ICR*)0xF885FE2Cu).B.IE = 0;

        while ((*(volatile Ifx_CPU_ICR*)0xF885FE2Cu).B.IE)
        {}

        (*(volatile Ifx_CPU_ICR*)0xF887FE2Cu).B.IE = 0;

        while ((*(volatile Ifx_CPU_ICR*)0xF887FE2Cu).B.IE)
        {}

        break;

    case IfxCpu_ResourceCpu_2:
        (*(volatile Ifx_CPU_ICR*)0xF881FE2Cu).B.IE = 0;

        while ((*(volatile Ifx_CPU_ICR*)0xF881FE2Cu).B.IE)
        {}

        (*(volatile Ifx_CPU_ICR*)0xF883FE2Cu).B.IE = 0;

        while ((*(volatile Ifx_CPU_ICR*)0xF883FE2Cu).B.IE)
        {}

        (*(volatile Ifx_CPU_ICR*)0xF887FE2Cu).B.IE = 0;

        while ((*(volatile Ifx_CPU_ICR*)0xF887FE2Cu).B.IE)
        {}

        break;

    case IfxCpu_ResourceCpu_3:
        (*(volatile Ifx_CPU_ICR*)0xF881FE2Cu).B.IE = 0;

        while ((*(volatile Ifx_CPU_ICR*)0xF881FE2Cu).B.IE)
        {}

        (*(volatile Ifx_CPU_ICR*)0xF883FE2Cu).B.IE = 0;

        while ((*(volatile Ifx_CPU_ICR*)0xF883FE2Cu).B.IE)
        {}

        (*(volatile Ifx_CPU_ICR*)0xF885FE2Cu).B.IE = 0;

        while ((*(volatile Ifx_CPU_ICR*)0xF885FE2Cu).B.IE)
        {}

        break;
    default:
        /* Invalid core selected */
        break;
    }

    IfxScuWdt_setGlobalEndinit(password);
}
