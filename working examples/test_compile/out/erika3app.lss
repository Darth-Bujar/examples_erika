
erika3app.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .interrupts   00000400  1ffe0000  1ffe0000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00003308  1ffe0400  1ffe0400  00010400  2**6
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .code_ram     00000000  1ffe3708  1ffe3708  000201bc  2**0
                  CONTENTS
  3 .data         000001bc  20000000  20000000  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .bss          00000508  200001c0  200001c0  000201bc  2**3
                  ALLOC
  5 .heap         00000400  200006c8  200006c8  000201bc  2**0
                  ALLOC
  6 .stack        00000400  2001ec00  2001ec00  000201bc  2**0
                  ALLOC
  7 .ARM.attributes 0000002a  00000000  00000000  000201bc  2**0
                  CONTENTS, READONLY
  8 .debug_info   0001bf6f  00000000  00000000  000201e6  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  9 .debug_abbrev 00003bb9  00000000  00000000  0003c155  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 10 .debug_loc    0000cabd  00000000  00000000  0003fd0e  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 11 .debug_aranges 00000a08  00000000  00000000  0004c7d0  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_ranges 000010c8  00000000  00000000  0004d1d8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_line   0000b8b1  00000000  00000000  0004e2a0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_str    00008cf2  00000000  00000000  00059b51  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .comment      00000049  00000000  00000000  00062843  2**0
                  CONTENTS, READONLY
 16 .debug_frame  00001608  00000000  00000000  0006288c  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

1ffe0400 <Reset_Handler>:
    .align 2
    .globl   Reset_Handler
    .weak    Reset_Handler
    .type    Reset_Handler, %function
Reset_Handler:
    cpsid   i               /* Mask interrupts */
1ffe0400:	b672      	cpsid	i

    /* Init the rest of the registers */
    ldr     r1,=0
1ffe0402:	f04f 0100 	mov.w	r1, #0
    ldr     r2,=0
1ffe0406:	f04f 0200 	mov.w	r2, #0
    ldr     r3,=0
1ffe040a:	f04f 0300 	mov.w	r3, #0
    ldr     r4,=0
1ffe040e:	f04f 0400 	mov.w	r4, #0
    ldr     r5,=0
1ffe0412:	f04f 0500 	mov.w	r5, #0
    ldr     r6,=0
1ffe0416:	f04f 0600 	mov.w	r6, #0
    ldr     r7,=0
1ffe041a:	f04f 0700 	mov.w	r7, #0
    mov     r8,r7
1ffe041e:	46b8      	mov	r8, r7
    mov     r9,r7
1ffe0420:	46b9      	mov	r9, r7
    mov     r10,r7
1ffe0422:	46ba      	mov	sl, r7
    mov     r11,r7
1ffe0424:	46bb      	mov	fp, r7
    mov     r12,r7
1ffe0426:	46bc      	mov	ip, r7

#ifndef __NO_SYSTEM_INIT
    /* Call the system init routine */
    ldr     r0,=SystemInit
1ffe0428:	4804      	ldr	r0, [pc, #16]	; (1ffe043c <JumpToSelf+0x2>)
    blx     r0
1ffe042a:	4780      	blx	r0
    bge .LC4
.LC5:
#endif
    
    /* Initialize the stack pointer */
    ldr     r0,=__StackTop
1ffe042c:	4804      	ldr	r0, [pc, #16]	; (1ffe0440 <JumpToSelf+0x6>)
    mov     r13,r0
1ffe042e:	4685      	mov	sp, r0

    /* Init .data and .bss sections */
    ldr     r0,=init_data_bss
1ffe0430:	4804      	ldr	r0, [pc, #16]	; (1ffe0444 <JumpToSelf+0xa>)
    blx     r0
1ffe0432:	4780      	blx	r0
    cpsie   i               /* Unmask interrupts */
1ffe0434:	b662      	cpsie	i
    bl      main
1ffe0436:	f000 f97b 	bl	1ffe0730 <main>

1ffe043a <JumpToSelf>:
JumpToSelf:
    b       JumpToSelf
1ffe043a:	e7fe      	b.n	1ffe043a <JumpToSelf>
    ldr     r0,=SystemInit
1ffe043c:	1ffe2935 	.word	0x1ffe2935
    ldr     r0,=__StackTop
1ffe0440:	2001f000 	.word	0x2001f000
    ldr     r0,=init_data_bss
1ffe0444:	1ffe2875 	.word	0x1ffe2875

1ffe0448 <ADC0_IRQHandler>:
    .align  1
    .thumb_func
    .weak DefaultISR
    .type DefaultISR, %function
DefaultISR:
    b       DefaultISR
1ffe0448:	f7ff bffe 	b.w	1ffe0448 <ADC0_IRQHandler>
	...

1ffe0480 <strlen>:
1ffe0480:	f890 f000 	pld	[r0]
1ffe0484:	e96d 4502 	strd	r4, r5, [sp, #-8]!
1ffe0488:	f020 0107 	bic.w	r1, r0, #7
1ffe048c:	f06f 0c00 	mvn.w	ip, #0
1ffe0490:	f010 0407 	ands.w	r4, r0, #7
1ffe0494:	f891 f020 	pld	[r1, #32]
1ffe0498:	f040 8049 	bne.w	1ffe052e <strlen+0xae>
1ffe049c:	f04f 0400 	mov.w	r4, #0
1ffe04a0:	f06f 0007 	mvn.w	r0, #7
1ffe04a4:	e9d1 2300 	ldrd	r2, r3, [r1]
1ffe04a8:	f891 f040 	pld	[r1, #64]	; 0x40
1ffe04ac:	f100 0008 	add.w	r0, r0, #8
1ffe04b0:	fa82 f24c 	uadd8	r2, r2, ip
1ffe04b4:	faa4 f28c 	sel	r2, r4, ip
1ffe04b8:	fa83 f34c 	uadd8	r3, r3, ip
1ffe04bc:	faa2 f38c 	sel	r3, r2, ip
1ffe04c0:	bb4b      	cbnz	r3, 1ffe0516 <strlen+0x96>
1ffe04c2:	e9d1 2302 	ldrd	r2, r3, [r1, #8]
1ffe04c6:	fa82 f24c 	uadd8	r2, r2, ip
1ffe04ca:	f100 0008 	add.w	r0, r0, #8
1ffe04ce:	faa4 f28c 	sel	r2, r4, ip
1ffe04d2:	fa83 f34c 	uadd8	r3, r3, ip
1ffe04d6:	faa2 f38c 	sel	r3, r2, ip
1ffe04da:	b9e3      	cbnz	r3, 1ffe0516 <strlen+0x96>
1ffe04dc:	e9d1 2304 	ldrd	r2, r3, [r1, #16]
1ffe04e0:	fa82 f24c 	uadd8	r2, r2, ip
1ffe04e4:	f100 0008 	add.w	r0, r0, #8
1ffe04e8:	faa4 f28c 	sel	r2, r4, ip
1ffe04ec:	fa83 f34c 	uadd8	r3, r3, ip
1ffe04f0:	faa2 f38c 	sel	r3, r2, ip
1ffe04f4:	b97b      	cbnz	r3, 1ffe0516 <strlen+0x96>
1ffe04f6:	e9d1 2306 	ldrd	r2, r3, [r1, #24]
1ffe04fa:	f101 0120 	add.w	r1, r1, #32
1ffe04fe:	fa82 f24c 	uadd8	r2, r2, ip
1ffe0502:	f100 0008 	add.w	r0, r0, #8
1ffe0506:	faa4 f28c 	sel	r2, r4, ip
1ffe050a:	fa83 f34c 	uadd8	r3, r3, ip
1ffe050e:	faa2 f38c 	sel	r3, r2, ip
1ffe0512:	2b00      	cmp	r3, #0
1ffe0514:	d0c6      	beq.n	1ffe04a4 <strlen+0x24>
1ffe0516:	2a00      	cmp	r2, #0
1ffe0518:	bf04      	itt	eq
1ffe051a:	3004      	addeq	r0, #4
1ffe051c:	461a      	moveq	r2, r3
1ffe051e:	ba12      	rev	r2, r2
1ffe0520:	fab2 f282 	clz	r2, r2
1ffe0524:	e8fd 4502 	ldrd	r4, r5, [sp], #8
1ffe0528:	eb00 00d2 	add.w	r0, r0, r2, lsr #3
1ffe052c:	4770      	bx	lr
1ffe052e:	e9d1 2300 	ldrd	r2, r3, [r1]
1ffe0532:	f004 0503 	and.w	r5, r4, #3
1ffe0536:	f1c4 0000 	rsb	r0, r4, #0
1ffe053a:	ea4f 05c5 	mov.w	r5, r5, lsl #3
1ffe053e:	f014 0f04 	tst.w	r4, #4
1ffe0542:	f891 f040 	pld	[r1, #64]	; 0x40
1ffe0546:	fa0c f505 	lsl.w	r5, ip, r5
1ffe054a:	ea62 0205 	orn	r2, r2, r5
1ffe054e:	bf1c      	itt	ne
1ffe0550:	ea63 0305 	ornne	r3, r3, r5
1ffe0554:	4662      	movne	r2, ip
1ffe0556:	f04f 0400 	mov.w	r4, #0
1ffe055a:	e7a9      	b.n	1ffe04b0 <strlen+0x30>

1ffe055c <osEE_hal_save_ctx_and_restore_ctx>:
	/*
	 * R0 parameter:	OsEE_TDB * p_to_tdb
	 * R1 parameter:	OsEE_SCB * p_to_scb
	 * R2 parameter: 	OsEE_SCB * p_from_scb
	 */
	osEE_hal_save_vcontext_m R2
1ffe055c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
1ffe0560:	f3ef 8403 	mrs	r4, PSR
1ffe0564:	b410      	push	{r4}
1ffe0566:	4614      	mov	r4, r2
1ffe0568:	6825      	ldr	r5, [r4, #0]
1ffe056a:	b460      	push	{r5, r6}
1ffe056c:	f3ef 8508 	mrs	r5, MSP
1ffe0570:	6025      	str	r5, [r4, #0]
	B	osEE_hal_restore_ctx
1ffe0572:	f000 b801 	b.w	1ffe0578 <osEE_hal_restore_ctx>
1ffe0576:	bf00      	nop

1ffe0578 <osEE_hal_restore_ctx>:
osEE_hal_restore_ctx:
	/*
	 * R0 parameter:	OsEE_TDB * p_to_tdb
	 * R1 parameter:	OsEE_SCB * p_to_scb
	 */
	osEE_hal_restore_vcontext_m R1
1ffe0578:	460c      	mov	r4, r1
1ffe057a:	6825      	ldr	r5, [r4, #0]
1ffe057c:	f385 8808 	msr	MSP, r5
1ffe0580:	bc60      	pop	{r5, r6}
1ffe0582:	6025      	str	r5, [r4, #0]
1ffe0584:	bc10      	pop	{r4}
1ffe0586:	f04f 7580 	mov.w	r5, #16777216	; 0x1000000
1ffe058a:	432c      	orrs	r4, r5
1ffe058c:	f384 8803 	msr	PSR, r4
1ffe0590:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	B	osEE_scheduler_task_wrapper_restore
1ffe0594:	f002 bb46 	b.w	1ffe2c24 <osEE_scheduler_task_wrapper_restore>

1ffe0598 <osEE_hal_ready2stacked>:
	MRS	R4, CONTROL
	LDR	R5, =CONTROL_FPCA_NEG
	ANDS	R4, R4, R5
	MSR	CONTROL, R4
#endif	/* defined(OS_EE_ARCH_CORTEX_M_M4F_FPU) */
	LDR	R2, [R1]
1ffe0598:	680a      	ldr	r2, [r1, #0]
	/* sp = R2 */
	MSR	MSP, R2
1ffe059a:	f382 8808 	msr	MSP, r2
	B	osEE_scheduler_task_wrapper_run
1ffe059e:	f002 bb45 	b.w	1ffe2c2c <osEE_scheduler_task_wrapper_run>
1ffe05a2:	bf00      	nop

1ffe05a4 <osEE_hal_save_ctx_and_ready2stacked>:
	/*
	 * R0 parameter:	OsEE_TDB * p_to_tdb
	 * R1 parameter:	OsEE_SCB * p_to_scb
	 * R2 parameter:	OsEE_SCB * p_from_scb
	*/
	osEE_hal_save_vcontext_m R2
1ffe05a4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
1ffe05a8:	f3ef 8403 	mrs	r4, PSR
1ffe05ac:	b410      	push	{r4}
1ffe05ae:	4614      	mov	r4, r2
1ffe05b0:	6825      	ldr	r5, [r4, #0]
1ffe05b2:	b460      	push	{r5, r6}
1ffe05b4:	f3ef 8508 	mrs	r5, MSP
1ffe05b8:	6025      	str	r5, [r4, #0]
	B	osEE_hal_ready2stacked
1ffe05ba:	f7ff bfed 	b.w	1ffe0598 <osEE_hal_ready2stacked>
1ffe05be:	bf00      	nop

1ffe05c0 <osEE_hal_terminate_ctx>:
	MRS	R4, CONTROL
	LDR	R5, =CONTROL_FPCA_NEG
	ANDS	R4, R4, R5
	MSR	CONTROL, R4
#endif	/* defined(OS_EE_ARCH_CORTEX_M_M4F_FPU) */
	LDR	R2, [R0]
1ffe05c0:	6802      	ldr	r2, [r0, #0]
	/* Unwind SP */
	MSR	MSP, R2
1ffe05c2:	f382 8808 	msr	MSP, r2
	/*  Jump to kern_callback (that schedule) */
	BX	R1
1ffe05c6:	4708      	bx	r1

1ffe05c8 <osEE_cortex_m_restore_ctx>:
osEE_cortex_m_restore_ctx:
	/*
	 * R0 parameter:	OsEE_TDB * p_to_tdb
	 * R1 parameter:	OsEE_SCB * p_to_scb
	 */
	osEE_hal_restore_vcontext_m R1
1ffe05c8:	460c      	mov	r4, r1
1ffe05ca:	6825      	ldr	r5, [r4, #0]
1ffe05cc:	f385 8808 	msr	MSP, r5
1ffe05d0:	bc60      	pop	{r5, r6}
1ffe05d2:	6025      	str	r5, [r4, #0]
1ffe05d4:	bc10      	pop	{r4}
1ffe05d6:	f04f 7580 	mov.w	r5, #16777216	; 0x1000000
1ffe05da:	432c      	orrs	r4, r5
1ffe05dc:	f384 8803 	msr	PSR, r4
1ffe05e0:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	BX	LR
1ffe05e4:	4770      	bx	lr
1ffe05e6:	bf00      	nop

1ffe05e8 <osEE_set_switch_context_pri>:
	.global	osEE_set_switch_context_pri
	.type	osEE_set_switch_context_pri, #function
osEE_set_switch_context_pri:

	/* Set PendSV priority to the minumum one */
	LDR	R0, =NVIC_SHPR3
1ffe05e8:	4812      	ldr	r0, [pc, #72]	; (1ffe0634 <SVC_Handler+0x4>)
	LDR	R1, =NVIC_PENDSV_PRI
1ffe05ea:	f44f 017f 	mov.w	r1, #16711680	; 0xff0000
	LDR	R2, [R0]
1ffe05ee:	6802      	ldr	r2, [r0, #0]
	ORRS	R2, R2, R1
1ffe05f0:	430a      	orrs	r2, r1
	STR	R2, [R0]
1ffe05f2:	6002      	str	r2, [r0, #0]

	/* SVCall priority to the maximum one */
	LDR	R0, =NVIC_SHPR2
1ffe05f4:	4810      	ldr	r0, [pc, #64]	; (1ffe0638 <SVC_Handler+0x8>)
	LDR	R1, =NVIC_SVCALL_PRI
1ffe05f6:	f06f 417f 	mvn.w	r1, #4278190080	; 0xff000000
	LDR	R2, [R0]
1ffe05fa:	6802      	ldr	r2, [r0, #0]
	ANDS	R2, R2, R1
1ffe05fc:	400a      	ands	r2, r1
	STR	R2, [R0]
1ffe05fe:	6002      	str	r2, [r0, #0]

	BX	LR
1ffe0600:	4770      	bx	lr
1ffe0602:	bf00      	nop

1ffe0604 <osEE_cortex_m_trigger_pend_sv>:
osEE_cortex_m_trigger_pend_sv:

	/* 
	 * Trigger the PendSV exception (causes context switch)
	 */
	LDR	R0, =NVIC_INT_CTRL
1ffe0604:	480d      	ldr	r0, [pc, #52]	; (1ffe063c <SVC_Handler+0xc>)
	LDR	R1, =NVIC_PENDSVSET
1ffe0606:	f04f 5180 	mov.w	r1, #268435456	; 0x10000000
	STR	R1, [R0]
1ffe060a:	6001      	str	r1, [r0, #0]

	BX	LR
1ffe060c:	4770      	bx	lr
1ffe060e:	bf00      	nop

1ffe0610 <PendSV_Handler>:
	.type	PendSV_Handler, %function
PendSV_Handler:

	/* Disable interrupts (set PRIMASK) */
#if	1	/* [GS]: To Be Checked. */
	CPSID	I
1ffe0610:	b672      	cpsid	i
#endif

	/* Clear the PendSV exception (preventing 2nd triggering) */
	LDR	R2, =NVIC_INT_CTRL
1ffe0612:	4a0a      	ldr	r2, [pc, #40]	; (1ffe063c <SVC_Handler+0xc>)
	LDR	R1, =NVIC_PENDSVCLR
1ffe0614:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
	STR	R1, [R2]
1ffe0618:	6011      	str	r1, [r2, #0]
	 * EE_std_change_context(EE_TID) at the
	 * end of PendSV_Handler.
	 */

	/* R3 = 0x01000000 (xPSR) */
	LDR	R3, =EPSR_T_BIT_VAL
1ffe061a:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000

	/* R2 = osEE_cortex_m_change_context_from_task_end (PC) */
	LDR	R2, =osEE_cortex_m_change_context_from_task_end
1ffe061e:	4a08      	ldr	r2, [pc, #32]	; (1ffe0640 <SVC_Handler+0x10>)

	/* R1 = osEE_cortex_m_thread_end (LR) */
	LDR	R1, =osEE_cortex_m_thread_end
1ffe0620:	4908      	ldr	r1, [pc, #32]	; (1ffe0644 <SVC_Handler+0x14>)
	 * |xPSR|-> xPSR AND 0xFFFFFE0
	 * | PC |-> osEE_cortex_m_change_context_from_task_end
	 * | LR |-> osEE_cortex_m_thread_end
	 * | R12|
	 */
	PUSH	{R0-R3}
1ffe0622:	b40f      	push	{r0, r1, r2, r3}
	 * | R3 |
	 * | R2 |
	 * | R1 |
	 * | R0 |
	 */
	PUSH	{R0-R3}
1ffe0624:	b40f      	push	{r0, r1, r2, r3}
	/*
	 * R0 = EXC_RETURN -> Return to Thread mode.
	 *		   -> Exception return gets state from MSP.
	 *		   -> Execution uses MSP after return.
	 */
	LDR	LR, =EXC_RETURN
1ffe0626:	f06f 0e06 	mvn.w	lr, #6

	BX	LR		/* EXC_RETURN. */
1ffe062a:	4770      	bx	lr

1ffe062c <osEE_cortex_m_thread_end>:
 * 		To solve this, instead of using PRIMASK to mask interrupts,
 * 		use BASEPRI to mask particular interrupts.
 */

	/* Enable interrupts (clear PRIMASK) */
	CPSIE	I
1ffe062c:	b662      	cpsie	i

	/* SVCall exception to remove Original PendSV stack-frame. */
	SVC	#0
1ffe062e:	df00      	svc	0

1ffe0630 <SVC_Handler>:
	.global	SVC_Handler
	.type	SVC_Handler, %function
SVC_Handler:

	/* Remove SVCall Stack-Frame. */
	ADD	SP, SP, #(8*4)
1ffe0630:	b008      	add	sp, #32
#if	defined(OS_EE_ARCH_CORTEX_M_M4F_FPU)
	/* Retrieves original Link Register. */
	POP	{R0, LR}
#endif	/* defined(OS_EE_ARCH_CORTEX_M_M4F_FPU) */

	BX	LR		/* EXC_RETURN. */
1ffe0632:	4770      	bx	lr
	LDR	R0, =NVIC_SHPR3
1ffe0634:	e000ed20 	.word	0xe000ed20
	LDR	R0, =NVIC_SHPR2
1ffe0638:	e000ed1c 	.word	0xe000ed1c
	LDR	R0, =NVIC_INT_CTRL
1ffe063c:	e000ed04 	.word	0xe000ed04
	LDR	R2, =osEE_cortex_m_change_context_from_task_end
1ffe0640:	1ffe30f5 	.word	0x1ffe30f5
	LDR	R1, =osEE_cortex_m_thread_end
1ffe0644:	1ffe062d 	.word	0x1ffe062d

1ffe0648 <StartupHook>:
#define	IDLE_STR_LEN	6U
#define	ISR_STR		(P2CONST(uint8_t, AUTOMATIC, OS_APPL_DATA))"ISR\r\n"
#define	ISR_STR_LEN	5U

void StartupHook(void)
{
1ffe0648:	b508      	push	{r3, lr}
  DemoHAL_TimerInit(TIMER_PERIOD_MS);
1ffe064a:	2001      	movs	r0, #1
1ffe064c:	f000 f98e 	bl	1ffe096c <DemoHAL_TimerInit>
}
1ffe0650:	bd08      	pop	{r3, pc}

1ffe0652 <serial_print>:

void serial_print(char const * msg) {
1ffe0652:	b510      	push	{r4, lr}
1ffe0654:	4604      	mov	r4, r0
  SuspendAllInterrupts();
1ffe0656:	f002 fa19 	bl	1ffe2a8c <SuspendAllInterrupts>
  DemoHAL_SerialWrite((uint8_t const *)msg, strlen(msg));
1ffe065a:	4620      	mov	r0, r4
1ffe065c:	f7ff ff10 	bl	1ffe0480 <strlen>
1ffe0660:	4601      	mov	r1, r0
1ffe0662:	4620      	mov	r0, r4
1ffe0664:	f000 f9a5 	bl	1ffe09b2 <DemoHAL_SerialWrite>
  ResumeAllInterrupts();
1ffe0668:	f002 fa18 	bl	1ffe2a9c <ResumeAllInterrupts>
}
1ffe066c:	bd10      	pop	{r4, pc}
	...

1ffe0670 <TimerISR>:
      ;                                                             \
    }                                                               \
  } while ( 0 )

/* Timer1 ISR2 */
ISR2(TimerISR) {
1ffe0670:	b508      	push	{r3, lr}
  ++isr2_fired;
1ffe0672:	4b0f      	ldr	r3, [pc, #60]	; (1ffe06b0 <TimerISR+0x40>)
1ffe0674:	681a      	ldr	r2, [r3, #0]
1ffe0676:	3201      	adds	r2, #1
1ffe0678:	601a      	str	r2, [r3, #0]
  if (isr2_fired >=ISR_DIVISOR)
1ffe067a:	681b      	ldr	r3, [r3, #0]
1ffe067c:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
1ffe0680:	d308      	bcc.n	1ffe0694 <TimerISR+0x24>
  {
    isr2_fired = 0;
1ffe0682:	4b0b      	ldr	r3, [pc, #44]	; (1ffe06b0 <TimerISR+0x40>)
1ffe0684:	2200      	movs	r2, #0
1ffe0686:	601a      	str	r2, [r3, #0]
    if (!isr2_armed) {
1ffe0688:	4b0a      	ldr	r3, [pc, #40]	; (1ffe06b4 <TimerISR+0x44>)
1ffe068a:	681b      	ldr	r3, [r3, #0]
1ffe068c:	b12b      	cbz	r3, 1ffe069a <TimerISR+0x2a>
      DemoHAL_LedToggle(DEMO_HAL_LED_2);
      DemoHAL_SerialWrite(ISR_STR, ISR_STR_LEN);
      ActivateTask(Task1);
    } else {
      isr2_armed = 0U;
1ffe068e:	4b09      	ldr	r3, [pc, #36]	; (1ffe06b4 <TimerISR+0x44>)
1ffe0690:	2200      	movs	r2, #0
1ffe0692:	601a      	str	r2, [r3, #0]
    }
  }
  DemoHAL_TimerAck();
1ffe0694:	f000 f986 	bl	1ffe09a4 <DemoHAL_TimerAck>
}
1ffe0698:	bd08      	pop	{r3, pc}
      DemoHAL_LedToggle(DEMO_HAL_LED_2);
1ffe069a:	2002      	movs	r0, #2
1ffe069c:	f000 f94a 	bl	1ffe0934 <DemoHAL_LedToggle>
      DemoHAL_SerialWrite(ISR_STR, ISR_STR_LEN);
1ffe06a0:	2105      	movs	r1, #5
1ffe06a2:	4805      	ldr	r0, [pc, #20]	; (1ffe06b8 <TimerISR+0x48>)
1ffe06a4:	f000 f985 	bl	1ffe09b2 <DemoHAL_SerialWrite>
      ActivateTask(Task1);
1ffe06a8:	2002      	movs	r0, #2
1ffe06aa:	f002 fa6d 	bl	1ffe2b88 <ActivateTask>
1ffe06ae:	e7f1      	b.n	1ffe0694 <TimerISR+0x24>
1ffe06b0:	200001c8 	.word	0x200001c8
1ffe06b4:	200001c4 	.word	0x200001c4
1ffe06b8:	1ffe3168 	.word	0x1ffe3168

1ffe06bc <idle_hook>:

void idle_hook ( void ) {
1ffe06bc:	b500      	push	{lr}
1ffe06be:	b083      	sub	sp, #12
OSEE_STATIC_INLINE FUNC(OsEE_addr, OS_CODE) OSEE_ALWAYS_INLINE
osEE_get_SP (
void
) {
  VAR(OsEE_addr, AUTOMATIC) temp;
  OSEE_GET_SP(temp);
1ffe06c0:	466b      	mov	r3, sp

  OsEE_addr volatile curr_sp = osEE_get_SP();
1ffe06c2:	9301      	str	r3, [sp, #4]

  if ( main_sp == 0 ) {
1ffe06c4:	4b15      	ldr	r3, [pc, #84]	; (1ffe071c <idle_hook+0x60>)
1ffe06c6:	681b      	ldr	r3, [r3, #0]
1ffe06c8:	b16b      	cbz	r3, 1ffe06e6 <idle_hook+0x2a>
    main_sp = curr_sp;
  } else if ( main_sp != curr_sp ) {
1ffe06ca:	4b14      	ldr	r3, [pc, #80]	; (1ffe071c <idle_hook+0x60>)
1ffe06cc:	681a      	ldr	r2, [r3, #0]
1ffe06ce:	9b01      	ldr	r3, [sp, #4]
1ffe06d0:	429a      	cmp	r2, r3
1ffe06d2:	d00b      	beq.n	1ffe06ec <idle_hook+0x30>
    OSEE_BREAK_POINT();
1ffe06d4:	2001      	movs	r0, #1
1ffe06d6:	f000 f911 	bl	1ffe08fc <DemoHAL_LedOn>
1ffe06da:	f002 f9cf 	bl	1ffe2a7c <DisableAllInterrupts>
1ffe06de:	4810      	ldr	r0, [pc, #64]	; (1ffe0720 <idle_hook+0x64>)
1ffe06e0:	f7ff ffb7 	bl	1ffe0652 <serial_print>
1ffe06e4:	e7fe      	b.n	1ffe06e4 <idle_hook+0x28>
    main_sp = curr_sp;
1ffe06e6:	9a01      	ldr	r2, [sp, #4]
1ffe06e8:	4b0c      	ldr	r3, [pc, #48]	; (1ffe071c <idle_hook+0x60>)
1ffe06ea:	601a      	str	r2, [r3, #0]
  }

  ++idle_cnt;
1ffe06ec:	4b0d      	ldr	r3, [pc, #52]	; (1ffe0724 <idle_hook+0x68>)
1ffe06ee:	681a      	ldr	r2, [r3, #0]
1ffe06f0:	3201      	adds	r2, #1
1ffe06f2:	601a      	str	r2, [r3, #0]
  if (idle_cnt >= IDLE_CNT_MAX) {
1ffe06f4:	681a      	ldr	r2, [r3, #0]
1ffe06f6:	4b0c      	ldr	r3, [pc, #48]	; (1ffe0728 <idle_hook+0x6c>)
1ffe06f8:	429a      	cmp	r2, r3
1ffe06fa:	d804      	bhi.n	1ffe0706 <idle_hook+0x4a>
    idle_cnt = 0;
    DemoHAL_LedToggle(DEMO_HAL_LED_0);
    DemoHAL_SerialWrite(IDLE_STR, IDLE_STR_LEN);
  }

  DemoHAL_MainFunction();
1ffe06fc:	f000 f8da 	bl	1ffe08b4 <DemoHAL_MainFunction>
}
1ffe0700:	b003      	add	sp, #12
1ffe0702:	f85d fb04 	ldr.w	pc, [sp], #4
    idle_cnt = 0;
1ffe0706:	2000      	movs	r0, #0
1ffe0708:	4b06      	ldr	r3, [pc, #24]	; (1ffe0724 <idle_hook+0x68>)
1ffe070a:	6018      	str	r0, [r3, #0]
    DemoHAL_LedToggle(DEMO_HAL_LED_0);
1ffe070c:	f000 f912 	bl	1ffe0934 <DemoHAL_LedToggle>
    DemoHAL_SerialWrite(IDLE_STR, IDLE_STR_LEN);
1ffe0710:	2106      	movs	r1, #6
1ffe0712:	4806      	ldr	r0, [pc, #24]	; (1ffe072c <idle_hook+0x70>)
1ffe0714:	f000 f94d 	bl	1ffe09b2 <DemoHAL_SerialWrite>
1ffe0718:	e7f0      	b.n	1ffe06fc <idle_hook+0x40>
1ffe071a:	bf00      	nop
1ffe071c:	200001cc 	.word	0x200001cc
1ffe0720:	1ffe3170 	.word	0x1ffe3170
1ffe0724:	200001c0 	.word	0x200001c0
1ffe0728:	0001869f 	.word	0x0001869f
1ffe072c:	1ffe318c 	.word	0x1ffe318c

1ffe0730 <main>:

int main(void)
{
1ffe0730:	b508      	push	{r3, lr}
  DemoHAL_Init();
1ffe0732:	f000 f8cb 	bl	1ffe08cc <DemoHAL_Init>
  InitSem(&V, 0);

  SetIdleHook(idle_hook);
#endif /* OSEE_API_DYNAMIC */

  StartOS(OSDEFAULTAPPMODE);
1ffe0736:	2000      	movs	r0, #0
1ffe0738:	f002 f9be 	bl	1ffe2ab8 <StartOS>

  return 0;
}
1ffe073c:	2000      	movs	r0, #0
1ffe073e:	bd08      	pop	{r3, pc}

1ffe0740 <FuncTask1>:

/*
 * TASK 1
 */
TASK(Task1)
{
1ffe0740:	b508      	push	{r3, lr}
  OsEE_addr curr_sp;

  serial_print("TASK1\r\n");
1ffe0742:	481e      	ldr	r0, [pc, #120]	; (1ffe07bc <FuncTask1+0x7c>)
1ffe0744:	f7ff ff85 	bl	1ffe0652 <serial_print>

  task1_fired++;
1ffe0748:	4a1d      	ldr	r2, [pc, #116]	; (1ffe07c0 <FuncTask1+0x80>)
1ffe074a:	6813      	ldr	r3, [r2, #0]
1ffe074c:	3301      	adds	r3, #1
1ffe074e:	6013      	str	r3, [r2, #0]

  isr2_armed = 1U;
1ffe0750:	4b1c      	ldr	r3, [pc, #112]	; (1ffe07c4 <FuncTask1+0x84>)
1ffe0752:	2201      	movs	r2, #1
1ffe0754:	601a      	str	r2, [r3, #0]
1ffe0756:	466a      	mov	r2, sp

  curr_sp = osEE_get_SP();
  if ( task1_sp == 0 ) {
1ffe0758:	4b1b      	ldr	r3, [pc, #108]	; (1ffe07c8 <FuncTask1+0x88>)
1ffe075a:	681b      	ldr	r3, [r3, #0]
1ffe075c:	b163      	cbz	r3, 1ffe0778 <FuncTask1+0x38>
    task1_sp = curr_sp;
  } else if ( task1_sp != curr_sp ) {
1ffe075e:	4b1a      	ldr	r3, [pc, #104]	; (1ffe07c8 <FuncTask1+0x88>)
1ffe0760:	681b      	ldr	r3, [r3, #0]
1ffe0762:	4293      	cmp	r3, r2
1ffe0764:	d00a      	beq.n	1ffe077c <FuncTask1+0x3c>
    OSEE_BREAK_POINT();
1ffe0766:	2001      	movs	r0, #1
1ffe0768:	f000 f8c8 	bl	1ffe08fc <DemoHAL_LedOn>
1ffe076c:	f002 f986 	bl	1ffe2a7c <DisableAllInterrupts>
1ffe0770:	4816      	ldr	r0, [pc, #88]	; (1ffe07cc <FuncTask1+0x8c>)
1ffe0772:	f7ff ff6e 	bl	1ffe0652 <serial_print>
1ffe0776:	e7fe      	b.n	1ffe0776 <FuncTask1+0x36>
    task1_sp = curr_sp;
1ffe0778:	4b13      	ldr	r3, [pc, #76]	; (1ffe07c8 <FuncTask1+0x88>)
1ffe077a:	601a      	str	r2, [r3, #0]
  }

  ActivateTask(Task2);
1ffe077c:	2003      	movs	r0, #3
1ffe077e:	f002 fa03 	bl	1ffe2b88 <ActivateTask>

  PostSem(&V);
1ffe0782:	4813      	ldr	r0, [pc, #76]	; (1ffe07d0 <FuncTask1+0x90>)
1ffe0784:	f002 f93c 	bl	1ffe2a00 <PostSem>

  while (isr2_armed) {
1ffe0788:	4b0e      	ldr	r3, [pc, #56]	; (1ffe07c4 <FuncTask1+0x84>)
1ffe078a:	681b      	ldr	r3, [r3, #0]
1ffe078c:	2b00      	cmp	r3, #0
1ffe078e:	d1fb      	bne.n	1ffe0788 <FuncTask1+0x48>
    ; /* Wait ISR2 release */
  }
  serial_print("Release TASK1\r\n");
1ffe0790:	4810      	ldr	r0, [pc, #64]	; (1ffe07d4 <FuncTask1+0x94>)
1ffe0792:	f7ff ff5e 	bl	1ffe0652 <serial_print>
1ffe0796:	466b      	mov	r3, sp

  curr_sp = osEE_get_SP();
  if ( task1_sp != curr_sp ) {
1ffe0798:	4a0b      	ldr	r2, [pc, #44]	; (1ffe07c8 <FuncTask1+0x88>)
1ffe079a:	6812      	ldr	r2, [r2, #0]
1ffe079c:	429a      	cmp	r2, r3
1ffe079e:	d008      	beq.n	1ffe07b2 <FuncTask1+0x72>
    OSEE_BREAK_POINT();
1ffe07a0:	2001      	movs	r0, #1
1ffe07a2:	f000 f8ab 	bl	1ffe08fc <DemoHAL_LedOn>
1ffe07a6:	f002 f969 	bl	1ffe2a7c <DisableAllInterrupts>
1ffe07aa:	480b      	ldr	r0, [pc, #44]	; (1ffe07d8 <FuncTask1+0x98>)
1ffe07ac:	f7ff ff51 	bl	1ffe0652 <serial_print>
1ffe07b0:	e7fe      	b.n	1ffe07b0 <FuncTask1+0x70>
  }

  task1_ended++;
1ffe07b2:	4a0a      	ldr	r2, [pc, #40]	; (1ffe07dc <FuncTask1+0x9c>)
1ffe07b4:	6813      	ldr	r3, [r2, #0]
1ffe07b6:	3301      	adds	r3, #1
1ffe07b8:	6013      	str	r3, [r2, #0]
}
1ffe07ba:	bd08      	pop	{r3, pc}
1ffe07bc:	1ffe31b8 	.word	0x1ffe31b8
1ffe07c0:	200001d4 	.word	0x200001d4
1ffe07c4:	200001c4 	.word	0x200001c4
1ffe07c8:	200001d8 	.word	0x200001d8
1ffe07cc:	1ffe3194 	.word	0x1ffe3194
1ffe07d0:	200001f8 	.word	0x200001f8
1ffe07d4:	1ffe31b0 	.word	0x1ffe31b0
1ffe07d8:	1ffe31c0 	.word	0x1ffe31c0
1ffe07dc:	200001d0 	.word	0x200001d0

1ffe07e0 <FuncTask2>:

/*
 * TASK 2
 */
TASK(Task2)
{
1ffe07e0:	b508      	push	{r3, lr}
  OsEE_addr  curr_sp;
  serial_print("TASK2\r\n");
1ffe07e2:	4814      	ldr	r0, [pc, #80]	; (1ffe0834 <FuncTask2+0x54>)
1ffe07e4:	f7ff ff35 	bl	1ffe0652 <serial_print>
1ffe07e8:	466a      	mov	r2, sp
  curr_sp = osEE_get_SP();
  if ( task2_sp == 0 ) {
1ffe07ea:	4b13      	ldr	r3, [pc, #76]	; (1ffe0838 <FuncTask2+0x58>)
1ffe07ec:	681b      	ldr	r3, [r3, #0]
1ffe07ee:	b163      	cbz	r3, 1ffe080a <FuncTask2+0x2a>
    task2_sp = curr_sp;
  } else if ( task2_sp != curr_sp ) {
1ffe07f0:	4b11      	ldr	r3, [pc, #68]	; (1ffe0838 <FuncTask2+0x58>)
1ffe07f2:	681b      	ldr	r3, [r3, #0]
1ffe07f4:	4293      	cmp	r3, r2
1ffe07f6:	d00a      	beq.n	1ffe080e <FuncTask2+0x2e>
    OSEE_BREAK_POINT();
1ffe07f8:	2001      	movs	r0, #1
1ffe07fa:	f000 f87f 	bl	1ffe08fc <DemoHAL_LedOn>
1ffe07fe:	f002 f93d 	bl	1ffe2a7c <DisableAllInterrupts>
1ffe0802:	480e      	ldr	r0, [pc, #56]	; (1ffe083c <FuncTask2+0x5c>)
1ffe0804:	f7ff ff25 	bl	1ffe0652 <serial_print>
1ffe0808:	e7fe      	b.n	1ffe0808 <FuncTask2+0x28>
    task2_sp = curr_sp;
1ffe080a:	4b0b      	ldr	r3, [pc, #44]	; (1ffe0838 <FuncTask2+0x58>)
1ffe080c:	601a      	str	r2, [r3, #0]
  }

  task2_fired++;
1ffe080e:	4a0c      	ldr	r2, [pc, #48]	; (1ffe0840 <FuncTask2+0x60>)
1ffe0810:	6813      	ldr	r3, [r2, #0]
1ffe0812:	3301      	adds	r3, #1
1ffe0814:	6013      	str	r3, [r2, #0]

  WaitSem(&V);
1ffe0816:	480b      	ldr	r0, [pc, #44]	; (1ffe0844 <FuncTask2+0x64>)
1ffe0818:	f002 f8bc 	bl	1ffe2994 <WaitSem>

  DemoHAL_LedToggle(DEMO_HAL_LED_3);
1ffe081c:	2003      	movs	r0, #3
1ffe081e:	f000 f889 	bl	1ffe0934 <DemoHAL_LedToggle>

  ActivateTask(Task3);
1ffe0822:	2004      	movs	r0, #4
1ffe0824:	f002 f9b0 	bl	1ffe2b88 <ActivateTask>
  task2_ended++;
1ffe0828:	4a07      	ldr	r2, [pc, #28]	; (1ffe0848 <FuncTask2+0x68>)
1ffe082a:	6813      	ldr	r3, [r2, #0]
1ffe082c:	3301      	adds	r3, #1
1ffe082e:	6013      	str	r3, [r2, #0]
}
1ffe0830:	bd08      	pop	{r3, pc}
1ffe0832:	bf00      	nop
1ffe0834:	1ffe31dc 	.word	0x1ffe31dc
1ffe0838:	200001e4 	.word	0x200001e4
1ffe083c:	1ffe31e4 	.word	0x1ffe31e4
1ffe0840:	200001e0 	.word	0x200001e0
1ffe0844:	200001f8 	.word	0x200001f8
1ffe0848:	200001dc 	.word	0x200001dc

1ffe084c <FuncTask3>:

TASK(Task3) {
1ffe084c:	b508      	push	{r3, lr}
  serial_print("TASK3\r\n");
1ffe084e:	4807      	ldr	r0, [pc, #28]	; (1ffe086c <FuncTask3+0x20>)
1ffe0850:	f7ff feff 	bl	1ffe0652 <serial_print>

  ++task3_fired;
1ffe0854:	4a06      	ldr	r2, [pc, #24]	; (1ffe0870 <FuncTask3+0x24>)
1ffe0856:	6813      	ldr	r3, [r2, #0]
1ffe0858:	3301      	adds	r3, #1
1ffe085a:	6013      	str	r3, [r2, #0]

  ActivateTask(Task4);
1ffe085c:	2005      	movs	r0, #5
1ffe085e:	f002 f993 	bl	1ffe2b88 <ActivateTask>

  ++task3_ended;
1ffe0862:	4a04      	ldr	r2, [pc, #16]	; (1ffe0874 <FuncTask3+0x28>)
1ffe0864:	6813      	ldr	r3, [r2, #0]
1ffe0866:	3301      	adds	r3, #1
1ffe0868:	6013      	str	r3, [r2, #0]
}
1ffe086a:	bd08      	pop	{r3, pc}
1ffe086c:	1ffe3200 	.word	0x1ffe3200
1ffe0870:	200001ec 	.word	0x200001ec
1ffe0874:	200001e8 	.word	0x200001e8

1ffe0878 <FuncTask4>:

TASK(Task4) {
1ffe0878:	b508      	push	{r3, lr}
  serial_print("TASK4\r\n");
1ffe087a:	4805      	ldr	r0, [pc, #20]	; (1ffe0890 <FuncTask4+0x18>)
1ffe087c:	f7ff fee9 	bl	1ffe0652 <serial_print>

  ++task4_fired;
1ffe0880:	4a04      	ldr	r2, [pc, #16]	; (1ffe0894 <FuncTask4+0x1c>)
1ffe0882:	6813      	ldr	r3, [r2, #0]
1ffe0884:	3301      	adds	r3, #1
1ffe0886:	6013      	str	r3, [r2, #0]
  ActivateTask(Task5);
1ffe0888:	2006      	movs	r0, #6
1ffe088a:	f002 f97d 	bl	1ffe2b88 <ActivateTask>

}
1ffe088e:	bd08      	pop	{r3, pc}
1ffe0890:	1ffe3208 	.word	0x1ffe3208
1ffe0894:	200001f0 	.word	0x200001f0

1ffe0898 <FuncTask5>:

TASK(Task5) {
1ffe0898:	b508      	push	{r3, lr}
  serial_print("TASK5\r\n");
1ffe089a:	4804      	ldr	r0, [pc, #16]	; (1ffe08ac <FuncTask5+0x14>)
1ffe089c:	f7ff fed9 	bl	1ffe0652 <serial_print>

  ++task5_fired;
1ffe08a0:	4a03      	ldr	r2, [pc, #12]	; (1ffe08b0 <FuncTask5+0x18>)
1ffe08a2:	6813      	ldr	r3, [r2, #0]
1ffe08a4:	3301      	adds	r3, #1
1ffe08a6:	6013      	str	r3, [r2, #0]
}
1ffe08a8:	bd08      	pop	{r3, pc}
1ffe08aa:	bf00      	nop
1ffe08ac:	1ffe3210 	.word	0x1ffe3210
1ffe08b0:	200001f4 	.word	0x200001f4

1ffe08b4 <DemoHAL_MainFunction>:
)
{
	HAL_Delay(interval*1024);
}

FUNC(void, APPL_CODE) DemoHAL_MainFunction( void ) {}
1ffe08b4:	4770      	bx	lr
	...

1ffe08b8 <DemoHAL_LedInit>:
#define	LED1		22U
#define	LED2		23U
#endif	/* OS_EE_LIB_S32_SDK */

FUNC(void, APPL_CODE) DemoHAL_LedInit( void )
{
1ffe08b8:	b508      	push	{r3, lr}
#ifdef	OS_EE_LIB_S32_SDK
	PINS_DRV_SetPinsDirection(
1ffe08ba:	f44f 0160 	mov.w	r1, #14680064	; 0xe00000
1ffe08be:	4802      	ldr	r0, [pc, #8]	; (1ffe08c8 <DemoHAL_LedInit+0x10>)
1ffe08c0:	f001 ff02 	bl	1ffe26c8 <PINS_DRV_SetPinsDirection>
		LED_GPIO_PORT,
		((1 << LED0) | (1 << LED1) | (1 << LED2))
	);
	*/
#endif	/* OS_EE_LIB_S32_SDK */
}
1ffe08c4:	bd08      	pop	{r3, pc}
1ffe08c6:	bf00      	nop
1ffe08c8:	400ff100 	.word	0x400ff100

1ffe08cc <DemoHAL_Init>:
{
1ffe08cc:	b508      	push	{r3, lr}
	CLOCK_SYS_Init(
1ffe08ce:	2300      	movs	r3, #0
1ffe08d0:	4a07      	ldr	r2, [pc, #28]	; (1ffe08f0 <DemoHAL_Init+0x24>)
1ffe08d2:	2101      	movs	r1, #1
1ffe08d4:	4807      	ldr	r0, [pc, #28]	; (1ffe08f4 <DemoHAL_Init+0x28>)
1ffe08d6:	f001 fb95 	bl	1ffe2004 <CLOCK_SYS_Init>
	CLOCK_SYS_UpdateConfiguration(
1ffe08da:	2100      	movs	r1, #0
1ffe08dc:	4608      	mov	r0, r1
1ffe08de:	f001 fba5 	bl	1ffe202c <CLOCK_SYS_UpdateConfiguration>
	PINS_DRV_Init(NUM_OF_CONFIGURED_PINS, g_pin_mux_InitConfigArr);
1ffe08e2:	4905      	ldr	r1, [pc, #20]	; (1ffe08f8 <DemoHAL_Init+0x2c>)
1ffe08e4:	2005      	movs	r0, #5
1ffe08e6:	f001 fedf 	bl	1ffe26a8 <PINS_DRV_Init>
	DemoHAL_LedInit();
1ffe08ea:	f7ff ffe5 	bl	1ffe08b8 <DemoHAL_LedInit>
}
1ffe08ee:	bd08      	pop	{r3, pc}
1ffe08f0:	1ffe3428 	.word	0x1ffe3428
1ffe08f4:	1ffe342c 	.word	0x1ffe342c
1ffe08f8:	1ffe3430 	.word	0x1ffe3430

1ffe08fc <DemoHAL_LedOn>:

FUNC(void, APPL_CODE) DemoHAL_LedOn(
	VAR(DemoHAL_Led, AUTOMATIC)				led
)
{
1ffe08fc:	b508      	push	{r3, lr}
	switch (led) {
1ffe08fe:	2801      	cmp	r0, #1
1ffe0900:	d009      	beq.n	1ffe0916 <DemoHAL_LedOn+0x1a>
1ffe0902:	2803      	cmp	r0, #3
1ffe0904:	d00d      	beq.n	1ffe0922 <DemoHAL_LedOn+0x26>
1ffe0906:	b100      	cbz	r0, 1ffe090a <DemoHAL_LedOn+0xe>
	case DEMO_HAL_LED_6:
	case DEMO_HAL_LED_7:
	default:
		break;
	}
}
1ffe0908:	bd08      	pop	{r3, pc}
		PINS_DRV_WritePin(LED_GPIO_PORT, LED0, 1U);
1ffe090a:	2201      	movs	r2, #1
1ffe090c:	2115      	movs	r1, #21
1ffe090e:	4808      	ldr	r0, [pc, #32]	; (1ffe0930 <DemoHAL_LedOn+0x34>)
1ffe0910:	f001 fedc 	bl	1ffe26cc <PINS_DRV_WritePin>
		break;
1ffe0914:	e7f8      	b.n	1ffe0908 <DemoHAL_LedOn+0xc>
		PINS_DRV_WritePin(LED_GPIO_PORT, LED1, 1U);
1ffe0916:	2201      	movs	r2, #1
1ffe0918:	2116      	movs	r1, #22
1ffe091a:	4805      	ldr	r0, [pc, #20]	; (1ffe0930 <DemoHAL_LedOn+0x34>)
1ffe091c:	f001 fed6 	bl	1ffe26cc <PINS_DRV_WritePin>
		break;
1ffe0920:	e7f2      	b.n	1ffe0908 <DemoHAL_LedOn+0xc>
		PINS_DRV_WritePin(LED_GPIO_PORT, LED2, 1U);
1ffe0922:	2201      	movs	r2, #1
1ffe0924:	2117      	movs	r1, #23
1ffe0926:	4802      	ldr	r0, [pc, #8]	; (1ffe0930 <DemoHAL_LedOn+0x34>)
1ffe0928:	f001 fed0 	bl	1ffe26cc <PINS_DRV_WritePin>
}
1ffe092c:	e7ec      	b.n	1ffe0908 <DemoHAL_LedOn+0xc>
1ffe092e:	bf00      	nop
1ffe0930:	400ff100 	.word	0x400ff100

1ffe0934 <DemoHAL_LedToggle>:
}

FUNC(void, APPL_CODE) DemoHAL_LedToggle(
	VAR(DemoHAL_Led, AUTOMATIC)				led
)
{
1ffe0934:	b508      	push	{r3, lr}
	switch (led) {
1ffe0936:	2801      	cmp	r0, #1
1ffe0938:	d009      	beq.n	1ffe094e <DemoHAL_LedToggle+0x1a>
1ffe093a:	2803      	cmp	r0, #3
1ffe093c:	d00d      	beq.n	1ffe095a <DemoHAL_LedToggle+0x26>
1ffe093e:	b100      	cbz	r0, 1ffe0942 <DemoHAL_LedToggle+0xe>
	case DEMO_HAL_LED_6:
	case DEMO_HAL_LED_7:
	default:
		break;
	}
}
1ffe0940:	bd08      	pop	{r3, pc}
		PINS_DRV_TogglePins(LED_GPIO_PORT, (1 << LED0));
1ffe0942:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
1ffe0946:	4808      	ldr	r0, [pc, #32]	; (1ffe0968 <DemoHAL_LedToggle+0x34>)
1ffe0948:	f001 fecc 	bl	1ffe26e4 <PINS_DRV_TogglePins>
		break;
1ffe094c:	e7f8      	b.n	1ffe0940 <DemoHAL_LedToggle+0xc>
		PINS_DRV_TogglePins(LED_GPIO_PORT, (1 << LED1));
1ffe094e:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
1ffe0952:	4805      	ldr	r0, [pc, #20]	; (1ffe0968 <DemoHAL_LedToggle+0x34>)
1ffe0954:	f001 fec6 	bl	1ffe26e4 <PINS_DRV_TogglePins>
		break;
1ffe0958:	e7f2      	b.n	1ffe0940 <DemoHAL_LedToggle+0xc>
		PINS_DRV_TogglePins(LED_GPIO_PORT, (1 << LED2));
1ffe095a:	f44f 0100 	mov.w	r1, #8388608	; 0x800000
1ffe095e:	4802      	ldr	r0, [pc, #8]	; (1ffe0968 <DemoHAL_LedToggle+0x34>)
1ffe0960:	f001 fec0 	bl	1ffe26e4 <PINS_DRV_TogglePins>
}
1ffe0964:	e7ec      	b.n	1ffe0940 <DemoHAL_LedToggle+0xc>
1ffe0966:	bf00      	nop
1ffe0968:	400ff100 	.word	0x400ff100

1ffe096c <DemoHAL_TimerInit>:
     false /* Initialization trigger */
};
#endif	/* OS_EE_LIB_S32_SDK */

FUNC(void, APPL_CODE) DemoHAL_TimerInit( VAR(MemSize, AUTOMATIC) period )
{
1ffe096c:	b510      	push	{r4, lr}
1ffe096e:	4604      	mov	r4, r0
#ifdef	OS_EE_LIB_S32_SDK
	/* Initialize Flex Timer instance as simple timer */
	FTM_DRV_Init(INST_FLEXTIMER1, &flexTimer1_InitConfig, &ftmStateStruct);
1ffe0970:	4a09      	ldr	r2, [pc, #36]	; (1ffe0998 <DemoHAL_TimerInit+0x2c>)
1ffe0972:	490a      	ldr	r1, [pc, #40]	; (1ffe099c <DemoHAL_TimerInit+0x30>)
1ffe0974:	2000      	movs	r0, #0
1ffe0976:	f001 fd31 	bl	1ffe23dc <FTM_DRV_Init>
	/* Setup the counter to trigger an interrupt every 1 ms */
	flexTimer1_TimerConfig.finalValue = 375*period;
1ffe097a:	4909      	ldr	r1, [pc, #36]	; (1ffe09a0 <DemoHAL_TimerInit+0x34>)
1ffe097c:	eb04 0484 	add.w	r4, r4, r4, lsl #2
1ffe0980:	eb04 0484 	add.w	r4, r4, r4, lsl #2
1ffe0984:	ebc4 1404 	rsb	r4, r4, r4, lsl #4
1ffe0988:	808c      	strh	r4, [r1, #4]
	FTM_DRV_InitCounter(INST_FLEXTIMER1, &flexTimer1_TimerConfig);
1ffe098a:	2000      	movs	r0, #0
1ffe098c:	f001 fdf6 	bl	1ffe257c <FTM_DRV_InitCounter>
	/* Start the counter */
	FTM_DRV_CounterStart(INST_FLEXTIMER1);
1ffe0990:	2000      	movs	r0, #0
1ffe0992:	f001 fe45 	bl	1ffe2620 <FTM_DRV_CounterStart>
#endif	/* OS_EE_LIB_S32_SDK */
}
1ffe0996:	bd10      	pop	{r4, pc}
1ffe0998:	2000061c 	.word	0x2000061c
1ffe099c:	1ffe3414 	.word	0x1ffe3414
1ffe09a0:	200000e4 	.word	0x200000e4

1ffe09a4 <DemoHAL_TimerAck>:

FUNC(void, APPL_CODE) DemoHAL_TimerDelay( VAR(MemSize, AUTOMATIC) interval )
{ (void)interval; }

FUNC(void, APPL_CODE) DemoHAL_TimerAck( void )
{
1ffe09a4:	b508      	push	{r3, lr}
#ifdef	OS_EE_LIB_S32_SDK
#ifdef	OS_EE_LIB_S32_SDK_0_8_6_EAR
	/* Clear FTM Timer Overflow flag */
	FTM_DRV_ClearStatusFlags(INST_FLEXTIMER1, FTM_TIME_OVER_FLOW_FLAG);
1ffe09a6:	f44f 7100 	mov.w	r1, #512	; 0x200
1ffe09aa:	2000      	movs	r0, #0
1ffe09ac:	f001 fc9c 	bl	1ffe22e8 <FTM_DRV_ClearStatusFlags>
#else	/* OS_EE_LIB_S32_SDK_0_8_6_EAR */
	/* Clear FTM Timer Overflow flag */
	FTM_DRV_ClearTimerOverflow(g_ftmBase[INST_FLEXTIMER1]);
#endif	/* OS_EE_LIB_S32_SDK_0_8_6_EAR */
#endif	/* OS_EE_LIB_S32_SDK */
}
1ffe09b0:	bd08      	pop	{r3, pc}

1ffe09b2 <DemoHAL_SerialWrite>:
FUNC(void, APPL_CODE) DemoHAL_SerialInit( void ) {}

FUNC(void, APPL_CODE) DemoHAL_SerialWrite(
	P2CONST(uint8_t, AUTOMATIC, OS_APPL_DATA)	buffer,
	VAR(MemSize, AUTOMATIC)						length
) { (void)buffer; (void)length;}
1ffe09b2:	4770      	bx	lr

1ffe09b4 <CLOCK_SYS_SetPccConfiguration>:
 * Function Name : CLOCK_SYS_SetPccConfiguration
 * Description   : This function configures the PCC block
 *
 * END**************************************************************************/
static void CLOCK_SYS_SetPccConfiguration(const pcc_config_t * peripheralClockConfig)
{
1ffe09b4:	b510      	push	{r4, lr}
    DEV_ASSERT(peripheralClockConfig != NULL);

    uint32_t i;

    if ((peripheralClockConfig != NULL) && (peripheralClockConfig->peripheralClocks != NULL))
1ffe09b6:	4684      	mov	ip, r0
1ffe09b8:	2800      	cmp	r0, #0
1ffe09ba:	d038      	beq.n	1ffe0a2e <CLOCK_SYS_SetPccConfiguration+0x7a>
1ffe09bc:	6843      	ldr	r3, [r0, #4]
1ffe09be:	2b00      	cmp	r3, #0
1ffe09c0:	d035      	beq.n	1ffe0a2e <CLOCK_SYS_SetPccConfiguration+0x7a>
    {
        for (i = 0U; i < peripheralClockConfig->count; i++)
1ffe09c2:	2100      	movs	r1, #0
1ffe09c4:	e008      	b.n	1ffe09d8 <CLOCK_SYS_SetPccConfiguration+0x24>
{
   /* Configure the peripheral clock source, the fractional clock divider and the clock gate */
   uint32_t value =  PCC_PCCn_PCS(clockSource)              |
                     PCC_PCCn_FRAC(multiplier)              |
                     PCC_PCCn_PCD(divider)                  |
                     PCC_PCCn_CGC(clockGate ? 1UL : 0UL );
1ffe09c6:	2200      	movs	r2, #0
   uint32_t value =  PCC_PCCn_PCS(clockSource)              |
1ffe09c8:	4313      	orrs	r3, r2

   base->PCCn[clockNameMappings[clockName]] = value;
1ffe09ca:	4a19      	ldr	r2, [pc, #100]	; (1ffe0a30 <CLOCK_SYS_SetPccConfiguration+0x7c>)
1ffe09cc:	f832 0010 	ldrh.w	r0, [r2, r0, lsl #1]
1ffe09d0:	4a18      	ldr	r2, [pc, #96]	; (1ffe0a34 <CLOCK_SYS_SetPccConfiguration+0x80>)
1ffe09d2:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
1ffe09d6:	3101      	adds	r1, #1
1ffe09d8:	f8dc 3000 	ldr.w	r3, [ip]
1ffe09dc:	428b      	cmp	r3, r1
1ffe09de:	d926      	bls.n	1ffe0a2e <CLOCK_SYS_SetPccConfiguration+0x7a>
        {
            /* Disable the peripheral clock */
            PCC_SetClockMode(PCC, peripheralClockConfig->peripheralClocks[i].clockName, false);
1ffe09e0:	f8dc 2004 	ldr.w	r2, [ip, #4]
1ffe09e4:	eb01 0381 	add.w	r3, r1, r1, lsl #2
1ffe09e8:	5cd0      	ldrb	r0, [r2, r3]
   {
       base->PCCn[clockNameMappings[clockName]] |= PCC_PCCn_CGC(1UL);
   }
   else
   {
       base->PCCn[clockNameMappings[clockName]] &= (uint32_t)(~(PCC_PCCn_CGC_MASK));
1ffe09ea:	4a11      	ldr	r2, [pc, #68]	; (1ffe0a30 <CLOCK_SYS_SetPccConfiguration+0x7c>)
1ffe09ec:	f832 4010 	ldrh.w	r4, [r2, r0, lsl #1]
1ffe09f0:	4810      	ldr	r0, [pc, #64]	; (1ffe0a34 <CLOCK_SYS_SetPccConfiguration+0x80>)
1ffe09f2:	f850 2024 	ldr.w	r2, [r0, r4, lsl #2]
1ffe09f6:	f022 4280 	bic.w	r2, r2, #1073741824	; 0x40000000
1ffe09fa:	f840 2024 	str.w	r2, [r0, r4, lsl #2]

            /* Set peripheral clock control */
            PCC_SetPeripheralClockControl(PCC,
                                          peripheralClockConfig->peripheralClocks[i].clockName,
1ffe09fe:	f8dc 0004 	ldr.w	r0, [ip, #4]
1ffe0a02:	18c2      	adds	r2, r0, r3
            PCC_SetPeripheralClockControl(PCC,
1ffe0a04:	5cc0      	ldrb	r0, [r0, r3]
1ffe0a06:	7854      	ldrb	r4, [r2, #1]
                                          peripheralClockConfig->peripheralClocks[i].clkGate,
                                          (uint32_t)peripheralClockConfig->peripheralClocks[i].clkSrc,
1ffe0a08:	7893      	ldrb	r3, [r2, #2]
                                          (uint32_t)peripheralClockConfig->peripheralClocks[i].divider,
1ffe0a0a:	f892 e004 	ldrb.w	lr, [r2, #4]
                                          (uint32_t)peripheralClockConfig->peripheralClocks[i].frac);
1ffe0a0e:	78d2      	ldrb	r2, [r2, #3]
   uint32_t value =  PCC_PCCn_PCS(clockSource)              |
1ffe0a10:	061b      	lsls	r3, r3, #24
1ffe0a12:	f003 63e0 	and.w	r3, r3, #117440512	; 0x7000000
                     PCC_PCCn_FRAC(multiplier)              |
1ffe0a16:	00d2      	lsls	r2, r2, #3
1ffe0a18:	f002 0208 	and.w	r2, r2, #8
   uint32_t value =  PCC_PCCn_PCS(clockSource)              |
1ffe0a1c:	4313      	orrs	r3, r2
                     PCC_PCCn_PCD(divider)                  |
1ffe0a1e:	f00e 0207 	and.w	r2, lr, #7
                     PCC_PCCn_FRAC(multiplier)              |
1ffe0a22:	4313      	orrs	r3, r2
                     PCC_PCCn_CGC(clockGate ? 1UL : 0UL );
1ffe0a24:	2c00      	cmp	r4, #0
1ffe0a26:	d0ce      	beq.n	1ffe09c6 <CLOCK_SYS_SetPccConfiguration+0x12>
1ffe0a28:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
1ffe0a2c:	e7cc      	b.n	1ffe09c8 <CLOCK_SYS_SetPccConfiguration+0x14>
        }
    }
}
1ffe0a2e:	bd10      	pop	{r4, pc}
1ffe0a30:	1ffe34b8 	.word	0x1ffe34b8
1ffe0a34:	40065000 	.word	0x40065000

1ffe0a38 <CLOCK_SYS_SetSimConfiguration>:
 * Function Name : CLOCK_SYS_SetSimConfiguration
 * Description   : This function configures the SIM block
 *
 * END**************************************************************************/
static void CLOCK_SYS_SetSimConfiguration(const sim_clock_config_t * simClockConfig)
{
1ffe0a38:	b430      	push	{r4, r5}
    DEV_ASSERT(simClockConfig != NULL);
    uint8_t i;

    /* ClockOut settings. */
    if (simClockConfig->clockOutConfig.initialize)
1ffe0a3a:	7803      	ldrb	r3, [r0, #0]
1ffe0a3c:	2b00      	cmp	r3, #0
1ffe0a3e:	d174      	bne.n	1ffe0b2a <CLOCK_SYS_SetSimConfiguration+0xf2>
    {
        SIM_SetClockout(SIM, simClockConfig->clockOutConfig.enable, simClockConfig->clockOutConfig.source, simClockConfig->clockOutConfig.divider);
    }

    /* Low Power Clock settings from SIM. */
    if (simClockConfig->lpoClockConfig.initialize)
1ffe0a40:	7903      	ldrb	r3, [r0, #4]
1ffe0a42:	2b00      	cmp	r3, #0
1ffe0a44:	f040 808b 	bne.w	1ffe0b5e <CLOCK_SYS_SetSimConfiguration+0x126>
                         simClockConfig->lpoClockConfig.sourceLpoClk,
                         simClockConfig->lpoClockConfig.sourceRtcClk);
    }

    /* Platform Gate Clock settings. */
    if (simClockConfig->platGateConfig.initialize)
1ffe0a48:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
1ffe0a4c:	2b00      	cmp	r3, #0
1ffe0a4e:	d046      	beq.n	1ffe0ade <CLOCK_SYS_SetSimConfiguration+0xa6>
    {
        SIM_SetMscmClockGate(SIM, simClockConfig->platGateConfig.enableMscm);
1ffe0a50:	f890 203d 	ldrb.w	r2, [r0, #61]	; 0x3d
 * @param[in] base Base address for current SIM instance.
 * @param[in] enable MPU clock gate enable setting
 */
static inline void SIM_SetMscmClockGate(SIM_Type* base, bool enable)
{
    uint32_t regValue = (uint32_t)base->PLATCGC;
1ffe0a54:	4b89      	ldr	r3, [pc, #548]	; (1ffe0c7c <CLOCK_SYS_SetSimConfiguration+0x244>)
1ffe0a56:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    regValue &= (uint32_t)(~(SIM_PLATCGC_CGCMSCM_MASK));
1ffe0a58:	f023 0301 	bic.w	r3, r3, #1
    regValue |= SIM_PLATCGC_CGCMSCM(enable ? 1UL : 0UL);
1ffe0a5c:	2a00      	cmp	r2, #0
1ffe0a5e:	f000 809b 	beq.w	1ffe0b98 <CLOCK_SYS_SetSimConfiguration+0x160>
1ffe0a62:	2201      	movs	r2, #1
1ffe0a64:	4313      	orrs	r3, r2
    base->PLATCGC = (uint32_t)regValue;
1ffe0a66:	4a85      	ldr	r2, [pc, #532]	; (1ffe0c7c <CLOCK_SYS_SetSimConfiguration+0x244>)
1ffe0a68:	6413      	str	r3, [r2, #64]	; 0x40
        SIM_SetMpuClockGate(SIM, simClockConfig->platGateConfig.enableMpu);
1ffe0a6a:	f890 103e 	ldrb.w	r1, [r0, #62]	; 0x3e
    uint32_t regValue = (uint32_t)base->PLATCGC;
1ffe0a6e:	6c13      	ldr	r3, [r2, #64]	; 0x40
    regValue &= (uint32_t)(~(SIM_PLATCGC_CGCMPU_MASK));
1ffe0a70:	f023 0302 	bic.w	r3, r3, #2
    regValue |= SIM_PLATCGC_CGCMPU(enable ? 1UL : 0UL);
1ffe0a74:	2900      	cmp	r1, #0
1ffe0a76:	f000 8091 	beq.w	1ffe0b9c <CLOCK_SYS_SetSimConfiguration+0x164>
1ffe0a7a:	2202      	movs	r2, #2
1ffe0a7c:	4313      	orrs	r3, r2
    base->PLATCGC = (uint32_t)regValue;
1ffe0a7e:	4a7f      	ldr	r2, [pc, #508]	; (1ffe0c7c <CLOCK_SYS_SetSimConfiguration+0x244>)
1ffe0a80:	6413      	str	r3, [r2, #64]	; 0x40
        SIM_SetDmaClockGate(SIM, simClockConfig->platGateConfig.enableDma);
1ffe0a82:	f890 103f 	ldrb.w	r1, [r0, #63]	; 0x3f
    uint32_t regValue = (uint32_t)base->PLATCGC;
1ffe0a86:	6c13      	ldr	r3, [r2, #64]	; 0x40
    regValue &= (uint32_t)(~(SIM_PLATCGC_CGCDMA_MASK));
1ffe0a88:	f023 0304 	bic.w	r3, r3, #4
    regValue |= SIM_PLATCGC_CGCDMA(enable ? 1UL : 0UL);
1ffe0a8c:	2900      	cmp	r1, #0
1ffe0a8e:	f000 8087 	beq.w	1ffe0ba0 <CLOCK_SYS_SetSimConfiguration+0x168>
1ffe0a92:	2204      	movs	r2, #4
1ffe0a94:	4313      	orrs	r3, r2
    base->PLATCGC = (uint32_t)regValue;
1ffe0a96:	4a79      	ldr	r2, [pc, #484]	; (1ffe0c7c <CLOCK_SYS_SetSimConfiguration+0x244>)
1ffe0a98:	6413      	str	r3, [r2, #64]	; 0x40
        SIM_SetErmClockGate(SIM, simClockConfig->platGateConfig.enableErm);
1ffe0a9a:	f890 1040 	ldrb.w	r1, [r0, #64]	; 0x40
    uint32_t regValue = (uint32_t)base->PLATCGC;
1ffe0a9e:	6c13      	ldr	r3, [r2, #64]	; 0x40
    regValue &= (uint32_t)(~(SIM_PLATCGC_CGCERM_MASK));
1ffe0aa0:	f023 0308 	bic.w	r3, r3, #8
    regValue |= SIM_PLATCGC_CGCERM(enable ? 1UL : 0UL);
1ffe0aa4:	2900      	cmp	r1, #0
1ffe0aa6:	d07d      	beq.n	1ffe0ba4 <CLOCK_SYS_SetSimConfiguration+0x16c>
1ffe0aa8:	2208      	movs	r2, #8
1ffe0aaa:	4313      	orrs	r3, r2
    base->PLATCGC = (uint32_t)regValue;
1ffe0aac:	4a73      	ldr	r2, [pc, #460]	; (1ffe0c7c <CLOCK_SYS_SetSimConfiguration+0x244>)
1ffe0aae:	6413      	str	r3, [r2, #64]	; 0x40
        SIM_SetEimClockGate(SIM, simClockConfig->platGateConfig.enableEim);
1ffe0ab0:	f890 1041 	ldrb.w	r1, [r0, #65]	; 0x41
    uint32_t regValue = (uint32_t)base->PLATCGC;
1ffe0ab4:	6c13      	ldr	r3, [r2, #64]	; 0x40
    regValue &= (uint32_t)(~(SIM_PLATCGC_CGCEIM_MASK));
1ffe0ab6:	f023 0310 	bic.w	r3, r3, #16
    regValue |= SIM_PLATCGC_CGCEIM(enable ? 1UL : 0UL);
1ffe0aba:	2900      	cmp	r1, #0
1ffe0abc:	d074      	beq.n	1ffe0ba8 <CLOCK_SYS_SetSimConfiguration+0x170>
1ffe0abe:	2210      	movs	r2, #16
1ffe0ac0:	4313      	orrs	r3, r2
    base->PLATCGC = (uint32_t)regValue;
1ffe0ac2:	4a6e      	ldr	r2, [pc, #440]	; (1ffe0c7c <CLOCK_SYS_SetSimConfiguration+0x244>)
1ffe0ac4:	6413      	str	r3, [r2, #64]	; 0x40
#if defined (QuadSPI_INSTANCE_COUNT)
        SIM_SetQspiIntRefClockGate(SIM, simClockConfig->qspiRefClkGating.enableQspiRefClk);
1ffe0ac6:	f890 1047 	ldrb.w	r1, [r0, #71]	; 0x47
 * @param[in] base Base address for current SIM instance.
 * @param[in] configures QuadSPI Internal Reference Clock Gating
 */
static inline void SIM_SetQspiIntRefClockGate(SIM_Type* base, bool enable)
{
    uint32_t regValue = (uint32_t)base->MISCTRL0;
1ffe0aca:	6a13      	ldr	r3, [r2, #32]
    regValue &= (uint32_t)(~(SIM_MISCTRL0_QSPI_CLK_SEL_MASK));
1ffe0acc:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
    regValue |= SIM_MISCTRL0_QSPI_CLK_SEL(enable ? 1UL : 0UL);
1ffe0ad0:	2900      	cmp	r1, #0
1ffe0ad2:	d06b      	beq.n	1ffe0bac <CLOCK_SYS_SetSimConfiguration+0x174>
1ffe0ad4:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
1ffe0ad8:	4313      	orrs	r3, r2
    base->MISCTRL0 = (uint32_t)regValue;
1ffe0ada:	4a68      	ldr	r2, [pc, #416]	; (1ffe0c7c <CLOCK_SYS_SetSimConfiguration+0x244>)
1ffe0adc:	6213      	str	r3, [r2, #32]
#endif
    }

    /* TCLK Clock settings. */
    if (simClockConfig->tclkConfig.initialize)
1ffe0ade:	7b03      	ldrb	r3, [r0, #12]
1ffe0ae0:	2b00      	cmp	r3, #0
1ffe0ae2:	d172      	bne.n	1ffe0bca <CLOCK_SYS_SetSimConfiguration+0x192>
        }
    }

#if defined (S32K14x_SERIES)
    /* Debug trace Clock settings. */
    if (simClockConfig->traceClockConfig.initialize)
1ffe0ae4:	f890 3042 	ldrb.w	r3, [r0, #66]	; 0x42
1ffe0ae8:	b1eb      	cbz	r3, 1ffe0b26 <CLOCK_SYS_SetSimConfiguration+0xee>
 * @param[in] base Register base address for the SIM instance.
 */
static inline void SIM_ClearTraceClockConfig(SIM_Type * base)
{
    /* Disable divider. */
    base->CLKDIV4 &= 0U;
1ffe0aea:	4b64      	ldr	r3, [pc, #400]	; (1ffe0c7c <CLOCK_SYS_SetSimConfiguration+0x244>)
1ffe0aec:	6e9a      	ldr	r2, [r3, #104]	; 0x68
1ffe0aee:	2400      	movs	r4, #0
1ffe0af0:	669c      	str	r4, [r3, #104]	; 0x68
    {
        SIM_ClearTraceClockConfig(SIM);
        SIM_SetTraceClockSource(SIM, simClockConfig->traceClockConfig.source);
1ffe0af2:	f890 1044 	ldrb.w	r1, [r0, #68]	; 0x44
    regValue = (uint32_t)base->CHIPCTL;
1ffe0af6:	685a      	ldr	r2, [r3, #4]
    regValue &= (uint32_t)(~(SIM_CHIPCTL_TRACECLK_SEL_MASK));
1ffe0af8:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
    regValue |= SIM_CHIPCTL_TRACECLK_SEL(clTraceSrc);
1ffe0afc:	0309      	lsls	r1, r1, #12
1ffe0afe:	f401 5180 	and.w	r1, r1, #4096	; 0x1000
1ffe0b02:	430a      	orrs	r2, r1
    base->CHIPCTL = (uint32_t)regValue;
1ffe0b04:	605a      	str	r2, [r3, #4]
 * @param[in] base        sim base pointer
 * @param[in] source      clock trace source
 */
static inline void SIM_SetTraceClockConfig(SIM_Type * base, bool enable, uint32_t divider, uint32_t multiplier)
{
    base->CLKDIV4 = SIM_CLKDIV4_TRACEDIVEN(enable ? 1UL : 0UL) |
1ffe0b06:	669c      	str	r4, [r3, #104]	; 0x68

        SIM_SetTraceClockConfig(SIM, false, 0U, 0U);

        if (simClockConfig->traceClockConfig.divEnable)
1ffe0b08:	f890 3043 	ldrb.w	r3, [r0, #67]	; 0x43
1ffe0b0c:	b15b      	cbz	r3, 1ffe0b26 <CLOCK_SYS_SetSimConfiguration+0xee>
        {
            SIM_SetTraceClockConfig(SIM,
                                    simClockConfig->traceClockConfig.divEnable,
                                    simClockConfig->traceClockConfig.divider,
1ffe0b0e:	f890 3045 	ldrb.w	r3, [r0, #69]	; 0x45
                                    simClockConfig->traceClockConfig.divFraction);
1ffe0b12:	f890 2046 	ldrb.w	r2, [r0, #70]	; 0x46
                    SIM_CLKDIV4_TRACEDIV(divider)              |
1ffe0b16:	005b      	lsls	r3, r3, #1
1ffe0b18:	f003 030e 	and.w	r3, r3, #14
    base->CLKDIV4 = SIM_CLKDIV4_TRACEDIVEN(enable ? 1UL : 0UL) |
1ffe0b1c:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
                    SIM_CLKDIV4_TRACEDIV(divider)              |
1ffe0b20:	4313      	orrs	r3, r2
    base->CLKDIV4 = SIM_CLKDIV4_TRACEDIVEN(enable ? 1UL : 0UL) |
1ffe0b22:	4a56      	ldr	r2, [pc, #344]	; (1ffe0c7c <CLOCK_SYS_SetSimConfiguration+0x244>)
1ffe0b24:	6693      	str	r3, [r2, #104]	; 0x68
        }
    }
#endif
}
1ffe0b26:	bc30      	pop	{r4, r5}
1ffe0b28:	4770      	bx	lr
        SIM_SetClockout(SIM, simClockConfig->clockOutConfig.enable, simClockConfig->clockOutConfig.source, simClockConfig->clockOutConfig.divider);
1ffe0b2a:	7845      	ldrb	r5, [r0, #1]
1ffe0b2c:	7881      	ldrb	r1, [r0, #2]
1ffe0b2e:	78c2      	ldrb	r2, [r0, #3]
    regValue = base->CHIPCTL;
1ffe0b30:	4c52      	ldr	r4, [pc, #328]	; (1ffe0c7c <CLOCK_SYS_SetSimConfiguration+0x244>)
1ffe0b32:	6863      	ldr	r3, [r4, #4]
    regValue &= ~( SIM_CHIPCTL_CLKOUTEN_MASK  |
1ffe0b34:	f423 637f 	bic.w	r3, r3, #4080	; 0xff0
    base->CHIPCTL = regValue;
1ffe0b38:	6063      	str	r3, [r4, #4]
    regValue |= SIM_CHIPCTL_CLKOUTSEL(source);
1ffe0b3a:	0109      	lsls	r1, r1, #4
1ffe0b3c:	b2c9      	uxtb	r1, r1
1ffe0b3e:	430b      	orrs	r3, r1
    base->CHIPCTL = regValue;
1ffe0b40:	6063      	str	r3, [r4, #4]
    regValue |= SIM_CHIPCTL_CLKOUTDIV(divider);
1ffe0b42:	0212      	lsls	r2, r2, #8
1ffe0b44:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
1ffe0b48:	4313      	orrs	r3, r2
    base->CHIPCTL = regValue;
1ffe0b4a:	6063      	str	r3, [r4, #4]
    regValue |= SIM_CHIPCTL_CLKOUTEN(enable ? 1UL : 0UL);
1ffe0b4c:	b12d      	cbz	r5, 1ffe0b5a <CLOCK_SYS_SetSimConfiguration+0x122>
1ffe0b4e:	f44f 6200 	mov.w	r2, #2048	; 0x800
1ffe0b52:	4313      	orrs	r3, r2
    base->CHIPCTL = regValue;
1ffe0b54:	4a49      	ldr	r2, [pc, #292]	; (1ffe0c7c <CLOCK_SYS_SetSimConfiguration+0x244>)
1ffe0b56:	6053      	str	r3, [r2, #4]
}
1ffe0b58:	e772      	b.n	1ffe0a40 <CLOCK_SYS_SetSimConfiguration+0x8>
    regValue |= SIM_CHIPCTL_CLKOUTEN(enable ? 1UL : 0UL);
1ffe0b5a:	2200      	movs	r2, #0
1ffe0b5c:	e7f9      	b.n	1ffe0b52 <CLOCK_SYS_SetSimConfiguration+0x11a>
        SIM_SetLpoClocks(SIM,
1ffe0b5e:	7a05      	ldrb	r5, [r0, #8]
1ffe0b60:	79c4      	ldrb	r4, [r0, #7]
                         simClockConfig->lpoClockConfig.sourceLpoClk,
1ffe0b62:	7981      	ldrb	r1, [r0, #6]
                         simClockConfig->lpoClockConfig.sourceRtcClk);
1ffe0b64:	7942      	ldrb	r2, [r0, #5]
    uint32_t regValue = base->LPOCLKS;
1ffe0b66:	4b45      	ldr	r3, [pc, #276]	; (1ffe0c7c <CLOCK_SYS_SetSimConfiguration+0x244>)
1ffe0b68:	691b      	ldr	r3, [r3, #16]
    regValue &= ~( SIM_LPOCLKS_LPO1KCLKEN_MASK  |
1ffe0b6a:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
    regValue |= SIM_LPOCLKS_LPO1KCLKEN(enableLpo1k ? 1UL : 0UL);
1ffe0b6e:	b17d      	cbz	r5, 1ffe0b90 <CLOCK_SYS_SetSimConfiguration+0x158>
1ffe0b70:	2501      	movs	r5, #1
1ffe0b72:	432b      	orrs	r3, r5
    regValue |= SIM_LPOCLKS_LPO32KCLKEN(enableLpo32k ? 1UL : 0UL);
1ffe0b74:	b174      	cbz	r4, 1ffe0b94 <CLOCK_SYS_SetSimConfiguration+0x15c>
1ffe0b76:	2402      	movs	r4, #2
1ffe0b78:	4323      	orrs	r3, r4
    regValue |= SIM_LPOCLKS_LPOCLKSEL(sourceLpoClk);
1ffe0b7a:	0089      	lsls	r1, r1, #2
1ffe0b7c:	f001 010c 	and.w	r1, r1, #12
1ffe0b80:	430b      	orrs	r3, r1
    regValue |= SIM_LPOCLKS_RTCCLKSEL(sourceRtcClk);
1ffe0b82:	0112      	lsls	r2, r2, #4
1ffe0b84:	f002 0230 	and.w	r2, r2, #48	; 0x30
1ffe0b88:	4313      	orrs	r3, r2
    base->LPOCLKS = regValue;
1ffe0b8a:	4a3c      	ldr	r2, [pc, #240]	; (1ffe0c7c <CLOCK_SYS_SetSimConfiguration+0x244>)
1ffe0b8c:	6113      	str	r3, [r2, #16]
}
1ffe0b8e:	e75b      	b.n	1ffe0a48 <CLOCK_SYS_SetSimConfiguration+0x10>
    regValue |= SIM_LPOCLKS_LPO1KCLKEN(enableLpo1k ? 1UL : 0UL);
1ffe0b90:	2500      	movs	r5, #0
1ffe0b92:	e7ee      	b.n	1ffe0b72 <CLOCK_SYS_SetSimConfiguration+0x13a>
    regValue |= SIM_LPOCLKS_LPO32KCLKEN(enableLpo32k ? 1UL : 0UL);
1ffe0b94:	2400      	movs	r4, #0
1ffe0b96:	e7ef      	b.n	1ffe0b78 <CLOCK_SYS_SetSimConfiguration+0x140>
    regValue |= SIM_PLATCGC_CGCMSCM(enable ? 1UL : 0UL);
1ffe0b98:	2200      	movs	r2, #0
1ffe0b9a:	e763      	b.n	1ffe0a64 <CLOCK_SYS_SetSimConfiguration+0x2c>
    regValue |= SIM_PLATCGC_CGCMPU(enable ? 1UL : 0UL);
1ffe0b9c:	2200      	movs	r2, #0
1ffe0b9e:	e76d      	b.n	1ffe0a7c <CLOCK_SYS_SetSimConfiguration+0x44>
    regValue |= SIM_PLATCGC_CGCDMA(enable ? 1UL : 0UL);
1ffe0ba0:	2200      	movs	r2, #0
1ffe0ba2:	e777      	b.n	1ffe0a94 <CLOCK_SYS_SetSimConfiguration+0x5c>
    regValue |= SIM_PLATCGC_CGCERM(enable ? 1UL : 0UL);
1ffe0ba4:	2200      	movs	r2, #0
1ffe0ba6:	e780      	b.n	1ffe0aaa <CLOCK_SYS_SetSimConfiguration+0x72>
    regValue |= SIM_PLATCGC_CGCEIM(enable ? 1UL : 0UL);
1ffe0ba8:	2200      	movs	r2, #0
1ffe0baa:	e789      	b.n	1ffe0ac0 <CLOCK_SYS_SetSimConfiguration+0x88>
    regValue |= SIM_MISCTRL0_QSPI_CLK_SEL(enable ? 1UL : 0UL);
1ffe0bac:	2200      	movs	r2, #0
1ffe0bae:	e793      	b.n	1ffe0ad8 <CLOCK_SYS_SetSimConfiguration+0xa0>
            g_TClkFreq[i] = simClockConfig->tclkConfig.tclkFreq[i];
1ffe0bb0:	1c9a      	adds	r2, r3, #2
1ffe0bb2:	eb00 0282 	add.w	r2, r0, r2, lsl #2
1ffe0bb6:	6891      	ldr	r1, [r2, #8]
1ffe0bb8:	4a31      	ldr	r2, [pc, #196]	; (1ffe0c80 <CLOCK_SYS_SetSimConfiguration+0x248>)
1ffe0bba:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
        for (i = 0; i < NUMBER_OF_TCLK_INPUTS; i++)
1ffe0bbe:	3301      	adds	r3, #1
1ffe0bc0:	b2db      	uxtb	r3, r3
1ffe0bc2:	2b02      	cmp	r3, #2
1ffe0bc4:	d9f4      	bls.n	1ffe0bb0 <CLOCK_SYS_SetSimConfiguration+0x178>
        for (i = 0; i < FTM_INSTANCE_COUNT; i++)
1ffe0bc6:	2300      	movs	r3, #0
1ffe0bc8:	e00b      	b.n	1ffe0be2 <CLOCK_SYS_SetSimConfiguration+0x1aa>
        for (i = 0; i < NUMBER_OF_TCLK_INPUTS; i++)
1ffe0bca:	2300      	movs	r3, #0
1ffe0bcc:	e7f9      	b.n	1ffe0bc2 <CLOCK_SYS_SetSimConfiguration+0x18a>
            regValue &= ~SIM_FTMOPT0_FTM0CLKSEL_MASK;
1ffe0bce:	f022 7240 	bic.w	r2, r2, #50331648	; 0x3000000
            regValue |= SIM_FTMOPT0_FTM0CLKSEL(source);
1ffe0bd2:	0609      	lsls	r1, r1, #24
1ffe0bd4:	f001 7140 	and.w	r1, r1, #50331648	; 0x3000000
1ffe0bd8:	430a      	orrs	r2, r1
    base->FTMOPT0 = regValue;
1ffe0bda:	4928      	ldr	r1, [pc, #160]	; (1ffe0c7c <CLOCK_SYS_SetSimConfiguration+0x244>)
1ffe0bdc:	60ca      	str	r2, [r1, #12]
        for (i = 0; i < FTM_INSTANCE_COUNT; i++)
1ffe0bde:	3301      	adds	r3, #1
1ffe0be0:	b2db      	uxtb	r3, r3
1ffe0be2:	2b07      	cmp	r3, #7
1ffe0be4:	f63f af7e 	bhi.w	1ffe0ae4 <CLOCK_SYS_SetSimConfiguration+0xac>
            SIM_SetExtPinSourceFtm(SIM, i, simClockConfig->tclkConfig.extPinSrc[i]);
1ffe0be8:	1d9a      	adds	r2, r3, #6
1ffe0bea:	eb00 0282 	add.w	r2, r0, r2, lsl #2
1ffe0bee:	6851      	ldr	r1, [r2, #4]
    uint32_t regValue = base->FTMOPT0;
1ffe0bf0:	4a22      	ldr	r2, [pc, #136]	; (1ffe0c7c <CLOCK_SYS_SetSimConfiguration+0x244>)
1ffe0bf2:	68d2      	ldr	r2, [r2, #12]
    switch (instance)
1ffe0bf4:	2b07      	cmp	r3, #7
1ffe0bf6:	d8f0      	bhi.n	1ffe0bda <CLOCK_SYS_SetSimConfiguration+0x1a2>
1ffe0bf8:	a401      	add	r4, pc, #4	; (adr r4, 1ffe0c00 <CLOCK_SYS_SetSimConfiguration+0x1c8>)
1ffe0bfa:	f854 f023 	ldr.w	pc, [r4, r3, lsl #2]
1ffe0bfe:	bf00      	nop
1ffe0c00:	1ffe0bcf 	.word	0x1ffe0bcf
1ffe0c04:	1ffe0c21 	.word	0x1ffe0c21
1ffe0c08:	1ffe0c2f 	.word	0x1ffe0c2f
1ffe0c0c:	1ffe0c3d 	.word	0x1ffe0c3d
1ffe0c10:	1ffe0c43 	.word	0x1ffe0c43
1ffe0c14:	1ffe0c51 	.word	0x1ffe0c51
1ffe0c18:	1ffe0c5f 	.word	0x1ffe0c5f
1ffe0c1c:	1ffe0c6d 	.word	0x1ffe0c6d
            regValue &= ~SIM_FTMOPT0_FTM1CLKSEL_MASK;
1ffe0c20:	f022 6240 	bic.w	r2, r2, #201326592	; 0xc000000
            regValue |= SIM_FTMOPT0_FTM1CLKSEL(source);
1ffe0c24:	0689      	lsls	r1, r1, #26
1ffe0c26:	f001 6140 	and.w	r1, r1, #201326592	; 0xc000000
1ffe0c2a:	430a      	orrs	r2, r1
            break;
1ffe0c2c:	e7d5      	b.n	1ffe0bda <CLOCK_SYS_SetSimConfiguration+0x1a2>
            regValue &= ~SIM_FTMOPT0_FTM2CLKSEL_MASK;
1ffe0c2e:	f022 5240 	bic.w	r2, r2, #805306368	; 0x30000000
            regValue |= SIM_FTMOPT0_FTM2CLKSEL(source);
1ffe0c32:	0709      	lsls	r1, r1, #28
1ffe0c34:	f001 5140 	and.w	r1, r1, #805306368	; 0x30000000
1ffe0c38:	430a      	orrs	r2, r1
            break;
1ffe0c3a:	e7ce      	b.n	1ffe0bda <CLOCK_SYS_SetSimConfiguration+0x1a2>
            regValue |= SIM_FTMOPT0_FTM3CLKSEL(source);
1ffe0c3c:	f361 729f 	bfi	r2, r1, #30, #2
            break;
1ffe0c40:	e7cb      	b.n	1ffe0bda <CLOCK_SYS_SetSimConfiguration+0x1a2>
            regValue &= ~SIM_FTMOPT0_FTM4CLKSEL_MASK;
1ffe0c42:	f422 3240 	bic.w	r2, r2, #196608	; 0x30000
            regValue |= SIM_FTMOPT0_FTM4CLKSEL(source);
1ffe0c46:	0409      	lsls	r1, r1, #16
1ffe0c48:	f401 3140 	and.w	r1, r1, #196608	; 0x30000
1ffe0c4c:	430a      	orrs	r2, r1
            break;
1ffe0c4e:	e7c4      	b.n	1ffe0bda <CLOCK_SYS_SetSimConfiguration+0x1a2>
            regValue &= ~SIM_FTMOPT0_FTM5CLKSEL_MASK;
1ffe0c50:	f422 2240 	bic.w	r2, r2, #786432	; 0xc0000
            regValue |= SIM_FTMOPT0_FTM5CLKSEL(source);
1ffe0c54:	0489      	lsls	r1, r1, #18
1ffe0c56:	f401 2140 	and.w	r1, r1, #786432	; 0xc0000
1ffe0c5a:	430a      	orrs	r2, r1
            break;
1ffe0c5c:	e7bd      	b.n	1ffe0bda <CLOCK_SYS_SetSimConfiguration+0x1a2>
            regValue &= ~SIM_FTMOPT0_FTM6CLKSEL_MASK;
1ffe0c5e:	f422 1240 	bic.w	r2, r2, #3145728	; 0x300000
            regValue |= SIM_FTMOPT0_FTM6CLKSEL(source);
1ffe0c62:	0509      	lsls	r1, r1, #20
1ffe0c64:	f401 1140 	and.w	r1, r1, #3145728	; 0x300000
1ffe0c68:	430a      	orrs	r2, r1
            break;
1ffe0c6a:	e7b6      	b.n	1ffe0bda <CLOCK_SYS_SetSimConfiguration+0x1a2>
            regValue &= ~SIM_FTMOPT0_FTM7CLKSEL_MASK;
1ffe0c6c:	f422 0240 	bic.w	r2, r2, #12582912	; 0xc00000
            regValue |= SIM_FTMOPT0_FTM7CLKSEL(source);
1ffe0c70:	0589      	lsls	r1, r1, #22
1ffe0c72:	f401 0140 	and.w	r1, r1, #12582912	; 0xc00000
1ffe0c76:	430a      	orrs	r2, r1
            break;
1ffe0c78:	e7af      	b.n	1ffe0bda <CLOCK_SYS_SetSimConfiguration+0x1a2>
1ffe0c7a:	bf00      	nop
1ffe0c7c:	40048000 	.word	0x40048000
1ffe0c80:	20000684 	.word	0x20000684

1ffe0c84 <CLOCK_SYS_SetPmcConfiguration>:
static void CLOCK_SYS_SetPmcConfiguration(const pmc_config_t * pmcConfig)
{
    DEV_ASSERT(pmcConfig != NULL);

    /* Low Power Clock settings from PMC. */
    if (pmcConfig->lpoClockConfig.initialize)
1ffe0c84:	7803      	ldrb	r3, [r0, #0]
1ffe0c86:	b1b3      	cbz	r3, 1ffe0cb6 <CLOCK_SYS_SetPmcConfiguration+0x32>
    {
        /* Enable/disable the low power oscillator. */
        PMC_SetLpoMode(PMC, pmcConfig->lpoClockConfig.enable);
1ffe0c88:	7843      	ldrb	r3, [r0, #1]
 * @param[in] baseAddr  Base address for current PMC instance.
 * @param[in] enable    enable/disable the Low Power Oscillator.
 */
static inline void PMC_SetLpoMode(PMC_Type* const baseAddr, const bool enable)
{
    uint8_t regValue = baseAddr->REGSC;
1ffe0c8a:	490d      	ldr	r1, [pc, #52]	; (1ffe0cc0 <CLOCK_SYS_SetPmcConfiguration+0x3c>)
1ffe0c8c:	788a      	ldrb	r2, [r1, #2]
    regValue &= (uint8_t)(~(PMC_REGSC_LPODIS_MASK));
1ffe0c8e:	f002 027f 	and.w	r2, r2, #127	; 0x7f
    regValue |= (uint8_t)PMC_REGSC_LPODIS(enable?0U:1U);
1ffe0c92:	f083 0301 	eor.w	r3, r3, #1
1ffe0c96:	01db      	lsls	r3, r3, #7
1ffe0c98:	b2db      	uxtb	r3, r3
1ffe0c9a:	4313      	orrs	r3, r2
    baseAddr->REGSC = regValue;
1ffe0c9c:	708b      	strb	r3, [r1, #2]

        /* Write trimming value. */
        PMC_SetLpoTrimValue(PMC, pmcConfig->lpoClockConfig.trimValue);
1ffe0c9e:	f990 3002 	ldrsb.w	r3, [r0, #2]
static inline void PMC_SetLpoTrimValue(PMC_Type* const baseAddr, const int8_t decimalValue)
{
    int8_t decValue = decimalValue;
    uint8_t lpotrim, trimval, regValue;

    if (decValue < 0)
1ffe0ca2:	2b00      	cmp	r3, #0
1ffe0ca4:	db08      	blt.n	1ffe0cb8 <CLOCK_SYS_SetPmcConfiguration+0x34>
    }
    trimval = (uint8_t)decValue;

    DEV_ASSERT(trimval <= (1U << PMC_LPOTRIM_LPOTRIM_WIDTH));

    regValue = baseAddr->LPOTRIM;
1ffe0ca6:	4906      	ldr	r1, [pc, #24]	; (1ffe0cc0 <CLOCK_SYS_SetPmcConfiguration+0x3c>)
1ffe0ca8:	790a      	ldrb	r2, [r1, #4]
    regValue &= (uint8_t)(~(PMC_LPOTRIM_LPOTRIM_MASK));
1ffe0caa:	f002 02e0 	and.w	r2, r2, #224	; 0xe0
    regValue |= (uint8_t)PMC_LPOTRIM_LPOTRIM(trimval);
1ffe0cae:	f003 031f 	and.w	r3, r3, #31
1ffe0cb2:	4313      	orrs	r3, r2
    baseAddr->LPOTRIM = regValue;
1ffe0cb4:	710b      	strb	r3, [r1, #4]
    }
}
1ffe0cb6:	4770      	bx	lr
        decValue = (int8_t)(decValue + (int8_t)(lpotrim));
1ffe0cb8:	3320      	adds	r3, #32
1ffe0cba:	b25b      	sxtb	r3, r3
1ffe0cbc:	e7f3      	b.n	1ffe0ca6 <CLOCK_SYS_SetPmcConfiguration+0x22>
1ffe0cbe:	bf00      	nop
1ffe0cc0:	4007d000 	.word	0x4007d000

1ffe0cc4 <CLOCK_SYS_GetDefaultConfiguration>:
        },
#endif
    };

    /* SCG */
    config->scgConfig.sircConfig.initialize               = true;                               /*!< Initialize */
1ffe0cc4:	2201      	movs	r2, #1
1ffe0cc6:	70c2      	strb	r2, [r0, #3]
    /* SIRCCSR */
    config->scgConfig.sircConfig.enableInStop             = false;                              /*!< SIRCSTEN  */
1ffe0cc8:	2300      	movs	r3, #0
1ffe0cca:	7103      	strb	r3, [r0, #4]
    config->scgConfig.sircConfig.enableInLowPower         = true;                               /*!< SIRCLPEN  */
1ffe0ccc:	7142      	strb	r2, [r0, #5]
    config->scgConfig.sircConfig.locked                   = false;                              /*!< LK        */
1ffe0cce:	7183      	strb	r3, [r0, #6]
    /* SIRCCFG */
    config->scgConfig.sircConfig.range                    = SCG_SIRC_RANGE_HIGH;                /*!< RANGE - High range (8 MHz) */
1ffe0cd0:	7002      	strb	r2, [r0, #0]
    /* SIRCDIV */
    config->scgConfig.sircConfig.div1                     = SCG_ASYNC_CLOCK_DIV_BY_1;           /*!< SIRCDIV1  */
1ffe0cd2:	7042      	strb	r2, [r0, #1]
    config->scgConfig.sircConfig.div2                     = SCG_ASYNC_CLOCK_DIV_BY_1;           /*!< SIRCDIV2  */
1ffe0cd4:	7082      	strb	r2, [r0, #2]

    config->scgConfig.fircConfig.initialize               = true;                               /*!< Initialize */
1ffe0cd6:	7382      	strb	r2, [r0, #14]
     /* FIRCCSR */
    config->scgConfig.fircConfig.regulator                = true;                               /*!< FIRCREGOFF */
1ffe0cd8:	7302      	strb	r2, [r0, #12]
    config->scgConfig.fircConfig.locked                   = false;                              /*!< LK         */
1ffe0cda:	7343      	strb	r3, [r0, #13]
    /* FIRCCFG */
    config->scgConfig.fircConfig.range                    = SCG_FIRC_RANGE_48M;                 /*!< RANGE      */
1ffe0cdc:	71c3      	strb	r3, [r0, #7]
    /* FIRCDIV */
    config->scgConfig.fircConfig.div1                     = SCG_ASYNC_CLOCK_DIV_BY_1;           /*!< FIRCDIV1   */
1ffe0cde:	7202      	strb	r2, [r0, #8]
    config->scgConfig.fircConfig.div2                     = SCG_ASYNC_CLOCK_DIV_BY_1;           /*!< FIRCDIV2   */
1ffe0ce0:	7242      	strb	r2, [r0, #9]

    config->scgConfig.rtcConfig.initialize                = true;                               /*!< Initialize  */
1ffe0ce2:	f880 2030 	strb.w	r2, [r0, #48]	; 0x30
    config->scgConfig.rtcConfig.rtcClkInFreq              = 0U;                                 /*!< RTC_CLKIN   */
1ffe0ce6:	62c3      	str	r3, [r0, #44]	; 0x2c

    config->scgConfig.soscConfig.initialize               = true;                               /*!< Initialize */
1ffe0ce8:	7742      	strb	r2, [r0, #29]
    config->scgConfig.soscConfig.freq                     = 8000000U;                           /*!< Frequency  */
1ffe0cea:	4943      	ldr	r1, [pc, #268]	; (1ffe0df8 <CLOCK_SYS_GetDefaultConfiguration+0x134>)
1ffe0cec:	6101      	str	r1, [r0, #16]
    /* SOSCCSR */
    config->scgConfig.soscConfig.monitorMode              = SCG_SOSC_MONITOR_DISABLE;           /*!< SOSCCM      */
1ffe0cee:	7503      	strb	r3, [r0, #20]
    config->scgConfig.soscConfig.locked                   = false;                              /*!< LK          */
1ffe0cf0:	7703      	strb	r3, [r0, #28]
    /* SOSCCFG */
    config->scgConfig.soscConfig.extRef                   = SCG_SOSC_REF_OSC;                   /*!< EREFS       */
1ffe0cf2:	7542      	strb	r2, [r0, #21]
    config->scgConfig.soscConfig.gain                     = SCG_SOSC_GAIN_LOW;                  /*!< HGO         */
1ffe0cf4:	7583      	strb	r3, [r0, #22]
    config->scgConfig.soscConfig.range                    = SCG_SOSC_RANGE_MID;                 /*!< RANGE       */
1ffe0cf6:	f04f 0c02 	mov.w	ip, #2
1ffe0cfa:	f880 c017 	strb.w	ip, [r0, #23]
    /* SOSCDIV */
    config->scgConfig.soscConfig.div1                     = SCG_ASYNC_CLOCK_DIV_BY_1;           /*!< SOSCDIV1    */
1ffe0cfe:	7602      	strb	r2, [r0, #24]
    config->scgConfig.soscConfig.div2                     = SCG_ASYNC_CLOCK_DIV_BY_1;           /*!< SOSCDIV2    */
1ffe0d00:	7642      	strb	r2, [r0, #25]

#ifdef SCG_SPLLCSR_SPLLEN_MASK
    config->scgConfig.spllConfig.initialize               = true;                               /*!< Initialize */
1ffe0d02:	f880 2028 	strb.w	r2, [r0, #40]	; 0x28
    /* SPLLCSR */
    config->scgConfig.spllConfig.monitorMode              = SCG_SPLL_MONITOR_DISABLE;           /*!< SPLLCM     */
1ffe0d06:	f880 3020 	strb.w	r3, [r0, #32]
    config->scgConfig.spllConfig.locked                   = false;                              /*!< LK         */
1ffe0d0a:	f880 3027 	strb.w	r3, [r0, #39]	; 0x27
    config->scgConfig.spllConfig.src                      = 0U;                                 /*!< SOURCE     */
        /* SPLLDIV */
    config->scgConfig.spllConfig.div1                     = SCG_ASYNC_CLOCK_DIV_BY_2;           /*!< SPLLDIV1   */
    config->scgConfig.spllConfig.div2                     = SCG_ASYNC_CLOCK_DIV_BY_4;           /*!< SPLLDIV2   */
#else
    config->scgConfig.spllConfig.prediv                   = SCG_SPLL_CLOCK_PREDIV_BY_1;         /*!< PREDIV     */
1ffe0d0e:	f880 3021 	strb.w	r3, [r0, #33]	; 0x21
    config->scgConfig.spllConfig.mult                     = SCG_SPLL_CLOCK_MULTIPLY_BY_28;      /*!< MULT       */
1ffe0d12:	210c      	movs	r1, #12
1ffe0d14:	f880 1022 	strb.w	r1, [r0, #34]	; 0x22
    config->scgConfig.spllConfig.src                      = 0U;                                 /*!< SOURCE     */
1ffe0d18:	f880 3023 	strb.w	r3, [r0, #35]	; 0x23
        /* SPLLDIV */
    config->scgConfig.spllConfig.div1                     = SCG_ASYNC_CLOCK_DIV_BY_1;           /*!< SPLLDIV1   */
1ffe0d1c:	f880 2024 	strb.w	r2, [r0, #36]	; 0x24
    config->scgConfig.spllConfig.div2                     = SCG_ASYNC_CLOCK_DIV_BY_1;           /*!< SPLLDIV2   */
1ffe0d20:	f880 2025 	strb.w	r2, [r0, #37]	; 0x25
#endif
#endif

    config->scgConfig.clockOutConfig.initialize           = true;                               /*!< Initialize    */
1ffe0d24:	f880 2035 	strb.w	r2, [r0, #53]	; 0x35
    config->scgConfig.clockOutConfig.source               = SCG_CLOCKOUT_SRC_FIRC;              /*!< SCG CLKOUTSEL     */
1ffe0d28:	2103      	movs	r1, #3
1ffe0d2a:	f880 1034 	strb.w	r1, [r0, #52]	; 0x34

    config->scgConfig.clockModeConfig.initialize          = true;                               /*!< Initialize */
1ffe0d2e:	f880 2043 	strb.w	r2, [r0, #67]	; 0x43
    /*!< RCCR - Run Clock Control Register          */
    config->scgConfig.clockModeConfig.rccrConfig.src      = SCG_SYSTEM_CLOCK_SRC_FIRC;          /*!< SCS        */
1ffe0d32:	f880 1039 	strb.w	r1, [r0, #57]	; 0x39
    config->scgConfig.clockModeConfig.rccrConfig.divCore  = SCG_SYSTEM_CLOCK_DIV_BY_1;          /*!< DIVCORE    */
1ffe0d36:	f880 3038 	strb.w	r3, [r0, #56]	; 0x38
    config->scgConfig.clockModeConfig.rccrConfig.divBus   = SCG_SYSTEM_CLOCK_DIV_BY_2;          /*!< DIVBUS     */
1ffe0d3a:	f880 2037 	strb.w	r2, [r0, #55]	; 0x37
#if (defined(S32K142W_SERIES) || defined(S32K144W_SERIES))
    config->scgConfig.clockModeConfig.rccrConfig.divSlow  = SCG_SYSTEM_CLOCK_DIV_BY_4;          /*!< DIVSLOW    */
#else
    config->scgConfig.clockModeConfig.rccrConfig.divSlow  = SCG_SYSTEM_CLOCK_DIV_BY_2;          /*!< DIVSLOW    */
1ffe0d3e:	f880 2036 	strb.w	r2, [r0, #54]	; 0x36
    config->scgConfig.clockModeConfig.vccrConfig.src      = SCG_SYSTEM_CLOCK_SRC_SIRC;          /*!< SCS        */
    config->scgConfig.clockModeConfig.vccrConfig.divCore  = SCG_SYSTEM_CLOCK_DIV_BY_8;          /*!< DIVCORE    */
    config->scgConfig.clockModeConfig.vccrConfig.divBus   = SCG_SYSTEM_CLOCK_DIV_BY_1;          /*!< DIVBUS     */
    config->scgConfig.clockModeConfig.vccrConfig.divSlow  = SCG_SYSTEM_CLOCK_DIV_BY_4;          /*!< DIVSLOW    */
#else
    config->scgConfig.clockModeConfig.vccrConfig.src      = SCG_SYSTEM_CLOCK_SRC_SIRC;          /*!< SCS        */
1ffe0d42:	f880 c03d 	strb.w	ip, [r0, #61]	; 0x3d
    config->scgConfig.clockModeConfig.vccrConfig.divCore  = SCG_SYSTEM_CLOCK_DIV_BY_2;          /*!< DIVCORE    */
1ffe0d46:	f880 203c 	strb.w	r2, [r0, #60]	; 0x3c
    config->scgConfig.clockModeConfig.vccrConfig.divBus   = SCG_SYSTEM_CLOCK_DIV_BY_1;          /*!< DIVBUS     */
1ffe0d4a:	f880 303b 	strb.w	r3, [r0, #59]	; 0x3b
    config->scgConfig.clockModeConfig.vccrConfig.divSlow  = SCG_SYSTEM_CLOCK_DIV_BY_4;          /*!< DIVSLOW    */
1ffe0d4e:	f880 103a 	strb.w	r1, [r0, #58]	; 0x3a
#endif

#if FEATURE_HAS_HIGH_SPEED_RUN_MODE
    /*!< HCCR - HSRUN Clock Control Register        */
    config->scgConfig.clockModeConfig.hccrConfig.src      = SCG_SYSTEM_CLOCK_SRC_SYS_PLL;       /*!< SCS        */
1ffe0d52:	f04f 0c06 	mov.w	ip, #6
1ffe0d56:	f880 c041 	strb.w	ip, [r0, #65]	; 0x41
    config->scgConfig.clockModeConfig.hccrConfig.divCore  = SCG_SYSTEM_CLOCK_DIV_BY_1;          /*!< DIVCORE    */
1ffe0d5a:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
    config->scgConfig.clockModeConfig.hccrConfig.divBus   = SCG_SYSTEM_CLOCK_DIV_BY_2;          /*!< DIVBUS     */
1ffe0d5e:	f880 203f 	strb.w	r2, [r0, #63]	; 0x3f
    config->scgConfig.clockModeConfig.hccrConfig.divSlow  = SCG_SYSTEM_CLOCK_DIV_BY_4;          /*!< DIVSLOW    */
1ffe0d62:	f880 103e 	strb.w	r1, [r0, #62]	; 0x3e
#endif

    /* PCC */
    config->pccConfig.peripheralClocks                    = peripheralClockConfig;             /*!< Peripheral clock control configurations  */
1ffe0d66:	4925      	ldr	r1, [pc, #148]	; (1ffe0dfc <CLOCK_SYS_GetDefaultConfiguration+0x138>)
1ffe0d68:	f8c0 1090 	str.w	r1, [r0, #144]	; 0x90
    config->pccConfig.count                               = CLOCK_PERIPHERALS_COUNT;         /*!< Number of the peripheral clock control configurations  */
1ffe0d6c:	2129      	movs	r1, #41	; 0x29
1ffe0d6e:	f8c0 108c 	str.w	r1, [r0, #140]	; 0x8c

    /* SIM */
    /*!< Clock Out configuration.           */
    config->simConfig.clockOutConfig.initialize           = true;                               /*!< Initialize    */
1ffe0d72:	f880 2044 	strb.w	r2, [r0, #68]	; 0x44
    config->simConfig.clockOutConfig.enable               = false;                              /*!< CLKOUTEN      */
1ffe0d76:	f880 3045 	strb.w	r3, [r0, #69]	; 0x45
    config->simConfig.clockOutConfig.source               = SIM_CLKOUT_SEL_SYSTEM_SCG_CLKOUT;   /*!< CLKOUTSEL     */
1ffe0d7a:	f880 3046 	strb.w	r3, [r0, #70]	; 0x46
    config->simConfig.clockOutConfig.divider              = SIM_CLKOUT_DIV_BY_1;                /*!< CLKOUTDIV     */
1ffe0d7e:	f880 3047 	strb.w	r3, [r0, #71]	; 0x47
    /*!< Low Power Clock configuration.     */
    config->simConfig.lpoClockConfig.initialize           = true;                               /*!< Initialize    */
1ffe0d82:	f880 2048 	strb.w	r2, [r0, #72]	; 0x48
    config->simConfig.lpoClockConfig.enableLpo1k          = true;                               /*!< LPO1KCLKEN    */
1ffe0d86:	f880 204c 	strb.w	r2, [r0, #76]	; 0x4c
    config->simConfig.lpoClockConfig.enableLpo32k         = true;                               /*!< LPO32KCLKEN   */
1ffe0d8a:	f880 204b 	strb.w	r2, [r0, #75]	; 0x4b
    config->simConfig.lpoClockConfig.sourceLpoClk         = SIM_LPO_CLK_SEL_LPO_128K;           /*!< LPOCLKSEL     */
1ffe0d8e:	f880 304a 	strb.w	r3, [r0, #74]	; 0x4a
    config->simConfig.lpoClockConfig.sourceRtcClk         = SIM_RTCCLK_SEL_SOSCDIV1_CLK;        /*!< RTCCLKSEL     */
1ffe0d92:	f880 3049 	strb.w	r3, [r0, #73]	; 0x49
    /*!< Platform Gate Clock configuration. */
    config->simConfig.platGateConfig.initialize           = true;                               /*!< Initialize    */
1ffe0d96:	f880 2080 	strb.w	r2, [r0, #128]	; 0x80
    config->simConfig.platGateConfig.enableMscm           = true;                               /*!< CGCMSCM       */
1ffe0d9a:	f880 2081 	strb.w	r2, [r0, #129]	; 0x81
    config->simConfig.platGateConfig.enableMpu            = true;                               /*!< CGCMPU       */
1ffe0d9e:	f880 2082 	strb.w	r2, [r0, #130]	; 0x82
    config->simConfig.platGateConfig.enableDma            = true;                               /*!< CGCDMA       */
1ffe0da2:	f880 2083 	strb.w	r2, [r0, #131]	; 0x83
    config->simConfig.platGateConfig.enableErm            = true;                               /*!< CGCERM       */
1ffe0da6:	f880 2084 	strb.w	r2, [r0, #132]	; 0x84
    config->simConfig.platGateConfig.enableEim            = true;                               /*!< CGCMEIM       */
1ffe0daa:	f880 2085 	strb.w	r2, [r0, #133]	; 0x85
    /*!< Quad Spi Internal Reference Clock Gating. */
    config->simConfig.qspiRefClkGating.enableQspiRefClk   = true;                               /*!< Qspi reference clock gating    */
1ffe0dae:	f880 208b 	strb.w	r2, [r0, #139]	; 0x8b
    /*!< TCLK CLOCK configuration. */
    config->simConfig.tclkConfig.initialize               = true;                               /*!< Initialize    */
1ffe0db2:	f880 2050 	strb.w	r2, [r0, #80]	; 0x50
    config->simConfig.tclkConfig.tclkFreq[0]              = 0U;                                 /*!< TCLK0         */
1ffe0db6:	6543      	str	r3, [r0, #84]	; 0x54
    config->simConfig.tclkConfig.tclkFreq[1]              = 0U;                                 /*!< TCLK0         */
1ffe0db8:	6583      	str	r3, [r0, #88]	; 0x58
    config->simConfig.tclkConfig.tclkFreq[2]              = 0U;                                 /*!< TCLK0         */
1ffe0dba:	65c3      	str	r3, [r0, #92]	; 0x5c
    for (i = 0; i < FTM_INSTANCE_COUNT; i++)
1ffe0dbc:	e006      	b.n	1ffe0dcc <CLOCK_SYS_GetDefaultConfiguration+0x108>
    {
        config->simConfig.tclkConfig.extPinSrc[i]              = 0U;                                 /*!< FTMx ext pin source         */
1ffe0dbe:	f103 0216 	add.w	r2, r3, #22
1ffe0dc2:	eb00 0282 	add.w	r2, r0, r2, lsl #2
1ffe0dc6:	2100      	movs	r1, #0
1ffe0dc8:	6091      	str	r1, [r2, #8]
    for (i = 0; i < FTM_INSTANCE_COUNT; i++)
1ffe0dca:	3301      	adds	r3, #1
1ffe0dcc:	2b07      	cmp	r3, #7
1ffe0dce:	d9f6      	bls.n	1ffe0dbe <CLOCK_SYS_GetDefaultConfiguration+0xfa>
    }

     /*!< Debug trace Clock Configuration. */
    config->simConfig.traceClockConfig.initialize         = true;                               /*!< Initialize    */
1ffe0dd0:	2201      	movs	r2, #1
1ffe0dd2:	f880 2086 	strb.w	r2, [r0, #134]	; 0x86
    config->simConfig.traceClockConfig.divEnable          = true;                               /*!< TRACEDIVEN    */
1ffe0dd6:	f880 2087 	strb.w	r2, [r0, #135]	; 0x87
    config->simConfig.traceClockConfig.source             = CLOCK_TRACE_SRC_CORE_CLK;           /*!< TRACECLK_SEL  */
1ffe0dda:	2300      	movs	r3, #0
1ffe0ddc:	f880 3088 	strb.w	r3, [r0, #136]	; 0x88
    config->simConfig.traceClockConfig.divider            = 0U;                                 /*!< TRACEDIV      */
1ffe0de0:	f880 3089 	strb.w	r3, [r0, #137]	; 0x89
    config->simConfig.traceClockConfig.divFraction        = false;                              /*!< TRACEFRAC     */
1ffe0de4:	f880 308a 	strb.w	r3, [r0, #138]	; 0x8a

    /* PMC */
    /*!< Low Power Clock configuration.     */
    config->pmcConfig.lpoClockConfig.initialize           = true;                               /*!< Initialize             */
1ffe0de8:	f880 2094 	strb.w	r2, [r0, #148]	; 0x94
    config->pmcConfig.lpoClockConfig.enable               = true;                               /*!< Enable/disable LPO     */
1ffe0dec:	f880 2095 	strb.w	r2, [r0, #149]	; 0x95
    config->pmcConfig.lpoClockConfig.trimValue            = 0;                                  /*!< Trimming value for LPO */
1ffe0df0:	f880 3096 	strb.w	r3, [r0, #150]	; 0x96
}
1ffe0df4:	4770      	bx	lr
1ffe0df6:	bf00      	nop
1ffe0df8:	007a1200 	.word	0x007a1200
1ffe0dfc:	200000ec 	.word	0x200000ec

1ffe0e00 <CLOCK_SYS_CheckPCCClock>:
static status_t CLOCK_SYS_CheckPCCClock(clock_names_t clockName)
{
    status_t returnCode = STATUS_SUCCESS;

    /* Invalid PCC clock names. */
    if ((clockName <= SIM_END_OF_CLOCKS) ||
1ffe0e00:	282c      	cmp	r0, #44	; 0x2c
1ffe0e02:	d917      	bls.n	1ffe0e34 <CLOCK_SYS_CheckPCCClock+0x34>
1ffe0e04:	2839      	cmp	r0, #57	; 0x39
1ffe0e06:	d017      	beq.n	1ffe0e38 <CLOCK_SYS_CheckPCCClock+0x38>
        (clockName == PCC_END_OF_BUS_CLOCKS) ||
1ffe0e08:	283f      	cmp	r0, #63	; 0x3f
1ffe0e0a:	d017      	beq.n	1ffe0e3c <CLOCK_SYS_CheckPCCClock+0x3c>
        (clockName == PCC_END_OF_SYS_CLOCKS) ||
1ffe0e0c:	2841      	cmp	r0, #65	; 0x41
1ffe0e0e:	d017      	beq.n	1ffe0e40 <CLOCK_SYS_CheckPCCClock+0x40>
        (clockName == PCC_END_OF_SLOW_CLOCKS) ||
1ffe0e10:	284b      	cmp	r0, #75	; 0x4b
1ffe0e12:	d017      	beq.n	1ffe0e44 <CLOCK_SYS_CheckPCCClock+0x44>
        (clockName == PCC_END_OF_ASYNCH_DIV1_CLOCKS) ||
1ffe0e14:	285a      	cmp	r0, #90	; 0x5a
1ffe0e16:	d017      	beq.n	1ffe0e48 <CLOCK_SYS_CheckPCCClock+0x48>
*        - true : Clock is enabled
*/
static inline bool PCC_GetClockMode(const PCC_Type* const base,
                                       const clock_names_t clockName)
{
   uint32_t regValue = (uint32_t)base->PCCn[clockNameMappings[clockName]];
1ffe0e18:	4b0c      	ldr	r3, [pc, #48]	; (1ffe0e4c <CLOCK_SYS_CheckPCCClock+0x4c>)
1ffe0e1a:	f833 2010 	ldrh.w	r2, [r3, r0, lsl #1]
1ffe0e1e:	4b0c      	ldr	r3, [pc, #48]	; (1ffe0e50 <CLOCK_SYS_CheckPCCClock+0x50>)
1ffe0e20:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
        (clockName == PCC_END_OF_ASYNCH_DIV2_CLOCKS))
    {
        returnCode = STATUS_UNSUPPORTED;
    }
    else if (PCC_GetClockMode(PCC, clockName) == false)
1ffe0e24:	f013 4f80 	tst.w	r3, #1073741824	; 0x40000000
1ffe0e28:	d001      	beq.n	1ffe0e2e <CLOCK_SYS_CheckPCCClock+0x2e>
        /* Module is not clocked. */
        returnCode = STATUS_MCU_GATED_OFF;
    }
    else
    {
        returnCode = STATUS_SUCCESS;
1ffe0e2a:	2000      	movs	r0, #0
    }

    return returnCode;
}
1ffe0e2c:	4770      	bx	lr
        returnCode = STATUS_MCU_GATED_OFF;
1ffe0e2e:	f44f 7080 	mov.w	r0, #256	; 0x100
1ffe0e32:	4770      	bx	lr
        returnCode = STATUS_UNSUPPORTED;
1ffe0e34:	2004      	movs	r0, #4
1ffe0e36:	4770      	bx	lr
1ffe0e38:	2004      	movs	r0, #4
1ffe0e3a:	4770      	bx	lr
1ffe0e3c:	2004      	movs	r0, #4
1ffe0e3e:	4770      	bx	lr
1ffe0e40:	2004      	movs	r0, #4
1ffe0e42:	4770      	bx	lr
1ffe0e44:	2004      	movs	r0, #4
1ffe0e46:	4770      	bx	lr
1ffe0e48:	2004      	movs	r0, #4
1ffe0e4a:	4770      	bx	lr
1ffe0e4c:	1ffe34b8 	.word	0x1ffe34b8
1ffe0e50:	40065000 	.word	0x40065000

1ffe0e54 <SIM_CheckPeripheralClockGate>:
 * END**************************************************************************/
static status_t SIM_CheckPeripheralClockGate(clock_names_t clockName)
{
    status_t returnCode = STATUS_SUCCESS;

    switch(clockName)
1ffe0e54:	3823      	subs	r0, #35	; 0x23
1ffe0e56:	2804      	cmp	r0, #4
1ffe0e58:	d827      	bhi.n	1ffe0eaa <SIM_CheckPeripheralClockGate+0x56>
1ffe0e5a:	e8df f000 	tbb	[pc, r0]
1ffe0e5e:	0a03      	.short	0x0a03
1ffe0e60:	1811      	.short	0x1811
1ffe0e62:	1f          	.byte	0x1f
1ffe0e63:	00          	.byte	0x00
    uint32_t regValue = (uint32_t)base->PLATCGC;
1ffe0e64:	4b19      	ldr	r3, [pc, #100]	; (1ffe0ecc <SIM_CheckPeripheralClockGate+0x78>)
1ffe0e66:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    {
        case SIM_EIM_CLK:
            if (!SIM_GetEimClockGate(SIM))
1ffe0e68:	f013 0f10 	tst.w	r3, #16
1ffe0e6c:	d01f      	beq.n	1ffe0eae <SIM_CheckPeripheralClockGate+0x5a>
    status_t returnCode = STATUS_SUCCESS;
1ffe0e6e:	2000      	movs	r0, #0
1ffe0e70:	4770      	bx	lr
    uint32_t regValue = (uint32_t)base->PLATCGC;
1ffe0e72:	4b16      	ldr	r3, [pc, #88]	; (1ffe0ecc <SIM_CheckPeripheralClockGate+0x78>)
1ffe0e74:	6c1b      	ldr	r3, [r3, #64]	; 0x40
                /* EIM is not clocked. */
                returnCode = STATUS_MCU_GATED_OFF;
            }
            break;
        case SIM_ERM_CLK:
            if (!SIM_GetErmClockGate(SIM))
1ffe0e76:	f013 0f08 	tst.w	r3, #8
1ffe0e7a:	d01b      	beq.n	1ffe0eb4 <SIM_CheckPeripheralClockGate+0x60>
    status_t returnCode = STATUS_SUCCESS;
1ffe0e7c:	2000      	movs	r0, #0
1ffe0e7e:	4770      	bx	lr
    uint32_t regValue = (uint32_t)base->PLATCGC;
1ffe0e80:	4b12      	ldr	r3, [pc, #72]	; (1ffe0ecc <SIM_CheckPeripheralClockGate+0x78>)
1ffe0e82:	6c1b      	ldr	r3, [r3, #64]	; 0x40
                /* ERM is not clocked. */
                returnCode = STATUS_MCU_GATED_OFF;
            }
            break;
        case SIM_DMA_CLK:
            if (!SIM_GetDmaClockGate(SIM))
1ffe0e84:	f013 0f04 	tst.w	r3, #4
1ffe0e88:	d017      	beq.n	1ffe0eba <SIM_CheckPeripheralClockGate+0x66>
    status_t returnCode = STATUS_SUCCESS;
1ffe0e8a:	2000      	movs	r0, #0
1ffe0e8c:	4770      	bx	lr
    uint32_t regValue = (uint32_t)base->PLATCGC;
1ffe0e8e:	4b0f      	ldr	r3, [pc, #60]	; (1ffe0ecc <SIM_CheckPeripheralClockGate+0x78>)
1ffe0e90:	6c1b      	ldr	r3, [r3, #64]	; 0x40
                /* DMA is not clocked. */
                returnCode = STATUS_MCU_GATED_OFF;
            }
            break;
        case SIM_MPU_CLK:
            if (!SIM_GetMpuClockGate(SIM))
1ffe0e92:	f013 0f02 	tst.w	r3, #2
1ffe0e96:	d013      	beq.n	1ffe0ec0 <SIM_CheckPeripheralClockGate+0x6c>
    status_t returnCode = STATUS_SUCCESS;
1ffe0e98:	2000      	movs	r0, #0
1ffe0e9a:	4770      	bx	lr
    uint32_t regValue = (uint32_t)base->PLATCGC;
1ffe0e9c:	4b0b      	ldr	r3, [pc, #44]	; (1ffe0ecc <SIM_CheckPeripheralClockGate+0x78>)
1ffe0e9e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
                /* MPU is not clocked. */
                returnCode = STATUS_MCU_GATED_OFF;
            }
            break;
        case SIM_MSCM_CLK:
            if (!SIM_GetMscmClockGate(SIM))
1ffe0ea0:	f013 0f01 	tst.w	r3, #1
1ffe0ea4:	d00f      	beq.n	1ffe0ec6 <SIM_CheckPeripheralClockGate+0x72>
    status_t returnCode = STATUS_SUCCESS;
1ffe0ea6:	2000      	movs	r0, #0
1ffe0ea8:	4770      	bx	lr
    switch(clockName)
1ffe0eaa:	2004      	movs	r0, #4
1ffe0eac:	4770      	bx	lr
                returnCode = STATUS_MCU_GATED_OFF;
1ffe0eae:	f44f 7080 	mov.w	r0, #256	; 0x100
1ffe0eb2:	4770      	bx	lr
                returnCode = STATUS_MCU_GATED_OFF;
1ffe0eb4:	f44f 7080 	mov.w	r0, #256	; 0x100
1ffe0eb8:	4770      	bx	lr
                returnCode = STATUS_MCU_GATED_OFF;
1ffe0eba:	f44f 7080 	mov.w	r0, #256	; 0x100
1ffe0ebe:	4770      	bx	lr
                returnCode = STATUS_MCU_GATED_OFF;
1ffe0ec0:	f44f 7080 	mov.w	r0, #256	; 0x100
1ffe0ec4:	4770      	bx	lr
            {
                /* MSCM is not clocked. */
                returnCode = STATUS_MCU_GATED_OFF;
1ffe0ec6:	f44f 7080 	mov.w	r0, #256	; 0x100
            returnCode = STATUS_UNSUPPORTED;
            break;
    }

    return returnCode;
}
1ffe0eca:	4770      	bx	lr
1ffe0ecc:	40048000 	.word	0x40048000

1ffe0ed0 <CLOCK_SYS_GetCurrentRunMode>:
 * @param[in] baseAddr  Base address for current SMC instance.
 * @return stat  Current power mode stat
 */
static inline uint32_t SMC_GetCurrentRunningMode(const SMC_Type* const baseAddr)
{
    return (baseAddr->PMSTAT & SMC_PMSTAT_PMSTAT_MASK) >> SMC_PMSTAT_PMSTAT_SHIFT;
1ffe0ed0:	4b08      	ldr	r3, [pc, #32]	; (1ffe0ef4 <CLOCK_SYS_GetCurrentRunMode+0x24>)
1ffe0ed2:	695b      	ldr	r3, [r3, #20]
1ffe0ed4:	b2db      	uxtb	r3, r3
static scg_system_clock_mode_t CLOCK_SYS_GetCurrentRunMode(void)
{
    scg_system_clock_mode_t mode;

    /* Get the current running mode */
    switch (SMC_GetCurrentRunningMode(SMC))
1ffe0ed6:	2b04      	cmp	r3, #4
1ffe0ed8:	d007      	beq.n	1ffe0eea <CLOCK_SYS_GetCurrentRunMode+0x1a>
1ffe0eda:	2b80      	cmp	r3, #128	; 0x80
1ffe0edc:	d007      	beq.n	1ffe0eee <CLOCK_SYS_GetCurrentRunMode+0x1e>
1ffe0ede:	2b01      	cmp	r3, #1
1ffe0ee0:	d001      	beq.n	1ffe0ee6 <CLOCK_SYS_GetCurrentRunMode+0x16>
        case VLPR_SPEED_RUNNING_MODE:
            mode = SCG_SYSTEM_CLOCK_MODE_VLPR;
            break;
        /* This should never happen - core has to be in some run mode to execute code */
        default:
            mode = SCG_SYSTEM_CLOCK_MODE_NONE;
1ffe0ee2:	2004      	movs	r0, #4
            break;
    }

    return mode;
}
1ffe0ee4:	4770      	bx	lr
            mode = SCG_SYSTEM_CLOCK_MODE_RUN;
1ffe0ee6:	2001      	movs	r0, #1
1ffe0ee8:	4770      	bx	lr
            mode = SCG_SYSTEM_CLOCK_MODE_VLPR;
1ffe0eea:	2002      	movs	r0, #2
1ffe0eec:	4770      	bx	lr
    switch (SMC_GetCurrentRunningMode(SMC))
1ffe0eee:	2003      	movs	r0, #3
1ffe0ef0:	4770      	bx	lr
1ffe0ef2:	bf00      	nop
1ffe0ef4:	4007e000 	.word	0x4007e000

1ffe0ef8 <CLOCK_SYS_GetSysOscFreq>:
 *        - false : SOSC is not enabled or clock is not valid
 *        - true  : SOSC is enabled and clock is valid
 */
static inline bool SCG_GetSoscStatus(const SCG_Type* const base)
{
    return (((base->SOSCCSR & SCG_SOSCCSR_SOSCVLD_MASK) >> SCG_SOSCCSR_SOSCVLD_SHIFT) != 0U) ? true : false;
1ffe0ef8:	4b04      	ldr	r3, [pc, #16]	; (1ffe0f0c <CLOCK_SYS_GetSysOscFreq+0x14>)
1ffe0efa:	f8d3 0100 	ldr.w	r0, [r3, #256]	; 0x100
 * Description   : Gets SCG System OSC clock frequency (SYSOSC).
 * END**************************************************************************/
static uint32_t CLOCK_SYS_GetSysOscFreq(void)
{
    uint32_t retValue;
    if (SCG_GetSoscStatus(SCG)) /* System OSC clock is valid. */
1ffe0efe:	f010 7080 	ands.w	r0, r0, #16777216	; 0x1000000
1ffe0f02:	d001      	beq.n	1ffe0f08 <CLOCK_SYS_GetSysOscFreq+0x10>
    {
        retValue = g_xtal0ClkFreq;
1ffe0f04:	4b02      	ldr	r3, [pc, #8]	; (1ffe0f10 <CLOCK_SYS_GetSysOscFreq+0x18>)
1ffe0f06:	6818      	ldr	r0, [r3, #0]
    {
        retValue = 0U;
    }

    return retValue;
}
1ffe0f08:	4770      	bx	lr
1ffe0f0a:	bf00      	nop
1ffe0f0c:	40064000 	.word	0x40064000
1ffe0f10:	200006a0 	.word	0x200006a0

1ffe0f14 <CLOCK_SYS_ConfigureSOSC>:
{
1ffe0f14:	b530      	push	{r4, r5, lr}
1ffe0f16:	b085      	sub	sp, #20
    if (soscConfig == NULL)
1ffe0f18:	460a      	mov	r2, r1
1ffe0f1a:	2900      	cmp	r1, #0
1ffe0f1c:	d044      	beq.n	1ffe0fa8 <CLOCK_SYS_ConfigureSOSC+0x94>
    uint32_t regValue = (uint32_t)base->SOSCCSR;
1ffe0f1e:	4b44      	ldr	r3, [pc, #272]	; (1ffe1030 <CLOCK_SYS_ConfigureSOSC+0x11c>)
1ffe0f20:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    if (SCG_GetSoscSystemClockMode(SCG))
1ffe0f24:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
1ffe0f28:	d153      	bne.n	1ffe0fd2 <CLOCK_SYS_ConfigureSOSC+0xbe>
 * @param[in] base        scg base pointer
 */
static inline void SCG_ClearSoscLock(SCG_Type*  base)
{
    /* Clear LK bit field */
    base->SOSCCSR &= (uint32_t)(~(SCG_SOSCCSR_LK_MASK));
1ffe0f2a:	4b41      	ldr	r3, [pc, #260]	; (1ffe1030 <CLOCK_SYS_ConfigureSOSC+0x11c>)
1ffe0f2c:	f8d3 1100 	ldr.w	r1, [r3, #256]	; 0x100
1ffe0f30:	f421 0100 	bic.w	r1, r1, #8388608	; 0x800000
1ffe0f34:	f8c3 1100 	str.w	r1, [r3, #256]	; 0x100
 * @param[in] base        scg base pointer
 */
static inline void SCG_ClearSoscControl(SCG_Type* base)
{
    /* Disable monitor, disable clock and clear error. */
    base->SOSCCSR = SCG_SOSCCSR_SOSCERR_MASK;
1ffe0f38:	f04f 6180 	mov.w	r1, #67108864	; 0x4000000
1ffe0f3c:	f8c3 1100 	str.w	r1, [r3, #256]	; 0x100
        g_xtal0ClkFreq = 0U;
1ffe0f40:	2500      	movs	r5, #0
1ffe0f42:	4b3c      	ldr	r3, [pc, #240]	; (1ffe1034 <CLOCK_SYS_ConfigureSOSC+0x120>)
1ffe0f44:	601d      	str	r5, [r3, #0]
    if (enable && (status == STATUS_SUCCESS))
1ffe0f46:	2800      	cmp	r0, #0
1ffe0f48:	d06c      	beq.n	1ffe1024 <CLOCK_SYS_ConfigureSOSC+0x110>
1ffe0f4a:	2d00      	cmp	r5, #0
1ffe0f4c:	d16a      	bne.n	1ffe1024 <CLOCK_SYS_ConfigureSOSC+0x110>
        SCG_SetSoscAsyncConfig(SCG, soscCfg->div1, soscCfg->div2);
1ffe0f4e:	7a13      	ldrb	r3, [r2, #8]
1ffe0f50:	7a51      	ldrb	r1, [r2, #9]
    uint32_t value = (uint32_t)(((div1 << SCG_SOSCDIV_SOSCDIV1_SHIFT) & SCG_SOSCDIV_SOSCDIV1_MASK)     |
1ffe0f52:	f003 0307 	and.w	r3, r3, #7
                                ((div2 << SCG_SOSCDIV_SOSCDIV2_SHIFT) & SCG_SOSCDIV_SOSCDIV2_MASK) );
1ffe0f56:	0209      	lsls	r1, r1, #8
1ffe0f58:	f401 61e0 	and.w	r1, r1, #1792	; 0x700
    uint32_t value = (uint32_t)(((div1 << SCG_SOSCDIV_SOSCDIV1_SHIFT) & SCG_SOSCDIV_SOSCDIV1_MASK)     |
1ffe0f5c:	430b      	orrs	r3, r1
    base->SOSCDIV = value;
1ffe0f5e:	4c34      	ldr	r4, [pc, #208]	; (1ffe1030 <CLOCK_SYS_ConfigureSOSC+0x11c>)
1ffe0f60:	f8c4 3104 	str.w	r3, [r4, #260]	; 0x104
        SCG_SetSoscConfiguration(SCG, soscCfg->range, soscCfg->gain, soscCfg->extRef);
1ffe0f64:	79d3      	ldrb	r3, [r2, #7]
1ffe0f66:	7990      	ldrb	r0, [r2, #6]
1ffe0f68:	7951      	ldrb	r1, [r2, #5]
 * @param[in] extRef      external reference
 */
static inline void SCG_SetSoscConfiguration(SCG_Type* base, uint32_t range, uint32_t gain, uint32_t extRef)
{
    /* Set SOSC configuration. */
    base->SOSCCFG = SCG_SOSCCFG_RANGE(range)        |
1ffe0f6a:	011b      	lsls	r3, r3, #4
1ffe0f6c:	f003 0330 	and.w	r3, r3, #48	; 0x30
                    SCG_SOSCCFG_HGO(gain)           |
1ffe0f70:	00c0      	lsls	r0, r0, #3
1ffe0f72:	f000 0008 	and.w	r0, r0, #8
    base->SOSCCFG = SCG_SOSCCFG_RANGE(range)        |
1ffe0f76:	4303      	orrs	r3, r0
                    SCG_SOSCCFG_EREFS(extRef);
1ffe0f78:	0089      	lsls	r1, r1, #2
1ffe0f7a:	f001 0104 	and.w	r1, r1, #4
                    SCG_SOSCCFG_HGO(gain)           |
1ffe0f7e:	430b      	orrs	r3, r1
    base->SOSCCFG = SCG_SOSCCFG_RANGE(range)        |
1ffe0f80:	f8c4 3108 	str.w	r3, [r4, #264]	; 0x108
        switch (soscCfg->monitorMode)
1ffe0f84:	7913      	ldrb	r3, [r2, #4]
1ffe0f86:	2b01      	cmp	r3, #1
1ffe0f88:	d031      	beq.n	1ffe0fee <CLOCK_SYS_ConfigureSOSC+0xda>
1ffe0f8a:	2b02      	cmp	r3, #2
1ffe0f8c:	d03b      	beq.n	1ffe1006 <CLOCK_SYS_ConfigureSOSC+0xf2>
1ffe0f8e:	b313      	cbz	r3, 1ffe0fd6 <CLOCK_SYS_ConfigureSOSC+0xc2>
        g_xtal0ClkFreq = soscCfg->freq;
1ffe0f90:	6812      	ldr	r2, [r2, #0]
1ffe0f92:	4b28      	ldr	r3, [pc, #160]	; (1ffe1034 <CLOCK_SYS_ConfigureSOSC+0x120>)
1ffe0f94:	601a      	str	r2, [r3, #0]
        timeout = SOSC_STABILIZATION_TIMEOUT;
1ffe0f96:	4c28      	ldr	r4, [pc, #160]	; (1ffe1038 <CLOCK_SYS_ConfigureSOSC+0x124>)
        while ((CLOCK_SYS_GetSysOscFreq() == 0U) && (timeout > 0U))
1ffe0f98:	f7ff ffae 	bl	1ffe0ef8 <CLOCK_SYS_GetSysOscFreq>
1ffe0f9c:	2800      	cmp	r0, #0
1ffe0f9e:	d140      	bne.n	1ffe1022 <CLOCK_SYS_ConfigureSOSC+0x10e>
1ffe0fa0:	2c00      	cmp	r4, #0
1ffe0fa2:	d03e      	beq.n	1ffe1022 <CLOCK_SYS_ConfigureSOSC+0x10e>
            timeout--;
1ffe0fa4:	3c01      	subs	r4, #1
1ffe0fa6:	e7f7      	b.n	1ffe0f98 <CLOCK_SYS_ConfigureSOSC+0x84>
        soscDefaultConfig.monitorMode       = SCG_SOSC_MONITOR_DISABLE;
1ffe0fa8:	2300      	movs	r3, #0
1ffe0faa:	f88d 3004 	strb.w	r3, [sp, #4]
        soscDefaultConfig.locked            = false;
1ffe0fae:	f88d 300c 	strb.w	r3, [sp, #12]
        soscDefaultConfig.div1              = SCG_ASYNC_CLOCK_DIV_BY_1;
1ffe0fb2:	2201      	movs	r2, #1
1ffe0fb4:	f88d 2008 	strb.w	r2, [sp, #8]
        soscDefaultConfig.div2              = SCG_ASYNC_CLOCK_DIV_BY_1;
1ffe0fb8:	f88d 2009 	strb.w	r2, [sp, #9]
        soscDefaultConfig.extRef            = SCG_SOSC_REF_OSC;
1ffe0fbc:	f88d 2005 	strb.w	r2, [sp, #5]
        soscDefaultConfig.gain              = SCG_SOSC_GAIN_LOW;
1ffe0fc0:	f88d 3006 	strb.w	r3, [sp, #6]
        soscDefaultConfig.range             = SCG_SOSC_RANGE_MID;
1ffe0fc4:	2302      	movs	r3, #2
1ffe0fc6:	f88d 3007 	strb.w	r3, [sp, #7]
        soscDefaultConfig.freq              = 8000000U;
1ffe0fca:	4b1c      	ldr	r3, [pc, #112]	; (1ffe103c <CLOCK_SYS_ConfigureSOSC+0x128>)
1ffe0fcc:	9300      	str	r3, [sp, #0]
        soscCfg = &soscDefaultConfig;
1ffe0fce:	466a      	mov	r2, sp
1ffe0fd0:	e7a5      	b.n	1ffe0f1e <CLOCK_SYS_ConfigureSOSC+0xa>
        status = STATUS_BUSY;
1ffe0fd2:	2502      	movs	r5, #2
1ffe0fd4:	e7b7      	b.n	1ffe0f46 <CLOCK_SYS_ConfigureSOSC+0x32>
                SCG_SetSoscControl(SCG, false, false, soscCfg->locked);
1ffe0fd6:	7b13      	ldrb	r3, [r2, #12]
static inline void SCG_SetSoscControl(SCG_Type* base, bool monitorMode, bool resetMode, bool lockMode)
{
    uint32_t value = SCG_SOSCCSR_SOSCEN(1U)                        |
                     SCG_SOSCCSR_SOSCCM((monitorMode) ? 1UL : 0UL) |
                     SCG_SOSCCSR_SOSCCMRE((resetMode) ? 1UL : 0UL) |
                     SCG_SOSCCSR_LK((lockMode) ? 1UL : 0UL);
1ffe0fd8:	b13b      	cbz	r3, 1ffe0fea <CLOCK_SYS_ConfigureSOSC+0xd6>
1ffe0fda:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
    uint32_t value = SCG_SOSCCSR_SOSCEN(1U)                        |
1ffe0fde:	f043 0301 	orr.w	r3, r3, #1

    base->SOSCCSR = value;
1ffe0fe2:	4913      	ldr	r1, [pc, #76]	; (1ffe1030 <CLOCK_SYS_ConfigureSOSC+0x11c>)
1ffe0fe4:	f8c1 3100 	str.w	r3, [r1, #256]	; 0x100
}
1ffe0fe8:	e7d2      	b.n	1ffe0f90 <CLOCK_SYS_ConfigureSOSC+0x7c>
                     SCG_SOSCCSR_LK((lockMode) ? 1UL : 0UL);
1ffe0fea:	2300      	movs	r3, #0
1ffe0fec:	e7f7      	b.n	1ffe0fde <CLOCK_SYS_ConfigureSOSC+0xca>
                SCG_SetSoscControl(SCG, true, false, soscCfg->locked);
1ffe0fee:	7b13      	ldrb	r3, [r2, #12]
1ffe0ff0:	b13b      	cbz	r3, 1ffe1002 <CLOCK_SYS_ConfigureSOSC+0xee>
1ffe0ff2:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
    uint32_t value = SCG_SOSCCSR_SOSCEN(1U)                        |
1ffe0ff6:	f043 1301 	orr.w	r3, r3, #65537	; 0x10001
    base->SOSCCSR = value;
1ffe0ffa:	490d      	ldr	r1, [pc, #52]	; (1ffe1030 <CLOCK_SYS_ConfigureSOSC+0x11c>)
1ffe0ffc:	f8c1 3100 	str.w	r3, [r1, #256]	; 0x100
}
1ffe1000:	e7c6      	b.n	1ffe0f90 <CLOCK_SYS_ConfigureSOSC+0x7c>
                     SCG_SOSCCSR_LK((lockMode) ? 1UL : 0UL);
1ffe1002:	2300      	movs	r3, #0
1ffe1004:	e7f7      	b.n	1ffe0ff6 <CLOCK_SYS_ConfigureSOSC+0xe2>
                SCG_SetSoscControl(SCG, true, true, soscCfg->locked);
1ffe1006:	7b13      	ldrb	r3, [r2, #12]
1ffe1008:	b14b      	cbz	r3, 1ffe101e <CLOCK_SYS_ConfigureSOSC+0x10a>
1ffe100a:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
    uint32_t value = SCG_SOSCCSR_SOSCEN(1U)                        |
1ffe100e:	f443 3340 	orr.w	r3, r3, #196608	; 0x30000
1ffe1012:	f043 0301 	orr.w	r3, r3, #1
    base->SOSCCSR = value;
1ffe1016:	4906      	ldr	r1, [pc, #24]	; (1ffe1030 <CLOCK_SYS_ConfigureSOSC+0x11c>)
1ffe1018:	f8c1 3100 	str.w	r3, [r1, #256]	; 0x100
}
1ffe101c:	e7b8      	b.n	1ffe0f90 <CLOCK_SYS_ConfigureSOSC+0x7c>
                     SCG_SOSCCSR_LK((lockMode) ? 1UL : 0UL);
1ffe101e:	2300      	movs	r3, #0
1ffe1020:	e7f5      	b.n	1ffe100e <CLOCK_SYS_ConfigureSOSC+0xfa>
        if (timeout == 0U)
1ffe1022:	b114      	cbz	r4, 1ffe102a <CLOCK_SYS_ConfigureSOSC+0x116>
}
1ffe1024:	4628      	mov	r0, r5
1ffe1026:	b005      	add	sp, #20
1ffe1028:	bd30      	pop	{r4, r5, pc}
            status = STATUS_TIMEOUT;
1ffe102a:	2503      	movs	r5, #3
1ffe102c:	e7fa      	b.n	1ffe1024 <CLOCK_SYS_ConfigureSOSC+0x110>
1ffe102e:	bf00      	nop
1ffe1030:	40064000 	.word	0x40064000
1ffe1034:	200006a0 	.word	0x200006a0
1ffe1038:	0030e788 	.word	0x0030e788
1ffe103c:	007a1200 	.word	0x007a1200

1ffe1040 <CLOCK_SYS_GetSircFreq>:
    return (((base->SIRCCSR & SCG_SIRCCSR_SIRCVLD_MASK) >> SCG_SIRCCSR_SIRCVLD_SHIFT) != 0U) ? true : false;
1ffe1040:	4b06      	ldr	r3, [pc, #24]	; (1ffe105c <CLOCK_SYS_GetSircFreq+0x1c>)
1ffe1042:	f8d3 0200 	ldr.w	r0, [r3, #512]	; 0x200
 * END**************************************************************************/
static uint32_t CLOCK_SYS_GetSircFreq(void)
{
    uint32_t retValue = 0U;

    if (SCG_GetSircStatus(SCG)) /* SIRC is valid. */
1ffe1046:	f010 7080 	ands.w	r0, r0, #16777216	; 0x1000000
1ffe104a:	d004      	beq.n	1ffe1056 <CLOCK_SYS_GetSircFreq+0x16>
    return ((base->SIRCCFG & SCG_SIRCCFG_RANGE_MASK) >> SCG_SIRCCFG_RANGE_SHIFT);
1ffe104c:	f8d3 0208 	ldr.w	r0, [r3, #520]	; 0x208
    {
        if (SCG_GetSircRange(SCG) != 0U)
1ffe1050:	f010 0001 	ands.w	r0, r0, #1
1ffe1054:	d100      	bne.n	1ffe1058 <CLOCK_SYS_GetSircFreq+0x18>
            retValue = FEATURE_SCG_SIRC_HIGH_RANGE_FREQ;
        }
    }

    return retValue;
}
1ffe1056:	4770      	bx	lr
            retValue = FEATURE_SCG_SIRC_HIGH_RANGE_FREQ;
1ffe1058:	4801      	ldr	r0, [pc, #4]	; (1ffe1060 <CLOCK_SYS_GetSircFreq+0x20>)
    return retValue;
1ffe105a:	e7fc      	b.n	1ffe1056 <CLOCK_SYS_GetSircFreq+0x16>
1ffe105c:	40064000 	.word	0x40064000
1ffe1060:	007a1200 	.word	0x007a1200

1ffe1064 <CLOCK_SYS_ConfigureSIRC>:
{
1ffe1064:	b530      	push	{r4, r5, lr}
1ffe1066:	b083      	sub	sp, #12
    if (sircConfig == NULL)
1ffe1068:	460b      	mov	r3, r1
1ffe106a:	2900      	cmp	r1, #0
1ffe106c:	d039      	beq.n	1ffe10e2 <CLOCK_SYS_ConfigureSIRC+0x7e>
    uint32_t regValue = (uint32_t)base->SIRCCSR;
1ffe106e:	4a2c      	ldr	r2, [pc, #176]	; (1ffe1120 <CLOCK_SYS_ConfigureSIRC+0xbc>)
1ffe1070:	f8d2 2200 	ldr.w	r2, [r2, #512]	; 0x200
    if (SCG_GetSircSystemClockMode(SCG))
1ffe1074:	f012 7f00 	tst.w	r2, #33554432	; 0x2000000
1ffe1078:	d143      	bne.n	1ffe1102 <CLOCK_SYS_ConfigureSIRC+0x9e>
    base->SIRCCSR &= (uint32_t)(~(SCG_SIRCCSR_LK_MASK));
1ffe107a:	4a29      	ldr	r2, [pc, #164]	; (1ffe1120 <CLOCK_SYS_ConfigureSIRC+0xbc>)
1ffe107c:	f8d2 1200 	ldr.w	r1, [r2, #512]	; 0x200
1ffe1080:	f421 0100 	bic.w	r1, r1, #8388608	; 0x800000
1ffe1084:	f8c2 1200 	str.w	r1, [r2, #512]	; 0x200
    base->SIRCCSR = 0U;
1ffe1088:	2500      	movs	r5, #0
1ffe108a:	f8c2 5200 	str.w	r5, [r2, #512]	; 0x200
    if (enable  && (status == STATUS_SUCCESS))
1ffe108e:	2800      	cmp	r0, #0
1ffe1090:	d040      	beq.n	1ffe1114 <CLOCK_SYS_ConfigureSIRC+0xb0>
1ffe1092:	2d00      	cmp	r5, #0
1ffe1094:	d13e      	bne.n	1ffe1114 <CLOCK_SYS_ConfigureSIRC+0xb0>
        SCG_SetSircAsyncConfig(SCG, sircCfg->div1, sircCfg->div2);
1ffe1096:	785a      	ldrb	r2, [r3, #1]
1ffe1098:	7899      	ldrb	r1, [r3, #2]
    uint32_t value = (uint32_t)(((div1 << SCG_SIRCDIV_SIRCDIV1_SHIFT) & SCG_SIRCDIV_SIRCDIV1_MASK)     |
1ffe109a:	f002 0207 	and.w	r2, r2, #7
                                ((div2 << SCG_SIRCDIV_SIRCDIV2_SHIFT) & SCG_SIRCDIV_SIRCDIV2_MASK) );
1ffe109e:	0209      	lsls	r1, r1, #8
1ffe10a0:	f401 61e0 	and.w	r1, r1, #1792	; 0x700
    uint32_t value = (uint32_t)(((div1 << SCG_SIRCDIV_SIRCDIV1_SHIFT) & SCG_SIRCDIV_SIRCDIV1_MASK)     |
1ffe10a4:	430a      	orrs	r2, r1
    base->SIRCDIV = value;
1ffe10a6:	491e      	ldr	r1, [pc, #120]	; (1ffe1120 <CLOCK_SYS_ConfigureSIRC+0xbc>)
1ffe10a8:	f8c1 2204 	str.w	r2, [r1, #516]	; 0x204
        SCG_SetSircConfiguration(SCG, sircCfg->range);
1ffe10ac:	781a      	ldrb	r2, [r3, #0]
    base->SIRCCFG = SCG_SIRCCFG_RANGE(range);
1ffe10ae:	f002 0201 	and.w	r2, r2, #1
1ffe10b2:	f8c1 2208 	str.w	r2, [r1, #520]	; 0x208
        SCG_SetSircControl(SCG, sircCfg->enableInStop, sircCfg->enableInLowPower, sircCfg->locked);
1ffe10b6:	7918      	ldrb	r0, [r3, #4]
1ffe10b8:	7959      	ldrb	r1, [r3, #5]
1ffe10ba:	799a      	ldrb	r2, [r3, #6]
    uint32_t value = SCG_SIRCCSR_SIRCEN(1U)                                  |
1ffe10bc:	b318      	cbz	r0, 1ffe1106 <CLOCK_SYS_ConfigureSIRC+0xa2>
1ffe10be:	2303      	movs	r3, #3
                     SCG_SIRCCSR_SIRCLPEN(((enableInLowPower) ? 1UL : 0UL )) |
1ffe10c0:	b319      	cbz	r1, 1ffe110a <CLOCK_SYS_ConfigureSIRC+0xa6>
1ffe10c2:	2104      	movs	r1, #4
                     SCG_SIRCCSR_SIRCSTEN(((enableInStop)     ? 1UL : 0UL )) |
1ffe10c4:	430b      	orrs	r3, r1
                     SCG_SIRCCSR_LK((lockMode) ? 1UL : 0UL);
1ffe10c6:	b312      	cbz	r2, 1ffe110e <CLOCK_SYS_ConfigureSIRC+0xaa>
1ffe10c8:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
    uint32_t value = SCG_SIRCCSR_SIRCEN(1U)                                  |
1ffe10cc:	4313      	orrs	r3, r2
    base->SIRCCSR = value;
1ffe10ce:	4a14      	ldr	r2, [pc, #80]	; (1ffe1120 <CLOCK_SYS_ConfigureSIRC+0xbc>)
1ffe10d0:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
        timeout = SIRC_STABILIZATION_TIMEOUT;
1ffe10d4:	2464      	movs	r4, #100	; 0x64
        while ((CLOCK_SYS_GetSircFreq() == 0U) && (timeout > 0U))
1ffe10d6:	f7ff ffb3 	bl	1ffe1040 <CLOCK_SYS_GetSircFreq>
1ffe10da:	b9d0      	cbnz	r0, 1ffe1112 <CLOCK_SYS_ConfigureSIRC+0xae>
1ffe10dc:	b1cc      	cbz	r4, 1ffe1112 <CLOCK_SYS_ConfigureSIRC+0xae>
            timeout--;
1ffe10de:	3c01      	subs	r4, #1
1ffe10e0:	e7f9      	b.n	1ffe10d6 <CLOCK_SYS_ConfigureSIRC+0x72>
        sircDefaultConfig.enableInStop      = false;
1ffe10e2:	2200      	movs	r2, #0
1ffe10e4:	f88d 2004 	strb.w	r2, [sp, #4]
        sircDefaultConfig.enableInLowPower  = true;
1ffe10e8:	2301      	movs	r3, #1
1ffe10ea:	f88d 3005 	strb.w	r3, [sp, #5]
        sircDefaultConfig.locked            = false;
1ffe10ee:	f88d 2006 	strb.w	r2, [sp, #6]
        sircDefaultConfig.div1              = SCG_ASYNC_CLOCK_DIV_BY_1;
1ffe10f2:	f88d 3001 	strb.w	r3, [sp, #1]
        sircDefaultConfig.div2              = SCG_ASYNC_CLOCK_DIV_BY_1;
1ffe10f6:	f88d 3002 	strb.w	r3, [sp, #2]
        sircDefaultConfig.range             = SCG_SIRC_RANGE_HIGH;
1ffe10fa:	f88d 3000 	strb.w	r3, [sp]
        sircCfg = &sircDefaultConfig;
1ffe10fe:	466b      	mov	r3, sp
1ffe1100:	e7b5      	b.n	1ffe106e <CLOCK_SYS_ConfigureSIRC+0xa>
        status = STATUS_BUSY;
1ffe1102:	2502      	movs	r5, #2
1ffe1104:	e7c3      	b.n	1ffe108e <CLOCK_SYS_ConfigureSIRC+0x2a>
    uint32_t value = SCG_SIRCCSR_SIRCEN(1U)                                  |
1ffe1106:	2301      	movs	r3, #1
1ffe1108:	e7da      	b.n	1ffe10c0 <CLOCK_SYS_ConfigureSIRC+0x5c>
                     SCG_SIRCCSR_SIRCLPEN(((enableInLowPower) ? 1UL : 0UL )) |
1ffe110a:	2100      	movs	r1, #0
1ffe110c:	e7da      	b.n	1ffe10c4 <CLOCK_SYS_ConfigureSIRC+0x60>
                     SCG_SIRCCSR_LK((lockMode) ? 1UL : 0UL);
1ffe110e:	2200      	movs	r2, #0
1ffe1110:	e7dc      	b.n	1ffe10cc <CLOCK_SYS_ConfigureSIRC+0x68>
        if (timeout == 0U)
1ffe1112:	b114      	cbz	r4, 1ffe111a <CLOCK_SYS_ConfigureSIRC+0xb6>
}
1ffe1114:	4628      	mov	r0, r5
1ffe1116:	b003      	add	sp, #12
1ffe1118:	bd30      	pop	{r4, r5, pc}
            status = STATUS_TIMEOUT;
1ffe111a:	2503      	movs	r5, #3
1ffe111c:	e7fa      	b.n	1ffe1114 <CLOCK_SYS_ConfigureSIRC+0xb0>
1ffe111e:	bf00      	nop
1ffe1120:	40064000 	.word	0x40064000

1ffe1124 <CLOCK_SYS_GetFircFreq>:
    return (((base->FIRCCSR & SCG_FIRCCSR_FIRCVLD_MASK) >> SCG_FIRCCSR_FIRCVLD_SHIFT) != 0U) ? true : false;
1ffe1124:	4b05      	ldr	r3, [pc, #20]	; (1ffe113c <CLOCK_SYS_GetFircFreq+0x18>)
1ffe1126:	f8d3 0300 	ldr.w	r0, [r3, #768]	; 0x300

    static const uint32_t fircFreq[] = {
        FEATURE_SCG_FIRC_FREQ0,
    };

    if (SCG_GetFircStatus(SCG)) /* FIRC is valid. */
1ffe112a:	f010 7080 	ands.w	r0, r0, #16777216	; 0x1000000
1ffe112e:	d100      	bne.n	1ffe1132 <CLOCK_SYS_GetFircFreq+0xe>
    {
        retValue = 0U;
    }

    return retValue;
}
1ffe1130:	4770      	bx	lr
    return ((base->FIRCCFG & SCG_FIRCCFG_RANGE_MASK) >> SCG_FIRCCFG_RANGE_SHIFT);
1ffe1132:	f8d3 3308 	ldr.w	r3, [r3, #776]	; 0x308
        retValue = fircFreq[SCG_GetFircRange(SCG)];
1ffe1136:	4802      	ldr	r0, [pc, #8]	; (1ffe1140 <CLOCK_SYS_GetFircFreq+0x1c>)
    return retValue;
1ffe1138:	e7fa      	b.n	1ffe1130 <CLOCK_SYS_GetFircFreq+0xc>
1ffe113a:	bf00      	nop
1ffe113c:	40064000 	.word	0x40064000
1ffe1140:	02dc6c00 	.word	0x02dc6c00

1ffe1144 <CLOCK_SYS_ConfigureFIRC>:
{
1ffe1144:	b530      	push	{r4, r5, lr}
1ffe1146:	b083      	sub	sp, #12
    if (fircConfig == NULL)
1ffe1148:	460b      	mov	r3, r1
1ffe114a:	b3a9      	cbz	r1, 1ffe11b8 <CLOCK_SYS_ConfigureFIRC+0x74>
    uint32_t regValue = (uint32_t)base->FIRCCSR;
1ffe114c:	4a27      	ldr	r2, [pc, #156]	; (1ffe11ec <CLOCK_SYS_ConfigureFIRC+0xa8>)
1ffe114e:	f8d2 2300 	ldr.w	r2, [r2, #768]	; 0x300
    if (SCG_GetFircSystemClockMode(SCG))
1ffe1152:	f012 7f00 	tst.w	r2, #33554432	; 0x2000000
1ffe1156:	d13d      	bne.n	1ffe11d4 <CLOCK_SYS_ConfigureFIRC+0x90>
    base->FIRCCSR &= (uint32_t)(~(SCG_FIRCCSR_LK_MASK));
1ffe1158:	4a24      	ldr	r2, [pc, #144]	; (1ffe11ec <CLOCK_SYS_ConfigureFIRC+0xa8>)
1ffe115a:	f8d2 1300 	ldr.w	r1, [r2, #768]	; 0x300
1ffe115e:	f421 0100 	bic.w	r1, r1, #8388608	; 0x800000
1ffe1162:	f8c2 1300 	str.w	r1, [r2, #768]	; 0x300
    base->FIRCCSR = SCG_FIRCCSR_FIRCERR_MASK;
1ffe1166:	f04f 6180 	mov.w	r1, #67108864	; 0x4000000
1ffe116a:	f8c2 1300 	str.w	r1, [r2, #768]	; 0x300
    status_t status = STATUS_SUCCESS;
1ffe116e:	2500      	movs	r5, #0
    if (enable && (status == STATUS_SUCCESS))
1ffe1170:	b3b8      	cbz	r0, 1ffe11e2 <CLOCK_SYS_ConfigureFIRC+0x9e>
1ffe1172:	bbb5      	cbnz	r5, 1ffe11e2 <CLOCK_SYS_ConfigureFIRC+0x9e>
        SCG_SetFircAsyncConfig(SCG, fircCfg->div1, fircCfg->div2);
1ffe1174:	785a      	ldrb	r2, [r3, #1]
1ffe1176:	7899      	ldrb	r1, [r3, #2]
    uint32_t value = (uint32_t)(((div1 << SCG_FIRCDIV_FIRCDIV1_SHIFT) & SCG_FIRCDIV_FIRCDIV1_MASK)     |
1ffe1178:	f002 0207 	and.w	r2, r2, #7
                                ((div2 << SCG_FIRCDIV_FIRCDIV2_SHIFT) & SCG_FIRCDIV_FIRCDIV2_MASK) );
1ffe117c:	0209      	lsls	r1, r1, #8
1ffe117e:	f401 61e0 	and.w	r1, r1, #1792	; 0x700
    uint32_t value = (uint32_t)(((div1 << SCG_FIRCDIV_FIRCDIV1_SHIFT) & SCG_FIRCDIV_FIRCDIV1_MASK)     |
1ffe1182:	430a      	orrs	r2, r1
    base->FIRCDIV = value;
1ffe1184:	4919      	ldr	r1, [pc, #100]	; (1ffe11ec <CLOCK_SYS_ConfigureFIRC+0xa8>)
1ffe1186:	f8c1 2304 	str.w	r2, [r1, #772]	; 0x304
        SCG_SetFircConfiguration(SCG, fircCfg->range);
1ffe118a:	781a      	ldrb	r2, [r3, #0]
    base->FIRCCFG = SCG_FIRCCFG_RANGE(range);
1ffe118c:	f002 0203 	and.w	r2, r2, #3
1ffe1190:	f8c1 2308 	str.w	r2, [r1, #776]	; 0x308
        SCG_SetFircControl(SCG, fircCfg->regulator, fircCfg->locked);
1ffe1194:	7959      	ldrb	r1, [r3, #5]
1ffe1196:	799a      	ldrb	r2, [r3, #6]
    uint32_t value = SCG_FIRCCSR_FIRCEN(1U)                             |
1ffe1198:	b1f1      	cbz	r1, 1ffe11d8 <CLOCK_SYS_ConfigureFIRC+0x94>
1ffe119a:	2301      	movs	r3, #1
                     SCG_FIRCCSR_LK((lockMode) ? 1UL : 0UL);
1ffe119c:	b1f2      	cbz	r2, 1ffe11dc <CLOCK_SYS_ConfigureFIRC+0x98>
1ffe119e:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
    uint32_t value = SCG_FIRCCSR_FIRCEN(1U)                             |
1ffe11a2:	4313      	orrs	r3, r2
    base->FIRCCSR = value;
1ffe11a4:	4a11      	ldr	r2, [pc, #68]	; (1ffe11ec <CLOCK_SYS_ConfigureFIRC+0xa8>)
1ffe11a6:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300
        timeout = FIRC_STABILIZATION_TIMEOUT;
1ffe11aa:	2464      	movs	r4, #100	; 0x64
        while ((CLOCK_SYS_GetFircFreq() == 0U) && (timeout > 0U))
1ffe11ac:	f7ff ffba 	bl	1ffe1124 <CLOCK_SYS_GetFircFreq>
1ffe11b0:	b9b0      	cbnz	r0, 1ffe11e0 <CLOCK_SYS_ConfigureFIRC+0x9c>
1ffe11b2:	b1ac      	cbz	r4, 1ffe11e0 <CLOCK_SYS_ConfigureFIRC+0x9c>
            timeout--;
1ffe11b4:	3c01      	subs	r4, #1
1ffe11b6:	e7f9      	b.n	1ffe11ac <CLOCK_SYS_ConfigureFIRC+0x68>
        fircDefaultConfig.regulator         = true;
1ffe11b8:	2301      	movs	r3, #1
1ffe11ba:	f88d 3005 	strb.w	r3, [sp, #5]
        fircDefaultConfig.locked            = false;
1ffe11be:	2200      	movs	r2, #0
1ffe11c0:	f88d 2006 	strb.w	r2, [sp, #6]
        fircDefaultConfig.div1              = SCG_ASYNC_CLOCK_DIV_BY_1;
1ffe11c4:	f88d 3001 	strb.w	r3, [sp, #1]
        fircDefaultConfig.div2              = SCG_ASYNC_CLOCK_DIV_BY_1;
1ffe11c8:	f88d 3002 	strb.w	r3, [sp, #2]
        fircDefaultConfig.range             = SCG_FIRC_RANGE_48M;
1ffe11cc:	f88d 2000 	strb.w	r2, [sp]
        fircCfg = &fircDefaultConfig;
1ffe11d0:	466b      	mov	r3, sp
1ffe11d2:	e7bb      	b.n	1ffe114c <CLOCK_SYS_ConfigureFIRC+0x8>
        status = STATUS_BUSY;
1ffe11d4:	2502      	movs	r5, #2
1ffe11d6:	e7cb      	b.n	1ffe1170 <CLOCK_SYS_ConfigureFIRC+0x2c>
    uint32_t value = SCG_FIRCCSR_FIRCEN(1U)                             |
1ffe11d8:	2309      	movs	r3, #9
1ffe11da:	e7df      	b.n	1ffe119c <CLOCK_SYS_ConfigureFIRC+0x58>
                     SCG_FIRCCSR_LK((lockMode) ? 1UL : 0UL);
1ffe11dc:	2200      	movs	r2, #0
1ffe11de:	e7e0      	b.n	1ffe11a2 <CLOCK_SYS_ConfigureFIRC+0x5e>
        if (timeout == 0U)
1ffe11e0:	b114      	cbz	r4, 1ffe11e8 <CLOCK_SYS_ConfigureFIRC+0xa4>
}
1ffe11e2:	4628      	mov	r0, r5
1ffe11e4:	b003      	add	sp, #12
1ffe11e6:	bd30      	pop	{r4, r5, pc}
            status = STATUS_TIMEOUT;
1ffe11e8:	2503      	movs	r5, #3
1ffe11ea:	e7fa      	b.n	1ffe11e2 <CLOCK_SYS_ConfigureFIRC+0x9e>
1ffe11ec:	40064000 	.word	0x40064000

1ffe11f0 <CLOCK_SYS_GetSysPllFreq>:
/*FUNCTION**********************************************************************
 * Function Name : CLOCK_SYS_GetSysPllFreq
 * Description   : Gets SCG System PLL clock frequency (SYSPLL).
 * END**************************************************************************/
static uint32_t CLOCK_SYS_GetSysPllFreq(void)
{
1ffe11f0:	b508      	push	{r3, lr}
 *        - false : SPLL is not enabled or clock is not valid
 *        - true  : SPLL is enabled and clock is valid
 */
static inline bool SCG_GetSpllStatus(const SCG_Type* const base)
{
    return (((base->SPLLCSR & SCG_SPLLCSR_SPLLVLD_MASK) >> SCG_SPLLCSR_SPLLVLD_SHIFT) != 0U) ? true : false;
1ffe11f2:	4b0e      	ldr	r3, [pc, #56]	; (1ffe122c <CLOCK_SYS_GetSysPllFreq+0x3c>)
1ffe11f4:	f8d3 0600 	ldr.w	r0, [r3, #1536]	; 0x600
    uint32_t freq, retValue;

    if (SCG_GetSpllStatus(SCG)) /* System PLL is valid. */
1ffe11f8:	f010 7080 	ands.w	r0, r0, #16777216	; 0x1000000
1ffe11fc:	d100      	bne.n	1ffe1200 <CLOCK_SYS_GetSysPllFreq+0x10>
    {
        retValue = 0U;
    }

    return retValue;
}
1ffe11fe:	bd08      	pop	{r3, pc}
        freq = CLOCK_SYS_GetSysOscFreq();
1ffe1200:	f7ff fe7a 	bl	1ffe0ef8 <CLOCK_SYS_GetSysOscFreq>
        if (freq != 0U) /* If source is valid. */
1ffe1204:	2800      	cmp	r0, #0
1ffe1206:	d0fa      	beq.n	1ffe11fe <CLOCK_SYS_GetSysPllFreq+0xe>
 *
 * @return  spll predivider value
 */
static inline uint32_t SCG_GetSpllPredivider(const SCG_Type* const base)
{
    return ((base->SPLLCFG & SCG_SPLLCFG_PREDIV_MASK) >> SCG_SPLLCFG_PREDIV_SHIFT);
1ffe1208:	4a08      	ldr	r2, [pc, #32]	; (1ffe122c <CLOCK_SYS_GetSysPllFreq+0x3c>)
1ffe120a:	f8d2 3608 	ldr.w	r3, [r2, #1544]	; 0x608
1ffe120e:	f3c3 2302 	ubfx	r3, r3, #8, #3
            freq /= (SCG_GetSpllPredivider(SCG) + SCG_SPLL_PREDIV_BASE);    /* Pre-divider. */
1ffe1212:	3301      	adds	r3, #1
1ffe1214:	fbb0 f0f3 	udiv	r0, r0, r3
 *
 * @return  spll multiplier value
 */
static inline uint32_t SCG_GetSpllMultiplier(const SCG_Type* const base)
{
    return ((base->SPLLCFG & SCG_SPLLCFG_MULT_MASK) >> SCG_SPLLCFG_MULT_SHIFT);
1ffe1218:	f8d2 3608 	ldr.w	r3, [r2, #1544]	; 0x608
1ffe121c:	f3c3 4304 	ubfx	r3, r3, #16, #5
            freq *= (SCG_GetSpllMultiplier(SCG) + SCG_SPLL_MULT_BASE);      /* Multiplier. */
1ffe1220:	3310      	adds	r3, #16
1ffe1222:	fb03 f000 	mul.w	r0, r3, r0
            freq = freq >> 1U;  /* Divide VCO by 2. */
1ffe1226:	0840      	lsrs	r0, r0, #1
    return retValue;
1ffe1228:	e7e9      	b.n	1ffe11fe <CLOCK_SYS_GetSysPllFreq+0xe>
1ffe122a:	bf00      	nop
1ffe122c:	40064000 	.word	0x40064000

1ffe1230 <CLOCK_SYS_ConfigureSPLL>:
{
1ffe1230:	b530      	push	{r4, r5, lr}
1ffe1232:	b085      	sub	sp, #20
    if (spllConfig == NULL)
1ffe1234:	460c      	mov	r4, r1
1ffe1236:	b1b1      	cbz	r1, 1ffe1266 <CLOCK_SYS_ConfigureSPLL+0x36>
    uint32_t regValue = (uint32_t)base->SPLLCSR;
1ffe1238:	4b41      	ldr	r3, [pc, #260]	; (1ffe1340 <CLOCK_SYS_ConfigureSPLL+0x110>)
1ffe123a:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    if (SCG_GetSpllSystemClockMode(SCG))
1ffe123e:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
1ffe1242:	d123      	bne.n	1ffe128c <CLOCK_SYS_ConfigureSPLL+0x5c>
 *
 */
static inline void SCG_ClearSpllLock(SCG_Type*  base)
{
    /* Clear LK bit field */
    base->SPLLCSR &= (uint32_t)(~(SCG_SPLLCSR_LK_MASK));
1ffe1244:	4b3e      	ldr	r3, [pc, #248]	; (1ffe1340 <CLOCK_SYS_ConfigureSPLL+0x110>)
1ffe1246:	f8d3 2600 	ldr.w	r2, [r3, #1536]	; 0x600
1ffe124a:	f422 0200 	bic.w	r2, r2, #8388608	; 0x800000
1ffe124e:	f8c3 2600 	str.w	r2, [r3, #1536]	; 0x600
 *
 */
static inline void SCG_ClearSpllControl(SCG_Type* base)
{
    /* Disable monitor, disable clock and clear error. */
    base->SPLLCSR = SCG_SPLLCSR_SPLLERR_MASK;
1ffe1252:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
1ffe1256:	f8c3 2600 	str.w	r2, [r3, #1536]	; 0x600
    status_t status = STATUS_SUCCESS;
1ffe125a:	2500      	movs	r5, #0
    if (enable && (status == STATUS_SUCCESS))
1ffe125c:	b100      	cbz	r0, 1ffe1260 <CLOCK_SYS_ConfigureSPLL+0x30>
1ffe125e:	b1bd      	cbz	r5, 1ffe1290 <CLOCK_SYS_ConfigureSPLL+0x60>
}
1ffe1260:	4628      	mov	r0, r5
1ffe1262:	b005      	add	sp, #20
1ffe1264:	bd30      	pop	{r4, r5, pc}
        spllDefaultConfig.monitorMode    = SCG_SPLL_MONITOR_DISABLE;
1ffe1266:	2300      	movs	r3, #0
1ffe1268:	f88d 3004 	strb.w	r3, [sp, #4]
        spllDefaultConfig.locked         = false;
1ffe126c:	f88d 300b 	strb.w	r3, [sp, #11]
        spllDefaultConfig.div1           = SCG_ASYNC_CLOCK_DIV_BY_1;
1ffe1270:	2201      	movs	r2, #1
1ffe1272:	f88d 2008 	strb.w	r2, [sp, #8]
        spllDefaultConfig.div2           = SCG_ASYNC_CLOCK_DIV_BY_1;
1ffe1276:	f88d 2009 	strb.w	r2, [sp, #9]
        spllDefaultConfig.prediv         = 0;
1ffe127a:	f88d 3005 	strb.w	r3, [sp, #5]
        spllDefaultConfig.mult           = 7;
1ffe127e:	2207      	movs	r2, #7
1ffe1280:	f88d 2006 	strb.w	r2, [sp, #6]
        spllDefaultConfig.src            = 0;
1ffe1284:	f88d 3007 	strb.w	r3, [sp, #7]
        spllCfg = &spllDefaultConfig;
1ffe1288:	ac01      	add	r4, sp, #4
1ffe128a:	e7d5      	b.n	1ffe1238 <CLOCK_SYS_ConfigureSPLL+0x8>
        status = STATUS_BUSY;
1ffe128c:	2502      	movs	r5, #2
1ffe128e:	e7e5      	b.n	1ffe125c <CLOCK_SYS_ConfigureSPLL+0x2c>
        srcFreq = CLOCK_SYS_GetSysOscFreq();
1ffe1290:	f7ff fe32 	bl	1ffe0ef8 <CLOCK_SYS_GetSysOscFreq>
        SCG_SetSpllAsyncConfig(SCG, spllCfg->div1, spllCfg->div2);
1ffe1294:	7923      	ldrb	r3, [r4, #4]
1ffe1296:	7962      	ldrb	r2, [r4, #5]
    uint32_t value = (uint32_t)(((div1 << SCG_SPLLDIV_SPLLDIV1_SHIFT) & SCG_SPLLDIV_SPLLDIV1_MASK)     |
1ffe1298:	f003 0307 	and.w	r3, r3, #7
                                ((div2 << SCG_SPLLDIV_SPLLDIV2_SHIFT) & SCG_SPLLDIV_SPLLDIV2_MASK) );
1ffe129c:	0212      	lsls	r2, r2, #8
1ffe129e:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
    uint32_t value = (uint32_t)(((div1 << SCG_SPLLDIV_SPLLDIV1_SHIFT) & SCG_SPLLDIV_SPLLDIV1_MASK)     |
1ffe12a2:	4313      	orrs	r3, r2
    base->SPLLDIV = value;
1ffe12a4:	4826      	ldr	r0, [pc, #152]	; (1ffe1340 <CLOCK_SYS_ConfigureSPLL+0x110>)
1ffe12a6:	f8c0 3604 	str.w	r3, [r0, #1540]	; 0x604
        SCG_SetSpllConfiguration(SCG, spllCfg->prediv, spllCfg->mult);
1ffe12aa:	7862      	ldrb	r2, [r4, #1]
1ffe12ac:	78a1      	ldrb	r1, [r4, #2]
 * @param[in] multiplier  spll multiplier value
 */
static inline void SCG_SetSpllConfiguration(SCG_Type *base, uint8_t divider, uint8_t multiplier)
{
    /* Set PLL configuration. */
    uint32_t value = base->SPLLCFG;
1ffe12ae:	f8d0 3608 	ldr.w	r3, [r0, #1544]	; 0x608

    value &= (~(SCG_SPLLCFG_PREDIV_MASK | SCG_SPLLCFG_MULT_MASK));
1ffe12b2:	f423 13f8 	bic.w	r3, r3, #2031616	; 0x1f0000
1ffe12b6:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
    value |= (SCG_SPLLCFG_PREDIV(divider) | SCG_SPLLCFG_MULT(multiplier));
1ffe12ba:	0212      	lsls	r2, r2, #8
1ffe12bc:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
1ffe12c0:	0409      	lsls	r1, r1, #16
1ffe12c2:	f401 11f8 	and.w	r1, r1, #2031616	; 0x1f0000
1ffe12c6:	430a      	orrs	r2, r1
1ffe12c8:	4313      	orrs	r3, r2

    base->SPLLCFG = value;
1ffe12ca:	f8c0 3608 	str.w	r3, [r0, #1544]	; 0x608
        switch (spllCfg->monitorMode)
1ffe12ce:	7823      	ldrb	r3, [r4, #0]
1ffe12d0:	2b01      	cmp	r3, #1
1ffe12d2:	d011      	beq.n	1ffe12f8 <CLOCK_SYS_ConfigureSPLL+0xc8>
1ffe12d4:	2b02      	cmp	r3, #2
1ffe12d6:	d01b      	beq.n	1ffe1310 <CLOCK_SYS_ConfigureSPLL+0xe0>
1ffe12d8:	b113      	cbz	r3, 1ffe12e0 <CLOCK_SYS_ConfigureSPLL+0xb0>
static inline void SCG_SetSpllControl(SCG_Type* base, bool monitorMode, bool resetMode, bool lockMode)
{
    uint32_t value = SCG_SPLLCSR_SPLLEN(1U)                        |
                     SCG_SPLLCSR_SPLLCM((monitorMode) ? 1UL : 0UL) |
                     SCG_SPLLCSR_SPLLCMRE((resetMode) ? 1UL : 0UL) |
                     SCG_SPLLCSR_LK((lockMode) ? 1UL : 0UL);
1ffe12da:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
1ffe12de:	e026      	b.n	1ffe132e <CLOCK_SYS_ConfigureSPLL+0xfe>
                SCG_SetSpllControl(SCG, false, false, spllCfg->locked);
1ffe12e0:	79e3      	ldrb	r3, [r4, #7]
1ffe12e2:	b13b      	cbz	r3, 1ffe12f4 <CLOCK_SYS_ConfigureSPLL+0xc4>
1ffe12e4:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
    uint32_t value = SCG_SPLLCSR_SPLLEN(1U)                        |
1ffe12e8:	f043 0301 	orr.w	r3, r3, #1

    base->SPLLCSR = value;
1ffe12ec:	4a14      	ldr	r2, [pc, #80]	; (1ffe1340 <CLOCK_SYS_ConfigureSPLL+0x110>)
1ffe12ee:	f8c2 3600 	str.w	r3, [r2, #1536]	; 0x600
}
1ffe12f2:	e7f2      	b.n	1ffe12da <CLOCK_SYS_ConfigureSPLL+0xaa>
                     SCG_SPLLCSR_LK((lockMode) ? 1UL : 0UL);
1ffe12f4:	2300      	movs	r3, #0
1ffe12f6:	e7f7      	b.n	1ffe12e8 <CLOCK_SYS_ConfigureSPLL+0xb8>
                SCG_SetSpllControl(SCG, true, false, spllCfg->locked);
1ffe12f8:	79e3      	ldrb	r3, [r4, #7]
1ffe12fa:	b13b      	cbz	r3, 1ffe130c <CLOCK_SYS_ConfigureSPLL+0xdc>
1ffe12fc:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
    uint32_t value = SCG_SPLLCSR_SPLLEN(1U)                        |
1ffe1300:	f043 1301 	orr.w	r3, r3, #65537	; 0x10001
    base->SPLLCSR = value;
1ffe1304:	4a0e      	ldr	r2, [pc, #56]	; (1ffe1340 <CLOCK_SYS_ConfigureSPLL+0x110>)
1ffe1306:	f8c2 3600 	str.w	r3, [r2, #1536]	; 0x600
}
1ffe130a:	e7e6      	b.n	1ffe12da <CLOCK_SYS_ConfigureSPLL+0xaa>
                     SCG_SPLLCSR_LK((lockMode) ? 1UL : 0UL);
1ffe130c:	2300      	movs	r3, #0
1ffe130e:	e7f7      	b.n	1ffe1300 <CLOCK_SYS_ConfigureSPLL+0xd0>
                SCG_SetSpllControl(SCG, true, true, spllCfg->locked);
1ffe1310:	79e3      	ldrb	r3, [r4, #7]
1ffe1312:	b14b      	cbz	r3, 1ffe1328 <CLOCK_SYS_ConfigureSPLL+0xf8>
1ffe1314:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
    uint32_t value = SCG_SPLLCSR_SPLLEN(1U)                        |
1ffe1318:	f443 3340 	orr.w	r3, r3, #196608	; 0x30000
1ffe131c:	f043 0301 	orr.w	r3, r3, #1
    base->SPLLCSR = value;
1ffe1320:	4a07      	ldr	r2, [pc, #28]	; (1ffe1340 <CLOCK_SYS_ConfigureSPLL+0x110>)
1ffe1322:	f8c2 3600 	str.w	r3, [r2, #1536]	; 0x600
}
1ffe1326:	e7d8      	b.n	1ffe12da <CLOCK_SYS_ConfigureSPLL+0xaa>
                     SCG_SPLLCSR_LK((lockMode) ? 1UL : 0UL);
1ffe1328:	2300      	movs	r3, #0
1ffe132a:	e7f5      	b.n	1ffe1318 <CLOCK_SYS_ConfigureSPLL+0xe8>
            timeout--;
1ffe132c:	3c01      	subs	r4, #1
        while ((CLOCK_SYS_GetSysPllFreq() == 0U) && (timeout > 0U))
1ffe132e:	f7ff ff5f 	bl	1ffe11f0 <CLOCK_SYS_GetSysPllFreq>
1ffe1332:	b908      	cbnz	r0, 1ffe1338 <CLOCK_SYS_ConfigureSPLL+0x108>
1ffe1334:	2c00      	cmp	r4, #0
1ffe1336:	d1f9      	bne.n	1ffe132c <CLOCK_SYS_ConfigureSPLL+0xfc>
        if (timeout == 0U)
1ffe1338:	2c00      	cmp	r4, #0
1ffe133a:	d191      	bne.n	1ffe1260 <CLOCK_SYS_ConfigureSPLL+0x30>
            status = STATUS_TIMEOUT;
1ffe133c:	2503      	movs	r5, #3
1ffe133e:	e78f      	b.n	1ffe1260 <CLOCK_SYS_ConfigureSPLL+0x30>
1ffe1340:	40064000 	.word	0x40064000

1ffe1344 <CLOCK_SYS_GetSrcFreq>:
{
1ffe1344:	b508      	push	{r3, lr}
    switch (src)
1ffe1346:	3801      	subs	r0, #1
1ffe1348:	2805      	cmp	r0, #5
1ffe134a:	d810      	bhi.n	1ffe136e <CLOCK_SYS_GetSrcFreq+0x2a>
1ffe134c:	e8df f000 	tbb	[pc, r0]
1ffe1350:	0f090603 	.word	0x0f090603
1ffe1354:	0c0f      	.short	0x0c0f
            srcFreq = CLOCK_SYS_GetSysOscFreq();
1ffe1356:	f7ff fdcf 	bl	1ffe0ef8 <CLOCK_SYS_GetSysOscFreq>
            break;
1ffe135a:	e009      	b.n	1ffe1370 <CLOCK_SYS_GetSrcFreq+0x2c>
            srcFreq = CLOCK_SYS_GetSircFreq();
1ffe135c:	f7ff fe70 	bl	1ffe1040 <CLOCK_SYS_GetSircFreq>
            break;
1ffe1360:	e006      	b.n	1ffe1370 <CLOCK_SYS_GetSrcFreq+0x2c>
            srcFreq = CLOCK_SYS_GetFircFreq();
1ffe1362:	f7ff fedf 	bl	1ffe1124 <CLOCK_SYS_GetFircFreq>
            break;
1ffe1366:	e003      	b.n	1ffe1370 <CLOCK_SYS_GetSrcFreq+0x2c>
            srcFreq = CLOCK_SYS_GetSysPllFreq();
1ffe1368:	f7ff ff42 	bl	1ffe11f0 <CLOCK_SYS_GetSysPllFreq>
            break;
1ffe136c:	e000      	b.n	1ffe1370 <CLOCK_SYS_GetSrcFreq+0x2c>
    switch (src)
1ffe136e:	2000      	movs	r0, #0
}
1ffe1370:	bd08      	pop	{r3, pc}
	...

1ffe1374 <CLOCK_SYS_SetSystemClockConfig>:
{
1ffe1374:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
1ffe1378:	4606      	mov	r6, r0
1ffe137a:	460c      	mov	r4, r1
    const uint32_t sysFreqMul = ((uint32_t)config->divCore) + 1UL;
1ffe137c:	788d      	ldrb	r5, [r1, #2]
1ffe137e:	1c6f      	adds	r7, r5, #1
    const uint32_t busFreqMul = (((uint32_t)config->divCore) + 1UL) * (((uint32_t)config->divBus) + 1UL);
1ffe1380:	784a      	ldrb	r2, [r1, #1]
1ffe1382:	3201      	adds	r2, #1
1ffe1384:	fb05 2802 	mla	r8, r5, r2, r2
    const uint32_t slowFreqMul = (((uint32_t)config->divCore) + 1UL) * (((uint32_t)config->divSlow) + 1UL);
1ffe1388:	780b      	ldrb	r3, [r1, #0]
1ffe138a:	3301      	adds	r3, #1
1ffe138c:	fb05 3503 	mla	r5, r5, r3, r3
    srcFreq = CLOCK_SYS_GetSrcFreq(config->src);
1ffe1390:	78c8      	ldrb	r0, [r1, #3]
1ffe1392:	f7ff ffd7 	bl	1ffe1344 <CLOCK_SYS_GetSrcFreq>
    srcFreq >>= 4U;
1ffe1396:	0900      	lsrs	r0, r0, #4
    switch (mode)
1ffe1398:	2e02      	cmp	r6, #2
1ffe139a:	d03c      	beq.n	1ffe1416 <CLOCK_SYS_SetSystemClockConfig+0xa2>
1ffe139c:	2e03      	cmp	r6, #3
1ffe139e:	d06e      	beq.n	1ffe147e <CLOCK_SYS_SetSystemClockConfig+0x10a>
1ffe13a0:	2e01      	cmp	r6, #1
1ffe13a2:	d002      	beq.n	1ffe13aa <CLOCK_SYS_SetSystemClockConfig+0x36>
1ffe13a4:	2000      	movs	r0, #0
}
1ffe13a6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            if ((srcFreq > (sysFreqMul  * (maxSysClksInRUN[(uint32_t)config->src][CORE_CLK_INDEX] >> 4U))) ||    /* Sys(core) clock */
1ffe13aa:	78e1      	ldrb	r1, [r4, #3]
1ffe13ac:	eb01 0241 	add.w	r2, r1, r1, lsl #1
1ffe13b0:	4b56      	ldr	r3, [pc, #344]	; (1ffe150c <CLOCK_SYS_SetSystemClockConfig+0x198>)
1ffe13b2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
1ffe13b6:	091b      	lsrs	r3, r3, #4
1ffe13b8:	fb03 f707 	mul.w	r7, r3, r7
1ffe13bc:	4287      	cmp	r7, r0
1ffe13be:	f0c0 8092 	bcc.w	1ffe14e6 <CLOCK_SYS_SetSystemClockConfig+0x172>
                (srcFreq > (busFreqMul  * (maxSysClksInRUN[(uint32_t)config->src][BUS_CLK_INDEX] >> 4U)))  ||    /* Bus clock */
1ffe13c2:	4613      	mov	r3, r2
1ffe13c4:	4a51      	ldr	r2, [pc, #324]	; (1ffe150c <CLOCK_SYS_SetSystemClockConfig+0x198>)
1ffe13c6:	eb02 0383 	add.w	r3, r2, r3, lsl #2
1ffe13ca:	685a      	ldr	r2, [r3, #4]
1ffe13cc:	0912      	lsrs	r2, r2, #4
1ffe13ce:	fb08 f202 	mul.w	r2, r8, r2
            if ((srcFreq > (sysFreqMul  * (maxSysClksInRUN[(uint32_t)config->src][CORE_CLK_INDEX] >> 4U))) ||    /* Sys(core) clock */
1ffe13d2:	4282      	cmp	r2, r0
1ffe13d4:	f0c0 8089 	bcc.w	1ffe14ea <CLOCK_SYS_SetSystemClockConfig+0x176>
                (srcFreq > (slowFreqMul * (maxSysClksInRUN[(uint32_t)config->src][SLOW_CLK_INDEX] >> 4U))))      /* Slow clock */
1ffe13d8:	eb01 0341 	add.w	r3, r1, r1, lsl #1
1ffe13dc:	4a4b      	ldr	r2, [pc, #300]	; (1ffe150c <CLOCK_SYS_SetSystemClockConfig+0x198>)
1ffe13de:	eb02 0383 	add.w	r3, r2, r3, lsl #2
1ffe13e2:	689b      	ldr	r3, [r3, #8]
1ffe13e4:	091b      	lsrs	r3, r3, #4
1ffe13e6:	fb05 f303 	mul.w	r3, r5, r3
                (srcFreq > (busFreqMul  * (maxSysClksInRUN[(uint32_t)config->src][BUS_CLK_INDEX] >> 4U)))  ||    /* Bus clock */
1ffe13ea:	4283      	cmp	r3, r0
1ffe13ec:	d37f      	bcc.n	1ffe14ee <CLOCK_SYS_SetSystemClockConfig+0x17a>
                SCG_SetRunClockControl(SCG, (uint32_t)config->src, (uint32_t)config->divCore, (uint32_t)config->divBus, (uint32_t)config->divSlow);
1ffe13ee:	78a0      	ldrb	r0, [r4, #2]
1ffe13f0:	7862      	ldrb	r2, [r4, #1]
1ffe13f2:	7824      	ldrb	r4, [r4, #0]
    uint32_t value = (uint32_t)(((source      << SCG_RCCR_SCS_SHIFT)     & SCG_RCCR_SCS_MASK)     |
1ffe13f4:	060b      	lsls	r3, r1, #24
1ffe13f6:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
                                ((coreDivider << SCG_RCCR_DIVCORE_SHIFT) & SCG_RCCR_DIVCORE_MASK) |
1ffe13fa:	0401      	lsls	r1, r0, #16
1ffe13fc:	f401 2170 	and.w	r1, r1, #983040	; 0xf0000
    uint32_t value = (uint32_t)(((source      << SCG_RCCR_SCS_SHIFT)     & SCG_RCCR_SCS_MASK)     |
1ffe1400:	430b      	orrs	r3, r1
                                ((busDivider  << SCG_RCCR_DIVBUS_SHIFT)  & SCG_RCCR_DIVBUS_MASK)  |
1ffe1402:	0112      	lsls	r2, r2, #4
1ffe1404:	b2d2      	uxtb	r2, r2
                                ((coreDivider << SCG_RCCR_DIVCORE_SHIFT) & SCG_RCCR_DIVCORE_MASK) |
1ffe1406:	4313      	orrs	r3, r2
                                ((slowDivider << SCG_RCCR_DIVSLOW_SHIFT) & SCG_RCCR_DIVSLOW_MASK) );
1ffe1408:	f004 020f 	and.w	r2, r4, #15
    uint32_t value = (uint32_t)(((source      << SCG_RCCR_SCS_SHIFT)     & SCG_RCCR_SCS_MASK)     |
1ffe140c:	4313      	orrs	r3, r2
    base->RCCR = value;
1ffe140e:	4a40      	ldr	r2, [pc, #256]	; (1ffe1510 <CLOCK_SYS_SetSystemClockConfig+0x19c>)
1ffe1410:	6153      	str	r3, [r2, #20]
    status_t status = STATUS_SUCCESS;
1ffe1412:	2000      	movs	r0, #0
}
1ffe1414:	e7c7      	b.n	1ffe13a6 <CLOCK_SYS_SetSystemClockConfig+0x32>
            if ((srcFreq > (sysFreqMul  * (maxSysClksInVLPR[(uint32_t)config->src][CORE_CLK_INDEX] >> 4U))) ||    /* Sys(core) clock */
1ffe1416:	78e1      	ldrb	r1, [r4, #3]
1ffe1418:	eb01 0241 	add.w	r2, r1, r1, lsl #1
1ffe141c:	4b3d      	ldr	r3, [pc, #244]	; (1ffe1514 <CLOCK_SYS_SetSystemClockConfig+0x1a0>)
1ffe141e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
1ffe1422:	091b      	lsrs	r3, r3, #4
1ffe1424:	fb03 f707 	mul.w	r7, r3, r7
1ffe1428:	4287      	cmp	r7, r0
1ffe142a:	d362      	bcc.n	1ffe14f2 <CLOCK_SYS_SetSystemClockConfig+0x17e>
                (srcFreq > (busFreqMul  * (maxSysClksInVLPR[(uint32_t)config->src][BUS_CLK_INDEX] >> 4U)))  ||    /* Bus clock */
1ffe142c:	4613      	mov	r3, r2
1ffe142e:	4a39      	ldr	r2, [pc, #228]	; (1ffe1514 <CLOCK_SYS_SetSystemClockConfig+0x1a0>)
1ffe1430:	eb02 0383 	add.w	r3, r2, r3, lsl #2
1ffe1434:	685a      	ldr	r2, [r3, #4]
1ffe1436:	0912      	lsrs	r2, r2, #4
1ffe1438:	fb08 f202 	mul.w	r2, r8, r2
            if ((srcFreq > (sysFreqMul  * (maxSysClksInVLPR[(uint32_t)config->src][CORE_CLK_INDEX] >> 4U))) ||    /* Sys(core) clock */
1ffe143c:	4282      	cmp	r2, r0
1ffe143e:	d35a      	bcc.n	1ffe14f6 <CLOCK_SYS_SetSystemClockConfig+0x182>
                (srcFreq > (slowFreqMul * (maxSysClksInVLPR[(uint32_t)config->src][SLOW_CLK_INDEX] >> 4U))))      /* Slow clock */
1ffe1440:	eb01 0341 	add.w	r3, r1, r1, lsl #1
1ffe1444:	4a33      	ldr	r2, [pc, #204]	; (1ffe1514 <CLOCK_SYS_SetSystemClockConfig+0x1a0>)
1ffe1446:	eb02 0383 	add.w	r3, r2, r3, lsl #2
1ffe144a:	689b      	ldr	r3, [r3, #8]
1ffe144c:	091b      	lsrs	r3, r3, #4
1ffe144e:	fb05 f303 	mul.w	r3, r5, r3
                (srcFreq > (busFreqMul  * (maxSysClksInVLPR[(uint32_t)config->src][BUS_CLK_INDEX] >> 4U)))  ||    /* Bus clock */
1ffe1452:	4283      	cmp	r3, r0
1ffe1454:	d351      	bcc.n	1ffe14fa <CLOCK_SYS_SetSystemClockConfig+0x186>
                SCG_SetVlprClockControl(SCG, (uint32_t)config->src, (uint32_t)config->divCore, (uint32_t)config->divBus, (uint32_t)config->divSlow);
1ffe1456:	78a0      	ldrb	r0, [r4, #2]
1ffe1458:	7862      	ldrb	r2, [r4, #1]
1ffe145a:	7824      	ldrb	r4, [r4, #0]
    uint32_t value = (uint32_t)(((source      << SCG_VCCR_SCS_SHIFT)     & SCG_VCCR_SCS_MASK)     |
1ffe145c:	060b      	lsls	r3, r1, #24
1ffe145e:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
                                ((coreDivider << SCG_VCCR_DIVCORE_SHIFT) & SCG_VCCR_DIVCORE_MASK) |
1ffe1462:	0401      	lsls	r1, r0, #16
1ffe1464:	f401 2170 	and.w	r1, r1, #983040	; 0xf0000
    uint32_t value = (uint32_t)(((source      << SCG_VCCR_SCS_SHIFT)     & SCG_VCCR_SCS_MASK)     |
1ffe1468:	430b      	orrs	r3, r1
                                ((busDivider  << SCG_VCCR_DIVBUS_SHIFT)  & SCG_VCCR_DIVBUS_MASK)  |
1ffe146a:	0112      	lsls	r2, r2, #4
1ffe146c:	b2d2      	uxtb	r2, r2
                                ((coreDivider << SCG_VCCR_DIVCORE_SHIFT) & SCG_VCCR_DIVCORE_MASK) |
1ffe146e:	4313      	orrs	r3, r2
                                ((slowDivider << SCG_VCCR_DIVSLOW_SHIFT) & SCG_VCCR_DIVSLOW_MASK) );
1ffe1470:	f004 020f 	and.w	r2, r4, #15
    uint32_t value = (uint32_t)(((source      << SCG_VCCR_SCS_SHIFT)     & SCG_VCCR_SCS_MASK)     |
1ffe1474:	4313      	orrs	r3, r2
    base->VCCR = value;
1ffe1476:	4a26      	ldr	r2, [pc, #152]	; (1ffe1510 <CLOCK_SYS_SetSystemClockConfig+0x19c>)
1ffe1478:	6193      	str	r3, [r2, #24]
    status_t status = STATUS_SUCCESS;
1ffe147a:	2000      	movs	r0, #0
}
1ffe147c:	e793      	b.n	1ffe13a6 <CLOCK_SYS_SetSystemClockConfig+0x32>
            if ((srcFreq > (sysFreqMul  * (maxSysClksInHSRUN[(uint32_t)config->src][CORE_CLK_INDEX] >> 4U))) ||    /* Sys(core) clock */
1ffe147e:	78e1      	ldrb	r1, [r4, #3]
1ffe1480:	eb01 0241 	add.w	r2, r1, r1, lsl #1
1ffe1484:	4b24      	ldr	r3, [pc, #144]	; (1ffe1518 <CLOCK_SYS_SetSystemClockConfig+0x1a4>)
1ffe1486:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
1ffe148a:	091b      	lsrs	r3, r3, #4
1ffe148c:	fb03 f707 	mul.w	r7, r3, r7
1ffe1490:	4287      	cmp	r7, r0
1ffe1492:	d334      	bcc.n	1ffe14fe <CLOCK_SYS_SetSystemClockConfig+0x18a>
                (srcFreq > (busFreqMul * (maxSysClksInHSRUN[(uint32_t)config->src][BUS_CLK_INDEX] >> 4U)))  ||    /* Bus clock */
1ffe1494:	4613      	mov	r3, r2
1ffe1496:	4a20      	ldr	r2, [pc, #128]	; (1ffe1518 <CLOCK_SYS_SetSystemClockConfig+0x1a4>)
1ffe1498:	eb02 0383 	add.w	r3, r2, r3, lsl #2
1ffe149c:	685a      	ldr	r2, [r3, #4]
1ffe149e:	0912      	lsrs	r2, r2, #4
1ffe14a0:	fb08 f202 	mul.w	r2, r8, r2
            if ((srcFreq > (sysFreqMul  * (maxSysClksInHSRUN[(uint32_t)config->src][CORE_CLK_INDEX] >> 4U))) ||    /* Sys(core) clock */
1ffe14a4:	4282      	cmp	r2, r0
1ffe14a6:	d32c      	bcc.n	1ffe1502 <CLOCK_SYS_SetSystemClockConfig+0x18e>
                (srcFreq > (slowFreqMul * (maxSysClksInHSRUN[(uint32_t)config->src][SLOW_CLK_INDEX] >> 4U))))      /* Slow clock */
1ffe14a8:	eb01 0341 	add.w	r3, r1, r1, lsl #1
1ffe14ac:	4a1a      	ldr	r2, [pc, #104]	; (1ffe1518 <CLOCK_SYS_SetSystemClockConfig+0x1a4>)
1ffe14ae:	eb02 0383 	add.w	r3, r2, r3, lsl #2
1ffe14b2:	689b      	ldr	r3, [r3, #8]
1ffe14b4:	091b      	lsrs	r3, r3, #4
1ffe14b6:	fb05 f303 	mul.w	r3, r5, r3
                (srcFreq > (busFreqMul * (maxSysClksInHSRUN[(uint32_t)config->src][BUS_CLK_INDEX] >> 4U)))  ||    /* Bus clock */
1ffe14ba:	4283      	cmp	r3, r0
1ffe14bc:	d323      	bcc.n	1ffe1506 <CLOCK_SYS_SetSystemClockConfig+0x192>
                SCG_SetHsrunClockControl(SCG, (uint32_t)config->src, (uint32_t)config->divCore, (uint32_t)config->divBus, (uint32_t)config->divSlow);
1ffe14be:	78a0      	ldrb	r0, [r4, #2]
1ffe14c0:	7862      	ldrb	r2, [r4, #1]
1ffe14c2:	7824      	ldrb	r4, [r4, #0]
    uint32_t value = (uint32_t)(((source      << SCG_HCCR_SCS_SHIFT)     & SCG_HCCR_SCS_MASK)     |
1ffe14c4:	060b      	lsls	r3, r1, #24
1ffe14c6:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
                                ((coreDivider << SCG_HCCR_DIVCORE_SHIFT) & SCG_HCCR_DIVCORE_MASK) |
1ffe14ca:	0401      	lsls	r1, r0, #16
1ffe14cc:	f401 2170 	and.w	r1, r1, #983040	; 0xf0000
    uint32_t value = (uint32_t)(((source      << SCG_HCCR_SCS_SHIFT)     & SCG_HCCR_SCS_MASK)     |
1ffe14d0:	430b      	orrs	r3, r1
                                ((busDivider  << SCG_HCCR_DIVBUS_SHIFT)  & SCG_HCCR_DIVBUS_MASK)  |
1ffe14d2:	0112      	lsls	r2, r2, #4
1ffe14d4:	b2d2      	uxtb	r2, r2
                                ((coreDivider << SCG_HCCR_DIVCORE_SHIFT) & SCG_HCCR_DIVCORE_MASK) |
1ffe14d6:	4313      	orrs	r3, r2
                                ((slowDivider << SCG_HCCR_DIVSLOW_SHIFT) & SCG_HCCR_DIVSLOW_MASK) );
1ffe14d8:	f004 020f 	and.w	r2, r4, #15
    uint32_t value = (uint32_t)(((source      << SCG_HCCR_SCS_SHIFT)     & SCG_HCCR_SCS_MASK)     |
1ffe14dc:	4313      	orrs	r3, r2
    base->HCCR = value;
1ffe14de:	4a0c      	ldr	r2, [pc, #48]	; (1ffe1510 <CLOCK_SYS_SetSystemClockConfig+0x19c>)
1ffe14e0:	61d3      	str	r3, [r2, #28]
    status_t status = STATUS_SUCCESS;
1ffe14e2:	2000      	movs	r0, #0
}
1ffe14e4:	e75f      	b.n	1ffe13a6 <CLOCK_SYS_SetSystemClockConfig+0x32>
                status = STATUS_ERROR;
1ffe14e6:	2001      	movs	r0, #1
1ffe14e8:	e75d      	b.n	1ffe13a6 <CLOCK_SYS_SetSystemClockConfig+0x32>
1ffe14ea:	2001      	movs	r0, #1
1ffe14ec:	e75b      	b.n	1ffe13a6 <CLOCK_SYS_SetSystemClockConfig+0x32>
1ffe14ee:	2001      	movs	r0, #1
1ffe14f0:	e759      	b.n	1ffe13a6 <CLOCK_SYS_SetSystemClockConfig+0x32>
                status = STATUS_ERROR;
1ffe14f2:	2001      	movs	r0, #1
1ffe14f4:	e757      	b.n	1ffe13a6 <CLOCK_SYS_SetSystemClockConfig+0x32>
1ffe14f6:	2001      	movs	r0, #1
1ffe14f8:	e755      	b.n	1ffe13a6 <CLOCK_SYS_SetSystemClockConfig+0x32>
1ffe14fa:	2001      	movs	r0, #1
1ffe14fc:	e753      	b.n	1ffe13a6 <CLOCK_SYS_SetSystemClockConfig+0x32>
                status = STATUS_ERROR;
1ffe14fe:	2001      	movs	r0, #1
1ffe1500:	e751      	b.n	1ffe13a6 <CLOCK_SYS_SetSystemClockConfig+0x32>
1ffe1502:	2001      	movs	r0, #1
1ffe1504:	e74f      	b.n	1ffe13a6 <CLOCK_SYS_SetSystemClockConfig+0x32>
1ffe1506:	2001      	movs	r0, #1
1ffe1508:	e74d      	b.n	1ffe13a6 <CLOCK_SYS_SetSystemClockConfig+0x32>
1ffe150a:	bf00      	nop
1ffe150c:	1ffe35c4 	.word	0x1ffe35c4
1ffe1510:	40064000 	.word	0x40064000
1ffe1514:	1ffe3618 	.word	0x1ffe3618
1ffe1518:	1ffe3570 	.word	0x1ffe3570

1ffe151c <CLOCK_SYS_TransitionSystemClock>:
{
1ffe151c:	b510      	push	{r4, lr}
1ffe151e:	4604      	mov	r4, r0
    run_mode = CLOCK_SYS_GetCurrentRunMode();
1ffe1520:	f7ff fcd6 	bl	1ffe0ed0 <CLOCK_SYS_GetCurrentRunMode>
    retValue = CLOCK_SYS_SetSystemClockConfig(run_mode, to_clk);
1ffe1524:	4621      	mov	r1, r4
1ffe1526:	f7ff ff25 	bl	1ffe1374 <CLOCK_SYS_SetSystemClockConfig>
    if (retValue == STATUS_SUCCESS)
1ffe152a:	b958      	cbnz	r0, 1ffe1544 <CLOCK_SYS_TransitionSystemClock+0x28>
        timeout = 10U;
1ffe152c:	220a      	movs	r2, #10
            timeout--;
1ffe152e:	3a01      	subs	r2, #1
    return ((base->CSR & SCG_CSR_SCS_MASK) >> SCG_CSR_SCS_SHIFT);
1ffe1530:	4b06      	ldr	r3, [pc, #24]	; (1ffe154c <CLOCK_SYS_TransitionSystemClock+0x30>)
1ffe1532:	691b      	ldr	r3, [r3, #16]
1ffe1534:	f3c3 6303 	ubfx	r3, r3, #24, #4
        while ((SCG_GetCurrentSystemClockSource(SCG) != ((uint32_t)to_clk->src)) && (timeout > 0U));
1ffe1538:	78e1      	ldrb	r1, [r4, #3]
1ffe153a:	4299      	cmp	r1, r3
1ffe153c:	d001      	beq.n	1ffe1542 <CLOCK_SYS_TransitionSystemClock+0x26>
1ffe153e:	2a00      	cmp	r2, #0
1ffe1540:	d1f5      	bne.n	1ffe152e <CLOCK_SYS_TransitionSystemClock+0x12>
        if (timeout == 0U)
1ffe1542:	b102      	cbz	r2, 1ffe1546 <CLOCK_SYS_TransitionSystemClock+0x2a>
}
1ffe1544:	bd10      	pop	{r4, pc}
            retValue = STATUS_TIMEOUT;
1ffe1546:	2003      	movs	r0, #3
1ffe1548:	e7fc      	b.n	1ffe1544 <CLOCK_SYS_TransitionSystemClock+0x28>
1ffe154a:	bf00      	nop
1ffe154c:	40064000 	.word	0x40064000

1ffe1550 <CLOCK_SYS_ConfigureTemporarySystemClock>:
{
1ffe1550:	b500      	push	{lr}
1ffe1552:	b083      	sub	sp, #12
1ffe1554:	4b10      	ldr	r3, [pc, #64]	; (1ffe1598 <CLOCK_SYS_ConfigureTemporarySystemClock+0x48>)
1ffe1556:	691b      	ldr	r3, [r3, #16]
1ffe1558:	f3c3 6303 	ubfx	r3, r3, #24, #4
    if (SCG_GetCurrentSystemClockSource(SCG) != ((uint32_t)SCG_SYSTEM_CLOCK_SRC_FIRC))
1ffe155c:	2b03      	cmp	r3, #3
1ffe155e:	d103      	bne.n	1ffe1568 <CLOCK_SYS_ConfigureTemporarySystemClock+0x18>
    status_t status = STATUS_SUCCESS;
1ffe1560:	2000      	movs	r0, #0
}
1ffe1562:	b003      	add	sp, #12
1ffe1564:	f85d fb04 	ldr.w	pc, [sp], #4
        if (CLOCK_SYS_GetFircFreq() == 0UL)
1ffe1568:	f7ff fddc 	bl	1ffe1124 <CLOCK_SYS_GetFircFreq>
1ffe156c:	b928      	cbnz	r0, 1ffe157a <CLOCK_SYS_ConfigureTemporarySystemClock+0x2a>
            status = CLOCK_SYS_ConfigureFIRC(true, NULL);
1ffe156e:	2100      	movs	r1, #0
1ffe1570:	2001      	movs	r0, #1
1ffe1572:	f7ff fde7 	bl	1ffe1144 <CLOCK_SYS_ConfigureFIRC>
        if (status == STATUS_SUCCESS)
1ffe1576:	2800      	cmp	r0, #0
1ffe1578:	d1f3      	bne.n	1ffe1562 <CLOCK_SYS_ConfigureTemporarySystemClock+0x12>
            sysClockConfig.src     = SCG_SYSTEM_CLOCK_SRC_FIRC;
1ffe157a:	2303      	movs	r3, #3
1ffe157c:	f88d 3007 	strb.w	r3, [sp, #7]
            sysClockConfig.divCore = tmpSysClk[TMP_FIRC_CLK][TMP_SYS_DIV];
1ffe1580:	2200      	movs	r2, #0
1ffe1582:	f88d 2006 	strb.w	r2, [sp, #6]
            sysClockConfig.divBus  = tmpSysClk[TMP_FIRC_CLK][TMP_BUS_DIV];
1ffe1586:	2201      	movs	r2, #1
1ffe1588:	f88d 2005 	strb.w	r2, [sp, #5]
            sysClockConfig.divSlow = tmpSysClk[TMP_FIRC_CLK][TMP_SLOW_DIV];
1ffe158c:	f88d 3004 	strb.w	r3, [sp, #4]
            status = CLOCK_SYS_TransitionSystemClock(&sysClockConfig);
1ffe1590:	a801      	add	r0, sp, #4
1ffe1592:	f7ff ffc3 	bl	1ffe151c <CLOCK_SYS_TransitionSystemClock>
1ffe1596:	e7e4      	b.n	1ffe1562 <CLOCK_SYS_ConfigureTemporarySystemClock+0x12>
1ffe1598:	40064000 	.word	0x40064000

1ffe159c <CLOCK_SYS_ConfigureModulesFromScg>:
{
1ffe159c:	b570      	push	{r4, r5, r6, lr}
1ffe159e:	b082      	sub	sp, #8
1ffe15a0:	4604      	mov	r4, r0
    status = CLOCK_SYS_ConfigureSIRC(scgConfig->sircConfig.initialize, &scgConfig->sircConfig);
1ffe15a2:	4601      	mov	r1, r0
1ffe15a4:	78c0      	ldrb	r0, [r0, #3]
1ffe15a6:	f7ff fd5d 	bl	1ffe1064 <CLOCK_SYS_ConfigureSIRC>
    if (status == STATUS_SUCCESS)
1ffe15aa:	4605      	mov	r5, r0
1ffe15ac:	b1e8      	cbz	r0, 1ffe15ea <CLOCK_SYS_ConfigureModulesFromScg+0x4e>
    switch (CLOCK_SYS_GetCurrentRunMode())
1ffe15ae:	f7ff fc8f 	bl	1ffe0ed0 <CLOCK_SYS_GetCurrentRunMode>
1ffe15b2:	2802      	cmp	r0, #2
1ffe15b4:	d02c      	beq.n	1ffe1610 <CLOCK_SYS_ConfigureModulesFromScg+0x74>
1ffe15b6:	2803      	cmp	r0, #3
1ffe15b8:	d02d      	beq.n	1ffe1616 <CLOCK_SYS_ConfigureModulesFromScg+0x7a>
1ffe15ba:	2801      	cmp	r0, #1
1ffe15bc:	d025      	beq.n	1ffe160a <CLOCK_SYS_ConfigureModulesFromScg+0x6e>
1ffe15be:	2600      	movs	r6, #0
    if (status == STATUS_SUCCESS)
1ffe15c0:	b985      	cbnz	r5, 1ffe15e4 <CLOCK_SYS_ConfigureModulesFromScg+0x48>
        if (nextSysClockConfig->src == SCG_SYSTEM_CLOCK_SRC_FIRC)
1ffe15c2:	78f3      	ldrb	r3, [r6, #3]
1ffe15c4:	2b03      	cmp	r3, #3
1ffe15c6:	d170      	bne.n	1ffe16aa <CLOCK_SYS_ConfigureModulesFromScg+0x10e>
            if (scgConfig->spllConfig.initialize && (status == STATUS_ERROR))
1ffe15c8:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
1ffe15cc:	bb33      	cbnz	r3, 1ffe161c <CLOCK_SYS_ConfigureModulesFromScg+0x80>
            status = STATUS_ERROR;
1ffe15ce:	2501      	movs	r5, #1
            if (scgConfig->soscConfig.initialize && (status == STATUS_ERROR))
1ffe15d0:	7f63      	ldrb	r3, [r4, #29]
1ffe15d2:	b10b      	cbz	r3, 1ffe15d8 <CLOCK_SYS_ConfigureModulesFromScg+0x3c>
1ffe15d4:	2d01      	cmp	r5, #1
1ffe15d6:	d031      	beq.n	1ffe163c <CLOCK_SYS_ConfigureModulesFromScg+0xa0>
            if (scgConfig->sircConfig.initialize && (status == STATUS_ERROR))
1ffe15d8:	78e3      	ldrb	r3, [r4, #3]
1ffe15da:	b10b      	cbz	r3, 1ffe15e0 <CLOCK_SYS_ConfigureModulesFromScg+0x44>
1ffe15dc:	2d01      	cmp	r5, #1
1ffe15de:	d03c      	beq.n	1ffe165a <CLOCK_SYS_ConfigureModulesFromScg+0xbe>
            if (status == STATUS_SUCCESS)
1ffe15e0:	2d00      	cmp	r5, #0
1ffe15e2:	d04a      	beq.n	1ffe167a <CLOCK_SYS_ConfigureModulesFromScg+0xde>
}
1ffe15e4:	4628      	mov	r0, r5
1ffe15e6:	b002      	add	sp, #8
1ffe15e8:	bd70      	pop	{r4, r5, r6, pc}
        status = CLOCK_SYS_ConfigureSOSC(scgConfig->soscConfig.initialize, &scgConfig->soscConfig);
1ffe15ea:	f104 0110 	add.w	r1, r4, #16
1ffe15ee:	7f60      	ldrb	r0, [r4, #29]
1ffe15f0:	f7ff fc90 	bl	1ffe0f14 <CLOCK_SYS_ConfigureSOSC>
        if (status == STATUS_SUCCESS)
1ffe15f4:	4605      	mov	r5, r0
1ffe15f6:	2800      	cmp	r0, #0
1ffe15f8:	d1d9      	bne.n	1ffe15ae <CLOCK_SYS_ConfigureModulesFromScg+0x12>
            status = CLOCK_SYS_ConfigureSPLL(scgConfig->spllConfig.initialize,&scgConfig->spllConfig);
1ffe15fa:	f104 0120 	add.w	r1, r4, #32
1ffe15fe:	f894 0028 	ldrb.w	r0, [r4, #40]	; 0x28
1ffe1602:	f7ff fe15 	bl	1ffe1230 <CLOCK_SYS_ConfigureSPLL>
1ffe1606:	4605      	mov	r5, r0
1ffe1608:	e7d1      	b.n	1ffe15ae <CLOCK_SYS_ConfigureModulesFromScg+0x12>
            nextSysClockConfig = &scgConfig->clockModeConfig.rccrConfig;
1ffe160a:	f104 0636 	add.w	r6, r4, #54	; 0x36
        break;
1ffe160e:	e7d7      	b.n	1ffe15c0 <CLOCK_SYS_ConfigureModulesFromScg+0x24>
            nextSysClockConfig = &scgConfig->clockModeConfig.vccrConfig;
1ffe1610:	f104 063a 	add.w	r6, r4, #58	; 0x3a
        break;
1ffe1614:	e7d4      	b.n	1ffe15c0 <CLOCK_SYS_ConfigureModulesFromScg+0x24>
            nextSysClockConfig = &scgConfig->clockModeConfig.hccrConfig;
1ffe1616:	f104 063e 	add.w	r6, r4, #62	; 0x3e
        break;
1ffe161a:	e7d1      	b.n	1ffe15c0 <CLOCK_SYS_ConfigureModulesFromScg+0x24>
                sysClockConfig.src     = SCG_SYSTEM_CLOCK_SRC_SYS_PLL;
1ffe161c:	2306      	movs	r3, #6
1ffe161e:	f88d 3007 	strb.w	r3, [sp, #7]
                sysClockConfig.divCore = tmpSysClk[TMP_SPLL_CLK][TMP_SYS_DIV];
1ffe1622:	2302      	movs	r3, #2
1ffe1624:	f88d 3006 	strb.w	r3, [sp, #6]
                sysClockConfig.divBus  = tmpSysClk[TMP_SPLL_CLK][TMP_BUS_DIV];
1ffe1628:	2301      	movs	r3, #1
1ffe162a:	f88d 3005 	strb.w	r3, [sp, #5]
                sysClockConfig.divSlow = tmpSysClk[TMP_SPLL_CLK][TMP_SLOW_DIV];
1ffe162e:	f88d 3004 	strb.w	r3, [sp, #4]
                status = CLOCK_SYS_TransitionSystemClock(&sysClockConfig);
1ffe1632:	a801      	add	r0, sp, #4
1ffe1634:	f7ff ff72 	bl	1ffe151c <CLOCK_SYS_TransitionSystemClock>
1ffe1638:	4605      	mov	r5, r0
1ffe163a:	e7c9      	b.n	1ffe15d0 <CLOCK_SYS_ConfigureModulesFromScg+0x34>
                sysClockConfig.src     = SCG_SYSTEM_CLOCK_SRC_SYS_OSC;
1ffe163c:	2301      	movs	r3, #1
1ffe163e:	f88d 3007 	strb.w	r3, [sp, #7]
                sysClockConfig.divCore = tmpSysClk[TMP_SOSC_CLK][TMP_SYS_DIV];
1ffe1642:	2200      	movs	r2, #0
1ffe1644:	f88d 2006 	strb.w	r2, [sp, #6]
                sysClockConfig.divBus  = tmpSysClk[TMP_SOSC_CLK][TMP_BUS_DIV];
1ffe1648:	f88d 3005 	strb.w	r3, [sp, #5]
                sysClockConfig.divSlow = tmpSysClk[TMP_SOSC_CLK][TMP_SLOW_DIV];
1ffe164c:	f88d 3004 	strb.w	r3, [sp, #4]
                status = CLOCK_SYS_TransitionSystemClock(&sysClockConfig);
1ffe1650:	a801      	add	r0, sp, #4
1ffe1652:	f7ff ff63 	bl	1ffe151c <CLOCK_SYS_TransitionSystemClock>
1ffe1656:	4605      	mov	r5, r0
1ffe1658:	e7be      	b.n	1ffe15d8 <CLOCK_SYS_ConfigureModulesFromScg+0x3c>
                sysClockConfig.src     = SCG_SYSTEM_CLOCK_SRC_SIRC;
1ffe165a:	2302      	movs	r3, #2
1ffe165c:	f88d 3007 	strb.w	r3, [sp, #7]
                sysClockConfig.divCore = tmpSysClk[TMP_SIRC_CLK][TMP_SYS_DIV];
1ffe1660:	2300      	movs	r3, #0
1ffe1662:	f88d 3006 	strb.w	r3, [sp, #6]
                sysClockConfig.divBus  = tmpSysClk[TMP_SIRC_CLK][TMP_BUS_DIV];
1ffe1666:	f88d 3005 	strb.w	r3, [sp, #5]
                sysClockConfig.divSlow = tmpSysClk[TMP_SIRC_CLK][TMP_SLOW_DIV];
1ffe166a:	2301      	movs	r3, #1
1ffe166c:	f88d 3004 	strb.w	r3, [sp, #4]
                status = CLOCK_SYS_TransitionSystemClock(&sysClockConfig);
1ffe1670:	a801      	add	r0, sp, #4
1ffe1672:	f7ff ff53 	bl	1ffe151c <CLOCK_SYS_TransitionSystemClock>
1ffe1676:	4605      	mov	r5, r0
1ffe1678:	e7b2      	b.n	1ffe15e0 <CLOCK_SYS_ConfigureModulesFromScg+0x44>
                status = CLOCK_SYS_ConfigureFIRC(scgConfig->fircConfig.initialize, &scgConfig->fircConfig);
1ffe167a:	1de1      	adds	r1, r4, #7
1ffe167c:	7ba0      	ldrb	r0, [r4, #14]
1ffe167e:	f7ff fd61 	bl	1ffe1144 <CLOCK_SYS_ConfigureFIRC>
                if (status == STATUS_SUCCESS)
1ffe1682:	4605      	mov	r5, r0
1ffe1684:	2800      	cmp	r0, #0
1ffe1686:	d1ad      	bne.n	1ffe15e4 <CLOCK_SYS_ConfigureModulesFromScg+0x48>
                    sysClockConfig.src     = nextSysClockConfig->src;
1ffe1688:	78f3      	ldrb	r3, [r6, #3]
1ffe168a:	f88d 3007 	strb.w	r3, [sp, #7]
                    sysClockConfig.divCore = nextSysClockConfig->divCore;
1ffe168e:	78b3      	ldrb	r3, [r6, #2]
1ffe1690:	f88d 3006 	strb.w	r3, [sp, #6]
                    sysClockConfig.divBus  = nextSysClockConfig->divBus;
1ffe1694:	7873      	ldrb	r3, [r6, #1]
1ffe1696:	f88d 3005 	strb.w	r3, [sp, #5]
                    sysClockConfig.divSlow = nextSysClockConfig->divSlow;
1ffe169a:	7833      	ldrb	r3, [r6, #0]
1ffe169c:	f88d 3004 	strb.w	r3, [sp, #4]
                    status = CLOCK_SYS_TransitionSystemClock(&sysClockConfig);
1ffe16a0:	a801      	add	r0, sp, #4
1ffe16a2:	f7ff ff3b 	bl	1ffe151c <CLOCK_SYS_TransitionSystemClock>
1ffe16a6:	4605      	mov	r5, r0
1ffe16a8:	e79c      	b.n	1ffe15e4 <CLOCK_SYS_ConfigureModulesFromScg+0x48>
            sysClockConfig.src     = nextSysClockConfig->src;
1ffe16aa:	f88d 3007 	strb.w	r3, [sp, #7]
            sysClockConfig.divCore = nextSysClockConfig->divCore;
1ffe16ae:	78b3      	ldrb	r3, [r6, #2]
1ffe16b0:	f88d 3006 	strb.w	r3, [sp, #6]
            sysClockConfig.divBus  = nextSysClockConfig->divBus;
1ffe16b4:	7873      	ldrb	r3, [r6, #1]
1ffe16b6:	f88d 3005 	strb.w	r3, [sp, #5]
            sysClockConfig.divSlow = nextSysClockConfig->divSlow;
1ffe16ba:	7833      	ldrb	r3, [r6, #0]
1ffe16bc:	f88d 3004 	strb.w	r3, [sp, #4]
            status = CLOCK_SYS_TransitionSystemClock(&sysClockConfig);
1ffe16c0:	a801      	add	r0, sp, #4
1ffe16c2:	f7ff ff2b 	bl	1ffe151c <CLOCK_SYS_TransitionSystemClock>
            if (status == STATUS_SUCCESS)
1ffe16c6:	4605      	mov	r5, r0
1ffe16c8:	2800      	cmp	r0, #0
1ffe16ca:	d18b      	bne.n	1ffe15e4 <CLOCK_SYS_ConfigureModulesFromScg+0x48>
                status = CLOCK_SYS_ConfigureFIRC(scgConfig->fircConfig.initialize, &scgConfig->fircConfig);
1ffe16cc:	1de1      	adds	r1, r4, #7
1ffe16ce:	7ba0      	ldrb	r0, [r4, #14]
1ffe16d0:	f7ff fd38 	bl	1ffe1144 <CLOCK_SYS_ConfigureFIRC>
1ffe16d4:	4605      	mov	r5, r0
1ffe16d6:	e785      	b.n	1ffe15e4 <CLOCK_SYS_ConfigureModulesFromScg+0x48>

1ffe16d8 <CLOCK_SYS_SetScgConfiguration>:
{
1ffe16d8:	b510      	push	{r4, lr}
    if (scgConfig != NULL)
1ffe16da:	4604      	mov	r4, r0
1ffe16dc:	b3a0      	cbz	r0, 1ffe1748 <CLOCK_SYS_SetScgConfiguration+0x70>
        status = CLOCK_SYS_ConfigureTemporarySystemClock();
1ffe16de:	f7ff ff37 	bl	1ffe1550 <CLOCK_SYS_ConfigureTemporarySystemClock>
        if (status == STATUS_SUCCESS)
1ffe16e2:	b338      	cbz	r0, 1ffe1734 <CLOCK_SYS_SetScgConfiguration+0x5c>
        if (status == STATUS_SUCCESS)
1ffe16e4:	bb88      	cbnz	r0, 1ffe174a <CLOCK_SYS_SetScgConfiguration+0x72>
            g_RtcClkInFreq = 0U; /* reset the value RTC_clk frequency. */
1ffe16e6:	4b19      	ldr	r3, [pc, #100]	; (1ffe174c <CLOCK_SYS_SetScgConfiguration+0x74>)
1ffe16e8:	2200      	movs	r2, #0
1ffe16ea:	601a      	str	r2, [r3, #0]
            if (scgConfig->rtcConfig.initialize)
1ffe16ec:	f894 3030 	ldrb.w	r3, [r4, #48]	; 0x30
1ffe16f0:	b113      	cbz	r3, 1ffe16f8 <CLOCK_SYS_SetScgConfiguration+0x20>
                g_RtcClkInFreq = scgConfig->rtcConfig.rtcClkInFreq;
1ffe16f2:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
1ffe16f4:	4b15      	ldr	r3, [pc, #84]	; (1ffe174c <CLOCK_SYS_SetScgConfiguration+0x74>)
1ffe16f6:	601a      	str	r2, [r3, #0]
            if (scgConfig->clockOutConfig.initialize)
1ffe16f8:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
1ffe16fc:	b153      	cbz	r3, 1ffe1714 <CLOCK_SYS_SetScgConfiguration+0x3c>
                SCG_SetClockoutSourceSel(SCG, (uint32_t)scgConfig->clockOutConfig.source);
1ffe16fe:	f894 2034 	ldrb.w	r2, [r4, #52]	; 0x34
    regValue = base->CLKOUTCNFG;
1ffe1702:	4913      	ldr	r1, [pc, #76]	; (1ffe1750 <CLOCK_SYS_SetScgConfiguration+0x78>)
1ffe1704:	6a0b      	ldr	r3, [r1, #32]
    regValue &= ~(SCG_CLKOUTCNFG_CLKOUTSEL_MASK);
1ffe1706:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    regValue |= SCG_CLKOUTCNFG_CLKOUTSEL(source);
1ffe170a:	0612      	lsls	r2, r2, #24
1ffe170c:	f002 6270 	and.w	r2, r2, #251658240	; 0xf000000
1ffe1710:	4313      	orrs	r3, r2
    base->CLKOUTCNFG = regValue;
1ffe1712:	620b      	str	r3, [r1, #32]
            if (scgConfig->clockModeConfig.initialize)
1ffe1714:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
1ffe1718:	b1bb      	cbz	r3, 1ffe174a <CLOCK_SYS_SetScgConfiguration+0x72>
                status = CLOCK_SYS_SetSystemClockConfig(SCG_SYSTEM_CLOCK_MODE_RUN, &(scgConfig->clockModeConfig.rccrConfig));
1ffe171a:	f104 0136 	add.w	r1, r4, #54	; 0x36
1ffe171e:	2001      	movs	r0, #1
1ffe1720:	f7ff fe28 	bl	1ffe1374 <CLOCK_SYS_SetSystemClockConfig>
                if (status == STATUS_SUCCESS)
1ffe1724:	b150      	cbz	r0, 1ffe173c <CLOCK_SYS_SetScgConfiguration+0x64>
                if (status == STATUS_SUCCESS)
1ffe1726:	b980      	cbnz	r0, 1ffe174a <CLOCK_SYS_SetScgConfiguration+0x72>
                    status = CLOCK_SYS_SetSystemClockConfig(SCG_SYSTEM_CLOCK_MODE_HSRUN, &(scgConfig->clockModeConfig.hccrConfig));
1ffe1728:	f104 013e 	add.w	r1, r4, #62	; 0x3e
1ffe172c:	2003      	movs	r0, #3
1ffe172e:	f7ff fe21 	bl	1ffe1374 <CLOCK_SYS_SetSystemClockConfig>
1ffe1732:	e00a      	b.n	1ffe174a <CLOCK_SYS_SetScgConfiguration+0x72>
            status = CLOCK_SYS_ConfigureModulesFromScg(scgConfig);
1ffe1734:	4620      	mov	r0, r4
1ffe1736:	f7ff ff31 	bl	1ffe159c <CLOCK_SYS_ConfigureModulesFromScg>
1ffe173a:	e7d3      	b.n	1ffe16e4 <CLOCK_SYS_SetScgConfiguration+0xc>
                    status = CLOCK_SYS_SetSystemClockConfig(SCG_SYSTEM_CLOCK_MODE_VLPR, &(scgConfig->clockModeConfig.vccrConfig));
1ffe173c:	f104 013a 	add.w	r1, r4, #58	; 0x3a
1ffe1740:	2002      	movs	r0, #2
1ffe1742:	f7ff fe17 	bl	1ffe1374 <CLOCK_SYS_SetSystemClockConfig>
1ffe1746:	e7ee      	b.n	1ffe1726 <CLOCK_SYS_SetScgConfiguration+0x4e>
    status_t status = STATUS_SUCCESS;
1ffe1748:	2000      	movs	r0, #0
}
1ffe174a:	bd10      	pop	{r4, pc}
1ffe174c:	20000680 	.word	0x20000680
1ffe1750:	40064000 	.word	0x40064000

1ffe1754 <CLOCK_SYS_GetSystemClockFreq>:
{
1ffe1754:	b510      	push	{r4, lr}
1ffe1756:	4604      	mov	r4, r0
    return ((base->CSR & SCG_CSR_SCS_MASK) >> SCG_CSR_SCS_SHIFT);
1ffe1758:	4b1b      	ldr	r3, [pc, #108]	; (1ffe17c8 <CLOCK_SYS_GetSystemClockFreq+0x74>)
1ffe175a:	691b      	ldr	r3, [r3, #16]
1ffe175c:	f3c3 6303 	ubfx	r3, r3, #24, #4
    switch (SCG_GetCurrentSystemClockSource(SCG))
1ffe1760:	3b01      	subs	r3, #1
1ffe1762:	2b05      	cmp	r3, #5
1ffe1764:	d810      	bhi.n	1ffe1788 <CLOCK_SYS_GetSystemClockFreq+0x34>
1ffe1766:	e8df f003 	tbb	[pc, r3]
1ffe176a:	0603      	.short	0x0603
1ffe176c:	0c0f0f09 	.word	0x0c0f0f09
            freq = CLOCK_SYS_GetSysOscFreq();
1ffe1770:	f7ff fbc2 	bl	1ffe0ef8 <CLOCK_SYS_GetSysOscFreq>
            break;
1ffe1774:	e009      	b.n	1ffe178a <CLOCK_SYS_GetSystemClockFreq+0x36>
            freq = CLOCK_SYS_GetSircFreq();
1ffe1776:	f7ff fc63 	bl	1ffe1040 <CLOCK_SYS_GetSircFreq>
            break;
1ffe177a:	e006      	b.n	1ffe178a <CLOCK_SYS_GetSystemClockFreq+0x36>
            freq = CLOCK_SYS_GetFircFreq();
1ffe177c:	f7ff fcd2 	bl	1ffe1124 <CLOCK_SYS_GetFircFreq>
            break;
1ffe1780:	e003      	b.n	1ffe178a <CLOCK_SYS_GetSystemClockFreq+0x36>
            freq = CLOCK_SYS_GetSysPllFreq();
1ffe1782:	f7ff fd35 	bl	1ffe11f0 <CLOCK_SYS_GetSysPllFreq>
            break;
1ffe1786:	e000      	b.n	1ffe178a <CLOCK_SYS_GetSystemClockFreq+0x36>
    switch (SCG_GetCurrentSystemClockSource(SCG))
1ffe1788:	2000      	movs	r0, #0
    return ((base->CSR & SCG_CSR_DIVCORE_MASK) >> SCG_CSR_DIVCORE_SHIFT);
1ffe178a:	4b0f      	ldr	r3, [pc, #60]	; (1ffe17c8 <CLOCK_SYS_GetSystemClockFreq+0x74>)
1ffe178c:	691b      	ldr	r3, [r3, #16]
1ffe178e:	f3c3 4303 	ubfx	r3, r3, #16, #4
    freq /= (SCG_GetCurrentCoreClockDividerRatio(SCG) + 1U);
1ffe1792:	3301      	adds	r3, #1
1ffe1794:	fbb0 f0f3 	udiv	r0, r0, r3
    switch (type)
1ffe1798:	2c01      	cmp	r4, #1
1ffe179a:	d004      	beq.n	1ffe17a6 <CLOCK_SYS_GetSystemClockFreq+0x52>
1ffe179c:	2c02      	cmp	r4, #2
1ffe179e:	d00a      	beq.n	1ffe17b6 <CLOCK_SYS_GetSystemClockFreq+0x62>
1ffe17a0:	b104      	cbz	r4, 1ffe17a4 <CLOCK_SYS_GetSystemClockFreq+0x50>
            freq = 0U;
1ffe17a2:	2000      	movs	r0, #0
}
1ffe17a4:	bd10      	pop	{r4, pc}
    return ((base->CSR & SCG_CSR_DIVBUS_MASK) >> SCG_CSR_DIVBUS_SHIFT);
1ffe17a6:	4b08      	ldr	r3, [pc, #32]	; (1ffe17c8 <CLOCK_SYS_GetSystemClockFreq+0x74>)
1ffe17a8:	691b      	ldr	r3, [r3, #16]
1ffe17aa:	f3c3 1303 	ubfx	r3, r3, #4, #4
            freq /= (SCG_GetCurrentBusClockDividerRatio(SCG) + 1U);
1ffe17ae:	3301      	adds	r3, #1
1ffe17b0:	fbb0 f0f3 	udiv	r0, r0, r3
            break;
1ffe17b4:	e7f6      	b.n	1ffe17a4 <CLOCK_SYS_GetSystemClockFreq+0x50>
    return ((base->CSR & SCG_CSR_DIVSLOW_MASK) >> SCG_CSR_DIVSLOW_SHIFT);
1ffe17b6:	4b04      	ldr	r3, [pc, #16]	; (1ffe17c8 <CLOCK_SYS_GetSystemClockFreq+0x74>)
1ffe17b8:	691b      	ldr	r3, [r3, #16]
1ffe17ba:	f003 030f 	and.w	r3, r3, #15
            freq /= (SCG_GetCurrentSlowClockDividerRatio(SCG) + 1U);
1ffe17be:	3301      	adds	r3, #1
1ffe17c0:	fbb0 f0f3 	udiv	r0, r0, r3
            break;
1ffe17c4:	e7ee      	b.n	1ffe17a4 <CLOCK_SYS_GetSystemClockFreq+0x50>
1ffe17c6:	bf00      	nop
1ffe17c8:	40064000 	.word	0x40064000

1ffe17cc <CLOCK_SYS_GetQspiIpgClk>:
{
1ffe17cc:	b508      	push	{r3, lr}
1ffe17ce:	4b0a      	ldr	r3, [pc, #40]	; (1ffe17f8 <CLOCK_SYS_GetQspiIpgClk+0x2c>)
1ffe17d0:	f8d3 31d8 	ldr.w	r3, [r3, #472]	; 0x1d8
   regValue = (regValue & PCC_PCCn_CGC_MASK) >> PCC_PCCn_CGC_SHIFT;
1ffe17d4:	f3c3 7080 	ubfx	r0, r3, #30, #1
    if (PCC_GetClockMode(PCC, QSPI0_CLK))
1ffe17d8:	f013 4f80 	tst.w	r3, #1073741824	; 0x40000000
1ffe17dc:	d007      	beq.n	1ffe17ee <CLOCK_SYS_GetQspiIpgClk+0x22>
    return (((baseAddr->MCR & QuadSPI_MCR_SCLKCFG_MASK) >> QuadSPI_MCR_SCLKCFG_SHIFT) & CLOCK_QSPI_MCR_SCLKCFG_CLK_MOD) != 0U;
1ffe17de:	4b07      	ldr	r3, [pc, #28]	; (1ffe17fc <CLOCK_SYS_GetQspiIpgClk+0x30>)
1ffe17e0:	681b      	ldr	r3, [r3, #0]
        if (QSPI_GetClockingModeSelection(QuadSPI))
1ffe17e2:	f013 4f80 	tst.w	r3, #1073741824	; 0x40000000
1ffe17e6:	d003      	beq.n	1ffe17f0 <CLOCK_SYS_GetQspiIpgClk+0x24>
            freq = CLOCK_SYS_GetSystemClockFreq(SCG_SYSTEM_CLOCK_BUS);
1ffe17e8:	2001      	movs	r0, #1
1ffe17ea:	f7ff ffb3 	bl	1ffe1754 <CLOCK_SYS_GetSystemClockFreq>
}
1ffe17ee:	bd08      	pop	{r3, pc}
            freq = CLOCK_SYS_GetSystemClockFreq(SCG_SYSTEM_CLOCK_CORE);
1ffe17f0:	2000      	movs	r0, #0
1ffe17f2:	f7ff ffaf 	bl	1ffe1754 <CLOCK_SYS_GetSystemClockFreq>
    return freq;
1ffe17f6:	e7fa      	b.n	1ffe17ee <CLOCK_SYS_GetQspiIpgClk+0x22>
1ffe17f8:	40065000 	.word	0x40065000
1ffe17fc:	40076000 	.word	0x40076000

1ffe1800 <CLOCK_SYS_GetScgClkOutFreq>:
{
1ffe1800:	b508      	push	{r3, lr}
    return (base->CLKOUTCNFG & SCG_CLKOUTCNFG_CLKOUTSEL_MASK) >> SCG_CLKOUTCNFG_CLKOUTSEL_SHIFT;
1ffe1802:	4b0f      	ldr	r3, [pc, #60]	; (1ffe1840 <CLOCK_SYS_GetScgClkOutFreq+0x40>)
1ffe1804:	6a1b      	ldr	r3, [r3, #32]
1ffe1806:	f3c3 6303 	ubfx	r3, r3, #24, #4
    switch (SCG_GetClockoutSourceSel(SCG))
1ffe180a:	2b06      	cmp	r3, #6
1ffe180c:	d815      	bhi.n	1ffe183a <CLOCK_SYS_GetScgClkOutFreq+0x3a>
1ffe180e:	e8df f003 	tbb	[pc, r3]
1ffe1812:	0804      	.short	0x0804
1ffe1814:	14140e0b 	.word	0x14140e0b
1ffe1818:	11          	.byte	0x11
1ffe1819:	00          	.byte	0x00
            frequency = CLOCK_SYS_GetSystemClockFreq(SCG_SYSTEM_CLOCK_SLOW);
1ffe181a:	2002      	movs	r0, #2
1ffe181c:	f7ff ff9a 	bl	1ffe1754 <CLOCK_SYS_GetSystemClockFreq>
}
1ffe1820:	bd08      	pop	{r3, pc}
            frequency = CLOCK_SYS_GetSysOscFreq();
1ffe1822:	f7ff fb69 	bl	1ffe0ef8 <CLOCK_SYS_GetSysOscFreq>
            break;
1ffe1826:	e7fb      	b.n	1ffe1820 <CLOCK_SYS_GetScgClkOutFreq+0x20>
            frequency = CLOCK_SYS_GetSircFreq();
1ffe1828:	f7ff fc0a 	bl	1ffe1040 <CLOCK_SYS_GetSircFreq>
            break;
1ffe182c:	e7f8      	b.n	1ffe1820 <CLOCK_SYS_GetScgClkOutFreq+0x20>
            frequency = CLOCK_SYS_GetFircFreq();
1ffe182e:	f7ff fc79 	bl	1ffe1124 <CLOCK_SYS_GetFircFreq>
            break;
1ffe1832:	e7f5      	b.n	1ffe1820 <CLOCK_SYS_GetScgClkOutFreq+0x20>
            frequency = CLOCK_SYS_GetSysPllFreq();
1ffe1834:	f7ff fcdc 	bl	1ffe11f0 <CLOCK_SYS_GetSysPllFreq>
            break;
1ffe1838:	e7f2      	b.n	1ffe1820 <CLOCK_SYS_GetScgClkOutFreq+0x20>
    switch (SCG_GetClockoutSourceSel(SCG))
1ffe183a:	2000      	movs	r0, #0
    return frequency;
1ffe183c:	e7f0      	b.n	1ffe1820 <CLOCK_SYS_GetScgClkOutFreq+0x20>
1ffe183e:	bf00      	nop
1ffe1840:	40064000 	.word	0x40064000

1ffe1844 <CLOCK_SYS_GetSysAsyncFreq>:
{
1ffe1844:	b508      	push	{r3, lr}
    switch (type)
1ffe1846:	b119      	cbz	r1, 1ffe1850 <CLOCK_SYS_GetSysAsyncFreq+0xc>
1ffe1848:	2901      	cmp	r1, #1
1ffe184a:	d031      	beq.n	1ffe18b0 <CLOCK_SYS_GetSysAsyncFreq+0x6c>
1ffe184c:	2000      	movs	r0, #0
}
1ffe184e:	bd08      	pop	{r3, pc}
            switch (clockSource)
1ffe1850:	3804      	subs	r0, #4
1ffe1852:	2803      	cmp	r0, #3
1ffe1854:	d857      	bhi.n	1ffe1906 <CLOCK_SYS_GetSysAsyncFreq+0xc2>
1ffe1856:	e8df f000 	tbb	[pc, r0]
1ffe185a:	0210      	.short	0x0210
1ffe185c:	2219      	.short	0x2219
                    freq = CLOCK_SYS_GetFircFreq();
1ffe185e:	f7ff fc61 	bl	1ffe1124 <CLOCK_SYS_GetFircFreq>
1ffe1862:	4602      	mov	r2, r0
    return (base->FIRCDIV & SCG_FIRCDIV_FIRCDIV1_MASK) >> SCG_FIRCDIV_FIRCDIV1_SHIFT;
1ffe1864:	4b2a      	ldr	r3, [pc, #168]	; (1ffe1910 <CLOCK_SYS_GetSysAsyncFreq+0xcc>)
1ffe1866:	f8d3 0304 	ldr.w	r0, [r3, #772]	; 0x304
1ffe186a:	f000 0007 	and.w	r0, r0, #7
    if (div != 0U)
1ffe186e:	2800      	cmp	r0, #0
1ffe1870:	d0ed      	beq.n	1ffe184e <CLOCK_SYS_GetSysAsyncFreq+0xa>
        freq = (freq >> (div - 1U));
1ffe1872:	1e43      	subs	r3, r0, #1
1ffe1874:	fa22 f003 	lsr.w	r0, r2, r3
1ffe1878:	e7e9      	b.n	1ffe184e <CLOCK_SYS_GetSysAsyncFreq+0xa>
                    freq = CLOCK_SYS_GetSircFreq();
1ffe187a:	f7ff fbe1 	bl	1ffe1040 <CLOCK_SYS_GetSircFreq>
1ffe187e:	4602      	mov	r2, r0
    return (base->SIRCDIV & SCG_SIRCDIV_SIRCDIV1_MASK) >> SCG_SIRCDIV_SIRCDIV1_SHIFT;
1ffe1880:	4b23      	ldr	r3, [pc, #140]	; (1ffe1910 <CLOCK_SYS_GetSysAsyncFreq+0xcc>)
1ffe1882:	f8d3 0204 	ldr.w	r0, [r3, #516]	; 0x204
1ffe1886:	f000 0007 	and.w	r0, r0, #7
                break;
1ffe188a:	e7f0      	b.n	1ffe186e <CLOCK_SYS_GetSysAsyncFreq+0x2a>
                    freq = CLOCK_SYS_GetSysOscFreq();
1ffe188c:	f7ff fb34 	bl	1ffe0ef8 <CLOCK_SYS_GetSysOscFreq>
1ffe1890:	4602      	mov	r2, r0
    return (base->SOSCDIV & SCG_SOSCDIV_SOSCDIV1_MASK) >> SCG_SOSCDIV_SOSCDIV1_SHIFT;
1ffe1892:	4b1f      	ldr	r3, [pc, #124]	; (1ffe1910 <CLOCK_SYS_GetSysAsyncFreq+0xcc>)
1ffe1894:	f8d3 0104 	ldr.w	r0, [r3, #260]	; 0x104
1ffe1898:	f000 0007 	and.w	r0, r0, #7
                break;
1ffe189c:	e7e7      	b.n	1ffe186e <CLOCK_SYS_GetSysAsyncFreq+0x2a>
                    freq = CLOCK_SYS_GetSysPllFreq();
1ffe189e:	f7ff fca7 	bl	1ffe11f0 <CLOCK_SYS_GetSysPllFreq>
1ffe18a2:	4602      	mov	r2, r0
    return (base->SPLLDIV & SCG_SPLLDIV_SPLLDIV1_MASK) >> SCG_SPLLDIV_SPLLDIV1_SHIFT;
1ffe18a4:	4b1a      	ldr	r3, [pc, #104]	; (1ffe1910 <CLOCK_SYS_GetSysAsyncFreq+0xcc>)
1ffe18a6:	f8d3 0604 	ldr.w	r0, [r3, #1540]	; 0x604
1ffe18aa:	f000 0007 	and.w	r0, r0, #7
                break;
1ffe18ae:	e7de      	b.n	1ffe186e <CLOCK_SYS_GetSysAsyncFreq+0x2a>
            switch (clockSource)
1ffe18b0:	3804      	subs	r0, #4
1ffe18b2:	2803      	cmp	r0, #3
1ffe18b4:	d829      	bhi.n	1ffe190a <CLOCK_SYS_GetSysAsyncFreq+0xc6>
1ffe18b6:	e8df f000 	tbb	[pc, r0]
1ffe18ba:	020b      	.short	0x020b
1ffe18bc:	1d14      	.short	0x1d14
                    freq = CLOCK_SYS_GetFircFreq();
1ffe18be:	f7ff fc31 	bl	1ffe1124 <CLOCK_SYS_GetFircFreq>
1ffe18c2:	4602      	mov	r2, r0
    return (base->FIRCDIV & SCG_FIRCDIV_FIRCDIV2_MASK) >> SCG_FIRCDIV_FIRCDIV2_SHIFT;
1ffe18c4:	4b12      	ldr	r3, [pc, #72]	; (1ffe1910 <CLOCK_SYS_GetSysAsyncFreq+0xcc>)
1ffe18c6:	f8d3 0304 	ldr.w	r0, [r3, #772]	; 0x304
1ffe18ca:	f3c0 2002 	ubfx	r0, r0, #8, #3
                break;
1ffe18ce:	e7ce      	b.n	1ffe186e <CLOCK_SYS_GetSysAsyncFreq+0x2a>
                    freq = CLOCK_SYS_GetSircFreq();
1ffe18d0:	f7ff fbb6 	bl	1ffe1040 <CLOCK_SYS_GetSircFreq>
1ffe18d4:	4602      	mov	r2, r0
    return (base->SIRCDIV & SCG_SIRCDIV_SIRCDIV2_MASK) >> SCG_SIRCDIV_SIRCDIV2_SHIFT;
1ffe18d6:	4b0e      	ldr	r3, [pc, #56]	; (1ffe1910 <CLOCK_SYS_GetSysAsyncFreq+0xcc>)
1ffe18d8:	f8d3 0204 	ldr.w	r0, [r3, #516]	; 0x204
1ffe18dc:	f3c0 2002 	ubfx	r0, r0, #8, #3
                break;
1ffe18e0:	e7c5      	b.n	1ffe186e <CLOCK_SYS_GetSysAsyncFreq+0x2a>
                    freq = CLOCK_SYS_GetSysOscFreq();
1ffe18e2:	f7ff fb09 	bl	1ffe0ef8 <CLOCK_SYS_GetSysOscFreq>
1ffe18e6:	4602      	mov	r2, r0
    return (base->SOSCDIV & SCG_SOSCDIV_SOSCDIV2_MASK) >> SCG_SOSCDIV_SOSCDIV2_SHIFT;
1ffe18e8:	4b09      	ldr	r3, [pc, #36]	; (1ffe1910 <CLOCK_SYS_GetSysAsyncFreq+0xcc>)
1ffe18ea:	f8d3 0104 	ldr.w	r0, [r3, #260]	; 0x104
1ffe18ee:	f3c0 2002 	ubfx	r0, r0, #8, #3
                break;
1ffe18f2:	e7bc      	b.n	1ffe186e <CLOCK_SYS_GetSysAsyncFreq+0x2a>
                    freq = CLOCK_SYS_GetSysPllFreq();
1ffe18f4:	f7ff fc7c 	bl	1ffe11f0 <CLOCK_SYS_GetSysPllFreq>
1ffe18f8:	4602      	mov	r2, r0
    return (base->SPLLDIV & SCG_SPLLDIV_SPLLDIV2_MASK) >> SCG_SPLLDIV_SPLLDIV2_SHIFT;
1ffe18fa:	4b05      	ldr	r3, [pc, #20]	; (1ffe1910 <CLOCK_SYS_GetSysAsyncFreq+0xcc>)
1ffe18fc:	f8d3 0604 	ldr.w	r0, [r3, #1540]	; 0x604
1ffe1900:	f3c0 2002 	ubfx	r0, r0, #8, #3
                break;
1ffe1904:	e7b3      	b.n	1ffe186e <CLOCK_SYS_GetSysAsyncFreq+0x2a>
1ffe1906:	2000      	movs	r0, #0
1ffe1908:	e7a1      	b.n	1ffe184e <CLOCK_SYS_GetSysAsyncFreq+0xa>
1ffe190a:	2000      	movs	r0, #0
    return freq;
1ffe190c:	e79f      	b.n	1ffe184e <CLOCK_SYS_GetSysAsyncFreq+0xa>
1ffe190e:	bf00      	nop
1ffe1910:	40064000 	.word	0x40064000

1ffe1914 <CLOCK_SYS_GetSimRtcClkFreq>:
{
1ffe1914:	b508      	push	{r3, lr}
    return ((base->LPOCLKS & SIM_LPOCLKS_RTCCLKSEL_MASK) >> SIM_LPOCLKS_RTCCLKSEL_SHIFT);
1ffe1916:	4b10      	ldr	r3, [pc, #64]	; (1ffe1958 <CLOCK_SYS_GetSimRtcClkFreq+0x44>)
1ffe1918:	691b      	ldr	r3, [r3, #16]
1ffe191a:	f3c3 1301 	ubfx	r3, r3, #4, #2
    switch (SIM_GetRtcClkSrc(SIM))
1ffe191e:	2b03      	cmp	r3, #3
1ffe1920:	d818      	bhi.n	1ffe1954 <CLOCK_SYS_GetSimRtcClkFreq+0x40>
1ffe1922:	e8df f003 	tbb	[pc, r3]
1ffe1926:	0702      	.short	0x0702
1ffe1928:	120f      	.short	0x120f
            frequency = CLOCK_SYS_GetSysAsyncFreq(SOSC_CLK, SCG_ASYNC_CLOCK_DIV1);
1ffe192a:	2100      	movs	r1, #0
1ffe192c:	2006      	movs	r0, #6
1ffe192e:	f7ff ff89 	bl	1ffe1844 <CLOCK_SYS_GetSysAsyncFreq>
}
1ffe1932:	bd08      	pop	{r3, pc}
    return (((base->LPOCLKS & SIM_LPOCLKS_LPO32KCLKEN_MASK) >> SIM_LPOCLKS_LPO32KCLKEN_SHIFT) != 0U) ? true : false;
1ffe1934:	4b08      	ldr	r3, [pc, #32]	; (1ffe1958 <CLOCK_SYS_GetSimRtcClkFreq+0x44>)
1ffe1936:	6918      	ldr	r0, [r3, #16]
            frequency = SIM_GetLpo32KStatus(SIM) ? LPO_32K_FREQUENCY : 0UL;
1ffe1938:	f010 0002 	ands.w	r0, r0, #2
1ffe193c:	d0f9      	beq.n	1ffe1932 <CLOCK_SYS_GetSimRtcClkFreq+0x1e>
1ffe193e:	f44f 40fa 	mov.w	r0, #32000	; 0x7d00
1ffe1942:	e7f6      	b.n	1ffe1932 <CLOCK_SYS_GetSimRtcClkFreq+0x1e>
            frequency = g_RtcClkInFreq;
1ffe1944:	4b05      	ldr	r3, [pc, #20]	; (1ffe195c <CLOCK_SYS_GetSimRtcClkFreq+0x48>)
1ffe1946:	6818      	ldr	r0, [r3, #0]
            break;
1ffe1948:	e7f3      	b.n	1ffe1932 <CLOCK_SYS_GetSimRtcClkFreq+0x1e>
            frequency = CLOCK_SYS_GetSysAsyncFreq(FIRC_CLK, SCG_ASYNC_CLOCK_DIV1);
1ffe194a:	2100      	movs	r1, #0
1ffe194c:	2005      	movs	r0, #5
1ffe194e:	f7ff ff79 	bl	1ffe1844 <CLOCK_SYS_GetSysAsyncFreq>
            break;
1ffe1952:	e7ee      	b.n	1ffe1932 <CLOCK_SYS_GetSimRtcClkFreq+0x1e>
    switch (SIM_GetRtcClkSrc(SIM))
1ffe1954:	2000      	movs	r0, #0
    return frequency;
1ffe1956:	e7ec      	b.n	1ffe1932 <CLOCK_SYS_GetSimRtcClkFreq+0x1e>
1ffe1958:	40048000 	.word	0x40048000
1ffe195c:	20000680 	.word	0x20000680

1ffe1960 <CLOCK_SYS_GetQSPIInternalReferenceClock>:
{
1ffe1960:	b508      	push	{r3, lr}
    return ((baseAddr->MISCTRL0 & SIM_MISCTRL0_QSPI_CLK_SEL_MASK) >> SIM_MISCTRL0_QSPI_CLK_SEL_SHIFT) != 0U;
1ffe1962:	4b0d      	ldr	r3, [pc, #52]	; (1ffe1998 <CLOCK_SYS_GetQSPIInternalReferenceClock+0x38>)
1ffe1964:	6a18      	ldr	r0, [r3, #32]
    if (SIM_GetClockingModeSelection(SIM))
1ffe1966:	f010 6080 	ands.w	r0, r0, #67108864	; 0x4000000
1ffe196a:	d00e      	beq.n	1ffe198a <CLOCK_SYS_GetQSPIInternalReferenceClock+0x2a>
    return (((baseAddr->MCR & QuadSPI_MCR_SCLKCFG_MASK) >> QuadSPI_MCR_SCLKCFG_SHIFT) & CLOCK_QSPI_MCR_SCLKCFG_CLK_SRC) != 0U;
1ffe196c:	f503 3338 	add.w	r3, r3, #188416	; 0x2e000
1ffe1970:	681b      	ldr	r3, [r3, #0]
        if (QSPI_GetClockingSourceSelection(QuadSPI))
1ffe1972:	f013 5f80 	tst.w	r3, #268435456	; 0x10000000
1ffe1976:	d009      	beq.n	1ffe198c <CLOCK_SYS_GetQSPIInternalReferenceClock+0x2c>
            freq = CLOCK_SYS_GetSysAsyncFreq(FIRC_CLK, SCG_ASYNC_CLOCK_DIV1);
1ffe1978:	2100      	movs	r1, #0
1ffe197a:	2005      	movs	r0, #5
1ffe197c:	f7ff ff62 	bl	1ffe1844 <CLOCK_SYS_GetSysAsyncFreq>
    return (baseAddr->SOCCR & QuadSPI_SOCCR_SOCCFG_MASK) >> QuadSPI_SOCCR_SOCCFG_SHIFT;
1ffe1980:	4b06      	ldr	r3, [pc, #24]	; (1ffe199c <CLOCK_SYS_GetQSPIInternalReferenceClock+0x3c>)
1ffe1982:	6a5b      	ldr	r3, [r3, #36]	; 0x24
        freq /= (divValue + 1U);
1ffe1984:	3301      	adds	r3, #1
1ffe1986:	fbb0 f0f3 	udiv	r0, r0, r3
}
1ffe198a:	bd08      	pop	{r3, pc}
            freq = CLOCK_SYS_GetSysAsyncFreq(SPLL_CLK, SCG_ASYNC_CLOCK_DIV1);
1ffe198c:	2100      	movs	r1, #0
1ffe198e:	2007      	movs	r0, #7
1ffe1990:	f7ff ff58 	bl	1ffe1844 <CLOCK_SYS_GetSysAsyncFreq>
1ffe1994:	e7f4      	b.n	1ffe1980 <CLOCK_SYS_GetQSPIInternalReferenceClock+0x20>
1ffe1996:	bf00      	nop
1ffe1998:	40048000 	.word	0x40048000
1ffe199c:	40076000 	.word	0x40076000

1ffe19a0 <CLOCK_SYS_GetQspiSfifClkHyp>:
{
1ffe19a0:	b508      	push	{r3, lr}
    freq = CLOCK_SYS_GetQSPIInternalReferenceClock();
1ffe19a2:	f7ff ffdd 	bl	1ffe1960 <CLOCK_SYS_GetQSPIInternalReferenceClock>
}
1ffe19a6:	0840      	lsrs	r0, r0, #1
1ffe19a8:	bd08      	pop	{r3, pc}
	...

1ffe19ac <CLOCK_SYS_GetQspiIpgClkSfif>:
{
1ffe19ac:	b508      	push	{r3, lr}
    freq = CLOCK_SYS_GetQSPIInternalReferenceClock();
1ffe19ae:	f7ff ffd7 	bl	1ffe1960 <CLOCK_SYS_GetQSPIInternalReferenceClock>
    return (((baseAddr->MCR & QuadSPI_MCR_SCLKCFG_MASK) >> QuadSPI_MCR_SCLKCFG_SHIFT) & CLOCK_QSPI_MCR_SCLKCFG_EXT_DQS) != 0U;
1ffe19b2:	4b03      	ldr	r3, [pc, #12]	; (1ffe19c0 <CLOCK_SYS_GetQspiIpgClkSfif+0x14>)
1ffe19b4:	681b      	ldr	r3, [r3, #0]
    if (QSPI_GetClockingHyperRamMode(QuadSPI))
1ffe19b6:	f013 5f00 	tst.w	r3, #536870912	; 0x20000000
1ffe19ba:	d000      	beq.n	1ffe19be <CLOCK_SYS_GetQspiIpgClkSfif+0x12>
        freq >>= 1U;
1ffe19bc:	0840      	lsrs	r0, r0, #1
}
1ffe19be:	bd08      	pop	{r3, pc}
1ffe19c0:	40076000 	.word	0x40076000

1ffe19c4 <CLOCK_SYS_GetQspiIpgClk2Xsfif>:
{
1ffe19c4:	b508      	push	{r3, lr}
1ffe19c6:	4b04      	ldr	r3, [pc, #16]	; (1ffe19d8 <CLOCK_SYS_GetQspiIpgClk2Xsfif+0x14>)
1ffe19c8:	6818      	ldr	r0, [r3, #0]
    if (QSPI_GetClockingHyperRamMode(QuadSPI))
1ffe19ca:	f010 5000 	ands.w	r0, r0, #536870912	; 0x20000000
1ffe19ce:	d100      	bne.n	1ffe19d2 <CLOCK_SYS_GetQspiIpgClk2Xsfif+0xe>
}
1ffe19d0:	bd08      	pop	{r3, pc}
        freq = CLOCK_SYS_GetQSPIInternalReferenceClock();
1ffe19d2:	f7ff ffc5 	bl	1ffe1960 <CLOCK_SYS_GetQSPIInternalReferenceClock>
    return freq;
1ffe19d6:	e7fb      	b.n	1ffe19d0 <CLOCK_SYS_GetQspiIpgClk2Xsfif+0xc>
1ffe19d8:	40076000 	.word	0x40076000

1ffe19dc <CLOCK_SYS_GetLpoFreq>:
    return ((base->LPOCLKS & SIM_LPOCLKS_LPOCLKSEL_MASK) >> SIM_LPOCLKS_LPOCLKSEL_SHIFT);
1ffe19dc:	4b10      	ldr	r3, [pc, #64]	; (1ffe1a20 <CLOCK_SYS_GetLpoFreq+0x44>)
1ffe19de:	691b      	ldr	r3, [r3, #16]
1ffe19e0:	f3c3 0381 	ubfx	r3, r3, #2, #2
 * END**************************************************************************/
static uint32_t CLOCK_SYS_GetLpoFreq(void)
{
    uint32_t freq = 0U;

    switch (SIM_GetLpoClkSelectorValue(SIM))
1ffe19e4:	2b02      	cmp	r3, #2
1ffe19e6:	d007      	beq.n	1ffe19f8 <CLOCK_SYS_GetLpoFreq+0x1c>
1ffe19e8:	2b03      	cmp	r3, #3
1ffe19ea:	d00d      	beq.n	1ffe1a08 <CLOCK_SYS_GetLpoFreq+0x2c>
1ffe19ec:	b10b      	cbz	r3, 1ffe19f2 <CLOCK_SYS_GetLpoFreq+0x16>
1ffe19ee:	2000      	movs	r0, #0
            DEV_ASSERT(false);
            break;
    }

    return freq;
}
1ffe19f0:	4770      	bx	lr
            freq = LPO_128K_FREQUENCY;
1ffe19f2:	f44f 30fa 	mov.w	r0, #128000	; 0x1f400
1ffe19f6:	4770      	bx	lr
    return (((base->LPOCLKS & SIM_LPOCLKS_LPO32KCLKEN_MASK) >> SIM_LPOCLKS_LPO32KCLKEN_SHIFT) != 0U) ? true : false;
1ffe19f8:	4b09      	ldr	r3, [pc, #36]	; (1ffe1a20 <CLOCK_SYS_GetLpoFreq+0x44>)
1ffe19fa:	6918      	ldr	r0, [r3, #16]
            freq = SIM_GetLpo32KStatus(SIM) ? LPO_32K_FREQUENCY : 0UL;
1ffe19fc:	f010 0002 	ands.w	r0, r0, #2
1ffe1a00:	d0f6      	beq.n	1ffe19f0 <CLOCK_SYS_GetLpoFreq+0x14>
1ffe1a02:	f44f 40fa 	mov.w	r0, #32000	; 0x7d00
1ffe1a06:	4770      	bx	lr
1ffe1a08:	4b05      	ldr	r3, [pc, #20]	; (1ffe1a20 <CLOCK_SYS_GetLpoFreq+0x44>)
1ffe1a0a:	6918      	ldr	r0, [r3, #16]
            freq = ((SIM_GetLpo32KStatus(SIM)) && (SIM_GetLpo1KStatus(SIM))) ? LPO_1K_FREQUENCY : 0UL;
1ffe1a0c:	f010 0002 	ands.w	r0, r0, #2
1ffe1a10:	d0ee      	beq.n	1ffe19f0 <CLOCK_SYS_GetLpoFreq+0x14>
    return (((base->LPOCLKS & SIM_LPOCLKS_LPO1KCLKEN_MASK) >> SIM_LPOCLKS_LPO1KCLKEN_SHIFT) != 0U) ? true : false;
1ffe1a12:	6918      	ldr	r0, [r3, #16]
1ffe1a14:	f010 0001 	ands.w	r0, r0, #1
1ffe1a18:	d0ea      	beq.n	1ffe19f0 <CLOCK_SYS_GetLpoFreq+0x14>
1ffe1a1a:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
1ffe1a1e:	4770      	bx	lr
1ffe1a20:	40048000 	.word	0x40048000

1ffe1a24 <CLOCK_SYS_GetSimClkOutFreq>:
{
1ffe1a24:	b508      	push	{r3, lr}
    return (((base->CHIPCTL & SIM_CHIPCTL_CLKOUTEN_MASK) >> SIM_CHIPCTL_CLKOUTEN_SHIFT) == 0U) ? false : true;
1ffe1a26:	4b28      	ldr	r3, [pc, #160]	; (1ffe1ac8 <CLOCK_SYS_GetSimClkOutFreq+0xa4>)
1ffe1a28:	6858      	ldr	r0, [r3, #4]
    if (SIM_GetClockoutStatus(SIM))
1ffe1a2a:	f410 6000 	ands.w	r0, r0, #2048	; 0x800
1ffe1a2e:	d01a      	beq.n	1ffe1a66 <CLOCK_SYS_GetSimClkOutFreq+0x42>
    return ((base->CHIPCTL & SIM_CHIPCTL_CLKOUTSEL_MASK) >> SIM_CHIPCTL_CLKOUTSEL_SHIFT);
1ffe1a30:	685b      	ldr	r3, [r3, #4]
1ffe1a32:	f3c3 1303 	ubfx	r3, r3, #4, #4
        switch (SIM_GetClockoutSelectorValue(SIM))
1ffe1a36:	2b0f      	cmp	r3, #15
1ffe1a38:	d844      	bhi.n	1ffe1ac4 <CLOCK_SYS_GetSimClkOutFreq+0xa0>
1ffe1a3a:	e8df f003 	tbb	[pc, r3]
1ffe1a3e:	430b      	.short	0x430b
1ffe1a40:	371a4315 	.word	0x371a4315
1ffe1a44:	2d28241f 	.word	0x2d28241f
1ffe1a48:	3d313a08 	.word	0x3d313a08
1ffe1a4c:	4034      	.short	0x4034
1ffe1a4e:	f44f 30fa 	mov.w	r0, #128000	; 0x1f400
1ffe1a52:	e001      	b.n	1ffe1a58 <CLOCK_SYS_GetSimClkOutFreq+0x34>
                frequency = CLOCK_SYS_GetScgClkOutFreq();
1ffe1a54:	f7ff fed4 	bl	1ffe1800 <CLOCK_SYS_GetScgClkOutFreq>
    return ((base->CHIPCTL & SIM_CHIPCTL_CLKOUTDIV_MASK) >> SIM_CHIPCTL_CLKOUTDIV_SHIFT);
1ffe1a58:	4b1b      	ldr	r3, [pc, #108]	; (1ffe1ac8 <CLOCK_SYS_GetSimClkOutFreq+0xa4>)
1ffe1a5a:	685b      	ldr	r3, [r3, #4]
1ffe1a5c:	f3c3 2302 	ubfx	r3, r3, #8, #3
        frequency /= (SIM_GetClockoutDividerValue(SIM) + 1U);
1ffe1a60:	3301      	adds	r3, #1
1ffe1a62:	fbb0 f0f3 	udiv	r0, r0, r3
}
1ffe1a66:	bd08      	pop	{r3, pc}
                frequency = CLOCK_SYS_GetSysAsyncFreq(SOSC_CLK, SCG_ASYNC_CLOCK_DIV2);
1ffe1a68:	2101      	movs	r1, #1
1ffe1a6a:	2006      	movs	r0, #6
1ffe1a6c:	f7ff feea 	bl	1ffe1844 <CLOCK_SYS_GetSysAsyncFreq>
                break;
1ffe1a70:	e7f2      	b.n	1ffe1a58 <CLOCK_SYS_GetSimClkOutFreq+0x34>
                frequency = CLOCK_SYS_GetSysAsyncFreq(SIRC_CLK, SCG_ASYNC_CLOCK_DIV2);
1ffe1a72:	2101      	movs	r1, #1
1ffe1a74:	2004      	movs	r0, #4
1ffe1a76:	f7ff fee5 	bl	1ffe1844 <CLOCK_SYS_GetSysAsyncFreq>
                break;
1ffe1a7a:	e7ed      	b.n	1ffe1a58 <CLOCK_SYS_GetSimClkOutFreq+0x34>
                frequency = CLOCK_SYS_GetSysAsyncFreq(FIRC_CLK, SCG_ASYNC_CLOCK_DIV2);
1ffe1a7c:	2101      	movs	r1, #1
1ffe1a7e:	2005      	movs	r0, #5
1ffe1a80:	f7ff fee0 	bl	1ffe1844 <CLOCK_SYS_GetSysAsyncFreq>
                break;
1ffe1a84:	e7e8      	b.n	1ffe1a58 <CLOCK_SYS_GetSimClkOutFreq+0x34>
                frequency = CLOCK_SYS_GetSystemClockFreq(SCG_SYSTEM_CLOCK_CORE);
1ffe1a86:	2000      	movs	r0, #0
1ffe1a88:	f7ff fe64 	bl	1ffe1754 <CLOCK_SYS_GetSystemClockFreq>
                break;
1ffe1a8c:	e7e4      	b.n	1ffe1a58 <CLOCK_SYS_GetSimClkOutFreq+0x34>
                frequency = CLOCK_SYS_GetSysAsyncFreq(SPLL_CLK, SCG_ASYNC_CLOCK_DIV2);
1ffe1a8e:	2101      	movs	r1, #1
1ffe1a90:	2007      	movs	r0, #7
1ffe1a92:	f7ff fed7 	bl	1ffe1844 <CLOCK_SYS_GetSysAsyncFreq>
                break;
1ffe1a96:	e7df      	b.n	1ffe1a58 <CLOCK_SYS_GetSimClkOutFreq+0x34>
                frequency = CLOCK_SYS_GetSystemClockFreq(SCG_SYSTEM_CLOCK_BUS);
1ffe1a98:	2001      	movs	r0, #1
1ffe1a9a:	f7ff fe5b 	bl	1ffe1754 <CLOCK_SYS_GetSystemClockFreq>
                break;
1ffe1a9e:	e7db      	b.n	1ffe1a58 <CLOCK_SYS_GetSimClkOutFreq+0x34>
                frequency = CLOCK_SYS_GetLpoFreq();
1ffe1aa0:	f7ff ff9c 	bl	1ffe19dc <CLOCK_SYS_GetLpoFreq>
                break;
1ffe1aa4:	e7d8      	b.n	1ffe1a58 <CLOCK_SYS_GetSimClkOutFreq+0x34>
                frequency = CLOCK_SYS_GetSimRtcClkFreq();
1ffe1aa6:	f7ff ff35 	bl	1ffe1914 <CLOCK_SYS_GetSimRtcClkFreq>
                break;
1ffe1aaa:	e7d5      	b.n	1ffe1a58 <CLOCK_SYS_GetSimClkOutFreq+0x34>
                frequency = CLOCK_SYS_GetQspiSfifClkHyp();
1ffe1aac:	f7ff ff78 	bl	1ffe19a0 <CLOCK_SYS_GetQspiSfifClkHyp>
                break;
1ffe1ab0:	e7d2      	b.n	1ffe1a58 <CLOCK_SYS_GetSimClkOutFreq+0x34>
                frequency = CLOCK_SYS_GetQspiIpgClk();
1ffe1ab2:	f7ff fe8b 	bl	1ffe17cc <CLOCK_SYS_GetQspiIpgClk>
                break;
1ffe1ab6:	e7cf      	b.n	1ffe1a58 <CLOCK_SYS_GetSimClkOutFreq+0x34>
                frequency = CLOCK_SYS_GetQspiIpgClkSfif();
1ffe1ab8:	f7ff ff78 	bl	1ffe19ac <CLOCK_SYS_GetQspiIpgClkSfif>
                break;
1ffe1abc:	e7cc      	b.n	1ffe1a58 <CLOCK_SYS_GetSimClkOutFreq+0x34>
                frequency = CLOCK_SYS_GetQspiIpgClk2Xsfif();
1ffe1abe:	f7ff ff81 	bl	1ffe19c4 <CLOCK_SYS_GetQspiIpgClk2Xsfif>
                break;
1ffe1ac2:	e7c9      	b.n	1ffe1a58 <CLOCK_SYS_GetSimClkOutFreq+0x34>
                frequency = 0U;
1ffe1ac4:	2000      	movs	r0, #0
1ffe1ac6:	e7c7      	b.n	1ffe1a58 <CLOCK_SYS_GetSimClkOutFreq+0x34>
1ffe1ac8:	40048000 	.word	0x40048000

1ffe1acc <CLOCK_SYS_GetScgClockFreq>:
{
1ffe1acc:	b510      	push	{r4, lr}
1ffe1ace:	460c      	mov	r4, r1
    switch (clockName)
1ffe1ad0:	2811      	cmp	r0, #17
1ffe1ad2:	d878      	bhi.n	1ffe1bc6 <CLOCK_SYS_GetScgClockFreq+0xfa>
1ffe1ad4:	e8df f000 	tbb	[pc, r0]
1ffe1ad8:	1d171109 	.word	0x1d171109
1ffe1adc:	312c2722 	.word	0x312c2722
1ffe1ae0:	463f3a36 	.word	0x463f3a36
1ffe1ae4:	625b544d 	.word	0x625b544d
1ffe1ae8:	7069      	.short	0x7069
            freq = CLOCK_SYS_GetSystemClockFreq(SCG_SYSTEM_CLOCK_CORE);
1ffe1aea:	2000      	movs	r0, #0
1ffe1aec:	f7ff fe32 	bl	1ffe1754 <CLOCK_SYS_GetSystemClockFreq>
1ffe1af0:	4603      	mov	r3, r0
    status_t returnCode = STATUS_SUCCESS;
1ffe1af2:	2000      	movs	r0, #0
    if (frequency != NULL)
1ffe1af4:	b104      	cbz	r4, 1ffe1af8 <CLOCK_SYS_GetScgClockFreq+0x2c>
        *frequency = freq;
1ffe1af6:	6023      	str	r3, [r4, #0]
}
1ffe1af8:	bd10      	pop	{r4, pc}
            freq = CLOCK_SYS_GetSystemClockFreq(SCG_SYSTEM_CLOCK_BUS);
1ffe1afa:	2001      	movs	r0, #1
1ffe1afc:	f7ff fe2a 	bl	1ffe1754 <CLOCK_SYS_GetSystemClockFreq>
1ffe1b00:	4603      	mov	r3, r0
    status_t returnCode = STATUS_SUCCESS;
1ffe1b02:	2000      	movs	r0, #0
            break;
1ffe1b04:	e7f6      	b.n	1ffe1af4 <CLOCK_SYS_GetScgClockFreq+0x28>
            freq = CLOCK_SYS_GetSystemClockFreq(SCG_SYSTEM_CLOCK_SLOW);
1ffe1b06:	2002      	movs	r0, #2
1ffe1b08:	f7ff fe24 	bl	1ffe1754 <CLOCK_SYS_GetSystemClockFreq>
1ffe1b0c:	4603      	mov	r3, r0
    status_t returnCode = STATUS_SUCCESS;
1ffe1b0e:	2000      	movs	r0, #0
            break;
1ffe1b10:	e7f0      	b.n	1ffe1af4 <CLOCK_SYS_GetScgClockFreq+0x28>
            freq = CLOCK_SYS_GetSimClkOutFreq();
1ffe1b12:	f7ff ff87 	bl	1ffe1a24 <CLOCK_SYS_GetSimClkOutFreq>
1ffe1b16:	4603      	mov	r3, r0
    status_t returnCode = STATUS_SUCCESS;
1ffe1b18:	2000      	movs	r0, #0
            break;
1ffe1b1a:	e7eb      	b.n	1ffe1af4 <CLOCK_SYS_GetScgClockFreq+0x28>
            freq = CLOCK_SYS_GetSircFreq();
1ffe1b1c:	f7ff fa90 	bl	1ffe1040 <CLOCK_SYS_GetSircFreq>
1ffe1b20:	4603      	mov	r3, r0
    status_t returnCode = STATUS_SUCCESS;
1ffe1b22:	2000      	movs	r0, #0
            break;
1ffe1b24:	e7e6      	b.n	1ffe1af4 <CLOCK_SYS_GetScgClockFreq+0x28>
            freq = CLOCK_SYS_GetFircFreq();
1ffe1b26:	f7ff fafd 	bl	1ffe1124 <CLOCK_SYS_GetFircFreq>
1ffe1b2a:	4603      	mov	r3, r0
    status_t returnCode = STATUS_SUCCESS;
1ffe1b2c:	2000      	movs	r0, #0
            break;
1ffe1b2e:	e7e1      	b.n	1ffe1af4 <CLOCK_SYS_GetScgClockFreq+0x28>
            freq = CLOCK_SYS_GetSysOscFreq();
1ffe1b30:	f7ff f9e2 	bl	1ffe0ef8 <CLOCK_SYS_GetSysOscFreq>
1ffe1b34:	4603      	mov	r3, r0
    status_t returnCode = STATUS_SUCCESS;
1ffe1b36:	2000      	movs	r0, #0
            break;
1ffe1b38:	e7dc      	b.n	1ffe1af4 <CLOCK_SYS_GetScgClockFreq+0x28>
            freq = CLOCK_SYS_GetSysPllFreq();
1ffe1b3a:	f7ff fb59 	bl	1ffe11f0 <CLOCK_SYS_GetSysPllFreq>
1ffe1b3e:	4603      	mov	r3, r0
    status_t returnCode = STATUS_SUCCESS;
1ffe1b40:	2000      	movs	r0, #0
            break;
1ffe1b42:	e7d7      	b.n	1ffe1af4 <CLOCK_SYS_GetScgClockFreq+0x28>
            freq = g_RtcClkInFreq;
1ffe1b44:	4b21      	ldr	r3, [pc, #132]	; (1ffe1bcc <CLOCK_SYS_GetScgClockFreq+0x100>)
1ffe1b46:	681b      	ldr	r3, [r3, #0]
    status_t returnCode = STATUS_SUCCESS;
1ffe1b48:	2000      	movs	r0, #0
            break;
1ffe1b4a:	e7d3      	b.n	1ffe1af4 <CLOCK_SYS_GetScgClockFreq+0x28>
            freq = CLOCK_SYS_GetScgClkOutFreq();
1ffe1b4c:	f7ff fe58 	bl	1ffe1800 <CLOCK_SYS_GetScgClkOutFreq>
1ffe1b50:	4603      	mov	r3, r0
    status_t returnCode = STATUS_SUCCESS;
1ffe1b52:	2000      	movs	r0, #0
            break;
1ffe1b54:	e7ce      	b.n	1ffe1af4 <CLOCK_SYS_GetScgClockFreq+0x28>
            freq = CLOCK_SYS_GetSysAsyncFreq(SIRC_CLK, SCG_ASYNC_CLOCK_DIV1);
1ffe1b56:	2100      	movs	r1, #0
1ffe1b58:	2004      	movs	r0, #4
1ffe1b5a:	f7ff fe73 	bl	1ffe1844 <CLOCK_SYS_GetSysAsyncFreq>
1ffe1b5e:	4603      	mov	r3, r0
    status_t returnCode = STATUS_SUCCESS;
1ffe1b60:	2000      	movs	r0, #0
            break;
1ffe1b62:	e7c7      	b.n	1ffe1af4 <CLOCK_SYS_GetScgClockFreq+0x28>
            freq = CLOCK_SYS_GetSysAsyncFreq(SIRC_CLK, SCG_ASYNC_CLOCK_DIV2);
1ffe1b64:	2101      	movs	r1, #1
1ffe1b66:	2004      	movs	r0, #4
1ffe1b68:	f7ff fe6c 	bl	1ffe1844 <CLOCK_SYS_GetSysAsyncFreq>
1ffe1b6c:	4603      	mov	r3, r0
    status_t returnCode = STATUS_SUCCESS;
1ffe1b6e:	2000      	movs	r0, #0
            break;
1ffe1b70:	e7c0      	b.n	1ffe1af4 <CLOCK_SYS_GetScgClockFreq+0x28>
            freq = CLOCK_SYS_GetSysAsyncFreq(FIRC_CLK, SCG_ASYNC_CLOCK_DIV1);
1ffe1b72:	2100      	movs	r1, #0
1ffe1b74:	2005      	movs	r0, #5
1ffe1b76:	f7ff fe65 	bl	1ffe1844 <CLOCK_SYS_GetSysAsyncFreq>
1ffe1b7a:	4603      	mov	r3, r0
    status_t returnCode = STATUS_SUCCESS;
1ffe1b7c:	2000      	movs	r0, #0
            break;
1ffe1b7e:	e7b9      	b.n	1ffe1af4 <CLOCK_SYS_GetScgClockFreq+0x28>
            freq = CLOCK_SYS_GetSysAsyncFreq(FIRC_CLK, SCG_ASYNC_CLOCK_DIV2);
1ffe1b80:	2101      	movs	r1, #1
1ffe1b82:	2005      	movs	r0, #5
1ffe1b84:	f7ff fe5e 	bl	1ffe1844 <CLOCK_SYS_GetSysAsyncFreq>
1ffe1b88:	4603      	mov	r3, r0
    status_t returnCode = STATUS_SUCCESS;
1ffe1b8a:	2000      	movs	r0, #0
            break;
1ffe1b8c:	e7b2      	b.n	1ffe1af4 <CLOCK_SYS_GetScgClockFreq+0x28>
            freq = CLOCK_SYS_GetSysAsyncFreq(SOSC_CLK, SCG_ASYNC_CLOCK_DIV1);
1ffe1b8e:	2100      	movs	r1, #0
1ffe1b90:	2006      	movs	r0, #6
1ffe1b92:	f7ff fe57 	bl	1ffe1844 <CLOCK_SYS_GetSysAsyncFreq>
1ffe1b96:	4603      	mov	r3, r0
    status_t returnCode = STATUS_SUCCESS;
1ffe1b98:	2000      	movs	r0, #0
            break;
1ffe1b9a:	e7ab      	b.n	1ffe1af4 <CLOCK_SYS_GetScgClockFreq+0x28>
            freq = CLOCK_SYS_GetSysAsyncFreq(SOSC_CLK, SCG_ASYNC_CLOCK_DIV2);
1ffe1b9c:	2101      	movs	r1, #1
1ffe1b9e:	2006      	movs	r0, #6
1ffe1ba0:	f7ff fe50 	bl	1ffe1844 <CLOCK_SYS_GetSysAsyncFreq>
1ffe1ba4:	4603      	mov	r3, r0
    status_t returnCode = STATUS_SUCCESS;
1ffe1ba6:	2000      	movs	r0, #0
            break;
1ffe1ba8:	e7a4      	b.n	1ffe1af4 <CLOCK_SYS_GetScgClockFreq+0x28>
            freq = CLOCK_SYS_GetSysAsyncFreq(SPLL_CLK, SCG_ASYNC_CLOCK_DIV1);
1ffe1baa:	2100      	movs	r1, #0
1ffe1bac:	2007      	movs	r0, #7
1ffe1bae:	f7ff fe49 	bl	1ffe1844 <CLOCK_SYS_GetSysAsyncFreq>
1ffe1bb2:	4603      	mov	r3, r0
    status_t returnCode = STATUS_SUCCESS;
1ffe1bb4:	2000      	movs	r0, #0
            break;
1ffe1bb6:	e79d      	b.n	1ffe1af4 <CLOCK_SYS_GetScgClockFreq+0x28>
            freq = CLOCK_SYS_GetSysAsyncFreq(SPLL_CLK, SCG_ASYNC_CLOCK_DIV2);
1ffe1bb8:	2101      	movs	r1, #1
1ffe1bba:	2007      	movs	r0, #7
1ffe1bbc:	f7ff fe42 	bl	1ffe1844 <CLOCK_SYS_GetSysAsyncFreq>
1ffe1bc0:	4603      	mov	r3, r0
    status_t returnCode = STATUS_SUCCESS;
1ffe1bc2:	2000      	movs	r0, #0
            break;
1ffe1bc4:	e796      	b.n	1ffe1af4 <CLOCK_SYS_GetScgClockFreq+0x28>
    switch (clockName)
1ffe1bc6:	2300      	movs	r3, #0
1ffe1bc8:	2004      	movs	r0, #4
1ffe1bca:	e793      	b.n	1ffe1af4 <CLOCK_SYS_GetScgClockFreq+0x28>
1ffe1bcc:	20000680 	.word	0x20000680

1ffe1bd0 <CLOCK_SYS_GetOtherSimClockFreq>:
{
1ffe1bd0:	b510      	push	{r4, lr}
1ffe1bd2:	460c      	mov	r4, r1
    switch(clockName)
1ffe1bd4:	f1a0 031d 	sub.w	r3, r0, #29
1ffe1bd8:	2b0e      	cmp	r3, #14
1ffe1bda:	d85b      	bhi.n	1ffe1c94 <CLOCK_SYS_GetOtherSimClockFreq+0xc4>
1ffe1bdc:	e8df f003 	tbb	[pc, r3]
1ffe1be0:	20140f08 	.word	0x20140f08
1ffe1be4:	5a5a3f32 	.word	0x5a5a3f32
1ffe1be8:	465a5a5a 	.word	0x465a5a5a
1ffe1bec:	504b      	.short	0x504b
1ffe1bee:	55          	.byte	0x55
1ffe1bef:	00          	.byte	0x00
            freq = CLOCK_SYS_GetSimClkOutFreq();
1ffe1bf0:	f7ff ff18 	bl	1ffe1a24 <CLOCK_SYS_GetSimClkOutFreq>
1ffe1bf4:	4603      	mov	r3, r0
    status_t returnCode = STATUS_SUCCESS;
1ffe1bf6:	2000      	movs	r0, #0
    if(frequency != NULL)
1ffe1bf8:	b104      	cbz	r4, 1ffe1bfc <CLOCK_SYS_GetOtherSimClockFreq+0x2c>
        *frequency = freq;
1ffe1bfa:	6023      	str	r3, [r4, #0]
}
1ffe1bfc:	bd10      	pop	{r4, pc}
            freq = CLOCK_SYS_GetSimRtcClkFreq();
1ffe1bfe:	f7ff fe89 	bl	1ffe1914 <CLOCK_SYS_GetSimRtcClkFreq>
1ffe1c02:	4603      	mov	r3, r0
    status_t returnCode = STATUS_SUCCESS;
1ffe1c04:	2000      	movs	r0, #0
            break;
1ffe1c06:	e7f7      	b.n	1ffe1bf8 <CLOCK_SYS_GetOtherSimClockFreq+0x28>
    uint8_t regValue = baseAddr->REGSC;
1ffe1c08:	4b2c      	ldr	r3, [pc, #176]	; (1ffe1cbc <CLOCK_SYS_GetOtherSimClockFreq+0xec>)
1ffe1c0a:	789b      	ldrb	r3, [r3, #2]
            if (PMC_GetLpoMode(PMC))
1ffe1c0c:	09db      	lsrs	r3, r3, #7
1ffe1c0e:	d002      	beq.n	1ffe1c16 <CLOCK_SYS_GetOtherSimClockFreq+0x46>
    uint32_t freq = 0 ;
1ffe1c10:	2300      	movs	r3, #0
    status_t returnCode = STATUS_SUCCESS;
1ffe1c12:	4618      	mov	r0, r3
1ffe1c14:	e7f0      	b.n	1ffe1bf8 <CLOCK_SYS_GetOtherSimClockFreq+0x28>
                freq = CLOCK_SYS_GetLpoFreq();
1ffe1c16:	f7ff fee1 	bl	1ffe19dc <CLOCK_SYS_GetLpoFreq>
1ffe1c1a:	4603      	mov	r3, r0
    status_t returnCode = STATUS_SUCCESS;
1ffe1c1c:	2000      	movs	r0, #0
1ffe1c1e:	e7eb      	b.n	1ffe1bf8 <CLOCK_SYS_GetOtherSimClockFreq+0x28>
1ffe1c20:	4b26      	ldr	r3, [pc, #152]	; (1ffe1cbc <CLOCK_SYS_GetOtherSimClockFreq+0xec>)
1ffe1c22:	789b      	ldrb	r3, [r3, #2]
            if (PMC_GetLpoMode(PMC))
1ffe1c24:	09db      	lsrs	r3, r3, #7
1ffe1c26:	d139      	bne.n	1ffe1c9c <CLOCK_SYS_GetOtherSimClockFreq+0xcc>
    return (((base->LPOCLKS & SIM_LPOCLKS_LPO32KCLKEN_MASK) >> SIM_LPOCLKS_LPO32KCLKEN_SHIFT) != 0U) ? true : false;
1ffe1c28:	4b25      	ldr	r3, [pc, #148]	; (1ffe1cc0 <CLOCK_SYS_GetOtherSimClockFreq+0xf0>)
1ffe1c2a:	691b      	ldr	r3, [r3, #16]
                freq = ((SIM_GetLpo32KStatus(SIM)) && (SIM_GetLpo1KStatus(SIM))) ? LPO_1K_FREQUENCY : 0UL;
1ffe1c2c:	f013 0302 	ands.w	r3, r3, #2
1ffe1c30:	d037      	beq.n	1ffe1ca2 <CLOCK_SYS_GetOtherSimClockFreq+0xd2>
    return (((base->LPOCLKS & SIM_LPOCLKS_LPO1KCLKEN_MASK) >> SIM_LPOCLKS_LPO1KCLKEN_SHIFT) != 0U) ? true : false;
1ffe1c32:	4b23      	ldr	r3, [pc, #140]	; (1ffe1cc0 <CLOCK_SYS_GetOtherSimClockFreq+0xf0>)
1ffe1c34:	691b      	ldr	r3, [r3, #16]
1ffe1c36:	f013 0301 	ands.w	r3, r3, #1
1ffe1c3a:	d034      	beq.n	1ffe1ca6 <CLOCK_SYS_GetOtherSimClockFreq+0xd6>
1ffe1c3c:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
    status_t returnCode = STATUS_SUCCESS;
1ffe1c40:	2000      	movs	r0, #0
1ffe1c42:	e7d9      	b.n	1ffe1bf8 <CLOCK_SYS_GetOtherSimClockFreq+0x28>
1ffe1c44:	4b1d      	ldr	r3, [pc, #116]	; (1ffe1cbc <CLOCK_SYS_GetOtherSimClockFreq+0xec>)
1ffe1c46:	789b      	ldrb	r3, [r3, #2]
            if (PMC_GetLpoMode(PMC))
1ffe1c48:	09db      	lsrs	r3, r3, #7
1ffe1c4a:	d12e      	bne.n	1ffe1caa <CLOCK_SYS_GetOtherSimClockFreq+0xda>
    return (((base->LPOCLKS & SIM_LPOCLKS_LPO32KCLKEN_MASK) >> SIM_LPOCLKS_LPO32KCLKEN_SHIFT) != 0U) ? true : false;
1ffe1c4c:	4b1c      	ldr	r3, [pc, #112]	; (1ffe1cc0 <CLOCK_SYS_GetOtherSimClockFreq+0xf0>)
1ffe1c4e:	691b      	ldr	r3, [r3, #16]
                freq = SIM_GetLpo32KStatus(SIM) ? LPO_32K_FREQUENCY : 0UL;
1ffe1c50:	f013 0302 	ands.w	r3, r3, #2
1ffe1c54:	d02c      	beq.n	1ffe1cb0 <CLOCK_SYS_GetOtherSimClockFreq+0xe0>
1ffe1c56:	f44f 43fa 	mov.w	r3, #32000	; 0x7d00
    status_t returnCode = STATUS_SUCCESS;
1ffe1c5a:	2000      	movs	r0, #0
1ffe1c5c:	e7cc      	b.n	1ffe1bf8 <CLOCK_SYS_GetOtherSimClockFreq+0x28>
1ffe1c5e:	4b17      	ldr	r3, [pc, #92]	; (1ffe1cbc <CLOCK_SYS_GetOtherSimClockFreq+0xec>)
1ffe1c60:	789b      	ldrb	r3, [r3, #2]
            if (PMC_GetLpoMode(PMC))
1ffe1c62:	09db      	lsrs	r3, r3, #7
1ffe1c64:	d026      	beq.n	1ffe1cb4 <CLOCK_SYS_GetOtherSimClockFreq+0xe4>
    uint32_t freq = 0 ;
1ffe1c66:	2300      	movs	r3, #0
    status_t returnCode = STATUS_SUCCESS;
1ffe1c68:	4618      	mov	r0, r3
1ffe1c6a:	e7c5      	b.n	1ffe1bf8 <CLOCK_SYS_GetOtherSimClockFreq+0x28>
            freq = CLOCK_SYS_GetQspiSfifClkHyp();
1ffe1c6c:	f7ff fe98 	bl	1ffe19a0 <CLOCK_SYS_GetQspiSfifClkHyp>
1ffe1c70:	4603      	mov	r3, r0
    status_t returnCode = STATUS_SUCCESS;
1ffe1c72:	2000      	movs	r0, #0
            break;
1ffe1c74:	e7c0      	b.n	1ffe1bf8 <CLOCK_SYS_GetOtherSimClockFreq+0x28>
            freq = CLOCK_SYS_GetQspiIpgClk();
1ffe1c76:	f7ff fda9 	bl	1ffe17cc <CLOCK_SYS_GetQspiIpgClk>
1ffe1c7a:	4603      	mov	r3, r0
    status_t returnCode = STATUS_SUCCESS;
1ffe1c7c:	2000      	movs	r0, #0
            break;
1ffe1c7e:	e7bb      	b.n	1ffe1bf8 <CLOCK_SYS_GetOtherSimClockFreq+0x28>
            freq = CLOCK_SYS_GetQspiIpgClkSfif();
1ffe1c80:	f7ff fe94 	bl	1ffe19ac <CLOCK_SYS_GetQspiIpgClkSfif>
1ffe1c84:	4603      	mov	r3, r0
    status_t returnCode = STATUS_SUCCESS;
1ffe1c86:	2000      	movs	r0, #0
            break;
1ffe1c88:	e7b6      	b.n	1ffe1bf8 <CLOCK_SYS_GetOtherSimClockFreq+0x28>
            freq = CLOCK_SYS_GetQspiIpgClk2Xsfif();
1ffe1c8a:	f7ff fe9b 	bl	1ffe19c4 <CLOCK_SYS_GetQspiIpgClk2Xsfif>
1ffe1c8e:	4603      	mov	r3, r0
    status_t returnCode = STATUS_SUCCESS;
1ffe1c90:	2000      	movs	r0, #0
            break;
1ffe1c92:	e7b1      	b.n	1ffe1bf8 <CLOCK_SYS_GetOtherSimClockFreq+0x28>
            returnCode = SIM_CheckPeripheralClockGate(clockName);
1ffe1c94:	f7ff f8de 	bl	1ffe0e54 <SIM_CheckPeripheralClockGate>
    uint32_t freq = 0 ;
1ffe1c98:	2300      	movs	r3, #0
            break;
1ffe1c9a:	e7ad      	b.n	1ffe1bf8 <CLOCK_SYS_GetOtherSimClockFreq+0x28>
    uint32_t freq = 0 ;
1ffe1c9c:	2300      	movs	r3, #0
    status_t returnCode = STATUS_SUCCESS;
1ffe1c9e:	4618      	mov	r0, r3
1ffe1ca0:	e7aa      	b.n	1ffe1bf8 <CLOCK_SYS_GetOtherSimClockFreq+0x28>
1ffe1ca2:	2000      	movs	r0, #0
1ffe1ca4:	e7a8      	b.n	1ffe1bf8 <CLOCK_SYS_GetOtherSimClockFreq+0x28>
1ffe1ca6:	2000      	movs	r0, #0
1ffe1ca8:	e7a6      	b.n	1ffe1bf8 <CLOCK_SYS_GetOtherSimClockFreq+0x28>
    uint32_t freq = 0 ;
1ffe1caa:	2300      	movs	r3, #0
    status_t returnCode = STATUS_SUCCESS;
1ffe1cac:	4618      	mov	r0, r3
1ffe1cae:	e7a3      	b.n	1ffe1bf8 <CLOCK_SYS_GetOtherSimClockFreq+0x28>
1ffe1cb0:	2000      	movs	r0, #0
1ffe1cb2:	e7a1      	b.n	1ffe1bf8 <CLOCK_SYS_GetOtherSimClockFreq+0x28>
                freq = LPO_128K_FREQUENCY;
1ffe1cb4:	f44f 33fa 	mov.w	r3, #128000	; 0x1f400
    status_t returnCode = STATUS_SUCCESS;
1ffe1cb8:	2000      	movs	r0, #0
1ffe1cba:	e79d      	b.n	1ffe1bf8 <CLOCK_SYS_GetOtherSimClockFreq+0x28>
1ffe1cbc:	4007d000 	.word	0x4007d000
1ffe1cc0:	40048000 	.word	0x40048000

1ffe1cc4 <CLOCK_SYS_GetSimClockFreq>:
{
1ffe1cc4:	b570      	push	{r4, r5, r6, lr}
1ffe1cc6:	b082      	sub	sp, #8
1ffe1cc8:	4604      	mov	r4, r0
1ffe1cca:	460d      	mov	r5, r1
    uint32_t freq = 0U;
1ffe1ccc:	2300      	movs	r3, #0
1ffe1cce:	9301      	str	r3, [sp, #4]
    switch (clockName)
1ffe1cd0:	f1a0 0315 	sub.w	r3, r0, #21
1ffe1cd4:	2b07      	cmp	r3, #7
1ffe1cd6:	d865      	bhi.n	1ffe1da4 <CLOCK_SYS_GetSimClockFreq+0xe0>
1ffe1cd8:	e8df f003 	tbb	[pc, r3]
1ffe1cdc:	281c1004 	.word	0x281c1004
1ffe1ce0:	584c4034 	.word	0x584c4034
    return (base->FTMOPT0 & SIM_FTMOPT0_FTM0CLKSEL_MASK) >> SIM_FTMOPT0_FTM0CLKSEL_SHIFT;
1ffe1ce4:	4b44      	ldr	r3, [pc, #272]	; (1ffe1df8 <CLOCK_SYS_GetSimClockFreq+0x134>)
1ffe1ce6:	68db      	ldr	r3, [r3, #12]
1ffe1ce8:	f3c3 6301 	ubfx	r3, r3, #24, #2
            if (clockPinSelect < NUMBER_OF_TCLK_INPUTS)
1ffe1cec:	2b02      	cmp	r3, #2
1ffe1cee:	d85e      	bhi.n	1ffe1dae <CLOCK_SYS_GetSimClockFreq+0xea>
                freq = g_TClkFreq[clockPinSelect];
1ffe1cf0:	4a42      	ldr	r2, [pc, #264]	; (1ffe1dfc <CLOCK_SYS_GetSimClockFreq+0x138>)
1ffe1cf2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
1ffe1cf6:	9301      	str	r3, [sp, #4]
    status_t returnCode = STATUS_SUCCESS;
1ffe1cf8:	2600      	movs	r6, #0
1ffe1cfa:	e059      	b.n	1ffe1db0 <CLOCK_SYS_GetSimClockFreq+0xec>
    return (base->FTMOPT0 & SIM_FTMOPT0_FTM1CLKSEL_MASK) >> SIM_FTMOPT0_FTM1CLKSEL_SHIFT;
1ffe1cfc:	4b3e      	ldr	r3, [pc, #248]	; (1ffe1df8 <CLOCK_SYS_GetSimClockFreq+0x134>)
1ffe1cfe:	68db      	ldr	r3, [r3, #12]
1ffe1d00:	f3c3 6381 	ubfx	r3, r3, #26, #2
            if (clockPinSelect < NUMBER_OF_TCLK_INPUTS)
1ffe1d04:	2b02      	cmp	r3, #2
1ffe1d06:	d863      	bhi.n	1ffe1dd0 <CLOCK_SYS_GetSimClockFreq+0x10c>
                freq = g_TClkFreq[clockPinSelect];
1ffe1d08:	4a3c      	ldr	r2, [pc, #240]	; (1ffe1dfc <CLOCK_SYS_GetSimClockFreq+0x138>)
1ffe1d0a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
1ffe1d0e:	9301      	str	r3, [sp, #4]
    status_t returnCode = STATUS_SUCCESS;
1ffe1d10:	2600      	movs	r6, #0
1ffe1d12:	e04d      	b.n	1ffe1db0 <CLOCK_SYS_GetSimClockFreq+0xec>
    return (base->FTMOPT0 & SIM_FTMOPT0_FTM2CLKSEL_MASK) >> SIM_FTMOPT0_FTM2CLKSEL_SHIFT;
1ffe1d14:	4b38      	ldr	r3, [pc, #224]	; (1ffe1df8 <CLOCK_SYS_GetSimClockFreq+0x134>)
1ffe1d16:	68db      	ldr	r3, [r3, #12]
1ffe1d18:	f3c3 7301 	ubfx	r3, r3, #28, #2
            if (clockPinSelect < NUMBER_OF_TCLK_INPUTS)
1ffe1d1c:	2b02      	cmp	r3, #2
1ffe1d1e:	d859      	bhi.n	1ffe1dd4 <CLOCK_SYS_GetSimClockFreq+0x110>
                freq = g_TClkFreq[clockPinSelect];
1ffe1d20:	4a36      	ldr	r2, [pc, #216]	; (1ffe1dfc <CLOCK_SYS_GetSimClockFreq+0x138>)
1ffe1d22:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
1ffe1d26:	9301      	str	r3, [sp, #4]
    status_t returnCode = STATUS_SUCCESS;
1ffe1d28:	2600      	movs	r6, #0
1ffe1d2a:	e041      	b.n	1ffe1db0 <CLOCK_SYS_GetSimClockFreq+0xec>
    return (base->FTMOPT0 & SIM_FTMOPT0_FTM3CLKSEL_MASK) >> SIM_FTMOPT0_FTM3CLKSEL_SHIFT;
1ffe1d2c:	4b32      	ldr	r3, [pc, #200]	; (1ffe1df8 <CLOCK_SYS_GetSimClockFreq+0x134>)
1ffe1d2e:	68db      	ldr	r3, [r3, #12]
1ffe1d30:	0f9a      	lsrs	r2, r3, #30
            if (clockPinSelect < NUMBER_OF_TCLK_INPUTS)
1ffe1d32:	f1b3 4f40 	cmp.w	r3, #3221225472	; 0xc0000000
1ffe1d36:	d24f      	bcs.n	1ffe1dd8 <CLOCK_SYS_GetSimClockFreq+0x114>
                freq = g_TClkFreq[clockPinSelect];
1ffe1d38:	4b30      	ldr	r3, [pc, #192]	; (1ffe1dfc <CLOCK_SYS_GetSimClockFreq+0x138>)
1ffe1d3a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
1ffe1d3e:	9301      	str	r3, [sp, #4]
    status_t returnCode = STATUS_SUCCESS;
1ffe1d40:	2600      	movs	r6, #0
1ffe1d42:	e035      	b.n	1ffe1db0 <CLOCK_SYS_GetSimClockFreq+0xec>
    return (base->FTMOPT0 & SIM_FTMOPT0_FTM4CLKSEL_MASK) >> SIM_FTMOPT0_FTM4CLKSEL_SHIFT;
1ffe1d44:	4b2c      	ldr	r3, [pc, #176]	; (1ffe1df8 <CLOCK_SYS_GetSimClockFreq+0x134>)
1ffe1d46:	68db      	ldr	r3, [r3, #12]
1ffe1d48:	f3c3 4301 	ubfx	r3, r3, #16, #2
            if (clockPinSelect < NUMBER_OF_TCLK_INPUTS)
1ffe1d4c:	2b02      	cmp	r3, #2
1ffe1d4e:	d845      	bhi.n	1ffe1ddc <CLOCK_SYS_GetSimClockFreq+0x118>
                freq = g_TClkFreq[clockPinSelect];
1ffe1d50:	4a2a      	ldr	r2, [pc, #168]	; (1ffe1dfc <CLOCK_SYS_GetSimClockFreq+0x138>)
1ffe1d52:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
1ffe1d56:	9301      	str	r3, [sp, #4]
    status_t returnCode = STATUS_SUCCESS;
1ffe1d58:	2600      	movs	r6, #0
1ffe1d5a:	e029      	b.n	1ffe1db0 <CLOCK_SYS_GetSimClockFreq+0xec>
    return (base->FTMOPT0 & SIM_FTMOPT0_FTM5CLKSEL_MASK) >> SIM_FTMOPT0_FTM5CLKSEL_SHIFT;
1ffe1d5c:	4b26      	ldr	r3, [pc, #152]	; (1ffe1df8 <CLOCK_SYS_GetSimClockFreq+0x134>)
1ffe1d5e:	68db      	ldr	r3, [r3, #12]
1ffe1d60:	f3c3 4381 	ubfx	r3, r3, #18, #2
            if (clockPinSelect < NUMBER_OF_TCLK_INPUTS)
1ffe1d64:	2b02      	cmp	r3, #2
1ffe1d66:	d83b      	bhi.n	1ffe1de0 <CLOCK_SYS_GetSimClockFreq+0x11c>
                freq = g_TClkFreq[clockPinSelect];
1ffe1d68:	4a24      	ldr	r2, [pc, #144]	; (1ffe1dfc <CLOCK_SYS_GetSimClockFreq+0x138>)
1ffe1d6a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
1ffe1d6e:	9301      	str	r3, [sp, #4]
    status_t returnCode = STATUS_SUCCESS;
1ffe1d70:	2600      	movs	r6, #0
1ffe1d72:	e01d      	b.n	1ffe1db0 <CLOCK_SYS_GetSimClockFreq+0xec>
    return (base->FTMOPT0 & SIM_FTMOPT0_FTM6CLKSEL_MASK) >> SIM_FTMOPT0_FTM6CLKSEL_SHIFT;
1ffe1d74:	4b20      	ldr	r3, [pc, #128]	; (1ffe1df8 <CLOCK_SYS_GetSimClockFreq+0x134>)
1ffe1d76:	68db      	ldr	r3, [r3, #12]
1ffe1d78:	f3c3 5301 	ubfx	r3, r3, #20, #2
            if (clockPinSelect < NUMBER_OF_TCLK_INPUTS)
1ffe1d7c:	2b02      	cmp	r3, #2
1ffe1d7e:	d831      	bhi.n	1ffe1de4 <CLOCK_SYS_GetSimClockFreq+0x120>
                freq = g_TClkFreq[clockPinSelect];
1ffe1d80:	4a1e      	ldr	r2, [pc, #120]	; (1ffe1dfc <CLOCK_SYS_GetSimClockFreq+0x138>)
1ffe1d82:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
1ffe1d86:	9301      	str	r3, [sp, #4]
    status_t returnCode = STATUS_SUCCESS;
1ffe1d88:	2600      	movs	r6, #0
1ffe1d8a:	e011      	b.n	1ffe1db0 <CLOCK_SYS_GetSimClockFreq+0xec>
    return (base->FTMOPT0 & SIM_FTMOPT0_FTM7CLKSEL_MASK) >> SIM_FTMOPT0_FTM7CLKSEL_SHIFT;
1ffe1d8c:	4b1a      	ldr	r3, [pc, #104]	; (1ffe1df8 <CLOCK_SYS_GetSimClockFreq+0x134>)
1ffe1d8e:	68db      	ldr	r3, [r3, #12]
1ffe1d90:	f3c3 5381 	ubfx	r3, r3, #22, #2
            if (clockPinSelect < NUMBER_OF_TCLK_INPUTS)
1ffe1d94:	2b02      	cmp	r3, #2
1ffe1d96:	d827      	bhi.n	1ffe1de8 <CLOCK_SYS_GetSimClockFreq+0x124>
                freq = g_TClkFreq[clockPinSelect];
1ffe1d98:	4a18      	ldr	r2, [pc, #96]	; (1ffe1dfc <CLOCK_SYS_GetSimClockFreq+0x138>)
1ffe1d9a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
1ffe1d9e:	9301      	str	r3, [sp, #4]
    status_t returnCode = STATUS_SUCCESS;
1ffe1da0:	2600      	movs	r6, #0
1ffe1da2:	e005      	b.n	1ffe1db0 <CLOCK_SYS_GetSimClockFreq+0xec>
            returnCode = CLOCK_SYS_GetOtherSimClockFreq(clockName, &freq);
1ffe1da4:	a901      	add	r1, sp, #4
1ffe1da6:	f7ff ff13 	bl	1ffe1bd0 <CLOCK_SYS_GetOtherSimClockFreq>
1ffe1daa:	4606      	mov	r6, r0
            break;
1ffe1dac:	e000      	b.n	1ffe1db0 <CLOCK_SYS_GetSimClockFreq+0xec>
    status_t returnCode = STATUS_SUCCESS;
1ffe1dae:	2600      	movs	r6, #0
    if ((clockName > SIM_LPO_128K_CLK) && (clockName <= SIM_MSCM_CLK) && (returnCode == STATUS_SUCCESS))
1ffe1db0:	3c23      	subs	r4, #35	; 0x23
1ffe1db2:	b2e4      	uxtb	r4, r4
1ffe1db4:	2c04      	cmp	r4, #4
1ffe1db6:	d800      	bhi.n	1ffe1dba <CLOCK_SYS_GetSimClockFreq+0xf6>
1ffe1db8:	b1c6      	cbz	r6, 1ffe1dec <CLOCK_SYS_GetSimClockFreq+0x128>
    if ((freq == 0UL) && (returnCode != STATUS_UNSUPPORTED))
1ffe1dba:	9b01      	ldr	r3, [sp, #4]
1ffe1dbc:	b91b      	cbnz	r3, 1ffe1dc6 <CLOCK_SYS_GetSimClockFreq+0x102>
1ffe1dbe:	2e04      	cmp	r6, #4
1ffe1dc0:	d001      	beq.n	1ffe1dc6 <CLOCK_SYS_GetSimClockFreq+0x102>
        returnCode = STATUS_MCU_GATED_OFF;
1ffe1dc2:	f44f 7680 	mov.w	r6, #256	; 0x100
    if (frequency != NULL)
1ffe1dc6:	b105      	cbz	r5, 1ffe1dca <CLOCK_SYS_GetSimClockFreq+0x106>
        *frequency = freq;
1ffe1dc8:	602b      	str	r3, [r5, #0]
}
1ffe1dca:	4630      	mov	r0, r6
1ffe1dcc:	b002      	add	sp, #8
1ffe1dce:	bd70      	pop	{r4, r5, r6, pc}
    status_t returnCode = STATUS_SUCCESS;
1ffe1dd0:	2600      	movs	r6, #0
1ffe1dd2:	e7ed      	b.n	1ffe1db0 <CLOCK_SYS_GetSimClockFreq+0xec>
1ffe1dd4:	2600      	movs	r6, #0
1ffe1dd6:	e7eb      	b.n	1ffe1db0 <CLOCK_SYS_GetSimClockFreq+0xec>
1ffe1dd8:	2600      	movs	r6, #0
1ffe1dda:	e7e9      	b.n	1ffe1db0 <CLOCK_SYS_GetSimClockFreq+0xec>
1ffe1ddc:	2600      	movs	r6, #0
1ffe1dde:	e7e7      	b.n	1ffe1db0 <CLOCK_SYS_GetSimClockFreq+0xec>
1ffe1de0:	2600      	movs	r6, #0
1ffe1de2:	e7e5      	b.n	1ffe1db0 <CLOCK_SYS_GetSimClockFreq+0xec>
1ffe1de4:	2600      	movs	r6, #0
1ffe1de6:	e7e3      	b.n	1ffe1db0 <CLOCK_SYS_GetSimClockFreq+0xec>
1ffe1de8:	2600      	movs	r6, #0
1ffe1dea:	e7e1      	b.n	1ffe1db0 <CLOCK_SYS_GetSimClockFreq+0xec>
        freq = CLOCK_SYS_GetSystemClockFreq(SCG_SYSTEM_CLOCK_BUS);
1ffe1dec:	2001      	movs	r0, #1
1ffe1dee:	f7ff fcb1 	bl	1ffe1754 <CLOCK_SYS_GetSystemClockFreq>
1ffe1df2:	9001      	str	r0, [sp, #4]
1ffe1df4:	e7e1      	b.n	1ffe1dba <CLOCK_SYS_GetSimClockFreq+0xf6>
1ffe1df6:	bf00      	nop
1ffe1df8:	40048000 	.word	0x40048000
1ffe1dfc:	20000684 	.word	0x20000684

1ffe1e00 <CLOCK_SYS_GetFtmOptionFreq>:
{
1ffe1e00:	b508      	push	{r3, lr}
    switch (clockName)
1ffe1e02:	3843      	subs	r0, #67	; 0x43
1ffe1e04:	2807      	cmp	r0, #7
1ffe1e06:	d825      	bhi.n	1ffe1e54 <CLOCK_SYS_GetFtmOptionFreq+0x54>
1ffe1e08:	e8df f000 	tbb	[pc, r0]
1ffe1e0c:	100c0804 	.word	0x100c0804
1ffe1e10:	201c1814 	.word	0x201c1814
            returnCode = CLOCK_SYS_GetSimClockFreq(SIM_FTM0_CLOCKSEL, frequency);
1ffe1e14:	2015      	movs	r0, #21
1ffe1e16:	f7ff ff55 	bl	1ffe1cc4 <CLOCK_SYS_GetSimClockFreq>
}
1ffe1e1a:	bd08      	pop	{r3, pc}
            returnCode = CLOCK_SYS_GetSimClockFreq(SIM_FTM1_CLOCKSEL, frequency);
1ffe1e1c:	2016      	movs	r0, #22
1ffe1e1e:	f7ff ff51 	bl	1ffe1cc4 <CLOCK_SYS_GetSimClockFreq>
            break;
1ffe1e22:	e7fa      	b.n	1ffe1e1a <CLOCK_SYS_GetFtmOptionFreq+0x1a>
            returnCode = CLOCK_SYS_GetSimClockFreq(SIM_FTM2_CLOCKSEL, frequency);
1ffe1e24:	2017      	movs	r0, #23
1ffe1e26:	f7ff ff4d 	bl	1ffe1cc4 <CLOCK_SYS_GetSimClockFreq>
            break;
1ffe1e2a:	e7f6      	b.n	1ffe1e1a <CLOCK_SYS_GetFtmOptionFreq+0x1a>
            returnCode = CLOCK_SYS_GetSimClockFreq(SIM_FTM3_CLOCKSEL, frequency);
1ffe1e2c:	2018      	movs	r0, #24
1ffe1e2e:	f7ff ff49 	bl	1ffe1cc4 <CLOCK_SYS_GetSimClockFreq>
            break;
1ffe1e32:	e7f2      	b.n	1ffe1e1a <CLOCK_SYS_GetFtmOptionFreq+0x1a>
            returnCode = CLOCK_SYS_GetSimClockFreq(SIM_FTM4_CLOCKSEL, frequency);
1ffe1e34:	2019      	movs	r0, #25
1ffe1e36:	f7ff ff45 	bl	1ffe1cc4 <CLOCK_SYS_GetSimClockFreq>
            break;
1ffe1e3a:	e7ee      	b.n	1ffe1e1a <CLOCK_SYS_GetFtmOptionFreq+0x1a>
            returnCode = CLOCK_SYS_GetSimClockFreq(SIM_FTM5_CLOCKSEL, frequency);
1ffe1e3c:	201a      	movs	r0, #26
1ffe1e3e:	f7ff ff41 	bl	1ffe1cc4 <CLOCK_SYS_GetSimClockFreq>
            break;
1ffe1e42:	e7ea      	b.n	1ffe1e1a <CLOCK_SYS_GetFtmOptionFreq+0x1a>
            returnCode = CLOCK_SYS_GetSimClockFreq(SIM_FTM6_CLOCKSEL, frequency);
1ffe1e44:	201b      	movs	r0, #27
1ffe1e46:	f7ff ff3d 	bl	1ffe1cc4 <CLOCK_SYS_GetSimClockFreq>
            break;
1ffe1e4a:	e7e6      	b.n	1ffe1e1a <CLOCK_SYS_GetFtmOptionFreq+0x1a>
            returnCode = CLOCK_SYS_GetSimClockFreq(SIM_FTM7_CLOCKSEL, frequency);
1ffe1e4c:	201c      	movs	r0, #28
1ffe1e4e:	f7ff ff39 	bl	1ffe1cc4 <CLOCK_SYS_GetSimClockFreq>
            break;
1ffe1e52:	e7e2      	b.n	1ffe1e1a <CLOCK_SYS_GetFtmOptionFreq+0x1a>
    switch (clockName)
1ffe1e54:	2000      	movs	r0, #0
1ffe1e56:	e7e0      	b.n	1ffe1e1a <CLOCK_SYS_GetFtmOptionFreq+0x1a>

1ffe1e58 <CLOCK_SYS_GetPeripheralClock>:
{
1ffe1e58:	b530      	push	{r4, r5, lr}
1ffe1e5a:	b083      	sub	sp, #12
    uint32_t frequency = 0;
1ffe1e5c:	2300      	movs	r3, #0
1ffe1e5e:	9301      	str	r3, [sp, #4]
*        - PCC_MULTPCCnLY_BY_TWO : Fractional value is one
*/
static inline uint32_t PCC_GetFracValueSel(const PCC_Type* const base,
                                               const clock_names_t clockName)
{
   return ((base->PCCn[clockNameMappings[clockName]] & PCC_PCCn_FRAC_MASK) >> PCC_PCCn_FRAC_SHIFT);
1ffe1e60:	4b21      	ldr	r3, [pc, #132]	; (1ffe1ee8 <CLOCK_SYS_GetPeripheralClock+0x90>)
1ffe1e62:	f833 3010 	ldrh.w	r3, [r3, r0, lsl #1]
1ffe1e66:	4a21      	ldr	r2, [pc, #132]	; (1ffe1eec <CLOCK_SYS_GetPeripheralClock+0x94>)
1ffe1e68:	f852 5023 	ldr.w	r5, [r2, r3, lsl #2]
1ffe1e6c:	f3c5 05c0 	ubfx	r5, r5, #3, #1
*        - PCC_DIVIDE_BY_EIGTH : Divide by 8
*/
static inline uint32_t PCC_GetDividerSel(const PCC_Type* const base,
                                             const clock_names_t clockName)
{
   return ((base->PCCn[clockNameMappings[clockName]] & PCC_PCCn_PCD_MASK) >> PCC_PCCn_PCD_SHIFT);
1ffe1e70:	f852 4023 	ldr.w	r4, [r2, r3, lsl #2]
1ffe1e74:	f004 0407 	and.w	r4, r4, #7
    if (((uint32_t)fracValue) <= ((uint32_t)divValue))
1ffe1e78:	42ac      	cmp	r4, r5
1ffe1e7a:	d31d      	bcc.n	1ffe1eb8 <CLOCK_SYS_GetPeripheralClock+0x60>
   uint32_t regValue = (uint32_t)base->PCCn[clockNameMappings[clockName]];
1ffe1e7c:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
        if (PCC_GetClockMode(PCC, clockName))
1ffe1e80:	f012 4f80 	tst.w	r2, #1073741824	; 0x40000000
1ffe1e84:	d018      	beq.n	1ffe1eb8 <CLOCK_SYS_GetPeripheralClock+0x60>
   return ((base->PCCn[clockNameMappings[clockName]] & PCC_PCCn_PCS_MASK) >> PCC_PCCn_PCS_SHIFT);
1ffe1e86:	4a19      	ldr	r2, [pc, #100]	; (1ffe1eec <CLOCK_SYS_GetPeripheralClock+0x94>)
1ffe1e88:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
1ffe1e8c:	f3c3 6302 	ubfx	r3, r3, #24, #3
            switch (PCC_GetClockSourceSel(PCC, clockName))
1ffe1e90:	3b01      	subs	r3, #1
1ffe1e92:	2b05      	cmp	r3, #5
1ffe1e94:	d822      	bhi.n	1ffe1edc <CLOCK_SYS_GetPeripheralClock+0x84>
1ffe1e96:	e8df f003 	tbb	[pc, r3]
1ffe1e9a:	1203      	.short	0x1203
1ffe1e9c:	1c212117 	.word	0x1c212117
                    frequency = CLOCK_SYS_GetSysAsyncFreq(SOSC_CLK, divider);
1ffe1ea0:	2006      	movs	r0, #6
1ffe1ea2:	f7ff fccf 	bl	1ffe1844 <CLOCK_SYS_GetSysAsyncFreq>
1ffe1ea6:	9001      	str	r0, [sp, #4]
            frequency = frequency / (divValue + 1U);
1ffe1ea8:	3401      	adds	r4, #1
1ffe1eaa:	9b01      	ldr	r3, [sp, #4]
1ffe1eac:	fbb3 f4f4 	udiv	r4, r3, r4
1ffe1eb0:	9401      	str	r4, [sp, #4]
            frequency = frequency * (fracValue + 1U);
1ffe1eb2:	fb05 4404 	mla	r4, r5, r4, r4
1ffe1eb6:	9401      	str	r4, [sp, #4]
}
1ffe1eb8:	9801      	ldr	r0, [sp, #4]
1ffe1eba:	b003      	add	sp, #12
1ffe1ebc:	bd30      	pop	{r4, r5, pc}
                    frequency = CLOCK_SYS_GetSysAsyncFreq(SIRC_CLK, divider);
1ffe1ebe:	2004      	movs	r0, #4
1ffe1ec0:	f7ff fcc0 	bl	1ffe1844 <CLOCK_SYS_GetSysAsyncFreq>
1ffe1ec4:	9001      	str	r0, [sp, #4]
                    break;
1ffe1ec6:	e7ef      	b.n	1ffe1ea8 <CLOCK_SYS_GetPeripheralClock+0x50>
                    frequency = CLOCK_SYS_GetSysAsyncFreq(FIRC_CLK, divider);
1ffe1ec8:	2005      	movs	r0, #5
1ffe1eca:	f7ff fcbb 	bl	1ffe1844 <CLOCK_SYS_GetSysAsyncFreq>
1ffe1ece:	9001      	str	r0, [sp, #4]
                    break;
1ffe1ed0:	e7ea      	b.n	1ffe1ea8 <CLOCK_SYS_GetPeripheralClock+0x50>
                    frequency = CLOCK_SYS_GetSysAsyncFreq(SPLL_CLK, divider);
1ffe1ed2:	2007      	movs	r0, #7
1ffe1ed4:	f7ff fcb6 	bl	1ffe1844 <CLOCK_SYS_GetSysAsyncFreq>
1ffe1ed8:	9001      	str	r0, [sp, #4]
                    break;
1ffe1eda:	e7e5      	b.n	1ffe1ea8 <CLOCK_SYS_GetPeripheralClock+0x50>
                    (void)CLOCK_SYS_GetFtmOptionFreq(clockName, &frequency);
1ffe1edc:	a901      	add	r1, sp, #4
1ffe1ede:	f7ff ff8f 	bl	1ffe1e00 <CLOCK_SYS_GetFtmOptionFreq>
                    divValue = 0U;
1ffe1ee2:	2400      	movs	r4, #0
                    break;
1ffe1ee4:	e7e0      	b.n	1ffe1ea8 <CLOCK_SYS_GetPeripheralClock+0x50>
1ffe1ee6:	bf00      	nop
1ffe1ee8:	1ffe34b8 	.word	0x1ffe34b8
1ffe1eec:	40065000 	.word	0x40065000

1ffe1ef0 <CLOCK_SYS_GetPccClockFreq>:
{
1ffe1ef0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
1ffe1ef2:	4607      	mov	r7, r0
1ffe1ef4:	460c      	mov	r4, r1
    returnCode = CLOCK_SYS_CheckPCCClock(clockName);
1ffe1ef6:	f7fe ff83 	bl	1ffe0e00 <CLOCK_SYS_CheckPCCClock>
    if (returnCode == STATUS_SUCCESS)
1ffe1efa:	4606      	mov	r6, r0
1ffe1efc:	2800      	cmp	r0, #0
1ffe1efe:	d148      	bne.n	1ffe1f92 <CLOCK_SYS_GetPccClockFreq+0xa2>
        if ((peripheralFeaturesList[clockName] & HAS_INT_CLOCK_FROM_BUS_CLOCK) != 0U)
1ffe1f00:	4b27      	ldr	r3, [pc, #156]	; (1ffe1fa0 <CLOCK_SYS_GetPccClockFreq+0xb0>)
1ffe1f02:	5ddd      	ldrb	r5, [r3, r7]
1ffe1f04:	f015 0f20 	tst.w	r5, #32
1ffe1f08:	d116      	bne.n	1ffe1f38 <CLOCK_SYS_GetPccClockFreq+0x48>
        else if ((peripheralFeaturesList[clockName] & HAS_INT_CLOCK_FROM_SYS_CLOCK) != 0U)
1ffe1f0a:	f015 0f40 	tst.w	r5, #64	; 0x40
1ffe1f0e:	d11c      	bne.n	1ffe1f4a <CLOCK_SYS_GetPccClockFreq+0x5a>
        else if ((peripheralFeaturesList[clockName] & HAS_INT_CLOCK_FROM_SLOW_CLOCK) != 0U)
1ffe1f10:	f015 0f80 	tst.w	r5, #128	; 0x80
1ffe1f14:	d122      	bne.n	1ffe1f5c <CLOCK_SYS_GetPccClockFreq+0x6c>
    uint32_t interfaceFreq = 0U;
1ffe1f16:	2300      	movs	r3, #0
        if (returnCode == STATUS_SUCCESS)
1ffe1f18:	2e00      	cmp	r6, #0
1ffe1f1a:	d13f      	bne.n	1ffe1f9c <CLOCK_SYS_GetPccClockFreq+0xac>
            if ((peripheralFeaturesList[clockName] & (HAS_PROTOCOL_CLOCK_FROM_ASYNC1 | HAS_PROTOCOL_CLOCK_FROM_ASYNC2)) != 0U)
1ffe1f1c:	f015 0f18 	tst.w	r5, #24
1ffe1f20:	d031      	beq.n	1ffe1f86 <CLOCK_SYS_GetPccClockFreq+0x96>
                if ((peripheralFeaturesList[clockName] & HAS_PROTOCOL_CLOCK_FROM_ASYNC1) != 0U)
1ffe1f22:	f015 0f08 	tst.w	r5, #8
1ffe1f26:	d122      	bne.n	1ffe1f6e <CLOCK_SYS_GetPccClockFreq+0x7e>
    uint32_t freq = 0U;
1ffe1f28:	2300      	movs	r3, #0
                if ((peripheralFeaturesList[clockName] & HAS_PROTOCOL_CLOCK_FROM_ASYNC2) != 0U)
1ffe1f2a:	f015 0f10 	tst.w	r5, #16
1ffe1f2e:	d124      	bne.n	1ffe1f7a <CLOCK_SYS_GetPccClockFreq+0x8a>
                if (freq == 0U)
1ffe1f30:	bb83      	cbnz	r3, 1ffe1f94 <CLOCK_SYS_GetPccClockFreq+0xa4>
                    returnCode = STATUS_MCU_GATED_OFF;
1ffe1f32:	f44f 7680 	mov.w	r6, #256	; 0x100
1ffe1f36:	e02d      	b.n	1ffe1f94 <CLOCK_SYS_GetPccClockFreq+0xa4>
            interfaceFreq = CLOCK_SYS_GetSystemClockFreq(SCG_SYSTEM_CLOCK_BUS);
1ffe1f38:	2001      	movs	r0, #1
1ffe1f3a:	f7ff fc0b 	bl	1ffe1754 <CLOCK_SYS_GetSystemClockFreq>
            returnCode = (status_t)((interfaceFreq == 0U) ? STATUS_MCU_GATED_OFF : STATUS_SUCCESS);
1ffe1f3e:	4603      	mov	r3, r0
1ffe1f40:	2800      	cmp	r0, #0
1ffe1f42:	d1e9      	bne.n	1ffe1f18 <CLOCK_SYS_GetPccClockFreq+0x28>
1ffe1f44:	f44f 7680 	mov.w	r6, #256	; 0x100
1ffe1f48:	e7e6      	b.n	1ffe1f18 <CLOCK_SYS_GetPccClockFreq+0x28>
            interfaceFreq = CLOCK_SYS_GetSystemClockFreq(SCG_SYSTEM_CLOCK_CORE);
1ffe1f4a:	2000      	movs	r0, #0
1ffe1f4c:	f7ff fc02 	bl	1ffe1754 <CLOCK_SYS_GetSystemClockFreq>
            returnCode = (status_t)((interfaceFreq == 0U) ? STATUS_MCU_GATED_OFF : STATUS_SUCCESS);
1ffe1f50:	4603      	mov	r3, r0
1ffe1f52:	2800      	cmp	r0, #0
1ffe1f54:	d1e0      	bne.n	1ffe1f18 <CLOCK_SYS_GetPccClockFreq+0x28>
1ffe1f56:	f44f 7680 	mov.w	r6, #256	; 0x100
1ffe1f5a:	e7dd      	b.n	1ffe1f18 <CLOCK_SYS_GetPccClockFreq+0x28>
            interfaceFreq = CLOCK_SYS_GetSystemClockFreq(SCG_SYSTEM_CLOCK_SLOW);
1ffe1f5c:	2002      	movs	r0, #2
1ffe1f5e:	f7ff fbf9 	bl	1ffe1754 <CLOCK_SYS_GetSystemClockFreq>
            returnCode = (status_t)((interfaceFreq == 0U) ? STATUS_MCU_GATED_OFF : STATUS_SUCCESS);
1ffe1f62:	4603      	mov	r3, r0
1ffe1f64:	2800      	cmp	r0, #0
1ffe1f66:	d1d7      	bne.n	1ffe1f18 <CLOCK_SYS_GetPccClockFreq+0x28>
1ffe1f68:	f44f 7680 	mov.w	r6, #256	; 0x100
1ffe1f6c:	e7d4      	b.n	1ffe1f18 <CLOCK_SYS_GetPccClockFreq+0x28>
                    freq = CLOCK_SYS_GetPeripheralClock(clockName, SCG_ASYNC_CLOCK_DIV1);
1ffe1f6e:	2100      	movs	r1, #0
1ffe1f70:	4638      	mov	r0, r7
1ffe1f72:	f7ff ff71 	bl	1ffe1e58 <CLOCK_SYS_GetPeripheralClock>
1ffe1f76:	4603      	mov	r3, r0
1ffe1f78:	e7d7      	b.n	1ffe1f2a <CLOCK_SYS_GetPccClockFreq+0x3a>
                    freq = CLOCK_SYS_GetPeripheralClock(clockName, SCG_ASYNC_CLOCK_DIV2);
1ffe1f7a:	2101      	movs	r1, #1
1ffe1f7c:	4638      	mov	r0, r7
1ffe1f7e:	f7ff ff6b 	bl	1ffe1e58 <CLOCK_SYS_GetPeripheralClock>
1ffe1f82:	4603      	mov	r3, r0
1ffe1f84:	e7d4      	b.n	1ffe1f30 <CLOCK_SYS_GetPccClockFreq+0x40>
                if (clockName == QSPI0_CLK)
1ffe1f86:	2f59      	cmp	r7, #89	; 0x59
1ffe1f88:	d104      	bne.n	1ffe1f94 <CLOCK_SYS_GetPccClockFreq+0xa4>
                    freq = CLOCK_SYS_GetQspiIpgClk();
1ffe1f8a:	f7ff fc1f 	bl	1ffe17cc <CLOCK_SYS_GetQspiIpgClk>
1ffe1f8e:	4603      	mov	r3, r0
1ffe1f90:	e000      	b.n	1ffe1f94 <CLOCK_SYS_GetPccClockFreq+0xa4>
    uint32_t freq = 0U;
1ffe1f92:	2300      	movs	r3, #0
    if (frequency != NULL)
1ffe1f94:	b104      	cbz	r4, 1ffe1f98 <CLOCK_SYS_GetPccClockFreq+0xa8>
        *frequency = freq;
1ffe1f96:	6023      	str	r3, [r4, #0]
}
1ffe1f98:	4630      	mov	r0, r6
1ffe1f9a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    uint32_t freq = 0U;
1ffe1f9c:	2300      	movs	r3, #0
1ffe1f9e:	e7f9      	b.n	1ffe1f94 <CLOCK_SYS_GetPccClockFreq+0xa4>
1ffe1fa0:	1ffe366c 	.word	0x1ffe366c

1ffe1fa4 <CLOCK_DRV_Init>:
{
1ffe1fa4:	b530      	push	{r4, r5, lr}
1ffe1fa6:	b0a7      	sub	sp, #156	; 0x9c
    if (config == NULL)
1ffe1fa8:	4604      	mov	r4, r0
1ffe1faa:	b138      	cbz	r0, 1ffe1fbc <CLOCK_DRV_Init+0x18>
    result = CLOCK_SYS_SetScgConfiguration(&cfg->scgConfig);
1ffe1fac:	4620      	mov	r0, r4
1ffe1fae:	f7ff fb93 	bl	1ffe16d8 <CLOCK_SYS_SetScgConfiguration>
    if (STATUS_SUCCESS == result)
1ffe1fb2:	4605      	mov	r5, r0
1ffe1fb4:	b138      	cbz	r0, 1ffe1fc6 <CLOCK_DRV_Init+0x22>
}
1ffe1fb6:	4628      	mov	r0, r5
1ffe1fb8:	b027      	add	sp, #156	; 0x9c
1ffe1fba:	bd30      	pop	{r4, r5, pc}
        CLOCK_SYS_GetDefaultConfiguration(&config_default);
1ffe1fbc:	4668      	mov	r0, sp
1ffe1fbe:	f7fe fe81 	bl	1ffe0cc4 <CLOCK_SYS_GetDefaultConfiguration>
        cfg = &config_default;
1ffe1fc2:	466c      	mov	r4, sp
1ffe1fc4:	e7f2      	b.n	1ffe1fac <CLOCK_DRV_Init+0x8>
        CLOCK_SYS_SetSimConfiguration(&cfg->simConfig);
1ffe1fc6:	f104 0044 	add.w	r0, r4, #68	; 0x44
1ffe1fca:	f7fe fd35 	bl	1ffe0a38 <CLOCK_SYS_SetSimConfiguration>
        CLOCK_SYS_SetPccConfiguration(&cfg->pccConfig);
1ffe1fce:	f104 008c 	add.w	r0, r4, #140	; 0x8c
1ffe1fd2:	f7fe fcef 	bl	1ffe09b4 <CLOCK_SYS_SetPccConfiguration>
        CLOCK_SYS_SetPmcConfiguration(&cfg->pmcConfig);
1ffe1fd6:	f104 0094 	add.w	r0, r4, #148	; 0x94
1ffe1fda:	f7fe fe53 	bl	1ffe0c84 <CLOCK_SYS_SetPmcConfiguration>
1ffe1fde:	e7ea      	b.n	1ffe1fb6 <CLOCK_DRV_Init+0x12>

1ffe1fe0 <CLOCK_DRV_GetFreq>:
{
1ffe1fe0:	b508      	push	{r3, lr}
    if (clockName < SCG_END_OF_CLOCKS)
1ffe1fe2:	2811      	cmp	r0, #17
1ffe1fe4:	d905      	bls.n	1ffe1ff2 <CLOCK_DRV_GetFreq+0x12>
    else if (clockName < SIM_END_OF_CLOCKS)
1ffe1fe6:	282b      	cmp	r0, #43	; 0x2b
1ffe1fe8:	d906      	bls.n	1ffe1ff8 <CLOCK_DRV_GetFreq+0x18>
    else if (clockName < PCC_END_OF_CLOCKS)
1ffe1fea:	285a      	cmp	r0, #90	; 0x5a
1ffe1fec:	d907      	bls.n	1ffe1ffe <CLOCK_DRV_GetFreq+0x1e>
        returnCode = STATUS_UNSUPPORTED;
1ffe1fee:	2004      	movs	r0, #4
1ffe1ff0:	e001      	b.n	1ffe1ff6 <CLOCK_DRV_GetFreq+0x16>
        returnCode = CLOCK_SYS_GetScgClockFreq(clockName, frequency);
1ffe1ff2:	f7ff fd6b 	bl	1ffe1acc <CLOCK_SYS_GetScgClockFreq>
}
1ffe1ff6:	bd08      	pop	{r3, pc}
        returnCode = CLOCK_SYS_GetSimClockFreq(clockName, frequency);
1ffe1ff8:	f7ff fe64 	bl	1ffe1cc4 <CLOCK_SYS_GetSimClockFreq>
1ffe1ffc:	e7fb      	b.n	1ffe1ff6 <CLOCK_DRV_GetFreq+0x16>
        returnCode = CLOCK_SYS_GetPccClockFreq(clockName, frequency);
1ffe1ffe:	f7ff ff77 	bl	1ffe1ef0 <CLOCK_SYS_GetPccClockFreq>
1ffe2002:	e7f8      	b.n	1ffe1ff6 <CLOCK_DRV_GetFreq+0x16>

1ffe2004 <CLOCK_SYS_Init>:
 *END**************************************************************************/
status_t CLOCK_SYS_Init(clock_manager_user_config_t const **clockConfigsPtr,
                              uint8_t configsNumber,
                              clock_manager_callback_user_config_t **callbacksPtr,
                              uint8_t callbacksNumber)
{
1ffe2004:	b410      	push	{r4}
    DEV_ASSERT(clockConfigsPtr != NULL);
    DEV_ASSERT(callbacksPtr != NULL);

    g_clockState.configTable     = clockConfigsPtr;
1ffe2006:	4c04      	ldr	r4, [pc, #16]	; (1ffe2018 <CLOCK_SYS_Init+0x14>)
1ffe2008:	6020      	str	r0, [r4, #0]
    g_clockState.clockConfigNum  = configsNumber;
1ffe200a:	7121      	strb	r1, [r4, #4]
    g_clockState.callbackConfig  = callbacksPtr;
1ffe200c:	60a2      	str	r2, [r4, #8]
    g_clockState.callbackNum     = callbacksNumber;
1ffe200e:	7323      	strb	r3, [r4, #12]
    /*
     * errorCallbackIndex is the index of the callback which returns error
     * during clock mode switch. If all callbacks return success, then the
     * errorCallbackIndex is callbacksNumber.
     */
    g_clockState.errorCallbackIndex = callbacksNumber;
1ffe2010:	7363      	strb	r3, [r4, #13]

    return STATUS_SUCCESS;
}
1ffe2012:	2000      	movs	r0, #0
1ffe2014:	bc10      	pop	{r4}
1ffe2016:	4770      	bx	lr
1ffe2018:	20000690 	.word	0x20000690

1ffe201c <CLOCK_SYS_GetFreq>:
 * Description   : Wrapper over CLOCK_DRV_GetFreq function. It's part of the old API.
 *
 * Implements CLOCK_SYS_GetFreq_Activity
 *END**************************************************************************/
status_t CLOCK_SYS_GetFreq(clock_names_t clockName, uint32_t *frequency)
{
1ffe201c:	b508      	push	{r3, lr}
    return CLOCK_DRV_GetFreq(clockName,frequency);
1ffe201e:	f7ff ffdf 	bl	1ffe1fe0 <CLOCK_DRV_GetFreq>
}
1ffe2022:	bd08      	pop	{r3, pc}

1ffe2024 <CLOCK_SYS_SetConfiguration>:
 * Description   : Wrapper over CLOCK_DRV_Init function. It's part of the old API.
 *
 * Implements CLOCK_SYS_SetConfiguration_Activity
 *END**************************************************************************/
status_t CLOCK_SYS_SetConfiguration(clock_manager_user_config_t const * config)
{
1ffe2024:	b508      	push	{r3, lr}
    return CLOCK_DRV_Init(config);
1ffe2026:	f7ff ffbd 	bl	1ffe1fa4 <CLOCK_DRV_Init>
}
1ffe202a:	bd08      	pop	{r3, pc}

1ffe202c <CLOCK_SYS_UpdateConfiguration>:
{
1ffe202c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
1ffe2030:	b082      	sub	sp, #8
1ffe2032:	4606      	mov	r6, r0
1ffe2034:	460d      	mov	r5, r1
    notifyStruct.targetClockConfigIndex = targetConfigIndex;
1ffe2036:	f88d 0004 	strb.w	r0, [sp, #4]
    notifyStruct.policy                 = policy;
1ffe203a:	f88d 1005 	strb.w	r1, [sp, #5]
    INT_SYS_DisableIRQGlobal();
1ffe203e:	f000 fb2b 	bl	1ffe2698 <INT_SYS_DisableIRQGlobal>
    g_clockState.errorCallbackIndex = g_clockState.callbackNum;
1ffe2042:	4b3a      	ldr	r3, [pc, #232]	; (1ffe212c <CLOCK_SYS_UpdateConfiguration+0x100>)
1ffe2044:	7b1a      	ldrb	r2, [r3, #12]
1ffe2046:	735a      	strb	r2, [r3, #13]
    notifyStruct.notifyType = CLOCK_MANAGER_NOTIFY_BEFORE;
1ffe2048:	2301      	movs	r3, #1
1ffe204a:	f88d 3006 	strb.w	r3, [sp, #6]
    for (callbackIdx=0; callbackIdx<g_clockState.callbackNum; callbackIdx++)
1ffe204e:	2400      	movs	r4, #0
1ffe2050:	e001      	b.n	1ffe2056 <CLOCK_SYS_UpdateConfiguration+0x2a>
1ffe2052:	3401      	adds	r4, #1
1ffe2054:	b2e4      	uxtb	r4, r4
1ffe2056:	4b35      	ldr	r3, [pc, #212]	; (1ffe212c <CLOCK_SYS_UpdateConfiguration+0x100>)
1ffe2058:	7b1b      	ldrb	r3, [r3, #12]
1ffe205a:	42a3      	cmp	r3, r4
1ffe205c:	d915      	bls.n	1ffe208a <CLOCK_SYS_UpdateConfiguration+0x5e>
        callbackConfig = g_clockState.callbackConfig[callbackIdx];
1ffe205e:	4b33      	ldr	r3, [pc, #204]	; (1ffe212c <CLOCK_SYS_UpdateConfiguration+0x100>)
1ffe2060:	689b      	ldr	r3, [r3, #8]
1ffe2062:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
        if ((callbackConfig) &&
1ffe2066:	2b00      	cmp	r3, #0
1ffe2068:	d0f3      	beq.n	1ffe2052 <CLOCK_SYS_UpdateConfiguration+0x26>
            (callbackConfig->callbackType != CLOCK_MANAGER_CALLBACK_AFTER))
1ffe206a:	791a      	ldrb	r2, [r3, #4]
        if ((callbackConfig) &&
1ffe206c:	2a02      	cmp	r2, #2
1ffe206e:	d0f0      	beq.n	1ffe2052 <CLOCK_SYS_UpdateConfiguration+0x26>
                    (*callbackConfig->callback)(&notifyStruct,
1ffe2070:	681a      	ldr	r2, [r3, #0]
1ffe2072:	6899      	ldr	r1, [r3, #8]
1ffe2074:	a801      	add	r0, sp, #4
1ffe2076:	4790      	blx	r2
            if (STATUS_SUCCESS !=
1ffe2078:	2800      	cmp	r0, #0
1ffe207a:	d0ea      	beq.n	1ffe2052 <CLOCK_SYS_UpdateConfiguration+0x26>
                g_clockState.errorCallbackIndex = callbackIdx;
1ffe207c:	4b2b      	ldr	r3, [pc, #172]	; (1ffe212c <CLOCK_SYS_UpdateConfiguration+0x100>)
1ffe207e:	735c      	strb	r4, [r3, #13]
                if (CLOCK_MANAGER_POLICY_AGREEMENT == policy)
1ffe2080:	2d00      	cmp	r5, #0
1ffe2082:	d1e6      	bne.n	1ffe2052 <CLOCK_SYS_UpdateConfiguration+0x26>
                    ret = STATUS_MCU_NOTIFY_BEFORE_ERROR;
1ffe2084:	f240 1703 	movw	r7, #259	; 0x103
1ffe2088:	e000      	b.n	1ffe208c <CLOCK_SYS_UpdateConfiguration+0x60>
    status_t ret = STATUS_SUCCESS;
1ffe208a:	2700      	movs	r7, #0
    if ((STATUS_SUCCESS == ret) ||
1ffe208c:	b16f      	cbz	r7, 1ffe20aa <CLOCK_SYS_UpdateConfiguration+0x7e>
1ffe208e:	2d01      	cmp	r5, #1
1ffe2090:	d00b      	beq.n	1ffe20aa <CLOCK_SYS_UpdateConfiguration+0x7e>
        if (0U != g_clockState.callbackNum)
1ffe2092:	4b26      	ldr	r3, [pc, #152]	; (1ffe212c <CLOCK_SYS_UpdateConfiguration+0x100>)
1ffe2094:	7b1b      	ldrb	r3, [r3, #12]
1ffe2096:	2b00      	cmp	r3, #0
1ffe2098:	d041      	beq.n	1ffe211e <CLOCK_SYS_UpdateConfiguration+0xf2>
            notifyStruct.notifyType = CLOCK_MANAGER_NOTIFY_RECOVER;
1ffe209a:	2200      	movs	r2, #0
1ffe209c:	f88d 2006 	strb.w	r2, [sp, #6]
            callbackIdx = (callbackIdx == g_clockState.callbackNum) ? (callbackIdx - 1U) : callbackIdx;
1ffe20a0:	42a3      	cmp	r3, r4
1ffe20a2:	d12f      	bne.n	1ffe2104 <CLOCK_SYS_UpdateConfiguration+0xd8>
1ffe20a4:	3c01      	subs	r4, #1
1ffe20a6:	b2e4      	uxtb	r4, r4
1ffe20a8:	e02c      	b.n	1ffe2104 <CLOCK_SYS_UpdateConfiguration+0xd8>
        ret = CLOCK_SYS_SetConfiguration(g_clockState.configTable[targetConfigIndex]);
1ffe20aa:	f8df 8080 	ldr.w	r8, [pc, #128]	; 1ffe212c <CLOCK_SYS_UpdateConfiguration+0x100>
1ffe20ae:	f8d8 3000 	ldr.w	r3, [r8]
1ffe20b2:	f853 0026 	ldr.w	r0, [r3, r6, lsl #2]
1ffe20b6:	f7ff ffb5 	bl	1ffe2024 <CLOCK_SYS_SetConfiguration>
        successfulSetConfig = (STATUS_SUCCESS == ret);
1ffe20ba:	4607      	mov	r7, r0
        g_clockState.curConfigIndex = targetConfigIndex;
1ffe20bc:	f888 6005 	strb.w	r6, [r8, #5]
    if(successfulSetConfig){
1ffe20c0:	2800      	cmp	r0, #0
1ffe20c2:	d1e6      	bne.n	1ffe2092 <CLOCK_SYS_UpdateConfiguration+0x66>
        notifyStruct.notifyType = CLOCK_MANAGER_NOTIFY_AFTER;
1ffe20c4:	2302      	movs	r3, #2
1ffe20c6:	f88d 3006 	strb.w	r3, [sp, #6]
        for (callbackIdx=0; callbackIdx<g_clockState.callbackNum; callbackIdx++)
1ffe20ca:	4604      	mov	r4, r0
1ffe20cc:	e005      	b.n	1ffe20da <CLOCK_SYS_UpdateConfiguration+0xae>
            if (STATUS_SUCCESS != callbackState)
1ffe20ce:	b110      	cbz	r0, 1ffe20d6 <CLOCK_SYS_UpdateConfiguration+0xaa>
                g_clockState.errorCallbackIndex = callbackIdx;
1ffe20d0:	4b16      	ldr	r3, [pc, #88]	; (1ffe212c <CLOCK_SYS_UpdateConfiguration+0x100>)
1ffe20d2:	735c      	strb	r4, [r3, #13]
                if (CLOCK_MANAGER_POLICY_AGREEMENT == policy)
1ffe20d4:	b30d      	cbz	r5, 1ffe211a <CLOCK_SYS_UpdateConfiguration+0xee>
        for (callbackIdx=0; callbackIdx<g_clockState.callbackNum; callbackIdx++)
1ffe20d6:	3401      	adds	r4, #1
1ffe20d8:	b2e4      	uxtb	r4, r4
1ffe20da:	4b14      	ldr	r3, [pc, #80]	; (1ffe212c <CLOCK_SYS_UpdateConfiguration+0x100>)
1ffe20dc:	7b1b      	ldrb	r3, [r3, #12]
1ffe20de:	42a3      	cmp	r3, r4
1ffe20e0:	d91d      	bls.n	1ffe211e <CLOCK_SYS_UpdateConfiguration+0xf2>
            callbackConfig = g_clockState.callbackConfig[callbackIdx];
1ffe20e2:	4b12      	ldr	r3, [pc, #72]	; (1ffe212c <CLOCK_SYS_UpdateConfiguration+0x100>)
1ffe20e4:	689b      	ldr	r3, [r3, #8]
1ffe20e6:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
            if ((callbackConfig) &&
1ffe20ea:	2b00      	cmp	r3, #0
1ffe20ec:	d0ef      	beq.n	1ffe20ce <CLOCK_SYS_UpdateConfiguration+0xa2>
                (callbackConfig->callbackType != CLOCK_MANAGER_CALLBACK_BEFORE))
1ffe20ee:	791a      	ldrb	r2, [r3, #4]
            if ((callbackConfig) &&
1ffe20f0:	2a01      	cmp	r2, #1
1ffe20f2:	d0ec      	beq.n	1ffe20ce <CLOCK_SYS_UpdateConfiguration+0xa2>
                callbackState = (*callbackConfig->callback)(&notifyStruct,
1ffe20f4:	681a      	ldr	r2, [r3, #0]
1ffe20f6:	6899      	ldr	r1, [r3, #8]
1ffe20f8:	a801      	add	r0, sp, #4
1ffe20fa:	4790      	blx	r2
1ffe20fc:	e7e7      	b.n	1ffe20ce <CLOCK_SYS_UpdateConfiguration+0xa2>
                if(callbackIdx == 0U)
1ffe20fe:	b174      	cbz	r4, 1ffe211e <CLOCK_SYS_UpdateConfiguration+0xf2>
                callbackIdx--;
1ffe2100:	3c01      	subs	r4, #1
1ffe2102:	b2e4      	uxtb	r4, r4
                callbackConfig = g_clockState.callbackConfig[callbackIdx];
1ffe2104:	4b09      	ldr	r3, [pc, #36]	; (1ffe212c <CLOCK_SYS_UpdateConfiguration+0x100>)
1ffe2106:	689b      	ldr	r3, [r3, #8]
1ffe2108:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
                if (callbackConfig != NULL)
1ffe210c:	2b00      	cmp	r3, #0
1ffe210e:	d0f6      	beq.n	1ffe20fe <CLOCK_SYS_UpdateConfiguration+0xd2>
                    (void)(*callbackConfig->callback)(&notifyStruct,
1ffe2110:	681a      	ldr	r2, [r3, #0]
1ffe2112:	6899      	ldr	r1, [r3, #8]
1ffe2114:	a801      	add	r0, sp, #4
1ffe2116:	4790      	blx	r2
1ffe2118:	e7f1      	b.n	1ffe20fe <CLOCK_SYS_UpdateConfiguration+0xd2>
                    ret = STATUS_MCU_NOTIFY_AFTER_ERROR;
1ffe211a:	f44f 7782 	mov.w	r7, #260	; 0x104
    INT_SYS_EnableIRQGlobal();
1ffe211e:	f000 faad 	bl	1ffe267c <INT_SYS_EnableIRQGlobal>
}
1ffe2122:	4638      	mov	r0, r7
1ffe2124:	b002      	add	sp, #8
1ffe2126:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
1ffe212a:	bf00      	nop
1ffe212c:	20000690 	.word	0x20000690

1ffe2130 <FTM_DRV_SetSync>:
status_t FTM_DRV_SetSync(uint32_t instance,
                         const ftm_pwm_sync_t * param)
{
    DEV_ASSERT(instance < FTM_INSTANCE_COUNT);
    DEV_ASSERT(param != NULL);
    FTM_Type * ftmBase = g_ftmBase[instance];
1ffe2130:	4b6c      	ldr	r3, [pc, #432]	; (1ffe22e4 <FTM_DRV_SetSync+0x1b4>)
1ffe2132:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    status_t retStatus = STATUS_SUCCESS;
    bool hardwareSync = param->hardwareSync0 || param->hardwareSync1 || param->hardwareSync2;
1ffe2136:	784a      	ldrb	r2, [r1, #1]
1ffe2138:	b94a      	cbnz	r2, 1ffe214e <FTM_DRV_SetSync+0x1e>
1ffe213a:	788a      	ldrb	r2, [r1, #2]
1ffe213c:	2a00      	cmp	r2, #0
1ffe213e:	f040 8095 	bne.w	1ffe226c <FTM_DRV_SetSync+0x13c>
1ffe2142:	78ca      	ldrb	r2, [r1, #3]
1ffe2144:	2a00      	cmp	r2, #0
1ffe2146:	f000 8093 	beq.w	1ffe2270 <FTM_DRV_SetSync+0x140>
1ffe214a:	2201      	movs	r2, #1
1ffe214c:	e000      	b.n	1ffe2150 <FTM_DRV_SetSync+0x20>
1ffe214e:	2201      	movs	r2, #1

    /* Software and hardware triggers are not allowed in the same time */
    if ((param->softwareSync && hardwareSync) || (true != (param->softwareSync || hardwareSync)))
1ffe2150:	7808      	ldrb	r0, [r1, #0]
1ffe2152:	b110      	cbz	r0, 1ffe215a <FTM_DRV_SetSync+0x2a>
1ffe2154:	2a00      	cmp	r2, #0
1ffe2156:	f040 80c1 	bne.w	1ffe22dc <FTM_DRV_SetSync+0x1ac>
1ffe215a:	b910      	cbnz	r0, 1ffe2162 <FTM_DRV_SetSync+0x32>
1ffe215c:	2a00      	cmp	r2, #0
1ffe215e:	f000 80bf 	beq.w	1ffe22e0 <FTM_DRV_SetSync+0x1b0>
    {
        retStatus = STATUS_ERROR;
    }
    else if (param->softwareSync)
1ffe2162:	2800      	cmp	r0, #0
1ffe2164:	f000 8086 	beq.w	1ffe2274 <FTM_DRV_SetSync+0x144>
 *                   - false: The software trigger does not activate OUTMASK register sync
 */
static inline void FTM_DRV_SetOutmaskSoftwareSyncModeCmd(FTM_Type * const ftmBase,
                                                         bool enable)
{
    ftmBase->SYNCONF = (ftmBase->SYNCONF & ~FTM_SYNCONF_SWOM_MASK) | FTM_SYNCONF_SWOM(enable);
1ffe2168:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c
1ffe216c:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
1ffe2170:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
    ftmBase->SYNCONF = (ftmBase->SYNCONF & ~FTM_SYNCONF_SWINVC_MASK) | FTM_SYNCONF_SWINVC(enable);
1ffe2174:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c
1ffe2178:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
1ffe217c:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
    ftmBase->SYNCONF = (ftmBase->SYNCONF & ~FTM_SYNCONF_SWSOC_MASK) | FTM_SYNCONF_SWSOC(enable);
1ffe2180:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c
1ffe2184:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
1ffe2188:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
 *                   - false: The software trigger does not activate FTM MOD, CNTIN and CV registers sync
 */
static inline void FTM_DRV_SetModCntinCvSoftwareSyncModeCmd(FTM_Type * const ftmBase,
                                                            bool enable)
{
    ftmBase->SYNCONF = (ftmBase->SYNCONF & ~FTM_SYNCONF_SWWRBUF_MASK) | FTM_SYNCONF_SWWRBUF(enable);
1ffe218c:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c
1ffe2190:	f442 7200 	orr.w	r2, r2, #512	; 0x200
1ffe2194:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
        /* Configure sync for SWOCTRL register */
        FTM_DRV_SetSwoctrlSoftwareSyncModeCmd(ftmBase, true);
        /* Configure sync for MOD, HCR, CNTIN, and CnV registers */
        FTM_DRV_SetModCntinCvSoftwareSyncModeCmd(ftmBase, true);
        /* Configure synchronization method (waiting next loading point or now) */
        FTM_DRV_SetCounterSoftwareSyncModeCmd(ftmBase, param->syncPoint);
1ffe2198:	7ac8      	ldrb	r0, [r1, #11]
 *                   - false: The software trigger does not activate FTM counter sync
 */
static inline void FTM_DRV_SetCounterSoftwareSyncModeCmd(FTM_Type * const ftmBase,
                                                         ftm_pwm_sync_mode_t update_mode)
{
    ftmBase->SYNCONF = (ftmBase->SYNCONF & ~FTM_SYNCONF_SWRSTCNT_MASK) | FTM_SYNCONF_SWRSTCNT(update_mode);
1ffe219a:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c
1ffe219e:	f422 7280 	bic.w	r2, r2, #256	; 0x100
1ffe21a2:	0200      	lsls	r0, r0, #8
1ffe21a4:	f400 7080 	and.w	r0, r0, #256	; 0x100
1ffe21a8:	4302      	orrs	r2, r0
1ffe21aa:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
 *                   - false: Legacy PWM synchronization is selected
 */
static inline void FTM_DRV_SetPwmSyncModeCmd(FTM_Type * const ftmBase,
                                             bool mode)
{
    ftmBase->SYNCONF = (ftmBase->SYNCONF & ~FTM_SYNCONF_SYNCMODE_MASK) | FTM_SYNCONF_SYNCMODE(mode);
1ffe21ae:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c
1ffe21b2:	f042 0280 	orr.w	r2, r2, #128	; 0x80
1ffe21b6:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
    if (STATUS_SUCCESS == retStatus)
    {
        /* Enhanced PWM sync is used */
        FTM_DRV_SetPwmSyncModeCmd(ftmBase, true);
        /* Configure trigger source for sync */
        FTM_DRV_SetHardwareSyncTriggerSrc(ftmBase, 0U, param->hardwareSync0);
1ffe21ba:	784a      	ldrb	r2, [r1, #1]
    if (enable)
1ffe21bc:	2a00      	cmp	r2, #0
1ffe21be:	d07e      	beq.n	1ffe22be <FTM_DRV_SetSync+0x18e>
        ((ftmBase)->SYNC) |= ((uint32_t)(FTM_SYNC_TRIG0_MASK) << trigger_num);
1ffe21c0:	6d9a      	ldr	r2, [r3, #88]	; 0x58
1ffe21c2:	f042 0210 	orr.w	r2, r2, #16
1ffe21c6:	659a      	str	r2, [r3, #88]	; 0x58
        FTM_DRV_SetHardwareSyncTriggerSrc(ftmBase, 1U, param->hardwareSync1);
1ffe21c8:	788a      	ldrb	r2, [r1, #2]
    if (enable)
1ffe21ca:	2a00      	cmp	r2, #0
1ffe21cc:	d07c      	beq.n	1ffe22c8 <FTM_DRV_SetSync+0x198>
        ((ftmBase)->SYNC) |= ((uint32_t)(FTM_SYNC_TRIG0_MASK) << trigger_num);
1ffe21ce:	6d9a      	ldr	r2, [r3, #88]	; 0x58
1ffe21d0:	f042 0220 	orr.w	r2, r2, #32
1ffe21d4:	659a      	str	r2, [r3, #88]	; 0x58
        FTM_DRV_SetHardwareSyncTriggerSrc(ftmBase, 2U, param->hardwareSync2);
1ffe21d6:	78ca      	ldrb	r2, [r1, #3]
    if (enable)
1ffe21d8:	2a00      	cmp	r2, #0
1ffe21da:	d07a      	beq.n	1ffe22d2 <FTM_DRV_SetSync+0x1a2>
        ((ftmBase)->SYNC) |= ((uint32_t)(FTM_SYNC_TRIG0_MASK) << trigger_num);
1ffe21dc:	6d9a      	ldr	r2, [r3, #88]	; 0x58
1ffe21de:	f042 0240 	orr.w	r2, r2, #64	; 0x40
1ffe21e2:	659a      	str	r2, [r3, #88]	; 0x58
        /* Configure loading points */
        FTM_DRV_SetMaxLoadingCmd(ftmBase, param->maxLoadingPoint);
1ffe21e4:	7908      	ldrb	r0, [r1, #4]
    FTM_RMW_SYNC(ftmBase, FTM_SYNC_CNTMAX_MASK, FTM_SYNC_CNTMAX(enable));
1ffe21e6:	6d9a      	ldr	r2, [r3, #88]	; 0x58
1ffe21e8:	f022 0202 	bic.w	r2, r2, #2
1ffe21ec:	0040      	lsls	r0, r0, #1
1ffe21ee:	f000 0002 	and.w	r0, r0, #2
1ffe21f2:	4302      	orrs	r2, r0
1ffe21f4:	659a      	str	r2, [r3, #88]	; 0x58
        FTM_DRV_SetMinLoadingCmd(ftmBase, param->minLoadingPoint);
1ffe21f6:	7948      	ldrb	r0, [r1, #5]
    FTM_RMW_SYNC(ftmBase, FTM_SYNC_CNTMIN_MASK, FTM_SYNC_CNTMIN(enable));
1ffe21f8:	6d9a      	ldr	r2, [r3, #88]	; 0x58
1ffe21fa:	f022 0201 	bic.w	r2, r2, #1
1ffe21fe:	4302      	orrs	r2, r0
1ffe2200:	659a      	str	r2, [r3, #88]	; 0x58
        /* Configure sync for OUTMASK register */
        FTM_DRV_SetOutmaskPwmSyncModeCmd(ftmBase, (bool)param->maskRegSync);
1ffe2202:	7a0a      	ldrb	r2, [r1, #8]
1ffe2204:	1e10      	subs	r0, r2, #0
1ffe2206:	bf18      	it	ne
1ffe2208:	2001      	movne	r0, #1
    FTM_RMW_SYNC(ftmBase, FTM_SYNC_SYNCHOM_MASK, FTM_SYNC_SYNCHOM(enable));
1ffe220a:	6d9a      	ldr	r2, [r3, #88]	; 0x58
1ffe220c:	f022 0208 	bic.w	r2, r2, #8
1ffe2210:	ea42 02c0 	orr.w	r2, r2, r0, lsl #3
1ffe2214:	659a      	str	r2, [r3, #88]	; 0x58
        /* Configure sync for INVCTRL register */
        FTM_DRV_SetInvctrlPwmSyncModeCmd(ftmBase, param->inverterSync);
1ffe2216:	7988      	ldrb	r0, [r1, #6]
 *                   - false: INVCTRL register is updated at all rising edges of system clock
 */
static inline void FTM_DRV_SetInvctrlPwmSyncModeCmd(FTM_Type * const ftmBase,
                                                    ftm_reg_update_t mode)
{
    ftmBase->SYNCONF = (ftmBase->SYNCONF & ~FTM_SYNCONF_INVC_MASK) | FTM_SYNCONF_INVC(mode);
1ffe2218:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c
1ffe221c:	f022 0210 	bic.w	r2, r2, #16
1ffe2220:	0100      	lsls	r0, r0, #4
1ffe2222:	f000 0010 	and.w	r0, r0, #16
1ffe2226:	4302      	orrs	r2, r0
1ffe2228:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
        /* Configure sync for SWOCTRL register */
        FTM_DRV_SetSwoctrlPwmSyncModeCmd(ftmBase, param->outRegSync);
1ffe222c:	79c8      	ldrb	r0, [r1, #7]
    ftmBase->SYNCONF = (ftmBase->SYNCONF & ~FTM_SYNCONF_SWOC_MASK) | FTM_SYNCONF_SWOC(mode);
1ffe222e:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c
1ffe2232:	f022 0220 	bic.w	r2, r2, #32
1ffe2236:	0140      	lsls	r0, r0, #5
1ffe2238:	f000 0020 	and.w	r0, r0, #32
1ffe223c:	4302      	orrs	r2, r0
1ffe223e:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
        /* Configure sync for MOD, HCR, CNTIN, and CnV registers */
        FTM_DRV_SetCntinPwmSyncModeCmd(ftmBase, param->initCounterSync);
1ffe2242:	7a48      	ldrb	r0, [r1, #9]
 *                   - false: CNTIN register is updated at all rising edges of system clock
 */
static inline void FTM_DRV_SetCntinPwmSyncModeCmd(FTM_Type * const ftmBase,
                                                  ftm_reg_update_t mode)
{
    ftmBase->SYNCONF = (ftmBase->SYNCONF & ~FTM_SYNCONF_CNTINC_MASK) | FTM_SYNCONF_CNTINC(mode);
1ffe2244:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c
1ffe2248:	f022 0204 	bic.w	r2, r2, #4
1ffe224c:	0080      	lsls	r0, r0, #2
1ffe224e:	f000 0004 	and.w	r0, r0, #4
1ffe2252:	4302      	orrs	r2, r0
1ffe2254:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
        /* Configure if FTM clears TRIGj (j=0,1,2) when the hardware trigger j is detected. */
        FTM_DRV_SetHwTriggerSyncModeCmd(ftmBase, param->autoClearTrigger);
1ffe2258:	7a89      	ldrb	r1, [r1, #10]
    ftmBase->SYNCONF = (ftmBase->SYNCONF & ~FTM_SYNCONF_HWTRIGMODE_MASK) | FTM_SYNCONF_HWTRIGMODE(enable);
1ffe225a:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c
1ffe225e:	f022 0201 	bic.w	r2, r2, #1
1ffe2262:	430a      	orrs	r2, r1
1ffe2264:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
}
1ffe2268:	2000      	movs	r0, #0
1ffe226a:	4770      	bx	lr
    bool hardwareSync = param->hardwareSync0 || param->hardwareSync1 || param->hardwareSync2;
1ffe226c:	2201      	movs	r2, #1
1ffe226e:	e76f      	b.n	1ffe2150 <FTM_DRV_SetSync+0x20>
1ffe2270:	2200      	movs	r2, #0
1ffe2272:	e76d      	b.n	1ffe2150 <FTM_DRV_SetSync+0x20>
    ftmBase->SYNCONF = (ftmBase->SYNCONF & ~FTM_SYNCONF_HWOM_MASK) | FTM_SYNCONF_HWOM(enable);
1ffe2274:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c
1ffe2278:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
1ffe227c:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
    ftmBase->SYNCONF = (ftmBase->SYNCONF & ~FTM_SYNCONF_HWINVC_MASK) | FTM_SYNCONF_HWINVC(enable);
1ffe2280:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c
1ffe2284:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
1ffe2288:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
    ftmBase->SYNCONF = (ftmBase->SYNCONF & ~FTM_SYNCONF_HWSOC_MASK) | FTM_SYNCONF_HWSOC(enable);
1ffe228c:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c
1ffe2290:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
1ffe2294:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
    ftmBase->SYNCONF = (ftmBase->SYNCONF & ~FTM_SYNCONF_HWWRBUF_MASK) | FTM_SYNCONF_HWWRBUF(enable);
1ffe2298:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c
1ffe229c:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
1ffe22a0:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
        FTM_DRV_SetCounterHardwareSyncModeCmd(ftmBase, (bool)param->syncPoint);
1ffe22a4:	7aca      	ldrb	r2, [r1, #11]
1ffe22a6:	1e10      	subs	r0, r2, #0
1ffe22a8:	bf18      	it	ne
1ffe22aa:	2001      	movne	r0, #1
    ftmBase->SYNCONF = (ftmBase->SYNCONF & ~FTM_SYNCONF_HWRSTCNT_MASK) | FTM_SYNCONF_HWRSTCNT(enable);
1ffe22ac:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c
1ffe22b0:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
1ffe22b4:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
1ffe22b8:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
    if (STATUS_SUCCESS == retStatus)
1ffe22bc:	e777      	b.n	1ffe21ae <FTM_DRV_SetSync+0x7e>
        ((ftmBase)->SYNC) &= ~((uint32_t)(FTM_SYNC_TRIG0_MASK) << trigger_num);
1ffe22be:	6d9a      	ldr	r2, [r3, #88]	; 0x58
1ffe22c0:	f022 0210 	bic.w	r2, r2, #16
1ffe22c4:	659a      	str	r2, [r3, #88]	; 0x58
1ffe22c6:	e77f      	b.n	1ffe21c8 <FTM_DRV_SetSync+0x98>
1ffe22c8:	6d9a      	ldr	r2, [r3, #88]	; 0x58
1ffe22ca:	f022 0220 	bic.w	r2, r2, #32
1ffe22ce:	659a      	str	r2, [r3, #88]	; 0x58
1ffe22d0:	e781      	b.n	1ffe21d6 <FTM_DRV_SetSync+0xa6>
1ffe22d2:	6d9a      	ldr	r2, [r3, #88]	; 0x58
1ffe22d4:	f022 0240 	bic.w	r2, r2, #64	; 0x40
1ffe22d8:	659a      	str	r2, [r3, #88]	; 0x58
1ffe22da:	e783      	b.n	1ffe21e4 <FTM_DRV_SetSync+0xb4>
        retStatus = STATUS_ERROR;
1ffe22dc:	2001      	movs	r0, #1
1ffe22de:	4770      	bx	lr
1ffe22e0:	2001      	movs	r0, #1
    }

    return retStatus;
}
1ffe22e2:	4770      	bx	lr
1ffe22e4:	1ffe36c8 	.word	0x1ffe36c8

1ffe22e8 <FTM_DRV_ClearStatusFlags>:
 *END**************************************************************************/
void FTM_DRV_ClearStatusFlags(uint32_t instance,
                              uint32_t flagMask)
{
    DEV_ASSERT(instance < FTM_INSTANCE_COUNT);
    FTM_Type * ftmBase = g_ftmBase[instance];
1ffe22e8:	4b22      	ldr	r3, [pc, #136]	; (1ffe2374 <FTM_DRV_ClearStatusFlags+0x8c>)
1ffe22ea:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
    uint32_t chnlMask = (flagMask & 0x000000FFU);
1ffe22ee:	b2ca      	uxtb	r2, r1
    uint8_t channel = 0U;

    /* Clear the timer overflow flag by writing a 0 to the bit while it is set */
    if ((flagMask & (uint32_t)FTM_TIME_OVER_FLOW_FLAG) != 0x0U)
1ffe22f0:	f411 7f00 	tst.w	r1, #512	; 0x200
1ffe22f4:	d004      	beq.n	1ffe2300 <FTM_DRV_ClearStatusFlags+0x18>
    FTM_RMW_SC(ftmBase, FTM_SC_TOF_MASK, FTM_SC_TOF(0U));
1ffe22f6:	6803      	ldr	r3, [r0, #0]
1ffe22f8:	f423 7300 	bic.w	r3, r3, #512	; 0x200
1ffe22fc:	6003      	str	r3, [r0, #0]
    ftmBase->SC;
1ffe22fe:	6803      	ldr	r3, [r0, #0]
    {
        FTM_DRV_ClearTimerOverflow(ftmBase);
    }

    /* Clear fault flag by writing a 0 to the bit while it is set */
    if ((flagMask & (uint32_t)FTM_FAULT_FLAG) != 0x0U)
1ffe2300:	f411 7f80 	tst.w	r1, #256	; 0x100
1ffe2304:	d110      	bne.n	1ffe2328 <FTM_DRV_ClearStatusFlags+0x40>
    {
        FTM_DRV_ClearFaultsIsr(ftmBase);
    }

    /* Check reload flag by writing a 0 to the bit while it is set */
    if ((flagMask & (uint32_t)FTM_RELOAD_FLAG) != 0x0U)
1ffe2306:	f411 6f80 	tst.w	r1, #1024	; 0x400
1ffe230a:	d004      	beq.n	1ffe2316 <FTM_DRV_ClearStatusFlags+0x2e>
    FTM_RMW_SC(ftmBase, FTM_SC_RF_MASK, FTM_SC_RF(0U));
1ffe230c:	6803      	ldr	r3, [r0, #0]
1ffe230e:	f023 0380 	bic.w	r3, r3, #128	; 0x80
1ffe2312:	6003      	str	r3, [r0, #0]
    ftmBase->SC;
1ffe2314:	6803      	ldr	r3, [r0, #0]
    {
        FTM_DRV_ClearReloadFlag(ftmBase);
    }

    /* Clear channel trigger flag */
    if ((flagMask & (uint32_t)FTM_CHANNEL_TRIGGER_FLAG) != 0x0U)
1ffe2316:	f411 6f00 	tst.w	r1, #2048	; 0x800
1ffe231a:	d003      	beq.n	1ffe2324 <FTM_DRV_ClearStatusFlags+0x3c>
    FTM_RMW_EXTTRIG_REG(ftmBase, FTM_EXTTRIG_TRIGF_MASK, FTM_EXTTRIG_TRIGF(0UL));
1ffe231c:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
1ffe231e:	f023 0380 	bic.w	r3, r3, #128	; 0x80
1ffe2322:	66c3      	str	r3, [r0, #108]	; 0x6c
{
1ffe2324:	2300      	movs	r3, #0
1ffe2326:	e014      	b.n	1ffe2352 <FTM_DRV_ClearStatusFlags+0x6a>
    FTM_RMW_FMS(ftmBase, FTM_FMS_FAULTF0_MASK | FTM_FMS_FAULTF_MASK, FTM_FMS_FAULTF0(0U) | FTM_FMS_FAULTF(0U));
1ffe2328:	6f43      	ldr	r3, [r0, #116]	; 0x74
1ffe232a:	f023 0381 	bic.w	r3, r3, #129	; 0x81
1ffe232e:	6743      	str	r3, [r0, #116]	; 0x74
    FTM_RMW_FMS(ftmBase, FTM_FMS_FAULTF1_MASK | FTM_FMS_FAULTF_MASK, FTM_FMS_FAULTF1(0U) | FTM_FMS_FAULTF(0U));
1ffe2330:	6f43      	ldr	r3, [r0, #116]	; 0x74
1ffe2332:	f023 0382 	bic.w	r3, r3, #130	; 0x82
1ffe2336:	6743      	str	r3, [r0, #116]	; 0x74
    FTM_RMW_FMS(ftmBase, FTM_FMS_FAULTF2_MASK | FTM_FMS_FAULTF_MASK, FTM_FMS_FAULTF2(0U) | FTM_FMS_FAULTF(0U));
1ffe2338:	6f43      	ldr	r3, [r0, #116]	; 0x74
1ffe233a:	f023 0384 	bic.w	r3, r3, #132	; 0x84
1ffe233e:	6743      	str	r3, [r0, #116]	; 0x74
    FTM_RMW_FMS(ftmBase, FTM_FMS_FAULTF3_MASK | FTM_FMS_FAULTF_MASK, FTM_FMS_FAULTF3(0U) | FTM_FMS_FAULTF(0U));
1ffe2340:	6f43      	ldr	r3, [r0, #116]	; 0x74
1ffe2342:	f023 0388 	bic.w	r3, r3, #136	; 0x88
1ffe2346:	6743      	str	r3, [r0, #116]	; 0x74
    ftmBase->FMS;
1ffe2348:	6f43      	ldr	r3, [r0, #116]	; 0x74
}
1ffe234a:	e7dc      	b.n	1ffe2306 <FTM_DRV_ClearStatusFlags+0x1e>
    {
        if ((chnlMask & 0x00000001U) != 0x0U)
        {
            FTM_DRV_ClearChnEventStatus(ftmBase, channel);
        }
        chnlMask = chnlMask >> 1U;
1ffe234c:	0852      	lsrs	r2, r2, #1
    for (channel = 0U; channel < FEATURE_FTM_CHANNEL_COUNT; channel++)
1ffe234e:	3301      	adds	r3, #1
1ffe2350:	b2db      	uxtb	r3, r3
1ffe2352:	2b07      	cmp	r3, #7
1ffe2354:	d80c      	bhi.n	1ffe2370 <FTM_DRV_ClearStatusFlags+0x88>
        if ((chnlMask & 0x00000001U) != 0x0U)
1ffe2356:	f012 0f01 	tst.w	r2, #1
1ffe235a:	d0f7      	beq.n	1ffe234c <FTM_DRV_ClearStatusFlags+0x64>
static inline void FTM_DRV_ClearChnEventStatus(FTM_Type * const ftmBase,
                                               uint8_t channel)
{
    DEV_ASSERT(channel < FEATURE_FTM_CHANNEL_COUNT);

    ((ftmBase)->STATUS) &= (~(1UL << channel));
1ffe235c:	6d01      	ldr	r1, [r0, #80]	; 0x50
1ffe235e:	f04f 0c01 	mov.w	ip, #1
1ffe2362:	fa0c fc03 	lsl.w	ip, ip, r3
1ffe2366:	ea21 010c 	bic.w	r1, r1, ip
1ffe236a:	6501      	str	r1, [r0, #80]	; 0x50
#ifdef ERRATA_E9005
    /* Read-after-write sequence to guarantee required serialization of memory operations */
    ftmBase->STATUS;
1ffe236c:	6d01      	ldr	r1, [r0, #80]	; 0x50
#endif
}
1ffe236e:	e7ed      	b.n	1ffe234c <FTM_DRV_ClearStatusFlags+0x64>
    }
}
1ffe2370:	4770      	bx	lr
1ffe2372:	bf00      	nop
1ffe2374:	1ffe36c8 	.word	0x1ffe36c8

1ffe2378 <FTM_DRV_GetFrequency>:
 * The returned value is clock sources for the FTM counter.
 *
 * Implements    : FTM_DRV_GetFrequency_Activity
 *END**************************************************************************/
uint32_t FTM_DRV_GetFrequency(uint32_t instance)
{
1ffe2378:	b510      	push	{r4, lr}
1ffe237a:	b082      	sub	sp, #8
    DEV_ASSERT(instance < FTM_INSTANCE_COUNT);
    FTM_Type const * ftmBase = g_ftmBase[instance];
1ffe237c:	4b14      	ldr	r3, [pc, #80]	; (1ffe23d0 <FTM_DRV_GetFrequency+0x58>)
1ffe237e:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    status_t returnCode = STATUS_SUCCESS;
    uint8_t clkPs;
    uint32_t frequency = 0U;
1ffe2382:	2200      	movs	r2, #0
1ffe2384:	9201      	str	r2, [sp, #4]
    const ftm_state_t * state = ftmStatePtr[instance];
1ffe2386:	4a13      	ldr	r2, [pc, #76]	; (1ffe23d4 <FTM_DRV_GetFrequency+0x5c>)
1ffe2388:	f852 2020 	ldr.w	r2, [r2, r0, lsl #2]
    return (uint8_t)((((ftmBase)->SC) & FTM_SC_PS_MASK) >> FTM_SC_PS_SHIFT);
1ffe238c:	681b      	ldr	r3, [r3, #0]
1ffe238e:	f003 0307 	and.w	r3, r3, #7
    DEV_ASSERT(state != NULL);
    clkPs = (uint8_t)(1U << FTM_DRV_GetClockPs(ftmBase));
1ffe2392:	2401      	movs	r4, #1
1ffe2394:	409c      	lsls	r4, r3

    switch (state->ftmClockSource)
1ffe2396:	7813      	ldrb	r3, [r2, #0]
1ffe2398:	2b02      	cmp	r3, #2
1ffe239a:	d00f      	beq.n	1ffe23bc <FTM_DRV_GetFrequency+0x44>
1ffe239c:	2b03      	cmp	r3, #3
1ffe239e:	d007      	beq.n	1ffe23b0 <FTM_DRV_GetFrequency+0x38>
1ffe23a0:	2b01      	cmp	r3, #1
1ffe23a2:	d010      	beq.n	1ffe23c6 <FTM_DRV_GetFrequency+0x4e>

    /* Checks the functional clock of FTM module */
    (void)returnCode;
    DEV_ASSERT(returnCode == STATUS_SUCCESS);

    return (uint32_t)(frequency / clkPs);
1ffe23a4:	b2e4      	uxtb	r4, r4
}
1ffe23a6:	9801      	ldr	r0, [sp, #4]
1ffe23a8:	fbb0 f0f4 	udiv	r0, r0, r4
1ffe23ac:	b002      	add	sp, #8
1ffe23ae:	bd10      	pop	{r4, pc}
            returnCode = CLOCK_SYS_GetFreq(g_ftmExtClockSel[instance], &frequency);
1ffe23b0:	a901      	add	r1, sp, #4
1ffe23b2:	4b09      	ldr	r3, [pc, #36]	; (1ffe23d8 <FTM_DRV_GetFrequency+0x60>)
1ffe23b4:	5c18      	ldrb	r0, [r3, r0]
1ffe23b6:	f7ff fe31 	bl	1ffe201c <CLOCK_SYS_GetFreq>
            break;
1ffe23ba:	e7f3      	b.n	1ffe23a4 <FTM_DRV_GetFrequency+0x2c>
            returnCode = CLOCK_SYS_GetFreq(SIM_RTCCLK_CLK, &frequency);
1ffe23bc:	a901      	add	r1, sp, #4
1ffe23be:	201e      	movs	r0, #30
1ffe23c0:	f7ff fe2c 	bl	1ffe201c <CLOCK_SYS_GetFreq>
            break;
1ffe23c4:	e7ee      	b.n	1ffe23a4 <FTM_DRV_GetFrequency+0x2c>
            returnCode = CLOCK_SYS_GetFreq(CORE_CLK, &frequency);
1ffe23c6:	a901      	add	r1, sp, #4
1ffe23c8:	2000      	movs	r0, #0
1ffe23ca:	f7ff fe27 	bl	1ffe201c <CLOCK_SYS_GetFreq>
            break;
1ffe23ce:	e7e9      	b.n	1ffe23a4 <FTM_DRV_GetFrequency+0x2c>
1ffe23d0:	1ffe36c8 	.word	0x1ffe36c8
1ffe23d4:	200006a4 	.word	0x200006a4
1ffe23d8:	1ffe36e8 	.word	0x1ffe36e8

1ffe23dc <FTM_DRV_Init>:
{
1ffe23dc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
1ffe23de:	4605      	mov	r5, r0
1ffe23e0:	460e      	mov	r6, r1
1ffe23e2:	4614      	mov	r4, r2
    FTM_Type * ftmBase = g_ftmBase[instance];
1ffe23e4:	4b34      	ldr	r3, [pc, #208]	; (1ffe24b8 <FTM_DRV_Init+0xdc>)
1ffe23e6:	f853 7020 	ldr.w	r7, [r3, r0, lsl #2]
    if (ftmStatePtr[instance] != NULL)
1ffe23ea:	4b34      	ldr	r3, [pc, #208]	; (1ffe24bc <FTM_DRV_Init+0xe0>)
1ffe23ec:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
1ffe23f0:	b113      	cbz	r3, 1ffe23f8 <FTM_DRV_Init+0x1c>
        status = STATUS_ERROR;
1ffe23f2:	2401      	movs	r4, #1
}
1ffe23f4:	4620      	mov	r0, r4
1ffe23f6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        state->ftmClockSource = info->ftmClockSource;
1ffe23f8:	7b8b      	ldrb	r3, [r1, #14]
1ffe23fa:	7013      	strb	r3, [r2, #0]
        state->ftmMode = FTM_MODE_NOT_INITIALIZED;
1ffe23fc:	2300      	movs	r3, #0
1ffe23fe:	7053      	strb	r3, [r2, #1]
        state->ftmPeriod = 0U;
1ffe2400:	8093      	strh	r3, [r2, #4]
        ftmStatePtr[instance] = state;
1ffe2402:	4a2e      	ldr	r2, [pc, #184]	; (1ffe24bc <FTM_DRV_Init+0xe0>)
1ffe2404:	f842 4020 	str.w	r4, [r2, r0, lsl #2]
        for (index = 0U; index < FEATURE_FTM_CHANNEL_COUNT; index++)
1ffe2408:	e012      	b.n	1ffe2430 <FTM_DRV_Init+0x54>
            state->measurementResults[index] = 0U;
1ffe240a:	1d19      	adds	r1, r3, #4
1ffe240c:	eb04 0141 	add.w	r1, r4, r1, lsl #1
1ffe2410:	2200      	movs	r2, #0
1ffe2412:	808a      	strh	r2, [r1, #4]
            state->channelsCallbacksParams[index] = NULL;
1ffe2414:	1d99      	adds	r1, r3, #6
1ffe2416:	eb04 0181 	add.w	r1, r4, r1, lsl #2
1ffe241a:	604a      	str	r2, [r1, #4]
            state->channelsCallbacks[index] = NULL;
1ffe241c:	f103 010e 	add.w	r1, r3, #14
1ffe2420:	eb04 0181 	add.w	r1, r4, r1, lsl #2
1ffe2424:	604a      	str	r2, [r1, #4]
            state->enableNotification[index] = false;
1ffe2426:	18e1      	adds	r1, r4, r3
1ffe2428:	f881 205c 	strb.w	r2, [r1, #92]	; 0x5c
        for (index = 0U; index < FEATURE_FTM_CHANNEL_COUNT; index++)
1ffe242c:	3301      	adds	r3, #1
1ffe242e:	b2db      	uxtb	r3, r3
1ffe2430:	2b07      	cmp	r3, #7
1ffe2432:	d9ea      	bls.n	1ffe240a <FTM_DRV_Init+0x2e>
        FTM_DRV_Reset(ftmBase);
1ffe2434:	4638      	mov	r0, r7
1ffe2436:	f000 f851 	bl	1ffe24dc <FTM_DRV_Reset>
        FTM_DRV_InitModule(ftmBase, info->ftmPrescaler);
1ffe243a:	7b71      	ldrb	r1, [r6, #13]
1ffe243c:	4638      	mov	r0, r7
1ffe243e:	f000 f841 	bl	1ffe24c4 <FTM_DRV_InitModule>
        state->ftmSourceClockFrequency = FTM_DRV_GetFrequency(instance);
1ffe2442:	4628      	mov	r0, r5
1ffe2444:	f7ff ff98 	bl	1ffe2378 <FTM_DRV_GetFrequency>
1ffe2448:	60a0      	str	r0, [r4, #8]
        if ((FTM_MODE_EDGE_ALIGNED_PWM == info->ftmMode) || (FTM_MODE_CEN_ALIGNED_PWM == info->ftmMode) || (FTM_MODE_OUTPUT_COMPARE == info->ftmMode) || (FTM_MODE_EDGE_ALIGNED_PWM_AND_INPUT_CAPTURE == info->ftmMode))
1ffe244a:	7b32      	ldrb	r2, [r6, #12]
1ffe244c:	1e93      	subs	r3, r2, #2
1ffe244e:	b2db      	uxtb	r3, r3
1ffe2450:	2b02      	cmp	r3, #2
1ffe2452:	d903      	bls.n	1ffe245c <FTM_DRV_Init+0x80>
1ffe2454:	2a08      	cmp	r2, #8
1ffe2456:	d001      	beq.n	1ffe245c <FTM_DRV_Init+0x80>
    status_t status = STATUS_SUCCESS;
1ffe2458:	2400      	movs	r4, #0
1ffe245a:	e004      	b.n	1ffe2466 <FTM_DRV_Init+0x8a>
            status = FTM_DRV_SetSync(instance, &(info->syncMethod));
1ffe245c:	4631      	mov	r1, r6
1ffe245e:	4628      	mov	r0, r5
1ffe2460:	f7ff fe66 	bl	1ffe2130 <FTM_DRV_SetSync>
1ffe2464:	4604      	mov	r4, r0
        FTM_DRV_SetInitTriggerCmd(ftmBase, info->enableInitializationTrigger);
1ffe2466:	7c72      	ldrb	r2, [r6, #17]
    ftmBase->EXTTRIG = (ftmBase->EXTTRIG & ~FTM_EXTTRIG_INITTRIGEN_MASK) | FTM_EXTTRIG_INITTRIGEN(enable);
1ffe2468:	6efb      	ldr	r3, [r7, #108]	; 0x6c
1ffe246a:	f023 0340 	bic.w	r3, r3, #64	; 0x40
1ffe246e:	0192      	lsls	r2, r2, #6
1ffe2470:	f002 0240 	and.w	r2, r2, #64	; 0x40
1ffe2474:	4313      	orrs	r3, r2
1ffe2476:	66fb      	str	r3, [r7, #108]	; 0x6c
        FTM_DRV_SetBdmMode(ftmBase, info->BDMMode);
1ffe2478:	7bf2      	ldrb	r2, [r6, #15]
    FTM_RMW_CONF(ftmBase, FTM_CONF_BDMMODE_MASK, FTM_CONF_BDMMODE(val));
1ffe247a:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
1ffe247e:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
1ffe2482:	0192      	lsls	r2, r2, #6
1ffe2484:	b2d2      	uxtb	r2, r2
1ffe2486:	4313      	orrs	r3, r2
1ffe2488:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
        if (info->isTofIsrEnabled)
1ffe248c:	7c33      	ldrb	r3, [r6, #16]
1ffe248e:	b14b      	cbz	r3, 1ffe24a4 <FTM_DRV_Init+0xc8>
    FTM_RMW_SC(ftmBase, FTM_SC_TOIE_MASK, FTM_SC_TOIE(state));
1ffe2490:	683b      	ldr	r3, [r7, #0]
1ffe2492:	f443 7380 	orr.w	r3, r3, #256	; 0x100
1ffe2496:	603b      	str	r3, [r7, #0]
            INT_SYS_EnableIRQ(g_ftmOverflowIrqId[instance]);
1ffe2498:	4b09      	ldr	r3, [pc, #36]	; (1ffe24c0 <FTM_DRV_Init+0xe4>)
1ffe249a:	f933 0015 	ldrsh.w	r0, [r3, r5, lsl #1]
1ffe249e:	f000 f8d5 	bl	1ffe264c <INT_SYS_EnableIRQ>
1ffe24a2:	e7a7      	b.n	1ffe23f4 <FTM_DRV_Init+0x18>
1ffe24a4:	683b      	ldr	r3, [r7, #0]
1ffe24a6:	f423 7380 	bic.w	r3, r3, #256	; 0x100
1ffe24aa:	603b      	str	r3, [r7, #0]
            INT_SYS_DisableIRQ(g_ftmOverflowIrqId[instance]);
1ffe24ac:	4b04      	ldr	r3, [pc, #16]	; (1ffe24c0 <FTM_DRV_Init+0xe4>)
1ffe24ae:	f933 0015 	ldrsh.w	r0, [r3, r5, lsl #1]
1ffe24b2:	f000 f8d7 	bl	1ffe2664 <INT_SYS_DisableIRQ>
1ffe24b6:	e79d      	b.n	1ffe23f4 <FTM_DRV_Init+0x18>
1ffe24b8:	1ffe36c8 	.word	0x1ffe36c8
1ffe24bc:	200006a4 	.word	0x200006a4
1ffe24c0:	1ffe36f0 	.word	0x1ffe36f0

1ffe24c4 <FTM_DRV_InitModule>:
    FTM_RMW_MODE(ftmBase, FTM_MODE_FTMEN_MASK, FTM_MODE_FTMEN(enable));
1ffe24c4:	6d43      	ldr	r3, [r0, #84]	; 0x54
1ffe24c6:	f043 0301 	orr.w	r3, r3, #1
1ffe24ca:	6543      	str	r3, [r0, #84]	; 0x54
    FTM_RMW_SC(ftmBase, FTM_SC_PS_MASK, FTM_SC_PS(ps));
1ffe24cc:	6803      	ldr	r3, [r0, #0]
1ffe24ce:	f023 0307 	bic.w	r3, r3, #7
1ffe24d2:	f001 0107 	and.w	r1, r1, #7
1ffe24d6:	430b      	orrs	r3, r1
1ffe24d8:	6003      	str	r3, [r0, #0]
                        ftm_clock_ps_t ftmClockPrescaler)
{
    /* Use FTM mode */
    FTM_DRV_Enable(ftmBase, true);
    FTM_DRV_SetClockPs(ftmBase, ftmClockPrescaler);
}
1ffe24da:	4770      	bx	lr

1ffe24dc <FTM_DRV_Reset>:
 * Function Name : FTM_DRV_Reset
 * Description   : Resets the FTM registers. All the register use in the driver should be
 * reset to default value of each register.
 *END**************************************************************************/
void FTM_DRV_Reset(FTM_Type * const ftmBase)
{
1ffe24dc:	b410      	push	{r4}
    uint8_t chnIndex;

    /* WPDIS is set when WPEN bit is read as a 1 and then 1 is written to WPDIS */
    ((ftmBase)->FMS) &= 0U;
1ffe24de:	6f43      	ldr	r3, [r0, #116]	; 0x74
1ffe24e0:	2300      	movs	r3, #0
1ffe24e2:	6743      	str	r3, [r0, #116]	; 0x74
    /* This is the reset value for MODE register. WPDIS bit is set to disable write protection */
    ((ftmBase)->MODE) = 0x00000004U;
1ffe24e4:	2204      	movs	r2, #4
1ffe24e6:	6542      	str	r2, [r0, #84]	; 0x54
    ((ftmBase)->SC) &= 0U;
1ffe24e8:	6802      	ldr	r2, [r0, #0]
1ffe24ea:	6003      	str	r3, [r0, #0]
    ((ftmBase)->CNT) = 0U;
1ffe24ec:	6043      	str	r3, [r0, #4]
    ((ftmBase)->MOD) = 0U;
1ffe24ee:	6083      	str	r3, [r0, #8]
    ((ftmBase)->CNTIN) = 0U;
1ffe24f0:	64c3      	str	r3, [r0, #76]	; 0x4c
    ((ftmBase)->STATUS) &= 0U;
1ffe24f2:	6d02      	ldr	r2, [r0, #80]	; 0x50
1ffe24f4:	6503      	str	r3, [r0, #80]	; 0x50
    ((ftmBase)->SYNC) = 0U;
1ffe24f6:	6583      	str	r3, [r0, #88]	; 0x58
    ((ftmBase)->OUTINIT) = 0U;
1ffe24f8:	65c3      	str	r3, [r0, #92]	; 0x5c
    ((ftmBase)->OUTMASK) = 0U;
1ffe24fa:	6603      	str	r3, [r0, #96]	; 0x60
    ((ftmBase)->COMBINE) = 0U;
1ffe24fc:	6643      	str	r3, [r0, #100]	; 0x64
    ((ftmBase)->DEADTIME) = 0U;
1ffe24fe:	6683      	str	r3, [r0, #104]	; 0x68
    ((ftmBase)->EXTTRIG) &= 0U;
1ffe2500:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
1ffe2502:	66c3      	str	r3, [r0, #108]	; 0x6c
    ((ftmBase)->POL) = 0U;
1ffe2504:	6703      	str	r3, [r0, #112]	; 0x70
    ((ftmBase)->FILTER) = 0U;
1ffe2506:	6783      	str	r3, [r0, #120]	; 0x78
    ((ftmBase)->FLTCTRL) = 0U;
1ffe2508:	67c3      	str	r3, [r0, #124]	; 0x7c
    ((ftmBase)->QDCTRL) = 0U;
1ffe250a:	f8c0 3080 	str.w	r3, [r0, #128]	; 0x80
    ((ftmBase)->CONF) = 0U;
1ffe250e:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
    ((ftmBase)->FLTPOL) = 0U;
1ffe2512:	f8c0 3088 	str.w	r3, [r0, #136]	; 0x88
    ((ftmBase)->SYNCONF) = 0U;
1ffe2516:	f8c0 308c 	str.w	r3, [r0, #140]	; 0x8c
    ((ftmBase)->INVCTRL) = 0U;
1ffe251a:	f8c0 3090 	str.w	r3, [r0, #144]	; 0x90
    ((ftmBase)->SWOCTRL) = 0U;
1ffe251e:	f8c0 3094 	str.w	r3, [r0, #148]	; 0x94
    ((ftmBase)->PWMLOAD) = 0U;
1ffe2522:	f8c0 3098 	str.w	r3, [r0, #152]	; 0x98
    ((ftmBase)->HCR) = 0U;
1ffe2526:	f8c0 309c 	str.w	r3, [r0, #156]	; 0x9c
    #if FEATURE_FTM_HAS_SUPPORTED_DITHERING
        #if (FTM_INSTANCE_COUNT > 2U)
        if ((ftmBase == FTM1) || (ftmBase == FTM2))
1ffe252a:	4b13      	ldr	r3, [pc, #76]	; (1ffe2578 <FTM_DRV_Reset+0x9c>)
1ffe252c:	4298      	cmp	r0, r3
1ffe252e:	d003      	beq.n	1ffe2538 <FTM_DRV_Reset+0x5c>
1ffe2530:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
1ffe2534:	4298      	cmp	r0, r3
1ffe2536:	d102      	bne.n	1ffe253e <FTM_DRV_Reset+0x62>
        #else
        if (ftmBase == FTM1)
        #endif
        {
            ((ftmBase)->MOD_MIRROR) = 0U;
1ffe2538:	2300      	movs	r3, #0
1ffe253a:	f8c0 3200 	str.w	r3, [r0, #512]	; 0x200
{
1ffe253e:	2300      	movs	r3, #0
1ffe2540:	e006      	b.n	1ffe2550 <FTM_DRV_Reset+0x74>
            if ((ftmBase == FTM1) || (ftmBase == FTM2))
            #else
            if (ftmBase == FTM1)
            #endif
            {
                ((ftmBase)->CV_MIRROR[chnIndex]) = 0U;
1ffe2542:	3180      	adds	r1, #128	; 0x80
1ffe2544:	eb00 0181 	add.w	r1, r0, r1, lsl #2
1ffe2548:	2200      	movs	r2, #0
1ffe254a:	604a      	str	r2, [r1, #4]
    for (chnIndex = 0; chnIndex < FEATURE_FTM_CHANNEL_COUNT; chnIndex++)
1ffe254c:	3301      	adds	r3, #1
1ffe254e:	b2db      	uxtb	r3, r3
1ffe2550:	2b07      	cmp	r3, #7
1ffe2552:	d80f      	bhi.n	1ffe2574 <FTM_DRV_Reset+0x98>
        ((ftmBase)->CONTROLS[chnIndex].CnSC) &= 0U;
1ffe2554:	4619      	mov	r1, r3
1ffe2556:	1c5a      	adds	r2, r3, #1
1ffe2558:	eb00 02c2 	add.w	r2, r0, r2, lsl #3
1ffe255c:	6854      	ldr	r4, [r2, #4]
1ffe255e:	2400      	movs	r4, #0
1ffe2560:	6054      	str	r4, [r2, #4]
        ((ftmBase)->CONTROLS[chnIndex].CnV) = 0U;
1ffe2562:	6094      	str	r4, [r2, #8]
            if ((ftmBase == FTM1) || (ftmBase == FTM2))
1ffe2564:	4a04      	ldr	r2, [pc, #16]	; (1ffe2578 <FTM_DRV_Reset+0x9c>)
1ffe2566:	4290      	cmp	r0, r2
1ffe2568:	d0eb      	beq.n	1ffe2542 <FTM_DRV_Reset+0x66>
1ffe256a:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
1ffe256e:	4290      	cmp	r0, r2
1ffe2570:	d1ec      	bne.n	1ffe254c <FTM_DRV_Reset+0x70>
1ffe2572:	e7e6      	b.n	1ffe2542 <FTM_DRV_Reset+0x66>
            }
        #endif
    }
}
1ffe2574:	bc10      	pop	{r4}
1ffe2576:	4770      	bx	lr
1ffe2578:	40039000 	.word	0x40039000

1ffe257c <FTM_DRV_InitCounter>:
 *
 * Implements    : FTM_DRV_InitCounter_Activity
 *END**************************************************************************/
status_t FTM_DRV_InitCounter(uint32_t instance,
                             const ftm_timer_param_t * timer)
{
1ffe257c:	b430      	push	{r4, r5}
    DEV_ASSERT(instance < FTM_INSTANCE_COUNT);
    DEV_ASSERT(timer != NULL);
    DEV_ASSERT((FTM_MODE_UP_TIMER == timer->mode) || (FTM_MODE_UP_DOWN_TIMER == timer->mode));
    FTM_Type * ftmBase = g_ftmBase[instance];
1ffe257e:	4b26      	ldr	r3, [pc, #152]	; (1ffe2618 <FTM_DRV_InitCounter+0x9c>)
1ffe2580:	f853 4020 	ldr.w	r4, [r3, r0, lsl #2]
    ftm_state_t * state = ftmStatePtr[instance];
1ffe2584:	4b25      	ldr	r3, [pc, #148]	; (1ffe261c <FTM_DRV_InitCounter+0xa0>)
1ffe2586:	f853 5020 	ldr.w	r5, [r3, r0, lsl #2]
    status_t retStatus = STATUS_SUCCESS;
    uint8_t channel = 0U;

    if ((NULL != state) && (FTM_MODE_NOT_INITIALIZED == state->ftmMode))
1ffe258a:	2d00      	cmp	r5, #0
1ffe258c:	d040      	beq.n	1ffe2610 <FTM_DRV_InitCounter+0x94>
1ffe258e:	786b      	ldrb	r3, [r5, #1]
1ffe2590:	2b00      	cmp	r3, #0
1ffe2592:	d13f      	bne.n	1ffe2614 <FTM_DRV_InitCounter+0x98>
    FTM_RMW_SC(ftmBase, FTM_SC_CLKS_MASK, FTM_SC_CLKS(clock));
1ffe2594:	6822      	ldr	r2, [r4, #0]
1ffe2596:	f022 0218 	bic.w	r2, r2, #24
1ffe259a:	6022      	str	r2, [r4, #0]
    FTM_RMW_SC(ftmBase, FTM_SC_TOF_MASK, FTM_SC_TOF(0U));
1ffe259c:	6822      	ldr	r2, [r4, #0]
1ffe259e:	f422 7200 	bic.w	r2, r2, #512	; 0x200
1ffe25a2:	6022      	str	r2, [r4, #0]
    ftmBase->SC;
1ffe25a4:	6822      	ldr	r2, [r4, #0]
        /* Disable counter clock */
        FTM_DRV_SetClockSource(ftmBase, FTM_CLOCK_SOURCE_NONE);
        /* Clear the overflow flag */
        FTM_DRV_ClearTimerOverflow(ftmBase);
        /* Set counter initial and maximum values */
        FTM_DRV_SetCounterInitVal(ftmBase, timer->initialValue);
1ffe25a6:	8848      	ldrh	r0, [r1, #2]
    FTM_RMW_CNTIN(ftmBase, FTM_CNTIN_INIT_MASK, FTM_CNTIN_INIT(value));
1ffe25a8:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
1ffe25aa:	0c12      	lsrs	r2, r2, #16
1ffe25ac:	0412      	lsls	r2, r2, #16
1ffe25ae:	4302      	orrs	r2, r0
1ffe25b0:	64e2      	str	r2, [r4, #76]	; 0x4c
        FTM_DRV_SetMod(ftmBase, timer->finalValue);
1ffe25b2:	8888      	ldrh	r0, [r1, #4]
    FTM_RMW_MOD(ftmBase, FTM_MOD_MOD_MASK, FTM_MOD_MOD(value));
1ffe25b4:	68a2      	ldr	r2, [r4, #8]
1ffe25b6:	0c12      	lsrs	r2, r2, #16
1ffe25b8:	0412      	lsls	r2, r2, #16
1ffe25ba:	4302      	orrs	r2, r0
1ffe25bc:	60a2      	str	r2, [r4, #8]
        ((ftmBase)->QDCTRL) &= ~(1UL << FTM_QDCTRL_QUADEN_SHIFT);
1ffe25be:	f8d4 2080 	ldr.w	r2, [r4, #128]	; 0x80
1ffe25c2:	f022 0201 	bic.w	r2, r2, #1
1ffe25c6:	f8c4 2080 	str.w	r2, [r4, #128]	; 0x80
        /* Disable the quadrature decoder mode */
        FTM_DRV_SetQuadDecoderCmd(ftmBase, false);
        /* Use FTM as counter, disable all the channels */
        for (channel = 0U; channel < FEATURE_FTM_CHANNEL_COUNT; channel++)
1ffe25ca:	e00b      	b.n	1ffe25e4 <FTM_DRV_InitCounter+0x68>
    FTM_RMW_CnSCV_REG(ftmBase, channel, FTM_CnSC_ELSA_MASK, FTM_CnSC_ELSA((uint32_t)level & 0x01U));
1ffe25cc:	3301      	adds	r3, #1
1ffe25ce:	eb04 02c3 	add.w	r2, r4, r3, lsl #3
1ffe25d2:	6850      	ldr	r0, [r2, #4]
1ffe25d4:	f020 0004 	bic.w	r0, r0, #4
1ffe25d8:	6050      	str	r0, [r2, #4]
    FTM_RMW_CnSCV_REG(ftmBase, channel, FTM_CnSC_ELSB_MASK, FTM_CnSC_ELSB(((uint32_t)level & 0x02U) >> 1U));
1ffe25da:	6850      	ldr	r0, [r2, #4]
1ffe25dc:	f020 0008 	bic.w	r0, r0, #8
1ffe25e0:	6050      	str	r0, [r2, #4]
1ffe25e2:	b2db      	uxtb	r3, r3
1ffe25e4:	2b07      	cmp	r3, #7
1ffe25e6:	d9f1      	bls.n	1ffe25cc <FTM_DRV_InitCounter+0x50>
        {
            FTM_DRV_SetChnEdgeLevel(ftmBase, channel, 0U);
        }

        /* Check the FTM counter modes */
        if (FTM_MODE_UP_TIMER == timer->mode)
1ffe25e8:	780b      	ldrb	r3, [r1, #0]
1ffe25ea:	2b06      	cmp	r3, #6
1ffe25ec:	d006      	beq.n	1ffe25fc <FTM_DRV_InitCounter+0x80>
        {
            FTM_DRV_SetCpwms(ftmBase, false);
        }
        else if (FTM_MODE_UP_DOWN_TIMER == timer->mode)
1ffe25ee:	2b07      	cmp	r3, #7
1ffe25f0:	d009      	beq.n	1ffe2606 <FTM_DRV_InitCounter+0x8a>
        else
        {
            /* Do nothing */
        }

        state->ftmMode = timer->mode;
1ffe25f2:	780b      	ldrb	r3, [r1, #0]
1ffe25f4:	706b      	strb	r3, [r5, #1]
    status_t retStatus = STATUS_SUCCESS;
1ffe25f6:	2000      	movs	r0, #0
    {
        retStatus = STATUS_ERROR;
    }

    return retStatus;
}
1ffe25f8:	bc30      	pop	{r4, r5}
1ffe25fa:	4770      	bx	lr
    FTM_RMW_SC(ftmBase, FTM_SC_CPWMS_MASK, FTM_SC_CPWMS(mode));
1ffe25fc:	6823      	ldr	r3, [r4, #0]
1ffe25fe:	f023 0320 	bic.w	r3, r3, #32
1ffe2602:	6023      	str	r3, [r4, #0]
}
1ffe2604:	e7f5      	b.n	1ffe25f2 <FTM_DRV_InitCounter+0x76>
    FTM_RMW_SC(ftmBase, FTM_SC_CPWMS_MASK, FTM_SC_CPWMS(mode));
1ffe2606:	6823      	ldr	r3, [r4, #0]
1ffe2608:	f043 0320 	orr.w	r3, r3, #32
1ffe260c:	6023      	str	r3, [r4, #0]
}
1ffe260e:	e7f0      	b.n	1ffe25f2 <FTM_DRV_InitCounter+0x76>
        retStatus = STATUS_ERROR;
1ffe2610:	2001      	movs	r0, #1
1ffe2612:	e7f1      	b.n	1ffe25f8 <FTM_DRV_InitCounter+0x7c>
1ffe2614:	2001      	movs	r0, #1
1ffe2616:	e7ef      	b.n	1ffe25f8 <FTM_DRV_InitCounter+0x7c>
1ffe2618:	1ffe36c8 	.word	0x1ffe36c8
1ffe261c:	200006a4 	.word	0x200006a4

1ffe2620 <FTM_DRV_CounterStart>:
 * Implements    : FTM_DRV_CounterStart_Activity
 *END**************************************************************************/
status_t FTM_DRV_CounterStart(uint32_t instance)
{
    DEV_ASSERT(instance < FTM_INSTANCE_COUNT);
    FTM_Type * ftmBase = g_ftmBase[instance];
1ffe2620:	4b08      	ldr	r3, [pc, #32]	; (1ffe2644 <FTM_DRV_CounterStart+0x24>)
1ffe2622:	f853 1020 	ldr.w	r1, [r3, r0, lsl #2]

    const ftm_state_t * state = ftmStatePtr[instance];
1ffe2626:	4b08      	ldr	r3, [pc, #32]	; (1ffe2648 <FTM_DRV_CounterStart+0x28>)
1ffe2628:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    /* Check the clock source is available for FTM counter */
    DEV_ASSERT(state->ftmSourceClockFrequency > 0U);
    /* Enable counter clock */
    FTM_DRV_SetClockSource(ftmBase, state->ftmClockSource);
1ffe262c:	781a      	ldrb	r2, [r3, #0]
    FTM_RMW_SC(ftmBase, FTM_SC_CLKS_MASK, FTM_SC_CLKS(clock));
1ffe262e:	680b      	ldr	r3, [r1, #0]
1ffe2630:	f023 0318 	bic.w	r3, r3, #24
1ffe2634:	00d2      	lsls	r2, r2, #3
1ffe2636:	f002 0218 	and.w	r2, r2, #24
1ffe263a:	4313      	orrs	r3, r2
1ffe263c:	600b      	str	r3, [r1, #0]

    return STATUS_SUCCESS;
}
1ffe263e:	2000      	movs	r0, #0
1ffe2640:	4770      	bx	lr
1ffe2642:	bf00      	nop
1ffe2644:	1ffe36c8 	.word	0x1ffe36c8
1ffe2648:	200006a4 	.word	0x200006a4

1ffe264c <INT_SYS_EnableIRQ>:
    int32_t dev_irqNumber = (int32_t)irqNumber;
    DEV_ASSERT(0 <= (int32_t)irqNumber);
    DEV_ASSERT(dev_irqNumber <= (int32_t)FEATURE_INTERRUPT_IRQ_MAX);
#endif /*(defined(DEV_ERROR_DETECT) || defined(CUSTOM_DEVASSERT)) */
    /* Enable interrupt */
    S32_NVIC->ISER[(uint32_t)(irqNumber) >> 5U] = (uint32_t)(1UL << ((uint32_t)(irqNumber) & (uint32_t)0x1FU));
1ffe264c:	f000 021f 	and.w	r2, r0, #31
1ffe2650:	0940      	lsrs	r0, r0, #5
1ffe2652:	2301      	movs	r3, #1
1ffe2654:	4093      	lsls	r3, r2
1ffe2656:	4a02      	ldr	r2, [pc, #8]	; (1ffe2660 <INT_SYS_EnableIRQ+0x14>)
1ffe2658:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
    /* Enable routing to current CPU */
    uint16_t cpu_enable = (uint16_t)(1UL << (MSCM->CPXNUM));
    MSCM->IRSPRC[irqNumber] |= cpu_enable;

#endif /* FEATURE_MSCM_HAS_INTERRUPT_ROUTER */
}
1ffe265c:	4770      	bx	lr
1ffe265e:	bf00      	nop
1ffe2660:	e000e100 	.word	0xe000e100

1ffe2664 <INT_SYS_DisableIRQ>:
    int32_t dev_irqNumber = (int32_t)irqNumber;
    DEV_ASSERT(0 <= (int32_t)irqNumber);
    DEV_ASSERT(dev_irqNumber <= (int32_t)FEATURE_INTERRUPT_IRQ_MAX);
#endif /*(defined(DEV_ERROR_DETECT) || defined(CUSTOM_DEVASSERT)) */
    /* Disable interrupt */
    S32_NVIC->ICER[((uint32_t)(irqNumber) >> 5U)] = (uint32_t)(1UL << ((uint32_t)(irqNumber) & (uint32_t)0x1FU));
1ffe2664:	f000 021f 	and.w	r2, r0, #31
1ffe2668:	0940      	lsrs	r0, r0, #5
1ffe266a:	2301      	movs	r3, #1
1ffe266c:	4093      	lsls	r3, r2
1ffe266e:	3020      	adds	r0, #32
1ffe2670:	4a01      	ldr	r2, [pc, #4]	; (1ffe2678 <INT_SYS_DisableIRQ+0x14>)
1ffe2672:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
    uint16_t cpu_enable = (uint16_t)(1UL << (MSCM->CPXNUM));
    MSCM->IRSPRC[irqNumber] &= (uint16_t)~(cpu_enable);

#endif /* FEATURE_MSCM_HAS_INTERRUPT_ROUTER */

}
1ffe2676:	4770      	bx	lr
1ffe2678:	e000e100 	.word	0xe000e100

1ffe267c <INT_SYS_EnableIRQGlobal>:
 *
 *END**************************************************************************/
void INT_SYS_EnableIRQGlobal(void)
{
    /* Check and update */
    if (g_interruptDisableCount > 0)
1ffe267c:	4b05      	ldr	r3, [pc, #20]	; (1ffe2694 <INT_SYS_EnableIRQGlobal+0x18>)
1ffe267e:	681b      	ldr	r3, [r3, #0]
1ffe2680:	2b00      	cmp	r3, #0
1ffe2682:	dd04      	ble.n	1ffe268e <INT_SYS_EnableIRQGlobal+0x12>
    {
        g_interruptDisableCount--;
1ffe2684:	3b01      	subs	r3, #1
1ffe2686:	4a03      	ldr	r2, [pc, #12]	; (1ffe2694 <INT_SYS_EnableIRQGlobal+0x18>)
1ffe2688:	6013      	str	r3, [r2, #0]

        if (g_interruptDisableCount <= 0)
1ffe268a:	2b00      	cmp	r3, #0
1ffe268c:	dd00      	ble.n	1ffe2690 <INT_SYS_EnableIRQGlobal+0x14>
        {
            /* Enable the global interrupt*/
            ENABLE_INTERRUPTS();
        }
    }
}
1ffe268e:	4770      	bx	lr
            ENABLE_INTERRUPTS();
1ffe2690:	b662      	cpsie	i
}
1ffe2692:	e7fc      	b.n	1ffe268e <INT_SYS_EnableIRQGlobal+0x12>
1ffe2694:	200006c4 	.word	0x200006c4

1ffe2698 <INT_SYS_DisableIRQGlobal>:
 *
 *END**************************************************************************/
void INT_SYS_DisableIRQGlobal(void)
{
    /* Disable the global interrupt */
    DISABLE_INTERRUPTS();
1ffe2698:	b672      	cpsid	i

    /* Update counter*/
    g_interruptDisableCount++;
1ffe269a:	4a02      	ldr	r2, [pc, #8]	; (1ffe26a4 <INT_SYS_DisableIRQGlobal+0xc>)
1ffe269c:	6813      	ldr	r3, [r2, #0]
1ffe269e:	3301      	adds	r3, #1
1ffe26a0:	6013      	str	r3, [r2, #0]
}
1ffe26a2:	4770      	bx	lr
1ffe26a4:	200006c4 	.word	0x200006c4

1ffe26a8 <PINS_DRV_Init>:
 *
 * Implements    : PINS_DRV_Init_Activity
 *END**************************************************************************/
status_t PINS_DRV_Init(uint32_t pinCount,
                       const pin_settings_config_t config[])
{
1ffe26a8:	b570      	push	{r4, r5, r6, lr}
1ffe26aa:	4605      	mov	r5, r0
1ffe26ac:	460e      	mov	r6, r1
    uint32_t i;
    for (i = 0U; i < pinCount; i++)
1ffe26ae:	2400      	movs	r4, #0
1ffe26b0:	e006      	b.n	1ffe26c0 <PINS_DRV_Init+0x18>
    {
        PINS_Init(&config[i]);
1ffe26b2:	eb04 0044 	add.w	r0, r4, r4, lsl #1
1ffe26b6:	eb06 00c0 	add.w	r0, r6, r0, lsl #3
1ffe26ba:	f000 f84d 	bl	1ffe2758 <PINS_Init>
    for (i = 0U; i < pinCount; i++)
1ffe26be:	3401      	adds	r4, #1
1ffe26c0:	42ac      	cmp	r4, r5
1ffe26c2:	d3f6      	bcc.n	1ffe26b2 <PINS_DRV_Init+0xa>
    }

    return STATUS_SUCCESS;
}
1ffe26c4:	2000      	movs	r0, #0
1ffe26c6:	bd70      	pop	{r4, r5, r6, pc}

1ffe26c8 <PINS_DRV_SetPinsDirection>:
 *        - 1: corresponding pin is set to output
 */
static inline void PINS_GPIO_SetPinsDirection(GPIO_Type * const base,
                                              pins_channel_type_t pins)
{
    base->PDDR = GPIO_PDDR_PDD(pins);
1ffe26c8:	6141      	str	r1, [r0, #20]
 *END**************************************************************************/
void PINS_DRV_SetPinsDirection(GPIO_Type * const base,
                               pins_channel_type_t pins)
{
    PINS_GPIO_SetPinsDirection(base, pins);
}
1ffe26ca:	4770      	bx	lr

1ffe26cc <PINS_DRV_WritePin>:
static inline void PINS_GPIO_WritePin(GPIO_Type * const base,
                                      pins_channel_type_t pin,
                                      pins_level_type_t value)
{
#if defined(FEATURE_PINS_DRIVER_USING_PORT)
    pins_channel_type_t pinsValues = (pins_channel_type_t)base->PDOR;
1ffe26cc:	6803      	ldr	r3, [r0, #0]
    pinsValues &= (pins_channel_type_t)(~((pins_channel_type_t)1U << pin));
1ffe26ce:	f04f 0c01 	mov.w	ip, #1
1ffe26d2:	fa0c fc01 	lsl.w	ip, ip, r1
1ffe26d6:	ea23 030c 	bic.w	r3, r3, ip
    pinsValues |= (pins_channel_type_t)((pins_channel_type_t)value << pin);
1ffe26da:	fa02 f101 	lsl.w	r1, r2, r1
1ffe26de:	430b      	orrs	r3, r1
    base->PDOR = GPIO_PDOR_PDO(pinsValues);
1ffe26e0:	6003      	str	r3, [r0, #0]
void PINS_DRV_WritePin(GPIO_Type * const base,
                       pins_channel_type_t pin,
                       pins_level_type_t value)
{
    PINS_GPIO_WritePin(base, pin, value);
}
1ffe26e2:	4770      	bx	lr

1ffe26e4 <PINS_DRV_TogglePins>:
 */
static inline void PINS_GPIO_TogglePins(GPIO_Type * const base,
                                        pins_channel_type_t pins)
{
#if defined(FEATURE_PINS_DRIVER_USING_PORT)
    base->PTOR = GPIO_PTOR_PTTO(pins);
1ffe26e4:	60c1      	str	r1, [r0, #12]
 *END**************************************************************************/
void PINS_DRV_TogglePins(GPIO_Type * const base,
                         pins_channel_type_t pins)
{
    PINS_GPIO_TogglePins(base, pins);
}
1ffe26e6:	4770      	bx	lr

1ffe26e8 <PINS_GetAdcInterleaveVal>:
                                         const uint32_t pinPortIdx,
                                         const uint32_t currentVal)
{
    uint32_t adcInterleaveVal = (uint32_t)PIN_ADC_INTERLEAVE_INVALID;
    /* calculate appropriate value to enable or disable in SIM_CHIPCTL[ADC_INTERLEAVE_EN] */
    if ((uint32_t)base == (uint32_t)PORTB)
1ffe26e8:	4b19      	ldr	r3, [pc, #100]	; (1ffe2750 <PINS_GetAdcInterleaveVal+0x68>)
1ffe26ea:	4298      	cmp	r0, r3
1ffe26ec:	d004      	beq.n	1ffe26f8 <PINS_GetAdcInterleaveVal+0x10>
            default:
                /* invalid command */
                break;
        }
    }
    else if ((uint32_t)base == (uint32_t)PORTC)
1ffe26ee:	4b19      	ldr	r3, [pc, #100]	; (1ffe2754 <PINS_GetAdcInterleaveVal+0x6c>)
1ffe26f0:	4298      	cmp	r0, r3
1ffe26f2:	d020      	beq.n	1ffe2736 <PINS_GetAdcInterleaveVal+0x4e>
    uint32_t adcInterleaveVal = (uint32_t)PIN_ADC_INTERLEAVE_INVALID;
1ffe26f4:	20ff      	movs	r0, #255	; 0xff
    else
    {
        /* invalid command */
    }
    return adcInterleaveVal;
}
1ffe26f6:	4770      	bx	lr
        switch (pinPortIdx)
1ffe26f8:	2910      	cmp	r1, #16
1ffe26fa:	d827      	bhi.n	1ffe274c <PINS_GetAdcInterleaveVal+0x64>
1ffe26fc:	e8df f001 	tbb	[pc, r1]
1ffe2700:	26260c09 	.word	0x26260c09
1ffe2704:	26262626 	.word	0x26262626
1ffe2708:	26262626 	.word	0x26262626
1ffe270c:	15120f26 	.word	0x15120f26
1ffe2710:	18          	.byte	0x18
1ffe2711:	00          	.byte	0x00
                adcInterleaveVal = (uint32_t)PIN_ADC_INTERLEAVE_ENABLE0 | currentVal;
1ffe2712:	f042 0001 	orr.w	r0, r2, #1
                break;
1ffe2716:	4770      	bx	lr
                adcInterleaveVal = (uint32_t)PIN_ADC_INTERLEAVE_ENABLE1 | currentVal;
1ffe2718:	f042 0002 	orr.w	r0, r2, #2
                break;
1ffe271c:	4770      	bx	lr
                adcInterleaveVal = (uint32_t)PIN_ADC_INTERLEAVE_ENABLE2 | currentVal;
1ffe271e:	f042 0004 	orr.w	r0, r2, #4
                break;
1ffe2722:	4770      	bx	lr
                adcInterleaveVal = (uint32_t)PIN_ADC_INTERLEAVE_ENABLE3 | currentVal;
1ffe2724:	f042 0008 	orr.w	r0, r2, #8
                break;
1ffe2728:	4770      	bx	lr
                adcInterleaveVal = (uint32_t)PIN_ADC_INTERLEAVE_DISABLE0 & currentVal;
1ffe272a:	f002 000e 	and.w	r0, r2, #14
                break;
1ffe272e:	4770      	bx	lr
                adcInterleaveVal = (uint32_t)PIN_ADC_INTERLEAVE_DISABLE1 & currentVal;
1ffe2730:	f002 000d 	and.w	r0, r2, #13
                break;
1ffe2734:	4770      	bx	lr
        switch (pinPortIdx)
1ffe2736:	b119      	cbz	r1, 1ffe2740 <PINS_GetAdcInterleaveVal+0x58>
1ffe2738:	2901      	cmp	r1, #1
1ffe273a:	d004      	beq.n	1ffe2746 <PINS_GetAdcInterleaveVal+0x5e>
1ffe273c:	20ff      	movs	r0, #255	; 0xff
1ffe273e:	4770      	bx	lr
                adcInterleaveVal = (uint32_t)PIN_ADC_INTERLEAVE_DISABLE2 & currentVal;
1ffe2740:	f002 000b 	and.w	r0, r2, #11
                break;
1ffe2744:	4770      	bx	lr
                adcInterleaveVal = (uint32_t)PIN_ADC_INTERLEAVE_DISABLE3 & currentVal;
1ffe2746:	f002 0007 	and.w	r0, r2, #7
                break;
1ffe274a:	4770      	bx	lr
        switch (pinPortIdx)
1ffe274c:	20ff      	movs	r0, #255	; 0xff
1ffe274e:	4770      	bx	lr
1ffe2750:	4004a000 	.word	0x4004a000
1ffe2754:	4004b000 	.word	0x4004b000

1ffe2758 <PINS_Init>:
 * Description   : This function configures the pins with the options provided
 * in the provided structure.
 *
 *END**************************************************************************/
void PINS_Init(const pin_settings_config_t * config)
{
1ffe2758:	b570      	push	{r4, r5, r6, lr}
1ffe275a:	4604      	mov	r4, r0
    DEV_ASSERT(config->base != NULL);
    DEV_ASSERT((PORT_MUX_AS_GPIO != config->mux) || (config->gpioBase != NULL));
    DEV_ASSERT(config->pinPortIdx < PORT_PCR_COUNT);
    uint32_t regValue = config->base->PCR[config->pinPortIdx];
1ffe275c:	6800      	ldr	r0, [r0, #0]
1ffe275e:	6861      	ldr	r1, [r4, #4]
1ffe2760:	f850 5021 	ldr.w	r5, [r0, r1, lsl #2]
    uint32_t directions;
    uint32_t digitalFilters;
    port_mux_t muxing;

#if FEATURE_PINS_HAS_PULL_SELECTION
    switch (config->pullConfig)
1ffe2764:	7a23      	ldrb	r3, [r4, #8]
1ffe2766:	2b01      	cmp	r3, #1
1ffe2768:	d043      	beq.n	1ffe27f2 <PINS_Init+0x9a>
1ffe276a:	2b02      	cmp	r3, #2
1ffe276c:	d046      	beq.n	1ffe27fc <PINS_Init+0xa4>
1ffe276e:	2b00      	cmp	r3, #0
1ffe2770:	d03c      	beq.n	1ffe27ec <PINS_Init+0x94>
#if FEATURE_PINS_HAS_SLEW_RATE
    regValue &= ~(PORT_PCR_SRE_MASK);
    regValue |= PORT_PCR_SRE(config->rateSelect);
#endif
#if FEATURE_PORT_HAS_PASSIVE_FILTER
    regValue &= ~(PORT_PCR_PFE_MASK);
1ffe2772:	f025 0510 	bic.w	r5, r5, #16
    regValue |= PORT_PCR_PFE(config->passiveFilter);
1ffe2776:	7a62      	ldrb	r2, [r4, #9]
1ffe2778:	0112      	lsls	r2, r2, #4
1ffe277a:	f002 0210 	and.w	r2, r2, #16
1ffe277e:	432a      	orrs	r2, r5
#if FEATURE_PINS_HAS_OPEN_DRAIN
    regValue &= ~(PORT_PCR_ODE_MASK);
    regValue |= PORT_PCR_ODE(config->openDrain);
#endif
#if FEATURE_PINS_HAS_DRIVE_STRENGTH
    regValue &= ~(PORT_PCR_DSE_MASK);
1ffe2780:	f022 0240 	bic.w	r2, r2, #64	; 0x40
    regValue |= PORT_PCR_DSE(config->driveSelect);
1ffe2784:	7aa3      	ldrb	r3, [r4, #10]
1ffe2786:	019b      	lsls	r3, r3, #6
1ffe2788:	f003 0340 	and.w	r3, r3, #64	; 0x40
1ffe278c:	4313      	orrs	r3, r2
#endif
    regValue &= ~(PORT_PCR_MUX_MASK);
1ffe278e:	f423 65e0 	bic.w	r5, r3, #1792	; 0x700
    muxing = config->mux;
1ffe2792:	7ae3      	ldrb	r3, [r4, #11]
#if FEATURE_PINS_HAS_ADC_INTERLEAVE_EN
    if (muxing == PORT_MUX_ADC_INTERLEAVE)
1ffe2794:	2b08      	cmp	r3, #8
1ffe2796:	d034      	beq.n	1ffe2802 <PINS_Init+0xaa>
        }
        /* return real muxing for pin */
        muxing = PORT_PIN_DISABLED;
    }
#endif
    regValue |= PORT_PCR_MUX(muxing);
1ffe2798:	021b      	lsls	r3, r3, #8
1ffe279a:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
1ffe279e:	432b      	orrs	r3, r5
#if FEATURE_PORT_HAS_PIN_CONTROL_LOCK
    regValue &= ~(PORT_PCR_LK_MASK);
1ffe27a0:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
    regValue |= PORT_PCR_LK(config->pinLock);
1ffe27a4:	7b22      	ldrb	r2, [r4, #12]
1ffe27a6:	03d2      	lsls	r2, r2, #15
1ffe27a8:	b292      	uxth	r2, r2
1ffe27aa:	4313      	orrs	r3, r2
#endif
    regValue &= ~(PORT_PCR_IRQC_MASK);
1ffe27ac:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
    regValue |= PORT_PCR_IRQC(config->intConfig);
1ffe27b0:	7b62      	ldrb	r2, [r4, #13]
1ffe27b2:	0412      	lsls	r2, r2, #16
1ffe27b4:	f402 2270 	and.w	r2, r2, #983040	; 0xf0000
1ffe27b8:	4313      	orrs	r3, r2
    if (config->clearIntFlag)
1ffe27ba:	7ba2      	ldrb	r2, [r4, #14]
1ffe27bc:	b10a      	cbz	r2, 1ffe27c2 <PINS_Init+0x6a>
    {
        regValue &= ~(PORT_PCR_ISF_MASK);
        regValue |= PORT_PCR_ISF(1U);
1ffe27be:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
    }

    config->base->PCR[config->pinPortIdx] = regValue;
1ffe27c2:	6822      	ldr	r2, [r4, #0]
1ffe27c4:	6861      	ldr	r1, [r4, #4]
1ffe27c6:	f842 3021 	str.w	r3, [r2, r1, lsl #2]

    /* Read current digital filter of port */
    digitalFilters = (uint32_t)(config->base->DFER);
1ffe27ca:	6821      	ldr	r1, [r4, #0]
1ffe27cc:	f8d1 20c0 	ldr.w	r2, [r1, #192]	; 0xc0
    digitalFilters &= ~(1UL << (config->pinPortIdx));
1ffe27d0:	6860      	ldr	r0, [r4, #4]
1ffe27d2:	2301      	movs	r3, #1
1ffe27d4:	4083      	lsls	r3, r0
1ffe27d6:	ea22 0203 	bic.w	r2, r2, r3
    digitalFilters |= (((uint32_t)(config->digitalFilter)) << (config->pinPortIdx));
1ffe27da:	7be3      	ldrb	r3, [r4, #15]
1ffe27dc:	4083      	lsls	r3, r0
1ffe27de:	4313      	orrs	r3, r2
    /* Write to digital filter enable register */
    config->base->DFER = digitalFilters;
1ffe27e0:	f8c1 30c0 	str.w	r3, [r1, #192]	; 0xc0

    /* If gpioBase address not null setup the direction of pin */
    if (PORT_MUX_AS_GPIO == config->mux)
1ffe27e4:	7ae3      	ldrb	r3, [r4, #11]
1ffe27e6:	2b01      	cmp	r3, #1
1ffe27e8:	d021      	beq.n	1ffe282e <PINS_Init+0xd6>
        }

        /* Configure direction */
        config->gpioBase->PDDR = GPIO_PDDR_PDD(directions);
    }
}
1ffe27ea:	bd70      	pop	{r4, r5, r6, pc}
                regValue &= ~(PORT_PCR_PE_MASK);
1ffe27ec:	f025 0502 	bic.w	r5, r5, #2
            break;
1ffe27f0:	e7bf      	b.n	1ffe2772 <PINS_Init+0x1a>
                regValue &= ~(PORT_PCR_PS_MASK);
1ffe27f2:	f025 0201 	bic.w	r2, r5, #1
                regValue |= PORT_PCR_PE(1U);
1ffe27f6:	f042 0502 	orr.w	r5, r2, #2
            break;
1ffe27fa:	e7ba      	b.n	1ffe2772 <PINS_Init+0x1a>
                regValue |= PORT_PCR_PS(1U);
1ffe27fc:	f045 0503 	orr.w	r5, r5, #3
            break;
1ffe2800:	e7b7      	b.n	1ffe2772 <PINS_Init+0x1a>
        uint32_t chipCtlReg = (SIM->CHIPCTL & SIM_CHIPCTL_ADC_INTERLEAVE_EN_MASK) >> SIM_CHIPCTL_ADC_INTERLEAVE_EN_SHIFT;
1ffe2802:	4b1b      	ldr	r3, [pc, #108]	; (1ffe2870 <PINS_Init+0x118>)
1ffe2804:	685a      	ldr	r2, [r3, #4]
        uint32_t interleaveVal = PINS_GetAdcInterleaveVal(config->base, config->pinPortIdx, chipCtlReg);
1ffe2806:	f002 020f 	and.w	r2, r2, #15
1ffe280a:	f7ff ff6d 	bl	1ffe26e8 <PINS_GetAdcInterleaveVal>
        if (interleaveVal != (uint32_t)PIN_ADC_INTERLEAVE_INVALID)
1ffe280e:	28ff      	cmp	r0, #255	; 0xff
1ffe2810:	d00b      	beq.n	1ffe282a <PINS_Init+0xd2>
            SIM->CHIPCTL &= ~(SIM_CHIPCTL_ADC_INTERLEAVE_EN_MASK);
1ffe2812:	4b17      	ldr	r3, [pc, #92]	; (1ffe2870 <PINS_Init+0x118>)
1ffe2814:	685a      	ldr	r2, [r3, #4]
1ffe2816:	f022 020f 	bic.w	r2, r2, #15
1ffe281a:	605a      	str	r2, [r3, #4]
            SIM->CHIPCTL |= SIM_CHIPCTL_ADC_INTERLEAVE_EN(interleaveVal);
1ffe281c:	685a      	ldr	r2, [r3, #4]
1ffe281e:	f000 000f 	and.w	r0, r0, #15
1ffe2822:	4310      	orrs	r0, r2
1ffe2824:	6058      	str	r0, [r3, #4]
        muxing = PORT_PIN_DISABLED;
1ffe2826:	2300      	movs	r3, #0
1ffe2828:	e7b6      	b.n	1ffe2798 <PINS_Init+0x40>
1ffe282a:	2300      	movs	r3, #0
1ffe282c:	e7b4      	b.n	1ffe2798 <PINS_Init+0x40>
        directions = (uint32_t)(config->gpioBase->PDDR);
1ffe282e:	6921      	ldr	r1, [r4, #16]
1ffe2830:	694a      	ldr	r2, [r1, #20]
        switch (config->direction)
1ffe2832:	7d23      	ldrb	r3, [r4, #20]
1ffe2834:	b133      	cbz	r3, 1ffe2844 <PINS_Init+0xec>
1ffe2836:	2b01      	cmp	r3, #1
1ffe2838:	d00a      	beq.n	1ffe2850 <PINS_Init+0xf8>
        if (config->direction == GPIO_OUTPUT_DIRECTION)
1ffe283a:	2b01      	cmp	r3, #1
1ffe283c:	d00d      	beq.n	1ffe285a <PINS_Init+0x102>
        config->gpioBase->PDDR = GPIO_PDDR_PDD(directions);
1ffe283e:	6923      	ldr	r3, [r4, #16]
1ffe2840:	615a      	str	r2, [r3, #20]
}
1ffe2842:	e7d2      	b.n	1ffe27ea <PINS_Init+0x92>
                directions &= ~(1UL << config->pinPortIdx);
1ffe2844:	6865      	ldr	r5, [r4, #4]
1ffe2846:	2001      	movs	r0, #1
1ffe2848:	40a8      	lsls	r0, r5
1ffe284a:	ea22 0200 	bic.w	r2, r2, r0
                break;
1ffe284e:	e7f4      	b.n	1ffe283a <PINS_Init+0xe2>
                directions |= (1UL << config->pinPortIdx);
1ffe2850:	6865      	ldr	r5, [r4, #4]
1ffe2852:	2001      	movs	r0, #1
1ffe2854:	40a8      	lsls	r0, r5
1ffe2856:	4302      	orrs	r2, r0
                break;
1ffe2858:	e7ef      	b.n	1ffe283a <PINS_Init+0xe2>
            PINS_GPIO_WritePin(config->gpioBase, config->pinPortIdx, config->initValue);
1ffe285a:	6866      	ldr	r6, [r4, #4]
1ffe285c:	7d60      	ldrb	r0, [r4, #21]
    pins_channel_type_t pinsValues = (pins_channel_type_t)base->PDOR;
1ffe285e:	680b      	ldr	r3, [r1, #0]
    pinsValues &= (pins_channel_type_t)(~((pins_channel_type_t)1U << pin));
1ffe2860:	2501      	movs	r5, #1
1ffe2862:	40b5      	lsls	r5, r6
1ffe2864:	ea23 0305 	bic.w	r3, r3, r5
    pinsValues |= (pins_channel_type_t)((pins_channel_type_t)value << pin);
1ffe2868:	40b0      	lsls	r0, r6
1ffe286a:	4303      	orrs	r3, r0
    base->PDOR = GPIO_PDOR_PDO(pinsValues);
1ffe286c:	600b      	str	r3, [r1, #0]
}
1ffe286e:	e7e6      	b.n	1ffe283e <PINS_Init+0xe6>
1ffe2870:	40048000 	.word	0x40048000

1ffe2874 <init_data_bss>:
    extern uint32_t __CUSTOM_ROM[];
    extern uint32_t __CUSTOM_END[];

    /* Data */
    data_ram        = (uint8_t *)__DATA_RAM;
    data_rom        = (uint8_t *)__DATA_ROM;
1ffe2874:	4b21      	ldr	r3, [pc, #132]	; (1ffe28fc <init_data_bss+0x88>)
    data_ram        = (uint8_t *)__DATA_RAM;
1ffe2876:	4922      	ldr	r1, [pc, #136]	; (1ffe2900 <init_data_bss+0x8c>)

#endif

#if !defined(__ARMCC_VERSION)
    /* Copy initialized data from ROM to RAM */
    while (data_rom_end != data_rom)
1ffe2878:	e003      	b.n	1ffe2882 <init_data_bss+0xe>
    {
        *data_ram = *data_rom;
1ffe287a:	f813 2b01 	ldrb.w	r2, [r3], #1
1ffe287e:	f801 2b01 	strb.w	r2, [r1], #1
    while (data_rom_end != data_rom)
1ffe2882:	4a20      	ldr	r2, [pc, #128]	; (1ffe2904 <init_data_bss+0x90>)
1ffe2884:	4293      	cmp	r3, r2
1ffe2886:	d1f8      	bne.n	1ffe287a <init_data_bss+0x6>
    code_rom        = (uint8_t *)__CODE_ROM;
1ffe2888:	4b1f      	ldr	r3, [pc, #124]	; (1ffe2908 <init_data_bss+0x94>)
    code_ram        = (uint8_t *)__CODE_RAM;
1ffe288a:	4920      	ldr	r1, [pc, #128]	; (1ffe290c <init_data_bss+0x98>)
1ffe288c:	e003      	b.n	1ffe2896 <init_data_bss+0x22>
    }

    /* Copy functions from ROM to RAM */
    while (code_rom_end != code_rom)
    {
        *code_ram = *code_rom;
1ffe288e:	f813 2b01 	ldrb.w	r2, [r3], #1
1ffe2892:	f801 2b01 	strb.w	r2, [r1], #1
    while (code_rom_end != code_rom)
1ffe2896:	4a1e      	ldr	r2, [pc, #120]	; (1ffe2910 <init_data_bss+0x9c>)
1ffe2898:	4293      	cmp	r3, r2
1ffe289a:	d1f8      	bne.n	1ffe288e <init_data_bss+0x1a>
    bss_start       = (uint8_t *)__BSS_START;
1ffe289c:	4b1d      	ldr	r3, [pc, #116]	; (1ffe2914 <init_data_bss+0xa0>)
1ffe289e:	e002      	b.n	1ffe28a6 <init_data_bss+0x32>
    }

    /* Clear the zero-initialized data section */
    while(bss_end != bss_start)
    {
        *bss_start = 0;
1ffe28a0:	2200      	movs	r2, #0
1ffe28a2:	f803 2b01 	strb.w	r2, [r3], #1
    while(bss_end != bss_start)
1ffe28a6:	4a1c      	ldr	r2, [pc, #112]	; (1ffe2918 <init_data_bss+0xa4>)
1ffe28a8:	4293      	cmp	r3, r2
1ffe28aa:	d1f9      	bne.n	1ffe28a0 <init_data_bss+0x2c>
    custom_rom      = (uint8_t *)__CUSTOM_ROM;
1ffe28ac:	4b1b      	ldr	r3, [pc, #108]	; (1ffe291c <init_data_bss+0xa8>)
    custom_ram      = CUSTOMSECTION_SECTION_START;
1ffe28ae:	491c      	ldr	r1, [pc, #112]	; (1ffe2920 <init_data_bss+0xac>)
1ffe28b0:	e003      	b.n	1ffe28ba <init_data_bss+0x46>
    }

    /* Copy customsection rom to ram */
    while(custom_rom_end != custom_rom)
    {
        *custom_ram = *custom_rom;
1ffe28b2:	f813 2b01 	ldrb.w	r2, [r3], #1
1ffe28b6:	f801 2b01 	strb.w	r2, [r1], #1
    while(custom_rom_end != custom_rom)
1ffe28ba:	4a1a      	ldr	r2, [pc, #104]	; (1ffe2924 <init_data_bss+0xb0>)
1ffe28bc:	4293      	cmp	r3, r2
1ffe28be:	d1f8      	bne.n	1ffe28b2 <init_data_bss+0x3e>
        }
        /* Point the VTOR to the position of vector table */
         *s_vectors[coreId] = (uint32_t) __VECTOR_RAM;
#else
    /* Check if VECTOR_TABLE copy is needed */
    if (__VECTOR_RAM != __VECTOR_TABLE)
1ffe28c0:	4a19      	ldr	r2, [pc, #100]	; (1ffe2928 <init_data_bss+0xb4>)
1ffe28c2:	4b1a      	ldr	r3, [pc, #104]	; (1ffe292c <init_data_bss+0xb8>)
1ffe28c4:	429a      	cmp	r2, r3
1ffe28c6:	d012      	beq.n	1ffe28ee <init_data_bss+0x7a>
    {
        /* Copy the vector table from ROM to RAM */
        for (n = 0; n < (((uint32_t)__RAM_VECTOR_TABLE_SIZE)/sizeof(uint32_t)); n++)
1ffe28c8:	2300      	movs	r3, #0
1ffe28ca:	e006      	b.n	1ffe28da <init_data_bss+0x66>
        {
            __VECTOR_RAM[n] = __VECTOR_TABLE[n];
1ffe28cc:	4a17      	ldr	r2, [pc, #92]	; (1ffe292c <init_data_bss+0xb8>)
1ffe28ce:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
1ffe28d2:	4a15      	ldr	r2, [pc, #84]	; (1ffe2928 <init_data_bss+0xb4>)
1ffe28d4:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
        for (n = 0; n < (((uint32_t)__RAM_VECTOR_TABLE_SIZE)/sizeof(uint32_t)); n++)
1ffe28d8:	3301      	adds	r3, #1
1ffe28da:	4a15      	ldr	r2, [pc, #84]	; (1ffe2930 <init_data_bss+0xbc>)
1ffe28dc:	ebb3 0f92 	cmp.w	r3, r2, lsr #2
1ffe28e0:	d3f4      	bcc.n	1ffe28cc <init_data_bss+0x58>
        }
        /* Point the VTOR to the position of vector table */
        *s_vectors[coreId] = (uint32_t)__VECTOR_RAM;
1ffe28e2:	4a11      	ldr	r2, [pc, #68]	; (1ffe2928 <init_data_bss+0xb4>)
1ffe28e4:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
1ffe28e8:	f8c3 2d08 	str.w	r2, [r3, #3336]	; 0xd08
1ffe28ec:	4770      	bx	lr
    }
    else
    {
        /* Point the VTOR to the position of vector table */
        *s_vectors[coreId] = (uint32_t)__VECTOR_TABLE;
1ffe28ee:	4a0f      	ldr	r2, [pc, #60]	; (1ffe292c <init_data_bss+0xb8>)
1ffe28f0:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
1ffe28f4:	f8c3 2d08 	str.w	r2, [r3, #3336]	; 0xd08
    }
#endif

}
1ffe28f8:	4770      	bx	lr
1ffe28fa:	bf00      	nop
1ffe28fc:	1ffe3708 	.word	0x1ffe3708
1ffe2900:	20000000 	.word	0x20000000
1ffe2904:	1ffe3708 	.word	0x1ffe3708
1ffe2908:	1ffe3708 	.word	0x1ffe3708
1ffe290c:	1ffe3708 	.word	0x1ffe3708
1ffe2910:	1ffe3708 	.word	0x1ffe3708
1ffe2914:	200001c0 	.word	0x200001c0
1ffe2918:	200006c8 	.word	0x200006c8
1ffe291c:	20000000 	.word	0x20000000
1ffe2920:	20000000 	.word	0x20000000
1ffe2924:	20000000 	.word	0x20000000
1ffe2928:	1ffe0000 	.word	0x1ffe0000
1ffe292c:	1ffe0000 	.word	0x1ffe0000
1ffe2930:	00000000 	.word	0x00000000

1ffe2934 <SystemInit>:
                      /* WDOG DISABLE*/
/**************************************************************************/
  
#if (DISABLE_WDOG)
  /* Write of the WDOG unlock key to CNT register, must be done in order to allow any modifications*/
  WDOG->CNT = (uint32_t ) FEATURE_WDOG_UNLOCK_VALUE;
1ffe2934:	4b08      	ldr	r3, [pc, #32]	; (1ffe2958 <SystemInit+0x24>)
1ffe2936:	4a09      	ldr	r2, [pc, #36]	; (1ffe295c <SystemInit+0x28>)
1ffe2938:	605a      	str	r2, [r3, #4]
  /* The dummy read is used in order to make sure that the WDOG registers will be configured only 
   * after the write of the unlock value was completed. */
  (void)WDOG->CNT;
1ffe293a:	685a      	ldr	r2, [r3, #4]

  /* Initial write of WDOG configuration register:
   * enables support for 32-bit refresh/unlock command write words,
   * clock select from LPO, update enable, watchdog disabled */
  WDOG->CS  = (uint32_t ) ( (1UL << WDOG_CS_CMD32EN_SHIFT)                       |
1ffe293c:	f242 1220 	movw	r2, #8480	; 0x2120
1ffe2940:	601a      	str	r2, [r3, #0]
                            (FEATURE_WDOG_CLK_FROM_LPO << WDOG_CS_CLK_SHIFT)     |
                            (0U << WDOG_CS_EN_SHIFT)                             |
                            (1U << WDOG_CS_UPDATE_SHIFT)                         );
                            
  /* Configure timeout */
  WDOG->TOVAL = (uint32_t )0xFFFF;
1ffe2942:	f64f 72ff 	movw	r2, #65535	; 0xffff
1ffe2946:	609a      	str	r2, [r3, #8]
            /* GRANT ACCESS TO ALL BUS MASTERS IN MPU */
/**************************************************************************/
#if ENABLE_ALL_BUS_MASTERS_IN_MPU
    /* Bus masters 0-2 are already enabled r/w/x in supervisor & user modes after reset */
    /* Enable also bus master 3 (ENET) in S/U modes in default region 0 */
    MPU->RGDAAC[0] |= ( MPU_RGDAAC_M3SM(3)  /* 11b - Same as User mode defined in M3UM */
1ffe2948:	4a05      	ldr	r2, [pc, #20]	; (1ffe2960 <SystemInit+0x2c>)
1ffe294a:	f8d2 3800 	ldr.w	r3, [r2, #2048]	; 0x800
1ffe294e:	f443 03f8 	orr.w	r3, r3, #8126464	; 0x7c0000
1ffe2952:	f8c2 3800 	str.w	r3, [r2, #2048]	; 0x800
                      | MPU_RGDAAC_M3UM(7) /* 111b - r/w/x */ );
#endif /* ENABLE_ALL_BUS_MASTERS_IN_MPU */
}
1ffe2956:	4770      	bx	lr
1ffe2958:	40052000 	.word	0x40052000
1ffe295c:	d928c520 	.word	0xd928c520
1ffe2960:	4000d000 	.word	0x4000d000

1ffe2964 <osEE_cortex_m_system_timer_init>:
{
  if (
    (period != OSEE_CORTEX_X_SYSTICK_RELOAD_S) &&
    (period <= OSEE_CORTEX_X_SYSTICK_RELOAD_M)
  ) {
    OSEE_CORTEX_X_SYSTICK_RELOAD_R = ( period - 1 );
1ffe2964:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
1ffe2968:	4a05      	ldr	r2, [pc, #20]	; (1ffe2980 <osEE_cortex_m_system_timer_init+0x1c>)
1ffe296a:	615a      	str	r2, [r3, #20]
  OSEE_CORTEX_X_SYSTICK_CTRL_R |= OSEE_CORTEX_X_SYSTICK_CTRL_INTEN;
1ffe296c:	691a      	ldr	r2, [r3, #16]
1ffe296e:	f042 0202 	orr.w	r2, r2, #2
1ffe2972:	611a      	str	r2, [r3, #16]
  OSEE_CORTEX_X_SYSTICK_CTRL_R |= (
1ffe2974:	691a      	ldr	r2, [r3, #16]
1ffe2976:	f042 0205 	orr.w	r2, r2, #5
1ffe297a:	611a      	str	r2, [r3, #16]
  osEE_cortex_m_systick_set_period(
    ((OSTICKDURATION / OSEE_KILO) / OSEE_KILO) * (OSEE_CPU_CLOCK / OSEE_KILO)
  );
  osEE_cortex_m_systick_enable_int();
  osEE_cortex_m_systick_start();
}
1ffe297c:	4770      	bx	lr
1ffe297e:	bf00      	nop
1ffe2980:	000752ff 	.word	0x000752ff

1ffe2984 <osEE_cortex_m_system_timer_handler>:

/*
 * System Timer ISR.
 */
ISR2(osEE_cortex_m_system_timer_handler)
{
1ffe2984:	b508      	push	{r3, lr}
  OsEE_CDB * p_cdb = osEE_get_curr_core();

  osEE_counter_increment(p_cdb->p_sys_counter_db);
1ffe2986:	4b02      	ldr	r3, [pc, #8]	; (1ffe2990 <osEE_cortex_m_system_timer_handler+0xc>)
1ffe2988:	68d8      	ldr	r0, [r3, #12]
1ffe298a:	f000 fb0d 	bl	1ffe2fa8 <osEE_counter_increment>
}
1ffe298e:	bd08      	pop	{r3, pc}
1ffe2990:	1ffe3220 	.word	0x1ffe3220

1ffe2994 <WaitSem>:
FUNC(StatusType, OS_CODE)
  WaitSem
(
  VAR(SemRefType, AUTOMATIC) Sem
)
{
1ffe2994:	b5f0      	push	{r4, r5, r6, r7, lr}
1ffe2996:	b083      	sub	sp, #12
  /* Error Value */
  VAR(StatusType, AUTOMATIC)  ev;

  if (Sem == NULL) {
1ffe2998:	4606      	mov	r6, r0
1ffe299a:	b358      	cbz	r0, 1ffe29f4 <WaitSem+0x60>
  osEE_get_curr_task
(
  void
)
{
  return osEE_get_curr_core()->p_ccb->p_curr ;
1ffe299c:	4b16      	ldr	r3, [pc, #88]	; (1ffe29f8 <WaitSem+0x64>)
1ffe299e:	681b      	ldr	r3, [r3, #0]
1ffe29a0:	681d      	ldr	r5, [r3, #0]
 * an IRQ and from within a task. */
OSEE_STATIC_INLINE FUNC(OsEE_reg, OS_CODE) OSEE_ALWAYS_INLINE
osEE_hal_begin_nested_primitive( void )
{
  OsEE_reg flags = 0U;
  OSEE_GET_IPL(flags);
1ffe29a2:	f3ef 8411 	mrs	r4, BASEPRI
  flags >>= OSEE_CORTEX_M_PRIO_SH_BITS;
1ffe29a6:	0923      	lsrs	r3, r4, #4
  if ( (flags == 0x00U) || (flags > OSEE_ISR2_MAX_HW_PRIO) ) {
1ffe29a8:	3b01      	subs	r3, #1
1ffe29aa:	2b07      	cmp	r3, #7
1ffe29ac:	d902      	bls.n	1ffe29b4 <WaitSem+0x20>
    OSEE_SET_IPL(OSEE_ISR2_MAX_HW_PRIO << OSEE_CORTEX_M_PRIO_SH_BITS);
1ffe29ae:	2380      	movs	r3, #128	; 0x80
1ffe29b0:	f383 8811 	msr	BASEPRI, r3
    CONSTP2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA) p_kdb  = osEE_get_kernel();
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_curr = osEE_get_curr_task();
    CONST(OsEE_reg, AUTOMATIC) flags  = osEE_begin_primitive();

    if (p_curr->task_type != OSEE_TASK_TYPE_EXTENDED) {
1ffe29b4:	7c2b      	ldrb	r3, [r5, #16]
1ffe29b6:	2b01      	cmp	r3, #1
1ffe29b8:	d006      	beq.n	1ffe29c8 <WaitSem+0x34>
      ev = E_OS_ACCESS;
1ffe29ba:	2001      	movs	r0, #1
OSEE_STATIC_INLINE FUNC(void, OS_CODE) OSEE_ALWAYS_INLINE
osEE_hal_end_nested_primitive(
  VAR(OsEE_reg, AUTOMATIC)	flag
)
{
  OSEE_SET_IPL(flag << OSEE_CORTEX_M_PRIO_SH_BITS);
1ffe29bc:	f024 040f 	bic.w	r4, r4, #15
1ffe29c0:	f384 8811 	msr	BASEPRI, r4
      ev = E_OK;
    }
    osEE_end_primitive(flags);
  }
  return ev;
}
1ffe29c4:	b003      	add	sp, #12
1ffe29c6:	bdf0      	pop	{r4, r5, r6, r7, pc}
      if (Sem->count != 0U) {
1ffe29c8:	6873      	ldr	r3, [r6, #4]
1ffe29ca:	b11b      	cbz	r3, 1ffe29d4 <WaitSem+0x40>
        --Sem->count;
1ffe29cc:	3b01      	subs	r3, #1
1ffe29ce:	6073      	str	r3, [r6, #4]
      ev = E_OK;
1ffe29d0:	2000      	movs	r0, #0
1ffe29d2:	e7f3      	b.n	1ffe29bc <WaitSem+0x28>
          p_to =  osEE_scheduler_task_block_current(p_kdb, &blocked_sn);
1ffe29d4:	a901      	add	r1, sp, #4
1ffe29d6:	4809      	ldr	r0, [pc, #36]	; (1ffe29fc <WaitSem+0x68>)
1ffe29d8:	f000 fa3a 	bl	1ffe2e50 <osEE_scheduler_task_block_current>
1ffe29dc:	4607      	mov	r7, r0
        (void)osEE_sn_priority_insert(&Sem->blocked_queue, blocked_sn, OSEE_FALSE);
1ffe29de:	2200      	movs	r2, #0
1ffe29e0:	9901      	ldr	r1, [sp, #4]
1ffe29e2:	4630      	mov	r0, r6
1ffe29e4:	f000 f998 	bl	1ffe2d18 <osEE_sn_priority_insert>
        osEE_change_context_from_running(p_curr, p_to);
1ffe29e8:	4639      	mov	r1, r7
1ffe29ea:	4628      	mov	r0, r5
1ffe29ec:	f000 fb06 	bl	1ffe2ffc <osEE_change_context_from_running>
      ev = E_OK;
1ffe29f0:	2000      	movs	r0, #0
1ffe29f2:	e7e3      	b.n	1ffe29bc <WaitSem+0x28>
    ev = E_OS_PARAM_POINTER;
1ffe29f4:	200e      	movs	r0, #14
1ffe29f6:	e7e5      	b.n	1ffe29c4 <WaitSem+0x30>
1ffe29f8:	1ffe3220 	.word	0x1ffe3220
1ffe29fc:	1ffe3248 	.word	0x1ffe3248

1ffe2a00 <PostSem>:
FUNC(StatusType, OS_CODE)
  PostSem
(
  VAR(SemRefType, AUTOMATIC) Sem
)
{
1ffe2a00:	b510      	push	{r4, lr}
  /* Error Value */
  VAR(StatusType, AUTOMATIC)  ev;

  if (Sem == NULL) {
1ffe2a02:	4602      	mov	r2, r0
1ffe2a04:	b1e8      	cbz	r0, 1ffe2a42 <PostSem+0x42>
  OSEE_GET_IPL(flags);
1ffe2a06:	f3ef 8411 	mrs	r4, BASEPRI
  flags >>= OSEE_CORTEX_M_PRIO_SH_BITS;
1ffe2a0a:	0923      	lsrs	r3, r4, #4
  if ( (flags == 0x00U) || (flags > OSEE_ISR2_MAX_HW_PRIO) ) {
1ffe2a0c:	3b01      	subs	r3, #1
1ffe2a0e:	2b07      	cmp	r3, #7
1ffe2a10:	d902      	bls.n	1ffe2a18 <PostSem+0x18>
    OSEE_SET_IPL(OSEE_ISR2_MAX_HW_PRIO << OSEE_CORTEX_M_PRIO_SH_BITS);
1ffe2a12:	2380      	movs	r3, #128	; 0x80
1ffe2a14:	f383 8811 	msr	BASEPRI, r3
  } else {
    CONST(OsEE_reg, AUTOMATIC) flags  = osEE_begin_primitive();
    /* check if the post on the semaphore wakes up someone */
    OSEE_HAL_SPIN_LOCK(&Sem->lock);

    if (Sem->blocked_queue != NULL) {
1ffe2a18:	6811      	ldr	r1, [r2, #0]
1ffe2a1a:	b149      	cbz	r1, 1ffe2a30 <PostSem+0x30>
        p_kdb = osEE_get_kernel();
      CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
        p_sn_released = Sem->blocked_queue;

      /* Remove the head from the blocking queue */
      Sem->blocked_queue = p_sn_released->p_next;
1ffe2a1c:	680b      	ldr	r3, [r1, #0]
1ffe2a1e:	6013      	str	r3, [r2, #0]

      /* Release the TASK (and the SN) */
      is_preemption = osEE_scheduler_task_unblocked(p_kdb, p_sn_released);
1ffe2a20:	4809      	ldr	r0, [pc, #36]	; (1ffe2a48 <PostSem+0x48>)
1ffe2a22:	f000 fa27 	bl	1ffe2e74 <osEE_scheduler_task_unblocked>

      OSEE_HAL_SPIN_UNLOCK(&Sem->lock);

      if (is_preemption) {
1ffe2a26:	b130      	cbz	r0, 1ffe2a36 <PostSem+0x36>
        (void)osEE_scheduler_task_preemption_point(p_kdb);
1ffe2a28:	4807      	ldr	r0, [pc, #28]	; (1ffe2a48 <PostSem+0x48>)
1ffe2a2a:	f000 fa81 	bl	1ffe2f30 <osEE_scheduler_task_preemption_point>
1ffe2a2e:	e002      	b.n	1ffe2a36 <PostSem+0x36>
      }
    } else {
      ++Sem->count;
1ffe2a30:	6853      	ldr	r3, [r2, #4]
1ffe2a32:	3301      	adds	r3, #1
1ffe2a34:	6053      	str	r3, [r2, #4]
  OSEE_SET_IPL(flag << OSEE_CORTEX_M_PRIO_SH_BITS);
1ffe2a36:	f024 040f 	bic.w	r4, r4, #15
1ffe2a3a:	f384 8811 	msr	BASEPRI, r4
      OSEE_HAL_SPIN_UNLOCK(&Sem->lock);
    }
    osEE_end_primitive(flags);
    ev = E_OK;
1ffe2a3e:	2000      	movs	r0, #0
  }

  return ev;
}
1ffe2a40:	bd10      	pop	{r4, pc}
    ev = E_OS_PARAM_POINTER;
1ffe2a42:	200e      	movs	r0, #14
1ffe2a44:	e7fc      	b.n	1ffe2a40 <PostSem+0x40>
1ffe2a46:	bf00      	nop
1ffe2a48:	1ffe3248 	.word	0x1ffe3248

1ffe2a4c <osEE_shutdown_os>:
(
  P2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST) p_cdb,
  VAR(StatusType, AUTOMATIC)                Error
)
{
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
1ffe2a4c:	6803      	ldr	r3, [r0, #0]

  p_ccb->os_status = OSEE_KERNEL_SHUTDOWN;
1ffe2a4e:	2203      	movs	r2, #3
1ffe2a50:	741a      	strb	r2, [r3, #16]
  /* Used to propagate the error to the ShutdownHook */
  p_ccb->last_error = Error;
1ffe2a52:	7499      	strb	r1, [r3, #18]
  OSEE_CLI();
1ffe2a54:	b672      	cpsid	i

  osEE_hal_disableIRQ();

  osEE_shutdown_os_extra();
  osEE_call_shutdown_hook(p_ccb, Error);
  for(;;) {
1ffe2a56:	e7fe      	b.n	1ffe2a56 <osEE_shutdown_os+0xa>

1ffe2a58 <osEE_suspend_all_interrupts>:
  osEE_suspend_all_interrupts
(
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb,
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb
)
{
1ffe2a58:	b508      	push	{r3, lr}
  if (p_ccb->s_isr_all_cnt == 0U) {
1ffe2a5a:	7f0b      	ldrb	r3, [r1, #28]
1ffe2a5c:	b933      	cbnz	r3, 1ffe2a6c <osEE_suspend_all_interrupts+0x14>
  OSEE_GET_ISR(sr);
1ffe2a5e:	f3ef 8210 	mrs	r2, PRIMASK
  OSEE_CLI();
1ffe2a62:	b672      	cpsid	i
    CONST(OsEE_reg, AUTOMATIC) flags = osEE_hal_suspendIRQ();
    p_ccb->prev_s_isr_all_status = flags;
1ffe2a64:	614a      	str	r2, [r1, #20]
    ++p_ccb->s_isr_all_cnt;
1ffe2a66:	3301      	adds	r3, #1
1ffe2a68:	770b      	strb	r3, [r1, #28]
#error Add ProtectionHook call here once it has been implemented
#else
    osEE_shutdown_os(p_cdb, E_OS_SYS_SUSPEND_NESTING_LIMIT);
#endif /* OSEE_HAS_PROTECTIONHOOK */
  }
}
1ffe2a6a:	bd08      	pop	{r3, pc}
  } else if (p_ccb->s_isr_all_cnt < OSEE_MAX_BYTE) {
1ffe2a6c:	2bff      	cmp	r3, #255	; 0xff
1ffe2a6e:	d002      	beq.n	1ffe2a76 <osEE_suspend_all_interrupts+0x1e>
    ++p_ccb->s_isr_all_cnt;
1ffe2a70:	3301      	adds	r3, #1
1ffe2a72:	770b      	strb	r3, [r1, #28]
1ffe2a74:	e7f9      	b.n	1ffe2a6a <osEE_suspend_all_interrupts+0x12>
    osEE_shutdown_os(p_cdb, E_OS_SYS_SUSPEND_NESTING_LIMIT);
1ffe2a76:	2119      	movs	r1, #25
1ffe2a78:	f7ff ffe8 	bl	1ffe2a4c <osEE_shutdown_os>

1ffe2a7c <DisableAllInterrupts>:
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb = p_cdb->p_ccb;
1ffe2a7c:	4b02      	ldr	r3, [pc, #8]	; (1ffe2a88 <DisableAllInterrupts+0xc>)
1ffe2a7e:	681b      	ldr	r3, [r3, #0]
1ffe2a80:	b672      	cpsid	i
  p_ccb->d_isr_all_cnt = 1U;
1ffe2a82:	2201      	movs	r2, #1
1ffe2a84:	779a      	strb	r2, [r3, #30]
}
1ffe2a86:	4770      	bx	lr
1ffe2a88:	1ffe3220 	.word	0x1ffe3220

1ffe2a8c <SuspendAllInterrupts>:
FUNC(void, OS_CODE)
  SuspendAllInterrupts
(
  void
)
{
1ffe2a8c:	b508      	push	{r3, lr}
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb = p_cdb->p_ccb;
1ffe2a8e:	4802      	ldr	r0, [pc, #8]	; (1ffe2a98 <SuspendAllInterrupts+0xc>)

  osEE_orti_trace_service_entry(p_ccb, OSServiceId_SuspendAllInterrupts);

  osEE_stack_monitoring(p_cdb);

  osEE_suspend_all_interrupts(p_cdb, p_ccb);
1ffe2a90:	6801      	ldr	r1, [r0, #0]
1ffe2a92:	f7ff ffe1 	bl	1ffe2a58 <osEE_suspend_all_interrupts>

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_SuspendAllInterrupts);

  return;
}
1ffe2a96:	bd08      	pop	{r3, pc}
1ffe2a98:	1ffe3220 	.word	0x1ffe3220

1ffe2a9c <ResumeAllInterrupts>:
(
  void
)
{
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb = p_cdb->p_ccb;
1ffe2a9c:	4b05      	ldr	r3, [pc, #20]	; (1ffe2ab4 <ResumeAllInterrupts+0x18>)
1ffe2a9e:	681a      	ldr	r2, [r3, #0]

  osEE_orti_trace_service_entry(p_ccb, OSServiceId_ResumeAllInterrupts);

  osEE_stack_monitoring(p_cdb);

  if (p_ccb->s_isr_all_cnt > 0U) {
1ffe2aa0:	7f13      	ldrb	r3, [r2, #28]
1ffe2aa2:	b133      	cbz	r3, 1ffe2ab2 <ResumeAllInterrupts+0x16>
    --p_ccb->s_isr_all_cnt;
1ffe2aa4:	3b01      	subs	r3, #1
1ffe2aa6:	b2db      	uxtb	r3, r3
1ffe2aa8:	7713      	strb	r3, [r2, #28]

    if (p_ccb->s_isr_all_cnt == 0U) {
1ffe2aaa:	b913      	cbnz	r3, 1ffe2ab2 <ResumeAllInterrupts+0x16>
      osEE_hal_resumeIRQ(p_ccb->prev_s_isr_all_status);
1ffe2aac:	6953      	ldr	r3, [r2, #20]
  OSEE_SET_ISR(flags);
1ffe2aae:	f383 8810 	msr	PRIMASK, r3
  }

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_ResumeAllInterrupts);

  return;
}
1ffe2ab2:	4770      	bx	lr
1ffe2ab4:	1ffe3220 	.word	0x1ffe3220

1ffe2ab8 <StartOS>:
FUNC(StatusType, OS_CODE)
  StartOS
(
  VAR(AppModeType, AUTOMATIC) Mode
)
{
1ffe2ab8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
1ffe2abc:	b083      	sub	sp, #12
1ffe2abe:	4606      	mov	r6, r0
  CONST(CoreIdType, AUTOMATIC)           curr_core_id = osEE_get_curr_core_id();
  CONSTP2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_CONST)  p_kdb = osEE_get_kernel();
  CONSTP2VAR(OsEE_KCB, AUTOMATIC, OS_APPL_DATA)   p_kcb = p_kdb->p_kcb;
#endif /* !OSEE_SINGLECORE */
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb = p_cdb->p_ccb;
1ffe2ac0:	4b2f      	ldr	r3, [pc, #188]	; (1ffe2b80 <StartOS+0xc8>)
1ffe2ac2:	681d      	ldr	r5, [r3, #0]
  OSEE_GET_IPL(flags);
1ffe2ac4:	f3ef 8811 	mrs	r8, BASEPRI
  flags >>= OSEE_CORTEX_M_PRIO_SH_BITS;
1ffe2ac8:	ea4f 1318 	mov.w	r3, r8, lsr #4
  if ( (flags == 0x00U) || (flags > OSEE_ISR2_MAX_HW_PRIO) ) {
1ffe2acc:	3b01      	subs	r3, #1
1ffe2ace:	2b07      	cmp	r3, #7
1ffe2ad0:	d902      	bls.n	1ffe2ad8 <StartOS+0x20>
    OSEE_SET_IPL(OSEE_ISR2_MAX_HW_PRIO << OSEE_CORTEX_M_PRIO_SH_BITS);
1ffe2ad2:	2380      	movs	r3, #128	; 0x80
1ffe2ad4:	f383 8811 	msr	BASEPRI, r3
  osEE_orti_trace_service_entry(p_ccb, OSServiceId_StartOS);
#if (defined(OSEE_ALLOW_TASK_MIGRATION))
  osEE_lock_kernel();
#endif /* OSEE_ALLOW_TASK_MIGRATION */

  if (p_ccb->os_status != OSEE_KERNEL_INITIALIZED) {
1ffe2ad8:	7c2b      	ldrb	r3, [r5, #16]
1ffe2ada:	f003 07ff 	and.w	r7, r3, #255	; 0xff
1ffe2ade:	b14b      	cbz	r3, 1ffe2af4 <StartOS+0x3c>
#if (defined(OSEE_ALLOW_TASK_MIGRATION))
    osEE_unlock_kernel();
#endif /* OSEE_ALLOW_TASK_MIGRATION */
    ev = E_OS_ACCESS;
1ffe2ae0:	2701      	movs	r7, #1
      osEE_hal_enableIRQ();
    }
#endif /* OSEE_STARTOS_RETURN || OSEE_API_DYNAMIC */
  }

  if (ev != E_OK) {
1ffe2ae2:	b11f      	cbz	r7, 1ffe2aec <StartOS+0x34>
  OSEE_SET_IPL(flag << OSEE_CORTEX_M_PRIO_SH_BITS);
1ffe2ae4:	f028 080f 	bic.w	r8, r8, #15
1ffe2ae8:	f388 8811 	msr	BASEPRI, r8
    osEE_orti_trace_service_exit(p_ccb, OSServiceId_StartOS);
    osEE_end_primitive(flags);
  }

  return ev;
}
1ffe2aec:	4638      	mov	r0, r7
1ffe2aee:	b003      	add	sp, #12
1ffe2af0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  OsEE_bool const cpu_startos_ok  = osEE_std_cpu_startos();
  if (cpu_startos_ok)
  {
#if (defined(OS_EE_LIB_S32_SDK))
    /* Restore original vector table (offset) (VTOR) */
    OSEE_CORTEX_M_NVIC_VTOR = (OsEE_reg)&__VECTOR_TABLE;
1ffe2af4:	4a23      	ldr	r2, [pc, #140]	; (1ffe2b84 <StartOS+0xcc>)
1ffe2af6:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
1ffe2afa:	f8c3 2d08 	str.w	r2, [r3, #3336]	; 0xd08
#endif	/* OS_EE_ARCH_CORTEX_M_M4F_FPU */
#endif	/* 0 - [GS]: T.B.C. */
#if	(defined(OSEE_HAS_ORTI)) || (defined(OSEE_HAS_STACK_MONITORING))
    osEE_cortex_m_stack_init();
#endif	/* OSEE_HAS_ORTI || OSEE_HAS_STACK_MONITORING */
    osEE_cortex_m_system_init();
1ffe2afe:	f000 faaa 	bl	1ffe3056 <osEE_cortex_m_system_init>
#if	(defined(OSEE_HAS_SYSTEM_TIMER))
    osEE_cortex_m_system_timer_init();
1ffe2b02:	f7ff ff2f 	bl	1ffe2964 <osEE_cortex_m_system_timer_init>
      p_idle_tdb = p_cdb->p_idle_task;
1ffe2b06:	4c1e      	ldr	r4, [pc, #120]	; (1ffe2b80 <StartOS+0xc8>)
1ffe2b08:	68a3      	ldr	r3, [r4, #8]
1ffe2b0a:	9301      	str	r3, [sp, #4]
    p_ccb->os_status                = OSEE_KERNEL_STARTING;
1ffe2b0c:	2301      	movs	r3, #1
1ffe2b0e:	742b      	strb	r3, [r5, #16]
    p_ccb->app_mode                 = real_mode;
1ffe2b10:	746e      	strb	r6, [r5, #17]
  StartupHook();
1ffe2b12:	f7fd fd99 	bl	1ffe0648 <StartupHook>
        p_auto_tdb  = &(*p_cdb->p_autostart_tdb_array)[real_mode];
1ffe2b16:	f8d4 a010 	ldr.w	sl, [r4, #16]
        p_rq        = &p_ccb->rq;
1ffe2b1a:	f105 0b04 	add.w	fp, r5, #4
      tdbsize = p_auto_tdb->tdb_array_size;
1ffe2b1e:	eb0a 03c6 	add.w	r3, sl, r6, lsl #3
1ffe2b22:	f8d3 9004 	ldr.w	r9, [r3, #4]
      for (i = 0U; i < tdbsize; ++i) {
1ffe2b26:	2400      	movs	r4, #0
1ffe2b28:	e012      	b.n	1ffe2b50 <StartOS+0x98>
          p_tdb_to_act = (*p_auto_tdb->p_tdb_ptr_array)[i];
1ffe2b2a:	f85a 3036 	ldr.w	r3, [sl, r6, lsl #3]
1ffe2b2e:	f853 2024 	ldr.w	r2, [r3, r4, lsl #2]
          p_tcb_to_act = p_tdb_to_act->p_tcb;
1ffe2b32:	6893      	ldr	r3, [r2, #8]
        ++p_tcb_to_act->current_num_of_act;
1ffe2b34:	7819      	ldrb	r1, [r3, #0]
1ffe2b36:	3101      	adds	r1, #1
1ffe2b38:	7019      	strb	r1, [r3, #0]
        p_tcb_to_act->status = OSEE_TASK_READY;
1ffe2b3a:	2101      	movs	r1, #1
1ffe2b3c:	7099      	strb	r1, [r3, #2]
  P2VAR(OsEE_SN *, AUTOMATIC, OS_APPL_DATA) pp_first
)
{
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_sn_allocated;

  p_sn_allocated          = (*pp_first);
1ffe2b3e:	68a9      	ldr	r1, [r5, #8]
  (*pp_first)             = p_sn_allocated->p_next;
1ffe2b40:	680b      	ldr	r3, [r1, #0]
1ffe2b42:	60ab      	str	r3, [r5, #8]
  p_sn_allocated->p_next  = NULL;
1ffe2b44:	2300      	movs	r3, #0
1ffe2b46:	600b      	str	r3, [r1, #0]
        (void)osEE_scheduler_rq_insert(
1ffe2b48:	4658      	mov	r0, fp
1ffe2b4a:	f000 f907 	bl	1ffe2d5c <osEE_scheduler_rq_insert>
      for (i = 0U; i < tdbsize; ++i) {
1ffe2b4e:	3401      	adds	r4, #1
1ffe2b50:	454c      	cmp	r4, r9
1ffe2b52:	d3ea      	bcc.n	1ffe2b2a <StartOS+0x72>
    if (p_ccb->os_status == OSEE_KERNEL_STARTING) {
1ffe2b54:	7c2b      	ldrb	r3, [r5, #16]
1ffe2b56:	b2db      	uxtb	r3, r3
1ffe2b58:	2b01      	cmp	r3, #1
1ffe2b5a:	d00d      	beq.n	1ffe2b78 <StartOS+0xc0>
    if (p_ccb->os_status == OSEE_KERNEL_STARTED) {
1ffe2b5c:	7c2b      	ldrb	r3, [r5, #16]
1ffe2b5e:	b2db      	uxtb	r3, r3
1ffe2b60:	2b02      	cmp	r3, #2
1ffe2b62:	d1be      	bne.n	1ffe2ae2 <StartOS+0x2a>
  osEE_idle_task_start
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_idle_tdb
)
{
  osEE_hal_save_ctx_and_ready2stacked(p_idle_tdb, p_idle_tdb->hdb.p_scb,
1ffe2b64:	9c01      	ldr	r4, [sp, #4]
1ffe2b66:	6861      	ldr	r1, [r4, #4]
1ffe2b68:	460a      	mov	r2, r1
1ffe2b6a:	4620      	mov	r0, r4
1ffe2b6c:	f7fd fd1a 	bl	1ffe05a4 <osEE_hal_save_ctx_and_ready2stacked>
      osEE_task_end(p_idle_tdb);
1ffe2b70:	4620      	mov	r0, r4
1ffe2b72:	f000 f916 	bl	1ffe2da2 <osEE_task_end>
1ffe2b76:	e7b4      	b.n	1ffe2ae2 <StartOS+0x2a>
      p_ccb->os_status = OSEE_KERNEL_STARTED;
1ffe2b78:	2302      	movs	r3, #2
1ffe2b7a:	742b      	strb	r3, [r5, #16]
1ffe2b7c:	e7ee      	b.n	1ffe2b5c <StartOS+0xa4>
1ffe2b7e:	bf00      	nop
1ffe2b80:	1ffe3220 	.word	0x1ffe3220
1ffe2b84:	1ffe0000 	.word	0x1ffe0000

1ffe2b88 <ActivateTask>:
FUNC(StatusType, OS_CODE)
  ActivateTask
(
  VAR(TaskType, AUTOMATIC) TaskID
)
{
1ffe2b88:	b570      	push	{r4, r5, r6, lr}
  return (tid < p_kdb->tdb_array_size);
1ffe2b8a:	4b14      	ldr	r3, [pc, #80]	; (1ffe2bdc <ActivateTask+0x54>)
1ffe2b8c:	689b      	ldr	r3, [r3, #8]
  if (p_ccb->os_context > OSEE_TASK_ISR2_CTX)
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
1ffe2b8e:	4298      	cmp	r0, r3
1ffe2b90:	d21f      	bcs.n	1ffe2bd2 <ActivateTask+0x4a>
    ev = E_OS_ID;
  } else
  {
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_tdb_act = (*p_kdb->p_tdb_ptr_array)[TaskID];
1ffe2b92:	4b12      	ldr	r3, [pc, #72]	; (1ffe2bdc <ActivateTask+0x54>)
1ffe2b94:	685b      	ldr	r3, [r3, #4]
1ffe2b96:	f853 6020 	ldr.w	r6, [r3, r0, lsl #2]

    if (p_tdb_act->task_type <= OSEE_TASK_TYPE_EXTENDED) {
1ffe2b9a:	7c33      	ldrb	r3, [r6, #16]
1ffe2b9c:	2b01      	cmp	r3, #1
1ffe2b9e:	d81a      	bhi.n	1ffe2bd6 <ActivateTask+0x4e>
  OSEE_GET_IPL(flags);
1ffe2ba0:	f3ef 8511 	mrs	r5, BASEPRI
  flags >>= OSEE_CORTEX_M_PRIO_SH_BITS;
1ffe2ba4:	092b      	lsrs	r3, r5, #4
  if ( (flags == 0x00U) || (flags > OSEE_ISR2_MAX_HW_PRIO) ) {
1ffe2ba6:	3b01      	subs	r3, #1
1ffe2ba8:	2b07      	cmp	r3, #7
1ffe2baa:	d902      	bls.n	1ffe2bb2 <ActivateTask+0x2a>
    OSEE_SET_IPL(OSEE_ISR2_MAX_HW_PRIO << OSEE_CORTEX_M_PRIO_SH_BITS);
1ffe2bac:	2380      	movs	r3, #128	; 0x80
1ffe2bae:	f383 8811 	msr	BASEPRI, r3
      CONST(OsEE_reg, AUTOMATIC)  flags = osEE_begin_primitive();

      ev = osEE_task_activated(p_tdb_act);
1ffe2bb2:	4630      	mov	r0, r6
1ffe2bb4:	f000 f8ea 	bl	1ffe2d8c <osEE_task_activated>

      if (ev == E_OK) {
1ffe2bb8:	4604      	mov	r4, r0
1ffe2bba:	b128      	cbz	r0, 1ffe2bc8 <ActivateTask+0x40>
  OSEE_SET_IPL(flag << OSEE_CORTEX_M_PRIO_SH_BITS);
1ffe2bbc:	f025 050f 	bic.w	r5, r5, #15
1ffe2bc0:	f385 8811 	msr	BASEPRI, r5
#if (defined(OSEE_HAS_ORTI))
  osEE_orti_trace_service_exit(p_ccb, OSServiceId_ActivateTask);
#endif /* OSEE_HAS_ORTI */

  return ev;
}
1ffe2bc4:	4620      	mov	r0, r4
1ffe2bc6:	bd70      	pop	{r4, r5, r6, pc}
        (void)osEE_scheduler_task_activated(p_kdb, p_tdb_act);
1ffe2bc8:	4631      	mov	r1, r6
1ffe2bca:	4804      	ldr	r0, [pc, #16]	; (1ffe2bdc <ActivateTask+0x54>)
1ffe2bcc:	f000 f918 	bl	1ffe2e00 <osEE_scheduler_task_activated>
1ffe2bd0:	e7f4      	b.n	1ffe2bbc <ActivateTask+0x34>
    ev = E_OS_ID;
1ffe2bd2:	2403      	movs	r4, #3
1ffe2bd4:	e7f6      	b.n	1ffe2bc4 <ActivateTask+0x3c>
      ev = E_OS_ID;
1ffe2bd6:	2403      	movs	r4, #3
1ffe2bd8:	e7f4      	b.n	1ffe2bc4 <ActivateTask+0x3c>
1ffe2bda:	bf00      	nop
1ffe2bdc:	1ffe3248 	.word	0x1ffe3248

1ffe2be0 <osEE_scheduler_task_not_terminated>:
static FUNC(void, OS_CODE)
  osEE_scheduler_task_not_terminated
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_to_term
)
{
1ffe2be0:	b508      	push	{r3, lr}
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)
    p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
    p_ccb = p_cdb->p_ccb;
1ffe2be2:	4b0e      	ldr	r3, [pc, #56]	; (1ffe2c1c <osEE_scheduler_task_not_terminated+0x3c>)
1ffe2be4:	681b      	ldr	r3, [r3, #0]

  /* Reset ISR Counters */
/* [SWS_Os_00239] If a task returns from the entry function without making a
    TerminateTask() or ChainTask() call and interrupts are still disabled,
    the Operating System module shall enable them. */
  p_ccb->s_isr_os_cnt  = 0U;
1ffe2be6:	2200      	movs	r2, #0
1ffe2be8:	775a      	strb	r2, [r3, #29]
  /* I won't re-enable OS Interrupts since I'm going to enter rescheduling
     critical section */
  if (p_ccb->s_isr_all_cnt > 0U) {
1ffe2bea:	7f1a      	ldrb	r2, [r3, #28]
1ffe2bec:	b122      	cbz	r2, 1ffe2bf8 <osEE_scheduler_task_not_terminated+0x18>
    p_ccb->s_isr_all_cnt = 0U;
1ffe2bee:	2200      	movs	r2, #0
1ffe2bf0:	771a      	strb	r2, [r3, #28]
    osEE_hal_resumeIRQ(p_ccb->prev_s_isr_all_status);
1ffe2bf2:	695a      	ldr	r2, [r3, #20]
  OSEE_SET_ISR(flags);
1ffe2bf4:	f382 8810 	msr	PRIMASK, r2
  }
  if (p_ccb->d_isr_all_cnt > 0U) {
1ffe2bf8:	7f9a      	ldrb	r2, [r3, #30]
1ffe2bfa:	b112      	cbz	r2, 1ffe2c02 <osEE_scheduler_task_not_terminated+0x22>
    p_ccb->d_isr_all_cnt = 0U;
1ffe2bfc:	2200      	movs	r2, #0
1ffe2bfe:	779a      	strb	r2, [r3, #30]
  OSEE_SEI();
1ffe2c00:	b662      	cpsie	i
  OSEE_GET_IPL(flags);
1ffe2c02:	f3ef 8311 	mrs	r3, BASEPRI
  flags >>= OSEE_CORTEX_M_PRIO_SH_BITS;
1ffe2c06:	091b      	lsrs	r3, r3, #4
  if ( (flags == 0x00U) || (flags > OSEE_ISR2_MAX_HW_PRIO) ) {
1ffe2c08:	3b01      	subs	r3, #1
1ffe2c0a:	2b07      	cmp	r3, #7
1ffe2c0c:	d902      	bls.n	1ffe2c14 <osEE_scheduler_task_not_terminated+0x34>
    OSEE_SET_IPL(OSEE_ISR2_MAX_HW_PRIO << OSEE_CORTEX_M_PRIO_SH_BITS);
1ffe2c0e:	2380      	movs	r3, #128	; 0x80
1ffe2c10:	f383 8811 	msr	BASEPRI, r3
  osEE_hal_terminate_ctx(p_to_term->hdb.p_scb, kernel_cb);
1ffe2c14:	4902      	ldr	r1, [pc, #8]	; (1ffe2c20 <osEE_scheduler_task_not_terminated+0x40>)
1ffe2c16:	6840      	ldr	r0, [r0, #4]
1ffe2c18:	f7fd fcd2 	bl	1ffe05c0 <osEE_hal_terminate_ctx>
1ffe2c1c:	1ffe3220 	.word	0x1ffe3220
1ffe2c20:	1ffe3065 	.word	0x1ffe3065

1ffe2c24 <osEE_scheduler_task_wrapper_restore>:
  }

#endif /* OSEE_HAS_ORTI */

  /* Set the TASK status to RUNNING. Before calling PreTaskHook */
  p_tdb_to->p_tcb->status = OSEE_TASK_RUNNING;
1ffe2c24:	6883      	ldr	r3, [r0, #8]
1ffe2c26:	2204      	movs	r2, #4
1ffe2c28:	709a      	strb	r2, [r3, #2]
    }
  }
#endif /* OSEE_SCHEDULER_GLOBAL */

  return;
}
1ffe2c2a:	4770      	bx	lr

1ffe2c2c <osEE_scheduler_task_wrapper_run>:
FUNC(void, OS_CODE)
  osEE_scheduler_task_wrapper_run
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_tdb_to
)
{
1ffe2c2c:	b538      	push	{r3, r4, r5, lr}
1ffe2c2e:	4604      	mov	r4, r0
  CONST(TaskPrio, AUTOMATIC) task_priority = p_tdb_to->p_tcb->current_prio;
1ffe2c30:	6883      	ldr	r3, [r0, #8]
1ffe2c32:	785d      	ldrb	r5, [r3, #1]
  osEE_scheduler_task_wrapper_restore(p_tdb_to);
1ffe2c34:	f7ff fff6 	bl	1ffe2c24 <osEE_scheduler_task_wrapper_restore>

  if (task_priority < OSEE_ISR_ALL_PRIO) {
1ffe2c38:	2dff      	cmp	r5, #255	; 0xff
1ffe2c3a:	d006      	beq.n	1ffe2c4a <osEE_scheduler_task_wrapper_run+0x1e>
  if (virt_prio < OSEE_ISR2_PRIO_BIT) {
1ffe2c3c:	f015 0f80 	tst.w	r5, #128	; 0x80
1ffe2c40:	d108      	bne.n	1ffe2c54 <osEE_scheduler_task_wrapper_run+0x28>
    OSEE_SET_IPL(OSEE_ISR_UNMASKED << OSEE_CORTEX_M_PRIO_SH_BITS);
1ffe2c42:	2300      	movs	r3, #0
1ffe2c44:	f383 8811 	msr	BASEPRI, r3
  OSEE_SEI();
1ffe2c48:	b662      	cpsie	i
    /* Set-up IPL at current TASK level in addition to enable IRQ */
    osEE_hal_set_ipl(task_priority);
    osEE_hal_enableIRQ();
  }
  p_tdb_to->task_func();
1ffe2c4a:	6963      	ldr	r3, [r4, #20]
1ffe2c4c:	4798      	blx	r3

  /* Unexpected TASK Function return */
  osEE_scheduler_task_not_terminated(p_tdb_to);
1ffe2c4e:	4620      	mov	r0, r4
1ffe2c50:	f7ff ffc6 	bl	1ffe2be0 <osEE_scheduler_task_not_terminated>
    OSEE_SET_IPL(
1ffe2c54:	f1c5 050f 	rsb	r5, r5, #15
1ffe2c58:	012d      	lsls	r5, r5, #4
1ffe2c5a:	b2ed      	uxtb	r5, r5
1ffe2c5c:	f385 8811 	msr	BASEPRI, r5
1ffe2c60:	e7f2      	b.n	1ffe2c48 <osEE_scheduler_task_wrapper_run+0x1c>
	...

1ffe2c64 <osEE_idle_hook_wrapper>:
FUNC(void, OS_CODE)
  osEE_idle_hook_wrapper
(
  void
)
{
1ffe2c64:	b510      	push	{r4, lr}
  OSEE_GET_IPL(flags);
1ffe2c66:	f3ef 8411 	mrs	r4, BASEPRI
  flags >>= OSEE_CORTEX_M_PRIO_SH_BITS;
1ffe2c6a:	0923      	lsrs	r3, r4, #4
  if ( (flags == 0x00U) || (flags > OSEE_ISR2_MAX_HW_PRIO) ) {
1ffe2c6c:	3b01      	subs	r3, #1
1ffe2c6e:	2b07      	cmp	r3, #7
1ffe2c70:	d902      	bls.n	1ffe2c78 <osEE_idle_hook_wrapper+0x14>
    OSEE_SET_IPL(OSEE_ISR2_MAX_HW_PRIO << OSEE_CORTEX_M_PRIO_SH_BITS);
1ffe2c72:	2380      	movs	r3, #128	; 0x80
1ffe2c74:	f383 8811 	msr	BASEPRI, r3
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)
    p_cdb = osEE_get_curr_core();
#if (defined(OSEE_HAS_AUTOSTART_TASK))
  /* Schedule Here: Autostart TASKs */
  CONST(OsEE_reg, AUTOMATIC) flags = osEE_begin_primitive();
  (void)osEE_scheduler_task_preemption_point(osEE_get_kernel());
1ffe2c78:	480b      	ldr	r0, [pc, #44]	; (1ffe2ca8 <osEE_idle_hook_wrapper+0x44>)
1ffe2c7a:	f000 f959 	bl	1ffe2f30 <osEE_scheduler_task_preemption_point>
  OSEE_SET_IPL(flag << OSEE_CORTEX_M_PRIO_SH_BITS);
1ffe2c7e:	f024 040f 	bic.w	r4, r4, #15
1ffe2c82:	f384 8811 	msr	BASEPRI, r4
  osEE_end_primitive(flags);
#endif /* !OSEE_STARTOS_RETURN && !OSEE_API_DYNAMIC && !OSEE_HAS_AUTOSTART_TASK */
  while (p_cdb->p_ccb->os_status == OSEE_KERNEL_STARTED) {
1ffe2c86:	4b09      	ldr	r3, [pc, #36]	; (1ffe2cac <osEE_idle_hook_wrapper+0x48>)
1ffe2c88:	681b      	ldr	r3, [r3, #0]
1ffe2c8a:	7c1b      	ldrb	r3, [r3, #16]
1ffe2c8c:	b2db      	uxtb	r3, r3
1ffe2c8e:	2b02      	cmp	r3, #2
1ffe2c90:	d105      	bne.n	1ffe2c9e <osEE_idle_hook_wrapper+0x3a>
#if (defined(OSEE_HAS_IDLEHOOK)) || (defined(OSEE_API_DYNAMIC))
    CONST(TaskFunc, AUTOMATIC) p_idle_hook = p_cdb->p_idle_hook;
1ffe2c92:	4b06      	ldr	r3, [pc, #24]	; (1ffe2cac <osEE_idle_hook_wrapper+0x48>)
1ffe2c94:	685b      	ldr	r3, [r3, #4]
    if (p_idle_hook != NULL) {
1ffe2c96:	2b00      	cmp	r3, #0
1ffe2c98:	d0f5      	beq.n	1ffe2c86 <osEE_idle_hook_wrapper+0x22>
      p_idle_hook();
1ffe2c9a:	4798      	blx	r3
1ffe2c9c:	e7f3      	b.n	1ffe2c86 <osEE_idle_hook_wrapper+0x22>
    }
#else
    ; /* Empty Endless Loop */
#endif /* OSEE_HAS_IDLEHOOK || OSEE_API_DYNAMIC */
  }
  osEE_idle_task_terminate(p_cdb->p_idle_task);
1ffe2c9e:	4b03      	ldr	r3, [pc, #12]	; (1ffe2cac <osEE_idle_hook_wrapper+0x48>)
1ffe2ca0:	6898      	ldr	r0, [r3, #8]
1ffe2ca2:	f000 f9ca 	bl	1ffe303a <osEE_idle_task_terminate>
}
1ffe2ca6:	bd10      	pop	{r4, pc}
1ffe2ca8:	1ffe3248 	.word	0x1ffe3248
1ffe2cac:	1ffe3220 	.word	0x1ffe3220

1ffe2cb0 <osEE_scheduler_stk_next>:
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb,
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)  p_rq_sn
)
{
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_tdb = p_rq_sn->p_tdb;
1ffe2cb0:	684b      	ldr	r3, [r1, #4]
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb = p_tdb->p_tcb;
1ffe2cb2:	689a      	ldr	r2, [r3, #8]
  /* N.B. The Handling of the preempted SN as Stacked or re-inserted in RQ
   * is done by the calling function */
  p_rq_sn->p_next               = NULL;
  p_tcb->current_core_id        = osEE_get_curr_core_id();
#else
  p_rq_sn->p_next               = p_ccb->p_stk_sn;
1ffe2cb4:	f8d0 c00c 	ldr.w	ip, [r0, #12]
1ffe2cb8:	f8c1 c000 	str.w	ip, [r1]
#endif /* OSEE_ALLOW_TASK_MIGRATION */
  p_ccb->p_stk_sn               = p_rq_sn;
1ffe2cbc:	60c1      	str	r1, [r0, #12]
  p_ccb->p_curr                 = p_tdb;
1ffe2cbe:	6003      	str	r3, [r0, #0]

  /* Adjust actual priority with dispatch priority: if needed */
  {
    CONST(TaskPrio, AUTOMATIC)
      dispatch_prio = p_tdb->dispatch_prio;
1ffe2cc0:	7e5b      	ldrb	r3, [r3, #25]
    if (p_tcb->current_prio < dispatch_prio) {
1ffe2cc2:	7851      	ldrb	r1, [r2, #1]
1ffe2cc4:	4299      	cmp	r1, r3
1ffe2cc6:	d200      	bcs.n	1ffe2cca <osEE_scheduler_stk_next+0x1a>
      p_tcb->current_prio = dispatch_prio;
1ffe2cc8:	7053      	strb	r3, [r2, #1]
    }
  }
}
1ffe2cca:	4770      	bx	lr

1ffe2ccc <osEE_scheduler_core_rq_preempt_stk>:
  osEE_scheduler_core_rq_preempt_stk
(
  P2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)  p_cdb,
  P2VAR(OsEE_RQ,  AUTOMATIC, OS_APPL_DATA)  p_rq
)
{
1ffe2ccc:	b538      	push	{r3, r4, r5, lr}
1ffe2cce:	4602      	mov	r2, r0
1ffe2cd0:	460b      	mov	r3, r1
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
1ffe2cd2:	6800      	ldr	r0, [r0, #0]
  CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)  p_rq_sn  = (*p_rq);
1ffe2cd4:	6809      	ldr	r1, [r1, #0]
  P2CONST(OsEE_SN, AUTOMATIC, OS_APPL_DATA)     p_ret_sn = p_ccb->p_stk_sn;
1ffe2cd6:	68c4      	ldr	r4, [r0, #12]

  VAR(OsEE_bool, AUTOMATIC)                     is_rq_preemption = OSEE_FALSE;
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)      p_ret_tdb;

  if (p_ret_sn != NULL) {
1ffe2cd8:	b194      	cbz	r4, 1ffe2d00 <osEE_scheduler_core_rq_preempt_stk+0x34>
    p_ret_tdb = p_ret_sn->p_tdb;
1ffe2cda:	6864      	ldr	r4, [r4, #4]
    if (p_rq_sn != NULL) {
1ffe2cdc:	b1b1      	cbz	r1, 1ffe2d0c <osEE_scheduler_core_rq_preempt_stk+0x40>
      CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
        p_ret_tcb = p_ret_tdb->p_tcb;
1ffe2cde:	68a2      	ldr	r2, [r4, #8]
      if (p_ret_tcb->current_prio <
1ffe2ce0:	f892 e001 	ldrb.w	lr, [r2, #1]
        p_rq_sn->p_tdb->p_tcb->current_prio)
1ffe2ce4:	684d      	ldr	r5, [r1, #4]
1ffe2ce6:	68ad      	ldr	r5, [r5, #8]
1ffe2ce8:	f895 c001 	ldrb.w	ip, [r5, #1]
      if (p_ret_tcb->current_prio <
1ffe2cec:	45e6      	cmp	lr, ip
1ffe2cee:	d20f      	bcs.n	1ffe2d10 <osEE_scheduler_core_rq_preempt_stk+0x44>
      {
        /* RQ preempt STK */
        /* Call PostTaskHook before switching active TASK */
        osEE_call_post_task_hook(p_ccb);

        p_ret_tcb->status = OSEE_TASK_READY_STACKED;
1ffe2cf0:	2502      	movs	r5, #2
1ffe2cf2:	7095      	strb	r5, [r2, #2]
    p_ret_tdb = NULL;
  }

  if (is_rq_preemption) {
    /* Extract from ready queue */
    (*p_rq)       = p_rq_sn->p_next;
1ffe2cf4:	680a      	ldr	r2, [r1, #0]
1ffe2cf6:	601a      	str	r2, [r3, #0]

    /* Set as current on top of STK */
    osEE_scheduler_stk_next(p_ccb, p_rq_sn);
1ffe2cf8:	f7ff ffda 	bl	1ffe2cb0 <osEE_scheduler_stk_next>
#if (defined(OSEE_ALLOW_TASK_MIGRATION))
  return p_ret_sn;
#else
  return p_ret_tdb;
#endif /* OSEE_ALLOW_TASK_MIGRATION */
}
1ffe2cfc:	4620      	mov	r0, r4
1ffe2cfe:	bd38      	pop	{r3, r4, r5, pc}
  } else if (p_rq_sn != NULL) {
1ffe2d00:	b141      	cbz	r1, 1ffe2d14 <osEE_scheduler_core_rq_preempt_stk+0x48>
    p_ret_tdb                 = p_cdb->p_idle_task;
1ffe2d02:	6894      	ldr	r4, [r2, #8]
    p_ret_tdb->p_tcb->status  = OSEE_TASK_READY_STACKED;
1ffe2d04:	68a2      	ldr	r2, [r4, #8]
1ffe2d06:	2502      	movs	r5, #2
1ffe2d08:	7095      	strb	r5, [r2, #2]
  if (is_rq_preemption) {
1ffe2d0a:	e7f3      	b.n	1ffe2cf4 <osEE_scheduler_core_rq_preempt_stk+0x28>
    p_ret_tdb = NULL;
1ffe2d0c:	460c      	mov	r4, r1
1ffe2d0e:	e7f5      	b.n	1ffe2cfc <osEE_scheduler_core_rq_preempt_stk+0x30>
1ffe2d10:	2400      	movs	r4, #0
1ffe2d12:	e7f3      	b.n	1ffe2cfc <osEE_scheduler_core_rq_preempt_stk+0x30>
1ffe2d14:	460c      	mov	r4, r1
  return p_ret_tdb;
1ffe2d16:	e7f1      	b.n	1ffe2cfc <osEE_scheduler_core_rq_preempt_stk+0x30>

1ffe2d18 <osEE_sn_priority_insert>:
(
  P2VAR(OsEE_SN *, AUTOMATIC, OS_APPL_DATA)     pp_first,
  P2VAR(OsEE_SN  , AUTOMATIC, OS_APPL_DATA)     p_sn_new,
  CONST(OsEE_bool, AUTOMATIC)                   as_ready
)
{
1ffe2d18:	b470      	push	{r4, r5, r6}
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)  p_tdb_new = p_sn_new->p_tdb;
1ffe2d1a:	684b      	ldr	r3, [r1, #4]
  CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb_new = p_tdb_new->p_tcb;
1ffe2d1c:	689c      	ldr	r4, [r3, #8]
  CONST(TaskPrio, AUTOMATIC)                  new_task_prio =
1ffe2d1e:	4616      	mov	r6, r2
1ffe2d20:	b122      	cbz	r2, 1ffe2d2c <osEE_sn_priority_insert+0x14>
1ffe2d22:	f893 c018 	ldrb.w	ip, [r3, #24]
    (as_ready)?
      p_tdb_new->ready_prio:
      p_tcb_new->current_prio;
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_prev          = NULL;
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_curr          = (*pp_first);
1ffe2d26:	6803      	ldr	r3, [r0, #0]
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_prev          = NULL;
1ffe2d28:	2500      	movs	r5, #0
  VAR(OsEE_bool, AUTOMATIC)               head_changed    = OSEE_FALSE;

  /* Traverse the queue until needed */
  while (p_curr != NULL) {
1ffe2d2a:	e007      	b.n	1ffe2d3c <osEE_sn_priority_insert+0x24>
  CONST(TaskPrio, AUTOMATIC)                  new_task_prio =
1ffe2d2c:	f894 c001 	ldrb.w	ip, [r4, #1]
1ffe2d30:	e7f9      	b.n	1ffe2d26 <osEE_sn_priority_insert+0xe>
      p_cur_tcb = p_cur_tdb->p_tcb;

    if (as_ready) {
      prio_to_check = p_cur_tdb->ready_prio;
    } else {
      prio_to_check = p_cur_tcb->current_prio;
1ffe2d32:	7862      	ldrb	r2, [r4, #1]
    }

    if (new_task_prio <= prio_to_check)
1ffe2d34:	4562      	cmp	r2, ip
1ffe2d36:	d308      	bcc.n	1ffe2d4a <osEE_sn_priority_insert+0x32>
    {
      p_prev = p_curr;
1ffe2d38:	461d      	mov	r5, r3
      p_curr = p_curr->p_next;
1ffe2d3a:	681b      	ldr	r3, [r3, #0]
  while (p_curr != NULL) {
1ffe2d3c:	b12b      	cbz	r3, 1ffe2d4a <osEE_sn_priority_insert+0x32>
      p_cur_tdb = p_curr->p_tdb;
1ffe2d3e:	685a      	ldr	r2, [r3, #4]
      p_cur_tcb = p_cur_tdb->p_tcb;
1ffe2d40:	6894      	ldr	r4, [r2, #8]
    if (as_ready) {
1ffe2d42:	2e00      	cmp	r6, #0
1ffe2d44:	d0f5      	beq.n	1ffe2d32 <osEE_sn_priority_insert+0x1a>
      prio_to_check = p_cur_tdb->ready_prio;
1ffe2d46:	7e12      	ldrb	r2, [r2, #24]
1ffe2d48:	e7f4      	b.n	1ffe2d34 <osEE_sn_priority_insert+0x1c>
    } else {
      break;
    }
  }

  if (p_prev != NULL) {
1ffe2d4a:	b125      	cbz	r5, 1ffe2d56 <osEE_sn_priority_insert+0x3e>
    p_prev->p_next = p_sn_new;
1ffe2d4c:	6029      	str	r1, [r5, #0]
  VAR(OsEE_bool, AUTOMATIC)               head_changed    = OSEE_FALSE;
1ffe2d4e:	2000      	movs	r0, #0
  } else {
    (*pp_first)   = p_sn_new;
    head_changed  = OSEE_TRUE;
  }

  p_sn_new->p_next = p_curr;
1ffe2d50:	600b      	str	r3, [r1, #0]

  return head_changed;
}
1ffe2d52:	bc70      	pop	{r4, r5, r6}
1ffe2d54:	4770      	bx	lr
    (*pp_first)   = p_sn_new;
1ffe2d56:	6001      	str	r1, [r0, #0]
    head_changed  = OSEE_TRUE;
1ffe2d58:	2001      	movs	r0, #1
1ffe2d5a:	e7f9      	b.n	1ffe2d50 <osEE_sn_priority_insert+0x38>

1ffe2d5c <osEE_scheduler_rq_insert>:
{
1ffe2d5c:	b508      	push	{r3, lr}
  p_sn_new->p_tdb = p_tdb_new;
1ffe2d5e:	604a      	str	r2, [r1, #4]
  return osEE_sn_priority_insert(p_rq, p_sn_new, OSEE_TRUE);
1ffe2d60:	2201      	movs	r2, #1
1ffe2d62:	f7ff ffd9 	bl	1ffe2d18 <osEE_sn_priority_insert>
}
1ffe2d66:	bd08      	pop	{r3, pc}

1ffe2d68 <osEE_scheduler_core_pop_running>:
  osEE_scheduler_core_pop_running
(
  P2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)  p_cdb,
  P2VAR(OsEE_RQ,  AUTOMATIC, OS_APPL_DATA)  p_rq
)
{
1ffe2d68:	b570      	push	{r4, r5, r6, lr}
1ffe2d6a:	4605      	mov	r5, r0
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb         = p_cdb->p_ccb;
1ffe2d6c:	6804      	ldr	r4, [r0, #0]
  CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)  p_prev_stk_sn = p_ccb->p_stk_sn;
1ffe2d6e:	68e6      	ldr	r6, [r4, #12]
  CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
    p_next_stk_sn = p_prev_stk_sn->p_next;
1ffe2d70:	6833      	ldr	r3, [r6, #0]

  /* Pop the current STK SN, if not IDLE TASK. This function MUST not be
   * called inside IDLE TASK. */
  p_ccb->p_stk_sn = p_next_stk_sn;
1ffe2d72:	60e3      	str	r3, [r4, #12]
   * */

  {
    /* Handle if RQ preempt STK (It manipulate the core data structures) */
    CONSTP2VAR(OsEE_preempt, AUTOMATIC, OS_APPL_DATA)
      p_preempt = osEE_scheduler_core_rq_preempt_stk(p_cdb, p_rq);
1ffe2d74:	f7ff ffaa 	bl	1ffe2ccc <osEE_scheduler_core_rq_preempt_stk>
    CONSTP2CONST(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
      p_curr_stk_sn = p_ccb->p_stk_sn;
1ffe2d78:	68e3      	ldr	r3, [r4, #12]

    /* If not, resume current STK first */
    if (p_preempt == NULL) {
1ffe2d7a:	b108      	cbz	r0, 1ffe2d80 <osEE_scheduler_core_pop_running+0x18>
    }
#endif /* OSEE_ALLOW_TASK_MIGRATION */
  }

  return p_prev_stk_sn;
}
1ffe2d7c:	4630      	mov	r0, r6
1ffe2d7e:	bd70      	pop	{r4, r5, r6, pc}
      if (p_curr_stk_sn != NULL) {
1ffe2d80:	b113      	cbz	r3, 1ffe2d88 <osEE_scheduler_core_pop_running+0x20>
        p_tdb_stk = p_curr_stk_sn->p_tdb;
1ffe2d82:	685b      	ldr	r3, [r3, #4]
      p_ccb->p_curr            = p_tdb_stk;
1ffe2d84:	6023      	str	r3, [r4, #0]
  return p_prev_stk_sn;
1ffe2d86:	e7f9      	b.n	1ffe2d7c <osEE_scheduler_core_pop_running+0x14>
        p_tdb_stk = p_cdb->p_idle_task;
1ffe2d88:	68ab      	ldr	r3, [r5, #8]
1ffe2d8a:	e7fb      	b.n	1ffe2d84 <osEE_scheduler_core_pop_running+0x1c>

1ffe2d8c <osEE_task_activated>:
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_tdb_act
)
{
  VAR(StatusType, AUTOMATIC)                    ev;
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb_act = p_tdb_act->p_tcb;
1ffe2d8c:	6882      	ldr	r2, [r0, #8]
#else
  osEE_lock_kernel();
#endif /* !OSEE_SCHEDULER_GLOBAL */
#endif /* !OSEE_SINGLECORE */

  if (p_tcb_act->current_num_of_act < p_tdb_act->max_num_of_act) {
1ffe2d8e:	7813      	ldrb	r3, [r2, #0]
1ffe2d90:	7e81      	ldrb	r1, [r0, #26]
1ffe2d92:	428b      	cmp	r3, r1
1ffe2d94:	d203      	bcs.n	1ffe2d9e <osEE_task_activated+0x12>
    ++p_tcb_act->current_num_of_act;
1ffe2d96:	3301      	adds	r3, #1
1ffe2d98:	7013      	strb	r3, [r2, #0]
    ev = E_OK;
1ffe2d9a:	2000      	movs	r0, #0
1ffe2d9c:	4770      	bx	lr
  } else {
    ev = E_OS_LIMIT;
1ffe2d9e:	2004      	movs	r0, #4
  osEE_lock_kernel();
#endif /* !OSEE_SCHEDULER_GLOBAL */
#endif /* !OSEE_SINGLECORE */

  return ev;
}
1ffe2da0:	4770      	bx	lr

1ffe2da2 <osEE_task_end>:
(
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_tdb
)
{
  /* It has to be called already in Multi-Core critical section */
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb = p_tdb->p_tcb;
1ffe2da2:	6882      	ldr	r2, [r0, #8]

  p_tcb->current_prio = p_tdb->ready_prio;
1ffe2da4:	7e03      	ldrb	r3, [r0, #24]
1ffe2da6:	7053      	strb	r3, [r2, #1]

  --p_tcb->current_num_of_act;
1ffe2da8:	7813      	ldrb	r3, [r2, #0]
1ffe2daa:	3b01      	subs	r3, #1
1ffe2dac:	b2db      	uxtb	r3, r3
1ffe2dae:	7013      	strb	r3, [r2, #0]

  if (p_tcb->current_num_of_act == 0U) {
1ffe2db0:	b90b      	cbnz	r3, 1ffe2db6 <osEE_task_end+0x14>
    p_tcb->status = OSEE_TASK_SUSPENDED;
1ffe2db2:	7093      	strb	r3, [r2, #2]
1ffe2db4:	4770      	bx	lr
  } else {
    p_tcb->status = OSEE_TASK_READY;
1ffe2db6:	2301      	movs	r3, #1
1ffe2db8:	7093      	strb	r3, [r2, #2]
  }
}
1ffe2dba:	4770      	bx	lr

1ffe2dbc <osEE_activate_isr2>:
FUNC(void, OS_CODE)
  osEE_activate_isr2
(
  VAR(TaskType, AUTOMATIC) isr2_id
)
{
1ffe2dbc:	b508      	push	{r3, lr}
1ffe2dbe:	4602      	mov	r2, r0
  osEE_stack_monitoring(osEE_get_curr_core());
#endif /* OSEE_HAS_STACK_MONITORING */
  {
    CONSTP2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA) p_kdb = osEE_get_kernel();
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_act_tdb = (*p_kdb->p_tdb_ptr_array)[isr2_id];
1ffe2dc0:	4805      	ldr	r0, [pc, #20]	; (1ffe2dd8 <osEE_activate_isr2+0x1c>)
1ffe2dc2:	6843      	ldr	r3, [r0, #4]
1ffe2dc4:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]

    /* Mark the TASK as Activated (I don't need to protect this increment
       since ISRs cannot be activated by another core (exception done for
       IPI, that have to be handled in a special way in any case). */
    ++p_act_tdb->p_tcb->current_num_of_act;
1ffe2dc8:	688a      	ldr	r2, [r1, #8]
1ffe2dca:	7813      	ldrb	r3, [r2, #0]
1ffe2dcc:	3301      	adds	r3, #1
1ffe2dce:	7013      	strb	r3, [r2, #0]

    osEE_scheduler_task_set_running(p_kdb, p_act_tdb, NULL);
1ffe2dd0:	2200      	movs	r2, #0
1ffe2dd2:	f000 f8bd 	bl	1ffe2f50 <osEE_scheduler_task_set_running>
  }
}
1ffe2dd6:	bd08      	pop	{r3, pc}
1ffe2dd8:	1ffe3248 	.word	0x1ffe3248

1ffe2ddc <osEE_scheduler_task_insert_rq>:
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_tdb_act,
  P2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)  p_tcb_act
)
{
1ffe2ddc:	b508      	push	{r3, lr}
1ffe2dde:	460b      	mov	r3, r1
  VAR(OsEE_bool, AUTOMATIC) rq_head_changed;

  /* Actually Insert the activated in Ready Queue.
   * Change Status only if is not active yet. */
  if (p_tcb_act->status == OSEE_TASK_SUSPENDED) {
1ffe2de0:	7891      	ldrb	r1, [r2, #2]
1ffe2de2:	b919      	cbnz	r1, 1ffe2dec <osEE_scheduler_task_insert_rq+0x10>
    p_tcb_act->status = OSEE_TASK_READY;
1ffe2de4:	2101      	movs	r1, #1
1ffe2de6:	7091      	strb	r1, [r2, #2]
  p_tcb->event_mask = 0U;
1ffe2de8:	2100      	movs	r1, #0
1ffe2dea:	6091      	str	r1, [r2, #8]
  p_sn_allocated          = (*pp_first);
1ffe2dec:	6881      	ldr	r1, [r0, #8]
  (*pp_first)             = p_sn_allocated->p_next;
1ffe2dee:	680a      	ldr	r2, [r1, #0]
1ffe2df0:	6082      	str	r2, [r0, #8]
  p_sn_allocated->p_next  = NULL;
1ffe2df2:	2200      	movs	r2, #0
1ffe2df4:	600a      	str	r2, [r1, #0]
    osEE_task_event_reset_mask(p_tcb_act);
  }

  rq_head_changed = osEE_scheduler_rq_insert(&p_ccb->rq,
1ffe2df6:	461a      	mov	r2, r3
1ffe2df8:	3004      	adds	r0, #4
1ffe2dfa:	f7ff ffaf 	bl	1ffe2d5c <osEE_scheduler_rq_insert>
    osEE_sn_alloc(&p_ccb->p_free_sn), p_tdb_act);

  return rq_head_changed;
}
1ffe2dfe:	bd08      	pop	{r3, pc}

1ffe2e00 <osEE_scheduler_task_activated>:
  osEE_scheduler_task_activated
(
  P2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA)  p_kdb,
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_tdb_act
)
{
1ffe2e00:	b538      	push	{r3, r4, r5, lr}
  VAR(OsEE_bool, AUTOMATIC)   is_preemption;
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb_act   = p_tdb_act->p_tcb;
1ffe2e02:	688a      	ldr	r2, [r1, #8]
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)
    p_cdb = osEE_task_get_curr_core(p_tdb_act);
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb       = p_cdb->p_ccb;
1ffe2e04:	4b11      	ldr	r3, [pc, #68]	; (1ffe2e4c <osEE_scheduler_task_activated+0x4c>)
1ffe2e06:	681b      	ldr	r3, [r3, #0]
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_curr      = p_ccb->p_curr;
1ffe2e08:	6818      	ldr	r0, [r3, #0]
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_curr_tcb  = p_curr->p_tcb;
1ffe2e0a:	6884      	ldr	r4, [r0, #8]
    }
    is_preemption = OSEE_FALSE;
  } else
#endif /* !OSEE_SINGLECORE */
  /* Preemption Check */
  if (p_curr_tcb->current_prio < p_tcb_act->current_prio) {
1ffe2e0c:	f894 e001 	ldrb.w	lr, [r4, #1]
1ffe2e10:	f892 c001 	ldrb.w	ip, [r2, #1]
1ffe2e14:	45e6      	cmp	lr, ip
1ffe2e16:	d213      	bcs.n	1ffe2e40 <osEE_scheduler_task_activated+0x40>
  p_sn_allocated          = (*pp_first);
1ffe2e18:	689a      	ldr	r2, [r3, #8]
  (*pp_first)             = p_sn_allocated->p_next;
1ffe2e1a:	6815      	ldr	r5, [r2, #0]
1ffe2e1c:	609d      	str	r5, [r3, #8]
  p_sn_allocated->p_next  = NULL;
1ffe2e1e:	2500      	movs	r5, #0
1ffe2e20:	6015      	str	r5, [r2, #0]
        osEE_call_post_task_hook(p_ccb);
      }
#endif /* OSEE_HAS_POSTTASKHOOK */

    /* Set Previous TASK status as Ready but stacked */
    p_curr_tcb->status = OSEE_TASK_READY_STACKED;
1ffe2e22:	f04f 0c02 	mov.w	ip, #2
1ffe2e26:	f884 c002 	strb.w	ip, [r4, #2]

    /* Set the activated TASK as current */
    p_new_stk->p_tdb            = p_tdb_act;
1ffe2e2a:	6051      	str	r1, [r2, #4]
    p_new_stk->p_next           = p_ccb->p_stk_sn;
1ffe2e2c:	68dc      	ldr	r4, [r3, #12]
1ffe2e2e:	6014      	str	r4, [r2, #0]
    p_ccb->p_stk_sn             = p_new_stk;
1ffe2e30:	60da      	str	r2, [r3, #12]
    p_ccb->p_curr               = p_tdb_act;
1ffe2e32:	6019      	str	r1, [r3, #0]
    osEE_task_event_reset_mask(p_tdb_act->p_tcb);
1ffe2e34:	688b      	ldr	r3, [r1, #8]
1ffe2e36:	609d      	str	r5, [r3, #8]

    osEE_unlock_core(p_cdb);

    osEE_change_context_from_running(p_curr, p_tdb_act);
1ffe2e38:	f000 f8e0 	bl	1ffe2ffc <osEE_change_context_from_running>

    is_preemption = OSEE_TRUE;
1ffe2e3c:	2001      	movs	r0, #1

    is_preemption = OSEE_FALSE;
  }

  return is_preemption;
}
1ffe2e3e:	bd38      	pop	{r3, r4, r5, pc}
    (void)osEE_scheduler_task_insert_rq(p_ccb, p_tdb_act, p_tcb_act);
1ffe2e40:	4618      	mov	r0, r3
1ffe2e42:	f7ff ffcb 	bl	1ffe2ddc <osEE_scheduler_task_insert_rq>
    is_preemption = OSEE_FALSE;
1ffe2e46:	2000      	movs	r0, #0
1ffe2e48:	e7f9      	b.n	1ffe2e3e <osEE_scheduler_task_activated+0x3e>
1ffe2e4a:	bf00      	nop
1ffe2e4c:	1ffe3220 	.word	0x1ffe3220

1ffe2e50 <osEE_scheduler_task_block_current>:
  osEE_scheduler_task_block_current
(
  P2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA)    p_kdb,
  P2VAR(OsEE_SN *,  AUTOMATIC, OS_APPL_DATA)  p_sn_blocked
)
{
1ffe2e50:	b570      	push	{r4, r5, r6, lr}
1ffe2e52:	460c      	mov	r4, r1
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)
    p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb         = p_cdb->p_ccb;
1ffe2e54:	4806      	ldr	r0, [pc, #24]	; (1ffe2e70 <osEE_scheduler_task_block_current+0x20>)
1ffe2e56:	6805      	ldr	r5, [r0, #0]
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_tdb_blocked = p_ccb->p_curr;
1ffe2e58:	4629      	mov	r1, r5
1ffe2e5a:	f851 6b04 	ldr.w	r6, [r1], #4

  /* Touch unused parameters */
  (void)p_kdb;
  osEE_lock_core(p_cdb);

  (*p_sn_blocked) = osEE_scheduler_core_pop_running(p_cdb, &p_ccb->rq);
1ffe2e5e:	f7ff ff83 	bl	1ffe2d68 <osEE_scheduler_core_pop_running>
1ffe2e62:	6020      	str	r0, [r4, #0]

  p_tdb_blocked->p_tcb->status = OSEE_TASK_WAITING;
1ffe2e64:	68b3      	ldr	r3, [r6, #8]
1ffe2e66:	2203      	movs	r2, #3
1ffe2e68:	709a      	strb	r2, [r3, #2]
#endif /* OSEE_HAS_PRETASKHOOK */

  osEE_unlock_core(p_cdb);

  return p_ccb->p_curr;
}
1ffe2e6a:	6828      	ldr	r0, [r5, #0]
1ffe2e6c:	bd70      	pop	{r4, r5, r6, pc}
1ffe2e6e:	bf00      	nop
1ffe2e70:	1ffe3220 	.word	0x1ffe3220

1ffe2e74 <osEE_scheduler_task_unblocked>:
  osEE_scheduler_task_unblocked
(
  P2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA)  p_kdb,
  P2VAR(OsEE_SN,  AUTOMATIC, OS_APPL_DATA)  p_sn_released
)
{
1ffe2e74:	b538      	push	{r3, r4, r5, lr}
  VAR(OsEE_bool, AUTOMATIC) rq_head_changed;
  VAR(OsEE_bool, AUTOMATIC)
    is_preemption = OSEE_FALSE;
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
    p_tdb_released = p_sn_released->p_tdb;
1ffe2e76:	684a      	ldr	r2, [r1, #4]
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
    p_tcb_released = p_tdb_released->p_tcb;
1ffe2e78:	6894      	ldr	r4, [r2, #8]
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)
    p_cdb = osEE_task_get_curr_core(p_tdb_released);
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
    p_ccb = p_cdb->p_ccb;
1ffe2e7a:	4b0b      	ldr	r3, [pc, #44]	; (1ffe2ea8 <osEE_scheduler_task_unblocked+0x34>)
1ffe2e7c:	681d      	ldr	r5, [r3, #0]

  p_tcb_released->status       = OSEE_TASK_READY_STACKED;
1ffe2e7e:	2302      	movs	r3, #2
1ffe2e80:	70a3      	strb	r3, [r4, #2]
  p_tcb_released->current_prio = p_tdb_released->ready_prio;
1ffe2e82:	7e13      	ldrb	r3, [r2, #24]
1ffe2e84:	7063      	strb	r3, [r4, #1]
  /* Touch unused parameters */
  (void)p_kdb;

  osEE_lock_core(p_cdb);

  rq_head_changed = osEE_scheduler_rq_insert(&p_ccb->rq,
1ffe2e86:	1d28      	adds	r0, r5, #4
1ffe2e88:	f7ff ff68 	bl	1ffe2d5c <osEE_scheduler_rq_insert>
    p_sn_released, p_tdb_released);

  if (rq_head_changed == OSEE_TRUE) {
1ffe2e8c:	2801      	cmp	r0, #1
1ffe2e8e:	d001      	beq.n	1ffe2e94 <osEE_scheduler_task_unblocked+0x20>
    is_preemption = OSEE_FALSE;
1ffe2e90:	2000      	movs	r0, #0
    }
  }
#endif /* !OSEE_SINGLECORE */

  return is_preemption;
}
1ffe2e92:	bd38      	pop	{r3, r4, r5, pc}
    is_preemption = (p_tcb_released->current_prio >
1ffe2e94:	7860      	ldrb	r0, [r4, #1]
      p_ccb->p_curr->p_tcb->current_prio);
1ffe2e96:	682b      	ldr	r3, [r5, #0]
1ffe2e98:	689b      	ldr	r3, [r3, #8]
1ffe2e9a:	785b      	ldrb	r3, [r3, #1]
    is_preemption = (p_tcb_released->current_prio >
1ffe2e9c:	4298      	cmp	r0, r3
1ffe2e9e:	bf94      	ite	ls
1ffe2ea0:	2000      	movls	r0, #0
1ffe2ea2:	2001      	movhi	r0, #1
1ffe2ea4:	e7f5      	b.n	1ffe2e92 <osEE_scheduler_task_unblocked+0x1e>
1ffe2ea6:	bf00      	nop
1ffe2ea8:	1ffe3220 	.word	0x1ffe3220

1ffe2eac <osEE_scheduler_task_terminated>:
  osEE_scheduler_task_terminated
(
  P2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA)    p_kdb,
  P2VAR(OsEE_TDB *, AUTOMATIC, OS_APPL_DATA)  pp_tdb_from
)
{
1ffe2eac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA) p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
1ffe2eb0:	4b1e      	ldr	r3, [pc, #120]	; (1ffe2f2c <osEE_scheduler_task_terminated+0x80>)
1ffe2eb2:	681c      	ldr	r4, [r3, #0]
  /* Touch unused parameters */
  (void)p_kdb;
  osEE_lock_core(p_cdb);
  {
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_tdb_term  = p_ccb->p_curr;
1ffe2eb4:	6825      	ldr	r5, [r4, #0]
    CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
      p_tcb_term  = p_tdb_term->p_tcb;
1ffe2eb6:	68ae      	ldr	r6, [r5, #8]

    /* Prepare the TDB from return value */
    (*pp_tdb_from) = p_tdb_term;
1ffe2eb8:	600d      	str	r5, [r1, #0]
    /* We are having a termination so the hook flag has to be
       unset */
    p_ccb->p_last_tdb_hook = NULL;
#endif /* OSEE_HAS_PRETASKHOOK */

    if (p_tcb_term->status == OSEE_TASK_RUNNING) {
1ffe2eba:	78b3      	ldrb	r3, [r6, #2]
1ffe2ebc:	2b04      	cmp	r3, #4
1ffe2ebe:	d018      	beq.n	1ffe2ef2 <osEE_scheduler_task_terminated+0x46>
      /* In Normal Termination => SN released */
      osEE_sn_release(&p_ccb->p_free_sn, p_sn_term);
    } else {
      /* Handle ChainTask */
      CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
        p_sn_term = p_ccb->p_stk_sn;
1ffe2ec0:	68e1      	ldr	r1, [r4, #12]

      /* Pop the current STK SN, if not IDLE TASK. This function MUST not be
       * called inside IDLE TASK. */
      p_ccb->p_stk_sn = p_sn_term->p_next;
1ffe2ec2:	680b      	ldr	r3, [r1, #0]
1ffe2ec4:	60e3      	str	r3, [r4, #12]
#endif /* OSEE_HAS_POSTTASKHOOK */

      /* I need to release internal resource for Chained TASK
       * (set ready prio instead of dispatch prio) to let RQ Tasks 'preempt'
       * the Chained. */
      p_tcb_term->current_prio = p_tdb_term->ready_prio;
1ffe2ec6:	7e2b      	ldrb	r3, [r5, #24]
1ffe2ec8:	7073      	strb	r3, [r6, #1]
      p_tcb_term->status = OSEE_TASK_READY;
1ffe2eca:	2301      	movs	r3, #1
1ffe2ecc:	70b3      	strb	r3, [r6, #2]
#if (defined(OSEE_HAS_EVENTS))
      /* If this activation is the last of a TASK, a chaining is
       * a transition from SUSPENDED to READY so I need to reset Events. */
      if (p_tcb_term->current_num_of_act == 1U) {
1ffe2ece:	7833      	ldrb	r3, [r6, #0]
1ffe2ed0:	2b01      	cmp	r3, #1
1ffe2ed2:	d023      	beq.n	1ffe2f1c <osEE_scheduler_task_terminated+0x70>
        osEE_task_event_reset_mask(p_tcb_term);
      }
#endif /* OSEE_HAS_EVENTS */

      (void)osEE_scheduler_rq_insert(&p_ccb->rq, p_sn_term, p_tdb_term);
1ffe2ed4:	1d23      	adds	r3, r4, #4
1ffe2ed6:	462a      	mov	r2, r5
1ffe2ed8:	461d      	mov	r5, r3
1ffe2eda:	4618      	mov	r0, r3
1ffe2edc:	f7ff ff3e 	bl	1ffe2d5c <osEE_scheduler_rq_insert>

      {
        CONSTP2VAR(OsEE_preempt, AUTOMATIC, OS_APPL_DATA)
          p_prev = osEE_scheduler_core_rq_preempt_stk(p_cdb, &p_ccb->rq);
1ffe2ee0:	4629      	mov	r1, r5
1ffe2ee2:	4812      	ldr	r0, [pc, #72]	; (1ffe2f2c <osEE_scheduler_task_terminated+0x80>)
1ffe2ee4:	f7ff fef2 	bl	1ffe2ccc <osEE_scheduler_core_rq_preempt_stk>

        if (p_prev == NULL) {
1ffe2ee8:	b1d8      	cbz	r0, 1ffe2f22 <osEE_scheduler_task_terminated+0x76>
           * Not Needed to Check Idle TASK since just reinserted the chained
           * in RQ */
          p_tdb_to                = p_ccb->p_stk_sn->p_tdb;
          p_ccb->p_curr           = p_tdb_to;
        } else {
          p_tdb_to = p_ccb->p_curr;
1ffe2eea:	6827      	ldr	r7, [r4, #0]
    }
  }
  osEE_unlock_core(p_cdb);

  return p_tdb_to;
}
1ffe2eec:	4638      	mov	r0, r7
1ffe2eee:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        p_sn_term = osEE_scheduler_core_pop_running(p_cdb, &p_ccb->rq);
1ffe2ef2:	1d21      	adds	r1, r4, #4
1ffe2ef4:	480d      	ldr	r0, [pc, #52]	; (1ffe2f2c <osEE_scheduler_task_terminated+0x80>)
1ffe2ef6:	f7ff ff37 	bl	1ffe2d68 <osEE_scheduler_core_pop_running>
1ffe2efa:	4680      	mov	r8, r0
      p_tdb_to = p_ccb->p_curr;
1ffe2efc:	6827      	ldr	r7, [r4, #0]
      if (p_tdb_term != p_tdb_to) {
1ffe2efe:	42bd      	cmp	r5, r7
1ffe2f00:	d008      	beq.n	1ffe2f14 <osEE_scheduler_task_terminated+0x68>
        osEE_task_end(p_tdb_term);
1ffe2f02:	4628      	mov	r0, r5
1ffe2f04:	f7ff ff4d 	bl	1ffe2da2 <osEE_task_end>
(
  P2VAR(OsEE_SN *, AUTOMATIC, OS_APPL_DATA) pp_first,
  P2VAR(OsEE_SN  , AUTOMATIC, OS_APPL_DATA) p_to_free
)
{
  p_to_free->p_next = (*pp_first);
1ffe2f08:	68a3      	ldr	r3, [r4, #8]
1ffe2f0a:	f8c8 3000 	str.w	r3, [r8]
  (*pp_first)       = p_to_free;
1ffe2f0e:	f8c4 8008 	str.w	r8, [r4, #8]
}
1ffe2f12:	e7eb      	b.n	1ffe2eec <osEE_scheduler_task_terminated+0x40>
        --p_tcb_term->current_num_of_act;
1ffe2f14:	7833      	ldrb	r3, [r6, #0]
1ffe2f16:	3b01      	subs	r3, #1
1ffe2f18:	7033      	strb	r3, [r6, #0]
1ffe2f1a:	e7f5      	b.n	1ffe2f08 <osEE_scheduler_task_terminated+0x5c>
1ffe2f1c:	2300      	movs	r3, #0
1ffe2f1e:	60b3      	str	r3, [r6, #8]
}
1ffe2f20:	e7d8      	b.n	1ffe2ed4 <osEE_scheduler_task_terminated+0x28>
          p_tdb_to                = p_ccb->p_stk_sn->p_tdb;
1ffe2f22:	68e3      	ldr	r3, [r4, #12]
1ffe2f24:	685f      	ldr	r7, [r3, #4]
          p_ccb->p_curr           = p_tdb_to;
1ffe2f26:	6027      	str	r7, [r4, #0]
1ffe2f28:	e7e0      	b.n	1ffe2eec <osEE_scheduler_task_terminated+0x40>
1ffe2f2a:	bf00      	nop
1ffe2f2c:	1ffe3220 	.word	0x1ffe3220

1ffe2f30 <osEE_scheduler_task_preemption_point>:
FUNC(OsEE_bool, OS_CODE)
  osEE_scheduler_task_preemption_point
(
  P2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA)  p_kdb
)
{
1ffe2f30:	b510      	push	{r4, lr}
  VAR(OsEE_bool, AUTOMATIC)                     is_preemption;
  P2VAR(OsEE_preempt, AUTOMATIC, OS_APPL_DATA)  p_prev;
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA) p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
1ffe2f32:	4806      	ldr	r0, [pc, #24]	; (1ffe2f4c <osEE_scheduler_task_preemption_point+0x1c>)
1ffe2f34:	6804      	ldr	r4, [r0, #0]
  /* Touch unused parameters */
  (void)p_kdb;
  /* Lock the Scheduler */
  osEE_lock_core(p_cdb);

  p_prev = osEE_scheduler_core_rq_preempt_stk(p_cdb, &p_ccb->rq);
1ffe2f36:	1d21      	adds	r1, r4, #4
1ffe2f38:	f7ff fec8 	bl	1ffe2ccc <osEE_scheduler_core_rq_preempt_stk>

  /* Unlock the Scheduler (critical section terminated) */
  osEE_unlock_core(p_cdb);

  if (p_prev != NULL) {
1ffe2f3c:	b120      	cbz	r0, 1ffe2f48 <osEE_scheduler_task_preemption_point+0x18>
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_curr = p_ccb->p_curr;

    osEE_change_context_from_running(p_prev, p_curr);
1ffe2f3e:	6821      	ldr	r1, [r4, #0]
1ffe2f40:	f000 f85c 	bl	1ffe2ffc <osEE_change_context_from_running>

    is_preemption = OSEE_TRUE;
1ffe2f44:	2001      	movs	r0, #1
  } else {
    is_preemption = OSEE_FALSE;
  }

  return is_preemption;
}
1ffe2f46:	bd10      	pop	{r4, pc}
    is_preemption = OSEE_FALSE;
1ffe2f48:	2000      	movs	r0, #0
1ffe2f4a:	e7fc      	b.n	1ffe2f46 <osEE_scheduler_task_preemption_point+0x16>
1ffe2f4c:	1ffe3220 	.word	0x1ffe3220

1ffe2f50 <osEE_scheduler_task_set_running>:
(
  P2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA)  p_kdb,
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_tdb,
  P2VAR(OsEE_SN,  AUTOMATIC, OS_APPL_DATA)  p_sn
)
{
1ffe2f50:	b538      	push	{r3, r4, r5, lr}
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb = p_cdb->p_ccb;
1ffe2f52:	4b14      	ldr	r3, [pc, #80]	; (1ffe2fa4 <osEE_scheduler_task_set_running+0x54>)
1ffe2f54:	681b      	ldr	r3, [r3, #0]
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)  p_preempted = p_ccb->p_curr;
1ffe2f56:	6818      	ldr	r0, [r3, #0]
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
    p_preempted_tcb = p_preempted->p_tcb;
1ffe2f58:	6884      	ldr	r4, [r0, #8]
  CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
    p_preempted_sn = p_ccb->p_stk_sn;
1ffe2f5a:	68dd      	ldr	r5, [r3, #12]

  /* Set previous TASK as stacked only if the activation has been completed */
  if (p_preempted_tcb->status == OSEE_TASK_RUNNING) {
1ffe2f5c:	f894 c002 	ldrb.w	ip, [r4, #2]
1ffe2f60:	f1bc 0f04 	cmp.w	ip, #4
1ffe2f64:	d012      	beq.n	1ffe2f8c <osEE_scheduler_task_set_running+0x3c>
    p_preempted_tcb->status  = OSEE_TASK_READY_STACKED;
  }
  /* Adjust current priority with dispatch priority: if needed */
  {
    CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_to_tcb = p_tdb->p_tcb;
1ffe2f66:	688c      	ldr	r4, [r1, #8]
    CONST(TaskPrio, AUTOMATIC)  dispatch_prio = p_tdb->dispatch_prio;
1ffe2f68:	f891 c019 	ldrb.w	ip, [r1, #25]

    if (p_to_tcb->current_prio < dispatch_prio) {
1ffe2f6c:	f894 e001 	ldrb.w	lr, [r4, #1]
1ffe2f70:	45e6      	cmp	lr, ip
1ffe2f72:	d201      	bcs.n	1ffe2f78 <osEE_scheduler_task_set_running+0x28>
      p_to_tcb->current_prio = dispatch_prio;
1ffe2f74:	f884 c001 	strb.w	ip, [r4, #1]
    }
  }

  p_ccb->p_curr                 = p_tdb;
1ffe2f78:	6019      	str	r1, [r3, #0]

  /* Touch unused parameters */
  (void)p_kdb;
  if (p_sn == NULL) {
1ffe2f7a:	b162      	cbz	r2, 1ffe2f96 <osEE_scheduler_task_set_running+0x46>
    osEE_lock_core(p_cdb);
    /* Alloc the SN for the new Running TASK */
    p_ccb->p_stk_sn             = osEE_sn_alloc(&p_ccb->p_free_sn);
    osEE_unlock_core(p_cdb);
  } else {
    p_ccb->p_stk_sn             = p_sn;
1ffe2f7c:	60da      	str	r2, [r3, #12]
  }

  /* In Scheduler partitioned the TASK are stacked */
  p_ccb->p_stk_sn->p_tdb        = p_tdb;
1ffe2f7e:	68da      	ldr	r2, [r3, #12]
1ffe2f80:	6051      	str	r1, [r2, #4]
  p_ccb->p_stk_sn->p_next       = p_preempted_sn;
1ffe2f82:	68db      	ldr	r3, [r3, #12]
1ffe2f84:	601d      	str	r5, [r3, #0]

  osEE_change_context_from_running(p_preempted, p_tdb);
1ffe2f86:	f000 f839 	bl	1ffe2ffc <osEE_change_context_from_running>
}
1ffe2f8a:	bd38      	pop	{r3, r4, r5, pc}
    p_preempted_tcb->status  = OSEE_TASK_READY_STACKED;
1ffe2f8c:	f04f 0c02 	mov.w	ip, #2
1ffe2f90:	f884 c002 	strb.w	ip, [r4, #2]
1ffe2f94:	e7e7      	b.n	1ffe2f66 <osEE_scheduler_task_set_running+0x16>
  p_sn_allocated          = (*pp_first);
1ffe2f96:	689a      	ldr	r2, [r3, #8]
  (*pp_first)             = p_sn_allocated->p_next;
1ffe2f98:	6814      	ldr	r4, [r2, #0]
1ffe2f9a:	609c      	str	r4, [r3, #8]
  p_sn_allocated->p_next  = NULL;
1ffe2f9c:	2400      	movs	r4, #0
1ffe2f9e:	6014      	str	r4, [r2, #0]
    p_ccb->p_stk_sn             = osEE_sn_alloc(&p_ccb->p_free_sn);
1ffe2fa0:	60da      	str	r2, [r3, #12]
    osEE_unlock_core(p_cdb);
1ffe2fa2:	e7ec      	b.n	1ffe2f7e <osEE_scheduler_task_set_running+0x2e>
1ffe2fa4:	1ffe3220 	.word	0x1ffe3220

1ffe2fa8 <osEE_counter_increment>:
FUNC(void, OS_CODE)
  osEE_counter_increment
(
  P2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_DATA) p_counter_db
)
{
1ffe2fa8:	b410      	push	{r4}
  CONSTP2VAR(OsEE_CounterCB, AUTOMATIC, OS_APPL_DATA)
    p_counter_cb = p_counter_db->p_counter_cb;
1ffe2faa:	6804      	ldr	r4, [r0, #0]
    CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)
      p_cdb = osEE_get_curr_core();

    /* Counter Increment can be done outside lock critical section, since only
       a core is allowed to do that */
    if (p_counter_cb->value >= p_counter_db->info.maxallowedvalue) {
1ffe2fac:	6861      	ldr	r1, [r4, #4]
1ffe2fae:	6843      	ldr	r3, [r0, #4]
1ffe2fb0:	4299      	cmp	r1, r3
1ffe2fb2:	d309      	bcc.n	1ffe2fc8 <osEE_counter_increment+0x20>
      counter_value       = 0U;
      p_counter_cb->value = 0U;
1ffe2fb4:	2100      	movs	r1, #0
1ffe2fb6:	6061      	str	r1, [r4, #4]
            to not have nested critical sections.
            To handle possible races due to cycling triggers a state
            protocol have been implemented. */
    osEE_lock_core(p_cdb);

    p_triggered_db = p_counter_cb->trigger_queue;
1ffe2fb8:	6822      	ldr	r2, [r4, #0]

    if (p_triggered_db != NULL) {
1ffe2fba:	b11a      	cbz	r2, 1ffe2fc4 <osEE_counter_increment+0x1c>
      P2CONST(OsEE_TriggerCB, AUTOMATIC, OS_APPL_DATA)
        p_triggered_cb = p_triggered_db->p_trigger_cb;
1ffe2fbc:	6813      	ldr	r3, [r2, #0]

      if (p_triggered_cb->when == counter_value) {
1ffe2fbe:	685b      	ldr	r3, [r3, #4]
1ffe2fc0:	428b      	cmp	r3, r1
1ffe2fc2:	d004      	beq.n	1ffe2fce <osEE_counter_increment+0x26>
      }
    } else {
      osEE_unlock_core(p_cdb);
    }
  }
}
1ffe2fc4:	bc10      	pop	{r4}
1ffe2fc6:	4770      	bx	lr
      ++p_counter_cb->value;
1ffe2fc8:	3101      	adds	r1, #1
1ffe2fca:	6061      	str	r1, [r4, #4]
      counter_value = p_counter_cb->value;
1ffe2fcc:	e7f4      	b.n	1ffe2fb8 <osEE_counter_increment+0x10>
          p_current = p_triggered_db;
1ffe2fce:	4613      	mov	r3, r2
            p_current_cb = p_current->p_trigger_cb;
1ffe2fd0:	6818      	ldr	r0, [r3, #0]
          p_current_cb->status = OSEE_TRIGGER_EXPIRED;
1ffe2fd2:	f04f 0c03 	mov.w	ip, #3
1ffe2fd6:	f880 c008 	strb.w	ip, [r0, #8]
          p_current = p_current_cb->p_next;
1ffe2fda:	469c      	mov	ip, r3
1ffe2fdc:	6803      	ldr	r3, [r0, #0]
          (p_current->p_trigger_cb->when == counter_value));
1ffe2fde:	b11b      	cbz	r3, 1ffe2fe8 <osEE_counter_increment+0x40>
1ffe2fe0:	6818      	ldr	r0, [r3, #0]
1ffe2fe2:	6840      	ldr	r0, [r0, #4]
        } while ((p_current != NULL) &&
1ffe2fe4:	4288      	cmp	r0, r1
1ffe2fe6:	d0f3      	beq.n	1ffe2fd0 <osEE_counter_increment+0x28>
        p_previous->p_trigger_cb->p_next = NULL;
1ffe2fe8:	f8dc 1000 	ldr.w	r1, [ip]
1ffe2fec:	2000      	movs	r0, #0
1ffe2fee:	6008      	str	r0, [r1, #0]
        p_counter_cb->trigger_queue = p_current;
1ffe2ff0:	6023      	str	r3, [r4, #0]
          p_triggered_db = p_triggered_db->p_trigger_cb->p_next;
1ffe2ff2:	6813      	ldr	r3, [r2, #0]
1ffe2ff4:	681a      	ldr	r2, [r3, #0]
        } while (p_triggered_db != NULL);
1ffe2ff6:	2a00      	cmp	r2, #0
1ffe2ff8:	d1fb      	bne.n	1ffe2ff2 <osEE_counter_increment+0x4a>
1ffe2ffa:	e7e3      	b.n	1ffe2fc4 <osEE_counter_increment+0x1c>

1ffe2ffc <osEE_change_context_from_running>:
  osEE_change_context_from_running
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_from,
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_to
)
{
1ffe2ffc:	b508      	push	{r3, lr}
1ffe2ffe:	4603      	mov	r3, r0
1ffe3000:	4608      	mov	r0, r1
  CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_to_tcb  = p_to->p_tcb;
1ffe3002:	688a      	ldr	r2, [r1, #8]

  if (p_to_tcb->status == OSEE_TASK_READY_STACKED) {
1ffe3004:	7892      	ldrb	r2, [r2, #2]
1ffe3006:	2a02      	cmp	r2, #2
1ffe3008:	d004      	beq.n	1ffe3014 <osEE_change_context_from_running+0x18>
    osEE_hal_save_ctx_and_restore_ctx(p_to, p_to->hdb.p_scb,
      p_from->hdb.p_scb);
  } else {
    osEE_hal_save_ctx_and_ready2stacked(p_to, p_to->hdb.p_scb,
1ffe300a:	685a      	ldr	r2, [r3, #4]
1ffe300c:	6849      	ldr	r1, [r1, #4]
1ffe300e:	f7fd fac9 	bl	1ffe05a4 <osEE_hal_save_ctx_and_ready2stacked>
      p_from->hdb.p_scb);
  }
}
1ffe3012:	bd08      	pop	{r3, pc}
    osEE_hal_save_ctx_and_restore_ctx(p_to, p_to->hdb.p_scb,
1ffe3014:	685a      	ldr	r2, [r3, #4]
1ffe3016:	6849      	ldr	r1, [r1, #4]
1ffe3018:	f7fd faa0 	bl	1ffe055c <osEE_hal_save_ctx_and_restore_ctx>
1ffe301c:	e7f9      	b.n	1ffe3012 <osEE_change_context_from_running+0x16>

1ffe301e <osEE_change_context_from_task_end>:
  osEE_change_context_from_task_end
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_from,
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_to
)
{
1ffe301e:	b508      	push	{r3, lr}
1ffe3020:	4608      	mov	r0, r1
  CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_to_tcb  = p_to->p_tcb;
1ffe3022:	688b      	ldr	r3, [r1, #8]

  if (p_to_tcb->status == OSEE_TASK_READY_STACKED) {
1ffe3024:	789b      	ldrb	r3, [r3, #2]
1ffe3026:	2b02      	cmp	r3, #2
1ffe3028:	d003      	beq.n	1ffe3032 <osEE_change_context_from_task_end+0x14>
    osEE_hal_restore_ctx(p_to, p_to->hdb.p_scb);
  } else {
    osEE_hal_ready2stacked(p_to, p_to->hdb.p_scb);
1ffe302a:	6849      	ldr	r1, [r1, #4]
1ffe302c:	f7fd fab4 	bl	1ffe0598 <osEE_hal_ready2stacked>
  }
  /* STD Implementation do not use p_from here, but I cannot assure
     that any implementation won't do that */
  (void)p_from;
}
1ffe3030:	bd08      	pop	{r3, pc}
    osEE_hal_restore_ctx(p_to, p_to->hdb.p_scb);
1ffe3032:	6849      	ldr	r1, [r1, #4]
1ffe3034:	f7fd faa0 	bl	1ffe0578 <osEE_hal_restore_ctx>
1ffe3038:	e7fa      	b.n	1ffe3030 <osEE_change_context_from_task_end+0x12>

1ffe303a <osEE_idle_task_terminate>:
FUNC(void, OS_CODE)
  osEE_idle_task_terminate
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_idle_tdb
)
{
1ffe303a:	b510      	push	{r4, lr}
  P2VAR(OsEE_CTX, AUTOMATIC, OS_APPL_DATA)      p_ctx;

  CONSTP2VAR(OsEE_HDB, AUTOMATIC, OS_APPL_DATA) p_idle_hdb  = &p_idle_tdb->hdb;
  CONSTP2VAR(OsEE_SDB, AUTOMATIC, OS_APPL_DATA) p_sdb       = p_idle_hdb->p_sdb;
1ffe303c:	6803      	ldr	r3, [r0, #0]
  CONSTP2VAR(OsEE_SCB, AUTOMATIC, OS_APPL_DATA) p_scb       = p_idle_hdb->p_scb;
1ffe303e:	6841      	ldr	r1, [r0, #4]
  CONSTP2CONST(OsEE_CTX, AUTOMATIC, OS_APPL_DATA) p_bos     = p_sdb->p_bos;
1ffe3040:	681c      	ldr	r4, [r3, #0]
  P2VAR(OsEE_CTX, AUTOMATIC, OS_APPL_DATA)      p_tos       = p_scb->p_tos;
1ffe3042:	680b      	ldr	r3, [r1, #0]

  do {
    p_ctx = p_tos;
    p_tos = p_tos->p_ctx;
1ffe3044:	461a      	mov	r2, r3
1ffe3046:	681b      	ldr	r3, [r3, #0]
  } while ((p_tos != NULL) && (p_tos != p_bos));
1ffe3048:	b10b      	cbz	r3, 1ffe304e <osEE_idle_task_terminate+0x14>
1ffe304a:	429c      	cmp	r4, r3
1ffe304c:	d1fa      	bne.n	1ffe3044 <osEE_idle_task_terminate+0xa>

  /* Unwind the stack until the last context*/
  p_scb->p_tos = p_ctx;
1ffe304e:	600a      	str	r2, [r1, #0]

  osEE_hal_restore_ctx(p_idle_tdb, p_scb);
1ffe3050:	f7fd fa92 	bl	1ffe0578 <osEE_hal_restore_ctx>
}
1ffe3054:	bd10      	pop	{r4, pc}

1ffe3056 <osEE_cortex_m_system_init>:

/*
 * System Initialization.
 */
FUNC(void, OS_CODE) osEE_cortex_m_system_init(void)
{
1ffe3056:	b508      	push	{r3, lr}
	/* 
	 * Set the priority of PendSV to the minimum one
	 * PendSV is the software interrupt used for context switch
	 */
	osEE_set_switch_context_pri();
1ffe3058:	f7fd fac6 	bl	1ffe05e8 <osEE_set_switch_context_pri>
#endif	/* OSEE_CORTEX_M_SYSTICK_ISR */

	/* 
	 * MCU System Initialization.
	 */
	osEE_cortex_m_mcu_system_init();
1ffe305c:	f000 f830 	bl	1ffe30c0 <osEE_cortex_m_mcu_system_init>

}	/* osEE_cortex_m_system_init() */
1ffe3060:	bd08      	pop	{r3, pc}
	...

1ffe3064 <osEE_cortex_m_scheduler_task_end>:
FUNC(void, OS_CODE)
  osEE_cortex_m_scheduler_task_end
(
  void
)
{
1ffe3064:	b510      	push	{r4, lr}
1ffe3066:	b082      	sub	sp, #8

  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)  p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb = p_cdb->p_ccb;
1ffe3068:	4b13      	ldr	r3, [pc, #76]	; (1ffe30b8 <osEE_cortex_m_scheduler_task_end+0x54>)
1ffe306a:	681b      	ldr	r3, [r3, #0]
  CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
    p_orig_task_sn = p_ccb->p_stk_sn->p_next;
1ffe306c:	68db      	ldr	r3, [r3, #12]
1ffe306e:	681b      	ldr	r3, [r3, #0]
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_orig_tdb;
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_to;
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_from;

  /* p_orig_task_sn == NULL means I preempted idle task */
  if (p_orig_task_sn != NULL) {
1ffe3070:	b193      	cbz	r3, 1ffe3098 <osEE_cortex_m_scheduler_task_end+0x34>
    p_orig_tdb = p_orig_task_sn->p_tdb;
1ffe3072:	685c      	ldr	r4, [r3, #4]
  } else {
    p_orig_tdb = p_cdb->p_idle_task;
  }

  p_to = osEE_scheduler_task_terminated(osEE_get_kernel(), &p_from);
1ffe3074:	a901      	add	r1, sp, #4
1ffe3076:	4811      	ldr	r0, [pc, #68]	; (1ffe30bc <osEE_cortex_m_scheduler_task_end+0x58>)
1ffe3078:	f7ff ff18 	bl	1ffe2eac <osEE_scheduler_task_terminated>
1ffe307c:	4603      	mov	r3, r0

  if (p_from->task_type != OSEE_TASK_TYPE_ISR2) {
1ffe307e:	9801      	ldr	r0, [sp, #4]
1ffe3080:	7c02      	ldrb	r2, [r0, #16]
1ffe3082:	2a02      	cmp	r2, #2
1ffe3084:	d10b      	bne.n	1ffe309e <osEE_cortex_m_scheduler_task_end+0x3a>
    osEE_change_context_from_task_end(p_from, p_to);
  } else {
    /* With these CTX restore I'll jump back on ISR2 wrapper on preempted stack
       (osEE_cortex_m_isr2_stub) after osEE_activate_isr2(t) call */
    if (p_orig_tdb == p_to) {
1ffe3086:	429c      	cmp	r4, r3
1ffe3088:	d00e      	beq.n	1ffe30a8 <osEE_cortex_m_scheduler_task_end+0x44>
      /* Restore old TASK, set it running and do not PendSV */
      p_to->p_tcb->status = OSEE_TASK_RUNNING;
      osEE_hal_restore_ctx(p_to, p_to->hdb.p_scb);
    } else {
      /* Set PendSV */
      osEE_cortex_m_trigger_pend_sv();
1ffe308a:	f7fd fabb 	bl	1ffe0604 <osEE_cortex_m_trigger_pend_sv>
      osEE_cortex_m_restore_ctx(p_orig_tdb, p_orig_tdb->hdb.p_scb);
1ffe308e:	6861      	ldr	r1, [r4, #4]
1ffe3090:	4620      	mov	r0, r4
1ffe3092:	f7fd fa99 	bl	1ffe05c8 <osEE_cortex_m_restore_ctx>
    }
  }

}
1ffe3096:	e005      	b.n	1ffe30a4 <osEE_cortex_m_scheduler_task_end+0x40>
    p_orig_tdb = p_cdb->p_idle_task;
1ffe3098:	4b07      	ldr	r3, [pc, #28]	; (1ffe30b8 <osEE_cortex_m_scheduler_task_end+0x54>)
1ffe309a:	689c      	ldr	r4, [r3, #8]
1ffe309c:	e7ea      	b.n	1ffe3074 <osEE_cortex_m_scheduler_task_end+0x10>
    osEE_change_context_from_task_end(p_from, p_to);
1ffe309e:	4619      	mov	r1, r3
1ffe30a0:	f7ff ffbd 	bl	1ffe301e <osEE_change_context_from_task_end>
}
1ffe30a4:	b002      	add	sp, #8
1ffe30a6:	bd10      	pop	{r4, pc}
      p_to->p_tcb->status = OSEE_TASK_RUNNING;
1ffe30a8:	689a      	ldr	r2, [r3, #8]
1ffe30aa:	2104      	movs	r1, #4
1ffe30ac:	7091      	strb	r1, [r2, #2]
      osEE_hal_restore_ctx(p_to, p_to->hdb.p_scb);
1ffe30ae:	6859      	ldr	r1, [r3, #4]
1ffe30b0:	4618      	mov	r0, r3
1ffe30b2:	f7fd fa61 	bl	1ffe0578 <osEE_hal_restore_ctx>
1ffe30b6:	e7f5      	b.n	1ffe30a4 <osEE_cortex_m_scheduler_task_end+0x40>
1ffe30b8:	1ffe3220 	.word	0x1ffe3220
1ffe30bc:	1ffe3248 	.word	0x1ffe3248

1ffe30c0 <osEE_cortex_m_mcu_system_init>:
#define	OSEE_CORTEX_M_FTM0_OVF_RELOAD_NUM		(		\
	OSEE_CORTEX_M_FTM0_OVF_RELOAD_ISR_ID -				\
	OSEE_CORTEX_M_OVERALL_EXC_NUM					\
)
#ifdef	OSEE_CORTEX_M_FTM0_OVF_RELOAD_ISR_PRI
	OSEE_CORTEX_M_NVIC_SET_PRI(
1ffe30c0:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
1ffe30c4:	f8d3 2468 	ldr.w	r2, [r3, #1128]	; 0x468
1ffe30c8:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
1ffe30cc:	f8c3 2468 	str.w	r2, [r3, #1128]	; 0x468
1ffe30d0:	f8d3 2468 	ldr.w	r2, [r3, #1128]	; 0x468
1ffe30d4:	f042 02f0 	orr.w	r2, r2, #240	; 0xf0
1ffe30d8:	f8c3 2468 	str.w	r2, [r3, #1128]	; 0x468
		OSEE_CORTEX_M_FTM0_OVF_RELOAD_NUM,
		OSEE_CORTEX_M_FTM0_OVF_RELOAD_ISR_PRI
	);
#endif	/* OSEE_CORTEX_M_FTM0_OVF_RELOAD_ISR_PRI */
	OSEE_CORTEX_M_NVIC_INT_ENABLE(OSEE_CORTEX_M_FTM0_OVF_RELOAD_NUM);
1ffe30dc:	f8d3 210c 	ldr.w	r2, [r3, #268]	; 0x10c
1ffe30e0:	f442 7280 	orr.w	r2, r2, #256	; 0x100
1ffe30e4:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
#endif	/* OSEE_CORTEX_M_FTM7_OVF_RELOAD_ISR_PRI */
	OSEE_CORTEX_M_NVIC_INT_ENABLE(OSEE_CORTEX_M_FTM7_OVF_RELOAD_NUM);
#endif	/* OSEE_CORTEX_M_FTM7_OVF_RELOAD_ISR */
#endif	/* OS_EE_ARCH_CORTEX_M_S32K148 */

}	/* osEE_cortex_m_mcu_system_init() */
1ffe30e8:	4770      	bx	lr

1ffe30ea <FTM0_Ovf_Reload_IRQHandler>:
 */
#if	(								\
		defined(OSEE_CORTEX_M_FTM0_OVF_RELOAD_ISR_TID) &&	\
		(OSEE_CORTEX_M_FTM0_OVF_RELOAD_ISR_CAT == 2U)		\
)
OSEE_CORTEX_M_ISR2_DEFINITION(
1ffe30ea:	b508      	push	{r3, lr}
1ffe30ec:	2001      	movs	r0, #1
1ffe30ee:	f000 f823 	bl	1ffe3138 <osEE_cortex_m_isr2_stub>
1ffe30f2:	bd08      	pop	{r3, pc}

1ffe30f4 <osEE_cortex_m_change_context_from_task_end>:
#include "ee_internal.h"

FUNC(void, OS_CODE) osEE_cortex_m_change_context_from_task_end(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_orig_tdb
)
{
1ffe30f4:	b510      	push	{r4, lr}
  OSEE_GET_IPL(flags);
1ffe30f6:	f3ef 8411 	mrs	r4, BASEPRI
  flags >>= OSEE_CORTEX_M_PRIO_SH_BITS;
1ffe30fa:	0923      	lsrs	r3, r4, #4
  if ( (flags == 0x00U) || (flags > OSEE_ISR2_MAX_HW_PRIO) ) {
1ffe30fc:	3b01      	subs	r3, #1
1ffe30fe:	2b07      	cmp	r3, #7
1ffe3100:	d902      	bls.n	1ffe3108 <osEE_cortex_m_change_context_from_task_end+0x14>
    OSEE_SET_IPL(OSEE_ISR2_MAX_HW_PRIO << OSEE_CORTEX_M_PRIO_SH_BITS);
1ffe3102:	2380      	movs	r3, #128	; 0x80
1ffe3104:	f383 8811 	msr	BASEPRI, r3
  OSEE_SEI();
1ffe3108:	b662      	cpsie	i

#if	1	/* [GS]: To Be Checked. */
  osEE_hal_enableIRQ();
#endif

  if (p_orig_tdb->p_tcb->status == OSEE_TASK_READY) {
1ffe310a:	6883      	ldr	r3, [r0, #8]
1ffe310c:	789b      	ldrb	r3, [r3, #2]
1ffe310e:	2b01      	cmp	r3, #1
1ffe3110:	d009      	beq.n	1ffe3126 <osEE_cortex_m_change_context_from_task_end+0x32>
    osEE_change_context_from_task_end(
      p_orig_tdb, osEE_get_curr_core()->p_ccb->p_curr
    );
  } else {
    osEE_change_context_from_running(
      p_orig_tdb, osEE_get_curr_core()->p_ccb->p_curr
1ffe3112:	4b08      	ldr	r3, [pc, #32]	; (1ffe3134 <osEE_cortex_m_change_context_from_task_end+0x40>)
1ffe3114:	681b      	ldr	r3, [r3, #0]
    osEE_change_context_from_running(
1ffe3116:	6819      	ldr	r1, [r3, #0]
1ffe3118:	f7ff ff70 	bl	1ffe2ffc <osEE_change_context_from_running>
  OSEE_SET_IPL(flag << OSEE_CORTEX_M_PRIO_SH_BITS);
1ffe311c:	f024 040f 	bic.w	r4, r4, #15
1ffe3120:	f384 8811 	msr	BASEPRI, r4
    );
  }

  osEE_hal_end_nested_primitive(f);
}
1ffe3124:	bd10      	pop	{r4, pc}
      p_orig_tdb, osEE_get_curr_core()->p_ccb->p_curr
1ffe3126:	4b03      	ldr	r3, [pc, #12]	; (1ffe3134 <osEE_cortex_m_change_context_from_task_end+0x40>)
1ffe3128:	681b      	ldr	r3, [r3, #0]
    osEE_change_context_from_task_end(
1ffe312a:	6819      	ldr	r1, [r3, #0]
1ffe312c:	f7ff ff77 	bl	1ffe301e <osEE_change_context_from_task_end>
1ffe3130:	e7f4      	b.n	1ffe311c <osEE_cortex_m_change_context_from_task_end+0x28>
1ffe3132:	bf00      	nop
1ffe3134:	1ffe3220 	.word	0x1ffe3220

1ffe3138 <osEE_cortex_m_isr2_stub>:
 */
FUNC_P2VAR(OsEE_TDB, OS_APPL_CONST, OS_CODE) OSEE_COMPILER_KEEP
osEE_cortex_m_isr2_stub(
  VAR(TaskType, AUTOMATIC)	t
)
{
1ffe3138:	b538      	push	{r3, r4, r5, lr}
  CONSTP2VAR(OsEE_TDB, OS_APPL_CONST, OS_CODE)
    p_orig_tdb = osEE_get_curr_core()->p_ccb->p_curr;
1ffe313a:	4b0a      	ldr	r3, [pc, #40]	; (1ffe3164 <osEE_cortex_m_isr2_stub+0x2c>)
1ffe313c:	681b      	ldr	r3, [r3, #0]
1ffe313e:	681d      	ldr	r5, [r3, #0]
  OSEE_GET_IPL(flags);
1ffe3140:	f3ef 8411 	mrs	r4, BASEPRI
  flags >>= OSEE_CORTEX_M_PRIO_SH_BITS;
1ffe3144:	0923      	lsrs	r3, r4, #4
  if ( (flags == 0x00U) || (flags > OSEE_ISR2_MAX_HW_PRIO) ) {
1ffe3146:	3b01      	subs	r3, #1
1ffe3148:	2b07      	cmp	r3, #7
1ffe314a:	d902      	bls.n	1ffe3152 <osEE_cortex_m_isr2_stub+0x1a>
    OSEE_SET_IPL(OSEE_ISR2_MAX_HW_PRIO << OSEE_CORTEX_M_PRIO_SH_BITS);
1ffe314c:	2380      	movs	r3, #128	; 0x80
1ffe314e:	f383 8811 	msr	BASEPRI, r3

  OsEE_reg f = osEE_hal_begin_nested_primitive();

  /* Activate ISR2 */
  osEE_activate_isr2(t);
1ffe3152:	f7ff fe33 	bl	1ffe2dbc <osEE_activate_isr2>
  OSEE_SET_IPL(flag << OSEE_CORTEX_M_PRIO_SH_BITS);
1ffe3156:	f024 040f 	bic.w	r4, r4, #15
1ffe315a:	f384 8811 	msr	BASEPRI, r4

  osEE_hal_end_nested_primitive(f);

  return p_orig_tdb;
}	/* osEE_cortex_m_isr2_stub() */
1ffe315e:	4628      	mov	r0, r5
1ffe3160:	bd38      	pop	{r3, r4, r5, pc}
1ffe3162:	bf00      	nop
1ffe3164:	1ffe3220 	.word	0x1ffe3220
1ffe3168:	0d525349 	.word	0x0d525349
1ffe316c:	0000000a 	.word	0x0000000a
1ffe3170:	74736554 	.word	0x74736554
1ffe3174:	69614620 	.word	0x69614620
1ffe3178:	2164656c 	.word	0x2164656c
1ffe317c:	202c2121 	.word	0x202c2121
1ffe3180:	656e696c 	.word	0x656e696c
1ffe3184:	3836313a 	.word	0x3836313a
1ffe3188:	000a0d20 	.word	0x000a0d20
1ffe318c:	656c6449 	.word	0x656c6449
1ffe3190:	00000a0d 	.word	0x00000a0d
1ffe3194:	74736554 	.word	0x74736554
1ffe3198:	69614620 	.word	0x69614620
1ffe319c:	2164656c 	.word	0x2164656c
1ffe31a0:	202c2121 	.word	0x202c2121
1ffe31a4:	656e696c 	.word	0x656e696c
1ffe31a8:	3133323a 	.word	0x3133323a
1ffe31ac:	000a0d20 	.word	0x000a0d20
1ffe31b0:	656c6552 	.word	0x656c6552
1ffe31b4:	20657361 	.word	0x20657361
1ffe31b8:	4b534154 	.word	0x4b534154
1ffe31bc:	000a0d31 	.word	0x000a0d31
1ffe31c0:	74736554 	.word	0x74736554
1ffe31c4:	69614620 	.word	0x69614620
1ffe31c8:	2164656c 	.word	0x2164656c
1ffe31cc:	202c2121 	.word	0x202c2121
1ffe31d0:	656e696c 	.word	0x656e696c
1ffe31d4:	3534323a 	.word	0x3534323a
1ffe31d8:	000a0d20 	.word	0x000a0d20
1ffe31dc:	4b534154 	.word	0x4b534154
1ffe31e0:	000a0d32 	.word	0x000a0d32
1ffe31e4:	74736554 	.word	0x74736554
1ffe31e8:	69614620 	.word	0x69614620
1ffe31ec:	2164656c 	.word	0x2164656c
1ffe31f0:	202c2121 	.word	0x202c2121
1ffe31f4:	656e696c 	.word	0x656e696c
1ffe31f8:	3236323a 	.word	0x3236323a
1ffe31fc:	000a0d20 	.word	0x000a0d20
1ffe3200:	4b534154 	.word	0x4b534154
1ffe3204:	000a0d33 	.word	0x000a0d33
1ffe3208:	4b534154 	.word	0x4b534154
1ffe320c:	000a0d34 	.word	0x000a0d34
1ffe3210:	4b534154 	.word	0x4b534154
1ffe3214:	000a0d35 	.word	0x000a0d35

1ffe3218 <osEE_autostart_tdb_array>:
1ffe3218:	1ffe3374 00000002                       t3......

1ffe3220 <osEE_cdb_var>:
1ffe3220:	20000000 1ffe06bd 1ffe3338 1ffe3238     ... ....83..82..
1ffe3230:	1ffe3218 00000001                       .2......

1ffe3238 <osEE_counter_db_array>:
1ffe3238:	20000200 7fffffff 00000001              ... ........

1ffe3244 <osEE_counter_db_ptr_array>:
1ffe3244:	1ffe3238                                82..

1ffe3248 <osEE_kdb_var>:
1ffe3248:	20000208 1ffe3354 00000008 1ffe3244     ... T3......D2..
1ffe3258:	00000001                                ....

1ffe325c <osEE_sdb_array>:
1ffe325c:	20000210 00000200 20000418 00000200     ... ....... ....
1ffe326c:	2001ec00 00000400                       ... ....

1ffe3274 <osEE_tdb_array>:
1ffe3274:	1ffe326c 20000028 20000064 00000000     l2..(.. d.. ....
1ffe3284:	00000002 1ffe2985 0001ff81 1ffe326c     .....)......l2..
1ffe3294:	20000028 20000074 00000001 00000002     (.. t.. ........
1ffe32a4:	1ffe0671 00018080 1ffe325c 20000020     q.......\2.. .. 
1ffe32b4:	20000084 00000002 00000000 1ffe0741     ... ........A...
1ffe32c4:	00010101 1ffe3264 20000024 20000094     ....d2..$.. ... 
1ffe32d4:	00000003 00000001 1ffe07e1 00010202     ................
1ffe32e4:	1ffe326c 20000028 200000a4 00000004     l2..(.. ... ....
1ffe32f4:	00000000 1ffe084d 00010101 1ffe326c     ....M.......l2..
1ffe3304:	20000028 200000b4 00000005 00000000     (.. ... ........
1ffe3314:	1ffe0879 00010101 1ffe326c 20000028     y.......l2..(.. 
1ffe3324:	200000c4 00000006 00000000 1ffe0899     ... ............
1ffe3334:	00010101 1ffe326c 20000028 200000d4     ....l2..(.. ... 
1ffe3344:	00000007 00000003 1ffe2c65 00010000     ........e,......

1ffe3354 <osEE_tdb_ptr_array>:
1ffe3354:	1ffe3274 1ffe3290 1ffe32ac 1ffe32c8     t2...2...2...2..
1ffe3364:	1ffe32e4 1ffe3300 1ffe331c 1ffe3338     .2...3...3..83..

1ffe3374 <osEE_tdb_ptr_autostart_OSDEFAULTAPPMODE>:
1ffe3374:	1ffe32ac 1ffe3300                       .2...3..

1ffe337c <clockMan_InitConfig>:
1ffe337c:	01010101 00000100 00000101 00010001     ................
1ffe338c:	007a1200 02000100 00000101 00000100     ..z.............
1ffe339c:	000c0000 00000101 00000001 00000000     ................
1ffe33ac:	00000001 01010103 00030300 01030201     ................
1ffe33bc:	01000600 00000001 01000001 00000001     ................
1ffe33cc:	00000001 00000000 00000000 00000000     ................
	...
1ffe33fc:	01010101 01010101 00000000 00000003     ................
1ffe340c:	1ffe34a8 00000101                       .4......

1ffe3414 <flexTimer1_InitConfig>:
	...
1ffe341c:	01000000 00010706 00000001              ............

1ffe3428 <g_clockManCallbacksArr>:
1ffe3428:	00000000                                ....

1ffe342c <g_clockManConfigsArr>:
1ffe342c:	1ffe337c                                |3..

1ffe3430 <g_pin_mux_InitConfigArr>:
1ffe3430:	4004b000 0000000c 01000000 00000000     ...@............
1ffe3440:	400ff080 00000000 4004b000 0000000d     ...@.......@....
1ffe3450:	01000000 00000000 400ff080 00000000     ...........@....
1ffe3460:	4004d000 00000015 01000000 00000000     ...@............
1ffe3470:	400ff100 00000001 4004d000 00000016     ...@.......@....
1ffe3480:	01000000 00000000 400ff100 00000001     ...........@....
1ffe3490:	4004d000 00000017 01000000 00000000     ...@............
1ffe34a0:	400ff100 00000001                       ...@....

1ffe34a8 <peripheralClockConfig>:
1ffe34a8:	00000133 00013500 01430000 00000000     3....5....C.....

1ffe34b8 <clockNameMappings>:
	...
1ffe3510:	00730000 00210032 00490061 004b004a     ..s.2.!.a.I.J.K.
1ffe3520:	004d004c 0054003d 00000055 00250024     L.M.=.T.U...$.%.
1ffe3530:	0036002b 00000031 00000020 00380079     +.6.1... ...y.8.
1ffe3540:	003a0039 006e0026 0070006f 00000071     9.:.&.n.o.p.q...
1ffe3550:	0027003b 0066005a 00370067 002d002c     ;.'.Z.f.g.7.,.-.
1ffe3560:	0040002e 006b006a 0076006c 00000000     ..@.j.k.l.v.....

1ffe3570 <maxSysClksInHSRUN.4>:
	...
1ffe357c:	06acfc00 03567e00 01ab3f00 06acfc00     .....~V..?......
1ffe358c:	03567e00 01ab3f00 06acfc00 03567e00     .~V..?.......~V.
1ffe359c:	01ab3f00 00000000 00000000 00000000     .?..............
	...
1ffe35b8:	06acfc00 03567e00 01ab3f00              .....~V..?..

1ffe35c4 <maxSysClksInRUN.6>:
	...
1ffe35d0:	04c4b400 02dc6c00 0196f3b0 04c4b400     .....l..........
1ffe35e0:	02dc6c00 0196f3b0 04c4b400 02dc6c00     .l...........l..
1ffe35f0:	0196f3b0 00000000 00000000 00000000     ................
	...
1ffe360c:	04c4b400 02625a00 0196f3b0              .....Zb.....

1ffe3618 <maxSysClksInVLPR.5>:
	...
1ffe3624:	003d0900 003d0900 000f4240 003d0900     ..=...=.@B....=.
1ffe3634:	003d0900 000f4240 003d0900 003d0900     ..=.@B....=...=.
1ffe3644:	000f4240 00000000 00000000 00000000     @B..............
	...
1ffe3660:	003d0900 003d0900 000f4240              ..=...=.@B..

1ffe366c <peripheralFeaturesList>:
	...
1ffe368c:	41000000 41414141 00000000 20202000     ...AAAAA.....   
1ffe369c:	20202020 20202020 40400020 00404040              .@@@@@.
1ffe36ac:	484e0080 48484848 00484848 30303030     ..NHHHHHHHH.0000
1ffe36bc:	30303030 30303630 00002030              000006000 ..

1ffe36c8 <g_ftmBase>:
1ffe36c8:	40038000 40039000 4003a000 40026000     ...@...@...@.`.@
1ffe36d8:	4006e000 4006f000 40070000 40071000     ...@...@...@...@

1ffe36e8 <g_ftmExtClockSel>:
1ffe36e8:	46454443 4a494847                       CDEFGHIJ

1ffe36f0 <g_ftmOverflowIrqId>:
1ffe36f0:	006e0068 007a0074 00860080 0092008c     h.n.t.z.........

1ffe3700 <_init>:
1ffe3700:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
1ffe3702:	bf00      	nop

1ffe3704 <_fini>:
1ffe3704:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
1ffe3706:	bf00      	nop
